// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/data_sharing/public/protocol/data_sharing_sdk.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include "components/data_sharing/public/protocol/group_data.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto {
    static const uint32_t offsets[];
};
namespace data_sharing_pb {
class AddAccessTokenParams;
struct AddAccessTokenParamsDefaultTypeInternal;
extern AddAccessTokenParamsDefaultTypeInternal _AddAccessTokenParams_default_instance_;
class AddAccessTokenResult;
struct AddAccessTokenResultDefaultTypeInternal;
extern AddAccessTokenResultDefaultTypeInternal _AddAccessTokenResult_default_instance_;
class AddMemberParams;
struct AddMemberParamsDefaultTypeInternal;
extern AddMemberParamsDefaultTypeInternal _AddMemberParams_default_instance_;
class CreateGroupParams;
struct CreateGroupParamsDefaultTypeInternal;
extern CreateGroupParamsDefaultTypeInternal _CreateGroupParams_default_instance_;
class CreateGroupResult;
struct CreateGroupResultDefaultTypeInternal;
extern CreateGroupResultDefaultTypeInternal _CreateGroupResult_default_instance_;
class DeleteGroupParams;
struct DeleteGroupParamsDefaultTypeInternal;
extern DeleteGroupParamsDefaultTypeInternal _DeleteGroupParams_default_instance_;
class LeaveGroupParams;
struct LeaveGroupParamsDefaultTypeInternal;
extern LeaveGroupParamsDefaultTypeInternal _LeaveGroupParams_default_instance_;
class LookupGaiaIdByEmailParams;
struct LookupGaiaIdByEmailParamsDefaultTypeInternal;
extern LookupGaiaIdByEmailParamsDefaultTypeInternal _LookupGaiaIdByEmailParams_default_instance_;
class LookupGaiaIdByEmailResult;
struct LookupGaiaIdByEmailResultDefaultTypeInternal;
extern LookupGaiaIdByEmailResultDefaultTypeInternal _LookupGaiaIdByEmailResult_default_instance_;
class ReadGroupsParams;
struct ReadGroupsParamsDefaultTypeInternal;
extern ReadGroupsParamsDefaultTypeInternal _ReadGroupsParams_default_instance_;
class ReadGroupsResult;
struct ReadGroupsResultDefaultTypeInternal;
extern ReadGroupsResultDefaultTypeInternal _ReadGroupsResult_default_instance_;
class RemoveMemberParams;
struct RemoveMemberParamsDefaultTypeInternal;
extern RemoveMemberParamsDefaultTypeInternal _RemoveMemberParams_default_instance_;
} // namespace data_sharing_pb
PROTOBUF_NAMESPACE_OPEN
template <>::data_sharing_pb::AddAccessTokenParams* Arena::CreateMaybeMessage<::data_sharing_pb::AddAccessTokenParams>(Arena*);
template <>::data_sharing_pb::AddAccessTokenResult* Arena::CreateMaybeMessage<::data_sharing_pb::AddAccessTokenResult>(Arena*);
template <>::data_sharing_pb::AddMemberParams* Arena::CreateMaybeMessage<::data_sharing_pb::AddMemberParams>(Arena*);
template <>::data_sharing_pb::CreateGroupParams* Arena::CreateMaybeMessage<::data_sharing_pb::CreateGroupParams>(Arena*);
template <>::data_sharing_pb::CreateGroupResult* Arena::CreateMaybeMessage<::data_sharing_pb::CreateGroupResult>(Arena*);
template <>::data_sharing_pb::DeleteGroupParams* Arena::CreateMaybeMessage<::data_sharing_pb::DeleteGroupParams>(Arena*);
template <>::data_sharing_pb::LeaveGroupParams* Arena::CreateMaybeMessage<::data_sharing_pb::LeaveGroupParams>(Arena*);
template <>::data_sharing_pb::LookupGaiaIdByEmailParams* Arena::CreateMaybeMessage<::data_sharing_pb::LookupGaiaIdByEmailParams>(Arena*);
template <>::data_sharing_pb::LookupGaiaIdByEmailResult* Arena::CreateMaybeMessage<::data_sharing_pb::LookupGaiaIdByEmailResult>(Arena*);
template <>::data_sharing_pb::ReadGroupsParams* Arena::CreateMaybeMessage<::data_sharing_pb::ReadGroupsParams>(Arena*);
template <>::data_sharing_pb::ReadGroupsResult* Arena::CreateMaybeMessage<::data_sharing_pb::ReadGroupsResult>(Arena*);
template <>::data_sharing_pb::RemoveMemberParams* Arena::CreateMaybeMessage<::data_sharing_pb::RemoveMemberParams>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace data_sharing_pb {

// ===================================================================

class CreateGroupParams final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:data_sharing_pb.CreateGroupParams) */ {
public:
    inline CreateGroupParams()
        : CreateGroupParams(nullptr)
    {
    }
    ~CreateGroupParams() override;
    explicit PROTOBUF_CONSTEXPR CreateGroupParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CreateGroupParams(const CreateGroupParams& from);
    CreateGroupParams(CreateGroupParams&& from) noexcept
        : CreateGroupParams()
    {
        *this = ::std::move(from);
    }

    inline CreateGroupParams& operator=(const CreateGroupParams& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CreateGroupParams& operator=(CreateGroupParams&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const CreateGroupParams& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CreateGroupParams* internal_default_instance()
    {
        return reinterpret_cast<const CreateGroupParams*>(&_CreateGroupParams_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(CreateGroupParams& a, CreateGroupParams& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CreateGroupParams* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CreateGroupParams* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CreateGroupParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CreateGroupParams>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CreateGroupParams& from);
    void MergeFrom(const CreateGroupParams& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CreateGroupParams* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "data_sharing_pb.CreateGroupParams";
    }

protected:
    explicit CreateGroupParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDisplayNameFieldNumber = 1,
    };
    // optional string display_name = 1;
    bool has_display_name() const;

private:
    bool _internal_has_display_name() const;

public:
    void clear_display_name();
    const std::string& display_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_display_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_display_name();
    PROTOBUF_NODISCARD std::string* release_display_name();
    void set_allocated_display_name(std::string* display_name);

private:
    const std::string& _internal_display_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
    std::string* _internal_mutable_display_name();

public:
    // @@protoc_insertion_point(class_scope:data_sharing_pb.CreateGroupParams)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class CreateGroupResult final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:data_sharing_pb.CreateGroupResult) */ {
public:
    inline CreateGroupResult()
        : CreateGroupResult(nullptr)
    {
    }
    ~CreateGroupResult() override;
    explicit PROTOBUF_CONSTEXPR CreateGroupResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CreateGroupResult(const CreateGroupResult& from);
    CreateGroupResult(CreateGroupResult&& from) noexcept
        : CreateGroupResult()
    {
        *this = ::std::move(from);
    }

    inline CreateGroupResult& operator=(const CreateGroupResult& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CreateGroupResult& operator=(CreateGroupResult&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const CreateGroupResult& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CreateGroupResult* internal_default_instance()
    {
        return reinterpret_cast<const CreateGroupResult*>(&_CreateGroupResult_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(CreateGroupResult& a, CreateGroupResult& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CreateGroupResult* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CreateGroupResult* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CreateGroupResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CreateGroupResult>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CreateGroupResult& from);
    void MergeFrom(const CreateGroupResult& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CreateGroupResult* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "data_sharing_pb.CreateGroupResult";
    }

protected:
    explicit CreateGroupResult(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kGroupDataFieldNumber = 1,
    };
    // optional .data_sharing_pb.GroupData group_data = 1;
    bool has_group_data() const;

private:
    bool _internal_has_group_data() const;

public:
    void clear_group_data();
    const ::data_sharing_pb::GroupData& group_data() const;
    PROTOBUF_NODISCARD ::data_sharing_pb::GroupData* release_group_data();
    ::data_sharing_pb::GroupData* mutable_group_data();
    void set_allocated_group_data(::data_sharing_pb::GroupData* group_data);

private:
    const ::data_sharing_pb::GroupData& _internal_group_data() const;
    ::data_sharing_pb::GroupData* _internal_mutable_group_data();

public:
    void unsafe_arena_set_allocated_group_data(::data_sharing_pb::GroupData* group_data);
    ::data_sharing_pb::GroupData* unsafe_arena_release_group_data();

    // @@protoc_insertion_point(class_scope:data_sharing_pb.CreateGroupResult)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::data_sharing_pb::GroupData* group_data_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class ReadGroupsParams final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:data_sharing_pb.ReadGroupsParams) */ {
public:
    inline ReadGroupsParams()
        : ReadGroupsParams(nullptr)
    {
    }
    ~ReadGroupsParams() override;
    explicit PROTOBUF_CONSTEXPR ReadGroupsParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ReadGroupsParams(const ReadGroupsParams& from);
    ReadGroupsParams(ReadGroupsParams&& from) noexcept
        : ReadGroupsParams()
    {
        *this = ::std::move(from);
    }

    inline ReadGroupsParams& operator=(const ReadGroupsParams& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ReadGroupsParams& operator=(ReadGroupsParams&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ReadGroupsParams& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ReadGroupsParams* internal_default_instance()
    {
        return reinterpret_cast<const ReadGroupsParams*>(&_ReadGroupsParams_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(ReadGroupsParams& a, ReadGroupsParams& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ReadGroupsParams* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ReadGroupsParams* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ReadGroupsParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ReadGroupsParams>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ReadGroupsParams& from);
    void MergeFrom(const ReadGroupsParams& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ReadGroupsParams* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "data_sharing_pb.ReadGroupsParams";
    }

protected:
    explicit ReadGroupsParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kGroupIdsFieldNumber = 1,
    };
    // repeated string group_ids = 1;
    int group_ids_size() const;

private:
    int _internal_group_ids_size() const;

public:
    void clear_group_ids();
    const std::string& group_ids(int index) const;
    std::string* mutable_group_ids(int index);
    void set_group_ids(int index, const std::string& value);
    void set_group_ids(int index, std::string&& value);
    void set_group_ids(int index, const char* value);
    void set_group_ids(int index, const char* value, size_t size);
    std::string* add_group_ids();
    void add_group_ids(const std::string& value);
    void add_group_ids(std::string&& value);
    void add_group_ids(const char* value);
    void add_group_ids(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& group_ids() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_group_ids();

private:
    const std::string& _internal_group_ids(int index) const;
    std::string* _internal_add_group_ids();

public:
    // @@protoc_insertion_point(class_scope:data_sharing_pb.ReadGroupsParams)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> group_ids_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class ReadGroupsResult final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:data_sharing_pb.ReadGroupsResult) */ {
public:
    inline ReadGroupsResult()
        : ReadGroupsResult(nullptr)
    {
    }
    ~ReadGroupsResult() override;
    explicit PROTOBUF_CONSTEXPR ReadGroupsResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ReadGroupsResult(const ReadGroupsResult& from);
    ReadGroupsResult(ReadGroupsResult&& from) noexcept
        : ReadGroupsResult()
    {
        *this = ::std::move(from);
    }

    inline ReadGroupsResult& operator=(const ReadGroupsResult& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ReadGroupsResult& operator=(ReadGroupsResult&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ReadGroupsResult& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ReadGroupsResult* internal_default_instance()
    {
        return reinterpret_cast<const ReadGroupsResult*>(&_ReadGroupsResult_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(ReadGroupsResult& a, ReadGroupsResult& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ReadGroupsResult* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ReadGroupsResult* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ReadGroupsResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ReadGroupsResult>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ReadGroupsResult& from);
    void MergeFrom(const ReadGroupsResult& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ReadGroupsResult* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "data_sharing_pb.ReadGroupsResult";
    }

protected:
    explicit ReadGroupsResult(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kGroupDataFieldNumber = 1,
    };
    // repeated .data_sharing_pb.GroupData group_data = 1;
    int group_data_size() const;

private:
    int _internal_group_data_size() const;

public:
    void clear_group_data();
    ::data_sharing_pb::GroupData* mutable_group_data(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::data_sharing_pb::GroupData>* mutable_group_data();

private:
    const ::data_sharing_pb::GroupData& _internal_group_data(int index) const;
    ::data_sharing_pb::GroupData* _internal_add_group_data();

public:
    const ::data_sharing_pb::GroupData& group_data(int index) const;
    ::data_sharing_pb::GroupData* add_group_data();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::data_sharing_pb::GroupData>& group_data() const;

    // @@protoc_insertion_point(class_scope:data_sharing_pb.ReadGroupsResult)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::data_sharing_pb::GroupData> group_data_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class AddMemberParams final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:data_sharing_pb.AddMemberParams) */ {
public:
    inline AddMemberParams()
        : AddMemberParams(nullptr)
    {
    }
    ~AddMemberParams() override;
    explicit PROTOBUF_CONSTEXPR AddMemberParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AddMemberParams(const AddMemberParams& from);
    AddMemberParams(AddMemberParams&& from) noexcept
        : AddMemberParams()
    {
        *this = ::std::move(from);
    }

    inline AddMemberParams& operator=(const AddMemberParams& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AddMemberParams& operator=(AddMemberParams&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AddMemberParams& default_instance()
    {
        return *internal_default_instance();
    }
    enum AddMemberOptionsCase {
        kMemberGaiaId = 2,
        kAccessToken = 3,
        ADDMEMBEROPTIONS_NOT_SET = 0,
    };

    static inline const AddMemberParams* internal_default_instance()
    {
        return reinterpret_cast<const AddMemberParams*>(&_AddMemberParams_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(AddMemberParams& a, AddMemberParams& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AddMemberParams* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AddMemberParams* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AddMemberParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AddMemberParams>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AddMemberParams& from);
    void MergeFrom(const AddMemberParams& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AddMemberParams* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "data_sharing_pb.AddMemberParams";
    }

protected:
    explicit AddMemberParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kGroupIdFieldNumber = 1,
        kMemberGaiaIdFieldNumber = 2,
        kAccessTokenFieldNumber = 3,
    };
    // optional string group_id = 1;
    bool has_group_id() const;

private:
    bool _internal_has_group_id() const;

public:
    void clear_group_id();
    const std::string& group_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_group_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_group_id();
    PROTOBUF_NODISCARD std::string* release_group_id();
    void set_allocated_group_id(std::string* group_id);

private:
    const std::string& _internal_group_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_id(const std::string& value);
    std::string* _internal_mutable_group_id();

public:
    // string member_gaia_id = 2;
    bool has_member_gaia_id() const;

private:
    bool _internal_has_member_gaia_id() const;

public:
    void clear_member_gaia_id();
    const std::string& member_gaia_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_member_gaia_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_member_gaia_id();
    PROTOBUF_NODISCARD std::string* release_member_gaia_id();
    void set_allocated_member_gaia_id(std::string* member_gaia_id);

private:
    const std::string& _internal_member_gaia_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_member_gaia_id(const std::string& value);
    std::string* _internal_mutable_member_gaia_id();

public:
    // string access_token = 3;
    bool has_access_token() const;

private:
    bool _internal_has_access_token() const;

public:
    void clear_access_token();
    const std::string& access_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_access_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_access_token();
    PROTOBUF_NODISCARD std::string* release_access_token();
    void set_allocated_access_token(std::string* access_token);

private:
    const std::string& _internal_access_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_token(const std::string& value);
    std::string* _internal_mutable_access_token();

public:
    void clear_AddMemberOptions();
    AddMemberOptionsCase AddMemberOptions_case() const;
    // @@protoc_insertion_point(class_scope:data_sharing_pb.AddMemberParams)
private:
    class _Internal;
    void set_has_member_gaia_id();
    void set_has_access_token();

    inline bool has_AddMemberOptions() const;
    inline void clear_has_AddMemberOptions();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_id_;
        union AddMemberOptionsUnion {
            constexpr AddMemberOptionsUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr member_gaia_id_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_token_;
        } AddMemberOptions_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class RemoveMemberParams final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:data_sharing_pb.RemoveMemberParams) */ {
public:
    inline RemoveMemberParams()
        : RemoveMemberParams(nullptr)
    {
    }
    ~RemoveMemberParams() override;
    explicit PROTOBUF_CONSTEXPR RemoveMemberParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    RemoveMemberParams(const RemoveMemberParams& from);
    RemoveMemberParams(RemoveMemberParams&& from) noexcept
        : RemoveMemberParams()
    {
        *this = ::std::move(from);
    }

    inline RemoveMemberParams& operator=(const RemoveMemberParams& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline RemoveMemberParams& operator=(RemoveMemberParams&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const RemoveMemberParams& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const RemoveMemberParams* internal_default_instance()
    {
        return reinterpret_cast<const RemoveMemberParams*>(&_RemoveMemberParams_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(RemoveMemberParams& a, RemoveMemberParams& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(RemoveMemberParams* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(RemoveMemberParams* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    RemoveMemberParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<RemoveMemberParams>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const RemoveMemberParams& from);
    void MergeFrom(const RemoveMemberParams& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RemoveMemberParams* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "data_sharing_pb.RemoveMemberParams";
    }

protected:
    explicit RemoveMemberParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kGroupIdFieldNumber = 1,
        kMemberGaiaIdFieldNumber = 2,
    };
    // optional string group_id = 1;
    bool has_group_id() const;

private:
    bool _internal_has_group_id() const;

public:
    void clear_group_id();
    const std::string& group_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_group_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_group_id();
    PROTOBUF_NODISCARD std::string* release_group_id();
    void set_allocated_group_id(std::string* group_id);

private:
    const std::string& _internal_group_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_id(const std::string& value);
    std::string* _internal_mutable_group_id();

public:
    // optional string member_gaia_id = 2;
    bool has_member_gaia_id() const;

private:
    bool _internal_has_member_gaia_id() const;

public:
    void clear_member_gaia_id();
    const std::string& member_gaia_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_member_gaia_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_member_gaia_id();
    PROTOBUF_NODISCARD std::string* release_member_gaia_id();
    void set_allocated_member_gaia_id(std::string* member_gaia_id);

private:
    const std::string& _internal_member_gaia_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_member_gaia_id(const std::string& value);
    std::string* _internal_mutable_member_gaia_id();

public:
    // @@protoc_insertion_point(class_scope:data_sharing_pb.RemoveMemberParams)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr member_gaia_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class LeaveGroupParams final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:data_sharing_pb.LeaveGroupParams) */ {
public:
    inline LeaveGroupParams()
        : LeaveGroupParams(nullptr)
    {
    }
    ~LeaveGroupParams() override;
    explicit PROTOBUF_CONSTEXPR LeaveGroupParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    LeaveGroupParams(const LeaveGroupParams& from);
    LeaveGroupParams(LeaveGroupParams&& from) noexcept
        : LeaveGroupParams()
    {
        *this = ::std::move(from);
    }

    inline LeaveGroupParams& operator=(const LeaveGroupParams& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline LeaveGroupParams& operator=(LeaveGroupParams&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const LeaveGroupParams& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const LeaveGroupParams* internal_default_instance()
    {
        return reinterpret_cast<const LeaveGroupParams*>(&_LeaveGroupParams_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(LeaveGroupParams& a, LeaveGroupParams& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(LeaveGroupParams* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(LeaveGroupParams* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    LeaveGroupParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<LeaveGroupParams>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const LeaveGroupParams& from);
    void MergeFrom(const LeaveGroupParams& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(LeaveGroupParams* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "data_sharing_pb.LeaveGroupParams";
    }

protected:
    explicit LeaveGroupParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kGroupIdFieldNumber = 1,
    };
    // optional string group_id = 1;
    bool has_group_id() const;

private:
    bool _internal_has_group_id() const;

public:
    void clear_group_id();
    const std::string& group_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_group_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_group_id();
    PROTOBUF_NODISCARD std::string* release_group_id();
    void set_allocated_group_id(std::string* group_id);

private:
    const std::string& _internal_group_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_id(const std::string& value);
    std::string* _internal_mutable_group_id();

public:
    // @@protoc_insertion_point(class_scope:data_sharing_pb.LeaveGroupParams)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class DeleteGroupParams final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:data_sharing_pb.DeleteGroupParams) */ {
public:
    inline DeleteGroupParams()
        : DeleteGroupParams(nullptr)
    {
    }
    ~DeleteGroupParams() override;
    explicit PROTOBUF_CONSTEXPR DeleteGroupParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    DeleteGroupParams(const DeleteGroupParams& from);
    DeleteGroupParams(DeleteGroupParams&& from) noexcept
        : DeleteGroupParams()
    {
        *this = ::std::move(from);
    }

    inline DeleteGroupParams& operator=(const DeleteGroupParams& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DeleteGroupParams& operator=(DeleteGroupParams&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const DeleteGroupParams& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DeleteGroupParams* internal_default_instance()
    {
        return reinterpret_cast<const DeleteGroupParams*>(&_DeleteGroupParams_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(DeleteGroupParams& a, DeleteGroupParams& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(DeleteGroupParams* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DeleteGroupParams* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DeleteGroupParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<DeleteGroupParams>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const DeleteGroupParams& from);
    void MergeFrom(const DeleteGroupParams& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeleteGroupParams* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "data_sharing_pb.DeleteGroupParams";
    }

protected:
    explicit DeleteGroupParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kGroupIdFieldNumber = 1,
    };
    // optional string group_id = 1;
    bool has_group_id() const;

private:
    bool _internal_has_group_id() const;

public:
    void clear_group_id();
    const std::string& group_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_group_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_group_id();
    PROTOBUF_NODISCARD std::string* release_group_id();
    void set_allocated_group_id(std::string* group_id);

private:
    const std::string& _internal_group_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_id(const std::string& value);
    std::string* _internal_mutable_group_id();

public:
    // @@protoc_insertion_point(class_scope:data_sharing_pb.DeleteGroupParams)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class LookupGaiaIdByEmailParams final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:data_sharing_pb.LookupGaiaIdByEmailParams) */ {
public:
    inline LookupGaiaIdByEmailParams()
        : LookupGaiaIdByEmailParams(nullptr)
    {
    }
    ~LookupGaiaIdByEmailParams() override;
    explicit PROTOBUF_CONSTEXPR LookupGaiaIdByEmailParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    LookupGaiaIdByEmailParams(const LookupGaiaIdByEmailParams& from);
    LookupGaiaIdByEmailParams(LookupGaiaIdByEmailParams&& from) noexcept
        : LookupGaiaIdByEmailParams()
    {
        *this = ::std::move(from);
    }

    inline LookupGaiaIdByEmailParams& operator=(const LookupGaiaIdByEmailParams& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline LookupGaiaIdByEmailParams& operator=(LookupGaiaIdByEmailParams&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const LookupGaiaIdByEmailParams& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const LookupGaiaIdByEmailParams* internal_default_instance()
    {
        return reinterpret_cast<const LookupGaiaIdByEmailParams*>(&_LookupGaiaIdByEmailParams_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(LookupGaiaIdByEmailParams& a, LookupGaiaIdByEmailParams& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(LookupGaiaIdByEmailParams* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(LookupGaiaIdByEmailParams* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    LookupGaiaIdByEmailParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<LookupGaiaIdByEmailParams>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const LookupGaiaIdByEmailParams& from);
    void MergeFrom(const LookupGaiaIdByEmailParams& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(LookupGaiaIdByEmailParams* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "data_sharing_pb.LookupGaiaIdByEmailParams";
    }

protected:
    explicit LookupGaiaIdByEmailParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kEmailFieldNumber = 1,
    };
    // optional string email = 1;
    bool has_email() const;

private:
    bool _internal_has_email() const;

public:
    void clear_email();
    const std::string& email() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_email(ArgT0&& arg0, ArgT... args);
    std::string* mutable_email();
    PROTOBUF_NODISCARD std::string* release_email();
    void set_allocated_email(std::string* email);

private:
    const std::string& _internal_email() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
    std::string* _internal_mutable_email();

public:
    // @@protoc_insertion_point(class_scope:data_sharing_pb.LookupGaiaIdByEmailParams)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class LookupGaiaIdByEmailResult final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:data_sharing_pb.LookupGaiaIdByEmailResult) */ {
public:
    inline LookupGaiaIdByEmailResult()
        : LookupGaiaIdByEmailResult(nullptr)
    {
    }
    ~LookupGaiaIdByEmailResult() override;
    explicit PROTOBUF_CONSTEXPR LookupGaiaIdByEmailResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    LookupGaiaIdByEmailResult(const LookupGaiaIdByEmailResult& from);
    LookupGaiaIdByEmailResult(LookupGaiaIdByEmailResult&& from) noexcept
        : LookupGaiaIdByEmailResult()
    {
        *this = ::std::move(from);
    }

    inline LookupGaiaIdByEmailResult& operator=(const LookupGaiaIdByEmailResult& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline LookupGaiaIdByEmailResult& operator=(LookupGaiaIdByEmailResult&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const LookupGaiaIdByEmailResult& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const LookupGaiaIdByEmailResult* internal_default_instance()
    {
        return reinterpret_cast<const LookupGaiaIdByEmailResult*>(&_LookupGaiaIdByEmailResult_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(LookupGaiaIdByEmailResult& a, LookupGaiaIdByEmailResult& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(LookupGaiaIdByEmailResult* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(LookupGaiaIdByEmailResult* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    LookupGaiaIdByEmailResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<LookupGaiaIdByEmailResult>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const LookupGaiaIdByEmailResult& from);
    void MergeFrom(const LookupGaiaIdByEmailResult& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(LookupGaiaIdByEmailResult* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "data_sharing_pb.LookupGaiaIdByEmailResult";
    }

protected:
    explicit LookupGaiaIdByEmailResult(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kGaiaIdFieldNumber = 1,
    };
    // optional string gaia_id = 1;
    bool has_gaia_id() const;

private:
    bool _internal_has_gaia_id() const;

public:
    void clear_gaia_id();
    const std::string& gaia_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_gaia_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_gaia_id();
    PROTOBUF_NODISCARD std::string* release_gaia_id();
    void set_allocated_gaia_id(std::string* gaia_id);

private:
    const std::string& _internal_gaia_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_gaia_id(const std::string& value);
    std::string* _internal_mutable_gaia_id();

public:
    // @@protoc_insertion_point(class_scope:data_sharing_pb.LookupGaiaIdByEmailResult)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gaia_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class AddAccessTokenParams final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:data_sharing_pb.AddAccessTokenParams) */ {
public:
    inline AddAccessTokenParams()
        : AddAccessTokenParams(nullptr)
    {
    }
    ~AddAccessTokenParams() override;
    explicit PROTOBUF_CONSTEXPR AddAccessTokenParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AddAccessTokenParams(const AddAccessTokenParams& from);
    AddAccessTokenParams(AddAccessTokenParams&& from) noexcept
        : AddAccessTokenParams()
    {
        *this = ::std::move(from);
    }

    inline AddAccessTokenParams& operator=(const AddAccessTokenParams& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AddAccessTokenParams& operator=(AddAccessTokenParams&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AddAccessTokenParams& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AddAccessTokenParams* internal_default_instance()
    {
        return reinterpret_cast<const AddAccessTokenParams*>(&_AddAccessTokenParams_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 10;

    friend void swap(AddAccessTokenParams& a, AddAccessTokenParams& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AddAccessTokenParams* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AddAccessTokenParams* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AddAccessTokenParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AddAccessTokenParams>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AddAccessTokenParams& from);
    void MergeFrom(const AddAccessTokenParams& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AddAccessTokenParams* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "data_sharing_pb.AddAccessTokenParams";
    }

protected:
    explicit AddAccessTokenParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kGroupIdFieldNumber = 1,
    };
    // optional string group_id = 1;
    bool has_group_id() const;

private:
    bool _internal_has_group_id() const;

public:
    void clear_group_id();
    const std::string& group_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_group_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_group_id();
    PROTOBUF_NODISCARD std::string* release_group_id();
    void set_allocated_group_id(std::string* group_id);

private:
    const std::string& _internal_group_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_id(const std::string& value);
    std::string* _internal_mutable_group_id();

public:
    // @@protoc_insertion_point(class_scope:data_sharing_pb.AddAccessTokenParams)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto;
};
// -------------------------------------------------------------------

class AddAccessTokenResult final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:data_sharing_pb.AddAccessTokenResult) */ {
public:
    inline AddAccessTokenResult()
        : AddAccessTokenResult(nullptr)
    {
    }
    ~AddAccessTokenResult() override;
    explicit PROTOBUF_CONSTEXPR AddAccessTokenResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AddAccessTokenResult(const AddAccessTokenResult& from);
    AddAccessTokenResult(AddAccessTokenResult&& from) noexcept
        : AddAccessTokenResult()
    {
        *this = ::std::move(from);
    }

    inline AddAccessTokenResult& operator=(const AddAccessTokenResult& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AddAccessTokenResult& operator=(AddAccessTokenResult&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AddAccessTokenResult& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AddAccessTokenResult* internal_default_instance()
    {
        return reinterpret_cast<const AddAccessTokenResult*>(&_AddAccessTokenResult_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 11;

    friend void swap(AddAccessTokenResult& a, AddAccessTokenResult& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AddAccessTokenResult* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AddAccessTokenResult* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AddAccessTokenResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AddAccessTokenResult>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AddAccessTokenResult& from);
    void MergeFrom(const AddAccessTokenResult& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AddAccessTokenResult* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "data_sharing_pb.AddAccessTokenResult";
    }

protected:
    explicit AddAccessTokenResult(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kGroupDataFieldNumber = 1,
    };
    // optional .data_sharing_pb.GroupData group_data = 1;
    bool has_group_data() const;

private:
    bool _internal_has_group_data() const;

public:
    void clear_group_data();
    const ::data_sharing_pb::GroupData& group_data() const;
    PROTOBUF_NODISCARD ::data_sharing_pb::GroupData* release_group_data();
    ::data_sharing_pb::GroupData* mutable_group_data();
    void set_allocated_group_data(::data_sharing_pb::GroupData* group_data);

private:
    const ::data_sharing_pb::GroupData& _internal_group_data() const;
    ::data_sharing_pb::GroupData* _internal_mutable_group_data();

public:
    void unsafe_arena_set_allocated_group_data(::data_sharing_pb::GroupData* group_data);
    ::data_sharing_pb::GroupData* unsafe_arena_release_group_data();

    // @@protoc_insertion_point(class_scope:data_sharing_pb.AddAccessTokenResult)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::data_sharing_pb::GroupData* group_data_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// CreateGroupParams

// optional string display_name = 1;
inline bool CreateGroupParams::_internal_has_display_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool CreateGroupParams::has_display_name() const
{
    return _internal_has_display_name();
}
inline void CreateGroupParams::clear_display_name()
{
    _impl_.display_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateGroupParams::display_name() const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.CreateGroupParams.display_name)
    return _internal_display_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CreateGroupParams::set_display_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.display_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:data_sharing_pb.CreateGroupParams.display_name)
}
inline std::string* CreateGroupParams::mutable_display_name()
{
    std::string* _s = _internal_mutable_display_name();
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.CreateGroupParams.display_name)
    return _s;
}
inline const std::string& CreateGroupParams::_internal_display_name() const
{
    return _impl_.display_name_.Get();
}
inline void CreateGroupParams::_internal_set_display_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateGroupParams::_internal_mutable_display_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateGroupParams::release_display_name()
{
    // @@protoc_insertion_point(field_release:data_sharing_pb.CreateGroupParams.display_name)
    if (!_internal_has_display_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.display_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.display_name_.IsDefault()) {
        _impl_.display_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void CreateGroupParams::set_allocated_display_name(std::string* display_name)
{
    if (display_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.display_name_.IsDefault()) {
        _impl_.display_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:data_sharing_pb.CreateGroupParams.display_name)
}

// -------------------------------------------------------------------

// CreateGroupResult

// optional .data_sharing_pb.GroupData group_data = 1;
inline bool CreateGroupResult::_internal_has_group_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.group_data_ != nullptr);
    return value;
}
inline bool CreateGroupResult::has_group_data() const
{
    return _internal_has_group_data();
}
inline const ::data_sharing_pb::GroupData& CreateGroupResult::_internal_group_data() const
{
    const ::data_sharing_pb::GroupData* p = _impl_.group_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::data_sharing_pb::GroupData&>(::data_sharing_pb::_GroupData_default_instance_);
}
inline const ::data_sharing_pb::GroupData& CreateGroupResult::group_data() const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.CreateGroupResult.group_data)
    return _internal_group_data();
}
inline void CreateGroupResult::unsafe_arena_set_allocated_group_data(::data_sharing_pb::GroupData* group_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_data_);
    }
    _impl_.group_data_ = group_data;
    if (group_data) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data_sharing_pb.CreateGroupResult.group_data)
}
inline ::data_sharing_pb::GroupData* CreateGroupResult::release_group_data()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::data_sharing_pb::GroupData* temp = _impl_.group_data_;
    _impl_.group_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::data_sharing_pb::GroupData* CreateGroupResult::unsafe_arena_release_group_data()
{
    // @@protoc_insertion_point(field_release:data_sharing_pb.CreateGroupResult.group_data)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::data_sharing_pb::GroupData* temp = _impl_.group_data_;
    _impl_.group_data_ = nullptr;
    return temp;
}
inline ::data_sharing_pb::GroupData* CreateGroupResult::_internal_mutable_group_data()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.group_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::data_sharing_pb::GroupData>(GetArenaForAllocation());
        _impl_.group_data_ = p;
    }
    return _impl_.group_data_;
}
inline ::data_sharing_pb::GroupData* CreateGroupResult::mutable_group_data()
{
    ::data_sharing_pb::GroupData* _msg = _internal_mutable_group_data();
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.CreateGroupResult.group_data)
    return _msg;
}
inline void CreateGroupResult::set_allocated_group_data(::data_sharing_pb::GroupData* group_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_data_);
    }
    if (group_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_data));
        if (message_arena != submessage_arena) {
            group_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, group_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.group_data_ = group_data;
    // @@protoc_insertion_point(field_set_allocated:data_sharing_pb.CreateGroupResult.group_data)
}

// -------------------------------------------------------------------

// ReadGroupsParams

// repeated string group_ids = 1;
inline int ReadGroupsParams::_internal_group_ids_size() const
{
    return _impl_.group_ids_.size();
}
inline int ReadGroupsParams::group_ids_size() const
{
    return _internal_group_ids_size();
}
inline void ReadGroupsParams::clear_group_ids()
{
    _impl_.group_ids_.Clear();
}
inline std::string* ReadGroupsParams::add_group_ids()
{
    std::string* _s = _internal_add_group_ids();
    // @@protoc_insertion_point(field_add_mutable:data_sharing_pb.ReadGroupsParams.group_ids)
    return _s;
}
inline const std::string& ReadGroupsParams::_internal_group_ids(int index) const
{
    return _impl_.group_ids_.Get(index);
}
inline const std::string& ReadGroupsParams::group_ids(int index) const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.ReadGroupsParams.group_ids)
    return _internal_group_ids(index);
}
inline std::string* ReadGroupsParams::mutable_group_ids(int index)
{
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.ReadGroupsParams.group_ids)
    return _impl_.group_ids_.Mutable(index);
}
inline void ReadGroupsParams::set_group_ids(int index, const std::string& value)
{
    _impl_.group_ids_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:data_sharing_pb.ReadGroupsParams.group_ids)
}
inline void ReadGroupsParams::set_group_ids(int index, std::string&& value)
{
    _impl_.group_ids_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:data_sharing_pb.ReadGroupsParams.group_ids)
}
inline void ReadGroupsParams::set_group_ids(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.group_ids_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:data_sharing_pb.ReadGroupsParams.group_ids)
}
inline void ReadGroupsParams::set_group_ids(int index, const char* value, size_t size)
{
    _impl_.group_ids_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:data_sharing_pb.ReadGroupsParams.group_ids)
}
inline std::string* ReadGroupsParams::_internal_add_group_ids()
{
    return _impl_.group_ids_.Add();
}
inline void ReadGroupsParams::add_group_ids(const std::string& value)
{
    _impl_.group_ids_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:data_sharing_pb.ReadGroupsParams.group_ids)
}
inline void ReadGroupsParams::add_group_ids(std::string&& value)
{
    _impl_.group_ids_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:data_sharing_pb.ReadGroupsParams.group_ids)
}
inline void ReadGroupsParams::add_group_ids(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.group_ids_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:data_sharing_pb.ReadGroupsParams.group_ids)
}
inline void ReadGroupsParams::add_group_ids(const char* value, size_t size)
{
    _impl_.group_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:data_sharing_pb.ReadGroupsParams.group_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ReadGroupsParams::group_ids() const
{
    // @@protoc_insertion_point(field_list:data_sharing_pb.ReadGroupsParams.group_ids)
    return _impl_.group_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ReadGroupsParams::mutable_group_ids()
{
    // @@protoc_insertion_point(field_mutable_list:data_sharing_pb.ReadGroupsParams.group_ids)
    return &_impl_.group_ids_;
}

// -------------------------------------------------------------------

// ReadGroupsResult

// repeated .data_sharing_pb.GroupData group_data = 1;
inline int ReadGroupsResult::_internal_group_data_size() const
{
    return _impl_.group_data_.size();
}
inline int ReadGroupsResult::group_data_size() const
{
    return _internal_group_data_size();
}
inline ::data_sharing_pb::GroupData* ReadGroupsResult::mutable_group_data(int index)
{
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.ReadGroupsResult.group_data)
    return _impl_.group_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::data_sharing_pb::GroupData>* ReadGroupsResult::mutable_group_data()
{
    // @@protoc_insertion_point(field_mutable_list:data_sharing_pb.ReadGroupsResult.group_data)
    return &_impl_.group_data_;
}
inline const ::data_sharing_pb::GroupData& ReadGroupsResult::_internal_group_data(int index) const
{
    return _impl_.group_data_.Get(index);
}
inline const ::data_sharing_pb::GroupData& ReadGroupsResult::group_data(int index) const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.ReadGroupsResult.group_data)
    return _internal_group_data(index);
}
inline ::data_sharing_pb::GroupData* ReadGroupsResult::_internal_add_group_data()
{
    return _impl_.group_data_.Add();
}
inline ::data_sharing_pb::GroupData* ReadGroupsResult::add_group_data()
{
    ::data_sharing_pb::GroupData* _add = _internal_add_group_data();
    // @@protoc_insertion_point(field_add:data_sharing_pb.ReadGroupsResult.group_data)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::data_sharing_pb::GroupData>& ReadGroupsResult::group_data() const
{
    // @@protoc_insertion_point(field_list:data_sharing_pb.ReadGroupsResult.group_data)
    return _impl_.group_data_;
}

// -------------------------------------------------------------------

// AddMemberParams

// optional string group_id = 1;
inline bool AddMemberParams::_internal_has_group_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool AddMemberParams::has_group_id() const
{
    return _internal_has_group_id();
}
inline void AddMemberParams::clear_group_id()
{
    _impl_.group_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AddMemberParams::group_id() const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.AddMemberParams.group_id)
    return _internal_group_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AddMemberParams::set_group_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.group_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:data_sharing_pb.AddMemberParams.group_id)
}
inline std::string* AddMemberParams::mutable_group_id()
{
    std::string* _s = _internal_mutable_group_id();
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.AddMemberParams.group_id)
    return _s;
}
inline const std::string& AddMemberParams::_internal_group_id() const
{
    return _impl_.group_id_.Get();
}
inline void AddMemberParams::_internal_set_group_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.group_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AddMemberParams::_internal_mutable_group_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.group_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AddMemberParams::release_group_id()
{
    // @@protoc_insertion_point(field_release:data_sharing_pb.AddMemberParams.group_id)
    if (!_internal_has_group_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.group_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.group_id_.IsDefault()) {
        _impl_.group_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AddMemberParams::set_allocated_group_id(std::string* group_id)
{
    if (group_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.group_id_.SetAllocated(group_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.group_id_.IsDefault()) {
        _impl_.group_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:data_sharing_pb.AddMemberParams.group_id)
}

// string member_gaia_id = 2;
inline bool AddMemberParams::_internal_has_member_gaia_id() const
{
    return AddMemberOptions_case() == kMemberGaiaId;
}
inline bool AddMemberParams::has_member_gaia_id() const
{
    return _internal_has_member_gaia_id();
}
inline void AddMemberParams::set_has_member_gaia_id()
{
    _impl_._oneof_case_[0] = kMemberGaiaId;
}
inline void AddMemberParams::clear_member_gaia_id()
{
    if (_internal_has_member_gaia_id()) {
        _impl_.AddMemberOptions_.member_gaia_id_.Destroy();
        clear_has_AddMemberOptions();
    }
}
inline const std::string& AddMemberParams::member_gaia_id() const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.AddMemberParams.member_gaia_id)
    return _internal_member_gaia_id();
}
template <typename ArgT0, typename... ArgT> inline void AddMemberParams::set_member_gaia_id(ArgT0&& arg0, ArgT... args)
{
    if (!_internal_has_member_gaia_id()) {
        clear_AddMemberOptions();
        set_has_member_gaia_id();
        _impl_.AddMemberOptions_.member_gaia_id_.InitDefault();
    }
    _impl_.AddMemberOptions_.member_gaia_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:data_sharing_pb.AddMemberParams.member_gaia_id)
}
inline std::string* AddMemberParams::mutable_member_gaia_id()
{
    std::string* _s = _internal_mutable_member_gaia_id();
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.AddMemberParams.member_gaia_id)
    return _s;
}
inline const std::string& AddMemberParams::_internal_member_gaia_id() const
{
    if (_internal_has_member_gaia_id()) {
        return _impl_.AddMemberOptions_.member_gaia_id_.Get();
    }
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AddMemberParams::_internal_set_member_gaia_id(const std::string& value)
{
    if (!_internal_has_member_gaia_id()) {
        clear_AddMemberOptions();
        set_has_member_gaia_id();
        _impl_.AddMemberOptions_.member_gaia_id_.InitDefault();
    }
    _impl_.AddMemberOptions_.member_gaia_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AddMemberParams::_internal_mutable_member_gaia_id()
{
    if (!_internal_has_member_gaia_id()) {
        clear_AddMemberOptions();
        set_has_member_gaia_id();
        _impl_.AddMemberOptions_.member_gaia_id_.InitDefault();
    }
    return _impl_.AddMemberOptions_.member_gaia_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AddMemberParams::release_member_gaia_id()
{
    // @@protoc_insertion_point(field_release:data_sharing_pb.AddMemberParams.member_gaia_id)
    if (_internal_has_member_gaia_id()) {
        clear_has_AddMemberOptions();
        return _impl_.AddMemberOptions_.member_gaia_id_.Release();
    } else {
        return nullptr;
    }
}
inline void AddMemberParams::set_allocated_member_gaia_id(std::string* member_gaia_id)
{
    if (has_AddMemberOptions()) {
        clear_AddMemberOptions();
    }
    if (member_gaia_id != nullptr) {
        set_has_member_gaia_id();
        _impl_.AddMemberOptions_.member_gaia_id_.InitAllocated(member_gaia_id, GetArenaForAllocation());
    }
    // @@protoc_insertion_point(field_set_allocated:data_sharing_pb.AddMemberParams.member_gaia_id)
}

// string access_token = 3;
inline bool AddMemberParams::_internal_has_access_token() const
{
    return AddMemberOptions_case() == kAccessToken;
}
inline bool AddMemberParams::has_access_token() const
{
    return _internal_has_access_token();
}
inline void AddMemberParams::set_has_access_token()
{
    _impl_._oneof_case_[0] = kAccessToken;
}
inline void AddMemberParams::clear_access_token()
{
    if (_internal_has_access_token()) {
        _impl_.AddMemberOptions_.access_token_.Destroy();
        clear_has_AddMemberOptions();
    }
}
inline const std::string& AddMemberParams::access_token() const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.AddMemberParams.access_token)
    return _internal_access_token();
}
template <typename ArgT0, typename... ArgT> inline void AddMemberParams::set_access_token(ArgT0&& arg0, ArgT... args)
{
    if (!_internal_has_access_token()) {
        clear_AddMemberOptions();
        set_has_access_token();
        _impl_.AddMemberOptions_.access_token_.InitDefault();
    }
    _impl_.AddMemberOptions_.access_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:data_sharing_pb.AddMemberParams.access_token)
}
inline std::string* AddMemberParams::mutable_access_token()
{
    std::string* _s = _internal_mutable_access_token();
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.AddMemberParams.access_token)
    return _s;
}
inline const std::string& AddMemberParams::_internal_access_token() const
{
    if (_internal_has_access_token()) {
        return _impl_.AddMemberOptions_.access_token_.Get();
    }
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AddMemberParams::_internal_set_access_token(const std::string& value)
{
    if (!_internal_has_access_token()) {
        clear_AddMemberOptions();
        set_has_access_token();
        _impl_.AddMemberOptions_.access_token_.InitDefault();
    }
    _impl_.AddMemberOptions_.access_token_.Set(value, GetArenaForAllocation());
}
inline std::string* AddMemberParams::_internal_mutable_access_token()
{
    if (!_internal_has_access_token()) {
        clear_AddMemberOptions();
        set_has_access_token();
        _impl_.AddMemberOptions_.access_token_.InitDefault();
    }
    return _impl_.AddMemberOptions_.access_token_.Mutable(GetArenaForAllocation());
}
inline std::string* AddMemberParams::release_access_token()
{
    // @@protoc_insertion_point(field_release:data_sharing_pb.AddMemberParams.access_token)
    if (_internal_has_access_token()) {
        clear_has_AddMemberOptions();
        return _impl_.AddMemberOptions_.access_token_.Release();
    } else {
        return nullptr;
    }
}
inline void AddMemberParams::set_allocated_access_token(std::string* access_token)
{
    if (has_AddMemberOptions()) {
        clear_AddMemberOptions();
    }
    if (access_token != nullptr) {
        set_has_access_token();
        _impl_.AddMemberOptions_.access_token_.InitAllocated(access_token, GetArenaForAllocation());
    }
    // @@protoc_insertion_point(field_set_allocated:data_sharing_pb.AddMemberParams.access_token)
}

inline bool AddMemberParams::has_AddMemberOptions() const
{
    return AddMemberOptions_case() != ADDMEMBEROPTIONS_NOT_SET;
}
inline void AddMemberParams::clear_has_AddMemberOptions()
{
    _impl_._oneof_case_[0] = ADDMEMBEROPTIONS_NOT_SET;
}
inline AddMemberParams::AddMemberOptionsCase AddMemberParams::AddMemberOptions_case() const
{
    return AddMemberParams::AddMemberOptionsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RemoveMemberParams

// optional string group_id = 1;
inline bool RemoveMemberParams::_internal_has_group_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool RemoveMemberParams::has_group_id() const
{
    return _internal_has_group_id();
}
inline void RemoveMemberParams::clear_group_id()
{
    _impl_.group_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RemoveMemberParams::group_id() const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.RemoveMemberParams.group_id)
    return _internal_group_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void RemoveMemberParams::set_group_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.group_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:data_sharing_pb.RemoveMemberParams.group_id)
}
inline std::string* RemoveMemberParams::mutable_group_id()
{
    std::string* _s = _internal_mutable_group_id();
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.RemoveMemberParams.group_id)
    return _s;
}
inline const std::string& RemoveMemberParams::_internal_group_id() const
{
    return _impl_.group_id_.Get();
}
inline void RemoveMemberParams::_internal_set_group_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.group_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveMemberParams::_internal_mutable_group_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.group_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveMemberParams::release_group_id()
{
    // @@protoc_insertion_point(field_release:data_sharing_pb.RemoveMemberParams.group_id)
    if (!_internal_has_group_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.group_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.group_id_.IsDefault()) {
        _impl_.group_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void RemoveMemberParams::set_allocated_group_id(std::string* group_id)
{
    if (group_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.group_id_.SetAllocated(group_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.group_id_.IsDefault()) {
        _impl_.group_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:data_sharing_pb.RemoveMemberParams.group_id)
}

// optional string member_gaia_id = 2;
inline bool RemoveMemberParams::_internal_has_member_gaia_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool RemoveMemberParams::has_member_gaia_id() const
{
    return _internal_has_member_gaia_id();
}
inline void RemoveMemberParams::clear_member_gaia_id()
{
    _impl_.member_gaia_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RemoveMemberParams::member_gaia_id() const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.RemoveMemberParams.member_gaia_id)
    return _internal_member_gaia_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void RemoveMemberParams::set_member_gaia_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.member_gaia_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:data_sharing_pb.RemoveMemberParams.member_gaia_id)
}
inline std::string* RemoveMemberParams::mutable_member_gaia_id()
{
    std::string* _s = _internal_mutable_member_gaia_id();
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.RemoveMemberParams.member_gaia_id)
    return _s;
}
inline const std::string& RemoveMemberParams::_internal_member_gaia_id() const
{
    return _impl_.member_gaia_id_.Get();
}
inline void RemoveMemberParams::_internal_set_member_gaia_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.member_gaia_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RemoveMemberParams::_internal_mutable_member_gaia_id()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.member_gaia_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RemoveMemberParams::release_member_gaia_id()
{
    // @@protoc_insertion_point(field_release:data_sharing_pb.RemoveMemberParams.member_gaia_id)
    if (!_internal_has_member_gaia_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.member_gaia_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.member_gaia_id_.IsDefault()) {
        _impl_.member_gaia_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void RemoveMemberParams::set_allocated_member_gaia_id(std::string* member_gaia_id)
{
    if (member_gaia_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.member_gaia_id_.SetAllocated(member_gaia_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.member_gaia_id_.IsDefault()) {
        _impl_.member_gaia_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:data_sharing_pb.RemoveMemberParams.member_gaia_id)
}

// -------------------------------------------------------------------

// LeaveGroupParams

// optional string group_id = 1;
inline bool LeaveGroupParams::_internal_has_group_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool LeaveGroupParams::has_group_id() const
{
    return _internal_has_group_id();
}
inline void LeaveGroupParams::clear_group_id()
{
    _impl_.group_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LeaveGroupParams::group_id() const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.LeaveGroupParams.group_id)
    return _internal_group_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void LeaveGroupParams::set_group_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.group_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:data_sharing_pb.LeaveGroupParams.group_id)
}
inline std::string* LeaveGroupParams::mutable_group_id()
{
    std::string* _s = _internal_mutable_group_id();
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.LeaveGroupParams.group_id)
    return _s;
}
inline const std::string& LeaveGroupParams::_internal_group_id() const
{
    return _impl_.group_id_.Get();
}
inline void LeaveGroupParams::_internal_set_group_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.group_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LeaveGroupParams::_internal_mutable_group_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.group_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LeaveGroupParams::release_group_id()
{
    // @@protoc_insertion_point(field_release:data_sharing_pb.LeaveGroupParams.group_id)
    if (!_internal_has_group_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.group_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.group_id_.IsDefault()) {
        _impl_.group_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void LeaveGroupParams::set_allocated_group_id(std::string* group_id)
{
    if (group_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.group_id_.SetAllocated(group_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.group_id_.IsDefault()) {
        _impl_.group_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:data_sharing_pb.LeaveGroupParams.group_id)
}

// -------------------------------------------------------------------

// DeleteGroupParams

// optional string group_id = 1;
inline bool DeleteGroupParams::_internal_has_group_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool DeleteGroupParams::has_group_id() const
{
    return _internal_has_group_id();
}
inline void DeleteGroupParams::clear_group_id()
{
    _impl_.group_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeleteGroupParams::group_id() const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.DeleteGroupParams.group_id)
    return _internal_group_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DeleteGroupParams::set_group_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.group_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:data_sharing_pb.DeleteGroupParams.group_id)
}
inline std::string* DeleteGroupParams::mutable_group_id()
{
    std::string* _s = _internal_mutable_group_id();
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.DeleteGroupParams.group_id)
    return _s;
}
inline const std::string& DeleteGroupParams::_internal_group_id() const
{
    return _impl_.group_id_.Get();
}
inline void DeleteGroupParams::_internal_set_group_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.group_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteGroupParams::_internal_mutable_group_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.group_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteGroupParams::release_group_id()
{
    // @@protoc_insertion_point(field_release:data_sharing_pb.DeleteGroupParams.group_id)
    if (!_internal_has_group_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.group_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.group_id_.IsDefault()) {
        _impl_.group_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DeleteGroupParams::set_allocated_group_id(std::string* group_id)
{
    if (group_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.group_id_.SetAllocated(group_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.group_id_.IsDefault()) {
        _impl_.group_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:data_sharing_pb.DeleteGroupParams.group_id)
}

// -------------------------------------------------------------------

// LookupGaiaIdByEmailParams

// optional string email = 1;
inline bool LookupGaiaIdByEmailParams::_internal_has_email() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool LookupGaiaIdByEmailParams::has_email() const
{
    return _internal_has_email();
}
inline void LookupGaiaIdByEmailParams::clear_email()
{
    _impl_.email_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LookupGaiaIdByEmailParams::email() const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.LookupGaiaIdByEmailParams.email)
    return _internal_email();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void LookupGaiaIdByEmailParams::set_email(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.email_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:data_sharing_pb.LookupGaiaIdByEmailParams.email)
}
inline std::string* LookupGaiaIdByEmailParams::mutable_email()
{
    std::string* _s = _internal_mutable_email();
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.LookupGaiaIdByEmailParams.email)
    return _s;
}
inline const std::string& LookupGaiaIdByEmailParams::_internal_email() const
{
    return _impl_.email_.Get();
}
inline void LookupGaiaIdByEmailParams::_internal_set_email(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupGaiaIdByEmailParams::_internal_mutable_email()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupGaiaIdByEmailParams::release_email()
{
    // @@protoc_insertion_point(field_release:data_sharing_pb.LookupGaiaIdByEmailParams.email)
    if (!_internal_has_email()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.email_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.email_.IsDefault()) {
        _impl_.email_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void LookupGaiaIdByEmailParams::set_allocated_email(std::string* email)
{
    if (email != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.email_.IsDefault()) {
        _impl_.email_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:data_sharing_pb.LookupGaiaIdByEmailParams.email)
}

// -------------------------------------------------------------------

// LookupGaiaIdByEmailResult

// optional string gaia_id = 1;
inline bool LookupGaiaIdByEmailResult::_internal_has_gaia_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool LookupGaiaIdByEmailResult::has_gaia_id() const
{
    return _internal_has_gaia_id();
}
inline void LookupGaiaIdByEmailResult::clear_gaia_id()
{
    _impl_.gaia_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LookupGaiaIdByEmailResult::gaia_id() const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.LookupGaiaIdByEmailResult.gaia_id)
    return _internal_gaia_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void LookupGaiaIdByEmailResult::set_gaia_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.gaia_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:data_sharing_pb.LookupGaiaIdByEmailResult.gaia_id)
}
inline std::string* LookupGaiaIdByEmailResult::mutable_gaia_id()
{
    std::string* _s = _internal_mutable_gaia_id();
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.LookupGaiaIdByEmailResult.gaia_id)
    return _s;
}
inline const std::string& LookupGaiaIdByEmailResult::_internal_gaia_id() const
{
    return _impl_.gaia_id_.Get();
}
inline void LookupGaiaIdByEmailResult::_internal_set_gaia_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.gaia_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LookupGaiaIdByEmailResult::_internal_mutable_gaia_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.gaia_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LookupGaiaIdByEmailResult::release_gaia_id()
{
    // @@protoc_insertion_point(field_release:data_sharing_pb.LookupGaiaIdByEmailResult.gaia_id)
    if (!_internal_has_gaia_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.gaia_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.gaia_id_.IsDefault()) {
        _impl_.gaia_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void LookupGaiaIdByEmailResult::set_allocated_gaia_id(std::string* gaia_id)
{
    if (gaia_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.gaia_id_.SetAllocated(gaia_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.gaia_id_.IsDefault()) {
        _impl_.gaia_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:data_sharing_pb.LookupGaiaIdByEmailResult.gaia_id)
}

// -------------------------------------------------------------------

// AddAccessTokenParams

// optional string group_id = 1;
inline bool AddAccessTokenParams::_internal_has_group_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool AddAccessTokenParams::has_group_id() const
{
    return _internal_has_group_id();
}
inline void AddAccessTokenParams::clear_group_id()
{
    _impl_.group_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AddAccessTokenParams::group_id() const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.AddAccessTokenParams.group_id)
    return _internal_group_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AddAccessTokenParams::set_group_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.group_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:data_sharing_pb.AddAccessTokenParams.group_id)
}
inline std::string* AddAccessTokenParams::mutable_group_id()
{
    std::string* _s = _internal_mutable_group_id();
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.AddAccessTokenParams.group_id)
    return _s;
}
inline const std::string& AddAccessTokenParams::_internal_group_id() const
{
    return _impl_.group_id_.Get();
}
inline void AddAccessTokenParams::_internal_set_group_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.group_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AddAccessTokenParams::_internal_mutable_group_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.group_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AddAccessTokenParams::release_group_id()
{
    // @@protoc_insertion_point(field_release:data_sharing_pb.AddAccessTokenParams.group_id)
    if (!_internal_has_group_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.group_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.group_id_.IsDefault()) {
        _impl_.group_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AddAccessTokenParams::set_allocated_group_id(std::string* group_id)
{
    if (group_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.group_id_.SetAllocated(group_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.group_id_.IsDefault()) {
        _impl_.group_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:data_sharing_pb.AddAccessTokenParams.group_id)
}

// -------------------------------------------------------------------

// AddAccessTokenResult

// optional .data_sharing_pb.GroupData group_data = 1;
inline bool AddAccessTokenResult::_internal_has_group_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.group_data_ != nullptr);
    return value;
}
inline bool AddAccessTokenResult::has_group_data() const
{
    return _internal_has_group_data();
}
inline const ::data_sharing_pb::GroupData& AddAccessTokenResult::_internal_group_data() const
{
    const ::data_sharing_pb::GroupData* p = _impl_.group_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::data_sharing_pb::GroupData&>(::data_sharing_pb::_GroupData_default_instance_);
}
inline const ::data_sharing_pb::GroupData& AddAccessTokenResult::group_data() const
{
    // @@protoc_insertion_point(field_get:data_sharing_pb.AddAccessTokenResult.group_data)
    return _internal_group_data();
}
inline void AddAccessTokenResult::unsafe_arena_set_allocated_group_data(::data_sharing_pb::GroupData* group_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_data_);
    }
    _impl_.group_data_ = group_data;
    if (group_data) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:data_sharing_pb.AddAccessTokenResult.group_data)
}
inline ::data_sharing_pb::GroupData* AddAccessTokenResult::release_group_data()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::data_sharing_pb::GroupData* temp = _impl_.group_data_;
    _impl_.group_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::data_sharing_pb::GroupData* AddAccessTokenResult::unsafe_arena_release_group_data()
{
    // @@protoc_insertion_point(field_release:data_sharing_pb.AddAccessTokenResult.group_data)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::data_sharing_pb::GroupData* temp = _impl_.group_data_;
    _impl_.group_data_ = nullptr;
    return temp;
}
inline ::data_sharing_pb::GroupData* AddAccessTokenResult::_internal_mutable_group_data()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.group_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::data_sharing_pb::GroupData>(GetArenaForAllocation());
        _impl_.group_data_ = p;
    }
    return _impl_.group_data_;
}
inline ::data_sharing_pb::GroupData* AddAccessTokenResult::mutable_group_data()
{
    ::data_sharing_pb::GroupData* _msg = _internal_mutable_group_data();
    // @@protoc_insertion_point(field_mutable:data_sharing_pb.AddAccessTokenResult.group_data)
    return _msg;
}
inline void AddAccessTokenResult::set_allocated_group_data(::data_sharing_pb::GroupData* group_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_data_);
    }
    if (group_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group_data));
        if (message_arena != submessage_arena) {
            group_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, group_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.group_data_ = group_data;
    // @@protoc_insertion_point(field_set_allocated:data_sharing_pb.AddAccessTokenResult.group_data)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace data_sharing_pb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fdata_5fsharing_2fpublic_2fprotocol_2fdata_5fsharing_5fsdk_2eproto
