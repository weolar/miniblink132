// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kidsmanagement_messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_kidsmanagement_5fmessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_kidsmanagement_5fmessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "families_common.pb.h"
#include "permissions_common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kidsmanagement_5fmessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_kidsmanagement_5fmessages_2eproto {
    static const uint32_t offsets[];
};
namespace kidsmanagement {
class ClassifyUrlRequest;
struct ClassifyUrlRequestDefaultTypeInternal;
extern ClassifyUrlRequestDefaultTypeInternal _ClassifyUrlRequest_default_instance_;
class ClassifyUrlResponse;
struct ClassifyUrlResponseDefaultTypeInternal;
extern ClassifyUrlResponseDefaultTypeInternal _ClassifyUrlResponse_default_instance_;
class CreatePermissionRequestResponse;
struct CreatePermissionRequestResponseDefaultTypeInternal;
extern CreatePermissionRequestResponseDefaultTypeInternal _CreatePermissionRequestResponse_default_instance_;
class DefineChromeTestStateRequest;
struct DefineChromeTestStateRequestDefaultTypeInternal;
extern DefineChromeTestStateRequestDefaultTypeInternal _DefineChromeTestStateRequest_default_instance_;
class DefineChromeTestStateRequest_UrlFilteringSettings;
struct DefineChromeTestStateRequest_UrlFilteringSettingsDefaultTypeInternal;
extern DefineChromeTestStateRequest_UrlFilteringSettingsDefaultTypeInternal _DefineChromeTestStateRequest_UrlFilteringSettings_default_instance_;
class ListMembersRequest;
struct ListMembersRequestDefaultTypeInternal;
extern ListMembersRequestDefaultTypeInternal _ListMembersRequest_default_instance_;
class ListMembersResponse;
struct ListMembersResponseDefaultTypeInternal;
extern ListMembersResponseDefaultTypeInternal _ListMembersResponse_default_instance_;
class PermissionRequest;
struct PermissionRequestDefaultTypeInternal;
extern PermissionRequestDefaultTypeInternal _PermissionRequest_default_instance_;
class ResetChromeTestStateRequest;
struct ResetChromeTestStateRequestDefaultTypeInternal;
extern ResetChromeTestStateRequestDefaultTypeInternal _ResetChromeTestStateRequest_default_instance_;
class WebsiteException;
struct WebsiteExceptionDefaultTypeInternal;
extern WebsiteExceptionDefaultTypeInternal _WebsiteException_default_instance_;
} // namespace kidsmanagement
PROTOBUF_NAMESPACE_OPEN
template <>::kidsmanagement::ClassifyUrlRequest* Arena::CreateMaybeMessage<::kidsmanagement::ClassifyUrlRequest>(Arena*);
template <>::kidsmanagement::ClassifyUrlResponse* Arena::CreateMaybeMessage<::kidsmanagement::ClassifyUrlResponse>(Arena*);
template <>::kidsmanagement::CreatePermissionRequestResponse* Arena::CreateMaybeMessage<::kidsmanagement::CreatePermissionRequestResponse>(Arena*);
template <>::kidsmanagement::DefineChromeTestStateRequest* Arena::CreateMaybeMessage<::kidsmanagement::DefineChromeTestStateRequest>(Arena*);
template <>
::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings*
Arena::CreateMaybeMessage<::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings>(Arena*);
template <>::kidsmanagement::ListMembersRequest* Arena::CreateMaybeMessage<::kidsmanagement::ListMembersRequest>(Arena*);
template <>::kidsmanagement::ListMembersResponse* Arena::CreateMaybeMessage<::kidsmanagement::ListMembersResponse>(Arena*);
template <>::kidsmanagement::PermissionRequest* Arena::CreateMaybeMessage<::kidsmanagement::PermissionRequest>(Arena*);
template <>::kidsmanagement::ResetChromeTestStateRequest* Arena::CreateMaybeMessage<::kidsmanagement::ResetChromeTestStateRequest>(Arena*);
template <>::kidsmanagement::WebsiteException* Arena::CreateMaybeMessage<::kidsmanagement::WebsiteException>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace kidsmanagement {

enum ClassifyUrlResponse_DisplayClassification : int {
    ClassifyUrlResponse_DisplayClassification_UNKNOWN_DISPLAY_CLASSIFICATION = 0,
    ClassifyUrlResponse_DisplayClassification_ALLOWED = 1,
    ClassifyUrlResponse_DisplayClassification_RESTRICTED = 2
};
bool ClassifyUrlResponse_DisplayClassification_IsValid(int value);
constexpr ClassifyUrlResponse_DisplayClassification ClassifyUrlResponse_DisplayClassification_DisplayClassification_MIN
    = ClassifyUrlResponse_DisplayClassification_UNKNOWN_DISPLAY_CLASSIFICATION;
constexpr ClassifyUrlResponse_DisplayClassification ClassifyUrlResponse_DisplayClassification_DisplayClassification_MAX
    = ClassifyUrlResponse_DisplayClassification_RESTRICTED;
constexpr int ClassifyUrlResponse_DisplayClassification_DisplayClassification_ARRAYSIZE
    = ClassifyUrlResponse_DisplayClassification_DisplayClassification_MAX + 1;

const std::string& ClassifyUrlResponse_DisplayClassification_Name(ClassifyUrlResponse_DisplayClassification value);
template <typename T> inline const std::string& ClassifyUrlResponse_DisplayClassification_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ClassifyUrlResponse_DisplayClassification>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ClassifyUrlResponse_DisplayClassification_Name.");
    return ClassifyUrlResponse_DisplayClassification_Name(static_cast<ClassifyUrlResponse_DisplayClassification>(enum_t_value));
}
bool ClassifyUrlResponse_DisplayClassification_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClassifyUrlResponse_DisplayClassification* value);
enum ExceptionType : int { EXCEPTION_TYPE_UNSPECIFIED = 0, ALLOW = 1, BLOCK = 2 };
bool ExceptionType_IsValid(int value);
constexpr ExceptionType ExceptionType_MIN = EXCEPTION_TYPE_UNSPECIFIED;
constexpr ExceptionType ExceptionType_MAX = BLOCK;
constexpr int ExceptionType_ARRAYSIZE = ExceptionType_MAX + 1;

const std::string& ExceptionType_Name(ExceptionType value);
template <typename T> inline const std::string& ExceptionType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ExceptionType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ExceptionType_Name.");
    return ExceptionType_Name(static_cast<ExceptionType>(enum_t_value));
}
bool ExceptionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExceptionType* value);
enum FilterLevel : int { FILTER_LEVEL_UNSPECIFIED = 0, ALLOW_BY_DEFAULT = 1, SAFE_SITES = 2, BLOCK_BY_DEFAULT = 3 };
bool FilterLevel_IsValid(int value);
constexpr FilterLevel FilterLevel_MIN = FILTER_LEVEL_UNSPECIFIED;
constexpr FilterLevel FilterLevel_MAX = BLOCK_BY_DEFAULT;
constexpr int FilterLevel_ARRAYSIZE = FilterLevel_MAX + 1;

const std::string& FilterLevel_Name(FilterLevel value);
template <typename T> inline const std::string& FilterLevel_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, FilterLevel>::value || ::std::is_integral<T>::value, "Incorrect type passed to function FilterLevel_Name.");
    return FilterLevel_Name(static_cast<FilterLevel>(enum_t_value));
}
bool FilterLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilterLevel* value);
// ===================================================================

class ListMembersRequest final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kidsmanagement.ListMembersRequest) */ {
public:
    inline ListMembersRequest()
        : ListMembersRequest(nullptr)
    {
    }
    ~ListMembersRequest() override;
    explicit PROTOBUF_CONSTEXPR ListMembersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ListMembersRequest(const ListMembersRequest& from);
    ListMembersRequest(ListMembersRequest&& from) noexcept
        : ListMembersRequest()
    {
        *this = ::std::move(from);
    }

    inline ListMembersRequest& operator=(const ListMembersRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ListMembersRequest& operator=(ListMembersRequest&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ListMembersRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ListMembersRequest* internal_default_instance()
    {
        return reinterpret_cast<const ListMembersRequest*>(&_ListMembersRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(ListMembersRequest& a, ListMembersRequest& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ListMembersRequest* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ListMembersRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ListMembersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ListMembersRequest>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ListMembersRequest& from);
    void MergeFrom(const ListMembersRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ListMembersRequest* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "kidsmanagement.ListMembersRequest";
    }

protected:
    explicit ListMembersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kAllowEmptyFamilyFieldNumber = 4,
    };
    // optional bool allow_empty_family = 4;
    bool has_allow_empty_family() const;

private:
    bool _internal_has_allow_empty_family() const;

public:
    void clear_allow_empty_family();
    bool allow_empty_family() const;
    void set_allow_empty_family(bool value);

private:
    bool _internal_allow_empty_family() const;
    void _internal_set_allow_empty_family(bool value);

public:
    // @@protoc_insertion_point(class_scope:kidsmanagement.ListMembersRequest)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        bool allow_empty_family_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_kidsmanagement_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class ListMembersResponse final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kidsmanagement.ListMembersResponse) */ {
public:
    inline ListMembersResponse()
        : ListMembersResponse(nullptr)
    {
    }
    ~ListMembersResponse() override;
    explicit PROTOBUF_CONSTEXPR ListMembersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ListMembersResponse(const ListMembersResponse& from);
    ListMembersResponse(ListMembersResponse&& from) noexcept
        : ListMembersResponse()
    {
        *this = ::std::move(from);
    }

    inline ListMembersResponse& operator=(const ListMembersResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ListMembersResponse& operator=(ListMembersResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ListMembersResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ListMembersResponse* internal_default_instance()
    {
        return reinterpret_cast<const ListMembersResponse*>(&_ListMembersResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(ListMembersResponse& a, ListMembersResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ListMembersResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ListMembersResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ListMembersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ListMembersResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ListMembersResponse& from);
    void MergeFrom(const ListMembersResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ListMembersResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "kidsmanagement.ListMembersResponse";
    }

protected:
    explicit ListMembersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kMembersFieldNumber = 1,
    };
    // repeated .kidsmanagement.FamilyMember members = 1;
    int members_size() const;

private:
    int _internal_members_size() const;

public:
    void clear_members();
    ::kidsmanagement::FamilyMember* mutable_members(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::kidsmanagement::FamilyMember>* mutable_members();

private:
    const ::kidsmanagement::FamilyMember& _internal_members(int index) const;
    ::kidsmanagement::FamilyMember* _internal_add_members();

public:
    const ::kidsmanagement::FamilyMember& members(int index) const;
    ::kidsmanagement::FamilyMember* add_members();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::kidsmanagement::FamilyMember>& members() const;

    // @@protoc_insertion_point(class_scope:kidsmanagement.ListMembersResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::kidsmanagement::FamilyMember> members_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_kidsmanagement_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class ClassifyUrlRequest final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kidsmanagement.ClassifyUrlRequest) */ {
public:
    inline ClassifyUrlRequest()
        : ClassifyUrlRequest(nullptr)
    {
    }
    ~ClassifyUrlRequest() override;
    explicit PROTOBUF_CONSTEXPR ClassifyUrlRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ClassifyUrlRequest(const ClassifyUrlRequest& from);
    ClassifyUrlRequest(ClassifyUrlRequest&& from) noexcept
        : ClassifyUrlRequest()
    {
        *this = ::std::move(from);
    }

    inline ClassifyUrlRequest& operator=(const ClassifyUrlRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ClassifyUrlRequest& operator=(ClassifyUrlRequest&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ClassifyUrlRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ClassifyUrlRequest* internal_default_instance()
    {
        return reinterpret_cast<const ClassifyUrlRequest*>(&_ClassifyUrlRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(ClassifyUrlRequest& a, ClassifyUrlRequest& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ClassifyUrlRequest* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ClassifyUrlRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ClassifyUrlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ClassifyUrlRequest>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ClassifyUrlRequest& from);
    void MergeFrom(const ClassifyUrlRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ClassifyUrlRequest* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "kidsmanagement.ClassifyUrlRequest";
    }

protected:
    explicit ClassifyUrlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUrlFieldNumber = 3,
        kRegionCodeFieldNumber = 4,
    };
    // optional string url = 3;
    bool has_url() const;

private:
    bool _internal_has_url() const;

public:
    void clear_url();
    const std::string& url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url();
    PROTOBUF_NODISCARD std::string* release_url();
    void set_allocated_url(std::string* url);

private:
    const std::string& _internal_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
    std::string* _internal_mutable_url();

public:
    // optional string region_code = 4;
    bool has_region_code() const;

private:
    bool _internal_has_region_code() const;

public:
    void clear_region_code();
    const std::string& region_code() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_region_code(ArgT0&& arg0, ArgT... args);
    std::string* mutable_region_code();
    PROTOBUF_NODISCARD std::string* release_region_code();
    void set_allocated_region_code(std::string* region_code);

private:
    const std::string& _internal_region_code() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_region_code(const std::string& value);
    std::string* _internal_mutable_region_code();

public:
    // @@protoc_insertion_point(class_scope:kidsmanagement.ClassifyUrlRequest)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_code_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_kidsmanagement_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class ClassifyUrlResponse final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kidsmanagement.ClassifyUrlResponse) */ {
public:
    inline ClassifyUrlResponse()
        : ClassifyUrlResponse(nullptr)
    {
    }
    ~ClassifyUrlResponse() override;
    explicit PROTOBUF_CONSTEXPR ClassifyUrlResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ClassifyUrlResponse(const ClassifyUrlResponse& from);
    ClassifyUrlResponse(ClassifyUrlResponse&& from) noexcept
        : ClassifyUrlResponse()
    {
        *this = ::std::move(from);
    }

    inline ClassifyUrlResponse& operator=(const ClassifyUrlResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ClassifyUrlResponse& operator=(ClassifyUrlResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ClassifyUrlResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ClassifyUrlResponse* internal_default_instance()
    {
        return reinterpret_cast<const ClassifyUrlResponse*>(&_ClassifyUrlResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(ClassifyUrlResponse& a, ClassifyUrlResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ClassifyUrlResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ClassifyUrlResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ClassifyUrlResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ClassifyUrlResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ClassifyUrlResponse& from);
    void MergeFrom(const ClassifyUrlResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ClassifyUrlResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "kidsmanagement.ClassifyUrlResponse";
    }

protected:
    explicit ClassifyUrlResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ClassifyUrlResponse_DisplayClassification DisplayClassification;
    static constexpr DisplayClassification UNKNOWN_DISPLAY_CLASSIFICATION = ClassifyUrlResponse_DisplayClassification_UNKNOWN_DISPLAY_CLASSIFICATION;
    static constexpr DisplayClassification ALLOWED = ClassifyUrlResponse_DisplayClassification_ALLOWED;
    static constexpr DisplayClassification RESTRICTED = ClassifyUrlResponse_DisplayClassification_RESTRICTED;
    static inline bool DisplayClassification_IsValid(int value)
    {
        return ClassifyUrlResponse_DisplayClassification_IsValid(value);
    }
    static constexpr DisplayClassification DisplayClassification_MIN = ClassifyUrlResponse_DisplayClassification_DisplayClassification_MIN;
    static constexpr DisplayClassification DisplayClassification_MAX = ClassifyUrlResponse_DisplayClassification_DisplayClassification_MAX;
    static constexpr int DisplayClassification_ARRAYSIZE = ClassifyUrlResponse_DisplayClassification_DisplayClassification_ARRAYSIZE;
    template <typename T> static inline const std::string& DisplayClassification_Name(T enum_t_value)
    {
        static_assert(
            ::std::is_same<T, DisplayClassification>::value || ::std::is_integral<T>::value, "Incorrect type passed to function DisplayClassification_Name.");
        return ClassifyUrlResponse_DisplayClassification_Name(enum_t_value);
    }
    static inline bool DisplayClassification_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DisplayClassification* value)
    {
        return ClassifyUrlResponse_DisplayClassification_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kDisplayClassificationFieldNumber = 2,
    };
    // optional .kidsmanagement.ClassifyUrlResponse.DisplayClassification display_classification = 2;
    bool has_display_classification() const;

private:
    bool _internal_has_display_classification() const;

public:
    void clear_display_classification();
    ::kidsmanagement::ClassifyUrlResponse_DisplayClassification display_classification() const;
    void set_display_classification(::kidsmanagement::ClassifyUrlResponse_DisplayClassification value);

private:
    ::kidsmanagement::ClassifyUrlResponse_DisplayClassification _internal_display_classification() const;
    void _internal_set_display_classification(::kidsmanagement::ClassifyUrlResponse_DisplayClassification value);

public:
    // @@protoc_insertion_point(class_scope:kidsmanagement.ClassifyUrlResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int display_classification_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_kidsmanagement_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class CreatePermissionRequestResponse final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kidsmanagement.CreatePermissionRequestResponse) */ {
public:
    inline CreatePermissionRequestResponse()
        : CreatePermissionRequestResponse(nullptr)
    {
    }
    ~CreatePermissionRequestResponse() override;
    explicit PROTOBUF_CONSTEXPR CreatePermissionRequestResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CreatePermissionRequestResponse(const CreatePermissionRequestResponse& from);
    CreatePermissionRequestResponse(CreatePermissionRequestResponse&& from) noexcept
        : CreatePermissionRequestResponse()
    {
        *this = ::std::move(from);
    }

    inline CreatePermissionRequestResponse& operator=(const CreatePermissionRequestResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CreatePermissionRequestResponse& operator=(CreatePermissionRequestResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const CreatePermissionRequestResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CreatePermissionRequestResponse* internal_default_instance()
    {
        return reinterpret_cast<const CreatePermissionRequestResponse*>(&_CreatePermissionRequestResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(CreatePermissionRequestResponse& a, CreatePermissionRequestResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CreatePermissionRequestResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CreatePermissionRequestResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CreatePermissionRequestResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CreatePermissionRequestResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CreatePermissionRequestResponse& from);
    void MergeFrom(const CreatePermissionRequestResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CreatePermissionRequestResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "kidsmanagement.CreatePermissionRequestResponse";
    }

protected:
    explicit CreatePermissionRequestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kPermissionRequestFieldNumber = 2,
    };
    // optional .kidsmanagement.PermissionRequest permission_request = 2;
    bool has_permission_request() const;

private:
    bool _internal_has_permission_request() const;

public:
    void clear_permission_request();
    const ::kidsmanagement::PermissionRequest& permission_request() const;
    PROTOBUF_NODISCARD ::kidsmanagement::PermissionRequest* release_permission_request();
    ::kidsmanagement::PermissionRequest* mutable_permission_request();
    void set_allocated_permission_request(::kidsmanagement::PermissionRequest* permission_request);

private:
    const ::kidsmanagement::PermissionRequest& _internal_permission_request() const;
    ::kidsmanagement::PermissionRequest* _internal_mutable_permission_request();

public:
    void unsafe_arena_set_allocated_permission_request(::kidsmanagement::PermissionRequest* permission_request);
    ::kidsmanagement::PermissionRequest* unsafe_arena_release_permission_request();

    // @@protoc_insertion_point(class_scope:kidsmanagement.CreatePermissionRequestResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::kidsmanagement::PermissionRequest* permission_request_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_kidsmanagement_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class PermissionRequest final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kidsmanagement.PermissionRequest) */ {
public:
    inline PermissionRequest()
        : PermissionRequest(nullptr)
    {
    }
    ~PermissionRequest() override;
    explicit PROTOBUF_CONSTEXPR PermissionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PermissionRequest(const PermissionRequest& from);
    PermissionRequest(PermissionRequest&& from) noexcept
        : PermissionRequest()
    {
        *this = ::std::move(from);
    }

    inline PermissionRequest& operator=(const PermissionRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline PermissionRequest& operator=(PermissionRequest&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const PermissionRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const PermissionRequest* internal_default_instance()
    {
        return reinterpret_cast<const PermissionRequest*>(&_PermissionRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(PermissionRequest& a, PermissionRequest& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(PermissionRequest* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PermissionRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<PermissionRequest>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const PermissionRequest& from);
    void MergeFrom(const PermissionRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PermissionRequest* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "kidsmanagement.PermissionRequest";
    }

protected:
    explicit PermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kIdFieldNumber = 1,
        kObjectRefFieldNumber = 4,
        kStateFieldNumber = 5,
        kEventTypeFieldNumber = 10,
    };
    // optional string id = 1;
    bool has_id() const;

private:
    bool _internal_has_id() const;

public:
    void clear_id();
    const std::string& id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_id();
    PROTOBUF_NODISCARD std::string* release_id();
    void set_allocated_id(std::string* id);

private:
    const std::string& _internal_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
    std::string* _internal_mutable_id();

public:
    // optional string object_ref = 4;
    bool has_object_ref() const;

private:
    bool _internal_has_object_ref() const;

public:
    void clear_object_ref();
    const std::string& object_ref() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_object_ref(ArgT0&& arg0, ArgT... args);
    std::string* mutable_object_ref();
    PROTOBUF_NODISCARD std::string* release_object_ref();
    void set_allocated_object_ref(std::string* object_ref);

private:
    const std::string& _internal_object_ref() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_object_ref(const std::string& value);
    std::string* _internal_mutable_object_ref();

public:
    // optional .kidsmanagement.PermissionRequestState state = 5;
    bool has_state() const;

private:
    bool _internal_has_state() const;

public:
    void clear_state();
    ::kidsmanagement::PermissionRequestState state() const;
    void set_state(::kidsmanagement::PermissionRequestState value);

private:
    ::kidsmanagement::PermissionRequestState _internal_state() const;
    void _internal_set_state(::kidsmanagement::PermissionRequestState value);

public:
    // optional .kidsmanagement.FamilyEventType event_type = 10;
    bool has_event_type() const;

private:
    bool _internal_has_event_type() const;

public:
    void clear_event_type();
    ::kidsmanagement::FamilyEventType event_type() const;
    void set_event_type(::kidsmanagement::FamilyEventType value);

private:
    ::kidsmanagement::FamilyEventType _internal_event_type() const;
    void _internal_set_event_type(::kidsmanagement::FamilyEventType value);

public:
    // @@protoc_insertion_point(class_scope:kidsmanagement.PermissionRequest)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr object_ref_;
        int state_;
        int event_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_kidsmanagement_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class WebsiteException final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kidsmanagement.WebsiteException) */ {
public:
    inline WebsiteException()
        : WebsiteException(nullptr)
    {
    }
    ~WebsiteException() override;
    explicit PROTOBUF_CONSTEXPR WebsiteException(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    WebsiteException(const WebsiteException& from);
    WebsiteException(WebsiteException&& from) noexcept
        : WebsiteException()
    {
        *this = ::std::move(from);
    }

    inline WebsiteException& operator=(const WebsiteException& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline WebsiteException& operator=(WebsiteException&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const WebsiteException& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const WebsiteException* internal_default_instance()
    {
        return reinterpret_cast<const WebsiteException*>(&_WebsiteException_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(WebsiteException& a, WebsiteException& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(WebsiteException* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(WebsiteException* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    WebsiteException* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<WebsiteException>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const WebsiteException& from);
    void MergeFrom(const WebsiteException& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(WebsiteException* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "kidsmanagement.WebsiteException";
    }

protected:
    explicit WebsiteException(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kPatternFieldNumber = 1,
        kIconUrlFieldNumber = 3,
        kExceptionTypeFieldNumber = 2,
    };
    // optional string pattern = 1;
    bool has_pattern() const;

private:
    bool _internal_has_pattern() const;

public:
    void clear_pattern();
    const std::string& pattern() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_pattern(ArgT0&& arg0, ArgT... args);
    std::string* mutable_pattern();
    PROTOBUF_NODISCARD std::string* release_pattern();
    void set_allocated_pattern(std::string* pattern);

private:
    const std::string& _internal_pattern() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(const std::string& value);
    std::string* _internal_mutable_pattern();

public:
    // optional string icon_url = 3;
    bool has_icon_url() const;

private:
    bool _internal_has_icon_url() const;

public:
    void clear_icon_url();
    const std::string& icon_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_icon_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_icon_url();
    PROTOBUF_NODISCARD std::string* release_icon_url();
    void set_allocated_icon_url(std::string* icon_url);

private:
    const std::string& _internal_icon_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon_url(const std::string& value);
    std::string* _internal_mutable_icon_url();

public:
    // optional .kidsmanagement.ExceptionType exception_type = 2;
    bool has_exception_type() const;

private:
    bool _internal_has_exception_type() const;

public:
    void clear_exception_type();
    ::kidsmanagement::ExceptionType exception_type() const;
    void set_exception_type(::kidsmanagement::ExceptionType value);

private:
    ::kidsmanagement::ExceptionType _internal_exception_type() const;
    void _internal_set_exception_type(::kidsmanagement::ExceptionType value);

public:
    // @@protoc_insertion_point(class_scope:kidsmanagement.WebsiteException)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pattern_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_url_;
        int exception_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_kidsmanagement_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class DefineChromeTestStateRequest_UrlFilteringSettings final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings) */ {
public:
    inline DefineChromeTestStateRequest_UrlFilteringSettings()
        : DefineChromeTestStateRequest_UrlFilteringSettings(nullptr)
    {
    }
    ~DefineChromeTestStateRequest_UrlFilteringSettings() override;
    explicit PROTOBUF_CONSTEXPR DefineChromeTestStateRequest_UrlFilteringSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    DefineChromeTestStateRequest_UrlFilteringSettings(const DefineChromeTestStateRequest_UrlFilteringSettings& from);
    DefineChromeTestStateRequest_UrlFilteringSettings(DefineChromeTestStateRequest_UrlFilteringSettings&& from) noexcept
        : DefineChromeTestStateRequest_UrlFilteringSettings()
    {
        *this = ::std::move(from);
    }

    inline DefineChromeTestStateRequest_UrlFilteringSettings& operator=(const DefineChromeTestStateRequest_UrlFilteringSettings& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DefineChromeTestStateRequest_UrlFilteringSettings& operator=(DefineChromeTestStateRequest_UrlFilteringSettings&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const DefineChromeTestStateRequest_UrlFilteringSettings& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DefineChromeTestStateRequest_UrlFilteringSettings* internal_default_instance()
    {
        return reinterpret_cast<const DefineChromeTestStateRequest_UrlFilteringSettings*>(
            &_DefineChromeTestStateRequest_UrlFilteringSettings_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(DefineChromeTestStateRequest_UrlFilteringSettings& a, DefineChromeTestStateRequest_UrlFilteringSettings& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(DefineChromeTestStateRequest_UrlFilteringSettings* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DefineChromeTestStateRequest_UrlFilteringSettings* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DefineChromeTestStateRequest_UrlFilteringSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<DefineChromeTestStateRequest_UrlFilteringSettings>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const DefineChromeTestStateRequest_UrlFilteringSettings& from);
    void MergeFrom(const DefineChromeTestStateRequest_UrlFilteringSettings& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DefineChromeTestStateRequest_UrlFilteringSettings* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings";
    }

protected:
    explicit DefineChromeTestStateRequest_UrlFilteringSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kExceptionsFieldNumber = 2,
        kFilterLevelFieldNumber = 1,
        kWebsitesCanRequestPermissionsFieldNumber = 3,
        kCanBlockCookiesFieldNumber = 4,
        kCanAddExtensionsFieldNumber = 5,
    };
    // repeated .kidsmanagement.WebsiteException exceptions = 2;
    int exceptions_size() const;

private:
    int _internal_exceptions_size() const;

public:
    void clear_exceptions();
    ::kidsmanagement::WebsiteException* mutable_exceptions(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::kidsmanagement::WebsiteException>* mutable_exceptions();

private:
    const ::kidsmanagement::WebsiteException& _internal_exceptions(int index) const;
    ::kidsmanagement::WebsiteException* _internal_add_exceptions();

public:
    const ::kidsmanagement::WebsiteException& exceptions(int index) const;
    ::kidsmanagement::WebsiteException* add_exceptions();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::kidsmanagement::WebsiteException>& exceptions() const;

    // optional .kidsmanagement.FilterLevel filter_level = 1;
    bool has_filter_level() const;

private:
    bool _internal_has_filter_level() const;

public:
    void clear_filter_level();
    ::kidsmanagement::FilterLevel filter_level() const;
    void set_filter_level(::kidsmanagement::FilterLevel value);

private:
    ::kidsmanagement::FilterLevel _internal_filter_level() const;
    void _internal_set_filter_level(::kidsmanagement::FilterLevel value);

public:
    // optional bool websites_can_request_permissions = 3;
    bool has_websites_can_request_permissions() const;

private:
    bool _internal_has_websites_can_request_permissions() const;

public:
    void clear_websites_can_request_permissions();
    bool websites_can_request_permissions() const;
    void set_websites_can_request_permissions(bool value);

private:
    bool _internal_websites_can_request_permissions() const;
    void _internal_set_websites_can_request_permissions(bool value);

public:
    // optional bool can_block_cookies = 4;
    bool has_can_block_cookies() const;

private:
    bool _internal_has_can_block_cookies() const;

public:
    void clear_can_block_cookies();
    bool can_block_cookies() const;
    void set_can_block_cookies(bool value);

private:
    bool _internal_can_block_cookies() const;
    void _internal_set_can_block_cookies(bool value);

public:
    // optional bool can_add_extensions = 5;
    bool has_can_add_extensions() const;

private:
    bool _internal_has_can_add_extensions() const;

public:
    void clear_can_add_extensions();
    bool can_add_extensions() const;
    void set_can_add_extensions(bool value);

private:
    bool _internal_can_add_extensions() const;
    void _internal_set_can_add_extensions(bool value);

public:
    // @@protoc_insertion_point(class_scope:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::kidsmanagement::WebsiteException> exceptions_;
        int filter_level_;
        bool websites_can_request_permissions_;
        bool can_block_cookies_;
        bool can_add_extensions_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_kidsmanagement_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class DefineChromeTestStateRequest final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kidsmanagement.DefineChromeTestStateRequest) */ {
public:
    inline DefineChromeTestStateRequest()
        : DefineChromeTestStateRequest(nullptr)
    {
    }
    ~DefineChromeTestStateRequest() override;
    explicit PROTOBUF_CONSTEXPR DefineChromeTestStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    DefineChromeTestStateRequest(const DefineChromeTestStateRequest& from);
    DefineChromeTestStateRequest(DefineChromeTestStateRequest&& from) noexcept
        : DefineChromeTestStateRequest()
    {
        *this = ::std::move(from);
    }

    inline DefineChromeTestStateRequest& operator=(const DefineChromeTestStateRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DefineChromeTestStateRequest& operator=(DefineChromeTestStateRequest&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const DefineChromeTestStateRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DefineChromeTestStateRequest* internal_default_instance()
    {
        return reinterpret_cast<const DefineChromeTestStateRequest*>(&_DefineChromeTestStateRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(DefineChromeTestStateRequest& a, DefineChromeTestStateRequest& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(DefineChromeTestStateRequest* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DefineChromeTestStateRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DefineChromeTestStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<DefineChromeTestStateRequest>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const DefineChromeTestStateRequest& from);
    void MergeFrom(const DefineChromeTestStateRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DefineChromeTestStateRequest* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "kidsmanagement.DefineChromeTestStateRequest";
    }

protected:
    explicit DefineChromeTestStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef DefineChromeTestStateRequest_UrlFilteringSettings UrlFilteringSettings;

    // accessors -------------------------------------------------------

    enum : int {
        kChildIdFieldNumber = 1,
        kUrlFilteringSettingsFieldNumber = 2,
    };
    // optional string child_id = 1;
    bool has_child_id() const;

private:
    bool _internal_has_child_id() const;

public:
    void clear_child_id();
    const std::string& child_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_child_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_child_id();
    PROTOBUF_NODISCARD std::string* release_child_id();
    void set_allocated_child_id(std::string* child_id);

private:
    const std::string& _internal_child_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_child_id(const std::string& value);
    std::string* _internal_mutable_child_id();

public:
    // optional .kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings url_filtering_settings = 2;
    bool has_url_filtering_settings() const;

private:
    bool _internal_has_url_filtering_settings() const;

public:
    void clear_url_filtering_settings();
    const ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings& url_filtering_settings() const;
    PROTOBUF_NODISCARD ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* release_url_filtering_settings();
    ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* mutable_url_filtering_settings();
    void set_allocated_url_filtering_settings(::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* url_filtering_settings);

private:
    const ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings& _internal_url_filtering_settings() const;
    ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* _internal_mutable_url_filtering_settings();

public:
    void unsafe_arena_set_allocated_url_filtering_settings(::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* url_filtering_settings);
    ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* unsafe_arena_release_url_filtering_settings();

    // @@protoc_insertion_point(class_scope:kidsmanagement.DefineChromeTestStateRequest)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr child_id_;
        ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* url_filtering_settings_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_kidsmanagement_5fmessages_2eproto;
};
// -------------------------------------------------------------------

class ResetChromeTestStateRequest final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:kidsmanagement.ResetChromeTestStateRequest) */ {
public:
    inline ResetChromeTestStateRequest()
        : ResetChromeTestStateRequest(nullptr)
    {
    }
    ~ResetChromeTestStateRequest() override;
    explicit PROTOBUF_CONSTEXPR ResetChromeTestStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ResetChromeTestStateRequest(const ResetChromeTestStateRequest& from);
    ResetChromeTestStateRequest(ResetChromeTestStateRequest&& from) noexcept
        : ResetChromeTestStateRequest()
    {
        *this = ::std::move(from);
    }

    inline ResetChromeTestStateRequest& operator=(const ResetChromeTestStateRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ResetChromeTestStateRequest& operator=(ResetChromeTestStateRequest&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ResetChromeTestStateRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ResetChromeTestStateRequest* internal_default_instance()
    {
        return reinterpret_cast<const ResetChromeTestStateRequest*>(&_ResetChromeTestStateRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(ResetChromeTestStateRequest& a, ResetChromeTestStateRequest& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ResetChromeTestStateRequest* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ResetChromeTestStateRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ResetChromeTestStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ResetChromeTestStateRequest>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ResetChromeTestStateRequest& from);
    void MergeFrom(const ResetChromeTestStateRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ResetChromeTestStateRequest* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "kidsmanagement.ResetChromeTestStateRequest";
    }

protected:
    explicit ResetChromeTestStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kChildIdFieldNumber = 1,
    };
    // optional string child_id = 1;
    bool has_child_id() const;

private:
    bool _internal_has_child_id() const;

public:
    void clear_child_id();
    const std::string& child_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_child_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_child_id();
    PROTOBUF_NODISCARD std::string* release_child_id();
    void set_allocated_child_id(std::string* child_id);

private:
    const std::string& _internal_child_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_child_id(const std::string& value);
    std::string* _internal_mutable_child_id();

public:
    // @@protoc_insertion_point(class_scope:kidsmanagement.ResetChromeTestStateRequest)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr child_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_kidsmanagement_5fmessages_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// ListMembersRequest

// optional bool allow_empty_family = 4;
inline bool ListMembersRequest::_internal_has_allow_empty_family() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ListMembersRequest::has_allow_empty_family() const
{
    return _internal_has_allow_empty_family();
}
inline void ListMembersRequest::clear_allow_empty_family()
{
    _impl_.allow_empty_family_ = false;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ListMembersRequest::_internal_allow_empty_family() const
{
    return _impl_.allow_empty_family_;
}
inline bool ListMembersRequest::allow_empty_family() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.ListMembersRequest.allow_empty_family)
    return _internal_allow_empty_family();
}
inline void ListMembersRequest::_internal_set_allow_empty_family(bool value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.allow_empty_family_ = value;
}
inline void ListMembersRequest::set_allow_empty_family(bool value)
{
    _internal_set_allow_empty_family(value);
    // @@protoc_insertion_point(field_set:kidsmanagement.ListMembersRequest.allow_empty_family)
}

// -------------------------------------------------------------------

// ListMembersResponse

// repeated .kidsmanagement.FamilyMember members = 1;
inline int ListMembersResponse::_internal_members_size() const
{
    return _impl_.members_.size();
}
inline int ListMembersResponse::members_size() const
{
    return _internal_members_size();
}
inline ::kidsmanagement::FamilyMember* ListMembersResponse::mutable_members(int index)
{
    // @@protoc_insertion_point(field_mutable:kidsmanagement.ListMembersResponse.members)
    return _impl_.members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::kidsmanagement::FamilyMember>* ListMembersResponse::mutable_members()
{
    // @@protoc_insertion_point(field_mutable_list:kidsmanagement.ListMembersResponse.members)
    return &_impl_.members_;
}
inline const ::kidsmanagement::FamilyMember& ListMembersResponse::_internal_members(int index) const
{
    return _impl_.members_.Get(index);
}
inline const ::kidsmanagement::FamilyMember& ListMembersResponse::members(int index) const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.ListMembersResponse.members)
    return _internal_members(index);
}
inline ::kidsmanagement::FamilyMember* ListMembersResponse::_internal_add_members()
{
    return _impl_.members_.Add();
}
inline ::kidsmanagement::FamilyMember* ListMembersResponse::add_members()
{
    ::kidsmanagement::FamilyMember* _add = _internal_add_members();
    // @@protoc_insertion_point(field_add:kidsmanagement.ListMembersResponse.members)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::kidsmanagement::FamilyMember>& ListMembersResponse::members() const
{
    // @@protoc_insertion_point(field_list:kidsmanagement.ListMembersResponse.members)
    return _impl_.members_;
}

// -------------------------------------------------------------------

// ClassifyUrlRequest

// optional string url = 3;
inline bool ClassifyUrlRequest::_internal_has_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ClassifyUrlRequest::has_url() const
{
    return _internal_has_url();
}
inline void ClassifyUrlRequest::clear_url()
{
    _impl_.url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClassifyUrlRequest::url() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.ClassifyUrlRequest.url)
    return _internal_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClassifyUrlRequest::set_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:kidsmanagement.ClassifyUrlRequest.url)
}
inline std::string* ClassifyUrlRequest::mutable_url()
{
    std::string* _s = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:kidsmanagement.ClassifyUrlRequest.url)
    return _s;
}
inline const std::string& ClassifyUrlRequest::_internal_url() const
{
    return _impl_.url_.Get();
}
inline void ClassifyUrlRequest::_internal_set_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ClassifyUrlRequest::_internal_mutable_url()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* ClassifyUrlRequest::release_url()
{
    // @@protoc_insertion_point(field_release:kidsmanagement.ClassifyUrlRequest.url)
    if (!_internal_has_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClassifyUrlRequest::set_allocated_url(std::string* url)
{
    if (url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:kidsmanagement.ClassifyUrlRequest.url)
}

// optional string region_code = 4;
inline bool ClassifyUrlRequest::_internal_has_region_code() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ClassifyUrlRequest::has_region_code() const
{
    return _internal_has_region_code();
}
inline void ClassifyUrlRequest::clear_region_code()
{
    _impl_.region_code_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClassifyUrlRequest::region_code() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.ClassifyUrlRequest.region_code)
    return _internal_region_code();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClassifyUrlRequest::set_region_code(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.region_code_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:kidsmanagement.ClassifyUrlRequest.region_code)
}
inline std::string* ClassifyUrlRequest::mutable_region_code()
{
    std::string* _s = _internal_mutable_region_code();
    // @@protoc_insertion_point(field_mutable:kidsmanagement.ClassifyUrlRequest.region_code)
    return _s;
}
inline const std::string& ClassifyUrlRequest::_internal_region_code() const
{
    return _impl_.region_code_.Get();
}
inline void ClassifyUrlRequest::_internal_set_region_code(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.region_code_.Set(value, GetArenaForAllocation());
}
inline std::string* ClassifyUrlRequest::_internal_mutable_region_code()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.region_code_.Mutable(GetArenaForAllocation());
}
inline std::string* ClassifyUrlRequest::release_region_code()
{
    // @@protoc_insertion_point(field_release:kidsmanagement.ClassifyUrlRequest.region_code)
    if (!_internal_has_region_code()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.region_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.region_code_.IsDefault()) {
        _impl_.region_code_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClassifyUrlRequest::set_allocated_region_code(std::string* region_code)
{
    if (region_code != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.region_code_.SetAllocated(region_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.region_code_.IsDefault()) {
        _impl_.region_code_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:kidsmanagement.ClassifyUrlRequest.region_code)
}

// -------------------------------------------------------------------

// ClassifyUrlResponse

// optional .kidsmanagement.ClassifyUrlResponse.DisplayClassification display_classification = 2;
inline bool ClassifyUrlResponse::_internal_has_display_classification() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ClassifyUrlResponse::has_display_classification() const
{
    return _internal_has_display_classification();
}
inline void ClassifyUrlResponse::clear_display_classification()
{
    _impl_.display_classification_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::kidsmanagement::ClassifyUrlResponse_DisplayClassification ClassifyUrlResponse::_internal_display_classification() const
{
    return static_cast<::kidsmanagement::ClassifyUrlResponse_DisplayClassification>(_impl_.display_classification_);
}
inline ::kidsmanagement::ClassifyUrlResponse_DisplayClassification ClassifyUrlResponse::display_classification() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.ClassifyUrlResponse.display_classification)
    return _internal_display_classification();
}
inline void ClassifyUrlResponse::_internal_set_display_classification(::kidsmanagement::ClassifyUrlResponse_DisplayClassification value)
{
    assert(::kidsmanagement::ClassifyUrlResponse_DisplayClassification_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.display_classification_ = value;
}
inline void ClassifyUrlResponse::set_display_classification(::kidsmanagement::ClassifyUrlResponse_DisplayClassification value)
{
    _internal_set_display_classification(value);
    // @@protoc_insertion_point(field_set:kidsmanagement.ClassifyUrlResponse.display_classification)
}

// -------------------------------------------------------------------

// CreatePermissionRequestResponse

// optional .kidsmanagement.PermissionRequest permission_request = 2;
inline bool CreatePermissionRequestResponse::_internal_has_permission_request() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.permission_request_ != nullptr);
    return value;
}
inline bool CreatePermissionRequestResponse::has_permission_request() const
{
    return _internal_has_permission_request();
}
inline void CreatePermissionRequestResponse::clear_permission_request()
{
    if (_impl_.permission_request_ != nullptr)
        _impl_.permission_request_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kidsmanagement::PermissionRequest& CreatePermissionRequestResponse::_internal_permission_request() const
{
    const ::kidsmanagement::PermissionRequest* p = _impl_.permission_request_;
    return p != nullptr ? *p : reinterpret_cast<const ::kidsmanagement::PermissionRequest&>(::kidsmanagement::_PermissionRequest_default_instance_);
}
inline const ::kidsmanagement::PermissionRequest& CreatePermissionRequestResponse::permission_request() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.CreatePermissionRequestResponse.permission_request)
    return _internal_permission_request();
}
inline void CreatePermissionRequestResponse::unsafe_arena_set_allocated_permission_request(::kidsmanagement::PermissionRequest* permission_request)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.permission_request_);
    }
    _impl_.permission_request_ = permission_request;
    if (permission_request) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kidsmanagement.CreatePermissionRequestResponse.permission_request)
}
inline ::kidsmanagement::PermissionRequest* CreatePermissionRequestResponse::release_permission_request()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::kidsmanagement::PermissionRequest* temp = _impl_.permission_request_;
    _impl_.permission_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::kidsmanagement::PermissionRequest* CreatePermissionRequestResponse::unsafe_arena_release_permission_request()
{
    // @@protoc_insertion_point(field_release:kidsmanagement.CreatePermissionRequestResponse.permission_request)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::kidsmanagement::PermissionRequest* temp = _impl_.permission_request_;
    _impl_.permission_request_ = nullptr;
    return temp;
}
inline ::kidsmanagement::PermissionRequest* CreatePermissionRequestResponse::_internal_mutable_permission_request()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.permission_request_ == nullptr) {
        auto* p = CreateMaybeMessage<::kidsmanagement::PermissionRequest>(GetArenaForAllocation());
        _impl_.permission_request_ = p;
    }
    return _impl_.permission_request_;
}
inline ::kidsmanagement::PermissionRequest* CreatePermissionRequestResponse::mutable_permission_request()
{
    ::kidsmanagement::PermissionRequest* _msg = _internal_mutable_permission_request();
    // @@protoc_insertion_point(field_mutable:kidsmanagement.CreatePermissionRequestResponse.permission_request)
    return _msg;
}
inline void CreatePermissionRequestResponse::set_allocated_permission_request(::kidsmanagement::PermissionRequest* permission_request)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.permission_request_;
    }
    if (permission_request) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(permission_request);
        if (message_arena != submessage_arena) {
            permission_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, permission_request, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.permission_request_ = permission_request;
    // @@protoc_insertion_point(field_set_allocated:kidsmanagement.CreatePermissionRequestResponse.permission_request)
}

// -------------------------------------------------------------------

// PermissionRequest

// optional string id = 1;
inline bool PermissionRequest::_internal_has_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool PermissionRequest::has_id() const
{
    return _internal_has_id();
}
inline void PermissionRequest::clear_id()
{
    _impl_.id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PermissionRequest::id() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.PermissionRequest.id)
    return _internal_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PermissionRequest::set_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:kidsmanagement.PermissionRequest.id)
}
inline std::string* PermissionRequest::mutable_id()
{
    std::string* _s = _internal_mutable_id();
    // @@protoc_insertion_point(field_mutable:kidsmanagement.PermissionRequest.id)
    return _s;
}
inline const std::string& PermissionRequest::_internal_id() const
{
    return _impl_.id_.Get();
}
inline void PermissionRequest::_internal_set_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* PermissionRequest::_internal_mutable_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* PermissionRequest::release_id()
{
    // @@protoc_insertion_point(field_release:kidsmanagement.PermissionRequest.id)
    if (!_internal_has_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.id_.IsDefault()) {
        _impl_.id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void PermissionRequest::set_allocated_id(std::string* id)
{
    if (id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.id_.IsDefault()) {
        _impl_.id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:kidsmanagement.PermissionRequest.id)
}

// optional .kidsmanagement.FamilyEventType event_type = 10;
inline bool PermissionRequest::_internal_has_event_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool PermissionRequest::has_event_type() const
{
    return _internal_has_event_type();
}
inline void PermissionRequest::clear_event_type()
{
    _impl_.event_type_ = 13;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::kidsmanagement::FamilyEventType PermissionRequest::_internal_event_type() const
{
    return static_cast<::kidsmanagement::FamilyEventType>(_impl_.event_type_);
}
inline ::kidsmanagement::FamilyEventType PermissionRequest::event_type() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.PermissionRequest.event_type)
    return _internal_event_type();
}
inline void PermissionRequest::_internal_set_event_type(::kidsmanagement::FamilyEventType value)
{
    assert(::kidsmanagement::FamilyEventType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.event_type_ = value;
}
inline void PermissionRequest::set_event_type(::kidsmanagement::FamilyEventType value)
{
    _internal_set_event_type(value);
    // @@protoc_insertion_point(field_set:kidsmanagement.PermissionRequest.event_type)
}

// optional string object_ref = 4;
inline bool PermissionRequest::_internal_has_object_ref() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool PermissionRequest::has_object_ref() const
{
    return _internal_has_object_ref();
}
inline void PermissionRequest::clear_object_ref()
{
    _impl_.object_ref_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PermissionRequest::object_ref() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.PermissionRequest.object_ref)
    return _internal_object_ref();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PermissionRequest::set_object_ref(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.object_ref_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:kidsmanagement.PermissionRequest.object_ref)
}
inline std::string* PermissionRequest::mutable_object_ref()
{
    std::string* _s = _internal_mutable_object_ref();
    // @@protoc_insertion_point(field_mutable:kidsmanagement.PermissionRequest.object_ref)
    return _s;
}
inline const std::string& PermissionRequest::_internal_object_ref() const
{
    return _impl_.object_ref_.Get();
}
inline void PermissionRequest::_internal_set_object_ref(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.object_ref_.Set(value, GetArenaForAllocation());
}
inline std::string* PermissionRequest::_internal_mutable_object_ref()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.object_ref_.Mutable(GetArenaForAllocation());
}
inline std::string* PermissionRequest::release_object_ref()
{
    // @@protoc_insertion_point(field_release:kidsmanagement.PermissionRequest.object_ref)
    if (!_internal_has_object_ref()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.object_ref_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.object_ref_.IsDefault()) {
        _impl_.object_ref_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void PermissionRequest::set_allocated_object_ref(std::string* object_ref)
{
    if (object_ref != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.object_ref_.SetAllocated(object_ref, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.object_ref_.IsDefault()) {
        _impl_.object_ref_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:kidsmanagement.PermissionRequest.object_ref)
}

// optional .kidsmanagement.PermissionRequestState state = 5;
inline bool PermissionRequest::_internal_has_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool PermissionRequest::has_state() const
{
    return _internal_has_state();
}
inline void PermissionRequest::clear_state()
{
    _impl_.state_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::kidsmanagement::PermissionRequestState PermissionRequest::_internal_state() const
{
    return static_cast<::kidsmanagement::PermissionRequestState>(_impl_.state_);
}
inline ::kidsmanagement::PermissionRequestState PermissionRequest::state() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.PermissionRequest.state)
    return _internal_state();
}
inline void PermissionRequest::_internal_set_state(::kidsmanagement::PermissionRequestState value)
{
    assert(::kidsmanagement::PermissionRequestState_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.state_ = value;
}
inline void PermissionRequest::set_state(::kidsmanagement::PermissionRequestState value)
{
    _internal_set_state(value);
    // @@protoc_insertion_point(field_set:kidsmanagement.PermissionRequest.state)
}

// -------------------------------------------------------------------

// WebsiteException

// optional string pattern = 1;
inline bool WebsiteException::_internal_has_pattern() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool WebsiteException::has_pattern() const
{
    return _internal_has_pattern();
}
inline void WebsiteException::clear_pattern()
{
    _impl_.pattern_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WebsiteException::pattern() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.WebsiteException.pattern)
    return _internal_pattern();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WebsiteException::set_pattern(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.pattern_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:kidsmanagement.WebsiteException.pattern)
}
inline std::string* WebsiteException::mutable_pattern()
{
    std::string* _s = _internal_mutable_pattern();
    // @@protoc_insertion_point(field_mutable:kidsmanagement.WebsiteException.pattern)
    return _s;
}
inline const std::string& WebsiteException::_internal_pattern() const
{
    return _impl_.pattern_.Get();
}
inline void WebsiteException::_internal_set_pattern(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* WebsiteException::_internal_mutable_pattern()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.pattern_.Mutable(GetArenaForAllocation());
}
inline std::string* WebsiteException::release_pattern()
{
    // @@protoc_insertion_point(field_release:kidsmanagement.WebsiteException.pattern)
    if (!_internal_has_pattern()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.pattern_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.pattern_.IsDefault()) {
        _impl_.pattern_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void WebsiteException::set_allocated_pattern(std::string* pattern)
{
    if (pattern != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.pattern_.SetAllocated(pattern, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.pattern_.IsDefault()) {
        _impl_.pattern_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:kidsmanagement.WebsiteException.pattern)
}

// optional .kidsmanagement.ExceptionType exception_type = 2;
inline bool WebsiteException::_internal_has_exception_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool WebsiteException::has_exception_type() const
{
    return _internal_has_exception_type();
}
inline void WebsiteException::clear_exception_type()
{
    _impl_.exception_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::kidsmanagement::ExceptionType WebsiteException::_internal_exception_type() const
{
    return static_cast<::kidsmanagement::ExceptionType>(_impl_.exception_type_);
}
inline ::kidsmanagement::ExceptionType WebsiteException::exception_type() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.WebsiteException.exception_type)
    return _internal_exception_type();
}
inline void WebsiteException::_internal_set_exception_type(::kidsmanagement::ExceptionType value)
{
    assert(::kidsmanagement::ExceptionType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.exception_type_ = value;
}
inline void WebsiteException::set_exception_type(::kidsmanagement::ExceptionType value)
{
    _internal_set_exception_type(value);
    // @@protoc_insertion_point(field_set:kidsmanagement.WebsiteException.exception_type)
}

// optional string icon_url = 3;
inline bool WebsiteException::_internal_has_icon_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool WebsiteException::has_icon_url() const
{
    return _internal_has_icon_url();
}
inline void WebsiteException::clear_icon_url()
{
    _impl_.icon_url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WebsiteException::icon_url() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.WebsiteException.icon_url)
    return _internal_icon_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WebsiteException::set_icon_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.icon_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:kidsmanagement.WebsiteException.icon_url)
}
inline std::string* WebsiteException::mutable_icon_url()
{
    std::string* _s = _internal_mutable_icon_url();
    // @@protoc_insertion_point(field_mutable:kidsmanagement.WebsiteException.icon_url)
    return _s;
}
inline const std::string& WebsiteException::_internal_icon_url() const
{
    return _impl_.icon_url_.Get();
}
inline void WebsiteException::_internal_set_icon_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.icon_url_.Set(value, GetArenaForAllocation());
}
inline std::string* WebsiteException::_internal_mutable_icon_url()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.icon_url_.Mutable(GetArenaForAllocation());
}
inline std::string* WebsiteException::release_icon_url()
{
    // @@protoc_insertion_point(field_release:kidsmanagement.WebsiteException.icon_url)
    if (!_internal_has_icon_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.icon_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.icon_url_.IsDefault()) {
        _impl_.icon_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void WebsiteException::set_allocated_icon_url(std::string* icon_url)
{
    if (icon_url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.icon_url_.SetAllocated(icon_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.icon_url_.IsDefault()) {
        _impl_.icon_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:kidsmanagement.WebsiteException.icon_url)
}

// -------------------------------------------------------------------

// DefineChromeTestStateRequest_UrlFilteringSettings

// optional .kidsmanagement.FilterLevel filter_level = 1;
inline bool DefineChromeTestStateRequest_UrlFilteringSettings::_internal_has_filter_level() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool DefineChromeTestStateRequest_UrlFilteringSettings::has_filter_level() const
{
    return _internal_has_filter_level();
}
inline void DefineChromeTestStateRequest_UrlFilteringSettings::clear_filter_level()
{
    _impl_.filter_level_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::kidsmanagement::FilterLevel DefineChromeTestStateRequest_UrlFilteringSettings::_internal_filter_level() const
{
    return static_cast<::kidsmanagement::FilterLevel>(_impl_.filter_level_);
}
inline ::kidsmanagement::FilterLevel DefineChromeTestStateRequest_UrlFilteringSettings::filter_level() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings.filter_level)
    return _internal_filter_level();
}
inline void DefineChromeTestStateRequest_UrlFilteringSettings::_internal_set_filter_level(::kidsmanagement::FilterLevel value)
{
    assert(::kidsmanagement::FilterLevel_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.filter_level_ = value;
}
inline void DefineChromeTestStateRequest_UrlFilteringSettings::set_filter_level(::kidsmanagement::FilterLevel value)
{
    _internal_set_filter_level(value);
    // @@protoc_insertion_point(field_set:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings.filter_level)
}

// repeated .kidsmanagement.WebsiteException exceptions = 2;
inline int DefineChromeTestStateRequest_UrlFilteringSettings::_internal_exceptions_size() const
{
    return _impl_.exceptions_.size();
}
inline int DefineChromeTestStateRequest_UrlFilteringSettings::exceptions_size() const
{
    return _internal_exceptions_size();
}
inline void DefineChromeTestStateRequest_UrlFilteringSettings::clear_exceptions()
{
    _impl_.exceptions_.Clear();
}
inline ::kidsmanagement::WebsiteException* DefineChromeTestStateRequest_UrlFilteringSettings::mutable_exceptions(int index)
{
    // @@protoc_insertion_point(field_mutable:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings.exceptions)
    return _impl_.exceptions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::kidsmanagement::WebsiteException>* DefineChromeTestStateRequest_UrlFilteringSettings::mutable_exceptions()
{
    // @@protoc_insertion_point(field_mutable_list:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings.exceptions)
    return &_impl_.exceptions_;
}
inline const ::kidsmanagement::WebsiteException& DefineChromeTestStateRequest_UrlFilteringSettings::_internal_exceptions(int index) const
{
    return _impl_.exceptions_.Get(index);
}
inline const ::kidsmanagement::WebsiteException& DefineChromeTestStateRequest_UrlFilteringSettings::exceptions(int index) const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings.exceptions)
    return _internal_exceptions(index);
}
inline ::kidsmanagement::WebsiteException* DefineChromeTestStateRequest_UrlFilteringSettings::_internal_add_exceptions()
{
    return _impl_.exceptions_.Add();
}
inline ::kidsmanagement::WebsiteException* DefineChromeTestStateRequest_UrlFilteringSettings::add_exceptions()
{
    ::kidsmanagement::WebsiteException* _add = _internal_add_exceptions();
    // @@protoc_insertion_point(field_add:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings.exceptions)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::kidsmanagement::WebsiteException>&
DefineChromeTestStateRequest_UrlFilteringSettings::exceptions() const
{
    // @@protoc_insertion_point(field_list:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings.exceptions)
    return _impl_.exceptions_;
}

// optional bool websites_can_request_permissions = 3;
inline bool DefineChromeTestStateRequest_UrlFilteringSettings::_internal_has_websites_can_request_permissions() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool DefineChromeTestStateRequest_UrlFilteringSettings::has_websites_can_request_permissions() const
{
    return _internal_has_websites_can_request_permissions();
}
inline void DefineChromeTestStateRequest_UrlFilteringSettings::clear_websites_can_request_permissions()
{
    _impl_.websites_can_request_permissions_ = false;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DefineChromeTestStateRequest_UrlFilteringSettings::_internal_websites_can_request_permissions() const
{
    return _impl_.websites_can_request_permissions_;
}
inline bool DefineChromeTestStateRequest_UrlFilteringSettings::websites_can_request_permissions() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings.websites_can_request_permissions)
    return _internal_websites_can_request_permissions();
}
inline void DefineChromeTestStateRequest_UrlFilteringSettings::_internal_set_websites_can_request_permissions(bool value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.websites_can_request_permissions_ = value;
}
inline void DefineChromeTestStateRequest_UrlFilteringSettings::set_websites_can_request_permissions(bool value)
{
    _internal_set_websites_can_request_permissions(value);
    // @@protoc_insertion_point(field_set:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings.websites_can_request_permissions)
}

// optional bool can_block_cookies = 4;
inline bool DefineChromeTestStateRequest_UrlFilteringSettings::_internal_has_can_block_cookies() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool DefineChromeTestStateRequest_UrlFilteringSettings::has_can_block_cookies() const
{
    return _internal_has_can_block_cookies();
}
inline void DefineChromeTestStateRequest_UrlFilteringSettings::clear_can_block_cookies()
{
    _impl_.can_block_cookies_ = false;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool DefineChromeTestStateRequest_UrlFilteringSettings::_internal_can_block_cookies() const
{
    return _impl_.can_block_cookies_;
}
inline bool DefineChromeTestStateRequest_UrlFilteringSettings::can_block_cookies() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings.can_block_cookies)
    return _internal_can_block_cookies();
}
inline void DefineChromeTestStateRequest_UrlFilteringSettings::_internal_set_can_block_cookies(bool value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.can_block_cookies_ = value;
}
inline void DefineChromeTestStateRequest_UrlFilteringSettings::set_can_block_cookies(bool value)
{
    _internal_set_can_block_cookies(value);
    // @@protoc_insertion_point(field_set:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings.can_block_cookies)
}

// optional bool can_add_extensions = 5;
inline bool DefineChromeTestStateRequest_UrlFilteringSettings::_internal_has_can_add_extensions() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool DefineChromeTestStateRequest_UrlFilteringSettings::has_can_add_extensions() const
{
    return _internal_has_can_add_extensions();
}
inline void DefineChromeTestStateRequest_UrlFilteringSettings::clear_can_add_extensions()
{
    _impl_.can_add_extensions_ = false;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool DefineChromeTestStateRequest_UrlFilteringSettings::_internal_can_add_extensions() const
{
    return _impl_.can_add_extensions_;
}
inline bool DefineChromeTestStateRequest_UrlFilteringSettings::can_add_extensions() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings.can_add_extensions)
    return _internal_can_add_extensions();
}
inline void DefineChromeTestStateRequest_UrlFilteringSettings::_internal_set_can_add_extensions(bool value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.can_add_extensions_ = value;
}
inline void DefineChromeTestStateRequest_UrlFilteringSettings::set_can_add_extensions(bool value)
{
    _internal_set_can_add_extensions(value);
    // @@protoc_insertion_point(field_set:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings.can_add_extensions)
}

// -------------------------------------------------------------------

// DefineChromeTestStateRequest

// optional string child_id = 1;
inline bool DefineChromeTestStateRequest::_internal_has_child_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool DefineChromeTestStateRequest::has_child_id() const
{
    return _internal_has_child_id();
}
inline void DefineChromeTestStateRequest::clear_child_id()
{
    _impl_.child_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DefineChromeTestStateRequest::child_id() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.DefineChromeTestStateRequest.child_id)
    return _internal_child_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DefineChromeTestStateRequest::set_child_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.child_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:kidsmanagement.DefineChromeTestStateRequest.child_id)
}
inline std::string* DefineChromeTestStateRequest::mutable_child_id()
{
    std::string* _s = _internal_mutable_child_id();
    // @@protoc_insertion_point(field_mutable:kidsmanagement.DefineChromeTestStateRequest.child_id)
    return _s;
}
inline const std::string& DefineChromeTestStateRequest::_internal_child_id() const
{
    return _impl_.child_id_.Get();
}
inline void DefineChromeTestStateRequest::_internal_set_child_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.child_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DefineChromeTestStateRequest::_internal_mutable_child_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.child_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DefineChromeTestStateRequest::release_child_id()
{
    // @@protoc_insertion_point(field_release:kidsmanagement.DefineChromeTestStateRequest.child_id)
    if (!_internal_has_child_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.child_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.child_id_.IsDefault()) {
        _impl_.child_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DefineChromeTestStateRequest::set_allocated_child_id(std::string* child_id)
{
    if (child_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.child_id_.SetAllocated(child_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.child_id_.IsDefault()) {
        _impl_.child_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:kidsmanagement.DefineChromeTestStateRequest.child_id)
}

// optional .kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings url_filtering_settings = 2;
inline bool DefineChromeTestStateRequest::_internal_has_url_filtering_settings() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.url_filtering_settings_ != nullptr);
    return value;
}
inline bool DefineChromeTestStateRequest::has_url_filtering_settings() const
{
    return _internal_has_url_filtering_settings();
}
inline void DefineChromeTestStateRequest::clear_url_filtering_settings()
{
    if (_impl_.url_filtering_settings_ != nullptr)
        _impl_.url_filtering_settings_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings& DefineChromeTestStateRequest::_internal_url_filtering_settings() const
{
    const ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* p = _impl_.url_filtering_settings_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings&>(
                            ::kidsmanagement::_DefineChromeTestStateRequest_UrlFilteringSettings_default_instance_);
}
inline const ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings& DefineChromeTestStateRequest::url_filtering_settings() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.DefineChromeTestStateRequest.url_filtering_settings)
    return _internal_url_filtering_settings();
}
inline void DefineChromeTestStateRequest::unsafe_arena_set_allocated_url_filtering_settings(
    ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* url_filtering_settings)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.url_filtering_settings_);
    }
    _impl_.url_filtering_settings_ = url_filtering_settings;
    if (url_filtering_settings) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kidsmanagement.DefineChromeTestStateRequest.url_filtering_settings)
}
inline ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* DefineChromeTestStateRequest::release_url_filtering_settings()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* temp = _impl_.url_filtering_settings_;
    _impl_.url_filtering_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* DefineChromeTestStateRequest::unsafe_arena_release_url_filtering_settings()
{
    // @@protoc_insertion_point(field_release:kidsmanagement.DefineChromeTestStateRequest.url_filtering_settings)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* temp = _impl_.url_filtering_settings_;
    _impl_.url_filtering_settings_ = nullptr;
    return temp;
}
inline ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* DefineChromeTestStateRequest::_internal_mutable_url_filtering_settings()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.url_filtering_settings_ == nullptr) {
        auto* p = CreateMaybeMessage<::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings>(GetArenaForAllocation());
        _impl_.url_filtering_settings_ = p;
    }
    return _impl_.url_filtering_settings_;
}
inline ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* DefineChromeTestStateRequest::mutable_url_filtering_settings()
{
    ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* _msg = _internal_mutable_url_filtering_settings();
    // @@protoc_insertion_point(field_mutable:kidsmanagement.DefineChromeTestStateRequest.url_filtering_settings)
    return _msg;
}
inline void DefineChromeTestStateRequest::set_allocated_url_filtering_settings(
    ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings* url_filtering_settings)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.url_filtering_settings_;
    }
    if (url_filtering_settings) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(url_filtering_settings);
        if (message_arena != submessage_arena) {
            url_filtering_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, url_filtering_settings, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.url_filtering_settings_ = url_filtering_settings;
    // @@protoc_insertion_point(field_set_allocated:kidsmanagement.DefineChromeTestStateRequest.url_filtering_settings)
}

// -------------------------------------------------------------------

// ResetChromeTestStateRequest

// optional string child_id = 1;
inline bool ResetChromeTestStateRequest::_internal_has_child_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ResetChromeTestStateRequest::has_child_id() const
{
    return _internal_has_child_id();
}
inline void ResetChromeTestStateRequest::clear_child_id()
{
    _impl_.child_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResetChromeTestStateRequest::child_id() const
{
    // @@protoc_insertion_point(field_get:kidsmanagement.ResetChromeTestStateRequest.child_id)
    return _internal_child_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ResetChromeTestStateRequest::set_child_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.child_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:kidsmanagement.ResetChromeTestStateRequest.child_id)
}
inline std::string* ResetChromeTestStateRequest::mutable_child_id()
{
    std::string* _s = _internal_mutable_child_id();
    // @@protoc_insertion_point(field_mutable:kidsmanagement.ResetChromeTestStateRequest.child_id)
    return _s;
}
inline const std::string& ResetChromeTestStateRequest::_internal_child_id() const
{
    return _impl_.child_id_.Get();
}
inline void ResetChromeTestStateRequest::_internal_set_child_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.child_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResetChromeTestStateRequest::_internal_mutable_child_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.child_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResetChromeTestStateRequest::release_child_id()
{
    // @@protoc_insertion_point(field_release:kidsmanagement.ResetChromeTestStateRequest.child_id)
    if (!_internal_has_child_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.child_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.child_id_.IsDefault()) {
        _impl_.child_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ResetChromeTestStateRequest::set_allocated_child_id(std::string* child_id)
{
    if (child_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.child_id_.SetAllocated(child_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.child_id_.IsDefault()) {
        _impl_.child_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:kidsmanagement.ResetChromeTestStateRequest.child_id)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace kidsmanagement

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::kidsmanagement::ClassifyUrlResponse_DisplayClassification> : ::std::true_type { };
template <> struct is_proto_enum<::kidsmanagement::ExceptionType> : ::std::true_type { };
template <> struct is_proto_enum<::kidsmanagement::FilterLevel> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_kidsmanagement_5fmessages_2eproto
