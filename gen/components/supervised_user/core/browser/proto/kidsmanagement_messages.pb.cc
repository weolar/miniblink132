// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kidsmanagement_messages.proto

#include "kidsmanagement_messages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace kidsmanagement {
PROTOBUF_CONSTEXPR ListMembersRequest::ListMembersRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.allow_empty_family_)*/ false }
{
}
struct ListMembersRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ListMembersRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ListMembersRequestDefaultTypeInternal()
    {
    }
    union {
        ListMembersRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListMembersRequestDefaultTypeInternal _ListMembersRequest_default_instance_;
PROTOBUF_CONSTEXPR ListMembersResponse::ListMembersResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.members_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ListMembersResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ListMembersResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ListMembersResponseDefaultTypeInternal()
    {
    }
    union {
        ListMembersResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListMembersResponseDefaultTypeInternal
    _ListMembersResponse_default_instance_;
PROTOBUF_CONSTEXPR ClassifyUrlRequest::ClassifyUrlRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.region_code_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClassifyUrlRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClassifyUrlRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClassifyUrlRequestDefaultTypeInternal()
    {
    }
    union {
        ClassifyUrlRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClassifyUrlRequestDefaultTypeInternal _ClassifyUrlRequest_default_instance_;
PROTOBUF_CONSTEXPR ClassifyUrlResponse::ClassifyUrlResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.display_classification_)*/ 0 }
{
}
struct ClassifyUrlResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClassifyUrlResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClassifyUrlResponseDefaultTypeInternal()
    {
    }
    union {
        ClassifyUrlResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClassifyUrlResponseDefaultTypeInternal
    _ClassifyUrlResponse_default_instance_;
PROTOBUF_CONSTEXPR CreatePermissionRequestResponse::CreatePermissionRequestResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.permission_request_)*/ nullptr }
{
}
struct CreatePermissionRequestResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CreatePermissionRequestResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CreatePermissionRequestResponseDefaultTypeInternal()
    {
    }
    union {
        CreatePermissionRequestResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CreatePermissionRequestResponseDefaultTypeInternal
    _CreatePermissionRequestResponse_default_instance_;
PROTOBUF_CONSTEXPR PermissionRequest::PermissionRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.object_ref_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.state_)*/ 0,
        /*decltype(_impl_.event_type_)*/ 13 }
{
}
struct PermissionRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PermissionRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PermissionRequestDefaultTypeInternal()
    {
    }
    union {
        PermissionRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionRequestDefaultTypeInternal _PermissionRequest_default_instance_;
PROTOBUF_CONSTEXPR WebsiteException::WebsiteException(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.pattern_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.icon_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.exception_type_)*/ 0 }
{
}
struct WebsiteExceptionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WebsiteExceptionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WebsiteExceptionDefaultTypeInternal()
    {
    }
    union {
        WebsiteException _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WebsiteExceptionDefaultTypeInternal _WebsiteException_default_instance_;
PROTOBUF_CONSTEXPR DefineChromeTestStateRequest_UrlFilteringSettings::DefineChromeTestStateRequest_UrlFilteringSettings(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.exceptions_)*/ {},
        /*decltype(_impl_.filter_level_)*/ 0, /*decltype(_impl_.websites_can_request_permissions_)*/ false, /*decltype(_impl_.can_block_cookies_)*/ false,
        /*decltype(_impl_.can_add_extensions_)*/ false }
{
}
struct DefineChromeTestStateRequest_UrlFilteringSettingsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DefineChromeTestStateRequest_UrlFilteringSettingsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DefineChromeTestStateRequest_UrlFilteringSettingsDefaultTypeInternal()
    {
    }
    union {
        DefineChromeTestStateRequest_UrlFilteringSettings _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DefineChromeTestStateRequest_UrlFilteringSettingsDefaultTypeInternal
    _DefineChromeTestStateRequest_UrlFilteringSettings_default_instance_;
PROTOBUF_CONSTEXPR DefineChromeTestStateRequest::DefineChromeTestStateRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.child_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.url_filtering_settings_)*/ nullptr }
{
}
struct DefineChromeTestStateRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DefineChromeTestStateRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DefineChromeTestStateRequestDefaultTypeInternal()
    {
    }
    union {
        DefineChromeTestStateRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DefineChromeTestStateRequestDefaultTypeInternal
    _DefineChromeTestStateRequest_default_instance_;
PROTOBUF_CONSTEXPR ResetChromeTestStateRequest::ResetChromeTestStateRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.child_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ResetChromeTestStateRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ResetChromeTestStateRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ResetChromeTestStateRequestDefaultTypeInternal()
    {
    }
    union {
        ResetChromeTestStateRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResetChromeTestStateRequestDefaultTypeInternal
    _ResetChromeTestStateRequest_default_instance_;
} // namespace kidsmanagement
namespace kidsmanagement {
bool ClassifyUrlResponse_DisplayClassification_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClassifyUrlResponse_DisplayClassification_strings[3] = {};

static const char ClassifyUrlResponse_DisplayClassification_names[] = "ALLOWED"
                                                                      "RESTRICTED"
                                                                      "UNKNOWN_DISPLAY_CLASSIFICATION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClassifyUrlResponse_DisplayClassification_entries[] = {
    { { ClassifyUrlResponse_DisplayClassification_names + 0, 7 }, 1 },
    { { ClassifyUrlResponse_DisplayClassification_names + 7, 10 }, 2 },
    { { ClassifyUrlResponse_DisplayClassification_names + 17, 30 }, 0 },
};

static const int ClassifyUrlResponse_DisplayClassification_entries_by_number[] = {
    2, // 0 -> UNKNOWN_DISPLAY_CLASSIFICATION
    0, // 1 -> ALLOWED
    1, // 2 -> RESTRICTED
};

const std::string& ClassifyUrlResponse_DisplayClassification_Name(ClassifyUrlResponse_DisplayClassification value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClassifyUrlResponse_DisplayClassification_entries,
        ClassifyUrlResponse_DisplayClassification_entries_by_number, 3, ClassifyUrlResponse_DisplayClassification_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ClassifyUrlResponse_DisplayClassification_entries, ClassifyUrlResponse_DisplayClassification_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClassifyUrlResponse_DisplayClassification_strings[idx].get();
}
bool ClassifyUrlResponse_DisplayClassification_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClassifyUrlResponse_DisplayClassification* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClassifyUrlResponse_DisplayClassification_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ClassifyUrlResponse_DisplayClassification>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClassifyUrlResponse_DisplayClassification ClassifyUrlResponse::UNKNOWN_DISPLAY_CLASSIFICATION;
constexpr ClassifyUrlResponse_DisplayClassification ClassifyUrlResponse::ALLOWED;
constexpr ClassifyUrlResponse_DisplayClassification ClassifyUrlResponse::RESTRICTED;
constexpr ClassifyUrlResponse_DisplayClassification ClassifyUrlResponse::DisplayClassification_MIN;
constexpr ClassifyUrlResponse_DisplayClassification ClassifyUrlResponse::DisplayClassification_MAX;
constexpr int ClassifyUrlResponse::DisplayClassification_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExceptionType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExceptionType_strings[3] = {};

static const char ExceptionType_names[] = "ALLOW"
                                          "BLOCK"
                                          "EXCEPTION_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExceptionType_entries[] = {
    { { ExceptionType_names + 0, 5 }, 1 },
    { { ExceptionType_names + 5, 5 }, 2 },
    { { ExceptionType_names + 10, 26 }, 0 },
};

static const int ExceptionType_entries_by_number[] = {
    2, // 0 -> EXCEPTION_TYPE_UNSPECIFIED
    0, // 1 -> ALLOW
    1, // 2 -> BLOCK
};

const std::string& ExceptionType_Name(ExceptionType value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ExceptionType_entries, ExceptionType_entries_by_number, 3, ExceptionType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ExceptionType_entries, ExceptionType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ExceptionType_strings[idx].get();
}
bool ExceptionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExceptionType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ExceptionType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ExceptionType>(int_value);
    }
    return success;
}
bool FilterLevel_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FilterLevel_strings[4] = {};

static const char FilterLevel_names[] = "ALLOW_BY_DEFAULT"
                                        "BLOCK_BY_DEFAULT"
                                        "FILTER_LEVEL_UNSPECIFIED"
                                        "SAFE_SITES";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FilterLevel_entries[] = {
    { { FilterLevel_names + 0, 16 }, 1 },
    { { FilterLevel_names + 16, 16 }, 3 },
    { { FilterLevel_names + 32, 24 }, 0 },
    { { FilterLevel_names + 56, 10 }, 2 },
};

static const int FilterLevel_entries_by_number[] = {
    2, // 0 -> FILTER_LEVEL_UNSPECIFIED
    0, // 1 -> ALLOW_BY_DEFAULT
    3, // 2 -> SAFE_SITES
    1, // 3 -> BLOCK_BY_DEFAULT
};

const std::string& FilterLevel_Name(FilterLevel value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(FilterLevel_entries, FilterLevel_entries_by_number, 4, FilterLevel_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(FilterLevel_entries, FilterLevel_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : FilterLevel_strings[idx].get();
}
bool FilterLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilterLevel* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(FilterLevel_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<FilterLevel>(int_value);
    }
    return success;
}

// ===================================================================

class ListMembersRequest::_Internal {
public:
    using HasBits = decltype(std::declval<ListMembersRequest>()._impl_._has_bits_);
    static void set_has_allow_empty_family(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ListMembersRequest::ListMembersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:kidsmanagement.ListMembersRequest)
}
ListMembersRequest::ListMembersRequest(const ListMembersRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ListMembersRequest* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.allow_empty_family_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.allow_empty_family_ = from._impl_.allow_empty_family_;
    // @@protoc_insertion_point(copy_constructor:kidsmanagement.ListMembersRequest)
}

inline void ListMembersRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.allow_empty_family_) { false } };
}

ListMembersRequest::~ListMembersRequest()
{
    // @@protoc_insertion_point(destructor:kidsmanagement.ListMembersRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ListMembersRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ListMembersRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ListMembersRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:kidsmanagement.ListMembersRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.allow_empty_family_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ListMembersRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bool allow_empty_family = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_allow_empty_family(&has_bits);
                _impl_.allow_empty_family_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ListMembersRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:kidsmanagement.ListMembersRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool allow_empty_family = 4;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_allow_empty_family(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:kidsmanagement.ListMembersRequest)
    return target;
}

size_t ListMembersRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:kidsmanagement.ListMembersRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional bool allow_empty_family = 4;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + 1;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ListMembersRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ListMembersRequest*>(&from));
}

void ListMembersRequest::MergeFrom(const ListMembersRequest& from)
{
    ListMembersRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:kidsmanagement.ListMembersRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_allow_empty_family()) {
        _this->_internal_set_allow_empty_family(from._internal_allow_empty_family());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ListMembersRequest::CopyFrom(const ListMembersRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:kidsmanagement.ListMembersRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ListMembersRequest::IsInitialized() const
{
    return true;
}

void ListMembersRequest::InternalSwap(ListMembersRequest* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.allow_empty_family_, other->_impl_.allow_empty_family_);
}

std::string ListMembersRequest::GetTypeName() const
{
    return "kidsmanagement.ListMembersRequest";
}

// ===================================================================

class ListMembersResponse::_Internal {
public:
};

void ListMembersResponse::clear_members()
{
    _impl_.members_.Clear();
}
ListMembersResponse::ListMembersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:kidsmanagement.ListMembersResponse)
}
ListMembersResponse::ListMembersResponse(const ListMembersResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ListMembersResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.members_) { from._impl_.members_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:kidsmanagement.ListMembersResponse)
}

inline void ListMembersResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.members_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ListMembersResponse::~ListMembersResponse()
{
    // @@protoc_insertion_point(destructor:kidsmanagement.ListMembersResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ListMembersResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.members_.~RepeatedPtrField();
}

void ListMembersResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ListMembersResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:kidsmanagement.ListMembersResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.members_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ListMembersResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .kidsmanagement.FamilyMember members = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_members(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ListMembersResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:kidsmanagement.ListMembersResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .kidsmanagement.FamilyMember members = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_members_size()); i < n; i++) {
        const auto& repfield = this->_internal_members(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:kidsmanagement.ListMembersResponse)
    return target;
}

size_t ListMembersResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:kidsmanagement.ListMembersResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .kidsmanagement.FamilyMember members = 1;
    total_size += 1UL * this->_internal_members_size();
    for (const auto& msg : this->_impl_.members_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ListMembersResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ListMembersResponse*>(&from));
}

void ListMembersResponse::MergeFrom(const ListMembersResponse& from)
{
    ListMembersResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:kidsmanagement.ListMembersResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.members_.MergeFrom(from._impl_.members_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ListMembersResponse::CopyFrom(const ListMembersResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:kidsmanagement.ListMembersResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ListMembersResponse::IsInitialized() const
{
    return true;
}

void ListMembersResponse::InternalSwap(ListMembersResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.members_.InternalSwap(&other->_impl_.members_);
}

std::string ListMembersResponse::GetTypeName() const
{
    return "kidsmanagement.ListMembersResponse";
}

// ===================================================================

class ClassifyUrlRequest::_Internal {
public:
    using HasBits = decltype(std::declval<ClassifyUrlRequest>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_region_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ClassifyUrlRequest::ClassifyUrlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:kidsmanagement.ClassifyUrlRequest)
}
ClassifyUrlRequest::ClassifyUrlRequest(const ClassifyUrlRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClassifyUrlRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {},
        decltype(_impl_.region_code_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _impl_.region_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_region_code()) {
        _this->_impl_.region_code_.Set(from._internal_region_code(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:kidsmanagement.ClassifyUrlRequest)
}

inline void ClassifyUrlRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {}, decltype(_impl_.region_code_) {} };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClassifyUrlRequest::~ClassifyUrlRequest()
{
    // @@protoc_insertion_point(destructor:kidsmanagement.ClassifyUrlRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClassifyUrlRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
    _impl_.region_code_.Destroy();
}

void ClassifyUrlRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClassifyUrlRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:kidsmanagement.ClassifyUrlRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.region_code_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClassifyUrlRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string region_code = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_region_code();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClassifyUrlRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:kidsmanagement.ClassifyUrlRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_url(), target);
    }

    // optional string region_code = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_region_code(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:kidsmanagement.ClassifyUrlRequest)
    return target;
}

size_t ClassifyUrlRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:kidsmanagement.ClassifyUrlRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string url = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional string region_code = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_region_code());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClassifyUrlRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClassifyUrlRequest*>(&from));
}

void ClassifyUrlRequest::MergeFrom(const ClassifyUrlRequest& from)
{
    ClassifyUrlRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:kidsmanagement.ClassifyUrlRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_region_code(from._internal_region_code());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClassifyUrlRequest::CopyFrom(const ClassifyUrlRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:kidsmanagement.ClassifyUrlRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClassifyUrlRequest::IsInitialized() const
{
    return true;
}

void ClassifyUrlRequest::InternalSwap(ClassifyUrlRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.region_code_, lhs_arena, &other->_impl_.region_code_, rhs_arena);
}

std::string ClassifyUrlRequest::GetTypeName() const
{
    return "kidsmanagement.ClassifyUrlRequest";
}

// ===================================================================

class ClassifyUrlResponse::_Internal {
public:
    using HasBits = decltype(std::declval<ClassifyUrlResponse>()._impl_._has_bits_);
    static void set_has_display_classification(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ClassifyUrlResponse::ClassifyUrlResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:kidsmanagement.ClassifyUrlResponse)
}
ClassifyUrlResponse::ClassifyUrlResponse(const ClassifyUrlResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClassifyUrlResponse* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.display_classification_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.display_classification_ = from._impl_.display_classification_;
    // @@protoc_insertion_point(copy_constructor:kidsmanagement.ClassifyUrlResponse)
}

inline void ClassifyUrlResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.display_classification_) { 0 } };
}

ClassifyUrlResponse::~ClassifyUrlResponse()
{
    // @@protoc_insertion_point(destructor:kidsmanagement.ClassifyUrlResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClassifyUrlResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClassifyUrlResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClassifyUrlResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:kidsmanagement.ClassifyUrlResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.display_classification_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClassifyUrlResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .kidsmanagement.ClassifyUrlResponse.DisplayClassification display_classification = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::kidsmanagement::ClassifyUrlResponse_DisplayClassification_IsValid(val))) {
                    _internal_set_display_classification(static_cast<::kidsmanagement::ClassifyUrlResponse_DisplayClassification>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClassifyUrlResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:kidsmanagement.ClassifyUrlResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .kidsmanagement.ClassifyUrlResponse.DisplayClassification display_classification = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_display_classification(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:kidsmanagement.ClassifyUrlResponse)
    return target;
}

size_t ClassifyUrlResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:kidsmanagement.ClassifyUrlResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .kidsmanagement.ClassifyUrlResponse.DisplayClassification display_classification = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_display_classification());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClassifyUrlResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClassifyUrlResponse*>(&from));
}

void ClassifyUrlResponse::MergeFrom(const ClassifyUrlResponse& from)
{
    ClassifyUrlResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:kidsmanagement.ClassifyUrlResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_display_classification()) {
        _this->_internal_set_display_classification(from._internal_display_classification());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClassifyUrlResponse::CopyFrom(const ClassifyUrlResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:kidsmanagement.ClassifyUrlResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClassifyUrlResponse::IsInitialized() const
{
    return true;
}

void ClassifyUrlResponse::InternalSwap(ClassifyUrlResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.display_classification_, other->_impl_.display_classification_);
}

std::string ClassifyUrlResponse::GetTypeName() const
{
    return "kidsmanagement.ClassifyUrlResponse";
}

// ===================================================================

class CreatePermissionRequestResponse::_Internal {
public:
    using HasBits = decltype(std::declval<CreatePermissionRequestResponse>()._impl_._has_bits_);
    static const ::kidsmanagement::PermissionRequest& permission_request(const CreatePermissionRequestResponse* msg);
    static void set_has_permission_request(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::kidsmanagement::PermissionRequest& CreatePermissionRequestResponse::_Internal::permission_request(const CreatePermissionRequestResponse* msg)
{
    return *msg->_impl_.permission_request_;
}
CreatePermissionRequestResponse::CreatePermissionRequestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:kidsmanagement.CreatePermissionRequestResponse)
}
CreatePermissionRequestResponse::CreatePermissionRequestResponse(const CreatePermissionRequestResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CreatePermissionRequestResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.permission_request_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_permission_request()) {
        _this->_impl_.permission_request_ = new ::kidsmanagement::PermissionRequest(*from._impl_.permission_request_);
    }
    // @@protoc_insertion_point(copy_constructor:kidsmanagement.CreatePermissionRequestResponse)
}

inline void CreatePermissionRequestResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.permission_request_) { nullptr } };
}

CreatePermissionRequestResponse::~CreatePermissionRequestResponse()
{
    // @@protoc_insertion_point(destructor:kidsmanagement.CreatePermissionRequestResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CreatePermissionRequestResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.permission_request_;
}

void CreatePermissionRequestResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CreatePermissionRequestResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:kidsmanagement.CreatePermissionRequestResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.permission_request_ != nullptr);
        _impl_.permission_request_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CreatePermissionRequestResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .kidsmanagement.PermissionRequest permission_request = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_permission_request(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CreatePermissionRequestResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:kidsmanagement.CreatePermissionRequestResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .kidsmanagement.PermissionRequest permission_request = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::permission_request(this), _Internal::permission_request(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:kidsmanagement.CreatePermissionRequestResponse)
    return target;
}

size_t CreatePermissionRequestResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:kidsmanagement.CreatePermissionRequestResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .kidsmanagement.PermissionRequest permission_request = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.permission_request_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CreatePermissionRequestResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CreatePermissionRequestResponse*>(&from));
}

void CreatePermissionRequestResponse::MergeFrom(const CreatePermissionRequestResponse& from)
{
    CreatePermissionRequestResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:kidsmanagement.CreatePermissionRequestResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_permission_request()) {
        _this->_internal_mutable_permission_request()->::kidsmanagement::PermissionRequest::MergeFrom(from._internal_permission_request());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CreatePermissionRequestResponse::CopyFrom(const CreatePermissionRequestResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:kidsmanagement.CreatePermissionRequestResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CreatePermissionRequestResponse::IsInitialized() const
{
    return true;
}

void CreatePermissionRequestResponse::InternalSwap(CreatePermissionRequestResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.permission_request_, other->_impl_.permission_request_);
}

std::string CreatePermissionRequestResponse::GetTypeName() const
{
    return "kidsmanagement.CreatePermissionRequestResponse";
}

// ===================================================================

class PermissionRequest::_Internal {
public:
    using HasBits = decltype(std::declval<PermissionRequest>()._impl_._has_bits_);
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_event_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_object_ref(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

PermissionRequest::PermissionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:kidsmanagement.PermissionRequest)
}
PermissionRequest::PermissionRequest(const PermissionRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PermissionRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.id_) {},
        decltype(_impl_.object_ref_) {}, decltype(_impl_.state_) {}, decltype(_impl_.event_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_id()) {
        _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
    }
    _impl_.object_ref_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_ref_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_object_ref()) {
        _this->_impl_.object_ref_.Set(from._internal_object_ref(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.state_, &from._impl_.state_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.event_type_) - reinterpret_cast<char*>(&_impl_.state_)) + sizeof(_impl_.event_type_));
    // @@protoc_insertion_point(copy_constructor:kidsmanagement.PermissionRequest)
}

inline void PermissionRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.id_) {}, decltype(_impl_.object_ref_) {},
        decltype(_impl_.state_) { 0 }, decltype(_impl_.event_type_) { 13 } };
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_ref_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.object_ref_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PermissionRequest::~PermissionRequest()
{
    // @@protoc_insertion_point(destructor:kidsmanagement.PermissionRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PermissionRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.id_.Destroy();
    _impl_.object_ref_.Destroy();
}

void PermissionRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PermissionRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:kidsmanagement.PermissionRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.object_ref_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000000cu) {
        _impl_.state_ = 0;
        _impl_.event_type_ = 13;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PermissionRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string object_ref = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_object_ref();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .kidsmanagement.PermissionRequestState state = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::kidsmanagement::PermissionRequestState_IsValid(val))) {
                    _internal_set_state(static_cast<::kidsmanagement::PermissionRequestState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .kidsmanagement.FamilyEventType event_type = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::kidsmanagement::FamilyEventType_IsValid(val))) {
                    _internal_set_event_type(static_cast<::kidsmanagement::FamilyEventType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PermissionRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:kidsmanagement.PermissionRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_id(), target);
    }

    // optional string object_ref = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_object_ref(), target);
    }

    // optional .kidsmanagement.PermissionRequestState state = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_state(), target);
    }

    // optional .kidsmanagement.FamilyEventType event_type = 10;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(10, this->_internal_event_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:kidsmanagement.PermissionRequest)
    return target;
}

size_t PermissionRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:kidsmanagement.PermissionRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_id());
        }

        // optional string object_ref = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_object_ref());
        }

        // optional .kidsmanagement.PermissionRequestState state = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
        }

        // optional .kidsmanagement.FamilyEventType event_type = 10;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_event_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PermissionRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PermissionRequest*>(&from));
}

void PermissionRequest::MergeFrom(const PermissionRequest& from)
{
    PermissionRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:kidsmanagement.PermissionRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_id(from._internal_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_object_ref(from._internal_object_ref());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.state_ = from._impl_.state_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.event_type_ = from._impl_.event_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionRequest::CopyFrom(const PermissionRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:kidsmanagement.PermissionRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PermissionRequest::IsInitialized() const
{
    return true;
}

void PermissionRequest::InternalSwap(PermissionRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena, &other->_impl_.id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.object_ref_, lhs_arena, &other->_impl_.object_ref_, rhs_arena);
    swap(_impl_.state_, other->_impl_.state_);
    swap(_impl_.event_type_, other->_impl_.event_type_);
}

std::string PermissionRequest::GetTypeName() const
{
    return "kidsmanagement.PermissionRequest";
}

// ===================================================================

class WebsiteException::_Internal {
public:
    using HasBits = decltype(std::declval<WebsiteException>()._impl_._has_bits_);
    static void set_has_pattern(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_exception_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_icon_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

WebsiteException::WebsiteException(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:kidsmanagement.WebsiteException)
}
WebsiteException::WebsiteException(const WebsiteException& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WebsiteException* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.pattern_) {},
        decltype(_impl_.icon_url_) {}, decltype(_impl_.exception_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.pattern_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pattern_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_pattern()) {
        _this->_impl_.pattern_.Set(from._internal_pattern(), _this->GetArenaForAllocation());
    }
    _impl_.icon_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_icon_url()) {
        _this->_impl_.icon_url_.Set(from._internal_icon_url(), _this->GetArenaForAllocation());
    }
    _this->_impl_.exception_type_ = from._impl_.exception_type_;
    // @@protoc_insertion_point(copy_constructor:kidsmanagement.WebsiteException)
}

inline void WebsiteException::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.pattern_) {}, decltype(_impl_.icon_url_) {},
        decltype(_impl_.exception_type_) { 0 } };
    _impl_.pattern_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pattern_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WebsiteException::~WebsiteException()
{
    // @@protoc_insertion_point(destructor:kidsmanagement.WebsiteException)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WebsiteException::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.pattern_.Destroy();
    _impl_.icon_url_.Destroy();
}

void WebsiteException::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WebsiteException::Clear()
{
    // @@protoc_insertion_point(message_clear_start:kidsmanagement.WebsiteException)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.pattern_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.icon_url_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.exception_type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WebsiteException::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string pattern = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_pattern();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .kidsmanagement.ExceptionType exception_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::kidsmanagement::ExceptionType_IsValid(val))) {
                    _internal_set_exception_type(static_cast<::kidsmanagement::ExceptionType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string icon_url = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_icon_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WebsiteException::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:kidsmanagement.WebsiteException)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string pattern = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_pattern(), target);
    }

    // optional .kidsmanagement.ExceptionType exception_type = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_exception_type(), target);
    }

    // optional string icon_url = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_icon_url(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:kidsmanagement.WebsiteException)
    return target;
}

size_t WebsiteException::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:kidsmanagement.WebsiteException)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string pattern = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_pattern());
        }

        // optional string icon_url = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_icon_url());
        }

        // optional .kidsmanagement.ExceptionType exception_type = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_exception_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WebsiteException::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WebsiteException*>(&from));
}

void WebsiteException::MergeFrom(const WebsiteException& from)
{
    WebsiteException* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:kidsmanagement.WebsiteException)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_pattern(from._internal_pattern());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_icon_url(from._internal_icon_url());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.exception_type_ = from._impl_.exception_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WebsiteException::CopyFrom(const WebsiteException& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:kidsmanagement.WebsiteException)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WebsiteException::IsInitialized() const
{
    return true;
}

void WebsiteException::InternalSwap(WebsiteException* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.pattern_, lhs_arena, &other->_impl_.pattern_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.icon_url_, lhs_arena, &other->_impl_.icon_url_, rhs_arena);
    swap(_impl_.exception_type_, other->_impl_.exception_type_);
}

std::string WebsiteException::GetTypeName() const
{
    return "kidsmanagement.WebsiteException";
}

// ===================================================================

class DefineChromeTestStateRequest_UrlFilteringSettings::_Internal {
public:
    using HasBits = decltype(std::declval<DefineChromeTestStateRequest_UrlFilteringSettings>()._impl_._has_bits_);
    static void set_has_filter_level(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_websites_can_request_permissions(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_can_block_cookies(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_can_add_extensions(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

DefineChromeTestStateRequest_UrlFilteringSettings::DefineChromeTestStateRequest_UrlFilteringSettings(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings)
}
DefineChromeTestStateRequest_UrlFilteringSettings::DefineChromeTestStateRequest_UrlFilteringSettings(
    const DefineChromeTestStateRequest_UrlFilteringSettings& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DefineChromeTestStateRequest_UrlFilteringSettings* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.exceptions_) { from._impl_.exceptions_ }, decltype(_impl_.filter_level_) {}, decltype(_impl_.websites_can_request_permissions_) {},
        decltype(_impl_.can_block_cookies_) {}, decltype(_impl_.can_add_extensions_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.filter_level_, &from._impl_.filter_level_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.can_add_extensions_) - reinterpret_cast<char*>(&_impl_.filter_level_))
            + sizeof(_impl_.can_add_extensions_));
    // @@protoc_insertion_point(copy_constructor:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings)
}

inline void DefineChromeTestStateRequest_UrlFilteringSettings::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.exceptions_) { arena },
        decltype(_impl_.filter_level_) { 0 }, decltype(_impl_.websites_can_request_permissions_) { false }, decltype(_impl_.can_block_cookies_) { false },
        decltype(_impl_.can_add_extensions_) { false } };
}

DefineChromeTestStateRequest_UrlFilteringSettings::~DefineChromeTestStateRequest_UrlFilteringSettings()
{
    // @@protoc_insertion_point(destructor:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DefineChromeTestStateRequest_UrlFilteringSettings::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.exceptions_.~RepeatedPtrField();
}

void DefineChromeTestStateRequest_UrlFilteringSettings::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DefineChromeTestStateRequest_UrlFilteringSettings::Clear()
{
    // @@protoc_insertion_point(message_clear_start:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.exceptions_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        ::memset(&_impl_.filter_level_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.can_add_extensions_) - reinterpret_cast<char*>(&_impl_.filter_level_))
                + sizeof(_impl_.can_add_extensions_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DefineChromeTestStateRequest_UrlFilteringSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .kidsmanagement.FilterLevel filter_level = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::kidsmanagement::FilterLevel_IsValid(val))) {
                    _internal_set_filter_level(static_cast<::kidsmanagement::FilterLevel>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated .kidsmanagement.WebsiteException exceptions = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_exceptions(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool websites_can_request_permissions = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_websites_can_request_permissions(&has_bits);
                _impl_.websites_can_request_permissions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool can_block_cookies = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_can_block_cookies(&has_bits);
                _impl_.can_block_cookies_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool can_add_extensions = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_can_add_extensions(&has_bits);
                _impl_.can_add_extensions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DefineChromeTestStateRequest_UrlFilteringSettings::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .kidsmanagement.FilterLevel filter_level = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_filter_level(), target);
    }

    // repeated .kidsmanagement.WebsiteException exceptions = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_exceptions_size()); i < n; i++) {
        const auto& repfield = this->_internal_exceptions(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bool websites_can_request_permissions = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_websites_can_request_permissions(), target);
    }

    // optional bool can_block_cookies = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_can_block_cookies(), target);
    }

    // optional bool can_add_extensions = 5;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_can_add_extensions(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings)
    return target;
}

size_t DefineChromeTestStateRequest_UrlFilteringSettings::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .kidsmanagement.WebsiteException exceptions = 2;
    total_size += 1UL * this->_internal_exceptions_size();
    for (const auto& msg : this->_impl_.exceptions_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .kidsmanagement.FilterLevel filter_level = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_filter_level());
        }

        // optional bool websites_can_request_permissions = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }

        // optional bool can_block_cookies = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }

        // optional bool can_add_extensions = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DefineChromeTestStateRequest_UrlFilteringSettings::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DefineChromeTestStateRequest_UrlFilteringSettings*>(&from));
}

void DefineChromeTestStateRequest_UrlFilteringSettings::MergeFrom(const DefineChromeTestStateRequest_UrlFilteringSettings& from)
{
    DefineChromeTestStateRequest_UrlFilteringSettings* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.exceptions_.MergeFrom(from._impl_.exceptions_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.filter_level_ = from._impl_.filter_level_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.websites_can_request_permissions_ = from._impl_.websites_can_request_permissions_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.can_block_cookies_ = from._impl_.can_block_cookies_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.can_add_extensions_ = from._impl_.can_add_extensions_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DefineChromeTestStateRequest_UrlFilteringSettings::CopyFrom(const DefineChromeTestStateRequest_UrlFilteringSettings& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DefineChromeTestStateRequest_UrlFilteringSettings::IsInitialized() const
{
    return true;
}

void DefineChromeTestStateRequest_UrlFilteringSettings::InternalSwap(DefineChromeTestStateRequest_UrlFilteringSettings* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.exceptions_.InternalSwap(&other->_impl_.exceptions_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(DefineChromeTestStateRequest_UrlFilteringSettings, _impl_.can_add_extensions_)
        + sizeof(DefineChromeTestStateRequest_UrlFilteringSettings::_impl_.can_add_extensions_)
        - PROTOBUF_FIELD_OFFSET(DefineChromeTestStateRequest_UrlFilteringSettings, _impl_.filter_level_)>(
        reinterpret_cast<char*>(&_impl_.filter_level_), reinterpret_cast<char*>(&other->_impl_.filter_level_));
}

std::string DefineChromeTestStateRequest_UrlFilteringSettings::GetTypeName() const
{
    return "kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings";
}

// ===================================================================

class DefineChromeTestStateRequest::_Internal {
public:
    using HasBits = decltype(std::declval<DefineChromeTestStateRequest>()._impl_._has_bits_);
    static void set_has_child_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings& url_filtering_settings(const DefineChromeTestStateRequest* msg);
    static void set_has_url_filtering_settings(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings& DefineChromeTestStateRequest::_Internal::url_filtering_settings(
    const DefineChromeTestStateRequest* msg)
{
    return *msg->_impl_.url_filtering_settings_;
}
DefineChromeTestStateRequest::DefineChromeTestStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:kidsmanagement.DefineChromeTestStateRequest)
}
DefineChromeTestStateRequest::DefineChromeTestStateRequest(const DefineChromeTestStateRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DefineChromeTestStateRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.child_id_) {},
        decltype(_impl_.url_filtering_settings_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.child_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.child_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_child_id()) {
        _this->_impl_.child_id_.Set(from._internal_child_id(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_url_filtering_settings()) {
        _this->_impl_.url_filtering_settings_ = new ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings(*from._impl_.url_filtering_settings_);
    }
    // @@protoc_insertion_point(copy_constructor:kidsmanagement.DefineChromeTestStateRequest)
}

inline void DefineChromeTestStateRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.child_id_) {},
        decltype(_impl_.url_filtering_settings_) { nullptr } };
    _impl_.child_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.child_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DefineChromeTestStateRequest::~DefineChromeTestStateRequest()
{
    // @@protoc_insertion_point(destructor:kidsmanagement.DefineChromeTestStateRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DefineChromeTestStateRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.child_id_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.url_filtering_settings_;
}

void DefineChromeTestStateRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DefineChromeTestStateRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:kidsmanagement.DefineChromeTestStateRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.child_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.url_filtering_settings_ != nullptr);
            _impl_.url_filtering_settings_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DefineChromeTestStateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string child_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_child_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings url_filtering_settings = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_url_filtering_settings(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DefineChromeTestStateRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:kidsmanagement.DefineChromeTestStateRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string child_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_child_id(), target);
    }

    // optional .kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings url_filtering_settings = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::url_filtering_settings(this), _Internal::url_filtering_settings(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:kidsmanagement.DefineChromeTestStateRequest)
    return target;
}

size_t DefineChromeTestStateRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:kidsmanagement.DefineChromeTestStateRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string child_id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_child_id());
        }

        // optional .kidsmanagement.DefineChromeTestStateRequest.UrlFilteringSettings url_filtering_settings = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.url_filtering_settings_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DefineChromeTestStateRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DefineChromeTestStateRequest*>(&from));
}

void DefineChromeTestStateRequest::MergeFrom(const DefineChromeTestStateRequest& from)
{
    DefineChromeTestStateRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:kidsmanagement.DefineChromeTestStateRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_child_id(from._internal_child_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_url_filtering_settings()->::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings::MergeFrom(
                from._internal_url_filtering_settings());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DefineChromeTestStateRequest::CopyFrom(const DefineChromeTestStateRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:kidsmanagement.DefineChromeTestStateRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DefineChromeTestStateRequest::IsInitialized() const
{
    return true;
}

void DefineChromeTestStateRequest::InternalSwap(DefineChromeTestStateRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.child_id_, lhs_arena, &other->_impl_.child_id_, rhs_arena);
    swap(_impl_.url_filtering_settings_, other->_impl_.url_filtering_settings_);
}

std::string DefineChromeTestStateRequest::GetTypeName() const
{
    return "kidsmanagement.DefineChromeTestStateRequest";
}

// ===================================================================

class ResetChromeTestStateRequest::_Internal {
public:
    using HasBits = decltype(std::declval<ResetChromeTestStateRequest>()._impl_._has_bits_);
    static void set_has_child_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ResetChromeTestStateRequest::ResetChromeTestStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:kidsmanagement.ResetChromeTestStateRequest)
}
ResetChromeTestStateRequest::ResetChromeTestStateRequest(const ResetChromeTestStateRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ResetChromeTestStateRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.child_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.child_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.child_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_child_id()) {
        _this->_impl_.child_id_.Set(from._internal_child_id(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:kidsmanagement.ResetChromeTestStateRequest)
}

inline void ResetChromeTestStateRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.child_id_) {} };
    _impl_.child_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.child_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResetChromeTestStateRequest::~ResetChromeTestStateRequest()
{
    // @@protoc_insertion_point(destructor:kidsmanagement.ResetChromeTestStateRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ResetChromeTestStateRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.child_id_.Destroy();
}

void ResetChromeTestStateRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ResetChromeTestStateRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:kidsmanagement.ResetChromeTestStateRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.child_id_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ResetChromeTestStateRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string child_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_child_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ResetChromeTestStateRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:kidsmanagement.ResetChromeTestStateRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string child_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_child_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:kidsmanagement.ResetChromeTestStateRequest)
    return target;
}

size_t ResetChromeTestStateRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:kidsmanagement.ResetChromeTestStateRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string child_id = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_child_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ResetChromeTestStateRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ResetChromeTestStateRequest*>(&from));
}

void ResetChromeTestStateRequest::MergeFrom(const ResetChromeTestStateRequest& from)
{
    ResetChromeTestStateRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:kidsmanagement.ResetChromeTestStateRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_child_id()) {
        _this->_internal_set_child_id(from._internal_child_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ResetChromeTestStateRequest::CopyFrom(const ResetChromeTestStateRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:kidsmanagement.ResetChromeTestStateRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ResetChromeTestStateRequest::IsInitialized() const
{
    return true;
}

void ResetChromeTestStateRequest::InternalSwap(ResetChromeTestStateRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.child_id_, lhs_arena, &other->_impl_.child_id_, rhs_arena);
}

std::string ResetChromeTestStateRequest::GetTypeName() const
{
    return "kidsmanagement.ResetChromeTestStateRequest";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace kidsmanagement
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::kidsmanagement::ListMembersRequest* Arena::CreateMaybeMessage<::kidsmanagement::ListMembersRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::kidsmanagement::ListMembersRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::kidsmanagement::ListMembersResponse* Arena::CreateMaybeMessage<::kidsmanagement::ListMembersResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::kidsmanagement::ListMembersResponse>(arena);
}
template <> PROTOBUF_NOINLINE ::kidsmanagement::ClassifyUrlRequest* Arena::CreateMaybeMessage<::kidsmanagement::ClassifyUrlRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::kidsmanagement::ClassifyUrlRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::kidsmanagement::ClassifyUrlResponse* Arena::CreateMaybeMessage<::kidsmanagement::ClassifyUrlResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::kidsmanagement::ClassifyUrlResponse>(arena);
}
template <>
PROTOBUF_NOINLINE ::kidsmanagement::CreatePermissionRequestResponse* Arena::CreateMaybeMessage<::kidsmanagement::CreatePermissionRequestResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::kidsmanagement::CreatePermissionRequestResponse>(arena);
}
template <> PROTOBUF_NOINLINE ::kidsmanagement::PermissionRequest* Arena::CreateMaybeMessage<::kidsmanagement::PermissionRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::kidsmanagement::PermissionRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::kidsmanagement::WebsiteException* Arena::CreateMaybeMessage<::kidsmanagement::WebsiteException>(Arena* arena)
{
    return Arena::CreateMessageInternal<::kidsmanagement::WebsiteException>(arena);
}
template <>
PROTOBUF_NOINLINE ::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings*
Arena::CreateMaybeMessage<::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings>(Arena* arena)
{
    return Arena::CreateMessageInternal<::kidsmanagement::DefineChromeTestStateRequest_UrlFilteringSettings>(arena);
}
template <>
PROTOBUF_NOINLINE ::kidsmanagement::DefineChromeTestStateRequest* Arena::CreateMaybeMessage<::kidsmanagement::DefineChromeTestStateRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::kidsmanagement::DefineChromeTestStateRequest>(arena);
}
template <>
PROTOBUF_NOINLINE ::kidsmanagement::ResetChromeTestStateRequest* Arena::CreateMaybeMessage<::kidsmanagement::ResetChromeTestStateRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::kidsmanagement::ResetChromeTestStateRequest>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
