// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stability_report.proto

#include "stability_report.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace stability_report {
PROTOBUF_CONSTEXPR ProcessState_MemoryState_WindowsMemory::ProcessState_MemoryState_WindowsMemory(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.process_private_usage_)*/ 0u,
        /*decltype(_impl_.process_peak_workingset_size_)*/ 0u, /*decltype(_impl_.process_peak_pagefile_usage_)*/ 0u,
        /*decltype(_impl_.process_allocation_attempt_)*/ 0u }
{
}
struct ProcessState_MemoryState_WindowsMemoryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ProcessState_MemoryState_WindowsMemoryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ProcessState_MemoryState_WindowsMemoryDefaultTypeInternal()
    {
    }
    union {
        ProcessState_MemoryState_WindowsMemory _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessState_MemoryState_WindowsMemoryDefaultTypeInternal
    _ProcessState_MemoryState_WindowsMemory_default_instance_;
PROTOBUF_CONSTEXPR ProcessState_MemoryState::ProcessState_MemoryState(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.windows_memory_)*/ nullptr }
{
}
struct ProcessState_MemoryStateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ProcessState_MemoryStateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ProcessState_MemoryStateDefaultTypeInternal()
    {
    }
    union {
        ProcessState_MemoryState _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessState_MemoryStateDefaultTypeInternal
    _ProcessState_MemoryState_default_instance_;
PROTOBUF_CONSTEXPR ProcessState_FileSystemState_PosixFileSystemState::ProcessState_FileSystemState_PosixFileSystemState(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.open_file_descriptors_)*/ 0u }
{
}
struct ProcessState_FileSystemState_PosixFileSystemStateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ProcessState_FileSystemState_PosixFileSystemStateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ProcessState_FileSystemState_PosixFileSystemStateDefaultTypeInternal()
    {
    }
    union {
        ProcessState_FileSystemState_PosixFileSystemState _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessState_FileSystemState_PosixFileSystemStateDefaultTypeInternal
    _ProcessState_FileSystemState_PosixFileSystemState_default_instance_;
PROTOBUF_CONSTEXPR ProcessState_FileSystemState_WindowsFileSystemState::ProcessState_FileSystemState_WindowsFileSystemState(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.process_handle_count_)*/ 0u }
{
}
struct ProcessState_FileSystemState_WindowsFileSystemStateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ProcessState_FileSystemState_WindowsFileSystemStateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ProcessState_FileSystemState_WindowsFileSystemStateDefaultTypeInternal()
    {
    }
    union {
        ProcessState_FileSystemState_WindowsFileSystemState _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessState_FileSystemState_WindowsFileSystemStateDefaultTypeInternal
    _ProcessState_FileSystemState_WindowsFileSystemState_default_instance_;
PROTOBUF_CONSTEXPR ProcessState_FileSystemState::ProcessState_FileSystemState(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.posix_file_system_state_)*/ nullptr,
        /*decltype(_impl_.windows_file_system_state_)*/ nullptr }
{
}
struct ProcessState_FileSystemStateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ProcessState_FileSystemStateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ProcessState_FileSystemStateDefaultTypeInternal()
    {
    }
    union {
        ProcessState_FileSystemState _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessState_FileSystemStateDefaultTypeInternal
    _ProcessState_FileSystemState_default_instance_;
PROTOBUF_CONSTEXPR ProcessState::ProcessState(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.memory_state_)*/ nullptr,
        /*decltype(_impl_.file_system_state_)*/ nullptr, /*decltype(_impl_.process_id_)*/ int64_t { 0 } }
{
}
struct ProcessStateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ProcessStateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ProcessStateDefaultTypeInternal()
    {
    }
    union {
        ProcessState _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProcessStateDefaultTypeInternal _ProcessState_default_instance_;
PROTOBUF_CONSTEXPR SystemMemoryState_WindowsMemory::SystemMemoryState_WindowsMemory(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.system_commit_limit_)*/ 0u,
        /*decltype(_impl_.system_commit_remaining_)*/ 0u, /*decltype(_impl_.system_handle_count_)*/ 0u }
{
}
struct SystemMemoryState_WindowsMemoryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SystemMemoryState_WindowsMemoryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SystemMemoryState_WindowsMemoryDefaultTypeInternal()
    {
    }
    union {
        SystemMemoryState_WindowsMemory _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemMemoryState_WindowsMemoryDefaultTypeInternal
    _SystemMemoryState_WindowsMemory_default_instance_;
PROTOBUF_CONSTEXPR SystemMemoryState::SystemMemoryState(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.windows_memory_)*/ nullptr }
{
}
struct SystemMemoryStateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SystemMemoryStateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SystemMemoryStateDefaultTypeInternal()
    {
    }
    union {
        SystemMemoryState _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemMemoryStateDefaultTypeInternal _SystemMemoryState_default_instance_;
PROTOBUF_CONSTEXPR StabilityReport::StabilityReport(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.process_states_)*/ {},
        /*decltype(_impl_.system_memory_state_)*/ nullptr }
{
}
struct StabilityReportDefaultTypeInternal {
    PROTOBUF_CONSTEXPR StabilityReportDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~StabilityReportDefaultTypeInternal()
    {
    }
    union {
        StabilityReport _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StabilityReportDefaultTypeInternal _StabilityReport_default_instance_;
} // namespace stability_report
namespace stability_report {

// ===================================================================

class ProcessState_MemoryState_WindowsMemory::_Internal {
public:
    using HasBits = decltype(std::declval<ProcessState_MemoryState_WindowsMemory>()._impl_._has_bits_);
    static void set_has_process_private_usage(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_process_peak_workingset_size(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_process_peak_pagefile_usage(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_process_allocation_attempt(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

ProcessState_MemoryState_WindowsMemory::ProcessState_MemoryState_WindowsMemory(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:stability_report.ProcessState.MemoryState.WindowsMemory)
}
ProcessState_MemoryState_WindowsMemory::ProcessState_MemoryState_WindowsMemory(const ProcessState_MemoryState_WindowsMemory& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ProcessState_MemoryState_WindowsMemory* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.process_private_usage_) {}, decltype(_impl_.process_peak_workingset_size_) {}, decltype(_impl_.process_peak_pagefile_usage_) {},
        decltype(_impl_.process_allocation_attempt_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.process_private_usage_, &from._impl_.process_private_usage_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.process_allocation_attempt_) - reinterpret_cast<char*>(&_impl_.process_private_usage_))
            + sizeof(_impl_.process_allocation_attempt_));
    // @@protoc_insertion_point(copy_constructor:stability_report.ProcessState.MemoryState.WindowsMemory)
}

inline void ProcessState_MemoryState_WindowsMemory::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.process_private_usage_) { 0u },
        decltype(_impl_.process_peak_workingset_size_) { 0u }, decltype(_impl_.process_peak_pagefile_usage_) { 0u },
        decltype(_impl_.process_allocation_attempt_) { 0u } };
}

ProcessState_MemoryState_WindowsMemory::~ProcessState_MemoryState_WindowsMemory()
{
    // @@protoc_insertion_point(destructor:stability_report.ProcessState.MemoryState.WindowsMemory)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ProcessState_MemoryState_WindowsMemory::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ProcessState_MemoryState_WindowsMemory::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ProcessState_MemoryState_WindowsMemory::Clear()
{
    // @@protoc_insertion_point(message_clear_start:stability_report.ProcessState.MemoryState.WindowsMemory)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        ::memset(&_impl_.process_private_usage_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.process_allocation_attempt_) - reinterpret_cast<char*>(&_impl_.process_private_usage_))
                + sizeof(_impl_.process_allocation_attempt_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ProcessState_MemoryState_WindowsMemory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint32 process_private_usage = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_process_private_usage(&has_bits);
                _impl_.process_private_usage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 process_peak_workingset_size = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_process_peak_workingset_size(&has_bits);
                _impl_.process_peak_workingset_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 process_peak_pagefile_usage = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_process_peak_pagefile_usage(&has_bits);
                _impl_.process_peak_pagefile_usage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 process_allocation_attempt = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_process_allocation_attempt(&has_bits);
                _impl_.process_allocation_attempt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ProcessState_MemoryState_WindowsMemory::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:stability_report.ProcessState.MemoryState.WindowsMemory)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 process_private_usage = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_process_private_usage(), target);
    }

    // optional uint32 process_peak_workingset_size = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_process_peak_workingset_size(), target);
    }

    // optional uint32 process_peak_pagefile_usage = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_process_peak_pagefile_usage(), target);
    }

    // optional uint32 process_allocation_attempt = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_process_allocation_attempt(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:stability_report.ProcessState.MemoryState.WindowsMemory)
    return target;
}

size_t ProcessState_MemoryState_WindowsMemory::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:stability_report.ProcessState.MemoryState.WindowsMemory)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional uint32 process_private_usage = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_process_private_usage());
        }

        // optional uint32 process_peak_workingset_size = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_process_peak_workingset_size());
        }

        // optional uint32 process_peak_pagefile_usage = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_process_peak_pagefile_usage());
        }

        // optional uint32 process_allocation_attempt = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_process_allocation_attempt());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ProcessState_MemoryState_WindowsMemory::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ProcessState_MemoryState_WindowsMemory*>(&from));
}

void ProcessState_MemoryState_WindowsMemory::MergeFrom(const ProcessState_MemoryState_WindowsMemory& from)
{
    ProcessState_MemoryState_WindowsMemory* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:stability_report.ProcessState.MemoryState.WindowsMemory)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.process_private_usage_ = from._impl_.process_private_usage_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.process_peak_workingset_size_ = from._impl_.process_peak_workingset_size_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.process_peak_pagefile_usage_ = from._impl_.process_peak_pagefile_usage_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.process_allocation_attempt_ = from._impl_.process_allocation_attempt_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProcessState_MemoryState_WindowsMemory::CopyFrom(const ProcessState_MemoryState_WindowsMemory& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:stability_report.ProcessState.MemoryState.WindowsMemory)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ProcessState_MemoryState_WindowsMemory::IsInitialized() const
{
    return true;
}

void ProcessState_MemoryState_WindowsMemory::InternalSwap(ProcessState_MemoryState_WindowsMemory* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ProcessState_MemoryState_WindowsMemory, _impl_.process_allocation_attempt_)
        + sizeof(ProcessState_MemoryState_WindowsMemory::_impl_.process_allocation_attempt_)
        - PROTOBUF_FIELD_OFFSET(ProcessState_MemoryState_WindowsMemory, _impl_.process_private_usage_)>(
        reinterpret_cast<char*>(&_impl_.process_private_usage_), reinterpret_cast<char*>(&other->_impl_.process_private_usage_));
}

std::string ProcessState_MemoryState_WindowsMemory::GetTypeName() const
{
    return "stability_report.ProcessState.MemoryState.WindowsMemory";
}

// ===================================================================

class ProcessState_MemoryState::_Internal {
public:
    using HasBits = decltype(std::declval<ProcessState_MemoryState>()._impl_._has_bits_);
    static const ::stability_report::ProcessState_MemoryState_WindowsMemory& windows_memory(const ProcessState_MemoryState* msg);
    static void set_has_windows_memory(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::stability_report::ProcessState_MemoryState_WindowsMemory& ProcessState_MemoryState::_Internal::windows_memory(const ProcessState_MemoryState* msg)
{
    return *msg->_impl_.windows_memory_;
}
ProcessState_MemoryState::ProcessState_MemoryState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:stability_report.ProcessState.MemoryState)
}
ProcessState_MemoryState::ProcessState_MemoryState(const ProcessState_MemoryState& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ProcessState_MemoryState* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.windows_memory_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_windows_memory()) {
        _this->_impl_.windows_memory_ = new ::stability_report::ProcessState_MemoryState_WindowsMemory(*from._impl_.windows_memory_);
    }
    // @@protoc_insertion_point(copy_constructor:stability_report.ProcessState.MemoryState)
}

inline void ProcessState_MemoryState::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.windows_memory_) { nullptr } };
}

ProcessState_MemoryState::~ProcessState_MemoryState()
{
    // @@protoc_insertion_point(destructor:stability_report.ProcessState.MemoryState)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ProcessState_MemoryState::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.windows_memory_;
}

void ProcessState_MemoryState::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ProcessState_MemoryState::Clear()
{
    // @@protoc_insertion_point(message_clear_start:stability_report.ProcessState.MemoryState)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.windows_memory_ != nullptr);
        _impl_.windows_memory_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ProcessState_MemoryState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .stability_report.ProcessState.MemoryState.WindowsMemory windows_memory = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_windows_memory(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ProcessState_MemoryState::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:stability_report.ProcessState.MemoryState)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .stability_report.ProcessState.MemoryState.WindowsMemory windows_memory = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::windows_memory(this), _Internal::windows_memory(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:stability_report.ProcessState.MemoryState)
    return target;
}

size_t ProcessState_MemoryState::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:stability_report.ProcessState.MemoryState)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .stability_report.ProcessState.MemoryState.WindowsMemory windows_memory = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.windows_memory_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ProcessState_MemoryState::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ProcessState_MemoryState*>(&from));
}

void ProcessState_MemoryState::MergeFrom(const ProcessState_MemoryState& from)
{
    ProcessState_MemoryState* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:stability_report.ProcessState.MemoryState)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_windows_memory()) {
        _this->_internal_mutable_windows_memory()->::stability_report::ProcessState_MemoryState_WindowsMemory::MergeFrom(from._internal_windows_memory());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProcessState_MemoryState::CopyFrom(const ProcessState_MemoryState& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:stability_report.ProcessState.MemoryState)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ProcessState_MemoryState::IsInitialized() const
{
    return true;
}

void ProcessState_MemoryState::InternalSwap(ProcessState_MemoryState* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.windows_memory_, other->_impl_.windows_memory_);
}

std::string ProcessState_MemoryState::GetTypeName() const
{
    return "stability_report.ProcessState.MemoryState";
}

// ===================================================================

class ProcessState_FileSystemState_PosixFileSystemState::_Internal {
public:
    using HasBits = decltype(std::declval<ProcessState_FileSystemState_PosixFileSystemState>()._impl_._has_bits_);
    static void set_has_open_file_descriptors(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ProcessState_FileSystemState_PosixFileSystemState::ProcessState_FileSystemState_PosixFileSystemState(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:stability_report.ProcessState.FileSystemState.PosixFileSystemState)
}
ProcessState_FileSystemState_PosixFileSystemState::ProcessState_FileSystemState_PosixFileSystemState(
    const ProcessState_FileSystemState_PosixFileSystemState& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ProcessState_FileSystemState_PosixFileSystemState* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.open_file_descriptors_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.open_file_descriptors_ = from._impl_.open_file_descriptors_;
    // @@protoc_insertion_point(copy_constructor:stability_report.ProcessState.FileSystemState.PosixFileSystemState)
}

inline void ProcessState_FileSystemState_PosixFileSystemState::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.open_file_descriptors_) { 0u } };
}

ProcessState_FileSystemState_PosixFileSystemState::~ProcessState_FileSystemState_PosixFileSystemState()
{
    // @@protoc_insertion_point(destructor:stability_report.ProcessState.FileSystemState.PosixFileSystemState)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ProcessState_FileSystemState_PosixFileSystemState::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ProcessState_FileSystemState_PosixFileSystemState::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ProcessState_FileSystemState_PosixFileSystemState::Clear()
{
    // @@protoc_insertion_point(message_clear_start:stability_report.ProcessState.FileSystemState.PosixFileSystemState)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.open_file_descriptors_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ProcessState_FileSystemState_PosixFileSystemState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint32 open_file_descriptors = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_open_file_descriptors(&has_bits);
                _impl_.open_file_descriptors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ProcessState_FileSystemState_PosixFileSystemState::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:stability_report.ProcessState.FileSystemState.PosixFileSystemState)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 open_file_descriptors = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_open_file_descriptors(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:stability_report.ProcessState.FileSystemState.PosixFileSystemState)
    return target;
}

size_t ProcessState_FileSystemState_PosixFileSystemState::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:stability_report.ProcessState.FileSystemState.PosixFileSystemState)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional uint32 open_file_descriptors = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_open_file_descriptors());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ProcessState_FileSystemState_PosixFileSystemState::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ProcessState_FileSystemState_PosixFileSystemState*>(&from));
}

void ProcessState_FileSystemState_PosixFileSystemState::MergeFrom(const ProcessState_FileSystemState_PosixFileSystemState& from)
{
    ProcessState_FileSystemState_PosixFileSystemState* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:stability_report.ProcessState.FileSystemState.PosixFileSystemState)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_open_file_descriptors()) {
        _this->_internal_set_open_file_descriptors(from._internal_open_file_descriptors());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProcessState_FileSystemState_PosixFileSystemState::CopyFrom(const ProcessState_FileSystemState_PosixFileSystemState& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:stability_report.ProcessState.FileSystemState.PosixFileSystemState)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ProcessState_FileSystemState_PosixFileSystemState::IsInitialized() const
{
    return true;
}

void ProcessState_FileSystemState_PosixFileSystemState::InternalSwap(ProcessState_FileSystemState_PosixFileSystemState* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.open_file_descriptors_, other->_impl_.open_file_descriptors_);
}

std::string ProcessState_FileSystemState_PosixFileSystemState::GetTypeName() const
{
    return "stability_report.ProcessState.FileSystemState.PosixFileSystemState";
}

// ===================================================================

class ProcessState_FileSystemState_WindowsFileSystemState::_Internal {
public:
    using HasBits = decltype(std::declval<ProcessState_FileSystemState_WindowsFileSystemState>()._impl_._has_bits_);
    static void set_has_process_handle_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ProcessState_FileSystemState_WindowsFileSystemState::ProcessState_FileSystemState_WindowsFileSystemState(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:stability_report.ProcessState.FileSystemState.WindowsFileSystemState)
}
ProcessState_FileSystemState_WindowsFileSystemState::ProcessState_FileSystemState_WindowsFileSystemState(
    const ProcessState_FileSystemState_WindowsFileSystemState& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ProcessState_FileSystemState_WindowsFileSystemState* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.process_handle_count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.process_handle_count_ = from._impl_.process_handle_count_;
    // @@protoc_insertion_point(copy_constructor:stability_report.ProcessState.FileSystemState.WindowsFileSystemState)
}

inline void ProcessState_FileSystemState_WindowsFileSystemState::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.process_handle_count_) { 0u } };
}

ProcessState_FileSystemState_WindowsFileSystemState::~ProcessState_FileSystemState_WindowsFileSystemState()
{
    // @@protoc_insertion_point(destructor:stability_report.ProcessState.FileSystemState.WindowsFileSystemState)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ProcessState_FileSystemState_WindowsFileSystemState::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ProcessState_FileSystemState_WindowsFileSystemState::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ProcessState_FileSystemState_WindowsFileSystemState::Clear()
{
    // @@protoc_insertion_point(message_clear_start:stability_report.ProcessState.FileSystemState.WindowsFileSystemState)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.process_handle_count_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ProcessState_FileSystemState_WindowsFileSystemState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint32 process_handle_count = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_process_handle_count(&has_bits);
                _impl_.process_handle_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ProcessState_FileSystemState_WindowsFileSystemState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:stability_report.ProcessState.FileSystemState.WindowsFileSystemState)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 process_handle_count = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_process_handle_count(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:stability_report.ProcessState.FileSystemState.WindowsFileSystemState)
    return target;
}

size_t ProcessState_FileSystemState_WindowsFileSystemState::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:stability_report.ProcessState.FileSystemState.WindowsFileSystemState)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional uint32 process_handle_count = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_process_handle_count());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ProcessState_FileSystemState_WindowsFileSystemState::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ProcessState_FileSystemState_WindowsFileSystemState*>(&from));
}

void ProcessState_FileSystemState_WindowsFileSystemState::MergeFrom(const ProcessState_FileSystemState_WindowsFileSystemState& from)
{
    ProcessState_FileSystemState_WindowsFileSystemState* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:stability_report.ProcessState.FileSystemState.WindowsFileSystemState)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_process_handle_count()) {
        _this->_internal_set_process_handle_count(from._internal_process_handle_count());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProcessState_FileSystemState_WindowsFileSystemState::CopyFrom(const ProcessState_FileSystemState_WindowsFileSystemState& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:stability_report.ProcessState.FileSystemState.WindowsFileSystemState)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ProcessState_FileSystemState_WindowsFileSystemState::IsInitialized() const
{
    return true;
}

void ProcessState_FileSystemState_WindowsFileSystemState::InternalSwap(ProcessState_FileSystemState_WindowsFileSystemState* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.process_handle_count_, other->_impl_.process_handle_count_);
}

std::string ProcessState_FileSystemState_WindowsFileSystemState::GetTypeName() const
{
    return "stability_report.ProcessState.FileSystemState.WindowsFileSystemState";
}

// ===================================================================

class ProcessState_FileSystemState::_Internal {
public:
    using HasBits = decltype(std::declval<ProcessState_FileSystemState>()._impl_._has_bits_);
    static const ::stability_report::ProcessState_FileSystemState_PosixFileSystemState& posix_file_system_state(const ProcessState_FileSystemState* msg);
    static void set_has_posix_file_system_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState& windows_file_system_state(const ProcessState_FileSystemState* msg);
    static void set_has_windows_file_system_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::stability_report::ProcessState_FileSystemState_PosixFileSystemState& ProcessState_FileSystemState::_Internal::posix_file_system_state(
    const ProcessState_FileSystemState* msg)
{
    return *msg->_impl_.posix_file_system_state_;
}
const ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState& ProcessState_FileSystemState::_Internal::windows_file_system_state(
    const ProcessState_FileSystemState* msg)
{
    return *msg->_impl_.windows_file_system_state_;
}
ProcessState_FileSystemState::ProcessState_FileSystemState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:stability_report.ProcessState.FileSystemState)
}
ProcessState_FileSystemState::ProcessState_FileSystemState(const ProcessState_FileSystemState& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ProcessState_FileSystemState* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.posix_file_system_state_) { nullptr }, decltype(_impl_.windows_file_system_state_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_posix_file_system_state()) {
        _this->_impl_.posix_file_system_state_
            = new ::stability_report::ProcessState_FileSystemState_PosixFileSystemState(*from._impl_.posix_file_system_state_);
    }
    if (from._internal_has_windows_file_system_state()) {
        _this->_impl_.windows_file_system_state_
            = new ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState(*from._impl_.windows_file_system_state_);
    }
    // @@protoc_insertion_point(copy_constructor:stability_report.ProcessState.FileSystemState)
}

inline void ProcessState_FileSystemState::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.posix_file_system_state_) { nullptr },
        decltype(_impl_.windows_file_system_state_) { nullptr } };
}

ProcessState_FileSystemState::~ProcessState_FileSystemState()
{
    // @@protoc_insertion_point(destructor:stability_report.ProcessState.FileSystemState)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ProcessState_FileSystemState::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.posix_file_system_state_;
    if (this != internal_default_instance())
        delete _impl_.windows_file_system_state_;
}

void ProcessState_FileSystemState::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ProcessState_FileSystemState::Clear()
{
    // @@protoc_insertion_point(message_clear_start:stability_report.ProcessState.FileSystemState)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.posix_file_system_state_ != nullptr);
            _impl_.posix_file_system_state_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.windows_file_system_state_ != nullptr);
            _impl_.windows_file_system_state_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ProcessState_FileSystemState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .stability_report.ProcessState.FileSystemState.PosixFileSystemState posix_file_system_state = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_posix_file_system_state(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .stability_report.ProcessState.FileSystemState.WindowsFileSystemState windows_file_system_state = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_windows_file_system_state(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ProcessState_FileSystemState::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:stability_report.ProcessState.FileSystemState)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .stability_report.ProcessState.FileSystemState.PosixFileSystemState posix_file_system_state = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::posix_file_system_state(this), _Internal::posix_file_system_state(this).GetCachedSize(), target, stream);
    }

    // optional .stability_report.ProcessState.FileSystemState.WindowsFileSystemState windows_file_system_state = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::windows_file_system_state(this), _Internal::windows_file_system_state(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:stability_report.ProcessState.FileSystemState)
    return target;
}

size_t ProcessState_FileSystemState::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:stability_report.ProcessState.FileSystemState)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .stability_report.ProcessState.FileSystemState.PosixFileSystemState posix_file_system_state = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.posix_file_system_state_);
        }

        // optional .stability_report.ProcessState.FileSystemState.WindowsFileSystemState windows_file_system_state = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.windows_file_system_state_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ProcessState_FileSystemState::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ProcessState_FileSystemState*>(&from));
}

void ProcessState_FileSystemState::MergeFrom(const ProcessState_FileSystemState& from)
{
    ProcessState_FileSystemState* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:stability_report.ProcessState.FileSystemState)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_posix_file_system_state()->::stability_report::ProcessState_FileSystemState_PosixFileSystemState::MergeFrom(
                from._internal_posix_file_system_state());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_windows_file_system_state()->::stability_report::ProcessState_FileSystemState_WindowsFileSystemState::MergeFrom(
                from._internal_windows_file_system_state());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProcessState_FileSystemState::CopyFrom(const ProcessState_FileSystemState& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:stability_report.ProcessState.FileSystemState)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ProcessState_FileSystemState::IsInitialized() const
{
    return true;
}

void ProcessState_FileSystemState::InternalSwap(ProcessState_FileSystemState* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ProcessState_FileSystemState, _impl_.windows_file_system_state_)
        + sizeof(ProcessState_FileSystemState::_impl_.windows_file_system_state_)
        - PROTOBUF_FIELD_OFFSET(ProcessState_FileSystemState, _impl_.posix_file_system_state_)>(
        reinterpret_cast<char*>(&_impl_.posix_file_system_state_), reinterpret_cast<char*>(&other->_impl_.posix_file_system_state_));
}

std::string ProcessState_FileSystemState::GetTypeName() const
{
    return "stability_report.ProcessState.FileSystemState";
}

// ===================================================================

class ProcessState::_Internal {
public:
    using HasBits = decltype(std::declval<ProcessState>()._impl_._has_bits_);
    static void set_has_process_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::stability_report::ProcessState_MemoryState& memory_state(const ProcessState* msg);
    static void set_has_memory_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::stability_report::ProcessState_FileSystemState& file_system_state(const ProcessState* msg);
    static void set_has_file_system_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::stability_report::ProcessState_MemoryState& ProcessState::_Internal::memory_state(const ProcessState* msg)
{
    return *msg->_impl_.memory_state_;
}
const ::stability_report::ProcessState_FileSystemState& ProcessState::_Internal::file_system_state(const ProcessState* msg)
{
    return *msg->_impl_.file_system_state_;
}
ProcessState::ProcessState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:stability_report.ProcessState)
}
ProcessState::ProcessState(const ProcessState& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ProcessState* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.memory_state_) { nullptr }, decltype(_impl_.file_system_state_) { nullptr }, decltype(_impl_.process_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_memory_state()) {
        _this->_impl_.memory_state_ = new ::stability_report::ProcessState_MemoryState(*from._impl_.memory_state_);
    }
    if (from._internal_has_file_system_state()) {
        _this->_impl_.file_system_state_ = new ::stability_report::ProcessState_FileSystemState(*from._impl_.file_system_state_);
    }
    _this->_impl_.process_id_ = from._impl_.process_id_;
    // @@protoc_insertion_point(copy_constructor:stability_report.ProcessState)
}

inline void ProcessState::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.memory_state_) { nullptr },
        decltype(_impl_.file_system_state_) { nullptr }, decltype(_impl_.process_id_) { int64_t { 0 } } };
}

ProcessState::~ProcessState()
{
    // @@protoc_insertion_point(destructor:stability_report.ProcessState)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ProcessState::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.memory_state_;
    if (this != internal_default_instance())
        delete _impl_.file_system_state_;
}

void ProcessState::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ProcessState::Clear()
{
    // @@protoc_insertion_point(message_clear_start:stability_report.ProcessState)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.memory_state_ != nullptr);
            _impl_.memory_state_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.file_system_state_ != nullptr);
            _impl_.file_system_state_->Clear();
        }
    }
    _impl_.process_id_ = int64_t { 0 };
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ProcessState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 process_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_process_id(&has_bits);
                _impl_.process_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .stability_report.ProcessState.MemoryState memory_state = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_memory_state(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .stability_report.ProcessState.FileSystemState file_system_state = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_file_system_state(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ProcessState::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:stability_report.ProcessState)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 process_id = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_process_id(), target);
    }

    // optional .stability_report.ProcessState.MemoryState memory_state = 4;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::memory_state(this), _Internal::memory_state(this).GetCachedSize(), target, stream);
    }

    // optional .stability_report.ProcessState.FileSystemState file_system_state = 7;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::file_system_state(this), _Internal::file_system_state(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:stability_report.ProcessState)
    return target;
}

size_t ProcessState::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:stability_report.ProcessState)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional .stability_report.ProcessState.MemoryState memory_state = 4;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.memory_state_);
        }

        // optional .stability_report.ProcessState.FileSystemState file_system_state = 7;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.file_system_state_);
        }

        // optional int64 process_id = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_process_id());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ProcessState::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ProcessState*>(&from));
}

void ProcessState::MergeFrom(const ProcessState& from)
{
    ProcessState* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:stability_report.ProcessState)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_memory_state()->::stability_report::ProcessState_MemoryState::MergeFrom(from._internal_memory_state());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_file_system_state()->::stability_report::ProcessState_FileSystemState::MergeFrom(from._internal_file_system_state());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.process_id_ = from._impl_.process_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ProcessState::CopyFrom(const ProcessState& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:stability_report.ProcessState)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ProcessState::IsInitialized() const
{
    return true;
}

void ProcessState::InternalSwap(ProcessState* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ProcessState, _impl_.process_id_) + sizeof(ProcessState::_impl_.process_id_)
        - PROTOBUF_FIELD_OFFSET(ProcessState, _impl_.memory_state_)>(
        reinterpret_cast<char*>(&_impl_.memory_state_), reinterpret_cast<char*>(&other->_impl_.memory_state_));
}

std::string ProcessState::GetTypeName() const
{
    return "stability_report.ProcessState";
}

// ===================================================================

class SystemMemoryState_WindowsMemory::_Internal {
public:
    using HasBits = decltype(std::declval<SystemMemoryState_WindowsMemory>()._impl_._has_bits_);
    static void set_has_system_commit_limit(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_system_commit_remaining(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_system_handle_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

SystemMemoryState_WindowsMemory::SystemMemoryState_WindowsMemory(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:stability_report.SystemMemoryState.WindowsMemory)
}
SystemMemoryState_WindowsMemory::SystemMemoryState_WindowsMemory(const SystemMemoryState_WindowsMemory& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SystemMemoryState_WindowsMemory* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.system_commit_limit_) {}, decltype(_impl_.system_commit_remaining_) {}, decltype(_impl_.system_handle_count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.system_commit_limit_, &from._impl_.system_commit_limit_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.system_handle_count_) - reinterpret_cast<char*>(&_impl_.system_commit_limit_))
            + sizeof(_impl_.system_handle_count_));
    // @@protoc_insertion_point(copy_constructor:stability_report.SystemMemoryState.WindowsMemory)
}

inline void SystemMemoryState_WindowsMemory::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.system_commit_limit_) { 0u },
        decltype(_impl_.system_commit_remaining_) { 0u }, decltype(_impl_.system_handle_count_) { 0u } };
}

SystemMemoryState_WindowsMemory::~SystemMemoryState_WindowsMemory()
{
    // @@protoc_insertion_point(destructor:stability_report.SystemMemoryState.WindowsMemory)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SystemMemoryState_WindowsMemory::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SystemMemoryState_WindowsMemory::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SystemMemoryState_WindowsMemory::Clear()
{
    // @@protoc_insertion_point(message_clear_start:stability_report.SystemMemoryState.WindowsMemory)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        ::memset(&_impl_.system_commit_limit_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.system_handle_count_) - reinterpret_cast<char*>(&_impl_.system_commit_limit_))
                + sizeof(_impl_.system_handle_count_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SystemMemoryState_WindowsMemory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint32 system_commit_limit = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_system_commit_limit(&has_bits);
                _impl_.system_commit_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 system_commit_remaining = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_system_commit_remaining(&has_bits);
                _impl_.system_commit_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 system_handle_count = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_system_handle_count(&has_bits);
                _impl_.system_handle_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SystemMemoryState_WindowsMemory::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:stability_report.SystemMemoryState.WindowsMemory)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 system_commit_limit = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_system_commit_limit(), target);
    }

    // optional uint32 system_commit_remaining = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_system_commit_remaining(), target);
    }

    // optional uint32 system_handle_count = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_system_handle_count(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:stability_report.SystemMemoryState.WindowsMemory)
    return target;
}

size_t SystemMemoryState_WindowsMemory::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:stability_report.SystemMemoryState.WindowsMemory)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional uint32 system_commit_limit = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_system_commit_limit());
        }

        // optional uint32 system_commit_remaining = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_system_commit_remaining());
        }

        // optional uint32 system_handle_count = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_system_handle_count());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SystemMemoryState_WindowsMemory::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SystemMemoryState_WindowsMemory*>(&from));
}

void SystemMemoryState_WindowsMemory::MergeFrom(const SystemMemoryState_WindowsMemory& from)
{
    SystemMemoryState_WindowsMemory* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:stability_report.SystemMemoryState.WindowsMemory)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.system_commit_limit_ = from._impl_.system_commit_limit_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.system_commit_remaining_ = from._impl_.system_commit_remaining_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.system_handle_count_ = from._impl_.system_handle_count_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemMemoryState_WindowsMemory::CopyFrom(const SystemMemoryState_WindowsMemory& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:stability_report.SystemMemoryState.WindowsMemory)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SystemMemoryState_WindowsMemory::IsInitialized() const
{
    return true;
}

void SystemMemoryState_WindowsMemory::InternalSwap(SystemMemoryState_WindowsMemory* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(SystemMemoryState_WindowsMemory, _impl_.system_handle_count_)
        + sizeof(SystemMemoryState_WindowsMemory::_impl_.system_handle_count_)
        - PROTOBUF_FIELD_OFFSET(SystemMemoryState_WindowsMemory, _impl_.system_commit_limit_)>(
        reinterpret_cast<char*>(&_impl_.system_commit_limit_), reinterpret_cast<char*>(&other->_impl_.system_commit_limit_));
}

std::string SystemMemoryState_WindowsMemory::GetTypeName() const
{
    return "stability_report.SystemMemoryState.WindowsMemory";
}

// ===================================================================

class SystemMemoryState::_Internal {
public:
    using HasBits = decltype(std::declval<SystemMemoryState>()._impl_._has_bits_);
    static const ::stability_report::SystemMemoryState_WindowsMemory& windows_memory(const SystemMemoryState* msg);
    static void set_has_windows_memory(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::stability_report::SystemMemoryState_WindowsMemory& SystemMemoryState::_Internal::windows_memory(const SystemMemoryState* msg)
{
    return *msg->_impl_.windows_memory_;
}
SystemMemoryState::SystemMemoryState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:stability_report.SystemMemoryState)
}
SystemMemoryState::SystemMemoryState(const SystemMemoryState& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SystemMemoryState* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.windows_memory_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_windows_memory()) {
        _this->_impl_.windows_memory_ = new ::stability_report::SystemMemoryState_WindowsMemory(*from._impl_.windows_memory_);
    }
    // @@protoc_insertion_point(copy_constructor:stability_report.SystemMemoryState)
}

inline void SystemMemoryState::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.windows_memory_) { nullptr } };
}

SystemMemoryState::~SystemMemoryState()
{
    // @@protoc_insertion_point(destructor:stability_report.SystemMemoryState)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SystemMemoryState::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.windows_memory_;
}

void SystemMemoryState::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SystemMemoryState::Clear()
{
    // @@protoc_insertion_point(message_clear_start:stability_report.SystemMemoryState)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.windows_memory_ != nullptr);
        _impl_.windows_memory_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SystemMemoryState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .stability_report.SystemMemoryState.WindowsMemory windows_memory = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_windows_memory(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SystemMemoryState::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:stability_report.SystemMemoryState)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .stability_report.SystemMemoryState.WindowsMemory windows_memory = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::windows_memory(this), _Internal::windows_memory(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:stability_report.SystemMemoryState)
    return target;
}

size_t SystemMemoryState::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:stability_report.SystemMemoryState)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .stability_report.SystemMemoryState.WindowsMemory windows_memory = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.windows_memory_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SystemMemoryState::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SystemMemoryState*>(&from));
}

void SystemMemoryState::MergeFrom(const SystemMemoryState& from)
{
    SystemMemoryState* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:stability_report.SystemMemoryState)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_windows_memory()) {
        _this->_internal_mutable_windows_memory()->::stability_report::SystemMemoryState_WindowsMemory::MergeFrom(from._internal_windows_memory());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SystemMemoryState::CopyFrom(const SystemMemoryState& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:stability_report.SystemMemoryState)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SystemMemoryState::IsInitialized() const
{
    return true;
}

void SystemMemoryState::InternalSwap(SystemMemoryState* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.windows_memory_, other->_impl_.windows_memory_);
}

std::string SystemMemoryState::GetTypeName() const
{
    return "stability_report.SystemMemoryState";
}

// ===================================================================

class StabilityReport::_Internal {
public:
    using HasBits = decltype(std::declval<StabilityReport>()._impl_._has_bits_);
    static const ::stability_report::SystemMemoryState& system_memory_state(const StabilityReport* msg);
    static void set_has_system_memory_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::stability_report::SystemMemoryState& StabilityReport::_Internal::system_memory_state(const StabilityReport* msg)
{
    return *msg->_impl_.system_memory_state_;
}
StabilityReport::StabilityReport(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:stability_report.StabilityReport)
}
StabilityReport::StabilityReport(const StabilityReport& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    StabilityReport* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.process_states_) { from._impl_.process_states_ }, decltype(_impl_.system_memory_state_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_system_memory_state()) {
        _this->_impl_.system_memory_state_ = new ::stability_report::SystemMemoryState(*from._impl_.system_memory_state_);
    }
    // @@protoc_insertion_point(copy_constructor:stability_report.StabilityReport)
}

inline void StabilityReport::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.process_states_) { arena },
        decltype(_impl_.system_memory_state_) { nullptr } };
}

StabilityReport::~StabilityReport()
{
    // @@protoc_insertion_point(destructor:stability_report.StabilityReport)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void StabilityReport::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.process_states_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.system_memory_state_;
}

void StabilityReport::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void StabilityReport::Clear()
{
    // @@protoc_insertion_point(message_clear_start:stability_report.StabilityReport)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.process_states_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.system_memory_state_ != nullptr);
        _impl_.system_memory_state_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* StabilityReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .stability_report.ProcessState process_states = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_process_states(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .stability_report.SystemMemoryState system_memory_state = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_system_memory_state(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* StabilityReport::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:stability_report.StabilityReport)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .stability_report.ProcessState process_states = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_process_states_size()); i < n; i++) {
        const auto& repfield = this->_internal_process_states(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .stability_report.SystemMemoryState system_memory_state = 7;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::system_memory_state(this), _Internal::system_memory_state(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:stability_report.StabilityReport)
    return target;
}

size_t StabilityReport::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:stability_report.StabilityReport)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .stability_report.ProcessState process_states = 2;
    total_size += 1UL * this->_internal_process_states_size();
    for (const auto& msg : this->_impl_.process_states_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional .stability_report.SystemMemoryState system_memory_state = 7;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.system_memory_state_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void StabilityReport::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const StabilityReport*>(&from));
}

void StabilityReport::MergeFrom(const StabilityReport& from)
{
    StabilityReport* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:stability_report.StabilityReport)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.process_states_.MergeFrom(from._impl_.process_states_);
    if (from._internal_has_system_memory_state()) {
        _this->_internal_mutable_system_memory_state()->::stability_report::SystemMemoryState::MergeFrom(from._internal_system_memory_state());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StabilityReport::CopyFrom(const StabilityReport& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:stability_report.StabilityReport)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool StabilityReport::IsInitialized() const
{
    return true;
}

void StabilityReport::InternalSwap(StabilityReport* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.process_states_.InternalSwap(&other->_impl_.process_states_);
    swap(_impl_.system_memory_state_, other->_impl_.system_memory_state_);
}

std::string StabilityReport::GetTypeName() const
{
    return "stability_report.StabilityReport";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace stability_report
PROTOBUF_NAMESPACE_OPEN
template <>
PROTOBUF_NOINLINE ::stability_report::ProcessState_MemoryState_WindowsMemory*
Arena::CreateMaybeMessage<::stability_report::ProcessState_MemoryState_WindowsMemory>(Arena* arena)
{
    return Arena::CreateMessageInternal<::stability_report::ProcessState_MemoryState_WindowsMemory>(arena);
}
template <>
PROTOBUF_NOINLINE ::stability_report::ProcessState_MemoryState* Arena::CreateMaybeMessage<::stability_report::ProcessState_MemoryState>(Arena* arena)
{
    return Arena::CreateMessageInternal<::stability_report::ProcessState_MemoryState>(arena);
}
template <>
PROTOBUF_NOINLINE ::stability_report::ProcessState_FileSystemState_PosixFileSystemState*
Arena::CreateMaybeMessage<::stability_report::ProcessState_FileSystemState_PosixFileSystemState>(Arena* arena)
{
    return Arena::CreateMessageInternal<::stability_report::ProcessState_FileSystemState_PosixFileSystemState>(arena);
}
template <>
PROTOBUF_NOINLINE ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState*
Arena::CreateMaybeMessage<::stability_report::ProcessState_FileSystemState_WindowsFileSystemState>(Arena* arena)
{
    return Arena::CreateMessageInternal<::stability_report::ProcessState_FileSystemState_WindowsFileSystemState>(arena);
}
template <>
PROTOBUF_NOINLINE ::stability_report::ProcessState_FileSystemState* Arena::CreateMaybeMessage<::stability_report::ProcessState_FileSystemState>(Arena* arena)
{
    return Arena::CreateMessageInternal<::stability_report::ProcessState_FileSystemState>(arena);
}
template <> PROTOBUF_NOINLINE ::stability_report::ProcessState* Arena::CreateMaybeMessage<::stability_report::ProcessState>(Arena* arena)
{
    return Arena::CreateMessageInternal<::stability_report::ProcessState>(arena);
}
template <>
PROTOBUF_NOINLINE ::stability_report::SystemMemoryState_WindowsMemory* Arena::CreateMaybeMessage<::stability_report::SystemMemoryState_WindowsMemory>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::stability_report::SystemMemoryState_WindowsMemory>(arena);
}
template <> PROTOBUF_NOINLINE ::stability_report::SystemMemoryState* Arena::CreateMaybeMessage<::stability_report::SystemMemoryState>(Arena* arena)
{
    return Arena::CreateMessageInternal<::stability_report::SystemMemoryState>(arena);
}
template <> PROTOBUF_NOINLINE ::stability_report::StabilityReport* Arena::CreateMaybeMessage<::stability_report::StabilityReport>(Arena* arena)
{
    return Arena::CreateMessageInternal<::stability_report::StabilityReport>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
