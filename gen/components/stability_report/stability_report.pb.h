// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: stability_report.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_stability_5freport_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_stability_5freport_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_stability_5freport_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_stability_5freport_2eproto {
    static const uint32_t offsets[];
};
namespace stability_report {
class ProcessState;
struct ProcessStateDefaultTypeInternal;
extern ProcessStateDefaultTypeInternal _ProcessState_default_instance_;
class ProcessState_FileSystemState;
struct ProcessState_FileSystemStateDefaultTypeInternal;
extern ProcessState_FileSystemStateDefaultTypeInternal _ProcessState_FileSystemState_default_instance_;
class ProcessState_FileSystemState_PosixFileSystemState;
struct ProcessState_FileSystemState_PosixFileSystemStateDefaultTypeInternal;
extern ProcessState_FileSystemState_PosixFileSystemStateDefaultTypeInternal _ProcessState_FileSystemState_PosixFileSystemState_default_instance_;
class ProcessState_FileSystemState_WindowsFileSystemState;
struct ProcessState_FileSystemState_WindowsFileSystemStateDefaultTypeInternal;
extern ProcessState_FileSystemState_WindowsFileSystemStateDefaultTypeInternal _ProcessState_FileSystemState_WindowsFileSystemState_default_instance_;
class ProcessState_MemoryState;
struct ProcessState_MemoryStateDefaultTypeInternal;
extern ProcessState_MemoryStateDefaultTypeInternal _ProcessState_MemoryState_default_instance_;
class ProcessState_MemoryState_WindowsMemory;
struct ProcessState_MemoryState_WindowsMemoryDefaultTypeInternal;
extern ProcessState_MemoryState_WindowsMemoryDefaultTypeInternal _ProcessState_MemoryState_WindowsMemory_default_instance_;
class StabilityReport;
struct StabilityReportDefaultTypeInternal;
extern StabilityReportDefaultTypeInternal _StabilityReport_default_instance_;
class SystemMemoryState;
struct SystemMemoryStateDefaultTypeInternal;
extern SystemMemoryStateDefaultTypeInternal _SystemMemoryState_default_instance_;
class SystemMemoryState_WindowsMemory;
struct SystemMemoryState_WindowsMemoryDefaultTypeInternal;
extern SystemMemoryState_WindowsMemoryDefaultTypeInternal _SystemMemoryState_WindowsMemory_default_instance_;
} // namespace stability_report
PROTOBUF_NAMESPACE_OPEN
template <>::stability_report::ProcessState* Arena::CreateMaybeMessage<::stability_report::ProcessState>(Arena*);
template <>::stability_report::ProcessState_FileSystemState* Arena::CreateMaybeMessage<::stability_report::ProcessState_FileSystemState>(Arena*);
template <>
::stability_report::ProcessState_FileSystemState_PosixFileSystemState*
Arena::CreateMaybeMessage<::stability_report::ProcessState_FileSystemState_PosixFileSystemState>(Arena*);
template <>
::stability_report::ProcessState_FileSystemState_WindowsFileSystemState*
Arena::CreateMaybeMessage<::stability_report::ProcessState_FileSystemState_WindowsFileSystemState>(Arena*);
template <>::stability_report::ProcessState_MemoryState* Arena::CreateMaybeMessage<::stability_report::ProcessState_MemoryState>(Arena*);
template <>
::stability_report::ProcessState_MemoryState_WindowsMemory* Arena::CreateMaybeMessage<::stability_report::ProcessState_MemoryState_WindowsMemory>(Arena*);
template <>::stability_report::StabilityReport* Arena::CreateMaybeMessage<::stability_report::StabilityReport>(Arena*);
template <>::stability_report::SystemMemoryState* Arena::CreateMaybeMessage<::stability_report::SystemMemoryState>(Arena*);
template <>::stability_report::SystemMemoryState_WindowsMemory* Arena::CreateMaybeMessage<::stability_report::SystemMemoryState_WindowsMemory>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace stability_report {

// ===================================================================

class ProcessState_MemoryState_WindowsMemory final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:stability_report.ProcessState.MemoryState.WindowsMemory) */ {
public:
    inline ProcessState_MemoryState_WindowsMemory()
        : ProcessState_MemoryState_WindowsMemory(nullptr)
    {
    }
    ~ProcessState_MemoryState_WindowsMemory() override;
    explicit PROTOBUF_CONSTEXPR ProcessState_MemoryState_WindowsMemory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ProcessState_MemoryState_WindowsMemory(const ProcessState_MemoryState_WindowsMemory& from);
    ProcessState_MemoryState_WindowsMemory(ProcessState_MemoryState_WindowsMemory&& from) noexcept
        : ProcessState_MemoryState_WindowsMemory()
    {
        *this = ::std::move(from);
    }

    inline ProcessState_MemoryState_WindowsMemory& operator=(const ProcessState_MemoryState_WindowsMemory& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ProcessState_MemoryState_WindowsMemory& operator=(ProcessState_MemoryState_WindowsMemory&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ProcessState_MemoryState_WindowsMemory& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ProcessState_MemoryState_WindowsMemory* internal_default_instance()
    {
        return reinterpret_cast<const ProcessState_MemoryState_WindowsMemory*>(&_ProcessState_MemoryState_WindowsMemory_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(ProcessState_MemoryState_WindowsMemory& a, ProcessState_MemoryState_WindowsMemory& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ProcessState_MemoryState_WindowsMemory* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ProcessState_MemoryState_WindowsMemory* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ProcessState_MemoryState_WindowsMemory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ProcessState_MemoryState_WindowsMemory>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ProcessState_MemoryState_WindowsMemory& from);
    void MergeFrom(const ProcessState_MemoryState_WindowsMemory& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ProcessState_MemoryState_WindowsMemory* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "stability_report.ProcessState.MemoryState.WindowsMemory";
    }

protected:
    explicit ProcessState_MemoryState_WindowsMemory(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kProcessPrivateUsageFieldNumber = 1,
        kProcessPeakWorkingsetSizeFieldNumber = 2,
        kProcessPeakPagefileUsageFieldNumber = 3,
        kProcessAllocationAttemptFieldNumber = 4,
    };
    // optional uint32 process_private_usage = 1;
    bool has_process_private_usage() const;

private:
    bool _internal_has_process_private_usage() const;

public:
    void clear_process_private_usage();
    uint32_t process_private_usage() const;
    void set_process_private_usage(uint32_t value);

private:
    uint32_t _internal_process_private_usage() const;
    void _internal_set_process_private_usage(uint32_t value);

public:
    // optional uint32 process_peak_workingset_size = 2;
    bool has_process_peak_workingset_size() const;

private:
    bool _internal_has_process_peak_workingset_size() const;

public:
    void clear_process_peak_workingset_size();
    uint32_t process_peak_workingset_size() const;
    void set_process_peak_workingset_size(uint32_t value);

private:
    uint32_t _internal_process_peak_workingset_size() const;
    void _internal_set_process_peak_workingset_size(uint32_t value);

public:
    // optional uint32 process_peak_pagefile_usage = 3;
    bool has_process_peak_pagefile_usage() const;

private:
    bool _internal_has_process_peak_pagefile_usage() const;

public:
    void clear_process_peak_pagefile_usage();
    uint32_t process_peak_pagefile_usage() const;
    void set_process_peak_pagefile_usage(uint32_t value);

private:
    uint32_t _internal_process_peak_pagefile_usage() const;
    void _internal_set_process_peak_pagefile_usage(uint32_t value);

public:
    // optional uint32 process_allocation_attempt = 4;
    bool has_process_allocation_attempt() const;

private:
    bool _internal_has_process_allocation_attempt() const;

public:
    void clear_process_allocation_attempt();
    uint32_t process_allocation_attempt() const;
    void set_process_allocation_attempt(uint32_t value);

private:
    uint32_t _internal_process_allocation_attempt() const;
    void _internal_set_process_allocation_attempt(uint32_t value);

public:
    // @@protoc_insertion_point(class_scope:stability_report.ProcessState.MemoryState.WindowsMemory)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t process_private_usage_;
        uint32_t process_peak_workingset_size_;
        uint32_t process_peak_pagefile_usage_;
        uint32_t process_allocation_attempt_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_stability_5freport_2eproto;
};
// -------------------------------------------------------------------

class ProcessState_MemoryState final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:stability_report.ProcessState.MemoryState) */ {
public:
    inline ProcessState_MemoryState()
        : ProcessState_MemoryState(nullptr)
    {
    }
    ~ProcessState_MemoryState() override;
    explicit PROTOBUF_CONSTEXPR ProcessState_MemoryState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ProcessState_MemoryState(const ProcessState_MemoryState& from);
    ProcessState_MemoryState(ProcessState_MemoryState&& from) noexcept
        : ProcessState_MemoryState()
    {
        *this = ::std::move(from);
    }

    inline ProcessState_MemoryState& operator=(const ProcessState_MemoryState& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ProcessState_MemoryState& operator=(ProcessState_MemoryState&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ProcessState_MemoryState& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ProcessState_MemoryState* internal_default_instance()
    {
        return reinterpret_cast<const ProcessState_MemoryState*>(&_ProcessState_MemoryState_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(ProcessState_MemoryState& a, ProcessState_MemoryState& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ProcessState_MemoryState* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ProcessState_MemoryState* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ProcessState_MemoryState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ProcessState_MemoryState>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ProcessState_MemoryState& from);
    void MergeFrom(const ProcessState_MemoryState& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ProcessState_MemoryState* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "stability_report.ProcessState.MemoryState";
    }

protected:
    explicit ProcessState_MemoryState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ProcessState_MemoryState_WindowsMemory WindowsMemory;

    // accessors -------------------------------------------------------

    enum : int {
        kWindowsMemoryFieldNumber = 1,
    };
    // optional .stability_report.ProcessState.MemoryState.WindowsMemory windows_memory = 1;
    bool has_windows_memory() const;

private:
    bool _internal_has_windows_memory() const;

public:
    void clear_windows_memory();
    const ::stability_report::ProcessState_MemoryState_WindowsMemory& windows_memory() const;
    PROTOBUF_NODISCARD ::stability_report::ProcessState_MemoryState_WindowsMemory* release_windows_memory();
    ::stability_report::ProcessState_MemoryState_WindowsMemory* mutable_windows_memory();
    void set_allocated_windows_memory(::stability_report::ProcessState_MemoryState_WindowsMemory* windows_memory);

private:
    const ::stability_report::ProcessState_MemoryState_WindowsMemory& _internal_windows_memory() const;
    ::stability_report::ProcessState_MemoryState_WindowsMemory* _internal_mutable_windows_memory();

public:
    void unsafe_arena_set_allocated_windows_memory(::stability_report::ProcessState_MemoryState_WindowsMemory* windows_memory);
    ::stability_report::ProcessState_MemoryState_WindowsMemory* unsafe_arena_release_windows_memory();

    // @@protoc_insertion_point(class_scope:stability_report.ProcessState.MemoryState)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::stability_report::ProcessState_MemoryState_WindowsMemory* windows_memory_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_stability_5freport_2eproto;
};
// -------------------------------------------------------------------

class ProcessState_FileSystemState_PosixFileSystemState final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:stability_report.ProcessState.FileSystemState.PosixFileSystemState) */ {
public:
    inline ProcessState_FileSystemState_PosixFileSystemState()
        : ProcessState_FileSystemState_PosixFileSystemState(nullptr)
    {
    }
    ~ProcessState_FileSystemState_PosixFileSystemState() override;
    explicit PROTOBUF_CONSTEXPR ProcessState_FileSystemState_PosixFileSystemState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ProcessState_FileSystemState_PosixFileSystemState(const ProcessState_FileSystemState_PosixFileSystemState& from);
    ProcessState_FileSystemState_PosixFileSystemState(ProcessState_FileSystemState_PosixFileSystemState&& from) noexcept
        : ProcessState_FileSystemState_PosixFileSystemState()
    {
        *this = ::std::move(from);
    }

    inline ProcessState_FileSystemState_PosixFileSystemState& operator=(const ProcessState_FileSystemState_PosixFileSystemState& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ProcessState_FileSystemState_PosixFileSystemState& operator=(ProcessState_FileSystemState_PosixFileSystemState&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ProcessState_FileSystemState_PosixFileSystemState& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ProcessState_FileSystemState_PosixFileSystemState* internal_default_instance()
    {
        return reinterpret_cast<const ProcessState_FileSystemState_PosixFileSystemState*>(
            &_ProcessState_FileSystemState_PosixFileSystemState_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(ProcessState_FileSystemState_PosixFileSystemState& a, ProcessState_FileSystemState_PosixFileSystemState& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ProcessState_FileSystemState_PosixFileSystemState* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ProcessState_FileSystemState_PosixFileSystemState* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ProcessState_FileSystemState_PosixFileSystemState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ProcessState_FileSystemState_PosixFileSystemState>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ProcessState_FileSystemState_PosixFileSystemState& from);
    void MergeFrom(const ProcessState_FileSystemState_PosixFileSystemState& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ProcessState_FileSystemState_PosixFileSystemState* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "stability_report.ProcessState.FileSystemState.PosixFileSystemState";
    }

protected:
    explicit ProcessState_FileSystemState_PosixFileSystemState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kOpenFileDescriptorsFieldNumber = 1,
    };
    // optional uint32 open_file_descriptors = 1;
    bool has_open_file_descriptors() const;

private:
    bool _internal_has_open_file_descriptors() const;

public:
    void clear_open_file_descriptors();
    uint32_t open_file_descriptors() const;
    void set_open_file_descriptors(uint32_t value);

private:
    uint32_t _internal_open_file_descriptors() const;
    void _internal_set_open_file_descriptors(uint32_t value);

public:
    // @@protoc_insertion_point(class_scope:stability_report.ProcessState.FileSystemState.PosixFileSystemState)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t open_file_descriptors_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_stability_5freport_2eproto;
};
// -------------------------------------------------------------------

class ProcessState_FileSystemState_WindowsFileSystemState final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:stability_report.ProcessState.FileSystemState.WindowsFileSystemState) */ {
public:
    inline ProcessState_FileSystemState_WindowsFileSystemState()
        : ProcessState_FileSystemState_WindowsFileSystemState(nullptr)
    {
    }
    ~ProcessState_FileSystemState_WindowsFileSystemState() override;
    explicit PROTOBUF_CONSTEXPR ProcessState_FileSystemState_WindowsFileSystemState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ProcessState_FileSystemState_WindowsFileSystemState(const ProcessState_FileSystemState_WindowsFileSystemState& from);
    ProcessState_FileSystemState_WindowsFileSystemState(ProcessState_FileSystemState_WindowsFileSystemState&& from) noexcept
        : ProcessState_FileSystemState_WindowsFileSystemState()
    {
        *this = ::std::move(from);
    }

    inline ProcessState_FileSystemState_WindowsFileSystemState& operator=(const ProcessState_FileSystemState_WindowsFileSystemState& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ProcessState_FileSystemState_WindowsFileSystemState& operator=(ProcessState_FileSystemState_WindowsFileSystemState&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ProcessState_FileSystemState_WindowsFileSystemState& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ProcessState_FileSystemState_WindowsFileSystemState* internal_default_instance()
    {
        return reinterpret_cast<const ProcessState_FileSystemState_WindowsFileSystemState*>(
            &_ProcessState_FileSystemState_WindowsFileSystemState_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(ProcessState_FileSystemState_WindowsFileSystemState& a, ProcessState_FileSystemState_WindowsFileSystemState& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ProcessState_FileSystemState_WindowsFileSystemState* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ProcessState_FileSystemState_WindowsFileSystemState* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ProcessState_FileSystemState_WindowsFileSystemState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ProcessState_FileSystemState_WindowsFileSystemState>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ProcessState_FileSystemState_WindowsFileSystemState& from);
    void MergeFrom(const ProcessState_FileSystemState_WindowsFileSystemState& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ProcessState_FileSystemState_WindowsFileSystemState* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "stability_report.ProcessState.FileSystemState.WindowsFileSystemState";
    }

protected:
    explicit ProcessState_FileSystemState_WindowsFileSystemState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kProcessHandleCountFieldNumber = 1,
    };
    // optional uint32 process_handle_count = 1;
    bool has_process_handle_count() const;

private:
    bool _internal_has_process_handle_count() const;

public:
    void clear_process_handle_count();
    uint32_t process_handle_count() const;
    void set_process_handle_count(uint32_t value);

private:
    uint32_t _internal_process_handle_count() const;
    void _internal_set_process_handle_count(uint32_t value);

public:
    // @@protoc_insertion_point(class_scope:stability_report.ProcessState.FileSystemState.WindowsFileSystemState)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t process_handle_count_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_stability_5freport_2eproto;
};
// -------------------------------------------------------------------

class ProcessState_FileSystemState final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:stability_report.ProcessState.FileSystemState) */ {
public:
    inline ProcessState_FileSystemState()
        : ProcessState_FileSystemState(nullptr)
    {
    }
    ~ProcessState_FileSystemState() override;
    explicit PROTOBUF_CONSTEXPR ProcessState_FileSystemState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ProcessState_FileSystemState(const ProcessState_FileSystemState& from);
    ProcessState_FileSystemState(ProcessState_FileSystemState&& from) noexcept
        : ProcessState_FileSystemState()
    {
        *this = ::std::move(from);
    }

    inline ProcessState_FileSystemState& operator=(const ProcessState_FileSystemState& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ProcessState_FileSystemState& operator=(ProcessState_FileSystemState&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ProcessState_FileSystemState& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ProcessState_FileSystemState* internal_default_instance()
    {
        return reinterpret_cast<const ProcessState_FileSystemState*>(&_ProcessState_FileSystemState_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(ProcessState_FileSystemState& a, ProcessState_FileSystemState& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ProcessState_FileSystemState* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ProcessState_FileSystemState* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ProcessState_FileSystemState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ProcessState_FileSystemState>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ProcessState_FileSystemState& from);
    void MergeFrom(const ProcessState_FileSystemState& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ProcessState_FileSystemState* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "stability_report.ProcessState.FileSystemState";
    }

protected:
    explicit ProcessState_FileSystemState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ProcessState_FileSystemState_PosixFileSystemState PosixFileSystemState;
    typedef ProcessState_FileSystemState_WindowsFileSystemState WindowsFileSystemState;

    // accessors -------------------------------------------------------

    enum : int {
        kPosixFileSystemStateFieldNumber = 1,
        kWindowsFileSystemStateFieldNumber = 2,
    };
    // optional .stability_report.ProcessState.FileSystemState.PosixFileSystemState posix_file_system_state = 1;
    bool has_posix_file_system_state() const;

private:
    bool _internal_has_posix_file_system_state() const;

public:
    void clear_posix_file_system_state();
    const ::stability_report::ProcessState_FileSystemState_PosixFileSystemState& posix_file_system_state() const;
    PROTOBUF_NODISCARD ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* release_posix_file_system_state();
    ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* mutable_posix_file_system_state();
    void set_allocated_posix_file_system_state(::stability_report::ProcessState_FileSystemState_PosixFileSystemState* posix_file_system_state);

private:
    const ::stability_report::ProcessState_FileSystemState_PosixFileSystemState& _internal_posix_file_system_state() const;
    ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* _internal_mutable_posix_file_system_state();

public:
    void unsafe_arena_set_allocated_posix_file_system_state(::stability_report::ProcessState_FileSystemState_PosixFileSystemState* posix_file_system_state);
    ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* unsafe_arena_release_posix_file_system_state();

    // optional .stability_report.ProcessState.FileSystemState.WindowsFileSystemState windows_file_system_state = 2;
    bool has_windows_file_system_state() const;

private:
    bool _internal_has_windows_file_system_state() const;

public:
    void clear_windows_file_system_state();
    const ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState& windows_file_system_state() const;
    PROTOBUF_NODISCARD ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* release_windows_file_system_state();
    ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* mutable_windows_file_system_state();
    void set_allocated_windows_file_system_state(::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* windows_file_system_state);

private:
    const ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState& _internal_windows_file_system_state() const;
    ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* _internal_mutable_windows_file_system_state();

public:
    void unsafe_arena_set_allocated_windows_file_system_state(
        ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* windows_file_system_state);
    ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* unsafe_arena_release_windows_file_system_state();

    // @@protoc_insertion_point(class_scope:stability_report.ProcessState.FileSystemState)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* posix_file_system_state_;
        ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* windows_file_system_state_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_stability_5freport_2eproto;
};
// -------------------------------------------------------------------

class ProcessState final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:stability_report.ProcessState) */ {
public:
    inline ProcessState()
        : ProcessState(nullptr)
    {
    }
    ~ProcessState() override;
    explicit PROTOBUF_CONSTEXPR ProcessState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ProcessState(const ProcessState& from);
    ProcessState(ProcessState&& from) noexcept
        : ProcessState()
    {
        *this = ::std::move(from);
    }

    inline ProcessState& operator=(const ProcessState& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ProcessState& operator=(ProcessState&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ProcessState& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ProcessState* internal_default_instance()
    {
        return reinterpret_cast<const ProcessState*>(&_ProcessState_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(ProcessState& a, ProcessState& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ProcessState* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ProcessState* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ProcessState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ProcessState>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ProcessState& from);
    void MergeFrom(const ProcessState& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ProcessState* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "stability_report.ProcessState";
    }

protected:
    explicit ProcessState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ProcessState_MemoryState MemoryState;
    typedef ProcessState_FileSystemState FileSystemState;

    // accessors -------------------------------------------------------

    enum : int {
        kMemoryStateFieldNumber = 4,
        kFileSystemStateFieldNumber = 7,
        kProcessIdFieldNumber = 3,
    };
    // optional .stability_report.ProcessState.MemoryState memory_state = 4;
    bool has_memory_state() const;

private:
    bool _internal_has_memory_state() const;

public:
    void clear_memory_state();
    const ::stability_report::ProcessState_MemoryState& memory_state() const;
    PROTOBUF_NODISCARD ::stability_report::ProcessState_MemoryState* release_memory_state();
    ::stability_report::ProcessState_MemoryState* mutable_memory_state();
    void set_allocated_memory_state(::stability_report::ProcessState_MemoryState* memory_state);

private:
    const ::stability_report::ProcessState_MemoryState& _internal_memory_state() const;
    ::stability_report::ProcessState_MemoryState* _internal_mutable_memory_state();

public:
    void unsafe_arena_set_allocated_memory_state(::stability_report::ProcessState_MemoryState* memory_state);
    ::stability_report::ProcessState_MemoryState* unsafe_arena_release_memory_state();

    // optional .stability_report.ProcessState.FileSystemState file_system_state = 7;
    bool has_file_system_state() const;

private:
    bool _internal_has_file_system_state() const;

public:
    void clear_file_system_state();
    const ::stability_report::ProcessState_FileSystemState& file_system_state() const;
    PROTOBUF_NODISCARD ::stability_report::ProcessState_FileSystemState* release_file_system_state();
    ::stability_report::ProcessState_FileSystemState* mutable_file_system_state();
    void set_allocated_file_system_state(::stability_report::ProcessState_FileSystemState* file_system_state);

private:
    const ::stability_report::ProcessState_FileSystemState& _internal_file_system_state() const;
    ::stability_report::ProcessState_FileSystemState* _internal_mutable_file_system_state();

public:
    void unsafe_arena_set_allocated_file_system_state(::stability_report::ProcessState_FileSystemState* file_system_state);
    ::stability_report::ProcessState_FileSystemState* unsafe_arena_release_file_system_state();

    // optional int64 process_id = 3;
    bool has_process_id() const;

private:
    bool _internal_has_process_id() const;

public:
    void clear_process_id();
    int64_t process_id() const;
    void set_process_id(int64_t value);

private:
    int64_t _internal_process_id() const;
    void _internal_set_process_id(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:stability_report.ProcessState)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::stability_report::ProcessState_MemoryState* memory_state_;
        ::stability_report::ProcessState_FileSystemState* file_system_state_;
        int64_t process_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_stability_5freport_2eproto;
};
// -------------------------------------------------------------------

class SystemMemoryState_WindowsMemory final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:stability_report.SystemMemoryState.WindowsMemory) */ {
public:
    inline SystemMemoryState_WindowsMemory()
        : SystemMemoryState_WindowsMemory(nullptr)
    {
    }
    ~SystemMemoryState_WindowsMemory() override;
    explicit PROTOBUF_CONSTEXPR SystemMemoryState_WindowsMemory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SystemMemoryState_WindowsMemory(const SystemMemoryState_WindowsMemory& from);
    SystemMemoryState_WindowsMemory(SystemMemoryState_WindowsMemory&& from) noexcept
        : SystemMemoryState_WindowsMemory()
    {
        *this = ::std::move(from);
    }

    inline SystemMemoryState_WindowsMemory& operator=(const SystemMemoryState_WindowsMemory& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SystemMemoryState_WindowsMemory& operator=(SystemMemoryState_WindowsMemory&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SystemMemoryState_WindowsMemory& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SystemMemoryState_WindowsMemory* internal_default_instance()
    {
        return reinterpret_cast<const SystemMemoryState_WindowsMemory*>(&_SystemMemoryState_WindowsMemory_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(SystemMemoryState_WindowsMemory& a, SystemMemoryState_WindowsMemory& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SystemMemoryState_WindowsMemory* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SystemMemoryState_WindowsMemory* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SystemMemoryState_WindowsMemory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SystemMemoryState_WindowsMemory>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SystemMemoryState_WindowsMemory& from);
    void MergeFrom(const SystemMemoryState_WindowsMemory& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SystemMemoryState_WindowsMemory* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "stability_report.SystemMemoryState.WindowsMemory";
    }

protected:
    explicit SystemMemoryState_WindowsMemory(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSystemCommitLimitFieldNumber = 1,
        kSystemCommitRemainingFieldNumber = 2,
        kSystemHandleCountFieldNumber = 3,
    };
    // optional uint32 system_commit_limit = 1;
    bool has_system_commit_limit() const;

private:
    bool _internal_has_system_commit_limit() const;

public:
    void clear_system_commit_limit();
    uint32_t system_commit_limit() const;
    void set_system_commit_limit(uint32_t value);

private:
    uint32_t _internal_system_commit_limit() const;
    void _internal_set_system_commit_limit(uint32_t value);

public:
    // optional uint32 system_commit_remaining = 2;
    bool has_system_commit_remaining() const;

private:
    bool _internal_has_system_commit_remaining() const;

public:
    void clear_system_commit_remaining();
    uint32_t system_commit_remaining() const;
    void set_system_commit_remaining(uint32_t value);

private:
    uint32_t _internal_system_commit_remaining() const;
    void _internal_set_system_commit_remaining(uint32_t value);

public:
    // optional uint32 system_handle_count = 3;
    bool has_system_handle_count() const;

private:
    bool _internal_has_system_handle_count() const;

public:
    void clear_system_handle_count();
    uint32_t system_handle_count() const;
    void set_system_handle_count(uint32_t value);

private:
    uint32_t _internal_system_handle_count() const;
    void _internal_set_system_handle_count(uint32_t value);

public:
    // @@protoc_insertion_point(class_scope:stability_report.SystemMemoryState.WindowsMemory)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t system_commit_limit_;
        uint32_t system_commit_remaining_;
        uint32_t system_handle_count_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_stability_5freport_2eproto;
};
// -------------------------------------------------------------------

class SystemMemoryState final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:stability_report.SystemMemoryState) */ {
public:
    inline SystemMemoryState()
        : SystemMemoryState(nullptr)
    {
    }
    ~SystemMemoryState() override;
    explicit PROTOBUF_CONSTEXPR SystemMemoryState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SystemMemoryState(const SystemMemoryState& from);
    SystemMemoryState(SystemMemoryState&& from) noexcept
        : SystemMemoryState()
    {
        *this = ::std::move(from);
    }

    inline SystemMemoryState& operator=(const SystemMemoryState& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SystemMemoryState& operator=(SystemMemoryState&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SystemMemoryState& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SystemMemoryState* internal_default_instance()
    {
        return reinterpret_cast<const SystemMemoryState*>(&_SystemMemoryState_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(SystemMemoryState& a, SystemMemoryState& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SystemMemoryState* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SystemMemoryState* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SystemMemoryState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SystemMemoryState>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SystemMemoryState& from);
    void MergeFrom(const SystemMemoryState& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SystemMemoryState* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "stability_report.SystemMemoryState";
    }

protected:
    explicit SystemMemoryState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef SystemMemoryState_WindowsMemory WindowsMemory;

    // accessors -------------------------------------------------------

    enum : int {
        kWindowsMemoryFieldNumber = 1,
    };
    // optional .stability_report.SystemMemoryState.WindowsMemory windows_memory = 1;
    bool has_windows_memory() const;

private:
    bool _internal_has_windows_memory() const;

public:
    void clear_windows_memory();
    const ::stability_report::SystemMemoryState_WindowsMemory& windows_memory() const;
    PROTOBUF_NODISCARD ::stability_report::SystemMemoryState_WindowsMemory* release_windows_memory();
    ::stability_report::SystemMemoryState_WindowsMemory* mutable_windows_memory();
    void set_allocated_windows_memory(::stability_report::SystemMemoryState_WindowsMemory* windows_memory);

private:
    const ::stability_report::SystemMemoryState_WindowsMemory& _internal_windows_memory() const;
    ::stability_report::SystemMemoryState_WindowsMemory* _internal_mutable_windows_memory();

public:
    void unsafe_arena_set_allocated_windows_memory(::stability_report::SystemMemoryState_WindowsMemory* windows_memory);
    ::stability_report::SystemMemoryState_WindowsMemory* unsafe_arena_release_windows_memory();

    // @@protoc_insertion_point(class_scope:stability_report.SystemMemoryState)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::stability_report::SystemMemoryState_WindowsMemory* windows_memory_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_stability_5freport_2eproto;
};
// -------------------------------------------------------------------

class StabilityReport final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:stability_report.StabilityReport) */ {
public:
    inline StabilityReport()
        : StabilityReport(nullptr)
    {
    }
    ~StabilityReport() override;
    explicit PROTOBUF_CONSTEXPR StabilityReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    StabilityReport(const StabilityReport& from);
    StabilityReport(StabilityReport&& from) noexcept
        : StabilityReport()
    {
        *this = ::std::move(from);
    }

    inline StabilityReport& operator=(const StabilityReport& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline StabilityReport& operator=(StabilityReport&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const StabilityReport& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const StabilityReport* internal_default_instance()
    {
        return reinterpret_cast<const StabilityReport*>(&_StabilityReport_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(StabilityReport& a, StabilityReport& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(StabilityReport* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(StabilityReport* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    StabilityReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<StabilityReport>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const StabilityReport& from);
    void MergeFrom(const StabilityReport& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(StabilityReport* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "stability_report.StabilityReport";
    }

protected:
    explicit StabilityReport(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kProcessStatesFieldNumber = 2,
        kSystemMemoryStateFieldNumber = 7,
    };
    // repeated .stability_report.ProcessState process_states = 2;
    int process_states_size() const;

private:
    int _internal_process_states_size() const;

public:
    void clear_process_states();
    ::stability_report::ProcessState* mutable_process_states(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::stability_report::ProcessState>* mutable_process_states();

private:
    const ::stability_report::ProcessState& _internal_process_states(int index) const;
    ::stability_report::ProcessState* _internal_add_process_states();

public:
    const ::stability_report::ProcessState& process_states(int index) const;
    ::stability_report::ProcessState* add_process_states();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::stability_report::ProcessState>& process_states() const;

    // optional .stability_report.SystemMemoryState system_memory_state = 7;
    bool has_system_memory_state() const;

private:
    bool _internal_has_system_memory_state() const;

public:
    void clear_system_memory_state();
    const ::stability_report::SystemMemoryState& system_memory_state() const;
    PROTOBUF_NODISCARD ::stability_report::SystemMemoryState* release_system_memory_state();
    ::stability_report::SystemMemoryState* mutable_system_memory_state();
    void set_allocated_system_memory_state(::stability_report::SystemMemoryState* system_memory_state);

private:
    const ::stability_report::SystemMemoryState& _internal_system_memory_state() const;
    ::stability_report::SystemMemoryState* _internal_mutable_system_memory_state();

public:
    void unsafe_arena_set_allocated_system_memory_state(::stability_report::SystemMemoryState* system_memory_state);
    ::stability_report::SystemMemoryState* unsafe_arena_release_system_memory_state();

    // @@protoc_insertion_point(class_scope:stability_report.StabilityReport)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::stability_report::ProcessState> process_states_;
        ::stability_report::SystemMemoryState* system_memory_state_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_stability_5freport_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// ProcessState_MemoryState_WindowsMemory

// optional uint32 process_private_usage = 1;
inline bool ProcessState_MemoryState_WindowsMemory::_internal_has_process_private_usage() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ProcessState_MemoryState_WindowsMemory::has_process_private_usage() const
{
    return _internal_has_process_private_usage();
}
inline void ProcessState_MemoryState_WindowsMemory::clear_process_private_usage()
{
    _impl_.process_private_usage_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ProcessState_MemoryState_WindowsMemory::_internal_process_private_usage() const
{
    return _impl_.process_private_usage_;
}
inline uint32_t ProcessState_MemoryState_WindowsMemory::process_private_usage() const
{
    // @@protoc_insertion_point(field_get:stability_report.ProcessState.MemoryState.WindowsMemory.process_private_usage)
    return _internal_process_private_usage();
}
inline void ProcessState_MemoryState_WindowsMemory::_internal_set_process_private_usage(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.process_private_usage_ = value;
}
inline void ProcessState_MemoryState_WindowsMemory::set_process_private_usage(uint32_t value)
{
    _internal_set_process_private_usage(value);
    // @@protoc_insertion_point(field_set:stability_report.ProcessState.MemoryState.WindowsMemory.process_private_usage)
}

// optional uint32 process_peak_workingset_size = 2;
inline bool ProcessState_MemoryState_WindowsMemory::_internal_has_process_peak_workingset_size() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ProcessState_MemoryState_WindowsMemory::has_process_peak_workingset_size() const
{
    return _internal_has_process_peak_workingset_size();
}
inline void ProcessState_MemoryState_WindowsMemory::clear_process_peak_workingset_size()
{
    _impl_.process_peak_workingset_size_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ProcessState_MemoryState_WindowsMemory::_internal_process_peak_workingset_size() const
{
    return _impl_.process_peak_workingset_size_;
}
inline uint32_t ProcessState_MemoryState_WindowsMemory::process_peak_workingset_size() const
{
    // @@protoc_insertion_point(field_get:stability_report.ProcessState.MemoryState.WindowsMemory.process_peak_workingset_size)
    return _internal_process_peak_workingset_size();
}
inline void ProcessState_MemoryState_WindowsMemory::_internal_set_process_peak_workingset_size(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.process_peak_workingset_size_ = value;
}
inline void ProcessState_MemoryState_WindowsMemory::set_process_peak_workingset_size(uint32_t value)
{
    _internal_set_process_peak_workingset_size(value);
    // @@protoc_insertion_point(field_set:stability_report.ProcessState.MemoryState.WindowsMemory.process_peak_workingset_size)
}

// optional uint32 process_peak_pagefile_usage = 3;
inline bool ProcessState_MemoryState_WindowsMemory::_internal_has_process_peak_pagefile_usage() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ProcessState_MemoryState_WindowsMemory::has_process_peak_pagefile_usage() const
{
    return _internal_has_process_peak_pagefile_usage();
}
inline void ProcessState_MemoryState_WindowsMemory::clear_process_peak_pagefile_usage()
{
    _impl_.process_peak_pagefile_usage_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ProcessState_MemoryState_WindowsMemory::_internal_process_peak_pagefile_usage() const
{
    return _impl_.process_peak_pagefile_usage_;
}
inline uint32_t ProcessState_MemoryState_WindowsMemory::process_peak_pagefile_usage() const
{
    // @@protoc_insertion_point(field_get:stability_report.ProcessState.MemoryState.WindowsMemory.process_peak_pagefile_usage)
    return _internal_process_peak_pagefile_usage();
}
inline void ProcessState_MemoryState_WindowsMemory::_internal_set_process_peak_pagefile_usage(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.process_peak_pagefile_usage_ = value;
}
inline void ProcessState_MemoryState_WindowsMemory::set_process_peak_pagefile_usage(uint32_t value)
{
    _internal_set_process_peak_pagefile_usage(value);
    // @@protoc_insertion_point(field_set:stability_report.ProcessState.MemoryState.WindowsMemory.process_peak_pagefile_usage)
}

// optional uint32 process_allocation_attempt = 4;
inline bool ProcessState_MemoryState_WindowsMemory::_internal_has_process_allocation_attempt() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ProcessState_MemoryState_WindowsMemory::has_process_allocation_attempt() const
{
    return _internal_has_process_allocation_attempt();
}
inline void ProcessState_MemoryState_WindowsMemory::clear_process_allocation_attempt()
{
    _impl_.process_allocation_attempt_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t ProcessState_MemoryState_WindowsMemory::_internal_process_allocation_attempt() const
{
    return _impl_.process_allocation_attempt_;
}
inline uint32_t ProcessState_MemoryState_WindowsMemory::process_allocation_attempt() const
{
    // @@protoc_insertion_point(field_get:stability_report.ProcessState.MemoryState.WindowsMemory.process_allocation_attempt)
    return _internal_process_allocation_attempt();
}
inline void ProcessState_MemoryState_WindowsMemory::_internal_set_process_allocation_attempt(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.process_allocation_attempt_ = value;
}
inline void ProcessState_MemoryState_WindowsMemory::set_process_allocation_attempt(uint32_t value)
{
    _internal_set_process_allocation_attempt(value);
    // @@protoc_insertion_point(field_set:stability_report.ProcessState.MemoryState.WindowsMemory.process_allocation_attempt)
}

// -------------------------------------------------------------------

// ProcessState_MemoryState

// optional .stability_report.ProcessState.MemoryState.WindowsMemory windows_memory = 1;
inline bool ProcessState_MemoryState::_internal_has_windows_memory() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.windows_memory_ != nullptr);
    return value;
}
inline bool ProcessState_MemoryState::has_windows_memory() const
{
    return _internal_has_windows_memory();
}
inline void ProcessState_MemoryState::clear_windows_memory()
{
    if (_impl_.windows_memory_ != nullptr)
        _impl_.windows_memory_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::stability_report::ProcessState_MemoryState_WindowsMemory& ProcessState_MemoryState::_internal_windows_memory() const
{
    const ::stability_report::ProcessState_MemoryState_WindowsMemory* p = _impl_.windows_memory_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::stability_report::ProcessState_MemoryState_WindowsMemory&>(
                            ::stability_report::_ProcessState_MemoryState_WindowsMemory_default_instance_);
}
inline const ::stability_report::ProcessState_MemoryState_WindowsMemory& ProcessState_MemoryState::windows_memory() const
{
    // @@protoc_insertion_point(field_get:stability_report.ProcessState.MemoryState.windows_memory)
    return _internal_windows_memory();
}
inline void ProcessState_MemoryState::unsafe_arena_set_allocated_windows_memory(::stability_report::ProcessState_MemoryState_WindowsMemory* windows_memory)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.windows_memory_);
    }
    _impl_.windows_memory_ = windows_memory;
    if (windows_memory) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:stability_report.ProcessState.MemoryState.windows_memory)
}
inline ::stability_report::ProcessState_MemoryState_WindowsMemory* ProcessState_MemoryState::release_windows_memory()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::stability_report::ProcessState_MemoryState_WindowsMemory* temp = _impl_.windows_memory_;
    _impl_.windows_memory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::stability_report::ProcessState_MemoryState_WindowsMemory* ProcessState_MemoryState::unsafe_arena_release_windows_memory()
{
    // @@protoc_insertion_point(field_release:stability_report.ProcessState.MemoryState.windows_memory)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::stability_report::ProcessState_MemoryState_WindowsMemory* temp = _impl_.windows_memory_;
    _impl_.windows_memory_ = nullptr;
    return temp;
}
inline ::stability_report::ProcessState_MemoryState_WindowsMemory* ProcessState_MemoryState::_internal_mutable_windows_memory()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.windows_memory_ == nullptr) {
        auto* p = CreateMaybeMessage<::stability_report::ProcessState_MemoryState_WindowsMemory>(GetArenaForAllocation());
        _impl_.windows_memory_ = p;
    }
    return _impl_.windows_memory_;
}
inline ::stability_report::ProcessState_MemoryState_WindowsMemory* ProcessState_MemoryState::mutable_windows_memory()
{
    ::stability_report::ProcessState_MemoryState_WindowsMemory* _msg = _internal_mutable_windows_memory();
    // @@protoc_insertion_point(field_mutable:stability_report.ProcessState.MemoryState.windows_memory)
    return _msg;
}
inline void ProcessState_MemoryState::set_allocated_windows_memory(::stability_report::ProcessState_MemoryState_WindowsMemory* windows_memory)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.windows_memory_;
    }
    if (windows_memory) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(windows_memory);
        if (message_arena != submessage_arena) {
            windows_memory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, windows_memory, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.windows_memory_ = windows_memory;
    // @@protoc_insertion_point(field_set_allocated:stability_report.ProcessState.MemoryState.windows_memory)
}

// -------------------------------------------------------------------

// ProcessState_FileSystemState_PosixFileSystemState

// optional uint32 open_file_descriptors = 1;
inline bool ProcessState_FileSystemState_PosixFileSystemState::_internal_has_open_file_descriptors() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ProcessState_FileSystemState_PosixFileSystemState::has_open_file_descriptors() const
{
    return _internal_has_open_file_descriptors();
}
inline void ProcessState_FileSystemState_PosixFileSystemState::clear_open_file_descriptors()
{
    _impl_.open_file_descriptors_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ProcessState_FileSystemState_PosixFileSystemState::_internal_open_file_descriptors() const
{
    return _impl_.open_file_descriptors_;
}
inline uint32_t ProcessState_FileSystemState_PosixFileSystemState::open_file_descriptors() const
{
    // @@protoc_insertion_point(field_get:stability_report.ProcessState.FileSystemState.PosixFileSystemState.open_file_descriptors)
    return _internal_open_file_descriptors();
}
inline void ProcessState_FileSystemState_PosixFileSystemState::_internal_set_open_file_descriptors(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.open_file_descriptors_ = value;
}
inline void ProcessState_FileSystemState_PosixFileSystemState::set_open_file_descriptors(uint32_t value)
{
    _internal_set_open_file_descriptors(value);
    // @@protoc_insertion_point(field_set:stability_report.ProcessState.FileSystemState.PosixFileSystemState.open_file_descriptors)
}

// -------------------------------------------------------------------

// ProcessState_FileSystemState_WindowsFileSystemState

// optional uint32 process_handle_count = 1;
inline bool ProcessState_FileSystemState_WindowsFileSystemState::_internal_has_process_handle_count() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ProcessState_FileSystemState_WindowsFileSystemState::has_process_handle_count() const
{
    return _internal_has_process_handle_count();
}
inline void ProcessState_FileSystemState_WindowsFileSystemState::clear_process_handle_count()
{
    _impl_.process_handle_count_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ProcessState_FileSystemState_WindowsFileSystemState::_internal_process_handle_count() const
{
    return _impl_.process_handle_count_;
}
inline uint32_t ProcessState_FileSystemState_WindowsFileSystemState::process_handle_count() const
{
    // @@protoc_insertion_point(field_get:stability_report.ProcessState.FileSystemState.WindowsFileSystemState.process_handle_count)
    return _internal_process_handle_count();
}
inline void ProcessState_FileSystemState_WindowsFileSystemState::_internal_set_process_handle_count(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.process_handle_count_ = value;
}
inline void ProcessState_FileSystemState_WindowsFileSystemState::set_process_handle_count(uint32_t value)
{
    _internal_set_process_handle_count(value);
    // @@protoc_insertion_point(field_set:stability_report.ProcessState.FileSystemState.WindowsFileSystemState.process_handle_count)
}

// -------------------------------------------------------------------

// ProcessState_FileSystemState

// optional .stability_report.ProcessState.FileSystemState.PosixFileSystemState posix_file_system_state = 1;
inline bool ProcessState_FileSystemState::_internal_has_posix_file_system_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.posix_file_system_state_ != nullptr);
    return value;
}
inline bool ProcessState_FileSystemState::has_posix_file_system_state() const
{
    return _internal_has_posix_file_system_state();
}
inline void ProcessState_FileSystemState::clear_posix_file_system_state()
{
    if (_impl_.posix_file_system_state_ != nullptr)
        _impl_.posix_file_system_state_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::stability_report::ProcessState_FileSystemState_PosixFileSystemState& ProcessState_FileSystemState::_internal_posix_file_system_state() const
{
    const ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* p = _impl_.posix_file_system_state_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::stability_report::ProcessState_FileSystemState_PosixFileSystemState&>(
                            ::stability_report::_ProcessState_FileSystemState_PosixFileSystemState_default_instance_);
}
inline const ::stability_report::ProcessState_FileSystemState_PosixFileSystemState& ProcessState_FileSystemState::posix_file_system_state() const
{
    // @@protoc_insertion_point(field_get:stability_report.ProcessState.FileSystemState.posix_file_system_state)
    return _internal_posix_file_system_state();
}
inline void ProcessState_FileSystemState::unsafe_arena_set_allocated_posix_file_system_state(
    ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* posix_file_system_state)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.posix_file_system_state_);
    }
    _impl_.posix_file_system_state_ = posix_file_system_state;
    if (posix_file_system_state) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:stability_report.ProcessState.FileSystemState.posix_file_system_state)
}
inline ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* ProcessState_FileSystemState::release_posix_file_system_state()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* temp = _impl_.posix_file_system_state_;
    _impl_.posix_file_system_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* ProcessState_FileSystemState::unsafe_arena_release_posix_file_system_state()
{
    // @@protoc_insertion_point(field_release:stability_report.ProcessState.FileSystemState.posix_file_system_state)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* temp = _impl_.posix_file_system_state_;
    _impl_.posix_file_system_state_ = nullptr;
    return temp;
}
inline ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* ProcessState_FileSystemState::_internal_mutable_posix_file_system_state()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.posix_file_system_state_ == nullptr) {
        auto* p = CreateMaybeMessage<::stability_report::ProcessState_FileSystemState_PosixFileSystemState>(GetArenaForAllocation());
        _impl_.posix_file_system_state_ = p;
    }
    return _impl_.posix_file_system_state_;
}
inline ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* ProcessState_FileSystemState::mutable_posix_file_system_state()
{
    ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* _msg = _internal_mutable_posix_file_system_state();
    // @@protoc_insertion_point(field_mutable:stability_report.ProcessState.FileSystemState.posix_file_system_state)
    return _msg;
}
inline void ProcessState_FileSystemState::set_allocated_posix_file_system_state(
    ::stability_report::ProcessState_FileSystemState_PosixFileSystemState* posix_file_system_state)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.posix_file_system_state_;
    }
    if (posix_file_system_state) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(posix_file_system_state);
        if (message_arena != submessage_arena) {
            posix_file_system_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, posix_file_system_state, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.posix_file_system_state_ = posix_file_system_state;
    // @@protoc_insertion_point(field_set_allocated:stability_report.ProcessState.FileSystemState.posix_file_system_state)
}

// optional .stability_report.ProcessState.FileSystemState.WindowsFileSystemState windows_file_system_state = 2;
inline bool ProcessState_FileSystemState::_internal_has_windows_file_system_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.windows_file_system_state_ != nullptr);
    return value;
}
inline bool ProcessState_FileSystemState::has_windows_file_system_state() const
{
    return _internal_has_windows_file_system_state();
}
inline void ProcessState_FileSystemState::clear_windows_file_system_state()
{
    if (_impl_.windows_file_system_state_ != nullptr)
        _impl_.windows_file_system_state_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState& ProcessState_FileSystemState::_internal_windows_file_system_state() const
{
    const ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* p = _impl_.windows_file_system_state_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState&>(
                            ::stability_report::_ProcessState_FileSystemState_WindowsFileSystemState_default_instance_);
}
inline const ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState& ProcessState_FileSystemState::windows_file_system_state() const
{
    // @@protoc_insertion_point(field_get:stability_report.ProcessState.FileSystemState.windows_file_system_state)
    return _internal_windows_file_system_state();
}
inline void ProcessState_FileSystemState::unsafe_arena_set_allocated_windows_file_system_state(
    ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* windows_file_system_state)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.windows_file_system_state_);
    }
    _impl_.windows_file_system_state_ = windows_file_system_state;
    if (windows_file_system_state) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:stability_report.ProcessState.FileSystemState.windows_file_system_state)
}
inline ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* ProcessState_FileSystemState::release_windows_file_system_state()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* temp = _impl_.windows_file_system_state_;
    _impl_.windows_file_system_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* ProcessState_FileSystemState::unsafe_arena_release_windows_file_system_state()
{
    // @@protoc_insertion_point(field_release:stability_report.ProcessState.FileSystemState.windows_file_system_state)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* temp = _impl_.windows_file_system_state_;
    _impl_.windows_file_system_state_ = nullptr;
    return temp;
}
inline ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* ProcessState_FileSystemState::_internal_mutable_windows_file_system_state()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.windows_file_system_state_ == nullptr) {
        auto* p = CreateMaybeMessage<::stability_report::ProcessState_FileSystemState_WindowsFileSystemState>(GetArenaForAllocation());
        _impl_.windows_file_system_state_ = p;
    }
    return _impl_.windows_file_system_state_;
}
inline ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* ProcessState_FileSystemState::mutable_windows_file_system_state()
{
    ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* _msg = _internal_mutable_windows_file_system_state();
    // @@protoc_insertion_point(field_mutable:stability_report.ProcessState.FileSystemState.windows_file_system_state)
    return _msg;
}
inline void ProcessState_FileSystemState::set_allocated_windows_file_system_state(
    ::stability_report::ProcessState_FileSystemState_WindowsFileSystemState* windows_file_system_state)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.windows_file_system_state_;
    }
    if (windows_file_system_state) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(windows_file_system_state);
        if (message_arena != submessage_arena) {
            windows_file_system_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, windows_file_system_state, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.windows_file_system_state_ = windows_file_system_state;
    // @@protoc_insertion_point(field_set_allocated:stability_report.ProcessState.FileSystemState.windows_file_system_state)
}

// -------------------------------------------------------------------

// ProcessState

// optional int64 process_id = 3;
inline bool ProcessState::_internal_has_process_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ProcessState::has_process_id() const
{
    return _internal_has_process_id();
}
inline void ProcessState::clear_process_id()
{
    _impl_.process_id_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t ProcessState::_internal_process_id() const
{
    return _impl_.process_id_;
}
inline int64_t ProcessState::process_id() const
{
    // @@protoc_insertion_point(field_get:stability_report.ProcessState.process_id)
    return _internal_process_id();
}
inline void ProcessState::_internal_set_process_id(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.process_id_ = value;
}
inline void ProcessState::set_process_id(int64_t value)
{
    _internal_set_process_id(value);
    // @@protoc_insertion_point(field_set:stability_report.ProcessState.process_id)
}

// optional .stability_report.ProcessState.MemoryState memory_state = 4;
inline bool ProcessState::_internal_has_memory_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.memory_state_ != nullptr);
    return value;
}
inline bool ProcessState::has_memory_state() const
{
    return _internal_has_memory_state();
}
inline void ProcessState::clear_memory_state()
{
    if (_impl_.memory_state_ != nullptr)
        _impl_.memory_state_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::stability_report::ProcessState_MemoryState& ProcessState::_internal_memory_state() const
{
    const ::stability_report::ProcessState_MemoryState* p = _impl_.memory_state_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::stability_report::ProcessState_MemoryState&>(::stability_report::_ProcessState_MemoryState_default_instance_);
}
inline const ::stability_report::ProcessState_MemoryState& ProcessState::memory_state() const
{
    // @@protoc_insertion_point(field_get:stability_report.ProcessState.memory_state)
    return _internal_memory_state();
}
inline void ProcessState::unsafe_arena_set_allocated_memory_state(::stability_report::ProcessState_MemoryState* memory_state)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.memory_state_);
    }
    _impl_.memory_state_ = memory_state;
    if (memory_state) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:stability_report.ProcessState.memory_state)
}
inline ::stability_report::ProcessState_MemoryState* ProcessState::release_memory_state()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::stability_report::ProcessState_MemoryState* temp = _impl_.memory_state_;
    _impl_.memory_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::stability_report::ProcessState_MemoryState* ProcessState::unsafe_arena_release_memory_state()
{
    // @@protoc_insertion_point(field_release:stability_report.ProcessState.memory_state)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::stability_report::ProcessState_MemoryState* temp = _impl_.memory_state_;
    _impl_.memory_state_ = nullptr;
    return temp;
}
inline ::stability_report::ProcessState_MemoryState* ProcessState::_internal_mutable_memory_state()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.memory_state_ == nullptr) {
        auto* p = CreateMaybeMessage<::stability_report::ProcessState_MemoryState>(GetArenaForAllocation());
        _impl_.memory_state_ = p;
    }
    return _impl_.memory_state_;
}
inline ::stability_report::ProcessState_MemoryState* ProcessState::mutable_memory_state()
{
    ::stability_report::ProcessState_MemoryState* _msg = _internal_mutable_memory_state();
    // @@protoc_insertion_point(field_mutable:stability_report.ProcessState.memory_state)
    return _msg;
}
inline void ProcessState::set_allocated_memory_state(::stability_report::ProcessState_MemoryState* memory_state)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.memory_state_;
    }
    if (memory_state) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(memory_state);
        if (message_arena != submessage_arena) {
            memory_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, memory_state, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.memory_state_ = memory_state;
    // @@protoc_insertion_point(field_set_allocated:stability_report.ProcessState.memory_state)
}

// optional .stability_report.ProcessState.FileSystemState file_system_state = 7;
inline bool ProcessState::_internal_has_file_system_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.file_system_state_ != nullptr);
    return value;
}
inline bool ProcessState::has_file_system_state() const
{
    return _internal_has_file_system_state();
}
inline void ProcessState::clear_file_system_state()
{
    if (_impl_.file_system_state_ != nullptr)
        _impl_.file_system_state_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::stability_report::ProcessState_FileSystemState& ProcessState::_internal_file_system_state() const
{
    const ::stability_report::ProcessState_FileSystemState* p = _impl_.file_system_state_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::stability_report::ProcessState_FileSystemState&>(::stability_report::_ProcessState_FileSystemState_default_instance_);
}
inline const ::stability_report::ProcessState_FileSystemState& ProcessState::file_system_state() const
{
    // @@protoc_insertion_point(field_get:stability_report.ProcessState.file_system_state)
    return _internal_file_system_state();
}
inline void ProcessState::unsafe_arena_set_allocated_file_system_state(::stability_report::ProcessState_FileSystemState* file_system_state)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.file_system_state_);
    }
    _impl_.file_system_state_ = file_system_state;
    if (file_system_state) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:stability_report.ProcessState.file_system_state)
}
inline ::stability_report::ProcessState_FileSystemState* ProcessState::release_file_system_state()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::stability_report::ProcessState_FileSystemState* temp = _impl_.file_system_state_;
    _impl_.file_system_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::stability_report::ProcessState_FileSystemState* ProcessState::unsafe_arena_release_file_system_state()
{
    // @@protoc_insertion_point(field_release:stability_report.ProcessState.file_system_state)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::stability_report::ProcessState_FileSystemState* temp = _impl_.file_system_state_;
    _impl_.file_system_state_ = nullptr;
    return temp;
}
inline ::stability_report::ProcessState_FileSystemState* ProcessState::_internal_mutable_file_system_state()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.file_system_state_ == nullptr) {
        auto* p = CreateMaybeMessage<::stability_report::ProcessState_FileSystemState>(GetArenaForAllocation());
        _impl_.file_system_state_ = p;
    }
    return _impl_.file_system_state_;
}
inline ::stability_report::ProcessState_FileSystemState* ProcessState::mutable_file_system_state()
{
    ::stability_report::ProcessState_FileSystemState* _msg = _internal_mutable_file_system_state();
    // @@protoc_insertion_point(field_mutable:stability_report.ProcessState.file_system_state)
    return _msg;
}
inline void ProcessState::set_allocated_file_system_state(::stability_report::ProcessState_FileSystemState* file_system_state)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.file_system_state_;
    }
    if (file_system_state) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(file_system_state);
        if (message_arena != submessage_arena) {
            file_system_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, file_system_state, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.file_system_state_ = file_system_state;
    // @@protoc_insertion_point(field_set_allocated:stability_report.ProcessState.file_system_state)
}

// -------------------------------------------------------------------

// SystemMemoryState_WindowsMemory

// optional uint32 system_commit_limit = 1;
inline bool SystemMemoryState_WindowsMemory::_internal_has_system_commit_limit() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SystemMemoryState_WindowsMemory::has_system_commit_limit() const
{
    return _internal_has_system_commit_limit();
}
inline void SystemMemoryState_WindowsMemory::clear_system_commit_limit()
{
    _impl_.system_commit_limit_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t SystemMemoryState_WindowsMemory::_internal_system_commit_limit() const
{
    return _impl_.system_commit_limit_;
}
inline uint32_t SystemMemoryState_WindowsMemory::system_commit_limit() const
{
    // @@protoc_insertion_point(field_get:stability_report.SystemMemoryState.WindowsMemory.system_commit_limit)
    return _internal_system_commit_limit();
}
inline void SystemMemoryState_WindowsMemory::_internal_set_system_commit_limit(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.system_commit_limit_ = value;
}
inline void SystemMemoryState_WindowsMemory::set_system_commit_limit(uint32_t value)
{
    _internal_set_system_commit_limit(value);
    // @@protoc_insertion_point(field_set:stability_report.SystemMemoryState.WindowsMemory.system_commit_limit)
}

// optional uint32 system_commit_remaining = 2;
inline bool SystemMemoryState_WindowsMemory::_internal_has_system_commit_remaining() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool SystemMemoryState_WindowsMemory::has_system_commit_remaining() const
{
    return _internal_has_system_commit_remaining();
}
inline void SystemMemoryState_WindowsMemory::clear_system_commit_remaining()
{
    _impl_.system_commit_remaining_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t SystemMemoryState_WindowsMemory::_internal_system_commit_remaining() const
{
    return _impl_.system_commit_remaining_;
}
inline uint32_t SystemMemoryState_WindowsMemory::system_commit_remaining() const
{
    // @@protoc_insertion_point(field_get:stability_report.SystemMemoryState.WindowsMemory.system_commit_remaining)
    return _internal_system_commit_remaining();
}
inline void SystemMemoryState_WindowsMemory::_internal_set_system_commit_remaining(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.system_commit_remaining_ = value;
}
inline void SystemMemoryState_WindowsMemory::set_system_commit_remaining(uint32_t value)
{
    _internal_set_system_commit_remaining(value);
    // @@protoc_insertion_point(field_set:stability_report.SystemMemoryState.WindowsMemory.system_commit_remaining)
}

// optional uint32 system_handle_count = 3;
inline bool SystemMemoryState_WindowsMemory::_internal_has_system_handle_count() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool SystemMemoryState_WindowsMemory::has_system_handle_count() const
{
    return _internal_has_system_handle_count();
}
inline void SystemMemoryState_WindowsMemory::clear_system_handle_count()
{
    _impl_.system_handle_count_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t SystemMemoryState_WindowsMemory::_internal_system_handle_count() const
{
    return _impl_.system_handle_count_;
}
inline uint32_t SystemMemoryState_WindowsMemory::system_handle_count() const
{
    // @@protoc_insertion_point(field_get:stability_report.SystemMemoryState.WindowsMemory.system_handle_count)
    return _internal_system_handle_count();
}
inline void SystemMemoryState_WindowsMemory::_internal_set_system_handle_count(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.system_handle_count_ = value;
}
inline void SystemMemoryState_WindowsMemory::set_system_handle_count(uint32_t value)
{
    _internal_set_system_handle_count(value);
    // @@protoc_insertion_point(field_set:stability_report.SystemMemoryState.WindowsMemory.system_handle_count)
}

// -------------------------------------------------------------------

// SystemMemoryState

// optional .stability_report.SystemMemoryState.WindowsMemory windows_memory = 1;
inline bool SystemMemoryState::_internal_has_windows_memory() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.windows_memory_ != nullptr);
    return value;
}
inline bool SystemMemoryState::has_windows_memory() const
{
    return _internal_has_windows_memory();
}
inline void SystemMemoryState::clear_windows_memory()
{
    if (_impl_.windows_memory_ != nullptr)
        _impl_.windows_memory_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::stability_report::SystemMemoryState_WindowsMemory& SystemMemoryState::_internal_windows_memory() const
{
    const ::stability_report::SystemMemoryState_WindowsMemory* p = _impl_.windows_memory_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::stability_report::SystemMemoryState_WindowsMemory&>(::stability_report::_SystemMemoryState_WindowsMemory_default_instance_);
}
inline const ::stability_report::SystemMemoryState_WindowsMemory& SystemMemoryState::windows_memory() const
{
    // @@protoc_insertion_point(field_get:stability_report.SystemMemoryState.windows_memory)
    return _internal_windows_memory();
}
inline void SystemMemoryState::unsafe_arena_set_allocated_windows_memory(::stability_report::SystemMemoryState_WindowsMemory* windows_memory)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.windows_memory_);
    }
    _impl_.windows_memory_ = windows_memory;
    if (windows_memory) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:stability_report.SystemMemoryState.windows_memory)
}
inline ::stability_report::SystemMemoryState_WindowsMemory* SystemMemoryState::release_windows_memory()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::stability_report::SystemMemoryState_WindowsMemory* temp = _impl_.windows_memory_;
    _impl_.windows_memory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::stability_report::SystemMemoryState_WindowsMemory* SystemMemoryState::unsafe_arena_release_windows_memory()
{
    // @@protoc_insertion_point(field_release:stability_report.SystemMemoryState.windows_memory)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::stability_report::SystemMemoryState_WindowsMemory* temp = _impl_.windows_memory_;
    _impl_.windows_memory_ = nullptr;
    return temp;
}
inline ::stability_report::SystemMemoryState_WindowsMemory* SystemMemoryState::_internal_mutable_windows_memory()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.windows_memory_ == nullptr) {
        auto* p = CreateMaybeMessage<::stability_report::SystemMemoryState_WindowsMemory>(GetArenaForAllocation());
        _impl_.windows_memory_ = p;
    }
    return _impl_.windows_memory_;
}
inline ::stability_report::SystemMemoryState_WindowsMemory* SystemMemoryState::mutable_windows_memory()
{
    ::stability_report::SystemMemoryState_WindowsMemory* _msg = _internal_mutable_windows_memory();
    // @@protoc_insertion_point(field_mutable:stability_report.SystemMemoryState.windows_memory)
    return _msg;
}
inline void SystemMemoryState::set_allocated_windows_memory(::stability_report::SystemMemoryState_WindowsMemory* windows_memory)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.windows_memory_;
    }
    if (windows_memory) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(windows_memory);
        if (message_arena != submessage_arena) {
            windows_memory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, windows_memory, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.windows_memory_ = windows_memory;
    // @@protoc_insertion_point(field_set_allocated:stability_report.SystemMemoryState.windows_memory)
}

// -------------------------------------------------------------------

// StabilityReport

// repeated .stability_report.ProcessState process_states = 2;
inline int StabilityReport::_internal_process_states_size() const
{
    return _impl_.process_states_.size();
}
inline int StabilityReport::process_states_size() const
{
    return _internal_process_states_size();
}
inline void StabilityReport::clear_process_states()
{
    _impl_.process_states_.Clear();
}
inline ::stability_report::ProcessState* StabilityReport::mutable_process_states(int index)
{
    // @@protoc_insertion_point(field_mutable:stability_report.StabilityReport.process_states)
    return _impl_.process_states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::stability_report::ProcessState>* StabilityReport::mutable_process_states()
{
    // @@protoc_insertion_point(field_mutable_list:stability_report.StabilityReport.process_states)
    return &_impl_.process_states_;
}
inline const ::stability_report::ProcessState& StabilityReport::_internal_process_states(int index) const
{
    return _impl_.process_states_.Get(index);
}
inline const ::stability_report::ProcessState& StabilityReport::process_states(int index) const
{
    // @@protoc_insertion_point(field_get:stability_report.StabilityReport.process_states)
    return _internal_process_states(index);
}
inline ::stability_report::ProcessState* StabilityReport::_internal_add_process_states()
{
    return _impl_.process_states_.Add();
}
inline ::stability_report::ProcessState* StabilityReport::add_process_states()
{
    ::stability_report::ProcessState* _add = _internal_add_process_states();
    // @@protoc_insertion_point(field_add:stability_report.StabilityReport.process_states)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::stability_report::ProcessState>& StabilityReport::process_states() const
{
    // @@protoc_insertion_point(field_list:stability_report.StabilityReport.process_states)
    return _impl_.process_states_;
}

// optional .stability_report.SystemMemoryState system_memory_state = 7;
inline bool StabilityReport::_internal_has_system_memory_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.system_memory_state_ != nullptr);
    return value;
}
inline bool StabilityReport::has_system_memory_state() const
{
    return _internal_has_system_memory_state();
}
inline void StabilityReport::clear_system_memory_state()
{
    if (_impl_.system_memory_state_ != nullptr)
        _impl_.system_memory_state_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::stability_report::SystemMemoryState& StabilityReport::_internal_system_memory_state() const
{
    const ::stability_report::SystemMemoryState* p = _impl_.system_memory_state_;
    return p != nullptr ? *p : reinterpret_cast<const ::stability_report::SystemMemoryState&>(::stability_report::_SystemMemoryState_default_instance_);
}
inline const ::stability_report::SystemMemoryState& StabilityReport::system_memory_state() const
{
    // @@protoc_insertion_point(field_get:stability_report.StabilityReport.system_memory_state)
    return _internal_system_memory_state();
}
inline void StabilityReport::unsafe_arena_set_allocated_system_memory_state(::stability_report::SystemMemoryState* system_memory_state)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.system_memory_state_);
    }
    _impl_.system_memory_state_ = system_memory_state;
    if (system_memory_state) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:stability_report.StabilityReport.system_memory_state)
}
inline ::stability_report::SystemMemoryState* StabilityReport::release_system_memory_state()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::stability_report::SystemMemoryState* temp = _impl_.system_memory_state_;
    _impl_.system_memory_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::stability_report::SystemMemoryState* StabilityReport::unsafe_arena_release_system_memory_state()
{
    // @@protoc_insertion_point(field_release:stability_report.StabilityReport.system_memory_state)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::stability_report::SystemMemoryState* temp = _impl_.system_memory_state_;
    _impl_.system_memory_state_ = nullptr;
    return temp;
}
inline ::stability_report::SystemMemoryState* StabilityReport::_internal_mutable_system_memory_state()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.system_memory_state_ == nullptr) {
        auto* p = CreateMaybeMessage<::stability_report::SystemMemoryState>(GetArenaForAllocation());
        _impl_.system_memory_state_ = p;
    }
    return _impl_.system_memory_state_;
}
inline ::stability_report::SystemMemoryState* StabilityReport::mutable_system_memory_state()
{
    ::stability_report::SystemMemoryState* _msg = _internal_mutable_system_memory_state();
    // @@protoc_insertion_point(field_mutable:stability_report.StabilityReport.system_memory_state)
    return _msg;
}
inline void StabilityReport::set_allocated_system_memory_state(::stability_report::SystemMemoryState* system_memory_state)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.system_memory_state_;
    }
    if (system_memory_state) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(system_memory_state);
        if (message_arena != submessage_arena) {
            system_memory_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, system_memory_state, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.system_memory_state_ = system_memory_state;
    // @@protoc_insertion_point(field_set_allocated:stability_report.StabilityReport.system_memory_state)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace stability_report

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_stability_5freport_2eproto
