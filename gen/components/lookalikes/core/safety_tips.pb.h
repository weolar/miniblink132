// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safety_tips.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_safety_5ftips_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_safety_5ftips_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_safety_5ftips_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_safety_5ftips_2eproto {
    static const uint32_t offsets[];
};
namespace reputation {
class Cohort;
struct CohortDefaultTypeInternal;
extern CohortDefaultTypeInternal _Cohort_default_instance_;
class FlaggedPage;
struct FlaggedPageDefaultTypeInternal;
extern FlaggedPageDefaultTypeInternal _FlaggedPage_default_instance_;
class HeuristicLaunchConfig;
struct HeuristicLaunchConfigDefaultTypeInternal;
extern HeuristicLaunchConfigDefaultTypeInternal _HeuristicLaunchConfig_default_instance_;
class HostPattern;
struct HostPatternDefaultTypeInternal;
extern HostPatternDefaultTypeInternal _HostPattern_default_instance_;
class SafetyTipsConfig;
struct SafetyTipsConfigDefaultTypeInternal;
extern SafetyTipsConfigDefaultTypeInternal _SafetyTipsConfig_default_instance_;
class UrlPattern;
struct UrlPatternDefaultTypeInternal;
extern UrlPatternDefaultTypeInternal _UrlPattern_default_instance_;
} // namespace reputation
PROTOBUF_NAMESPACE_OPEN
template <>::reputation::Cohort* Arena::CreateMaybeMessage<::reputation::Cohort>(Arena*);
template <>::reputation::FlaggedPage* Arena::CreateMaybeMessage<::reputation::FlaggedPage>(Arena*);
template <>::reputation::HeuristicLaunchConfig* Arena::CreateMaybeMessage<::reputation::HeuristicLaunchConfig>(Arena*);
template <>::reputation::HostPattern* Arena::CreateMaybeMessage<::reputation::HostPattern>(Arena*);
template <>::reputation::SafetyTipsConfig* Arena::CreateMaybeMessage<::reputation::SafetyTipsConfig>(Arena*);
template <>::reputation::UrlPattern* Arena::CreateMaybeMessage<::reputation::UrlPattern>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace reputation {

enum FlaggedPage_FlagType : int { FlaggedPage_FlagType_UNKNOWN = 0, FlaggedPage_FlagType_BAD_REP = 1, FlaggedPage_FlagType_YOUNG_DOMAIN = 2 };
bool FlaggedPage_FlagType_IsValid(int value);
constexpr FlaggedPage_FlagType FlaggedPage_FlagType_FlagType_MIN = FlaggedPage_FlagType_UNKNOWN;
constexpr FlaggedPage_FlagType FlaggedPage_FlagType_FlagType_MAX = FlaggedPage_FlagType_YOUNG_DOMAIN;
constexpr int FlaggedPage_FlagType_FlagType_ARRAYSIZE = FlaggedPage_FlagType_FlagType_MAX + 1;

const std::string& FlaggedPage_FlagType_Name(FlaggedPage_FlagType value);
template <typename T> inline const std::string& FlaggedPage_FlagType_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, FlaggedPage_FlagType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function FlaggedPage_FlagType_Name.");
    return FlaggedPage_FlagType_Name(static_cast<FlaggedPage_FlagType>(enum_t_value));
}
bool FlaggedPage_FlagType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FlaggedPage_FlagType* value);
enum HeuristicLaunchConfig_Heuristic : int {
    HeuristicLaunchConfig_Heuristic_HEURISTIC_UNKNOWN = 0,
    HeuristicLaunchConfig_Heuristic_HEURISTIC_CHARACTER_SWAP_ENGAGED_SITES = 1,
    HeuristicLaunchConfig_Heuristic_HEURISTIC_CHARACTER_SWAP_TOP_SITES = 2,
    HeuristicLaunchConfig_Heuristic_HEURISTIC_COMBO_SQUATTING_TOP_DOMAINS = 3,
    HeuristicLaunchConfig_Heuristic_HEURISTIC_COMBO_SQUATTING_ENGAGED_SITES = 4
};
bool HeuristicLaunchConfig_Heuristic_IsValid(int value);
constexpr HeuristicLaunchConfig_Heuristic HeuristicLaunchConfig_Heuristic_Heuristic_MIN = HeuristicLaunchConfig_Heuristic_HEURISTIC_UNKNOWN;
constexpr HeuristicLaunchConfig_Heuristic HeuristicLaunchConfig_Heuristic_Heuristic_MAX
    = HeuristicLaunchConfig_Heuristic_HEURISTIC_COMBO_SQUATTING_ENGAGED_SITES;
constexpr int HeuristicLaunchConfig_Heuristic_Heuristic_ARRAYSIZE = HeuristicLaunchConfig_Heuristic_Heuristic_MAX + 1;

const std::string& HeuristicLaunchConfig_Heuristic_Name(HeuristicLaunchConfig_Heuristic value);
template <typename T> inline const std::string& HeuristicLaunchConfig_Heuristic_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, HeuristicLaunchConfig_Heuristic>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function HeuristicLaunchConfig_Heuristic_Name.");
    return HeuristicLaunchConfig_Heuristic_Name(static_cast<HeuristicLaunchConfig_Heuristic>(enum_t_value));
}
bool HeuristicLaunchConfig_Heuristic_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HeuristicLaunchConfig_Heuristic* value);
// ===================================================================

class FlaggedPage final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reputation.FlaggedPage) */ {
public:
    inline FlaggedPage()
        : FlaggedPage(nullptr)
    {
    }
    ~FlaggedPage() override;
    explicit PROTOBUF_CONSTEXPR FlaggedPage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FlaggedPage(const FlaggedPage& from);
    FlaggedPage(FlaggedPage&& from) noexcept
        : FlaggedPage()
    {
        *this = ::std::move(from);
    }

    inline FlaggedPage& operator=(const FlaggedPage& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FlaggedPage& operator=(FlaggedPage&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const FlaggedPage& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FlaggedPage* internal_default_instance()
    {
        return reinterpret_cast<const FlaggedPage*>(&_FlaggedPage_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(FlaggedPage& a, FlaggedPage& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FlaggedPage* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FlaggedPage* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FlaggedPage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FlaggedPage>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FlaggedPage& from);
    void MergeFrom(const FlaggedPage& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FlaggedPage* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reputation.FlaggedPage";
    }

protected:
    explicit FlaggedPage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef FlaggedPage_FlagType FlagType;
    static constexpr FlagType UNKNOWN = FlaggedPage_FlagType_UNKNOWN;
    static constexpr FlagType BAD_REP = FlaggedPage_FlagType_BAD_REP;
    static constexpr FlagType YOUNG_DOMAIN = FlaggedPage_FlagType_YOUNG_DOMAIN;
    static inline bool FlagType_IsValid(int value)
    {
        return FlaggedPage_FlagType_IsValid(value);
    }
    static constexpr FlagType FlagType_MIN = FlaggedPage_FlagType_FlagType_MIN;
    static constexpr FlagType FlagType_MAX = FlaggedPage_FlagType_FlagType_MAX;
    static constexpr int FlagType_ARRAYSIZE = FlaggedPage_FlagType_FlagType_ARRAYSIZE;
    template <typename T> static inline const std::string& FlagType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, FlagType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function FlagType_Name.");
        return FlaggedPage_FlagType_Name(enum_t_value);
    }
    static inline bool FlagType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FlagType* value)
    {
        return FlaggedPage_FlagType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kPatternFieldNumber = 1,
        kTypeFieldNumber = 2,
    };
    // optional string pattern = 1;
    bool has_pattern() const;

private:
    bool _internal_has_pattern() const;

public:
    void clear_pattern();
    const std::string& pattern() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_pattern(ArgT0&& arg0, ArgT... args);
    std::string* mutable_pattern();
    PROTOBUF_NODISCARD std::string* release_pattern();
    void set_allocated_pattern(std::string* pattern);

private:
    const std::string& _internal_pattern() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(const std::string& value);
    std::string* _internal_mutable_pattern();

public:
    // optional .reputation.FlaggedPage.FlagType type = 2;
    bool has_type() const;

private:
    bool _internal_has_type() const;

public:
    void clear_type();
    ::reputation::FlaggedPage_FlagType type() const;
    void set_type(::reputation::FlaggedPage_FlagType value);

private:
    ::reputation::FlaggedPage_FlagType _internal_type() const;
    void _internal_set_type(::reputation::FlaggedPage_FlagType value);

public:
    // @@protoc_insertion_point(class_scope:reputation.FlaggedPage)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pattern_;
        int type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_safety_5ftips_2eproto;
};
// -------------------------------------------------------------------

class UrlPattern final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reputation.UrlPattern) */ {
public:
    inline UrlPattern()
        : UrlPattern(nullptr)
    {
    }
    ~UrlPattern() override;
    explicit PROTOBUF_CONSTEXPR UrlPattern(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    UrlPattern(const UrlPattern& from);
    UrlPattern(UrlPattern&& from) noexcept
        : UrlPattern()
    {
        *this = ::std::move(from);
    }

    inline UrlPattern& operator=(const UrlPattern& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UrlPattern& operator=(UrlPattern&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const UrlPattern& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const UrlPattern* internal_default_instance()
    {
        return reinterpret_cast<const UrlPattern*>(&_UrlPattern_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(UrlPattern& a, UrlPattern& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(UrlPattern* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UrlPattern* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UrlPattern* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<UrlPattern>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const UrlPattern& from);
    void MergeFrom(const UrlPattern& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(UrlPattern* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reputation.UrlPattern";
    }

protected:
    explicit UrlPattern(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCohortIndexFieldNumber = 2,
        kPatternFieldNumber = 1,
    };
    // repeated uint32 cohort_index = 2 [packed = true];
    int cohort_index_size() const;

private:
    int _internal_cohort_index_size() const;

public:
    void clear_cohort_index();

private:
    uint32_t _internal_cohort_index(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& _internal_cohort_index() const;
    void _internal_add_cohort_index(uint32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* _internal_mutable_cohort_index();

public:
    uint32_t cohort_index(int index) const;
    void set_cohort_index(int index, uint32_t value);
    void add_cohort_index(uint32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& cohort_index() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* mutable_cohort_index();

    // optional string pattern = 1;
    bool has_pattern() const;

private:
    bool _internal_has_pattern() const;

public:
    void clear_pattern();
    const std::string& pattern() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_pattern(ArgT0&& arg0, ArgT... args);
    std::string* mutable_pattern();
    PROTOBUF_NODISCARD std::string* release_pattern();
    void set_allocated_pattern(std::string* pattern);

private:
    const std::string& _internal_pattern() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(const std::string& value);
    std::string* _internal_mutable_pattern();

public:
    // @@protoc_insertion_point(class_scope:reputation.UrlPattern)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t> cohort_index_;
        mutable std::atomic<int> _cohort_index_cached_byte_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pattern_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_safety_5ftips_2eproto;
};
// -------------------------------------------------------------------

class HostPattern final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reputation.HostPattern) */ {
public:
    inline HostPattern()
        : HostPattern(nullptr)
    {
    }
    ~HostPattern() override;
    explicit PROTOBUF_CONSTEXPR HostPattern(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    HostPattern(const HostPattern& from);
    HostPattern(HostPattern&& from) noexcept
        : HostPattern()
    {
        *this = ::std::move(from);
    }

    inline HostPattern& operator=(const HostPattern& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline HostPattern& operator=(HostPattern&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const HostPattern& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const HostPattern* internal_default_instance()
    {
        return reinterpret_cast<const HostPattern*>(&_HostPattern_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(HostPattern& a, HostPattern& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(HostPattern* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(HostPattern* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    HostPattern* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<HostPattern>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const HostPattern& from);
    void MergeFrom(const HostPattern& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(HostPattern* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reputation.HostPattern";
    }

protected:
    explicit HostPattern(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kRegexFieldNumber = 1,
    };
    // optional string regex = 1;
    bool has_regex() const;

private:
    bool _internal_has_regex() const;

public:
    void clear_regex();
    const std::string& regex() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_regex(ArgT0&& arg0, ArgT... args);
    std::string* mutable_regex();
    PROTOBUF_NODISCARD std::string* release_regex();
    void set_allocated_regex(std::string* regex);

private:
    const std::string& _internal_regex() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_regex(const std::string& value);
    std::string* _internal_mutable_regex();

public:
    // @@protoc_insertion_point(class_scope:reputation.HostPattern)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr regex_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_safety_5ftips_2eproto;
};
// -------------------------------------------------------------------

class HeuristicLaunchConfig final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reputation.HeuristicLaunchConfig) */ {
public:
    inline HeuristicLaunchConfig()
        : HeuristicLaunchConfig(nullptr)
    {
    }
    ~HeuristicLaunchConfig() override;
    explicit PROTOBUF_CONSTEXPR HeuristicLaunchConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    HeuristicLaunchConfig(const HeuristicLaunchConfig& from);
    HeuristicLaunchConfig(HeuristicLaunchConfig&& from) noexcept
        : HeuristicLaunchConfig()
    {
        *this = ::std::move(from);
    }

    inline HeuristicLaunchConfig& operator=(const HeuristicLaunchConfig& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline HeuristicLaunchConfig& operator=(HeuristicLaunchConfig&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const HeuristicLaunchConfig& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const HeuristicLaunchConfig* internal_default_instance()
    {
        return reinterpret_cast<const HeuristicLaunchConfig*>(&_HeuristicLaunchConfig_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(HeuristicLaunchConfig& a, HeuristicLaunchConfig& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(HeuristicLaunchConfig* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(HeuristicLaunchConfig* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    HeuristicLaunchConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<HeuristicLaunchConfig>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const HeuristicLaunchConfig& from);
    void MergeFrom(const HeuristicLaunchConfig& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(HeuristicLaunchConfig* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reputation.HeuristicLaunchConfig";
    }

protected:
    explicit HeuristicLaunchConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef HeuristicLaunchConfig_Heuristic Heuristic;
    static constexpr Heuristic HEURISTIC_UNKNOWN = HeuristicLaunchConfig_Heuristic_HEURISTIC_UNKNOWN;
    static constexpr Heuristic HEURISTIC_CHARACTER_SWAP_ENGAGED_SITES = HeuristicLaunchConfig_Heuristic_HEURISTIC_CHARACTER_SWAP_ENGAGED_SITES;
    static constexpr Heuristic HEURISTIC_CHARACTER_SWAP_TOP_SITES = HeuristicLaunchConfig_Heuristic_HEURISTIC_CHARACTER_SWAP_TOP_SITES;
    static constexpr Heuristic HEURISTIC_COMBO_SQUATTING_TOP_DOMAINS = HeuristicLaunchConfig_Heuristic_HEURISTIC_COMBO_SQUATTING_TOP_DOMAINS;
    static constexpr Heuristic HEURISTIC_COMBO_SQUATTING_ENGAGED_SITES = HeuristicLaunchConfig_Heuristic_HEURISTIC_COMBO_SQUATTING_ENGAGED_SITES;
    static inline bool Heuristic_IsValid(int value)
    {
        return HeuristicLaunchConfig_Heuristic_IsValid(value);
    }
    static constexpr Heuristic Heuristic_MIN = HeuristicLaunchConfig_Heuristic_Heuristic_MIN;
    static constexpr Heuristic Heuristic_MAX = HeuristicLaunchConfig_Heuristic_Heuristic_MAX;
    static constexpr int Heuristic_ARRAYSIZE = HeuristicLaunchConfig_Heuristic_Heuristic_ARRAYSIZE;
    template <typename T> static inline const std::string& Heuristic_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Heuristic>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Heuristic_Name.");
        return HeuristicLaunchConfig_Heuristic_Name(enum_t_value);
    }
    static inline bool Heuristic_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Heuristic* value)
    {
        return HeuristicLaunchConfig_Heuristic_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kHeuristicFieldNumber = 1,
        kLaunchPercentageFieldNumber = 2,
    };
    // optional .reputation.HeuristicLaunchConfig.Heuristic heuristic = 1;
    bool has_heuristic() const;

private:
    bool _internal_has_heuristic() const;

public:
    void clear_heuristic();
    ::reputation::HeuristicLaunchConfig_Heuristic heuristic() const;
    void set_heuristic(::reputation::HeuristicLaunchConfig_Heuristic value);

private:
    ::reputation::HeuristicLaunchConfig_Heuristic _internal_heuristic() const;
    void _internal_set_heuristic(::reputation::HeuristicLaunchConfig_Heuristic value);

public:
    // optional uint32 launch_percentage = 2;
    bool has_launch_percentage() const;

private:
    bool _internal_has_launch_percentage() const;

public:
    void clear_launch_percentage();
    uint32_t launch_percentage() const;
    void set_launch_percentage(uint32_t value);

private:
    uint32_t _internal_launch_percentage() const;
    void _internal_set_launch_percentage(uint32_t value);

public:
    // @@protoc_insertion_point(class_scope:reputation.HeuristicLaunchConfig)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int heuristic_;
        uint32_t launch_percentage_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_safety_5ftips_2eproto;
};
// -------------------------------------------------------------------

class Cohort final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reputation.Cohort) */ {
public:
    inline Cohort()
        : Cohort(nullptr)
    {
    }
    ~Cohort() override;
    explicit PROTOBUF_CONSTEXPR Cohort(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Cohort(const Cohort& from);
    Cohort(Cohort&& from) noexcept
        : Cohort()
    {
        *this = ::std::move(from);
    }

    inline Cohort& operator=(const Cohort& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Cohort& operator=(Cohort&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Cohort& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Cohort* internal_default_instance()
    {
        return reinterpret_cast<const Cohort*>(&_Cohort_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(Cohort& a, Cohort& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Cohort* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Cohort* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Cohort* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Cohort>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Cohort& from);
    void MergeFrom(const Cohort& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Cohort* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reputation.Cohort";
    }

protected:
    explicit Cohort(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kAllowedIndexFieldNumber = 1,
        kCanonicalIndexFieldNumber = 2,
    };
    // repeated uint32 allowed_index = 1 [packed = true];
    int allowed_index_size() const;

private:
    int _internal_allowed_index_size() const;

public:
    void clear_allowed_index();

private:
    uint32_t _internal_allowed_index(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& _internal_allowed_index() const;
    void _internal_add_allowed_index(uint32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* _internal_mutable_allowed_index();

public:
    uint32_t allowed_index(int index) const;
    void set_allowed_index(int index, uint32_t value);
    void add_allowed_index(uint32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& allowed_index() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* mutable_allowed_index();

    // repeated uint32 canonical_index = 2 [packed = true];
    int canonical_index_size() const;

private:
    int _internal_canonical_index_size() const;

public:
    void clear_canonical_index();

private:
    uint32_t _internal_canonical_index(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& _internal_canonical_index() const;
    void _internal_add_canonical_index(uint32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* _internal_mutable_canonical_index();

public:
    uint32_t canonical_index(int index) const;
    void set_canonical_index(int index, uint32_t value);
    void add_canonical_index(uint32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& canonical_index() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* mutable_canonical_index();

    // @@protoc_insertion_point(class_scope:reputation.Cohort)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t> allowed_index_;
        mutable std::atomic<int> _allowed_index_cached_byte_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t> canonical_index_;
        mutable std::atomic<int> _canonical_index_cached_byte_size_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_safety_5ftips_2eproto;
};
// -------------------------------------------------------------------

class SafetyTipsConfig final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reputation.SafetyTipsConfig) */ {
public:
    inline SafetyTipsConfig()
        : SafetyTipsConfig(nullptr)
    {
    }
    ~SafetyTipsConfig() override;
    explicit PROTOBUF_CONSTEXPR SafetyTipsConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SafetyTipsConfig(const SafetyTipsConfig& from);
    SafetyTipsConfig(SafetyTipsConfig&& from) noexcept
        : SafetyTipsConfig()
    {
        *this = ::std::move(from);
    }

    inline SafetyTipsConfig& operator=(const SafetyTipsConfig& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SafetyTipsConfig& operator=(SafetyTipsConfig&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SafetyTipsConfig& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SafetyTipsConfig* internal_default_instance()
    {
        return reinterpret_cast<const SafetyTipsConfig*>(&_SafetyTipsConfig_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(SafetyTipsConfig& a, SafetyTipsConfig& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SafetyTipsConfig* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SafetyTipsConfig* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SafetyTipsConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SafetyTipsConfig>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SafetyTipsConfig& from);
    void MergeFrom(const SafetyTipsConfig& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SafetyTipsConfig* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reputation.SafetyTipsConfig";
    }

protected:
    explicit SafetyTipsConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFlaggedPageFieldNumber = 2,
        kAllowedPatternFieldNumber = 3,
        kAllowedTargetPatternFieldNumber = 4,
        kCommonWordFieldNumber = 5,
        kLaunchConfigFieldNumber = 6,
        kCanonicalPatternFieldNumber = 7,
        kCohortFieldNumber = 8,
        kVersionIdFieldNumber = 1,
    };
    // repeated .reputation.FlaggedPage flagged_page = 2;
    int flagged_page_size() const;

private:
    int _internal_flagged_page_size() const;

public:
    void clear_flagged_page();
    ::reputation::FlaggedPage* mutable_flagged_page(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::FlaggedPage>* mutable_flagged_page();

private:
    const ::reputation::FlaggedPage& _internal_flagged_page(int index) const;
    ::reputation::FlaggedPage* _internal_add_flagged_page();

public:
    const ::reputation::FlaggedPage& flagged_page(int index) const;
    ::reputation::FlaggedPage* add_flagged_page();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::FlaggedPage>& flagged_page() const;

    // repeated .reputation.UrlPattern allowed_pattern = 3;
    int allowed_pattern_size() const;

private:
    int _internal_allowed_pattern_size() const;

public:
    void clear_allowed_pattern();
    ::reputation::UrlPattern* mutable_allowed_pattern(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::UrlPattern>* mutable_allowed_pattern();

private:
    const ::reputation::UrlPattern& _internal_allowed_pattern(int index) const;
    ::reputation::UrlPattern* _internal_add_allowed_pattern();

public:
    const ::reputation::UrlPattern& allowed_pattern(int index) const;
    ::reputation::UrlPattern* add_allowed_pattern();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::UrlPattern>& allowed_pattern() const;

    // repeated .reputation.HostPattern allowed_target_pattern = 4;
    int allowed_target_pattern_size() const;

private:
    int _internal_allowed_target_pattern_size() const;

public:
    void clear_allowed_target_pattern();
    ::reputation::HostPattern* mutable_allowed_target_pattern(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::HostPattern>* mutable_allowed_target_pattern();

private:
    const ::reputation::HostPattern& _internal_allowed_target_pattern(int index) const;
    ::reputation::HostPattern* _internal_add_allowed_target_pattern();

public:
    const ::reputation::HostPattern& allowed_target_pattern(int index) const;
    ::reputation::HostPattern* add_allowed_target_pattern();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::HostPattern>& allowed_target_pattern() const;

    // repeated string common_word = 5;
    int common_word_size() const;

private:
    int _internal_common_word_size() const;

public:
    void clear_common_word();
    const std::string& common_word(int index) const;
    std::string* mutable_common_word(int index);
    void set_common_word(int index, const std::string& value);
    void set_common_word(int index, std::string&& value);
    void set_common_word(int index, const char* value);
    void set_common_word(int index, const char* value, size_t size);
    std::string* add_common_word();
    void add_common_word(const std::string& value);
    void add_common_word(std::string&& value);
    void add_common_word(const char* value);
    void add_common_word(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& common_word() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_common_word();

private:
    const std::string& _internal_common_word(int index) const;
    std::string* _internal_add_common_word();

public:
    // repeated .reputation.HeuristicLaunchConfig launch_config = 6;
    int launch_config_size() const;

private:
    int _internal_launch_config_size() const;

public:
    void clear_launch_config();
    ::reputation::HeuristicLaunchConfig* mutable_launch_config(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::HeuristicLaunchConfig>* mutable_launch_config();

private:
    const ::reputation::HeuristicLaunchConfig& _internal_launch_config(int index) const;
    ::reputation::HeuristicLaunchConfig* _internal_add_launch_config();

public:
    const ::reputation::HeuristicLaunchConfig& launch_config(int index) const;
    ::reputation::HeuristicLaunchConfig* add_launch_config();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::HeuristicLaunchConfig>& launch_config() const;

    // repeated .reputation.UrlPattern canonical_pattern = 7;
    int canonical_pattern_size() const;

private:
    int _internal_canonical_pattern_size() const;

public:
    void clear_canonical_pattern();
    ::reputation::UrlPattern* mutable_canonical_pattern(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::UrlPattern>* mutable_canonical_pattern();

private:
    const ::reputation::UrlPattern& _internal_canonical_pattern(int index) const;
    ::reputation::UrlPattern* _internal_add_canonical_pattern();

public:
    const ::reputation::UrlPattern& canonical_pattern(int index) const;
    ::reputation::UrlPattern* add_canonical_pattern();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::UrlPattern>& canonical_pattern() const;

    // repeated .reputation.Cohort cohort = 8;
    int cohort_size() const;

private:
    int _internal_cohort_size() const;

public:
    void clear_cohort();
    ::reputation::Cohort* mutable_cohort(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::Cohort>* mutable_cohort();

private:
    const ::reputation::Cohort& _internal_cohort(int index) const;
    ::reputation::Cohort* _internal_add_cohort();

public:
    const ::reputation::Cohort& cohort(int index) const;
    ::reputation::Cohort* add_cohort();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::Cohort>& cohort() const;

    // optional uint32 version_id = 1;
    bool has_version_id() const;

private:
    bool _internal_has_version_id() const;

public:
    void clear_version_id();
    uint32_t version_id() const;
    void set_version_id(uint32_t value);

private:
    uint32_t _internal_version_id() const;
    void _internal_set_version_id(uint32_t value);

public:
    // @@protoc_insertion_point(class_scope:reputation.SafetyTipsConfig)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::FlaggedPage> flagged_page_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::UrlPattern> allowed_pattern_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::HostPattern> allowed_target_pattern_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> common_word_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::HeuristicLaunchConfig> launch_config_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::UrlPattern> canonical_pattern_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::Cohort> cohort_;
        uint32_t version_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_safety_5ftips_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// FlaggedPage

// optional string pattern = 1;
inline bool FlaggedPage::_internal_has_pattern() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool FlaggedPage::has_pattern() const
{
    return _internal_has_pattern();
}
inline void FlaggedPage::clear_pattern()
{
    _impl_.pattern_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FlaggedPage::pattern() const
{
    // @@protoc_insertion_point(field_get:reputation.FlaggedPage.pattern)
    return _internal_pattern();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FlaggedPage::set_pattern(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.pattern_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reputation.FlaggedPage.pattern)
}
inline std::string* FlaggedPage::mutable_pattern()
{
    std::string* _s = _internal_mutable_pattern();
    // @@protoc_insertion_point(field_mutable:reputation.FlaggedPage.pattern)
    return _s;
}
inline const std::string& FlaggedPage::_internal_pattern() const
{
    return _impl_.pattern_.Get();
}
inline void FlaggedPage::_internal_set_pattern(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* FlaggedPage::_internal_mutable_pattern()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.pattern_.Mutable(GetArenaForAllocation());
}
inline std::string* FlaggedPage::release_pattern()
{
    // @@protoc_insertion_point(field_release:reputation.FlaggedPage.pattern)
    if (!_internal_has_pattern()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.pattern_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.pattern_.IsDefault()) {
        _impl_.pattern_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void FlaggedPage::set_allocated_pattern(std::string* pattern)
{
    if (pattern != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.pattern_.SetAllocated(pattern, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.pattern_.IsDefault()) {
        _impl_.pattern_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reputation.FlaggedPage.pattern)
}

// optional .reputation.FlaggedPage.FlagType type = 2;
inline bool FlaggedPage::_internal_has_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool FlaggedPage::has_type() const
{
    return _internal_has_type();
}
inline void FlaggedPage::clear_type()
{
    _impl_.type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::reputation::FlaggedPage_FlagType FlaggedPage::_internal_type() const
{
    return static_cast<::reputation::FlaggedPage_FlagType>(_impl_.type_);
}
inline ::reputation::FlaggedPage_FlagType FlaggedPage::type() const
{
    // @@protoc_insertion_point(field_get:reputation.FlaggedPage.type)
    return _internal_type();
}
inline void FlaggedPage::_internal_set_type(::reputation::FlaggedPage_FlagType value)
{
    assert(::reputation::FlaggedPage_FlagType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.type_ = value;
}
inline void FlaggedPage::set_type(::reputation::FlaggedPage_FlagType value)
{
    _internal_set_type(value);
    // @@protoc_insertion_point(field_set:reputation.FlaggedPage.type)
}

// -------------------------------------------------------------------

// UrlPattern

// optional string pattern = 1;
inline bool UrlPattern::_internal_has_pattern() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool UrlPattern::has_pattern() const
{
    return _internal_has_pattern();
}
inline void UrlPattern::clear_pattern()
{
    _impl_.pattern_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UrlPattern::pattern() const
{
    // @@protoc_insertion_point(field_get:reputation.UrlPattern.pattern)
    return _internal_pattern();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void UrlPattern::set_pattern(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.pattern_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reputation.UrlPattern.pattern)
}
inline std::string* UrlPattern::mutable_pattern()
{
    std::string* _s = _internal_mutable_pattern();
    // @@protoc_insertion_point(field_mutable:reputation.UrlPattern.pattern)
    return _s;
}
inline const std::string& UrlPattern::_internal_pattern() const
{
    return _impl_.pattern_.Get();
}
inline void UrlPattern::_internal_set_pattern(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* UrlPattern::_internal_mutable_pattern()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.pattern_.Mutable(GetArenaForAllocation());
}
inline std::string* UrlPattern::release_pattern()
{
    // @@protoc_insertion_point(field_release:reputation.UrlPattern.pattern)
    if (!_internal_has_pattern()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.pattern_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.pattern_.IsDefault()) {
        _impl_.pattern_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void UrlPattern::set_allocated_pattern(std::string* pattern)
{
    if (pattern != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.pattern_.SetAllocated(pattern, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.pattern_.IsDefault()) {
        _impl_.pattern_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reputation.UrlPattern.pattern)
}

// repeated uint32 cohort_index = 2 [packed = true];
inline int UrlPattern::_internal_cohort_index_size() const
{
    return _impl_.cohort_index_.size();
}
inline int UrlPattern::cohort_index_size() const
{
    return _internal_cohort_index_size();
}
inline void UrlPattern::clear_cohort_index()
{
    _impl_.cohort_index_.Clear();
}
inline uint32_t UrlPattern::_internal_cohort_index(int index) const
{
    return _impl_.cohort_index_.Get(index);
}
inline uint32_t UrlPattern::cohort_index(int index) const
{
    // @@protoc_insertion_point(field_get:reputation.UrlPattern.cohort_index)
    return _internal_cohort_index(index);
}
inline void UrlPattern::set_cohort_index(int index, uint32_t value)
{
    _impl_.cohort_index_.Set(index, value);
    // @@protoc_insertion_point(field_set:reputation.UrlPattern.cohort_index)
}
inline void UrlPattern::_internal_add_cohort_index(uint32_t value)
{
    _impl_.cohort_index_.Add(value);
}
inline void UrlPattern::add_cohort_index(uint32_t value)
{
    _internal_add_cohort_index(value);
    // @@protoc_insertion_point(field_add:reputation.UrlPattern.cohort_index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& UrlPattern::_internal_cohort_index() const
{
    return _impl_.cohort_index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& UrlPattern::cohort_index() const
{
    // @@protoc_insertion_point(field_list:reputation.UrlPattern.cohort_index)
    return _internal_cohort_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* UrlPattern::_internal_mutable_cohort_index()
{
    return &_impl_.cohort_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* UrlPattern::mutable_cohort_index()
{
    // @@protoc_insertion_point(field_mutable_list:reputation.UrlPattern.cohort_index)
    return _internal_mutable_cohort_index();
}

// -------------------------------------------------------------------

// HostPattern

// optional string regex = 1;
inline bool HostPattern::_internal_has_regex() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool HostPattern::has_regex() const
{
    return _internal_has_regex();
}
inline void HostPattern::clear_regex()
{
    _impl_.regex_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HostPattern::regex() const
{
    // @@protoc_insertion_point(field_get:reputation.HostPattern.regex)
    return _internal_regex();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void HostPattern::set_regex(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.regex_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reputation.HostPattern.regex)
}
inline std::string* HostPattern::mutable_regex()
{
    std::string* _s = _internal_mutable_regex();
    // @@protoc_insertion_point(field_mutable:reputation.HostPattern.regex)
    return _s;
}
inline const std::string& HostPattern::_internal_regex() const
{
    return _impl_.regex_.Get();
}
inline void HostPattern::_internal_set_regex(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.regex_.Set(value, GetArenaForAllocation());
}
inline std::string* HostPattern::_internal_mutable_regex()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.regex_.Mutable(GetArenaForAllocation());
}
inline std::string* HostPattern::release_regex()
{
    // @@protoc_insertion_point(field_release:reputation.HostPattern.regex)
    if (!_internal_has_regex()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.regex_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.regex_.IsDefault()) {
        _impl_.regex_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void HostPattern::set_allocated_regex(std::string* regex)
{
    if (regex != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.regex_.SetAllocated(regex, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.regex_.IsDefault()) {
        _impl_.regex_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reputation.HostPattern.regex)
}

// -------------------------------------------------------------------

// HeuristicLaunchConfig

// optional .reputation.HeuristicLaunchConfig.Heuristic heuristic = 1;
inline bool HeuristicLaunchConfig::_internal_has_heuristic() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool HeuristicLaunchConfig::has_heuristic() const
{
    return _internal_has_heuristic();
}
inline void HeuristicLaunchConfig::clear_heuristic()
{
    _impl_.heuristic_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::reputation::HeuristicLaunchConfig_Heuristic HeuristicLaunchConfig::_internal_heuristic() const
{
    return static_cast<::reputation::HeuristicLaunchConfig_Heuristic>(_impl_.heuristic_);
}
inline ::reputation::HeuristicLaunchConfig_Heuristic HeuristicLaunchConfig::heuristic() const
{
    // @@protoc_insertion_point(field_get:reputation.HeuristicLaunchConfig.heuristic)
    return _internal_heuristic();
}
inline void HeuristicLaunchConfig::_internal_set_heuristic(::reputation::HeuristicLaunchConfig_Heuristic value)
{
    assert(::reputation::HeuristicLaunchConfig_Heuristic_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.heuristic_ = value;
}
inline void HeuristicLaunchConfig::set_heuristic(::reputation::HeuristicLaunchConfig_Heuristic value)
{
    _internal_set_heuristic(value);
    // @@protoc_insertion_point(field_set:reputation.HeuristicLaunchConfig.heuristic)
}

// optional uint32 launch_percentage = 2;
inline bool HeuristicLaunchConfig::_internal_has_launch_percentage() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool HeuristicLaunchConfig::has_launch_percentage() const
{
    return _internal_has_launch_percentage();
}
inline void HeuristicLaunchConfig::clear_launch_percentage()
{
    _impl_.launch_percentage_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t HeuristicLaunchConfig::_internal_launch_percentage() const
{
    return _impl_.launch_percentage_;
}
inline uint32_t HeuristicLaunchConfig::launch_percentage() const
{
    // @@protoc_insertion_point(field_get:reputation.HeuristicLaunchConfig.launch_percentage)
    return _internal_launch_percentage();
}
inline void HeuristicLaunchConfig::_internal_set_launch_percentage(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.launch_percentage_ = value;
}
inline void HeuristicLaunchConfig::set_launch_percentage(uint32_t value)
{
    _internal_set_launch_percentage(value);
    // @@protoc_insertion_point(field_set:reputation.HeuristicLaunchConfig.launch_percentage)
}

// -------------------------------------------------------------------

// Cohort

// repeated uint32 allowed_index = 1 [packed = true];
inline int Cohort::_internal_allowed_index_size() const
{
    return _impl_.allowed_index_.size();
}
inline int Cohort::allowed_index_size() const
{
    return _internal_allowed_index_size();
}
inline void Cohort::clear_allowed_index()
{
    _impl_.allowed_index_.Clear();
}
inline uint32_t Cohort::_internal_allowed_index(int index) const
{
    return _impl_.allowed_index_.Get(index);
}
inline uint32_t Cohort::allowed_index(int index) const
{
    // @@protoc_insertion_point(field_get:reputation.Cohort.allowed_index)
    return _internal_allowed_index(index);
}
inline void Cohort::set_allowed_index(int index, uint32_t value)
{
    _impl_.allowed_index_.Set(index, value);
    // @@protoc_insertion_point(field_set:reputation.Cohort.allowed_index)
}
inline void Cohort::_internal_add_allowed_index(uint32_t value)
{
    _impl_.allowed_index_.Add(value);
}
inline void Cohort::add_allowed_index(uint32_t value)
{
    _internal_add_allowed_index(value);
    // @@protoc_insertion_point(field_add:reputation.Cohort.allowed_index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& Cohort::_internal_allowed_index() const
{
    return _impl_.allowed_index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& Cohort::allowed_index() const
{
    // @@protoc_insertion_point(field_list:reputation.Cohort.allowed_index)
    return _internal_allowed_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* Cohort::_internal_mutable_allowed_index()
{
    return &_impl_.allowed_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* Cohort::mutable_allowed_index()
{
    // @@protoc_insertion_point(field_mutable_list:reputation.Cohort.allowed_index)
    return _internal_mutable_allowed_index();
}

// repeated uint32 canonical_index = 2 [packed = true];
inline int Cohort::_internal_canonical_index_size() const
{
    return _impl_.canonical_index_.size();
}
inline int Cohort::canonical_index_size() const
{
    return _internal_canonical_index_size();
}
inline void Cohort::clear_canonical_index()
{
    _impl_.canonical_index_.Clear();
}
inline uint32_t Cohort::_internal_canonical_index(int index) const
{
    return _impl_.canonical_index_.Get(index);
}
inline uint32_t Cohort::canonical_index(int index) const
{
    // @@protoc_insertion_point(field_get:reputation.Cohort.canonical_index)
    return _internal_canonical_index(index);
}
inline void Cohort::set_canonical_index(int index, uint32_t value)
{
    _impl_.canonical_index_.Set(index, value);
    // @@protoc_insertion_point(field_set:reputation.Cohort.canonical_index)
}
inline void Cohort::_internal_add_canonical_index(uint32_t value)
{
    _impl_.canonical_index_.Add(value);
}
inline void Cohort::add_canonical_index(uint32_t value)
{
    _internal_add_canonical_index(value);
    // @@protoc_insertion_point(field_add:reputation.Cohort.canonical_index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& Cohort::_internal_canonical_index() const
{
    return _impl_.canonical_index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& Cohort::canonical_index() const
{
    // @@protoc_insertion_point(field_list:reputation.Cohort.canonical_index)
    return _internal_canonical_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* Cohort::_internal_mutable_canonical_index()
{
    return &_impl_.canonical_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* Cohort::mutable_canonical_index()
{
    // @@protoc_insertion_point(field_mutable_list:reputation.Cohort.canonical_index)
    return _internal_mutable_canonical_index();
}

// -------------------------------------------------------------------

// SafetyTipsConfig

// optional uint32 version_id = 1;
inline bool SafetyTipsConfig::_internal_has_version_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SafetyTipsConfig::has_version_id() const
{
    return _internal_has_version_id();
}
inline void SafetyTipsConfig::clear_version_id()
{
    _impl_.version_id_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t SafetyTipsConfig::_internal_version_id() const
{
    return _impl_.version_id_;
}
inline uint32_t SafetyTipsConfig::version_id() const
{
    // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.version_id)
    return _internal_version_id();
}
inline void SafetyTipsConfig::_internal_set_version_id(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.version_id_ = value;
}
inline void SafetyTipsConfig::set_version_id(uint32_t value)
{
    _internal_set_version_id(value);
    // @@protoc_insertion_point(field_set:reputation.SafetyTipsConfig.version_id)
}

// repeated .reputation.FlaggedPage flagged_page = 2;
inline int SafetyTipsConfig::_internal_flagged_page_size() const
{
    return _impl_.flagged_page_.size();
}
inline int SafetyTipsConfig::flagged_page_size() const
{
    return _internal_flagged_page_size();
}
inline void SafetyTipsConfig::clear_flagged_page()
{
    _impl_.flagged_page_.Clear();
}
inline ::reputation::FlaggedPage* SafetyTipsConfig::mutable_flagged_page(int index)
{
    // @@protoc_insertion_point(field_mutable:reputation.SafetyTipsConfig.flagged_page)
    return _impl_.flagged_page_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::FlaggedPage>* SafetyTipsConfig::mutable_flagged_page()
{
    // @@protoc_insertion_point(field_mutable_list:reputation.SafetyTipsConfig.flagged_page)
    return &_impl_.flagged_page_;
}
inline const ::reputation::FlaggedPage& SafetyTipsConfig::_internal_flagged_page(int index) const
{
    return _impl_.flagged_page_.Get(index);
}
inline const ::reputation::FlaggedPage& SafetyTipsConfig::flagged_page(int index) const
{
    // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.flagged_page)
    return _internal_flagged_page(index);
}
inline ::reputation::FlaggedPage* SafetyTipsConfig::_internal_add_flagged_page()
{
    return _impl_.flagged_page_.Add();
}
inline ::reputation::FlaggedPage* SafetyTipsConfig::add_flagged_page()
{
    ::reputation::FlaggedPage* _add = _internal_add_flagged_page();
    // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.flagged_page)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::FlaggedPage>& SafetyTipsConfig::flagged_page() const
{
    // @@protoc_insertion_point(field_list:reputation.SafetyTipsConfig.flagged_page)
    return _impl_.flagged_page_;
}

// repeated .reputation.UrlPattern allowed_pattern = 3;
inline int SafetyTipsConfig::_internal_allowed_pattern_size() const
{
    return _impl_.allowed_pattern_.size();
}
inline int SafetyTipsConfig::allowed_pattern_size() const
{
    return _internal_allowed_pattern_size();
}
inline void SafetyTipsConfig::clear_allowed_pattern()
{
    _impl_.allowed_pattern_.Clear();
}
inline ::reputation::UrlPattern* SafetyTipsConfig::mutable_allowed_pattern(int index)
{
    // @@protoc_insertion_point(field_mutable:reputation.SafetyTipsConfig.allowed_pattern)
    return _impl_.allowed_pattern_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::UrlPattern>* SafetyTipsConfig::mutable_allowed_pattern()
{
    // @@protoc_insertion_point(field_mutable_list:reputation.SafetyTipsConfig.allowed_pattern)
    return &_impl_.allowed_pattern_;
}
inline const ::reputation::UrlPattern& SafetyTipsConfig::_internal_allowed_pattern(int index) const
{
    return _impl_.allowed_pattern_.Get(index);
}
inline const ::reputation::UrlPattern& SafetyTipsConfig::allowed_pattern(int index) const
{
    // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.allowed_pattern)
    return _internal_allowed_pattern(index);
}
inline ::reputation::UrlPattern* SafetyTipsConfig::_internal_add_allowed_pattern()
{
    return _impl_.allowed_pattern_.Add();
}
inline ::reputation::UrlPattern* SafetyTipsConfig::add_allowed_pattern()
{
    ::reputation::UrlPattern* _add = _internal_add_allowed_pattern();
    // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.allowed_pattern)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::UrlPattern>& SafetyTipsConfig::allowed_pattern() const
{
    // @@protoc_insertion_point(field_list:reputation.SafetyTipsConfig.allowed_pattern)
    return _impl_.allowed_pattern_;
}

// repeated .reputation.HostPattern allowed_target_pattern = 4;
inline int SafetyTipsConfig::_internal_allowed_target_pattern_size() const
{
    return _impl_.allowed_target_pattern_.size();
}
inline int SafetyTipsConfig::allowed_target_pattern_size() const
{
    return _internal_allowed_target_pattern_size();
}
inline void SafetyTipsConfig::clear_allowed_target_pattern()
{
    _impl_.allowed_target_pattern_.Clear();
}
inline ::reputation::HostPattern* SafetyTipsConfig::mutable_allowed_target_pattern(int index)
{
    // @@protoc_insertion_point(field_mutable:reputation.SafetyTipsConfig.allowed_target_pattern)
    return _impl_.allowed_target_pattern_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::HostPattern>* SafetyTipsConfig::mutable_allowed_target_pattern()
{
    // @@protoc_insertion_point(field_mutable_list:reputation.SafetyTipsConfig.allowed_target_pattern)
    return &_impl_.allowed_target_pattern_;
}
inline const ::reputation::HostPattern& SafetyTipsConfig::_internal_allowed_target_pattern(int index) const
{
    return _impl_.allowed_target_pattern_.Get(index);
}
inline const ::reputation::HostPattern& SafetyTipsConfig::allowed_target_pattern(int index) const
{
    // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.allowed_target_pattern)
    return _internal_allowed_target_pattern(index);
}
inline ::reputation::HostPattern* SafetyTipsConfig::_internal_add_allowed_target_pattern()
{
    return _impl_.allowed_target_pattern_.Add();
}
inline ::reputation::HostPattern* SafetyTipsConfig::add_allowed_target_pattern()
{
    ::reputation::HostPattern* _add = _internal_add_allowed_target_pattern();
    // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.allowed_target_pattern)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::HostPattern>& SafetyTipsConfig::allowed_target_pattern() const
{
    // @@protoc_insertion_point(field_list:reputation.SafetyTipsConfig.allowed_target_pattern)
    return _impl_.allowed_target_pattern_;
}

// repeated string common_word = 5;
inline int SafetyTipsConfig::_internal_common_word_size() const
{
    return _impl_.common_word_.size();
}
inline int SafetyTipsConfig::common_word_size() const
{
    return _internal_common_word_size();
}
inline void SafetyTipsConfig::clear_common_word()
{
    _impl_.common_word_.Clear();
}
inline std::string* SafetyTipsConfig::add_common_word()
{
    std::string* _s = _internal_add_common_word();
    // @@protoc_insertion_point(field_add_mutable:reputation.SafetyTipsConfig.common_word)
    return _s;
}
inline const std::string& SafetyTipsConfig::_internal_common_word(int index) const
{
    return _impl_.common_word_.Get(index);
}
inline const std::string& SafetyTipsConfig::common_word(int index) const
{
    // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.common_word)
    return _internal_common_word(index);
}
inline std::string* SafetyTipsConfig::mutable_common_word(int index)
{
    // @@protoc_insertion_point(field_mutable:reputation.SafetyTipsConfig.common_word)
    return _impl_.common_word_.Mutable(index);
}
inline void SafetyTipsConfig::set_common_word(int index, const std::string& value)
{
    _impl_.common_word_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:reputation.SafetyTipsConfig.common_word)
}
inline void SafetyTipsConfig::set_common_word(int index, std::string&& value)
{
    _impl_.common_word_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:reputation.SafetyTipsConfig.common_word)
}
inline void SafetyTipsConfig::set_common_word(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.common_word_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:reputation.SafetyTipsConfig.common_word)
}
inline void SafetyTipsConfig::set_common_word(int index, const char* value, size_t size)
{
    _impl_.common_word_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:reputation.SafetyTipsConfig.common_word)
}
inline std::string* SafetyTipsConfig::_internal_add_common_word()
{
    return _impl_.common_word_.Add();
}
inline void SafetyTipsConfig::add_common_word(const std::string& value)
{
    _impl_.common_word_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.common_word)
}
inline void SafetyTipsConfig::add_common_word(std::string&& value)
{
    _impl_.common_word_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.common_word)
}
inline void SafetyTipsConfig::add_common_word(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.common_word_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:reputation.SafetyTipsConfig.common_word)
}
inline void SafetyTipsConfig::add_common_word(const char* value, size_t size)
{
    _impl_.common_word_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:reputation.SafetyTipsConfig.common_word)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& SafetyTipsConfig::common_word() const
{
    // @@protoc_insertion_point(field_list:reputation.SafetyTipsConfig.common_word)
    return _impl_.common_word_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* SafetyTipsConfig::mutable_common_word()
{
    // @@protoc_insertion_point(field_mutable_list:reputation.SafetyTipsConfig.common_word)
    return &_impl_.common_word_;
}

// repeated .reputation.HeuristicLaunchConfig launch_config = 6;
inline int SafetyTipsConfig::_internal_launch_config_size() const
{
    return _impl_.launch_config_.size();
}
inline int SafetyTipsConfig::launch_config_size() const
{
    return _internal_launch_config_size();
}
inline void SafetyTipsConfig::clear_launch_config()
{
    _impl_.launch_config_.Clear();
}
inline ::reputation::HeuristicLaunchConfig* SafetyTipsConfig::mutable_launch_config(int index)
{
    // @@protoc_insertion_point(field_mutable:reputation.SafetyTipsConfig.launch_config)
    return _impl_.launch_config_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::HeuristicLaunchConfig>* SafetyTipsConfig::mutable_launch_config()
{
    // @@protoc_insertion_point(field_mutable_list:reputation.SafetyTipsConfig.launch_config)
    return &_impl_.launch_config_;
}
inline const ::reputation::HeuristicLaunchConfig& SafetyTipsConfig::_internal_launch_config(int index) const
{
    return _impl_.launch_config_.Get(index);
}
inline const ::reputation::HeuristicLaunchConfig& SafetyTipsConfig::launch_config(int index) const
{
    // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.launch_config)
    return _internal_launch_config(index);
}
inline ::reputation::HeuristicLaunchConfig* SafetyTipsConfig::_internal_add_launch_config()
{
    return _impl_.launch_config_.Add();
}
inline ::reputation::HeuristicLaunchConfig* SafetyTipsConfig::add_launch_config()
{
    ::reputation::HeuristicLaunchConfig* _add = _internal_add_launch_config();
    // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.launch_config)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::HeuristicLaunchConfig>& SafetyTipsConfig::launch_config() const
{
    // @@protoc_insertion_point(field_list:reputation.SafetyTipsConfig.launch_config)
    return _impl_.launch_config_;
}

// repeated .reputation.UrlPattern canonical_pattern = 7;
inline int SafetyTipsConfig::_internal_canonical_pattern_size() const
{
    return _impl_.canonical_pattern_.size();
}
inline int SafetyTipsConfig::canonical_pattern_size() const
{
    return _internal_canonical_pattern_size();
}
inline void SafetyTipsConfig::clear_canonical_pattern()
{
    _impl_.canonical_pattern_.Clear();
}
inline ::reputation::UrlPattern* SafetyTipsConfig::mutable_canonical_pattern(int index)
{
    // @@protoc_insertion_point(field_mutable:reputation.SafetyTipsConfig.canonical_pattern)
    return _impl_.canonical_pattern_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::UrlPattern>* SafetyTipsConfig::mutable_canonical_pattern()
{
    // @@protoc_insertion_point(field_mutable_list:reputation.SafetyTipsConfig.canonical_pattern)
    return &_impl_.canonical_pattern_;
}
inline const ::reputation::UrlPattern& SafetyTipsConfig::_internal_canonical_pattern(int index) const
{
    return _impl_.canonical_pattern_.Get(index);
}
inline const ::reputation::UrlPattern& SafetyTipsConfig::canonical_pattern(int index) const
{
    // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.canonical_pattern)
    return _internal_canonical_pattern(index);
}
inline ::reputation::UrlPattern* SafetyTipsConfig::_internal_add_canonical_pattern()
{
    return _impl_.canonical_pattern_.Add();
}
inline ::reputation::UrlPattern* SafetyTipsConfig::add_canonical_pattern()
{
    ::reputation::UrlPattern* _add = _internal_add_canonical_pattern();
    // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.canonical_pattern)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::UrlPattern>& SafetyTipsConfig::canonical_pattern() const
{
    // @@protoc_insertion_point(field_list:reputation.SafetyTipsConfig.canonical_pattern)
    return _impl_.canonical_pattern_;
}

// repeated .reputation.Cohort cohort = 8;
inline int SafetyTipsConfig::_internal_cohort_size() const
{
    return _impl_.cohort_.size();
}
inline int SafetyTipsConfig::cohort_size() const
{
    return _internal_cohort_size();
}
inline void SafetyTipsConfig::clear_cohort()
{
    _impl_.cohort_.Clear();
}
inline ::reputation::Cohort* SafetyTipsConfig::mutable_cohort(int index)
{
    // @@protoc_insertion_point(field_mutable:reputation.SafetyTipsConfig.cohort)
    return _impl_.cohort_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::Cohort>* SafetyTipsConfig::mutable_cohort()
{
    // @@protoc_insertion_point(field_mutable_list:reputation.SafetyTipsConfig.cohort)
    return &_impl_.cohort_;
}
inline const ::reputation::Cohort& SafetyTipsConfig::_internal_cohort(int index) const
{
    return _impl_.cohort_.Get(index);
}
inline const ::reputation::Cohort& SafetyTipsConfig::cohort(int index) const
{
    // @@protoc_insertion_point(field_get:reputation.SafetyTipsConfig.cohort)
    return _internal_cohort(index);
}
inline ::reputation::Cohort* SafetyTipsConfig::_internal_add_cohort()
{
    return _impl_.cohort_.Add();
}
inline ::reputation::Cohort* SafetyTipsConfig::add_cohort()
{
    ::reputation::Cohort* _add = _internal_add_cohort();
    // @@protoc_insertion_point(field_add:reputation.SafetyTipsConfig.cohort)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reputation::Cohort>& SafetyTipsConfig::cohort() const
{
    // @@protoc_insertion_point(field_list:reputation.SafetyTipsConfig.cohort)
    return _impl_.cohort_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace reputation

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::reputation::FlaggedPage_FlagType> : ::std::true_type { };
template <> struct is_proto_enum<::reputation::HeuristicLaunchConfig_Heuristic> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_safety_5ftips_2eproto
