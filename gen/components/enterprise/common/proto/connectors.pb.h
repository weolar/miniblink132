// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/enterprise/common/proto/connectors.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/safe_browsing/core/common/proto/csd.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto {
    static const uint32_t offsets[];
};
namespace enterprise_connectors {
class ClientMetadata;
struct ClientMetadataDefaultTypeInternal;
extern ClientMetadataDefaultTypeInternal _ClientMetadata_default_instance_;
class ClientMetadata_Browser;
struct ClientMetadata_BrowserDefaultTypeInternal;
extern ClientMetadata_BrowserDefaultTypeInternal _ClientMetadata_Browser_default_instance_;
class ClientMetadata_Device;
struct ClientMetadata_DeviceDefaultTypeInternal;
extern ClientMetadata_DeviceDefaultTypeInternal _ClientMetadata_Device_default_instance_;
class ClientMetadata_Profile;
struct ClientMetadata_ProfileDefaultTypeInternal;
extern ClientMetadata_ProfileDefaultTypeInternal _ClientMetadata_Profile_default_instance_;
class ContentAnalysisAcknowledgement;
struct ContentAnalysisAcknowledgementDefaultTypeInternal;
extern ContentAnalysisAcknowledgementDefaultTypeInternal _ContentAnalysisAcknowledgement_default_instance_;
class ContentAnalysisRequest;
struct ContentAnalysisRequestDefaultTypeInternal;
extern ContentAnalysisRequestDefaultTypeInternal _ContentAnalysisRequest_default_instance_;
class ContentAnalysisResponse;
struct ContentAnalysisResponseDefaultTypeInternal;
extern ContentAnalysisResponseDefaultTypeInternal _ContentAnalysisResponse_default_instance_;
class ContentAnalysisResponse_Result;
struct ContentAnalysisResponse_ResultDefaultTypeInternal;
extern ContentAnalysisResponse_ResultDefaultTypeInternal _ContentAnalysisResponse_Result_default_instance_;
class ContentAnalysisResponse_Result_CustomMessage;
struct ContentAnalysisResponse_Result_CustomMessageDefaultTypeInternal;
extern ContentAnalysisResponse_Result_CustomMessageDefaultTypeInternal _ContentAnalysisResponse_Result_CustomMessage_default_instance_;
class ContentAnalysisResponse_Result_TriggeredRule;
struct ContentAnalysisResponse_Result_TriggeredRuleDefaultTypeInternal;
extern ContentAnalysisResponse_Result_TriggeredRuleDefaultTypeInternal _ContentAnalysisResponse_Result_TriggeredRule_default_instance_;
class ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage;
struct ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageDefaultTypeInternal;
extern ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageDefaultTypeInternal
    _ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage_default_instance_;
class ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment;
struct ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegmentDefaultTypeInternal;
extern ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegmentDefaultTypeInternal
    _ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment_default_instance_;
class ContentMetaData;
struct ContentMetaDataDefaultTypeInternal;
extern ContentMetaDataDefaultTypeInternal _ContentMetaData_default_instance_;
class ContentMetaData_PrintMetadata;
struct ContentMetaData_PrintMetadataDefaultTypeInternal;
extern ContentMetaData_PrintMetadataDefaultTypeInternal _ContentMetaData_PrintMetadata_default_instance_;
} // namespace enterprise_connectors
PROTOBUF_NAMESPACE_OPEN
template <>::enterprise_connectors::ClientMetadata* Arena::CreateMaybeMessage<::enterprise_connectors::ClientMetadata>(Arena*);
template <>::enterprise_connectors::ClientMetadata_Browser* Arena::CreateMaybeMessage<::enterprise_connectors::ClientMetadata_Browser>(Arena*);
template <>::enterprise_connectors::ClientMetadata_Device* Arena::CreateMaybeMessage<::enterprise_connectors::ClientMetadata_Device>(Arena*);
template <>::enterprise_connectors::ClientMetadata_Profile* Arena::CreateMaybeMessage<::enterprise_connectors::ClientMetadata_Profile>(Arena*);
template <>::enterprise_connectors::ContentAnalysisAcknowledgement* Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisAcknowledgement>(Arena*);
template <>::enterprise_connectors::ContentAnalysisRequest* Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisRequest>(Arena*);
template <>::enterprise_connectors::ContentAnalysisResponse* Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse>(Arena*);
template <>::enterprise_connectors::ContentAnalysisResponse_Result* Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse_Result>(Arena*);
template <>
::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage*
Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage>(Arena*);
template <>
::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule*
Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule>(Arena*);
template <>
::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage*
Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage>(Arena*);
template <>
::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment*
Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment>(Arena*);
template <>::enterprise_connectors::ContentMetaData* Arena::CreateMaybeMessage<::enterprise_connectors::ContentMetaData>(Arena*);
template <>::enterprise_connectors::ContentMetaData_PrintMetadata* Arena::CreateMaybeMessage<::enterprise_connectors::ContentMetaData_PrintMetadata>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace enterprise_connectors {

enum ContentMetaData_PrintMetadata_PrinterType : int {
    ContentMetaData_PrintMetadata_PrinterType_UNKNOWN = 0,
    ContentMetaData_PrintMetadata_PrinterType_CLOUD = 1,
    ContentMetaData_PrintMetadata_PrinterType_LOCAL = 2
};
bool ContentMetaData_PrintMetadata_PrinterType_IsValid(int value);
constexpr ContentMetaData_PrintMetadata_PrinterType ContentMetaData_PrintMetadata_PrinterType_PrinterType_MIN
    = ContentMetaData_PrintMetadata_PrinterType_UNKNOWN;
constexpr ContentMetaData_PrintMetadata_PrinterType ContentMetaData_PrintMetadata_PrinterType_PrinterType_MAX = ContentMetaData_PrintMetadata_PrinterType_LOCAL;
constexpr int ContentMetaData_PrintMetadata_PrinterType_PrinterType_ARRAYSIZE = ContentMetaData_PrintMetadata_PrinterType_PrinterType_MAX + 1;

const std::string& ContentMetaData_PrintMetadata_PrinterType_Name(ContentMetaData_PrintMetadata_PrinterType value);
template <typename T> inline const std::string& ContentMetaData_PrintMetadata_PrinterType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ContentMetaData_PrintMetadata_PrinterType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ContentMetaData_PrintMetadata_PrinterType_Name.");
    return ContentMetaData_PrintMetadata_PrinterType_Name(static_cast<ContentMetaData_PrintMetadata_PrinterType>(enum_t_value));
}
bool ContentMetaData_PrintMetadata_PrinterType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentMetaData_PrintMetadata_PrinterType* value);
enum ContentAnalysisRequest_Reason : int {
    ContentAnalysisRequest_Reason_UNKNOWN = 0,
    ContentAnalysisRequest_Reason_CLIPBOARD_PASTE = 1,
    ContentAnalysisRequest_Reason_DRAG_AND_DROP = 2,
    ContentAnalysisRequest_Reason_FILE_PICKER_DIALOG = 3,
    ContentAnalysisRequest_Reason_PRINT_PREVIEW_PRINT = 4,
    ContentAnalysisRequest_Reason_SYSTEM_DIALOG_PRINT = 5,
    ContentAnalysisRequest_Reason_NORMAL_DOWNLOAD = 6,
    ContentAnalysisRequest_Reason_SAVE_AS_DOWNLOAD = 7
};
bool ContentAnalysisRequest_Reason_IsValid(int value);
constexpr ContentAnalysisRequest_Reason ContentAnalysisRequest_Reason_Reason_MIN = ContentAnalysisRequest_Reason_UNKNOWN;
constexpr ContentAnalysisRequest_Reason ContentAnalysisRequest_Reason_Reason_MAX = ContentAnalysisRequest_Reason_SAVE_AS_DOWNLOAD;
constexpr int ContentAnalysisRequest_Reason_Reason_ARRAYSIZE = ContentAnalysisRequest_Reason_Reason_MAX + 1;

const std::string& ContentAnalysisRequest_Reason_Name(ContentAnalysisRequest_Reason value);
template <typename T> inline const std::string& ContentAnalysisRequest_Reason_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ContentAnalysisRequest_Reason>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ContentAnalysisRequest_Reason_Name.");
    return ContentAnalysisRequest_Reason_Name(static_cast<ContentAnalysisRequest_Reason>(enum_t_value));
}
bool ContentAnalysisRequest_Reason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisRequest_Reason* value);
enum ContentAnalysisResponse_Result_TriggeredRule_Action : int {
    ContentAnalysisResponse_Result_TriggeredRule_Action_ACTION_UNSPECIFIED = 0,
    ContentAnalysisResponse_Result_TriggeredRule_Action_REPORT_ONLY = 1,
    ContentAnalysisResponse_Result_TriggeredRule_Action_WARN = 2,
    ContentAnalysisResponse_Result_TriggeredRule_Action_BLOCK = 3
};
bool ContentAnalysisResponse_Result_TriggeredRule_Action_IsValid(int value);
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule_Action_Action_MIN
    = ContentAnalysisResponse_Result_TriggeredRule_Action_ACTION_UNSPECIFIED;
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule_Action_Action_MAX
    = ContentAnalysisResponse_Result_TriggeredRule_Action_BLOCK;
constexpr int ContentAnalysisResponse_Result_TriggeredRule_Action_Action_ARRAYSIZE = ContentAnalysisResponse_Result_TriggeredRule_Action_Action_MAX + 1;

const std::string& ContentAnalysisResponse_Result_TriggeredRule_Action_Name(ContentAnalysisResponse_Result_TriggeredRule_Action value);
template <typename T> inline const std::string& ContentAnalysisResponse_Result_TriggeredRule_Action_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ContentAnalysisResponse_Result_TriggeredRule_Action>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ContentAnalysisResponse_Result_TriggeredRule_Action_Name.");
    return ContentAnalysisResponse_Result_TriggeredRule_Action_Name(static_cast<ContentAnalysisResponse_Result_TriggeredRule_Action>(enum_t_value));
}
bool ContentAnalysisResponse_Result_TriggeredRule_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisResponse_Result_TriggeredRule_Action* value);
enum ContentAnalysisResponse_Result_Status : int {
    ContentAnalysisResponse_Result_Status_STATUS_UNKNOWN = 0,
    ContentAnalysisResponse_Result_Status_SUCCESS = 1,
    ContentAnalysisResponse_Result_Status_FAILURE = 2
};
bool ContentAnalysisResponse_Result_Status_IsValid(int value);
constexpr ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result_Status_Status_MIN = ContentAnalysisResponse_Result_Status_STATUS_UNKNOWN;
constexpr ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result_Status_Status_MAX = ContentAnalysisResponse_Result_Status_FAILURE;
constexpr int ContentAnalysisResponse_Result_Status_Status_ARRAYSIZE = ContentAnalysisResponse_Result_Status_Status_MAX + 1;

const std::string& ContentAnalysisResponse_Result_Status_Name(ContentAnalysisResponse_Result_Status value);
template <typename T> inline const std::string& ContentAnalysisResponse_Result_Status_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ContentAnalysisResponse_Result_Status>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ContentAnalysisResponse_Result_Status_Name.");
    return ContentAnalysisResponse_Result_Status_Name(static_cast<ContentAnalysisResponse_Result_Status>(enum_t_value));
}
bool ContentAnalysisResponse_Result_Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisResponse_Result_Status* value);
enum ContentAnalysisResponse_Result_StatusErrorMessage : int {
    ContentAnalysisResponse_Result_StatusErrorMessage_STATUS_ERROR_MESSAGE_UNSPECIFIED = 0,
    ContentAnalysisResponse_Result_StatusErrorMessage_DECRYPTION_FAILED = 1
};
bool ContentAnalysisResponse_Result_StatusErrorMessage_IsValid(int value);
constexpr ContentAnalysisResponse_Result_StatusErrorMessage ContentAnalysisResponse_Result_StatusErrorMessage_StatusErrorMessage_MIN
    = ContentAnalysisResponse_Result_StatusErrorMessage_STATUS_ERROR_MESSAGE_UNSPECIFIED;
constexpr ContentAnalysisResponse_Result_StatusErrorMessage ContentAnalysisResponse_Result_StatusErrorMessage_StatusErrorMessage_MAX
    = ContentAnalysisResponse_Result_StatusErrorMessage_DECRYPTION_FAILED;
constexpr int ContentAnalysisResponse_Result_StatusErrorMessage_StatusErrorMessage_ARRAYSIZE
    = ContentAnalysisResponse_Result_StatusErrorMessage_StatusErrorMessage_MAX + 1;

const std::string& ContentAnalysisResponse_Result_StatusErrorMessage_Name(ContentAnalysisResponse_Result_StatusErrorMessage value);
template <typename T> inline const std::string& ContentAnalysisResponse_Result_StatusErrorMessage_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ContentAnalysisResponse_Result_StatusErrorMessage>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ContentAnalysisResponse_Result_StatusErrorMessage_Name.");
    return ContentAnalysisResponse_Result_StatusErrorMessage_Name(static_cast<ContentAnalysisResponse_Result_StatusErrorMessage>(enum_t_value));
}
bool ContentAnalysisResponse_Result_StatusErrorMessage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisResponse_Result_StatusErrorMessage* value);
enum ContentAnalysisAcknowledgement_Status : int {
    ContentAnalysisAcknowledgement_Status_SUCCESS = 1,
    ContentAnalysisAcknowledgement_Status_INVALID_RESPONSE = 2,
    ContentAnalysisAcknowledgement_Status_TOO_LATE = 3
};
bool ContentAnalysisAcknowledgement_Status_IsValid(int value);
constexpr ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement_Status_Status_MIN = ContentAnalysisAcknowledgement_Status_SUCCESS;
constexpr ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement_Status_Status_MAX = ContentAnalysisAcknowledgement_Status_TOO_LATE;
constexpr int ContentAnalysisAcknowledgement_Status_Status_ARRAYSIZE = ContentAnalysisAcknowledgement_Status_Status_MAX + 1;

const std::string& ContentAnalysisAcknowledgement_Status_Name(ContentAnalysisAcknowledgement_Status value);
template <typename T> inline const std::string& ContentAnalysisAcknowledgement_Status_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ContentAnalysisAcknowledgement_Status>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ContentAnalysisAcknowledgement_Status_Name.");
    return ContentAnalysisAcknowledgement_Status_Name(static_cast<ContentAnalysisAcknowledgement_Status>(enum_t_value));
}
bool ContentAnalysisAcknowledgement_Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisAcknowledgement_Status* value);
enum ContentAnalysisAcknowledgement_FinalAction : int {
    ContentAnalysisAcknowledgement_FinalAction_ACTION_UNSPECIFIED = 0,
    ContentAnalysisAcknowledgement_FinalAction_ALLOW = 1,
    ContentAnalysisAcknowledgement_FinalAction_REPORT_ONLY = 2,
    ContentAnalysisAcknowledgement_FinalAction_WARN = 3,
    ContentAnalysisAcknowledgement_FinalAction_BLOCK = 4
};
bool ContentAnalysisAcknowledgement_FinalAction_IsValid(int value);
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement_FinalAction_FinalAction_MIN
    = ContentAnalysisAcknowledgement_FinalAction_ACTION_UNSPECIFIED;
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement_FinalAction_FinalAction_MAX
    = ContentAnalysisAcknowledgement_FinalAction_BLOCK;
constexpr int ContentAnalysisAcknowledgement_FinalAction_FinalAction_ARRAYSIZE = ContentAnalysisAcknowledgement_FinalAction_FinalAction_MAX + 1;

const std::string& ContentAnalysisAcknowledgement_FinalAction_Name(ContentAnalysisAcknowledgement_FinalAction value);
template <typename T> inline const std::string& ContentAnalysisAcknowledgement_FinalAction_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ContentAnalysisAcknowledgement_FinalAction>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ContentAnalysisAcknowledgement_FinalAction_Name.");
    return ContentAnalysisAcknowledgement_FinalAction_Name(static_cast<ContentAnalysisAcknowledgement_FinalAction>(enum_t_value));
}
bool ContentAnalysisAcknowledgement_FinalAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisAcknowledgement_FinalAction* value);
enum AnalysisConnector : int { ANALYSIS_CONNECTOR_UNSPECIFIED = 0, FILE_DOWNLOADED = 1, FILE_ATTACHED = 2, BULK_DATA_ENTRY = 3, PRINT = 4, FILE_TRANSFER = 5 };
bool AnalysisConnector_IsValid(int value);
constexpr AnalysisConnector AnalysisConnector_MIN = ANALYSIS_CONNECTOR_UNSPECIFIED;
constexpr AnalysisConnector AnalysisConnector_MAX = FILE_TRANSFER;
constexpr int AnalysisConnector_ARRAYSIZE = AnalysisConnector_MAX + 1;

const std::string& AnalysisConnector_Name(AnalysisConnector value);
template <typename T> inline const std::string& AnalysisConnector_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AnalysisConnector>::value || ::std::is_integral<T>::value, "Incorrect type passed to function AnalysisConnector_Name.");
    return AnalysisConnector_Name(static_cast<AnalysisConnector>(enum_t_value));
}
bool AnalysisConnector_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AnalysisConnector* value);
// ===================================================================

class ContentMetaData_PrintMetadata final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_connectors.ContentMetaData.PrintMetadata) */ {
public:
    inline ContentMetaData_PrintMetadata()
        : ContentMetaData_PrintMetadata(nullptr)
    {
    }
    ~ContentMetaData_PrintMetadata() override;
    explicit PROTOBUF_CONSTEXPR ContentMetaData_PrintMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ContentMetaData_PrintMetadata(const ContentMetaData_PrintMetadata& from);
    ContentMetaData_PrintMetadata(ContentMetaData_PrintMetadata&& from) noexcept
        : ContentMetaData_PrintMetadata()
    {
        *this = ::std::move(from);
    }

    inline ContentMetaData_PrintMetadata& operator=(const ContentMetaData_PrintMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ContentMetaData_PrintMetadata& operator=(ContentMetaData_PrintMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ContentMetaData_PrintMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ContentMetaData_PrintMetadata* internal_default_instance()
    {
        return reinterpret_cast<const ContentMetaData_PrintMetadata*>(&_ContentMetaData_PrintMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(ContentMetaData_PrintMetadata& a, ContentMetaData_PrintMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ContentMetaData_PrintMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ContentMetaData_PrintMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ContentMetaData_PrintMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ContentMetaData_PrintMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ContentMetaData_PrintMetadata& from);
    void MergeFrom(const ContentMetaData_PrintMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ContentMetaData_PrintMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "enterprise_connectors.ContentMetaData.PrintMetadata";
    }

protected:
    explicit ContentMetaData_PrintMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ContentMetaData_PrintMetadata_PrinterType PrinterType;
    static constexpr PrinterType UNKNOWN = ContentMetaData_PrintMetadata_PrinterType_UNKNOWN;
    static constexpr PrinterType CLOUD = ContentMetaData_PrintMetadata_PrinterType_CLOUD;
    static constexpr PrinterType LOCAL = ContentMetaData_PrintMetadata_PrinterType_LOCAL;
    static inline bool PrinterType_IsValid(int value)
    {
        return ContentMetaData_PrintMetadata_PrinterType_IsValid(value);
    }
    static constexpr PrinterType PrinterType_MIN = ContentMetaData_PrintMetadata_PrinterType_PrinterType_MIN;
    static constexpr PrinterType PrinterType_MAX = ContentMetaData_PrintMetadata_PrinterType_PrinterType_MAX;
    static constexpr int PrinterType_ARRAYSIZE = ContentMetaData_PrintMetadata_PrinterType_PrinterType_ARRAYSIZE;
    template <typename T> static inline const std::string& PrinterType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, PrinterType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function PrinterType_Name.");
        return ContentMetaData_PrintMetadata_PrinterType_Name(enum_t_value);
    }
    static inline bool PrinterType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrinterType* value)
    {
        return ContentMetaData_PrintMetadata_PrinterType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kPrinterNameFieldNumber = 1,
        kPrinterTypeFieldNumber = 2,
    };
    // optional string printer_name = 1;
    bool has_printer_name() const;

private:
    bool _internal_has_printer_name() const;

public:
    void clear_printer_name();
    const std::string& printer_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_printer_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_printer_name();
    PROTOBUF_NODISCARD std::string* release_printer_name();
    void set_allocated_printer_name(std::string* printer_name);

private:
    const std::string& _internal_printer_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_printer_name(const std::string& value);
    std::string* _internal_mutable_printer_name();

public:
    // optional .enterprise_connectors.ContentMetaData.PrintMetadata.PrinterType printer_type = 2;
    bool has_printer_type() const;

private:
    bool _internal_has_printer_type() const;

public:
    void clear_printer_type();
    ::enterprise_connectors::ContentMetaData_PrintMetadata_PrinterType printer_type() const;
    void set_printer_type(::enterprise_connectors::ContentMetaData_PrintMetadata_PrinterType value);

private:
    ::enterprise_connectors::ContentMetaData_PrintMetadata_PrinterType _internal_printer_type() const;
    void _internal_set_printer_type(::enterprise_connectors::ContentMetaData_PrintMetadata_PrinterType value);

public:
    // @@protoc_insertion_point(class_scope:enterprise_connectors.ContentMetaData.PrintMetadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr printer_name_;
        int printer_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto;
};
// -------------------------------------------------------------------

class ContentMetaData final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_connectors.ContentMetaData) */ {
public:
    inline ContentMetaData()
        : ContentMetaData(nullptr)
    {
    }
    ~ContentMetaData() override;
    explicit PROTOBUF_CONSTEXPR ContentMetaData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ContentMetaData(const ContentMetaData& from);
    ContentMetaData(ContentMetaData&& from) noexcept
        : ContentMetaData()
    {
        *this = ::std::move(from);
    }

    inline ContentMetaData& operator=(const ContentMetaData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ContentMetaData& operator=(ContentMetaData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ContentMetaData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ContentMetaData* internal_default_instance()
    {
        return reinterpret_cast<const ContentMetaData*>(&_ContentMetaData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(ContentMetaData& a, ContentMetaData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ContentMetaData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ContentMetaData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ContentMetaData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ContentMetaData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ContentMetaData& from);
    void MergeFrom(const ContentMetaData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ContentMetaData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "enterprise_connectors.ContentMetaData";
    }

protected:
    explicit ContentMetaData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ContentMetaData_PrintMetadata PrintMetadata;

    // accessors -------------------------------------------------------

    enum : int {
        kUrlFieldNumber = 1,
        kFilenameFieldNumber = 2,
        kDigestFieldNumber = 3,
        kEmailFieldNumber = 5,
        kContentTypeFieldNumber = 6,
        kSourceFieldNumber = 7,
        kDestinationFieldNumber = 8,
        kTabTitleFieldNumber = 9,
        kTabUrlFieldNumber = 10,
        kDecryptionKeyFieldNumber = 12,
        kCsdFieldNumber = 4,
        kPrintMetadataFieldNumber = 11,
    };
    // optional string url = 1;
    bool has_url() const;

private:
    bool _internal_has_url() const;

public:
    void clear_url();
    const std::string& url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url();
    PROTOBUF_NODISCARD std::string* release_url();
    void set_allocated_url(std::string* url);

private:
    const std::string& _internal_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
    std::string* _internal_mutable_url();

public:
    // optional string filename = 2;
    bool has_filename() const;

private:
    bool _internal_has_filename() const;

public:
    void clear_filename();
    const std::string& filename() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_filename(ArgT0&& arg0, ArgT... args);
    std::string* mutable_filename();
    PROTOBUF_NODISCARD std::string* release_filename();
    void set_allocated_filename(std::string* filename);

private:
    const std::string& _internal_filename() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
    std::string* _internal_mutable_filename();

public:
    // optional string digest = 3;
    bool has_digest() const;

private:
    bool _internal_has_digest() const;

public:
    void clear_digest();
    const std::string& digest() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_digest(ArgT0&& arg0, ArgT... args);
    std::string* mutable_digest();
    PROTOBUF_NODISCARD std::string* release_digest();
    void set_allocated_digest(std::string* digest);

private:
    const std::string& _internal_digest() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
    std::string* _internal_mutable_digest();

public:
    // optional string email = 5;
    bool has_email() const;

private:
    bool _internal_has_email() const;

public:
    void clear_email();
    const std::string& email() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_email(ArgT0&& arg0, ArgT... args);
    std::string* mutable_email();
    PROTOBUF_NODISCARD std::string* release_email();
    void set_allocated_email(std::string* email);

private:
    const std::string& _internal_email() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
    std::string* _internal_mutable_email();

public:
    // optional string content_type = 6;
    bool has_content_type() const;

private:
    bool _internal_has_content_type() const;

public:
    void clear_content_type();
    const std::string& content_type() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_content_type(ArgT0&& arg0, ArgT... args);
    std::string* mutable_content_type();
    PROTOBUF_NODISCARD std::string* release_content_type();
    void set_allocated_content_type(std::string* content_type);

private:
    const std::string& _internal_content_type() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_type(const std::string& value);
    std::string* _internal_mutable_content_type();

public:
    // optional string source = 7;
    bool has_source() const;

private:
    bool _internal_has_source() const;

public:
    void clear_source();
    const std::string& source() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_source(ArgT0&& arg0, ArgT... args);
    std::string* mutable_source();
    PROTOBUF_NODISCARD std::string* release_source();
    void set_allocated_source(std::string* source);

private:
    const std::string& _internal_source() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(const std::string& value);
    std::string* _internal_mutable_source();

public:
    // optional string destination = 8;
    bool has_destination() const;

private:
    bool _internal_has_destination() const;

public:
    void clear_destination();
    const std::string& destination() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_destination(ArgT0&& arg0, ArgT... args);
    std::string* mutable_destination();
    PROTOBUF_NODISCARD std::string* release_destination();
    void set_allocated_destination(std::string* destination);

private:
    const std::string& _internal_destination() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(const std::string& value);
    std::string* _internal_mutable_destination();

public:
    // optional string tab_title = 9;
    bool has_tab_title() const;

private:
    bool _internal_has_tab_title() const;

public:
    void clear_tab_title();
    const std::string& tab_title() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_tab_title(ArgT0&& arg0, ArgT... args);
    std::string* mutable_tab_title();
    PROTOBUF_NODISCARD std::string* release_tab_title();
    void set_allocated_tab_title(std::string* tab_title);

private:
    const std::string& _internal_tab_title() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_tab_title(const std::string& value);
    std::string* _internal_mutable_tab_title();

public:
    // optional string tab_url = 10;
    bool has_tab_url() const;

private:
    bool _internal_has_tab_url() const;

public:
    void clear_tab_url();
    const std::string& tab_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_tab_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_tab_url();
    PROTOBUF_NODISCARD std::string* release_tab_url();
    void set_allocated_tab_url(std::string* tab_url);

private:
    const std::string& _internal_tab_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_tab_url(const std::string& value);
    std::string* _internal_mutable_tab_url();

public:
    // optional bytes decryption_key = 12;
    bool has_decryption_key() const;

private:
    bool _internal_has_decryption_key() const;

public:
    void clear_decryption_key();
    const std::string& decryption_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_decryption_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_decryption_key();
    PROTOBUF_NODISCARD std::string* release_decryption_key();
    void set_allocated_decryption_key(std::string* decryption_key);

private:
    const std::string& _internal_decryption_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_decryption_key(const std::string& value);
    std::string* _internal_mutable_decryption_key();

public:
    // optional .safe_browsing.ClientDownloadRequest csd = 4;
    bool has_csd() const;

private:
    bool _internal_has_csd() const;

public:
    void clear_csd();
    const ::safe_browsing::ClientDownloadRequest& csd() const;
    PROTOBUF_NODISCARD ::safe_browsing::ClientDownloadRequest* release_csd();
    ::safe_browsing::ClientDownloadRequest* mutable_csd();
    void set_allocated_csd(::safe_browsing::ClientDownloadRequest* csd);

private:
    const ::safe_browsing::ClientDownloadRequest& _internal_csd() const;
    ::safe_browsing::ClientDownloadRequest* _internal_mutable_csd();

public:
    void unsafe_arena_set_allocated_csd(::safe_browsing::ClientDownloadRequest* csd);
    ::safe_browsing::ClientDownloadRequest* unsafe_arena_release_csd();

    // optional .enterprise_connectors.ContentMetaData.PrintMetadata print_metadata = 11;
    bool has_print_metadata() const;

private:
    bool _internal_has_print_metadata() const;

public:
    void clear_print_metadata();
    const ::enterprise_connectors::ContentMetaData_PrintMetadata& print_metadata() const;
    PROTOBUF_NODISCARD ::enterprise_connectors::ContentMetaData_PrintMetadata* release_print_metadata();
    ::enterprise_connectors::ContentMetaData_PrintMetadata* mutable_print_metadata();
    void set_allocated_print_metadata(::enterprise_connectors::ContentMetaData_PrintMetadata* print_metadata);

private:
    const ::enterprise_connectors::ContentMetaData_PrintMetadata& _internal_print_metadata() const;
    ::enterprise_connectors::ContentMetaData_PrintMetadata* _internal_mutable_print_metadata();

public:
    void unsafe_arena_set_allocated_print_metadata(::enterprise_connectors::ContentMetaData_PrintMetadata* print_metadata);
    ::enterprise_connectors::ContentMetaData_PrintMetadata* unsafe_arena_release_print_metadata();

    // @@protoc_insertion_point(class_scope:enterprise_connectors.ContentMetaData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_type_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tab_title_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tab_url_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr decryption_key_;
        ::safe_browsing::ClientDownloadRequest* csd_;
        ::enterprise_connectors::ContentMetaData_PrintMetadata* print_metadata_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto;
};
// -------------------------------------------------------------------

class ClientMetadata_Browser final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_connectors.ClientMetadata.Browser) */ {
public:
    inline ClientMetadata_Browser()
        : ClientMetadata_Browser(nullptr)
    {
    }
    ~ClientMetadata_Browser() override;
    explicit PROTOBUF_CONSTEXPR ClientMetadata_Browser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ClientMetadata_Browser(const ClientMetadata_Browser& from);
    ClientMetadata_Browser(ClientMetadata_Browser&& from) noexcept
        : ClientMetadata_Browser()
    {
        *this = ::std::move(from);
    }

    inline ClientMetadata_Browser& operator=(const ClientMetadata_Browser& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ClientMetadata_Browser& operator=(ClientMetadata_Browser&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ClientMetadata_Browser& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ClientMetadata_Browser* internal_default_instance()
    {
        return reinterpret_cast<const ClientMetadata_Browser*>(&_ClientMetadata_Browser_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(ClientMetadata_Browser& a, ClientMetadata_Browser& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ClientMetadata_Browser* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ClientMetadata_Browser* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ClientMetadata_Browser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ClientMetadata_Browser>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ClientMetadata_Browser& from);
    void MergeFrom(const ClientMetadata_Browser& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ClientMetadata_Browser* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "enterprise_connectors.ClientMetadata.Browser";
    }

protected:
    explicit ClientMetadata_Browser(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kBrowserIdFieldNumber = 1,
        kUserAgentFieldNumber = 2,
        kChromeVersionFieldNumber = 3,
        kMachineUserFieldNumber = 4,
    };
    // optional string browser_id = 1;
    bool has_browser_id() const;

private:
    bool _internal_has_browser_id() const;

public:
    void clear_browser_id();
    const std::string& browser_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_browser_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_browser_id();
    PROTOBUF_NODISCARD std::string* release_browser_id();
    void set_allocated_browser_id(std::string* browser_id);

private:
    const std::string& _internal_browser_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser_id(const std::string& value);
    std::string* _internal_mutable_browser_id();

public:
    // optional string user_agent = 2;
    bool has_user_agent() const;

private:
    bool _internal_has_user_agent() const;

public:
    void clear_user_agent();
    const std::string& user_agent() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_user_agent(ArgT0&& arg0, ArgT... args);
    std::string* mutable_user_agent();
    PROTOBUF_NODISCARD std::string* release_user_agent();
    void set_allocated_user_agent(std::string* user_agent);

private:
    const std::string& _internal_user_agent() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_agent(const std::string& value);
    std::string* _internal_mutable_user_agent();

public:
    // optional string chrome_version = 3;
    bool has_chrome_version() const;

private:
    bool _internal_has_chrome_version() const;

public:
    void clear_chrome_version();
    const std::string& chrome_version() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_chrome_version(ArgT0&& arg0, ArgT... args);
    std::string* mutable_chrome_version();
    PROTOBUF_NODISCARD std::string* release_chrome_version();
    void set_allocated_chrome_version(std::string* chrome_version);

private:
    const std::string& _internal_chrome_version() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_chrome_version(const std::string& value);
    std::string* _internal_mutable_chrome_version();

public:
    // optional string machine_user = 4;
    bool has_machine_user() const;

private:
    bool _internal_has_machine_user() const;

public:
    void clear_machine_user();
    const std::string& machine_user() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_machine_user(ArgT0&& arg0, ArgT... args);
    std::string* mutable_machine_user();
    PROTOBUF_NODISCARD std::string* release_machine_user();
    void set_allocated_machine_user(std::string* machine_user);

private:
    const std::string& _internal_machine_user() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_user(const std::string& value);
    std::string* _internal_mutable_machine_user();

public:
    // @@protoc_insertion_point(class_scope:enterprise_connectors.ClientMetadata.Browser)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_agent_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chrome_version_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_user_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto;
};
// -------------------------------------------------------------------

class ClientMetadata_Device final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_connectors.ClientMetadata.Device) */ {
public:
    inline ClientMetadata_Device()
        : ClientMetadata_Device(nullptr)
    {
    }
    ~ClientMetadata_Device() override;
    explicit PROTOBUF_CONSTEXPR ClientMetadata_Device(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ClientMetadata_Device(const ClientMetadata_Device& from);
    ClientMetadata_Device(ClientMetadata_Device&& from) noexcept
        : ClientMetadata_Device()
    {
        *this = ::std::move(from);
    }

    inline ClientMetadata_Device& operator=(const ClientMetadata_Device& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ClientMetadata_Device& operator=(ClientMetadata_Device&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ClientMetadata_Device& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ClientMetadata_Device* internal_default_instance()
    {
        return reinterpret_cast<const ClientMetadata_Device*>(&_ClientMetadata_Device_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(ClientMetadata_Device& a, ClientMetadata_Device& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ClientMetadata_Device* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ClientMetadata_Device* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ClientMetadata_Device* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ClientMetadata_Device>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ClientMetadata_Device& from);
    void MergeFrom(const ClientMetadata_Device& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ClientMetadata_Device* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "enterprise_connectors.ClientMetadata.Device";
    }

protected:
    explicit ClientMetadata_Device(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDmTokenFieldNumber = 1,
        kClientIdFieldNumber = 2,
        kOsVersionFieldNumber = 3,
        kOsPlatformFieldNumber = 4,
        kNameFieldNumber = 5,
    };
    // optional string dm_token = 1;
    bool has_dm_token() const;

private:
    bool _internal_has_dm_token() const;

public:
    void clear_dm_token();
    const std::string& dm_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_dm_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_dm_token();
    PROTOBUF_NODISCARD std::string* release_dm_token();
    void set_allocated_dm_token(std::string* dm_token);

private:
    const std::string& _internal_dm_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_dm_token(const std::string& value);
    std::string* _internal_mutable_dm_token();

public:
    // optional string client_id = 2;
    bool has_client_id() const;

private:
    bool _internal_has_client_id() const;

public:
    void clear_client_id();
    const std::string& client_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_client_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_client_id();
    PROTOBUF_NODISCARD std::string* release_client_id();
    void set_allocated_client_id(std::string* client_id);

private:
    const std::string& _internal_client_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
    std::string* _internal_mutable_client_id();

public:
    // optional string os_version = 3;
    bool has_os_version() const;

private:
    bool _internal_has_os_version() const;

public:
    void clear_os_version();
    const std::string& os_version() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_os_version(ArgT0&& arg0, ArgT... args);
    std::string* mutable_os_version();
    PROTOBUF_NODISCARD std::string* release_os_version();
    void set_allocated_os_version(std::string* os_version);

private:
    const std::string& _internal_os_version() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_version(const std::string& value);
    std::string* _internal_mutable_os_version();

public:
    // optional string os_platform = 4;
    bool has_os_platform() const;

private:
    bool _internal_has_os_platform() const;

public:
    void clear_os_platform();
    const std::string& os_platform() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_os_platform(ArgT0&& arg0, ArgT... args);
    std::string* mutable_os_platform();
    PROTOBUF_NODISCARD std::string* release_os_platform();
    void set_allocated_os_platform(std::string* os_platform);

private:
    const std::string& _internal_os_platform() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_os_platform(const std::string& value);
    std::string* _internal_mutable_os_platform();

public:
    // optional string name = 5;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // @@protoc_insertion_point(class_scope:enterprise_connectors.ClientMetadata.Device)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dm_token_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_version_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_platform_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto;
};
// -------------------------------------------------------------------

class ClientMetadata_Profile final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_connectors.ClientMetadata.Profile) */ {
public:
    inline ClientMetadata_Profile()
        : ClientMetadata_Profile(nullptr)
    {
    }
    ~ClientMetadata_Profile() override;
    explicit PROTOBUF_CONSTEXPR ClientMetadata_Profile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ClientMetadata_Profile(const ClientMetadata_Profile& from);
    ClientMetadata_Profile(ClientMetadata_Profile&& from) noexcept
        : ClientMetadata_Profile()
    {
        *this = ::std::move(from);
    }

    inline ClientMetadata_Profile& operator=(const ClientMetadata_Profile& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ClientMetadata_Profile& operator=(ClientMetadata_Profile&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ClientMetadata_Profile& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ClientMetadata_Profile* internal_default_instance()
    {
        return reinterpret_cast<const ClientMetadata_Profile*>(&_ClientMetadata_Profile_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(ClientMetadata_Profile& a, ClientMetadata_Profile& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ClientMetadata_Profile* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ClientMetadata_Profile* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ClientMetadata_Profile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ClientMetadata_Profile>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ClientMetadata_Profile& from);
    void MergeFrom(const ClientMetadata_Profile& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ClientMetadata_Profile* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "enterprise_connectors.ClientMetadata.Profile";
    }

protected:
    explicit ClientMetadata_Profile(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDmTokenFieldNumber = 1,
        kGaiaEmailFieldNumber = 2,
        kProfilePathFieldNumber = 3,
        kProfileNameFieldNumber = 4,
        kClientIdFieldNumber = 5,
    };
    // optional string dm_token = 1;
    bool has_dm_token() const;

private:
    bool _internal_has_dm_token() const;

public:
    void clear_dm_token();
    const std::string& dm_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_dm_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_dm_token();
    PROTOBUF_NODISCARD std::string* release_dm_token();
    void set_allocated_dm_token(std::string* dm_token);

private:
    const std::string& _internal_dm_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_dm_token(const std::string& value);
    std::string* _internal_mutable_dm_token();

public:
    // optional string gaia_email = 2;
    bool has_gaia_email() const;

private:
    bool _internal_has_gaia_email() const;

public:
    void clear_gaia_email();
    const std::string& gaia_email() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_gaia_email(ArgT0&& arg0, ArgT... args);
    std::string* mutable_gaia_email();
    PROTOBUF_NODISCARD std::string* release_gaia_email();
    void set_allocated_gaia_email(std::string* gaia_email);

private:
    const std::string& _internal_gaia_email() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_gaia_email(const std::string& value);
    std::string* _internal_mutable_gaia_email();

public:
    // optional string profile_path = 3;
    bool has_profile_path() const;

private:
    bool _internal_has_profile_path() const;

public:
    void clear_profile_path();
    const std::string& profile_path() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_profile_path(ArgT0&& arg0, ArgT... args);
    std::string* mutable_profile_path();
    PROTOBUF_NODISCARD std::string* release_profile_path();
    void set_allocated_profile_path(std::string* profile_path);

private:
    const std::string& _internal_profile_path() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_profile_path(const std::string& value);
    std::string* _internal_mutable_profile_path();

public:
    // optional string profile_name = 4;
    bool has_profile_name() const;

private:
    bool _internal_has_profile_name() const;

public:
    void clear_profile_name();
    const std::string& profile_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_profile_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_profile_name();
    PROTOBUF_NODISCARD std::string* release_profile_name();
    void set_allocated_profile_name(std::string* profile_name);

private:
    const std::string& _internal_profile_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_profile_name(const std::string& value);
    std::string* _internal_mutable_profile_name();

public:
    // optional string client_id = 5;
    bool has_client_id() const;

private:
    bool _internal_has_client_id() const;

public:
    void clear_client_id();
    const std::string& client_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_client_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_client_id();
    PROTOBUF_NODISCARD std::string* release_client_id();
    void set_allocated_client_id(std::string* client_id);

private:
    const std::string& _internal_client_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
    std::string* _internal_mutable_client_id();

public:
    // @@protoc_insertion_point(class_scope:enterprise_connectors.ClientMetadata.Profile)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dm_token_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gaia_email_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profile_path_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profile_name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto;
};
// -------------------------------------------------------------------

class ClientMetadata final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_connectors.ClientMetadata) */ {
public:
    inline ClientMetadata()
        : ClientMetadata(nullptr)
    {
    }
    ~ClientMetadata() override;
    explicit PROTOBUF_CONSTEXPR ClientMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ClientMetadata(const ClientMetadata& from);
    ClientMetadata(ClientMetadata&& from) noexcept
        : ClientMetadata()
    {
        *this = ::std::move(from);
    }

    inline ClientMetadata& operator=(const ClientMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ClientMetadata& operator=(ClientMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ClientMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ClientMetadata* internal_default_instance()
    {
        return reinterpret_cast<const ClientMetadata*>(&_ClientMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(ClientMetadata& a, ClientMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ClientMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ClientMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ClientMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ClientMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ClientMetadata& from);
    void MergeFrom(const ClientMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ClientMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "enterprise_connectors.ClientMetadata";
    }

protected:
    explicit ClientMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ClientMetadata_Browser Browser;
    typedef ClientMetadata_Device Device;
    typedef ClientMetadata_Profile Profile;

    // accessors -------------------------------------------------------

    enum : int {
        kBrowserFieldNumber = 1,
        kDeviceFieldNumber = 2,
        kProfileFieldNumber = 3,
        kIsChromeOsManagedGuestSessionFieldNumber = 4,
    };
    // optional .enterprise_connectors.ClientMetadata.Browser browser = 1;
    bool has_browser() const;

private:
    bool _internal_has_browser() const;

public:
    void clear_browser();
    const ::enterprise_connectors::ClientMetadata_Browser& browser() const;
    PROTOBUF_NODISCARD ::enterprise_connectors::ClientMetadata_Browser* release_browser();
    ::enterprise_connectors::ClientMetadata_Browser* mutable_browser();
    void set_allocated_browser(::enterprise_connectors::ClientMetadata_Browser* browser);

private:
    const ::enterprise_connectors::ClientMetadata_Browser& _internal_browser() const;
    ::enterprise_connectors::ClientMetadata_Browser* _internal_mutable_browser();

public:
    void unsafe_arena_set_allocated_browser(::enterprise_connectors::ClientMetadata_Browser* browser);
    ::enterprise_connectors::ClientMetadata_Browser* unsafe_arena_release_browser();

    // optional .enterprise_connectors.ClientMetadata.Device device = 2;
    bool has_device() const;

private:
    bool _internal_has_device() const;

public:
    void clear_device();
    const ::enterprise_connectors::ClientMetadata_Device& device() const;
    PROTOBUF_NODISCARD ::enterprise_connectors::ClientMetadata_Device* release_device();
    ::enterprise_connectors::ClientMetadata_Device* mutable_device();
    void set_allocated_device(::enterprise_connectors::ClientMetadata_Device* device);

private:
    const ::enterprise_connectors::ClientMetadata_Device& _internal_device() const;
    ::enterprise_connectors::ClientMetadata_Device* _internal_mutable_device();

public:
    void unsafe_arena_set_allocated_device(::enterprise_connectors::ClientMetadata_Device* device);
    ::enterprise_connectors::ClientMetadata_Device* unsafe_arena_release_device();

    // optional .enterprise_connectors.ClientMetadata.Profile profile = 3;
    bool has_profile() const;

private:
    bool _internal_has_profile() const;

public:
    void clear_profile();
    const ::enterprise_connectors::ClientMetadata_Profile& profile() const;
    PROTOBUF_NODISCARD ::enterprise_connectors::ClientMetadata_Profile* release_profile();
    ::enterprise_connectors::ClientMetadata_Profile* mutable_profile();
    void set_allocated_profile(::enterprise_connectors::ClientMetadata_Profile* profile);

private:
    const ::enterprise_connectors::ClientMetadata_Profile& _internal_profile() const;
    ::enterprise_connectors::ClientMetadata_Profile* _internal_mutable_profile();

public:
    void unsafe_arena_set_allocated_profile(::enterprise_connectors::ClientMetadata_Profile* profile);
    ::enterprise_connectors::ClientMetadata_Profile* unsafe_arena_release_profile();

    // optional bool is_chrome_os_managed_guest_session = 4;
    bool has_is_chrome_os_managed_guest_session() const;

private:
    bool _internal_has_is_chrome_os_managed_guest_session() const;

public:
    void clear_is_chrome_os_managed_guest_session();
    bool is_chrome_os_managed_guest_session() const;
    void set_is_chrome_os_managed_guest_session(bool value);

private:
    bool _internal_is_chrome_os_managed_guest_session() const;
    void _internal_set_is_chrome_os_managed_guest_session(bool value);

public:
    // @@protoc_insertion_point(class_scope:enterprise_connectors.ClientMetadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::enterprise_connectors::ClientMetadata_Browser* browser_;
        ::enterprise_connectors::ClientMetadata_Device* device_;
        ::enterprise_connectors::ClientMetadata_Profile* profile_;
        bool is_chrome_os_managed_guest_session_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisRequest final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_connectors.ContentAnalysisRequest) */ {
public:
    inline ContentAnalysisRequest()
        : ContentAnalysisRequest(nullptr)
    {
    }
    ~ContentAnalysisRequest() override;
    explicit PROTOBUF_CONSTEXPR ContentAnalysisRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ContentAnalysisRequest(const ContentAnalysisRequest& from);
    ContentAnalysisRequest(ContentAnalysisRequest&& from) noexcept
        : ContentAnalysisRequest()
    {
        *this = ::std::move(from);
    }

    inline ContentAnalysisRequest& operator=(const ContentAnalysisRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ContentAnalysisRequest& operator=(ContentAnalysisRequest&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ContentAnalysisRequest& default_instance()
    {
        return *internal_default_instance();
    }
    enum ContentDataCase {
        kTextContent = 13,
        kFilePath = 14,
        CONTENT_DATA_NOT_SET = 0,
    };

    static inline const ContentAnalysisRequest* internal_default_instance()
    {
        return reinterpret_cast<const ContentAnalysisRequest*>(&_ContentAnalysisRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(ContentAnalysisRequest& a, ContentAnalysisRequest& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ContentAnalysisRequest* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ContentAnalysisRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ContentAnalysisRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ContentAnalysisRequest>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ContentAnalysisRequest& from);
    void MergeFrom(const ContentAnalysisRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ContentAnalysisRequest* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "enterprise_connectors.ContentAnalysisRequest";
    }

protected:
    explicit ContentAnalysisRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ContentAnalysisRequest_Reason Reason;
    static constexpr Reason UNKNOWN = ContentAnalysisRequest_Reason_UNKNOWN;
    static constexpr Reason CLIPBOARD_PASTE = ContentAnalysisRequest_Reason_CLIPBOARD_PASTE;
    static constexpr Reason DRAG_AND_DROP = ContentAnalysisRequest_Reason_DRAG_AND_DROP;
    static constexpr Reason FILE_PICKER_DIALOG = ContentAnalysisRequest_Reason_FILE_PICKER_DIALOG;
    static constexpr Reason PRINT_PREVIEW_PRINT = ContentAnalysisRequest_Reason_PRINT_PREVIEW_PRINT;
    static constexpr Reason SYSTEM_DIALOG_PRINT = ContentAnalysisRequest_Reason_SYSTEM_DIALOG_PRINT;
    static constexpr Reason NORMAL_DOWNLOAD = ContentAnalysisRequest_Reason_NORMAL_DOWNLOAD;
    static constexpr Reason SAVE_AS_DOWNLOAD = ContentAnalysisRequest_Reason_SAVE_AS_DOWNLOAD;
    static inline bool Reason_IsValid(int value)
    {
        return ContentAnalysisRequest_Reason_IsValid(value);
    }
    static constexpr Reason Reason_MIN = ContentAnalysisRequest_Reason_Reason_MIN;
    static constexpr Reason Reason_MAX = ContentAnalysisRequest_Reason_Reason_MAX;
    static constexpr int Reason_ARRAYSIZE = ContentAnalysisRequest_Reason_Reason_ARRAYSIZE;
    template <typename T> static inline const std::string& Reason_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Reason>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Reason_Name.");
        return ContentAnalysisRequest_Reason_Name(enum_t_value);
    }
    static inline bool Reason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Reason* value)
    {
        return ContentAnalysisRequest_Reason_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kTagsFieldNumber = 11,
        kDeviceTokenFieldNumber = 1,
        kFcmNotificationTokenFieldNumber = 2,
        kRequestTokenFieldNumber = 5,
        kUserActionIdFieldNumber = 16,
        kRequestDataFieldNumber = 10,
        kClientMetadataFieldNumber = 12,
        kAnalysisConnectorFieldNumber = 9,
        kReasonFieldNumber = 19,
        kExpiresAtFieldNumber = 15,
        kUserActionRequestsCountFieldNumber = 17,
        kBlockingFieldNumber = 20,
        kRequireMetadataVerdictFieldNumber = 21,
        kTextContentFieldNumber = 13,
        kFilePathFieldNumber = 14,
    };
    // repeated string tags = 11;
    int tags_size() const;

private:
    int _internal_tags_size() const;

public:
    void clear_tags();
    const std::string& tags(int index) const;
    std::string* mutable_tags(int index);
    void set_tags(int index, const std::string& value);
    void set_tags(int index, std::string&& value);
    void set_tags(int index, const char* value);
    void set_tags(int index, const char* value, size_t size);
    std::string* add_tags();
    void add_tags(const std::string& value);
    void add_tags(std::string&& value);
    void add_tags(const char* value);
    void add_tags(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();

private:
    const std::string& _internal_tags(int index) const;
    std::string* _internal_add_tags();

public:
    // optional string device_token = 1;
    bool has_device_token() const;

private:
    bool _internal_has_device_token() const;

public:
    void clear_device_token();
    const std::string& device_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_device_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_device_token();
    PROTOBUF_NODISCARD std::string* release_device_token();
    void set_allocated_device_token(std::string* device_token);

private:
    const std::string& _internal_device_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_token(const std::string& value);
    std::string* _internal_mutable_device_token();

public:
    // optional string fcm_notification_token = 2;
    bool has_fcm_notification_token() const;

private:
    bool _internal_has_fcm_notification_token() const;

public:
    void clear_fcm_notification_token();
    const std::string& fcm_notification_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_fcm_notification_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_fcm_notification_token();
    PROTOBUF_NODISCARD std::string* release_fcm_notification_token();
    void set_allocated_fcm_notification_token(std::string* fcm_notification_token);

private:
    const std::string& _internal_fcm_notification_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_fcm_notification_token(const std::string& value);
    std::string* _internal_mutable_fcm_notification_token();

public:
    // optional string request_token = 5;
    bool has_request_token() const;

private:
    bool _internal_has_request_token() const;

public:
    void clear_request_token();
    const std::string& request_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_request_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_request_token();
    PROTOBUF_NODISCARD std::string* release_request_token();
    void set_allocated_request_token(std::string* request_token);

private:
    const std::string& _internal_request_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_token(const std::string& value);
    std::string* _internal_mutable_request_token();

public:
    // optional string user_action_id = 16;
    bool has_user_action_id() const;

private:
    bool _internal_has_user_action_id() const;

public:
    void clear_user_action_id();
    const std::string& user_action_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_user_action_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_user_action_id();
    PROTOBUF_NODISCARD std::string* release_user_action_id();
    void set_allocated_user_action_id(std::string* user_action_id);

private:
    const std::string& _internal_user_action_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_action_id(const std::string& value);
    std::string* _internal_mutable_user_action_id();

public:
    // optional .enterprise_connectors.ContentMetaData request_data = 10;
    bool has_request_data() const;

private:
    bool _internal_has_request_data() const;

public:
    void clear_request_data();
    const ::enterprise_connectors::ContentMetaData& request_data() const;
    PROTOBUF_NODISCARD ::enterprise_connectors::ContentMetaData* release_request_data();
    ::enterprise_connectors::ContentMetaData* mutable_request_data();
    void set_allocated_request_data(::enterprise_connectors::ContentMetaData* request_data);

private:
    const ::enterprise_connectors::ContentMetaData& _internal_request_data() const;
    ::enterprise_connectors::ContentMetaData* _internal_mutable_request_data();

public:
    void unsafe_arena_set_allocated_request_data(::enterprise_connectors::ContentMetaData* request_data);
    ::enterprise_connectors::ContentMetaData* unsafe_arena_release_request_data();

    // optional .enterprise_connectors.ClientMetadata client_metadata = 12;
    bool has_client_metadata() const;

private:
    bool _internal_has_client_metadata() const;

public:
    void clear_client_metadata();
    const ::enterprise_connectors::ClientMetadata& client_metadata() const;
    PROTOBUF_NODISCARD ::enterprise_connectors::ClientMetadata* release_client_metadata();
    ::enterprise_connectors::ClientMetadata* mutable_client_metadata();
    void set_allocated_client_metadata(::enterprise_connectors::ClientMetadata* client_metadata);

private:
    const ::enterprise_connectors::ClientMetadata& _internal_client_metadata() const;
    ::enterprise_connectors::ClientMetadata* _internal_mutable_client_metadata();

public:
    void unsafe_arena_set_allocated_client_metadata(::enterprise_connectors::ClientMetadata* client_metadata);
    ::enterprise_connectors::ClientMetadata* unsafe_arena_release_client_metadata();

    // optional .enterprise_connectors.AnalysisConnector analysis_connector = 9;
    bool has_analysis_connector() const;

private:
    bool _internal_has_analysis_connector() const;

public:
    void clear_analysis_connector();
    ::enterprise_connectors::AnalysisConnector analysis_connector() const;
    void set_analysis_connector(::enterprise_connectors::AnalysisConnector value);

private:
    ::enterprise_connectors::AnalysisConnector _internal_analysis_connector() const;
    void _internal_set_analysis_connector(::enterprise_connectors::AnalysisConnector value);

public:
    // optional .enterprise_connectors.ContentAnalysisRequest.Reason reason = 19;
    bool has_reason() const;

private:
    bool _internal_has_reason() const;

public:
    void clear_reason();
    ::enterprise_connectors::ContentAnalysisRequest_Reason reason() const;
    void set_reason(::enterprise_connectors::ContentAnalysisRequest_Reason value);

private:
    ::enterprise_connectors::ContentAnalysisRequest_Reason _internal_reason() const;
    void _internal_set_reason(::enterprise_connectors::ContentAnalysisRequest_Reason value);

public:
    // optional int64 expires_at = 15;
    bool has_expires_at() const;

private:
    bool _internal_has_expires_at() const;

public:
    void clear_expires_at();
    int64_t expires_at() const;
    void set_expires_at(int64_t value);

private:
    int64_t _internal_expires_at() const;
    void _internal_set_expires_at(int64_t value);

public:
    // optional int64 user_action_requests_count = 17;
    bool has_user_action_requests_count() const;

private:
    bool _internal_has_user_action_requests_count() const;

public:
    void clear_user_action_requests_count();
    int64_t user_action_requests_count() const;
    void set_user_action_requests_count(int64_t value);

private:
    int64_t _internal_user_action_requests_count() const;
    void _internal_set_user_action_requests_count(int64_t value);

public:
    // optional bool blocking = 20;
    bool has_blocking() const;

private:
    bool _internal_has_blocking() const;

public:
    void clear_blocking();
    bool blocking() const;
    void set_blocking(bool value);

private:
    bool _internal_blocking() const;
    void _internal_set_blocking(bool value);

public:
    // optional bool require_metadata_verdict = 21;
    bool has_require_metadata_verdict() const;

private:
    bool _internal_has_require_metadata_verdict() const;

public:
    void clear_require_metadata_verdict();
    bool require_metadata_verdict() const;
    void set_require_metadata_verdict(bool value);

private:
    bool _internal_require_metadata_verdict() const;
    void _internal_set_require_metadata_verdict(bool value);

public:
    // string text_content = 13;
    bool has_text_content() const;

private:
    bool _internal_has_text_content() const;

public:
    void clear_text_content();
    const std::string& text_content() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_text_content(ArgT0&& arg0, ArgT... args);
    std::string* mutable_text_content();
    PROTOBUF_NODISCARD std::string* release_text_content();
    void set_allocated_text_content(std::string* text_content);

private:
    const std::string& _internal_text_content() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_content(const std::string& value);
    std::string* _internal_mutable_text_content();

public:
    // string file_path = 14;
    bool has_file_path() const;

private:
    bool _internal_has_file_path() const;

public:
    void clear_file_path();
    const std::string& file_path() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_file_path(ArgT0&& arg0, ArgT... args);
    std::string* mutable_file_path();
    PROTOBUF_NODISCARD std::string* release_file_path();
    void set_allocated_file_path(std::string* file_path);

private:
    const std::string& _internal_file_path() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
    std::string* _internal_mutable_file_path();

public:
    void clear_content_data();
    ContentDataCase content_data_case() const;
    // @@protoc_insertion_point(class_scope:enterprise_connectors.ContentAnalysisRequest)
private:
    class _Internal;
    void set_has_text_content();
    void set_has_file_path();

    inline bool has_content_data() const;
    inline void clear_has_content_data();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_token_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fcm_notification_token_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_token_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_action_id_;
        ::enterprise_connectors::ContentMetaData* request_data_;
        ::enterprise_connectors::ClientMetadata* client_metadata_;
        int analysis_connector_;
        int reason_;
        int64_t expires_at_;
        int64_t user_action_requests_count_;
        bool blocking_;
        bool require_metadata_verdict_;
        union ContentDataUnion {
            constexpr ContentDataUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_content_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
        } content_data_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisResponse_Result_CustomMessage final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage) */ {
public:
    inline ContentAnalysisResponse_Result_CustomMessage()
        : ContentAnalysisResponse_Result_CustomMessage(nullptr)
    {
    }
    ~ContentAnalysisResponse_Result_CustomMessage() override;
    explicit PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_CustomMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ContentAnalysisResponse_Result_CustomMessage(const ContentAnalysisResponse_Result_CustomMessage& from);
    ContentAnalysisResponse_Result_CustomMessage(ContentAnalysisResponse_Result_CustomMessage&& from) noexcept
        : ContentAnalysisResponse_Result_CustomMessage()
    {
        *this = ::std::move(from);
    }

    inline ContentAnalysisResponse_Result_CustomMessage& operator=(const ContentAnalysisResponse_Result_CustomMessage& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ContentAnalysisResponse_Result_CustomMessage& operator=(ContentAnalysisResponse_Result_CustomMessage&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ContentAnalysisResponse_Result_CustomMessage& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ContentAnalysisResponse_Result_CustomMessage* internal_default_instance()
    {
        return reinterpret_cast<const ContentAnalysisResponse_Result_CustomMessage*>(&_ContentAnalysisResponse_Result_CustomMessage_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(ContentAnalysisResponse_Result_CustomMessage& a, ContentAnalysisResponse_Result_CustomMessage& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ContentAnalysisResponse_Result_CustomMessage* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ContentAnalysisResponse_Result_CustomMessage* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ContentAnalysisResponse_Result_CustomMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ContentAnalysisResponse_Result_CustomMessage>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ContentAnalysisResponse_Result_CustomMessage& from);
    void MergeFrom(const ContentAnalysisResponse_Result_CustomMessage& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ContentAnalysisResponse_Result_CustomMessage* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage";
    }

protected:
    explicit ContentAnalysisResponse_Result_CustomMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kLearnMoreUrlFieldNumber = 1,
        kMessageFieldNumber = 2,
    };
    // optional string learn_more_url = 1;
    bool has_learn_more_url() const;

private:
    bool _internal_has_learn_more_url() const;

public:
    void clear_learn_more_url();
    const std::string& learn_more_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_learn_more_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_learn_more_url();
    PROTOBUF_NODISCARD std::string* release_learn_more_url();
    void set_allocated_learn_more_url(std::string* learn_more_url);

private:
    const std::string& _internal_learn_more_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_learn_more_url(const std::string& value);
    std::string* _internal_mutable_learn_more_url();

public:
    // optional string message = 2;
    bool has_message() const;

private:
    bool _internal_has_message() const;

public:
    void clear_message();
    const std::string& message() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_message(ArgT0&& arg0, ArgT... args);
    std::string* mutable_message();
    PROTOBUF_NODISCARD std::string* release_message();
    void set_allocated_message(std::string* message);

private:
    const std::string& _internal_message() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
    std::string* _internal_mutable_message();

public:
    // @@protoc_insertion_point(class_scope:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr learn_more_url_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment) */
{
public:
    inline ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment()
        : ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment(nullptr)
    {
    }
    ~ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment() override;
    explicit PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment(const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment& from);
    ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment(ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment&& from) noexcept
        : ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment()
    {
        *this = ::std::move(from);
    }

    inline ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment& operator=(
        const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment& operator=(
        ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment* internal_default_instance()
    {
        return reinterpret_cast<const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment*>(
            &_ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(
        ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment& a, ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment& from);
    void MergeFrom(const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment";
    }

protected:
    explicit ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTextFieldNumber = 1,
        kLinkFieldNumber = 2,
    };
    // optional string text = 1;
    bool has_text() const;

private:
    bool _internal_has_text() const;

public:
    void clear_text();
    const std::string& text() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_text(ArgT0&& arg0, ArgT... args);
    std::string* mutable_text();
    PROTOBUF_NODISCARD std::string* release_text();
    void set_allocated_text(std::string* text);

private:
    const std::string& _internal_text() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
    std::string* _internal_mutable_text();

public:
    // optional string link = 2;
    bool has_link() const;

private:
    bool _internal_has_link() const;

public:
    void clear_link();
    const std::string& link() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_link(ArgT0&& arg0, ArgT... args);
    std::string* mutable_link();
    PROTOBUF_NODISCARD std::string* release_link();
    void set_allocated_link(std::string* link);

private:
    const std::string& _internal_link() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_link(const std::string& value);
    std::string* _internal_mutable_link();

public:
    // @@protoc_insertion_point(class_scope:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage) */ {
public:
    inline ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage()
        : ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage(nullptr)
    {
    }
    ~ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage() override;
    explicit PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage(const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& from);
    ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage(ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage&& from) noexcept
        : ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage()
    {
        *this = ::std::move(from);
    }

    inline ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& operator=(const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& operator=(
        ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* internal_default_instance()
    {
        return reinterpret_cast<const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage*>(
            &_ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& a, ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& from);
    void MergeFrom(const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage";
    }

protected:
    explicit ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kMessageSegmentsFieldNumber = 1,
    };
    // repeated .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment message_segments = 1;
    int message_segments_size() const;

private:
    int _internal_message_segments_size() const;

public:
    void clear_message_segments();
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment* mutable_message_segments(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment>*
    mutable_message_segments();

private:
    const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment& _internal_message_segments(int index) const;
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment* _internal_add_message_segments();

public:
    const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment& message_segments(int index) const;
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment* add_message_segments();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment>&
    message_segments() const;

    // @@protoc_insertion_point(class_scope:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment>
            message_segments_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisResponse_Result_TriggeredRule final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule) */ {
public:
    inline ContentAnalysisResponse_Result_TriggeredRule()
        : ContentAnalysisResponse_Result_TriggeredRule(nullptr)
    {
    }
    ~ContentAnalysisResponse_Result_TriggeredRule() override;
    explicit PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_TriggeredRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ContentAnalysisResponse_Result_TriggeredRule(const ContentAnalysisResponse_Result_TriggeredRule& from);
    ContentAnalysisResponse_Result_TriggeredRule(ContentAnalysisResponse_Result_TriggeredRule&& from) noexcept
        : ContentAnalysisResponse_Result_TriggeredRule()
    {
        *this = ::std::move(from);
    }

    inline ContentAnalysisResponse_Result_TriggeredRule& operator=(const ContentAnalysisResponse_Result_TriggeredRule& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ContentAnalysisResponse_Result_TriggeredRule& operator=(ContentAnalysisResponse_Result_TriggeredRule&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ContentAnalysisResponse_Result_TriggeredRule& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ContentAnalysisResponse_Result_TriggeredRule* internal_default_instance()
    {
        return reinterpret_cast<const ContentAnalysisResponse_Result_TriggeredRule*>(&_ContentAnalysisResponse_Result_TriggeredRule_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 10;

    friend void swap(ContentAnalysisResponse_Result_TriggeredRule& a, ContentAnalysisResponse_Result_TriggeredRule& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ContentAnalysisResponse_Result_TriggeredRule* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ContentAnalysisResponse_Result_TriggeredRule* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ContentAnalysisResponse_Result_TriggeredRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ContentAnalysisResponse_Result_TriggeredRule>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ContentAnalysisResponse_Result_TriggeredRule& from);
    void MergeFrom(const ContentAnalysisResponse_Result_TriggeredRule& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ContentAnalysisResponse_Result_TriggeredRule* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule";
    }

protected:
    explicit ContentAnalysisResponse_Result_TriggeredRule(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment CustomRuleMessageSegment;
    typedef ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage CustomRuleMessage;

    typedef ContentAnalysisResponse_Result_TriggeredRule_Action Action;
    static constexpr Action ACTION_UNSPECIFIED = ContentAnalysisResponse_Result_TriggeredRule_Action_ACTION_UNSPECIFIED;
    static constexpr Action REPORT_ONLY = ContentAnalysisResponse_Result_TriggeredRule_Action_REPORT_ONLY;
    static constexpr Action WARN = ContentAnalysisResponse_Result_TriggeredRule_Action_WARN;
    static constexpr Action BLOCK = ContentAnalysisResponse_Result_TriggeredRule_Action_BLOCK;
    static inline bool Action_IsValid(int value)
    {
        return ContentAnalysisResponse_Result_TriggeredRule_Action_IsValid(value);
    }
    static constexpr Action Action_MIN = ContentAnalysisResponse_Result_TriggeredRule_Action_Action_MIN;
    static constexpr Action Action_MAX = ContentAnalysisResponse_Result_TriggeredRule_Action_Action_MAX;
    static constexpr int Action_ARRAYSIZE = ContentAnalysisResponse_Result_TriggeredRule_Action_Action_ARRAYSIZE;
    template <typename T> static inline const std::string& Action_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Action>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Action_Name.");
        return ContentAnalysisResponse_Result_TriggeredRule_Action_Name(enum_t_value);
    }
    static inline bool Action_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Action* value)
    {
        return ContentAnalysisResponse_Result_TriggeredRule_Action_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kRuleNameFieldNumber = 2,
        kRuleIdFieldNumber = 3,
        kUrlCategoryFieldNumber = 5,
        kCustomMessageFieldNumber = 4,
        kCustomRuleMessageFieldNumber = 6,
        kActionFieldNumber = 1,
    };
    // optional string rule_name = 2;
    bool has_rule_name() const;

private:
    bool _internal_has_rule_name() const;

public:
    void clear_rule_name();
    const std::string& rule_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_rule_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_rule_name();
    PROTOBUF_NODISCARD std::string* release_rule_name();
    void set_allocated_rule_name(std::string* rule_name);

private:
    const std::string& _internal_rule_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule_name(const std::string& value);
    std::string* _internal_mutable_rule_name();

public:
    // optional string rule_id = 3;
    bool has_rule_id() const;

private:
    bool _internal_has_rule_id() const;

public:
    void clear_rule_id();
    const std::string& rule_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_rule_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_rule_id();
    PROTOBUF_NODISCARD std::string* release_rule_id();
    void set_allocated_rule_id(std::string* rule_id);

private:
    const std::string& _internal_rule_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule_id(const std::string& value);
    std::string* _internal_mutable_rule_id();

public:
    // optional string url_category = 5;
    bool has_url_category() const;

private:
    bool _internal_has_url_category() const;

public:
    void clear_url_category();
    const std::string& url_category() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url_category(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url_category();
    PROTOBUF_NODISCARD std::string* release_url_category();
    void set_allocated_url_category(std::string* url_category);

private:
    const std::string& _internal_url_category() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url_category(const std::string& value);
    std::string* _internal_mutable_url_category();

public:
    // optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 4 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_custom_message() const;

private:
    bool _internal_has_custom_message() const;

public:
    PROTOBUF_DEPRECATED void clear_custom_message();
    PROTOBUF_DEPRECATED const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage& custom_message() const;
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* release_custom_message();
    PROTOBUF_DEPRECATED ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* mutable_custom_message();
    PROTOBUF_DEPRECATED void set_allocated_custom_message(::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* custom_message);

private:
    const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage& _internal_custom_message() const;
    ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* _internal_mutable_custom_message();

public:
    PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_custom_message(::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* custom_message);
    PROTOBUF_DEPRECATED ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* unsafe_arena_release_custom_message();

    // optional .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage custom_rule_message = 6;
    bool has_custom_rule_message() const;

private:
    bool _internal_has_custom_rule_message() const;

public:
    void clear_custom_rule_message();
    const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& custom_rule_message() const;
    PROTOBUF_NODISCARD ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* release_custom_rule_message();
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* mutable_custom_rule_message();
    void set_allocated_custom_rule_message(::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* custom_rule_message);

private:
    const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& _internal_custom_rule_message() const;
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* _internal_mutable_custom_rule_message();

public:
    void unsafe_arena_set_allocated_custom_rule_message(
        ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* custom_rule_message);
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* unsafe_arena_release_custom_rule_message();

    // optional .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.Action action = 1;
    bool has_action() const;

private:
    bool _internal_has_action() const;

public:
    void clear_action();
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action action() const;
    void set_action(::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action value);

private:
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action _internal_action() const;
    void _internal_set_action(::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action value);

public:
    // @@protoc_insertion_point(class_scope:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rule_name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rule_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_category_;
        ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* custom_message_;
        ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* custom_rule_message_;
        int action_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisResponse_Result final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_connectors.ContentAnalysisResponse.Result) */ {
public:
    inline ContentAnalysisResponse_Result()
        : ContentAnalysisResponse_Result(nullptr)
    {
    }
    ~ContentAnalysisResponse_Result() override;
    explicit PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ContentAnalysisResponse_Result(const ContentAnalysisResponse_Result& from);
    ContentAnalysisResponse_Result(ContentAnalysisResponse_Result&& from) noexcept
        : ContentAnalysisResponse_Result()
    {
        *this = ::std::move(from);
    }

    inline ContentAnalysisResponse_Result& operator=(const ContentAnalysisResponse_Result& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ContentAnalysisResponse_Result& operator=(ContentAnalysisResponse_Result&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ContentAnalysisResponse_Result& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ContentAnalysisResponse_Result* internal_default_instance()
    {
        return reinterpret_cast<const ContentAnalysisResponse_Result*>(&_ContentAnalysisResponse_Result_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 11;

    friend void swap(ContentAnalysisResponse_Result& a, ContentAnalysisResponse_Result& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ContentAnalysisResponse_Result* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ContentAnalysisResponse_Result* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ContentAnalysisResponse_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ContentAnalysisResponse_Result>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ContentAnalysisResponse_Result& from);
    void MergeFrom(const ContentAnalysisResponse_Result& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ContentAnalysisResponse_Result* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "enterprise_connectors.ContentAnalysisResponse.Result";
    }

protected:
    explicit ContentAnalysisResponse_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ContentAnalysisResponse_Result_CustomMessage CustomMessage;
    typedef ContentAnalysisResponse_Result_TriggeredRule TriggeredRule;

    typedef ContentAnalysisResponse_Result_Status Status;
    static constexpr Status STATUS_UNKNOWN = ContentAnalysisResponse_Result_Status_STATUS_UNKNOWN;
    static constexpr Status SUCCESS = ContentAnalysisResponse_Result_Status_SUCCESS;
    static constexpr Status FAILURE = ContentAnalysisResponse_Result_Status_FAILURE;
    static inline bool Status_IsValid(int value)
    {
        return ContentAnalysisResponse_Result_Status_IsValid(value);
    }
    static constexpr Status Status_MIN = ContentAnalysisResponse_Result_Status_Status_MIN;
    static constexpr Status Status_MAX = ContentAnalysisResponse_Result_Status_Status_MAX;
    static constexpr int Status_ARRAYSIZE = ContentAnalysisResponse_Result_Status_Status_ARRAYSIZE;
    template <typename T> static inline const std::string& Status_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Status>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Status_Name.");
        return ContentAnalysisResponse_Result_Status_Name(enum_t_value);
    }
    static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status* value)
    {
        return ContentAnalysisResponse_Result_Status_Parse(name, value);
    }

    typedef ContentAnalysisResponse_Result_StatusErrorMessage StatusErrorMessage;
    static constexpr StatusErrorMessage STATUS_ERROR_MESSAGE_UNSPECIFIED = ContentAnalysisResponse_Result_StatusErrorMessage_STATUS_ERROR_MESSAGE_UNSPECIFIED;
    static constexpr StatusErrorMessage DECRYPTION_FAILED = ContentAnalysisResponse_Result_StatusErrorMessage_DECRYPTION_FAILED;
    static inline bool StatusErrorMessage_IsValid(int value)
    {
        return ContentAnalysisResponse_Result_StatusErrorMessage_IsValid(value);
    }
    static constexpr StatusErrorMessage StatusErrorMessage_MIN = ContentAnalysisResponse_Result_StatusErrorMessage_StatusErrorMessage_MIN;
    static constexpr StatusErrorMessage StatusErrorMessage_MAX = ContentAnalysisResponse_Result_StatusErrorMessage_StatusErrorMessage_MAX;
    static constexpr int StatusErrorMessage_ARRAYSIZE = ContentAnalysisResponse_Result_StatusErrorMessage_StatusErrorMessage_ARRAYSIZE;
    template <typename T> static inline const std::string& StatusErrorMessage_Name(T enum_t_value)
    {
        static_assert(
            ::std::is_same<T, StatusErrorMessage>::value || ::std::is_integral<T>::value, "Incorrect type passed to function StatusErrorMessage_Name.");
        return ContentAnalysisResponse_Result_StatusErrorMessage_Name(enum_t_value);
    }
    static inline bool StatusErrorMessage_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StatusErrorMessage* value)
    {
        return ContentAnalysisResponse_Result_StatusErrorMessage_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kTriggeredRulesFieldNumber = 3,
        kTagFieldNumber = 1,
        kCustomMessageFieldNumber = 7,
        kStatusFieldNumber = 2,
        kStatusErrorMessageFieldNumber = 8,
    };
    // repeated .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule triggered_rules = 3;
    int triggered_rules_size() const;

private:
    int _internal_triggered_rules_size() const;

public:
    void clear_triggered_rules();
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule* mutable_triggered_rules(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule>* mutable_triggered_rules();

private:
    const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule& _internal_triggered_rules(int index) const;
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule* _internal_add_triggered_rules();

public:
    const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule& triggered_rules(int index) const;
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule* add_triggered_rules();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule>& triggered_rules() const;

    // optional string tag = 1;
    bool has_tag() const;

private:
    bool _internal_has_tag() const;

public:
    void clear_tag();
    const std::string& tag() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_tag(ArgT0&& arg0, ArgT... args);
    std::string* mutable_tag();
    PROTOBUF_NODISCARD std::string* release_tag();
    void set_allocated_tag(std::string* tag);

private:
    const std::string& _internal_tag() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
    std::string* _internal_mutable_tag();

public:
    // optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 7 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_custom_message() const;

private:
    bool _internal_has_custom_message() const;

public:
    PROTOBUF_DEPRECATED void clear_custom_message();
    PROTOBUF_DEPRECATED const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage& custom_message() const;
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* release_custom_message();
    PROTOBUF_DEPRECATED ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* mutable_custom_message();
    PROTOBUF_DEPRECATED void set_allocated_custom_message(::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* custom_message);

private:
    const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage& _internal_custom_message() const;
    ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* _internal_mutable_custom_message();

public:
    PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_custom_message(::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* custom_message);
    PROTOBUF_DEPRECATED ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* unsafe_arena_release_custom_message();

    // optional .enterprise_connectors.ContentAnalysisResponse.Result.Status status = 2;
    bool has_status() const;

private:
    bool _internal_has_status() const;

public:
    void clear_status();
    ::enterprise_connectors::ContentAnalysisResponse_Result_Status status() const;
    void set_status(::enterprise_connectors::ContentAnalysisResponse_Result_Status value);

private:
    ::enterprise_connectors::ContentAnalysisResponse_Result_Status _internal_status() const;
    void _internal_set_status(::enterprise_connectors::ContentAnalysisResponse_Result_Status value);

public:
    // optional .enterprise_connectors.ContentAnalysisResponse.Result.StatusErrorMessage status_error_message = 8;
    bool has_status_error_message() const;

private:
    bool _internal_has_status_error_message() const;

public:
    void clear_status_error_message();
    ::enterprise_connectors::ContentAnalysisResponse_Result_StatusErrorMessage status_error_message() const;
    void set_status_error_message(::enterprise_connectors::ContentAnalysisResponse_Result_StatusErrorMessage value);

private:
    ::enterprise_connectors::ContentAnalysisResponse_Result_StatusErrorMessage _internal_status_error_message() const;
    void _internal_set_status_error_message(::enterprise_connectors::ContentAnalysisResponse_Result_StatusErrorMessage value);

public:
    // @@protoc_insertion_point(class_scope:enterprise_connectors.ContentAnalysisResponse.Result)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule> triggered_rules_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
        ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* custom_message_;
        int status_;
        int status_error_message_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisResponse final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_connectors.ContentAnalysisResponse) */ {
public:
    inline ContentAnalysisResponse()
        : ContentAnalysisResponse(nullptr)
    {
    }
    ~ContentAnalysisResponse() override;
    explicit PROTOBUF_CONSTEXPR ContentAnalysisResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ContentAnalysisResponse(const ContentAnalysisResponse& from);
    ContentAnalysisResponse(ContentAnalysisResponse&& from) noexcept
        : ContentAnalysisResponse()
    {
        *this = ::std::move(from);
    }

    inline ContentAnalysisResponse& operator=(const ContentAnalysisResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ContentAnalysisResponse& operator=(ContentAnalysisResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ContentAnalysisResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ContentAnalysisResponse* internal_default_instance()
    {
        return reinterpret_cast<const ContentAnalysisResponse*>(&_ContentAnalysisResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 12;

    friend void swap(ContentAnalysisResponse& a, ContentAnalysisResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ContentAnalysisResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ContentAnalysisResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ContentAnalysisResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ContentAnalysisResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ContentAnalysisResponse& from);
    void MergeFrom(const ContentAnalysisResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ContentAnalysisResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "enterprise_connectors.ContentAnalysisResponse";
    }

protected:
    explicit ContentAnalysisResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ContentAnalysisResponse_Result Result;

    // accessors -------------------------------------------------------

    enum : int {
        kResultsFieldNumber = 4,
        kRequestTokenFieldNumber = 1,
    };
    // repeated .enterprise_connectors.ContentAnalysisResponse.Result results = 4;
    int results_size() const;

private:
    int _internal_results_size() const;

public:
    void clear_results();
    ::enterprise_connectors::ContentAnalysisResponse_Result* mutable_results(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result>* mutable_results();

private:
    const ::enterprise_connectors::ContentAnalysisResponse_Result& _internal_results(int index) const;
    ::enterprise_connectors::ContentAnalysisResponse_Result* _internal_add_results();

public:
    const ::enterprise_connectors::ContentAnalysisResponse_Result& results(int index) const;
    ::enterprise_connectors::ContentAnalysisResponse_Result* add_results();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result>& results() const;

    // optional string request_token = 1;
    bool has_request_token() const;

private:
    bool _internal_has_request_token() const;

public:
    void clear_request_token();
    const std::string& request_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_request_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_request_token();
    PROTOBUF_NODISCARD std::string* release_request_token();
    void set_allocated_request_token(std::string* request_token);

private:
    const std::string& _internal_request_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_token(const std::string& value);
    std::string* _internal_mutable_request_token();

public:
    // @@protoc_insertion_point(class_scope:enterprise_connectors.ContentAnalysisResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result> results_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_token_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto;
};
// -------------------------------------------------------------------

class ContentAnalysisAcknowledgement final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:enterprise_connectors.ContentAnalysisAcknowledgement) */ {
public:
    inline ContentAnalysisAcknowledgement()
        : ContentAnalysisAcknowledgement(nullptr)
    {
    }
    ~ContentAnalysisAcknowledgement() override;
    explicit PROTOBUF_CONSTEXPR ContentAnalysisAcknowledgement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ContentAnalysisAcknowledgement(const ContentAnalysisAcknowledgement& from);
    ContentAnalysisAcknowledgement(ContentAnalysisAcknowledgement&& from) noexcept
        : ContentAnalysisAcknowledgement()
    {
        *this = ::std::move(from);
    }

    inline ContentAnalysisAcknowledgement& operator=(const ContentAnalysisAcknowledgement& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ContentAnalysisAcknowledgement& operator=(ContentAnalysisAcknowledgement&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ContentAnalysisAcknowledgement& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ContentAnalysisAcknowledgement* internal_default_instance()
    {
        return reinterpret_cast<const ContentAnalysisAcknowledgement*>(&_ContentAnalysisAcknowledgement_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 13;

    friend void swap(ContentAnalysisAcknowledgement& a, ContentAnalysisAcknowledgement& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ContentAnalysisAcknowledgement* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ContentAnalysisAcknowledgement* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ContentAnalysisAcknowledgement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ContentAnalysisAcknowledgement>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ContentAnalysisAcknowledgement& from);
    void MergeFrom(const ContentAnalysisAcknowledgement& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ContentAnalysisAcknowledgement* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "enterprise_connectors.ContentAnalysisAcknowledgement";
    }

protected:
    explicit ContentAnalysisAcknowledgement(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ContentAnalysisAcknowledgement_Status Status;
    static constexpr Status SUCCESS = ContentAnalysisAcknowledgement_Status_SUCCESS;
    static constexpr Status INVALID_RESPONSE = ContentAnalysisAcknowledgement_Status_INVALID_RESPONSE;
    static constexpr Status TOO_LATE = ContentAnalysisAcknowledgement_Status_TOO_LATE;
    static inline bool Status_IsValid(int value)
    {
        return ContentAnalysisAcknowledgement_Status_IsValid(value);
    }
    static constexpr Status Status_MIN = ContentAnalysisAcknowledgement_Status_Status_MIN;
    static constexpr Status Status_MAX = ContentAnalysisAcknowledgement_Status_Status_MAX;
    static constexpr int Status_ARRAYSIZE = ContentAnalysisAcknowledgement_Status_Status_ARRAYSIZE;
    template <typename T> static inline const std::string& Status_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Status>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Status_Name.");
        return ContentAnalysisAcknowledgement_Status_Name(enum_t_value);
    }
    static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Status* value)
    {
        return ContentAnalysisAcknowledgement_Status_Parse(name, value);
    }

    typedef ContentAnalysisAcknowledgement_FinalAction FinalAction;
    static constexpr FinalAction ACTION_UNSPECIFIED = ContentAnalysisAcknowledgement_FinalAction_ACTION_UNSPECIFIED;
    static constexpr FinalAction ALLOW = ContentAnalysisAcknowledgement_FinalAction_ALLOW;
    static constexpr FinalAction REPORT_ONLY = ContentAnalysisAcknowledgement_FinalAction_REPORT_ONLY;
    static constexpr FinalAction WARN = ContentAnalysisAcknowledgement_FinalAction_WARN;
    static constexpr FinalAction BLOCK = ContentAnalysisAcknowledgement_FinalAction_BLOCK;
    static inline bool FinalAction_IsValid(int value)
    {
        return ContentAnalysisAcknowledgement_FinalAction_IsValid(value);
    }
    static constexpr FinalAction FinalAction_MIN = ContentAnalysisAcknowledgement_FinalAction_FinalAction_MIN;
    static constexpr FinalAction FinalAction_MAX = ContentAnalysisAcknowledgement_FinalAction_FinalAction_MAX;
    static constexpr int FinalAction_ARRAYSIZE = ContentAnalysisAcknowledgement_FinalAction_FinalAction_ARRAYSIZE;
    template <typename T> static inline const std::string& FinalAction_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, FinalAction>::value || ::std::is_integral<T>::value, "Incorrect type passed to function FinalAction_Name.");
        return ContentAnalysisAcknowledgement_FinalAction_Name(enum_t_value);
    }
    static inline bool FinalAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FinalAction* value)
    {
        return ContentAnalysisAcknowledgement_FinalAction_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kRequestTokenFieldNumber = 1,
        kFinalActionFieldNumber = 3,
        kStatusFieldNumber = 2,
    };
    // optional string request_token = 1;
    bool has_request_token() const;

private:
    bool _internal_has_request_token() const;

public:
    void clear_request_token();
    const std::string& request_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_request_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_request_token();
    PROTOBUF_NODISCARD std::string* release_request_token();
    void set_allocated_request_token(std::string* request_token);

private:
    const std::string& _internal_request_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_token(const std::string& value);
    std::string* _internal_mutable_request_token();

public:
    // optional .enterprise_connectors.ContentAnalysisAcknowledgement.FinalAction final_action = 3;
    bool has_final_action() const;

private:
    bool _internal_has_final_action() const;

public:
    void clear_final_action();
    ::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction final_action() const;
    void set_final_action(::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction value);

private:
    ::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction _internal_final_action() const;
    void _internal_set_final_action(::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction value);

public:
    // optional .enterprise_connectors.ContentAnalysisAcknowledgement.Status status = 2;
    bool has_status() const;

private:
    bool _internal_has_status() const;

public:
    void clear_status();
    ::enterprise_connectors::ContentAnalysisAcknowledgement_Status status() const;
    void set_status(::enterprise_connectors::ContentAnalysisAcknowledgement_Status value);

private:
    ::enterprise_connectors::ContentAnalysisAcknowledgement_Status _internal_status() const;
    void _internal_set_status(::enterprise_connectors::ContentAnalysisAcknowledgement_Status value);

public:
    // @@protoc_insertion_point(class_scope:enterprise_connectors.ContentAnalysisAcknowledgement)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_token_;
        int final_action_;
        int status_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// ContentMetaData_PrintMetadata

// optional string printer_name = 1;
inline bool ContentMetaData_PrintMetadata::_internal_has_printer_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ContentMetaData_PrintMetadata::has_printer_name() const
{
    return _internal_has_printer_name();
}
inline void ContentMetaData_PrintMetadata::clear_printer_name()
{
    _impl_.printer_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentMetaData_PrintMetadata::printer_name() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentMetaData.PrintMetadata.printer_name)
    return _internal_printer_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentMetaData_PrintMetadata::set_printer_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.printer_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentMetaData.PrintMetadata.printer_name)
}
inline std::string* ContentMetaData_PrintMetadata::mutable_printer_name()
{
    std::string* _s = _internal_mutable_printer_name();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentMetaData.PrintMetadata.printer_name)
    return _s;
}
inline const std::string& ContentMetaData_PrintMetadata::_internal_printer_name() const
{
    return _impl_.printer_name_.Get();
}
inline void ContentMetaData_PrintMetadata::_internal_set_printer_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.printer_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData_PrintMetadata::_internal_mutable_printer_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.printer_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData_PrintMetadata::release_printer_name()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentMetaData.PrintMetadata.printer_name)
    if (!_internal_has_printer_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.printer_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.printer_name_.IsDefault()) {
        _impl_.printer_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentMetaData_PrintMetadata::set_allocated_printer_name(std::string* printer_name)
{
    if (printer_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.printer_name_.SetAllocated(printer_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.printer_name_.IsDefault()) {
        _impl_.printer_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentMetaData.PrintMetadata.printer_name)
}

// optional .enterprise_connectors.ContentMetaData.PrintMetadata.PrinterType printer_type = 2;
inline bool ContentMetaData_PrintMetadata::_internal_has_printer_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ContentMetaData_PrintMetadata::has_printer_type() const
{
    return _internal_has_printer_type();
}
inline void ContentMetaData_PrintMetadata::clear_printer_type()
{
    _impl_.printer_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_connectors::ContentMetaData_PrintMetadata_PrinterType ContentMetaData_PrintMetadata::_internal_printer_type() const
{
    return static_cast<::enterprise_connectors::ContentMetaData_PrintMetadata_PrinterType>(_impl_.printer_type_);
}
inline ::enterprise_connectors::ContentMetaData_PrintMetadata_PrinterType ContentMetaData_PrintMetadata::printer_type() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentMetaData.PrintMetadata.printer_type)
    return _internal_printer_type();
}
inline void ContentMetaData_PrintMetadata::_internal_set_printer_type(::enterprise_connectors::ContentMetaData_PrintMetadata_PrinterType value)
{
    assert(::enterprise_connectors::ContentMetaData_PrintMetadata_PrinterType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.printer_type_ = value;
}
inline void ContentMetaData_PrintMetadata::set_printer_type(::enterprise_connectors::ContentMetaData_PrintMetadata_PrinterType value)
{
    _internal_set_printer_type(value);
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentMetaData.PrintMetadata.printer_type)
}

// -------------------------------------------------------------------

// ContentMetaData

// optional string url = 1;
inline bool ContentMetaData::_internal_has_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ContentMetaData::has_url() const
{
    return _internal_has_url();
}
inline void ContentMetaData::clear_url()
{
    _impl_.url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentMetaData::url() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentMetaData.url)
    return _internal_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentMetaData::set_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentMetaData.url)
}
inline std::string* ContentMetaData::mutable_url()
{
    std::string* _s = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentMetaData.url)
    return _s;
}
inline const std::string& ContentMetaData::_internal_url() const
{
    return _impl_.url_.Get();
}
inline void ContentMetaData::_internal_set_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_url()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_url()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentMetaData.url)
    if (!_internal_has_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentMetaData::set_allocated_url(std::string* url)
{
    if (url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentMetaData.url)
}

// optional string filename = 2;
inline bool ContentMetaData::_internal_has_filename() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ContentMetaData::has_filename() const
{
    return _internal_has_filename();
}
inline void ContentMetaData::clear_filename()
{
    _impl_.filename_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContentMetaData::filename() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentMetaData.filename)
    return _internal_filename();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentMetaData::set_filename(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.filename_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentMetaData.filename)
}
inline std::string* ContentMetaData::mutable_filename()
{
    std::string* _s = _internal_mutable_filename();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentMetaData.filename)
    return _s;
}
inline const std::string& ContentMetaData::_internal_filename() const
{
    return _impl_.filename_.Get();
}
inline void ContentMetaData::_internal_set_filename(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_filename()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_filename()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentMetaData.filename)
    if (!_internal_has_filename()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.filename_.IsDefault()) {
        _impl_.filename_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentMetaData::set_allocated_filename(std::string* filename)
{
    if (filename != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.filename_.IsDefault()) {
        _impl_.filename_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentMetaData.filename)
}

// optional string digest = 3;
inline bool ContentMetaData::_internal_has_digest() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ContentMetaData::has_digest() const
{
    return _internal_has_digest();
}
inline void ContentMetaData::clear_digest()
{
    _impl_.digest_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ContentMetaData::digest() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentMetaData.digest)
    return _internal_digest();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentMetaData::set_digest(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.digest_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentMetaData.digest)
}
inline std::string* ContentMetaData::mutable_digest()
{
    std::string* _s = _internal_mutable_digest();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentMetaData.digest)
    return _s;
}
inline const std::string& ContentMetaData::_internal_digest() const
{
    return _impl_.digest_.Get();
}
inline void ContentMetaData::_internal_set_digest(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.digest_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_digest()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.digest_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_digest()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentMetaData.digest)
    if (!_internal_has_digest()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.digest_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.digest_.IsDefault()) {
        _impl_.digest_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentMetaData::set_allocated_digest(std::string* digest)
{
    if (digest != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.digest_.SetAllocated(digest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.digest_.IsDefault()) {
        _impl_.digest_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentMetaData.digest)
}

// optional .safe_browsing.ClientDownloadRequest csd = 4;
inline bool ContentMetaData::_internal_has_csd() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.csd_ != nullptr);
    return value;
}
inline bool ContentMetaData::has_csd() const
{
    return _internal_has_csd();
}
inline const ::safe_browsing::ClientDownloadRequest& ContentMetaData::_internal_csd() const
{
    const ::safe_browsing::ClientDownloadRequest* p = _impl_.csd_;
    return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::ClientDownloadRequest&>(::safe_browsing::_ClientDownloadRequest_default_instance_);
}
inline const ::safe_browsing::ClientDownloadRequest& ContentMetaData::csd() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentMetaData.csd)
    return _internal_csd();
}
inline void ContentMetaData::unsafe_arena_set_allocated_csd(::safe_browsing::ClientDownloadRequest* csd)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.csd_);
    }
    _impl_.csd_ = csd;
    if (csd) {
        _impl_._has_bits_[0] |= 0x00000400u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000400u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_connectors.ContentMetaData.csd)
}
inline ::safe_browsing::ClientDownloadRequest* ContentMetaData::release_csd()
{
    _impl_._has_bits_[0] &= ~0x00000400u;
    ::safe_browsing::ClientDownloadRequest* temp = _impl_.csd_;
    _impl_.csd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::safe_browsing::ClientDownloadRequest* ContentMetaData::unsafe_arena_release_csd()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentMetaData.csd)
    _impl_._has_bits_[0] &= ~0x00000400u;
    ::safe_browsing::ClientDownloadRequest* temp = _impl_.csd_;
    _impl_.csd_ = nullptr;
    return temp;
}
inline ::safe_browsing::ClientDownloadRequest* ContentMetaData::_internal_mutable_csd()
{
    _impl_._has_bits_[0] |= 0x00000400u;
    if (_impl_.csd_ == nullptr) {
        auto* p = CreateMaybeMessage<::safe_browsing::ClientDownloadRequest>(GetArenaForAllocation());
        _impl_.csd_ = p;
    }
    return _impl_.csd_;
}
inline ::safe_browsing::ClientDownloadRequest* ContentMetaData::mutable_csd()
{
    ::safe_browsing::ClientDownloadRequest* _msg = _internal_mutable_csd();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentMetaData.csd)
    return _msg;
}
inline void ContentMetaData::set_allocated_csd(::safe_browsing::ClientDownloadRequest* csd)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.csd_);
    }
    if (csd) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(csd));
        if (message_arena != submessage_arena) {
            csd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, csd, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000400u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000400u;
    }
    _impl_.csd_ = csd;
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentMetaData.csd)
}

// optional string email = 5;
inline bool ContentMetaData::_internal_has_email() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ContentMetaData::has_email() const
{
    return _internal_has_email();
}
inline void ContentMetaData::clear_email()
{
    _impl_.email_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ContentMetaData::email() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentMetaData.email)
    return _internal_email();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentMetaData::set_email(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.email_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentMetaData.email)
}
inline std::string* ContentMetaData::mutable_email()
{
    std::string* _s = _internal_mutable_email();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentMetaData.email)
    return _s;
}
inline const std::string& ContentMetaData::_internal_email() const
{
    return _impl_.email_.Get();
}
inline void ContentMetaData::_internal_set_email(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_email()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_email()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentMetaData.email)
    if (!_internal_has_email()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.email_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.email_.IsDefault()) {
        _impl_.email_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentMetaData::set_allocated_email(std::string* email)
{
    if (email != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.email_.IsDefault()) {
        _impl_.email_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentMetaData.email)
}

// optional string content_type = 6;
inline bool ContentMetaData::_internal_has_content_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool ContentMetaData::has_content_type() const
{
    return _internal_has_content_type();
}
inline void ContentMetaData::clear_content_type()
{
    _impl_.content_type_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ContentMetaData::content_type() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentMetaData.content_type)
    return _internal_content_type();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentMetaData::set_content_type(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.content_type_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentMetaData.content_type)
}
inline std::string* ContentMetaData::mutable_content_type()
{
    std::string* _s = _internal_mutable_content_type();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentMetaData.content_type)
    return _s;
}
inline const std::string& ContentMetaData::_internal_content_type() const
{
    return _impl_.content_type_.Get();
}
inline void ContentMetaData::_internal_set_content_type(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.content_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_content_type()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    return _impl_.content_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_content_type()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentMetaData.content_type)
    if (!_internal_has_content_type()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000010u;
    auto* p = _impl_.content_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.content_type_.IsDefault()) {
        _impl_.content_type_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentMetaData::set_allocated_content_type(std::string* content_type)
{
    if (content_type != nullptr) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.content_type_.SetAllocated(content_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.content_type_.IsDefault()) {
        _impl_.content_type_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentMetaData.content_type)
}

// optional string source = 7;
inline bool ContentMetaData::_internal_has_source() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool ContentMetaData::has_source() const
{
    return _internal_has_source();
}
inline void ContentMetaData::clear_source()
{
    _impl_.source_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ContentMetaData::source() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentMetaData.source)
    return _internal_source();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentMetaData::set_source(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.source_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentMetaData.source)
}
inline std::string* ContentMetaData::mutable_source()
{
    std::string* _s = _internal_mutable_source();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentMetaData.source)
    return _s;
}
inline const std::string& ContentMetaData::_internal_source() const
{
    return _impl_.source_.Get();
}
inline void ContentMetaData::_internal_set_source(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.source_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_source()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    return _impl_.source_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_source()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentMetaData.source)
    if (!_internal_has_source()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000020u;
    auto* p = _impl_.source_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.source_.IsDefault()) {
        _impl_.source_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentMetaData::set_allocated_source(std::string* source)
{
    if (source != nullptr) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.source_.SetAllocated(source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.source_.IsDefault()) {
        _impl_.source_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentMetaData.source)
}

// optional string destination = 8;
inline bool ContentMetaData::_internal_has_destination() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool ContentMetaData::has_destination() const
{
    return _internal_has_destination();
}
inline void ContentMetaData::clear_destination()
{
    _impl_.destination_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ContentMetaData::destination() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentMetaData.destination)
    return _internal_destination();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentMetaData::set_destination(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.destination_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentMetaData.destination)
}
inline std::string* ContentMetaData::mutable_destination()
{
    std::string* _s = _internal_mutable_destination();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentMetaData.destination)
    return _s;
}
inline const std::string& ContentMetaData::_internal_destination() const
{
    return _impl_.destination_.Get();
}
inline void ContentMetaData::_internal_set_destination(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_destination()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    return _impl_.destination_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_destination()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentMetaData.destination)
    if (!_internal_has_destination()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000040u;
    auto* p = _impl_.destination_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.destination_.IsDefault()) {
        _impl_.destination_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentMetaData::set_allocated_destination(std::string* destination)
{
    if (destination != nullptr) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.destination_.SetAllocated(destination, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.destination_.IsDefault()) {
        _impl_.destination_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentMetaData.destination)
}

// optional string tab_title = 9;
inline bool ContentMetaData::_internal_has_tab_title() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool ContentMetaData::has_tab_title() const
{
    return _internal_has_tab_title();
}
inline void ContentMetaData::clear_tab_title()
{
    _impl_.tab_title_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ContentMetaData::tab_title() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentMetaData.tab_title)
    return _internal_tab_title();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentMetaData::set_tab_title(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.tab_title_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentMetaData.tab_title)
}
inline std::string* ContentMetaData::mutable_tab_title()
{
    std::string* _s = _internal_mutable_tab_title();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentMetaData.tab_title)
    return _s;
}
inline const std::string& ContentMetaData::_internal_tab_title() const
{
    return _impl_.tab_title_.Get();
}
inline void ContentMetaData::_internal_set_tab_title(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.tab_title_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_tab_title()
{
    _impl_._has_bits_[0] |= 0x00000080u;
    return _impl_.tab_title_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_tab_title()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentMetaData.tab_title)
    if (!_internal_has_tab_title()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000080u;
    auto* p = _impl_.tab_title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.tab_title_.IsDefault()) {
        _impl_.tab_title_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentMetaData::set_allocated_tab_title(std::string* tab_title)
{
    if (tab_title != nullptr) {
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    _impl_.tab_title_.SetAllocated(tab_title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.tab_title_.IsDefault()) {
        _impl_.tab_title_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentMetaData.tab_title)
}

// optional string tab_url = 10;
inline bool ContentMetaData::_internal_has_tab_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool ContentMetaData::has_tab_url() const
{
    return _internal_has_tab_url();
}
inline void ContentMetaData::clear_tab_url()
{
    _impl_.tab_url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& ContentMetaData::tab_url() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentMetaData.tab_url)
    return _internal_tab_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentMetaData::set_tab_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.tab_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentMetaData.tab_url)
}
inline std::string* ContentMetaData::mutable_tab_url()
{
    std::string* _s = _internal_mutable_tab_url();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentMetaData.tab_url)
    return _s;
}
inline const std::string& ContentMetaData::_internal_tab_url() const
{
    return _impl_.tab_url_.Get();
}
inline void ContentMetaData::_internal_set_tab_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.tab_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_tab_url()
{
    _impl_._has_bits_[0] |= 0x00000100u;
    return _impl_.tab_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_tab_url()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentMetaData.tab_url)
    if (!_internal_has_tab_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000100u;
    auto* p = _impl_.tab_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.tab_url_.IsDefault()) {
        _impl_.tab_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentMetaData::set_allocated_tab_url(std::string* tab_url)
{
    if (tab_url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    _impl_.tab_url_.SetAllocated(tab_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.tab_url_.IsDefault()) {
        _impl_.tab_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentMetaData.tab_url)
}

// optional .enterprise_connectors.ContentMetaData.PrintMetadata print_metadata = 11;
inline bool ContentMetaData::_internal_has_print_metadata() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.print_metadata_ != nullptr);
    return value;
}
inline bool ContentMetaData::has_print_metadata() const
{
    return _internal_has_print_metadata();
}
inline void ContentMetaData::clear_print_metadata()
{
    if (_impl_.print_metadata_ != nullptr)
        _impl_.print_metadata_->Clear();
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::enterprise_connectors::ContentMetaData_PrintMetadata& ContentMetaData::_internal_print_metadata() const
{
    const ::enterprise_connectors::ContentMetaData_PrintMetadata* p = _impl_.print_metadata_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::enterprise_connectors::ContentMetaData_PrintMetadata&>(
                            ::enterprise_connectors::_ContentMetaData_PrintMetadata_default_instance_);
}
inline const ::enterprise_connectors::ContentMetaData_PrintMetadata& ContentMetaData::print_metadata() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentMetaData.print_metadata)
    return _internal_print_metadata();
}
inline void ContentMetaData::unsafe_arena_set_allocated_print_metadata(::enterprise_connectors::ContentMetaData_PrintMetadata* print_metadata)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.print_metadata_);
    }
    _impl_.print_metadata_ = print_metadata;
    if (print_metadata) {
        _impl_._has_bits_[0] |= 0x00000800u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000800u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_connectors.ContentMetaData.print_metadata)
}
inline ::enterprise_connectors::ContentMetaData_PrintMetadata* ContentMetaData::release_print_metadata()
{
    _impl_._has_bits_[0] &= ~0x00000800u;
    ::enterprise_connectors::ContentMetaData_PrintMetadata* temp = _impl_.print_metadata_;
    _impl_.print_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::enterprise_connectors::ContentMetaData_PrintMetadata* ContentMetaData::unsafe_arena_release_print_metadata()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentMetaData.print_metadata)
    _impl_._has_bits_[0] &= ~0x00000800u;
    ::enterprise_connectors::ContentMetaData_PrintMetadata* temp = _impl_.print_metadata_;
    _impl_.print_metadata_ = nullptr;
    return temp;
}
inline ::enterprise_connectors::ContentMetaData_PrintMetadata* ContentMetaData::_internal_mutable_print_metadata()
{
    _impl_._has_bits_[0] |= 0x00000800u;
    if (_impl_.print_metadata_ == nullptr) {
        auto* p = CreateMaybeMessage<::enterprise_connectors::ContentMetaData_PrintMetadata>(GetArenaForAllocation());
        _impl_.print_metadata_ = p;
    }
    return _impl_.print_metadata_;
}
inline ::enterprise_connectors::ContentMetaData_PrintMetadata* ContentMetaData::mutable_print_metadata()
{
    ::enterprise_connectors::ContentMetaData_PrintMetadata* _msg = _internal_mutable_print_metadata();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentMetaData.print_metadata)
    return _msg;
}
inline void ContentMetaData::set_allocated_print_metadata(::enterprise_connectors::ContentMetaData_PrintMetadata* print_metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.print_metadata_;
    }
    if (print_metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(print_metadata);
        if (message_arena != submessage_arena) {
            print_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, print_metadata, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000800u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000800u;
    }
    _impl_.print_metadata_ = print_metadata;
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentMetaData.print_metadata)
}

// optional bytes decryption_key = 12;
inline bool ContentMetaData::_internal_has_decryption_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool ContentMetaData::has_decryption_key() const
{
    return _internal_has_decryption_key();
}
inline void ContentMetaData::clear_decryption_key()
{
    _impl_.decryption_key_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& ContentMetaData::decryption_key() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentMetaData.decryption_key)
    return _internal_decryption_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentMetaData::set_decryption_key(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.decryption_key_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentMetaData.decryption_key)
}
inline std::string* ContentMetaData::mutable_decryption_key()
{
    std::string* _s = _internal_mutable_decryption_key();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentMetaData.decryption_key)
    return _s;
}
inline const std::string& ContentMetaData::_internal_decryption_key() const
{
    return _impl_.decryption_key_.Get();
}
inline void ContentMetaData::_internal_set_decryption_key(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.decryption_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentMetaData::_internal_mutable_decryption_key()
{
    _impl_._has_bits_[0] |= 0x00000200u;
    return _impl_.decryption_key_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentMetaData::release_decryption_key()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentMetaData.decryption_key)
    if (!_internal_has_decryption_key()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000200u;
    auto* p = _impl_.decryption_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.decryption_key_.IsDefault()) {
        _impl_.decryption_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentMetaData::set_allocated_decryption_key(std::string* decryption_key)
{
    if (decryption_key != nullptr) {
        _impl_._has_bits_[0] |= 0x00000200u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000200u;
    }
    _impl_.decryption_key_.SetAllocated(decryption_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.decryption_key_.IsDefault()) {
        _impl_.decryption_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentMetaData.decryption_key)
}

// -------------------------------------------------------------------

// ClientMetadata_Browser

// optional string browser_id = 1;
inline bool ClientMetadata_Browser::_internal_has_browser_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ClientMetadata_Browser::has_browser_id() const
{
    return _internal_has_browser_id();
}
inline void ClientMetadata_Browser::clear_browser_id()
{
    _impl_.browser_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientMetadata_Browser::browser_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.Browser.browser_id)
    return _internal_browser_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientMetadata_Browser::set_browser_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.browser_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.Browser.browser_id)
}
inline std::string* ClientMetadata_Browser::mutable_browser_id()
{
    std::string* _s = _internal_mutable_browser_id();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.Browser.browser_id)
    return _s;
}
inline const std::string& ClientMetadata_Browser::_internal_browser_id() const
{
    return _impl_.browser_id_.Get();
}
inline void ClientMetadata_Browser::_internal_set_browser_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.browser_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Browser::_internal_mutable_browser_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.browser_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Browser::release_browser_id()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.Browser.browser_id)
    if (!_internal_has_browser_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.browser_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.browser_id_.IsDefault()) {
        _impl_.browser_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientMetadata_Browser::set_allocated_browser_id(std::string* browser_id)
{
    if (browser_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.browser_id_.SetAllocated(browser_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.browser_id_.IsDefault()) {
        _impl_.browser_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.Browser.browser_id)
}

// optional string user_agent = 2;
inline bool ClientMetadata_Browser::_internal_has_user_agent() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ClientMetadata_Browser::has_user_agent() const
{
    return _internal_has_user_agent();
}
inline void ClientMetadata_Browser::clear_user_agent()
{
    _impl_.user_agent_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientMetadata_Browser::user_agent() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.Browser.user_agent)
    return _internal_user_agent();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientMetadata_Browser::set_user_agent(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.user_agent_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.Browser.user_agent)
}
inline std::string* ClientMetadata_Browser::mutable_user_agent()
{
    std::string* _s = _internal_mutable_user_agent();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.Browser.user_agent)
    return _s;
}
inline const std::string& ClientMetadata_Browser::_internal_user_agent() const
{
    return _impl_.user_agent_.Get();
}
inline void ClientMetadata_Browser::_internal_set_user_agent(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.user_agent_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Browser::_internal_mutable_user_agent()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.user_agent_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Browser::release_user_agent()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.Browser.user_agent)
    if (!_internal_has_user_agent()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.user_agent_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.user_agent_.IsDefault()) {
        _impl_.user_agent_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientMetadata_Browser::set_allocated_user_agent(std::string* user_agent)
{
    if (user_agent != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.user_agent_.SetAllocated(user_agent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.user_agent_.IsDefault()) {
        _impl_.user_agent_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.Browser.user_agent)
}

// optional string chrome_version = 3;
inline bool ClientMetadata_Browser::_internal_has_chrome_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ClientMetadata_Browser::has_chrome_version() const
{
    return _internal_has_chrome_version();
}
inline void ClientMetadata_Browser::clear_chrome_version()
{
    _impl_.chrome_version_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ClientMetadata_Browser::chrome_version() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.Browser.chrome_version)
    return _internal_chrome_version();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientMetadata_Browser::set_chrome_version(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.chrome_version_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.Browser.chrome_version)
}
inline std::string* ClientMetadata_Browser::mutable_chrome_version()
{
    std::string* _s = _internal_mutable_chrome_version();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.Browser.chrome_version)
    return _s;
}
inline const std::string& ClientMetadata_Browser::_internal_chrome_version() const
{
    return _impl_.chrome_version_.Get();
}
inline void ClientMetadata_Browser::_internal_set_chrome_version(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.chrome_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Browser::_internal_mutable_chrome_version()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.chrome_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Browser::release_chrome_version()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.Browser.chrome_version)
    if (!_internal_has_chrome_version()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.chrome_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.chrome_version_.IsDefault()) {
        _impl_.chrome_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientMetadata_Browser::set_allocated_chrome_version(std::string* chrome_version)
{
    if (chrome_version != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.chrome_version_.SetAllocated(chrome_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.chrome_version_.IsDefault()) {
        _impl_.chrome_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.Browser.chrome_version)
}

// optional string machine_user = 4;
inline bool ClientMetadata_Browser::_internal_has_machine_user() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ClientMetadata_Browser::has_machine_user() const
{
    return _internal_has_machine_user();
}
inline void ClientMetadata_Browser::clear_machine_user()
{
    _impl_.machine_user_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ClientMetadata_Browser::machine_user() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.Browser.machine_user)
    return _internal_machine_user();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientMetadata_Browser::set_machine_user(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.machine_user_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.Browser.machine_user)
}
inline std::string* ClientMetadata_Browser::mutable_machine_user()
{
    std::string* _s = _internal_mutable_machine_user();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.Browser.machine_user)
    return _s;
}
inline const std::string& ClientMetadata_Browser::_internal_machine_user() const
{
    return _impl_.machine_user_.Get();
}
inline void ClientMetadata_Browser::_internal_set_machine_user(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.machine_user_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Browser::_internal_mutable_machine_user()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.machine_user_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Browser::release_machine_user()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.Browser.machine_user)
    if (!_internal_has_machine_user()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.machine_user_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.machine_user_.IsDefault()) {
        _impl_.machine_user_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientMetadata_Browser::set_allocated_machine_user(std::string* machine_user)
{
    if (machine_user != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.machine_user_.SetAllocated(machine_user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.machine_user_.IsDefault()) {
        _impl_.machine_user_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.Browser.machine_user)
}

// -------------------------------------------------------------------

// ClientMetadata_Device

// optional string dm_token = 1;
inline bool ClientMetadata_Device::_internal_has_dm_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ClientMetadata_Device::has_dm_token() const
{
    return _internal_has_dm_token();
}
inline void ClientMetadata_Device::clear_dm_token()
{
    _impl_.dm_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientMetadata_Device::dm_token() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.Device.dm_token)
    return _internal_dm_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientMetadata_Device::set_dm_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.dm_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.Device.dm_token)
}
inline std::string* ClientMetadata_Device::mutable_dm_token()
{
    std::string* _s = _internal_mutable_dm_token();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.Device.dm_token)
    return _s;
}
inline const std::string& ClientMetadata_Device::_internal_dm_token() const
{
    return _impl_.dm_token_.Get();
}
inline void ClientMetadata_Device::_internal_set_dm_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.dm_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Device::_internal_mutable_dm_token()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.dm_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Device::release_dm_token()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.Device.dm_token)
    if (!_internal_has_dm_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.dm_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.dm_token_.IsDefault()) {
        _impl_.dm_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientMetadata_Device::set_allocated_dm_token(std::string* dm_token)
{
    if (dm_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.dm_token_.SetAllocated(dm_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.dm_token_.IsDefault()) {
        _impl_.dm_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.Device.dm_token)
}

// optional string client_id = 2;
inline bool ClientMetadata_Device::_internal_has_client_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ClientMetadata_Device::has_client_id() const
{
    return _internal_has_client_id();
}
inline void ClientMetadata_Device::clear_client_id()
{
    _impl_.client_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientMetadata_Device::client_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.Device.client_id)
    return _internal_client_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientMetadata_Device::set_client_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.client_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.Device.client_id)
}
inline std::string* ClientMetadata_Device::mutable_client_id()
{
    std::string* _s = _internal_mutable_client_id();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.Device.client_id)
    return _s;
}
inline const std::string& ClientMetadata_Device::_internal_client_id() const
{
    return _impl_.client_id_.Get();
}
inline void ClientMetadata_Device::_internal_set_client_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Device::_internal_mutable_client_id()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Device::release_client_id()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.Device.client_id)
    if (!_internal_has_client_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.client_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.client_id_.IsDefault()) {
        _impl_.client_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientMetadata_Device::set_allocated_client_id(std::string* client_id)
{
    if (client_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.client_id_.IsDefault()) {
        _impl_.client_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.Device.client_id)
}

// optional string os_version = 3;
inline bool ClientMetadata_Device::_internal_has_os_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ClientMetadata_Device::has_os_version() const
{
    return _internal_has_os_version();
}
inline void ClientMetadata_Device::clear_os_version()
{
    _impl_.os_version_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ClientMetadata_Device::os_version() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.Device.os_version)
    return _internal_os_version();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientMetadata_Device::set_os_version(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.os_version_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.Device.os_version)
}
inline std::string* ClientMetadata_Device::mutable_os_version()
{
    std::string* _s = _internal_mutable_os_version();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.Device.os_version)
    return _s;
}
inline const std::string& ClientMetadata_Device::_internal_os_version() const
{
    return _impl_.os_version_.Get();
}
inline void ClientMetadata_Device::_internal_set_os_version(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.os_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Device::_internal_mutable_os_version()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.os_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Device::release_os_version()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.Device.os_version)
    if (!_internal_has_os_version()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.os_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.os_version_.IsDefault()) {
        _impl_.os_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientMetadata_Device::set_allocated_os_version(std::string* os_version)
{
    if (os_version != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.os_version_.SetAllocated(os_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.os_version_.IsDefault()) {
        _impl_.os_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.Device.os_version)
}

// optional string os_platform = 4;
inline bool ClientMetadata_Device::_internal_has_os_platform() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ClientMetadata_Device::has_os_platform() const
{
    return _internal_has_os_platform();
}
inline void ClientMetadata_Device::clear_os_platform()
{
    _impl_.os_platform_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ClientMetadata_Device::os_platform() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.Device.os_platform)
    return _internal_os_platform();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientMetadata_Device::set_os_platform(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.os_platform_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.Device.os_platform)
}
inline std::string* ClientMetadata_Device::mutable_os_platform()
{
    std::string* _s = _internal_mutable_os_platform();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.Device.os_platform)
    return _s;
}
inline const std::string& ClientMetadata_Device::_internal_os_platform() const
{
    return _impl_.os_platform_.Get();
}
inline void ClientMetadata_Device::_internal_set_os_platform(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.os_platform_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Device::_internal_mutable_os_platform()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.os_platform_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Device::release_os_platform()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.Device.os_platform)
    if (!_internal_has_os_platform()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.os_platform_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.os_platform_.IsDefault()) {
        _impl_.os_platform_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientMetadata_Device::set_allocated_os_platform(std::string* os_platform)
{
    if (os_platform != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.os_platform_.SetAllocated(os_platform, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.os_platform_.IsDefault()) {
        _impl_.os_platform_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.Device.os_platform)
}

// optional string name = 5;
inline bool ClientMetadata_Device::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool ClientMetadata_Device::has_name() const
{
    return _internal_has_name();
}
inline void ClientMetadata_Device::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ClientMetadata_Device::name() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.Device.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientMetadata_Device::set_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.Device.name)
}
inline std::string* ClientMetadata_Device::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.Device.name)
    return _s;
}
inline const std::string& ClientMetadata_Device::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void ClientMetadata_Device::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Device::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Device::release_name()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.Device.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000010u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientMetadata_Device::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.Device.name)
}

// -------------------------------------------------------------------

// ClientMetadata_Profile

// optional string dm_token = 1;
inline bool ClientMetadata_Profile::_internal_has_dm_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ClientMetadata_Profile::has_dm_token() const
{
    return _internal_has_dm_token();
}
inline void ClientMetadata_Profile::clear_dm_token()
{
    _impl_.dm_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientMetadata_Profile::dm_token() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.Profile.dm_token)
    return _internal_dm_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientMetadata_Profile::set_dm_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.dm_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.Profile.dm_token)
}
inline std::string* ClientMetadata_Profile::mutable_dm_token()
{
    std::string* _s = _internal_mutable_dm_token();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.Profile.dm_token)
    return _s;
}
inline const std::string& ClientMetadata_Profile::_internal_dm_token() const
{
    return _impl_.dm_token_.Get();
}
inline void ClientMetadata_Profile::_internal_set_dm_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.dm_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Profile::_internal_mutable_dm_token()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.dm_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Profile::release_dm_token()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.Profile.dm_token)
    if (!_internal_has_dm_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.dm_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.dm_token_.IsDefault()) {
        _impl_.dm_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientMetadata_Profile::set_allocated_dm_token(std::string* dm_token)
{
    if (dm_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.dm_token_.SetAllocated(dm_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.dm_token_.IsDefault()) {
        _impl_.dm_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.Profile.dm_token)
}

// optional string gaia_email = 2;
inline bool ClientMetadata_Profile::_internal_has_gaia_email() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ClientMetadata_Profile::has_gaia_email() const
{
    return _internal_has_gaia_email();
}
inline void ClientMetadata_Profile::clear_gaia_email()
{
    _impl_.gaia_email_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientMetadata_Profile::gaia_email() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.Profile.gaia_email)
    return _internal_gaia_email();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientMetadata_Profile::set_gaia_email(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.gaia_email_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.Profile.gaia_email)
}
inline std::string* ClientMetadata_Profile::mutable_gaia_email()
{
    std::string* _s = _internal_mutable_gaia_email();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.Profile.gaia_email)
    return _s;
}
inline const std::string& ClientMetadata_Profile::_internal_gaia_email() const
{
    return _impl_.gaia_email_.Get();
}
inline void ClientMetadata_Profile::_internal_set_gaia_email(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.gaia_email_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Profile::_internal_mutable_gaia_email()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.gaia_email_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Profile::release_gaia_email()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.Profile.gaia_email)
    if (!_internal_has_gaia_email()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.gaia_email_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.gaia_email_.IsDefault()) {
        _impl_.gaia_email_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientMetadata_Profile::set_allocated_gaia_email(std::string* gaia_email)
{
    if (gaia_email != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.gaia_email_.SetAllocated(gaia_email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.gaia_email_.IsDefault()) {
        _impl_.gaia_email_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.Profile.gaia_email)
}

// optional string profile_path = 3;
inline bool ClientMetadata_Profile::_internal_has_profile_path() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ClientMetadata_Profile::has_profile_path() const
{
    return _internal_has_profile_path();
}
inline void ClientMetadata_Profile::clear_profile_path()
{
    _impl_.profile_path_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ClientMetadata_Profile::profile_path() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.Profile.profile_path)
    return _internal_profile_path();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientMetadata_Profile::set_profile_path(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.profile_path_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.Profile.profile_path)
}
inline std::string* ClientMetadata_Profile::mutable_profile_path()
{
    std::string* _s = _internal_mutable_profile_path();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.Profile.profile_path)
    return _s;
}
inline const std::string& ClientMetadata_Profile::_internal_profile_path() const
{
    return _impl_.profile_path_.Get();
}
inline void ClientMetadata_Profile::_internal_set_profile_path(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.profile_path_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Profile::_internal_mutable_profile_path()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.profile_path_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Profile::release_profile_path()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.Profile.profile_path)
    if (!_internal_has_profile_path()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.profile_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.profile_path_.IsDefault()) {
        _impl_.profile_path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientMetadata_Profile::set_allocated_profile_path(std::string* profile_path)
{
    if (profile_path != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.profile_path_.SetAllocated(profile_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.profile_path_.IsDefault()) {
        _impl_.profile_path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.Profile.profile_path)
}

// optional string profile_name = 4;
inline bool ClientMetadata_Profile::_internal_has_profile_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ClientMetadata_Profile::has_profile_name() const
{
    return _internal_has_profile_name();
}
inline void ClientMetadata_Profile::clear_profile_name()
{
    _impl_.profile_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ClientMetadata_Profile::profile_name() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.Profile.profile_name)
    return _internal_profile_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientMetadata_Profile::set_profile_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.profile_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.Profile.profile_name)
}
inline std::string* ClientMetadata_Profile::mutable_profile_name()
{
    std::string* _s = _internal_mutable_profile_name();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.Profile.profile_name)
    return _s;
}
inline const std::string& ClientMetadata_Profile::_internal_profile_name() const
{
    return _impl_.profile_name_.Get();
}
inline void ClientMetadata_Profile::_internal_set_profile_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.profile_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Profile::_internal_mutable_profile_name()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.profile_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Profile::release_profile_name()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.Profile.profile_name)
    if (!_internal_has_profile_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.profile_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.profile_name_.IsDefault()) {
        _impl_.profile_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientMetadata_Profile::set_allocated_profile_name(std::string* profile_name)
{
    if (profile_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.profile_name_.SetAllocated(profile_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.profile_name_.IsDefault()) {
        _impl_.profile_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.Profile.profile_name)
}

// optional string client_id = 5;
inline bool ClientMetadata_Profile::_internal_has_client_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool ClientMetadata_Profile::has_client_id() const
{
    return _internal_has_client_id();
}
inline void ClientMetadata_Profile::clear_client_id()
{
    _impl_.client_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ClientMetadata_Profile::client_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.Profile.client_id)
    return _internal_client_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientMetadata_Profile::set_client_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.client_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.Profile.client_id)
}
inline std::string* ClientMetadata_Profile::mutable_client_id()
{
    std::string* _s = _internal_mutable_client_id();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.Profile.client_id)
    return _s;
}
inline const std::string& ClientMetadata_Profile::_internal_client_id() const
{
    return _impl_.client_id_.Get();
}
inline void ClientMetadata_Profile::_internal_set_client_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientMetadata_Profile::_internal_mutable_client_id()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    return _impl_.client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientMetadata_Profile::release_client_id()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.Profile.client_id)
    if (!_internal_has_client_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000010u;
    auto* p = _impl_.client_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.client_id_.IsDefault()) {
        _impl_.client_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientMetadata_Profile::set_allocated_client_id(std::string* client_id)
{
    if (client_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.client_id_.IsDefault()) {
        _impl_.client_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.Profile.client_id)
}

// -------------------------------------------------------------------

// ClientMetadata

// optional .enterprise_connectors.ClientMetadata.Browser browser = 1;
inline bool ClientMetadata::_internal_has_browser() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.browser_ != nullptr);
    return value;
}
inline bool ClientMetadata::has_browser() const
{
    return _internal_has_browser();
}
inline void ClientMetadata::clear_browser()
{
    if (_impl_.browser_ != nullptr)
        _impl_.browser_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::enterprise_connectors::ClientMetadata_Browser& ClientMetadata::_internal_browser() const
{
    const ::enterprise_connectors::ClientMetadata_Browser* p = _impl_.browser_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::enterprise_connectors::ClientMetadata_Browser&>(::enterprise_connectors::_ClientMetadata_Browser_default_instance_);
}
inline const ::enterprise_connectors::ClientMetadata_Browser& ClientMetadata::browser() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.browser)
    return _internal_browser();
}
inline void ClientMetadata::unsafe_arena_set_allocated_browser(::enterprise_connectors::ClientMetadata_Browser* browser)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.browser_);
    }
    _impl_.browser_ = browser;
    if (browser) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_connectors.ClientMetadata.browser)
}
inline ::enterprise_connectors::ClientMetadata_Browser* ClientMetadata::release_browser()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::enterprise_connectors::ClientMetadata_Browser* temp = _impl_.browser_;
    _impl_.browser_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::enterprise_connectors::ClientMetadata_Browser* ClientMetadata::unsafe_arena_release_browser()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.browser)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::enterprise_connectors::ClientMetadata_Browser* temp = _impl_.browser_;
    _impl_.browser_ = nullptr;
    return temp;
}
inline ::enterprise_connectors::ClientMetadata_Browser* ClientMetadata::_internal_mutable_browser()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.browser_ == nullptr) {
        auto* p = CreateMaybeMessage<::enterprise_connectors::ClientMetadata_Browser>(GetArenaForAllocation());
        _impl_.browser_ = p;
    }
    return _impl_.browser_;
}
inline ::enterprise_connectors::ClientMetadata_Browser* ClientMetadata::mutable_browser()
{
    ::enterprise_connectors::ClientMetadata_Browser* _msg = _internal_mutable_browser();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.browser)
    return _msg;
}
inline void ClientMetadata::set_allocated_browser(::enterprise_connectors::ClientMetadata_Browser* browser)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.browser_;
    }
    if (browser) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(browser);
        if (message_arena != submessage_arena) {
            browser = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, browser, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.browser_ = browser;
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.browser)
}

// optional .enterprise_connectors.ClientMetadata.Device device = 2;
inline bool ClientMetadata::_internal_has_device() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.device_ != nullptr);
    return value;
}
inline bool ClientMetadata::has_device() const
{
    return _internal_has_device();
}
inline void ClientMetadata::clear_device()
{
    if (_impl_.device_ != nullptr)
        _impl_.device_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_connectors::ClientMetadata_Device& ClientMetadata::_internal_device() const
{
    const ::enterprise_connectors::ClientMetadata_Device* p = _impl_.device_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::enterprise_connectors::ClientMetadata_Device&>(::enterprise_connectors::_ClientMetadata_Device_default_instance_);
}
inline const ::enterprise_connectors::ClientMetadata_Device& ClientMetadata::device() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.device)
    return _internal_device();
}
inline void ClientMetadata::unsafe_arena_set_allocated_device(::enterprise_connectors::ClientMetadata_Device* device)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.device_);
    }
    _impl_.device_ = device;
    if (device) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_connectors.ClientMetadata.device)
}
inline ::enterprise_connectors::ClientMetadata_Device* ClientMetadata::release_device()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::enterprise_connectors::ClientMetadata_Device* temp = _impl_.device_;
    _impl_.device_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::enterprise_connectors::ClientMetadata_Device* ClientMetadata::unsafe_arena_release_device()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.device)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::enterprise_connectors::ClientMetadata_Device* temp = _impl_.device_;
    _impl_.device_ = nullptr;
    return temp;
}
inline ::enterprise_connectors::ClientMetadata_Device* ClientMetadata::_internal_mutable_device()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.device_ == nullptr) {
        auto* p = CreateMaybeMessage<::enterprise_connectors::ClientMetadata_Device>(GetArenaForAllocation());
        _impl_.device_ = p;
    }
    return _impl_.device_;
}
inline ::enterprise_connectors::ClientMetadata_Device* ClientMetadata::mutable_device()
{
    ::enterprise_connectors::ClientMetadata_Device* _msg = _internal_mutable_device();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.device)
    return _msg;
}
inline void ClientMetadata::set_allocated_device(::enterprise_connectors::ClientMetadata_Device* device)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.device_;
    }
    if (device) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(device);
        if (message_arena != submessage_arena) {
            device = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, device, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.device_ = device;
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.device)
}

// optional .enterprise_connectors.ClientMetadata.Profile profile = 3;
inline bool ClientMetadata::_internal_has_profile() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.profile_ != nullptr);
    return value;
}
inline bool ClientMetadata::has_profile() const
{
    return _internal_has_profile();
}
inline void ClientMetadata::clear_profile()
{
    if (_impl_.profile_ != nullptr)
        _impl_.profile_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::enterprise_connectors::ClientMetadata_Profile& ClientMetadata::_internal_profile() const
{
    const ::enterprise_connectors::ClientMetadata_Profile* p = _impl_.profile_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::enterprise_connectors::ClientMetadata_Profile&>(::enterprise_connectors::_ClientMetadata_Profile_default_instance_);
}
inline const ::enterprise_connectors::ClientMetadata_Profile& ClientMetadata::profile() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.profile)
    return _internal_profile();
}
inline void ClientMetadata::unsafe_arena_set_allocated_profile(::enterprise_connectors::ClientMetadata_Profile* profile)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.profile_);
    }
    _impl_.profile_ = profile;
    if (profile) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_connectors.ClientMetadata.profile)
}
inline ::enterprise_connectors::ClientMetadata_Profile* ClientMetadata::release_profile()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::enterprise_connectors::ClientMetadata_Profile* temp = _impl_.profile_;
    _impl_.profile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::enterprise_connectors::ClientMetadata_Profile* ClientMetadata::unsafe_arena_release_profile()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ClientMetadata.profile)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::enterprise_connectors::ClientMetadata_Profile* temp = _impl_.profile_;
    _impl_.profile_ = nullptr;
    return temp;
}
inline ::enterprise_connectors::ClientMetadata_Profile* ClientMetadata::_internal_mutable_profile()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.profile_ == nullptr) {
        auto* p = CreateMaybeMessage<::enterprise_connectors::ClientMetadata_Profile>(GetArenaForAllocation());
        _impl_.profile_ = p;
    }
    return _impl_.profile_;
}
inline ::enterprise_connectors::ClientMetadata_Profile* ClientMetadata::mutable_profile()
{
    ::enterprise_connectors::ClientMetadata_Profile* _msg = _internal_mutable_profile();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ClientMetadata.profile)
    return _msg;
}
inline void ClientMetadata::set_allocated_profile(::enterprise_connectors::ClientMetadata_Profile* profile)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.profile_;
    }
    if (profile) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(profile);
        if (message_arena != submessage_arena) {
            profile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, profile, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.profile_ = profile;
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ClientMetadata.profile)
}

// optional bool is_chrome_os_managed_guest_session = 4;
inline bool ClientMetadata::_internal_has_is_chrome_os_managed_guest_session() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ClientMetadata::has_is_chrome_os_managed_guest_session() const
{
    return _internal_has_is_chrome_os_managed_guest_session();
}
inline void ClientMetadata::clear_is_chrome_os_managed_guest_session()
{
    _impl_.is_chrome_os_managed_guest_session_ = false;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ClientMetadata::_internal_is_chrome_os_managed_guest_session() const
{
    return _impl_.is_chrome_os_managed_guest_session_;
}
inline bool ClientMetadata::is_chrome_os_managed_guest_session() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ClientMetadata.is_chrome_os_managed_guest_session)
    return _internal_is_chrome_os_managed_guest_session();
}
inline void ClientMetadata::_internal_set_is_chrome_os_managed_guest_session(bool value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.is_chrome_os_managed_guest_session_ = value;
}
inline void ClientMetadata::set_is_chrome_os_managed_guest_session(bool value)
{
    _internal_set_is_chrome_os_managed_guest_session(value);
    // @@protoc_insertion_point(field_set:enterprise_connectors.ClientMetadata.is_chrome_os_managed_guest_session)
}

// -------------------------------------------------------------------

// ContentAnalysisRequest

// optional string device_token = 1;
inline bool ContentAnalysisRequest::_internal_has_device_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ContentAnalysisRequest::has_device_token() const
{
    return _internal_has_device_token();
}
inline void ContentAnalysisRequest::clear_device_token()
{
    _impl_.device_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentAnalysisRequest::device_token() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.device_token)
    return _internal_device_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentAnalysisRequest::set_device_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.device_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisRequest.device_token)
}
inline std::string* ContentAnalysisRequest::mutable_device_token()
{
    std::string* _s = _internal_mutable_device_token();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisRequest.device_token)
    return _s;
}
inline const std::string& ContentAnalysisRequest::_internal_device_token() const
{
    return _impl_.device_token_.Get();
}
inline void ContentAnalysisRequest::_internal_set_device_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.device_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::_internal_mutable_device_token()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.device_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::release_device_token()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisRequest.device_token)
    if (!_internal_has_device_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.device_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.device_token_.IsDefault()) {
        _impl_.device_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentAnalysisRequest::set_allocated_device_token(std::string* device_token)
{
    if (device_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.device_token_.SetAllocated(device_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.device_token_.IsDefault()) {
        _impl_.device_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisRequest.device_token)
}

// optional string fcm_notification_token = 2;
inline bool ContentAnalysisRequest::_internal_has_fcm_notification_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ContentAnalysisRequest::has_fcm_notification_token() const
{
    return _internal_has_fcm_notification_token();
}
inline void ContentAnalysisRequest::clear_fcm_notification_token()
{
    _impl_.fcm_notification_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContentAnalysisRequest::fcm_notification_token() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.fcm_notification_token)
    return _internal_fcm_notification_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentAnalysisRequest::set_fcm_notification_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.fcm_notification_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisRequest.fcm_notification_token)
}
inline std::string* ContentAnalysisRequest::mutable_fcm_notification_token()
{
    std::string* _s = _internal_mutable_fcm_notification_token();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisRequest.fcm_notification_token)
    return _s;
}
inline const std::string& ContentAnalysisRequest::_internal_fcm_notification_token() const
{
    return _impl_.fcm_notification_token_.Get();
}
inline void ContentAnalysisRequest::_internal_set_fcm_notification_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.fcm_notification_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::_internal_mutable_fcm_notification_token()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.fcm_notification_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::release_fcm_notification_token()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisRequest.fcm_notification_token)
    if (!_internal_has_fcm_notification_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.fcm_notification_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.fcm_notification_token_.IsDefault()) {
        _impl_.fcm_notification_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentAnalysisRequest::set_allocated_fcm_notification_token(std::string* fcm_notification_token)
{
    if (fcm_notification_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.fcm_notification_token_.SetAllocated(fcm_notification_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.fcm_notification_token_.IsDefault()) {
        _impl_.fcm_notification_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisRequest.fcm_notification_token)
}

// optional string request_token = 5;
inline bool ContentAnalysisRequest::_internal_has_request_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ContentAnalysisRequest::has_request_token() const
{
    return _internal_has_request_token();
}
inline void ContentAnalysisRequest::clear_request_token()
{
    _impl_.request_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ContentAnalysisRequest::request_token() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.request_token)
    return _internal_request_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentAnalysisRequest::set_request_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.request_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisRequest.request_token)
}
inline std::string* ContentAnalysisRequest::mutable_request_token()
{
    std::string* _s = _internal_mutable_request_token();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisRequest.request_token)
    return _s;
}
inline const std::string& ContentAnalysisRequest::_internal_request_token() const
{
    return _impl_.request_token_.Get();
}
inline void ContentAnalysisRequest::_internal_set_request_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.request_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::_internal_mutable_request_token()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.request_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::release_request_token()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisRequest.request_token)
    if (!_internal_has_request_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.request_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.request_token_.IsDefault()) {
        _impl_.request_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentAnalysisRequest::set_allocated_request_token(std::string* request_token)
{
    if (request_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.request_token_.SetAllocated(request_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.request_token_.IsDefault()) {
        _impl_.request_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisRequest.request_token)
}

// optional .enterprise_connectors.AnalysisConnector analysis_connector = 9;
inline bool ContentAnalysisRequest::_internal_has_analysis_connector() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool ContentAnalysisRequest::has_analysis_connector() const
{
    return _internal_has_analysis_connector();
}
inline void ContentAnalysisRequest::clear_analysis_connector()
{
    _impl_.analysis_connector_ = 0;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::enterprise_connectors::AnalysisConnector ContentAnalysisRequest::_internal_analysis_connector() const
{
    return static_cast<::enterprise_connectors::AnalysisConnector>(_impl_.analysis_connector_);
}
inline ::enterprise_connectors::AnalysisConnector ContentAnalysisRequest::analysis_connector() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.analysis_connector)
    return _internal_analysis_connector();
}
inline void ContentAnalysisRequest::_internal_set_analysis_connector(::enterprise_connectors::AnalysisConnector value)
{
    assert(::enterprise_connectors::AnalysisConnector_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.analysis_connector_ = value;
}
inline void ContentAnalysisRequest::set_analysis_connector(::enterprise_connectors::AnalysisConnector value)
{
    _internal_set_analysis_connector(value);
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisRequest.analysis_connector)
}

// optional .enterprise_connectors.ContentMetaData request_data = 10;
inline bool ContentAnalysisRequest::_internal_has_request_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.request_data_ != nullptr);
    return value;
}
inline bool ContentAnalysisRequest::has_request_data() const
{
    return _internal_has_request_data();
}
inline void ContentAnalysisRequest::clear_request_data()
{
    if (_impl_.request_data_ != nullptr)
        _impl_.request_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::enterprise_connectors::ContentMetaData& ContentAnalysisRequest::_internal_request_data() const
{
    const ::enterprise_connectors::ContentMetaData* p = _impl_.request_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::enterprise_connectors::ContentMetaData&>(::enterprise_connectors::_ContentMetaData_default_instance_);
}
inline const ::enterprise_connectors::ContentMetaData& ContentAnalysisRequest::request_data() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.request_data)
    return _internal_request_data();
}
inline void ContentAnalysisRequest::unsafe_arena_set_allocated_request_data(::enterprise_connectors::ContentMetaData* request_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_data_);
    }
    _impl_.request_data_ = request_data;
    if (request_data) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_connectors.ContentAnalysisRequest.request_data)
}
inline ::enterprise_connectors::ContentMetaData* ContentAnalysisRequest::release_request_data()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::enterprise_connectors::ContentMetaData* temp = _impl_.request_data_;
    _impl_.request_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::enterprise_connectors::ContentMetaData* ContentAnalysisRequest::unsafe_arena_release_request_data()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisRequest.request_data)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::enterprise_connectors::ContentMetaData* temp = _impl_.request_data_;
    _impl_.request_data_ = nullptr;
    return temp;
}
inline ::enterprise_connectors::ContentMetaData* ContentAnalysisRequest::_internal_mutable_request_data()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.request_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::enterprise_connectors::ContentMetaData>(GetArenaForAllocation());
        _impl_.request_data_ = p;
    }
    return _impl_.request_data_;
}
inline ::enterprise_connectors::ContentMetaData* ContentAnalysisRequest::mutable_request_data()
{
    ::enterprise_connectors::ContentMetaData* _msg = _internal_mutable_request_data();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisRequest.request_data)
    return _msg;
}
inline void ContentAnalysisRequest::set_allocated_request_data(::enterprise_connectors::ContentMetaData* request_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.request_data_;
    }
    if (request_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_data);
        if (message_arena != submessage_arena) {
            request_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, request_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.request_data_ = request_data;
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisRequest.request_data)
}

// repeated string tags = 11;
inline int ContentAnalysisRequest::_internal_tags_size() const
{
    return _impl_.tags_.size();
}
inline int ContentAnalysisRequest::tags_size() const
{
    return _internal_tags_size();
}
inline void ContentAnalysisRequest::clear_tags()
{
    _impl_.tags_.Clear();
}
inline std::string* ContentAnalysisRequest::add_tags()
{
    std::string* _s = _internal_add_tags();
    // @@protoc_insertion_point(field_add_mutable:enterprise_connectors.ContentAnalysisRequest.tags)
    return _s;
}
inline const std::string& ContentAnalysisRequest::_internal_tags(int index) const
{
    return _impl_.tags_.Get(index);
}
inline const std::string& ContentAnalysisRequest::tags(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.tags)
    return _internal_tags(index);
}
inline std::string* ContentAnalysisRequest::mutable_tags(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisRequest.tags)
    return _impl_.tags_.Mutable(index);
}
inline void ContentAnalysisRequest::set_tags(int index, const std::string& value)
{
    _impl_.tags_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisRequest.tags)
}
inline void ContentAnalysisRequest::set_tags(int index, std::string&& value)
{
    _impl_.tags_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisRequest.tags)
}
inline void ContentAnalysisRequest::set_tags(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.tags_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:enterprise_connectors.ContentAnalysisRequest.tags)
}
inline void ContentAnalysisRequest::set_tags(int index, const char* value, size_t size)
{
    _impl_.tags_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:enterprise_connectors.ContentAnalysisRequest.tags)
}
inline std::string* ContentAnalysisRequest::_internal_add_tags()
{
    return _impl_.tags_.Add();
}
inline void ContentAnalysisRequest::add_tags(const std::string& value)
{
    _impl_.tags_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:enterprise_connectors.ContentAnalysisRequest.tags)
}
inline void ContentAnalysisRequest::add_tags(std::string&& value)
{
    _impl_.tags_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:enterprise_connectors.ContentAnalysisRequest.tags)
}
inline void ContentAnalysisRequest::add_tags(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.tags_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:enterprise_connectors.ContentAnalysisRequest.tags)
}
inline void ContentAnalysisRequest::add_tags(const char* value, size_t size)
{
    _impl_.tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:enterprise_connectors.ContentAnalysisRequest.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ContentAnalysisRequest::tags() const
{
    // @@protoc_insertion_point(field_list:enterprise_connectors.ContentAnalysisRequest.tags)
    return _impl_.tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ContentAnalysisRequest::mutable_tags()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_connectors.ContentAnalysisRequest.tags)
    return &_impl_.tags_;
}

// optional .enterprise_connectors.ClientMetadata client_metadata = 12;
inline bool ContentAnalysisRequest::_internal_has_client_metadata() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.client_metadata_ != nullptr);
    return value;
}
inline bool ContentAnalysisRequest::has_client_metadata() const
{
    return _internal_has_client_metadata();
}
inline void ContentAnalysisRequest::clear_client_metadata()
{
    if (_impl_.client_metadata_ != nullptr)
        _impl_.client_metadata_->Clear();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::enterprise_connectors::ClientMetadata& ContentAnalysisRequest::_internal_client_metadata() const
{
    const ::enterprise_connectors::ClientMetadata* p = _impl_.client_metadata_;
    return p != nullptr ? *p : reinterpret_cast<const ::enterprise_connectors::ClientMetadata&>(::enterprise_connectors::_ClientMetadata_default_instance_);
}
inline const ::enterprise_connectors::ClientMetadata& ContentAnalysisRequest::client_metadata() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.client_metadata)
    return _internal_client_metadata();
}
inline void ContentAnalysisRequest::unsafe_arena_set_allocated_client_metadata(::enterprise_connectors::ClientMetadata* client_metadata)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_metadata_);
    }
    _impl_.client_metadata_ = client_metadata;
    if (client_metadata) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_connectors.ContentAnalysisRequest.client_metadata)
}
inline ::enterprise_connectors::ClientMetadata* ContentAnalysisRequest::release_client_metadata()
{
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::enterprise_connectors::ClientMetadata* temp = _impl_.client_metadata_;
    _impl_.client_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::enterprise_connectors::ClientMetadata* ContentAnalysisRequest::unsafe_arena_release_client_metadata()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisRequest.client_metadata)
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::enterprise_connectors::ClientMetadata* temp = _impl_.client_metadata_;
    _impl_.client_metadata_ = nullptr;
    return temp;
}
inline ::enterprise_connectors::ClientMetadata* ContentAnalysisRequest::_internal_mutable_client_metadata()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    if (_impl_.client_metadata_ == nullptr) {
        auto* p = CreateMaybeMessage<::enterprise_connectors::ClientMetadata>(GetArenaForAllocation());
        _impl_.client_metadata_ = p;
    }
    return _impl_.client_metadata_;
}
inline ::enterprise_connectors::ClientMetadata* ContentAnalysisRequest::mutable_client_metadata()
{
    ::enterprise_connectors::ClientMetadata* _msg = _internal_mutable_client_metadata();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisRequest.client_metadata)
    return _msg;
}
inline void ContentAnalysisRequest::set_allocated_client_metadata(::enterprise_connectors::ClientMetadata* client_metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.client_metadata_;
    }
    if (client_metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_metadata);
        if (message_arena != submessage_arena) {
            client_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, client_metadata, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.client_metadata_ = client_metadata;
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisRequest.client_metadata)
}

// string text_content = 13;
inline bool ContentAnalysisRequest::_internal_has_text_content() const
{
    return content_data_case() == kTextContent;
}
inline bool ContentAnalysisRequest::has_text_content() const
{
    return _internal_has_text_content();
}
inline void ContentAnalysisRequest::set_has_text_content()
{
    _impl_._oneof_case_[0] = kTextContent;
}
inline void ContentAnalysisRequest::clear_text_content()
{
    if (_internal_has_text_content()) {
        _impl_.content_data_.text_content_.Destroy();
        clear_has_content_data();
    }
}
inline const std::string& ContentAnalysisRequest::text_content() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.text_content)
    return _internal_text_content();
}
template <typename ArgT0, typename... ArgT> inline void ContentAnalysisRequest::set_text_content(ArgT0&& arg0, ArgT... args)
{
    if (!_internal_has_text_content()) {
        clear_content_data();
        set_has_text_content();
        _impl_.content_data_.text_content_.InitDefault();
    }
    _impl_.content_data_.text_content_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisRequest.text_content)
}
inline std::string* ContentAnalysisRequest::mutable_text_content()
{
    std::string* _s = _internal_mutable_text_content();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisRequest.text_content)
    return _s;
}
inline const std::string& ContentAnalysisRequest::_internal_text_content() const
{
    if (_internal_has_text_content()) {
        return _impl_.content_data_.text_content_.Get();
    }
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ContentAnalysisRequest::_internal_set_text_content(const std::string& value)
{
    if (!_internal_has_text_content()) {
        clear_content_data();
        set_has_text_content();
        _impl_.content_data_.text_content_.InitDefault();
    }
    _impl_.content_data_.text_content_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::_internal_mutable_text_content()
{
    if (!_internal_has_text_content()) {
        clear_content_data();
        set_has_text_content();
        _impl_.content_data_.text_content_.InitDefault();
    }
    return _impl_.content_data_.text_content_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::release_text_content()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisRequest.text_content)
    if (_internal_has_text_content()) {
        clear_has_content_data();
        return _impl_.content_data_.text_content_.Release();
    } else {
        return nullptr;
    }
}
inline void ContentAnalysisRequest::set_allocated_text_content(std::string* text_content)
{
    if (has_content_data()) {
        clear_content_data();
    }
    if (text_content != nullptr) {
        set_has_text_content();
        _impl_.content_data_.text_content_.InitAllocated(text_content, GetArenaForAllocation());
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisRequest.text_content)
}

// string file_path = 14;
inline bool ContentAnalysisRequest::_internal_has_file_path() const
{
    return content_data_case() == kFilePath;
}
inline bool ContentAnalysisRequest::has_file_path() const
{
    return _internal_has_file_path();
}
inline void ContentAnalysisRequest::set_has_file_path()
{
    _impl_._oneof_case_[0] = kFilePath;
}
inline void ContentAnalysisRequest::clear_file_path()
{
    if (_internal_has_file_path()) {
        _impl_.content_data_.file_path_.Destroy();
        clear_has_content_data();
    }
}
inline const std::string& ContentAnalysisRequest::file_path() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.file_path)
    return _internal_file_path();
}
template <typename ArgT0, typename... ArgT> inline void ContentAnalysisRequest::set_file_path(ArgT0&& arg0, ArgT... args)
{
    if (!_internal_has_file_path()) {
        clear_content_data();
        set_has_file_path();
        _impl_.content_data_.file_path_.InitDefault();
    }
    _impl_.content_data_.file_path_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisRequest.file_path)
}
inline std::string* ContentAnalysisRequest::mutable_file_path()
{
    std::string* _s = _internal_mutable_file_path();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisRequest.file_path)
    return _s;
}
inline const std::string& ContentAnalysisRequest::_internal_file_path() const
{
    if (_internal_has_file_path()) {
        return _impl_.content_data_.file_path_.Get();
    }
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void ContentAnalysisRequest::_internal_set_file_path(const std::string& value)
{
    if (!_internal_has_file_path()) {
        clear_content_data();
        set_has_file_path();
        _impl_.content_data_.file_path_.InitDefault();
    }
    _impl_.content_data_.file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::_internal_mutable_file_path()
{
    if (!_internal_has_file_path()) {
        clear_content_data();
        set_has_file_path();
        _impl_.content_data_.file_path_.InitDefault();
    }
    return _impl_.content_data_.file_path_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::release_file_path()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisRequest.file_path)
    if (_internal_has_file_path()) {
        clear_has_content_data();
        return _impl_.content_data_.file_path_.Release();
    } else {
        return nullptr;
    }
}
inline void ContentAnalysisRequest::set_allocated_file_path(std::string* file_path)
{
    if (has_content_data()) {
        clear_content_data();
    }
    if (file_path != nullptr) {
        set_has_file_path();
        _impl_.content_data_.file_path_.InitAllocated(file_path, GetArenaForAllocation());
    }
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisRequest.file_path)
}

// optional int64 expires_at = 15;
inline bool ContentAnalysisRequest::_internal_has_expires_at() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool ContentAnalysisRequest::has_expires_at() const
{
    return _internal_has_expires_at();
}
inline void ContentAnalysisRequest::clear_expires_at()
{
    _impl_.expires_at_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int64_t ContentAnalysisRequest::_internal_expires_at() const
{
    return _impl_.expires_at_;
}
inline int64_t ContentAnalysisRequest::expires_at() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.expires_at)
    return _internal_expires_at();
}
inline void ContentAnalysisRequest::_internal_set_expires_at(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.expires_at_ = value;
}
inline void ContentAnalysisRequest::set_expires_at(int64_t value)
{
    _internal_set_expires_at(value);
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisRequest.expires_at)
}

// optional string user_action_id = 16;
inline bool ContentAnalysisRequest::_internal_has_user_action_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ContentAnalysisRequest::has_user_action_id() const
{
    return _internal_has_user_action_id();
}
inline void ContentAnalysisRequest::clear_user_action_id()
{
    _impl_.user_action_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ContentAnalysisRequest::user_action_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.user_action_id)
    return _internal_user_action_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentAnalysisRequest::set_user_action_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.user_action_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisRequest.user_action_id)
}
inline std::string* ContentAnalysisRequest::mutable_user_action_id()
{
    std::string* _s = _internal_mutable_user_action_id();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisRequest.user_action_id)
    return _s;
}
inline const std::string& ContentAnalysisRequest::_internal_user_action_id() const
{
    return _impl_.user_action_id_.Get();
}
inline void ContentAnalysisRequest::_internal_set_user_action_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.user_action_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::_internal_mutable_user_action_id()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.user_action_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisRequest::release_user_action_id()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisRequest.user_action_id)
    if (!_internal_has_user_action_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.user_action_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.user_action_id_.IsDefault()) {
        _impl_.user_action_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentAnalysisRequest::set_allocated_user_action_id(std::string* user_action_id)
{
    if (user_action_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.user_action_id_.SetAllocated(user_action_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.user_action_id_.IsDefault()) {
        _impl_.user_action_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisRequest.user_action_id)
}

// optional int64 user_action_requests_count = 17;
inline bool ContentAnalysisRequest::_internal_has_user_action_requests_count() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool ContentAnalysisRequest::has_user_action_requests_count() const
{
    return _internal_has_user_action_requests_count();
}
inline void ContentAnalysisRequest::clear_user_action_requests_count()
{
    _impl_.user_action_requests_count_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t ContentAnalysisRequest::_internal_user_action_requests_count() const
{
    return _impl_.user_action_requests_count_;
}
inline int64_t ContentAnalysisRequest::user_action_requests_count() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.user_action_requests_count)
    return _internal_user_action_requests_count();
}
inline void ContentAnalysisRequest::_internal_set_user_action_requests_count(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.user_action_requests_count_ = value;
}
inline void ContentAnalysisRequest::set_user_action_requests_count(int64_t value)
{
    _internal_set_user_action_requests_count(value);
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisRequest.user_action_requests_count)
}

// optional .enterprise_connectors.ContentAnalysisRequest.Reason reason = 19;
inline bool ContentAnalysisRequest::_internal_has_reason() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool ContentAnalysisRequest::has_reason() const
{
    return _internal_has_reason();
}
inline void ContentAnalysisRequest::clear_reason()
{
    _impl_.reason_ = 0;
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::enterprise_connectors::ContentAnalysisRequest_Reason ContentAnalysisRequest::_internal_reason() const
{
    return static_cast<::enterprise_connectors::ContentAnalysisRequest_Reason>(_impl_.reason_);
}
inline ::enterprise_connectors::ContentAnalysisRequest_Reason ContentAnalysisRequest::reason() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.reason)
    return _internal_reason();
}
inline void ContentAnalysisRequest::_internal_set_reason(::enterprise_connectors::ContentAnalysisRequest_Reason value)
{
    assert(::enterprise_connectors::ContentAnalysisRequest_Reason_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.reason_ = value;
}
inline void ContentAnalysisRequest::set_reason(::enterprise_connectors::ContentAnalysisRequest_Reason value)
{
    _internal_set_reason(value);
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisRequest.reason)
}

// optional bool blocking = 20;
inline bool ContentAnalysisRequest::_internal_has_blocking() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    return value;
}
inline bool ContentAnalysisRequest::has_blocking() const
{
    return _internal_has_blocking();
}
inline void ContentAnalysisRequest::clear_blocking()
{
    _impl_.blocking_ = false;
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool ContentAnalysisRequest::_internal_blocking() const
{
    return _impl_.blocking_;
}
inline bool ContentAnalysisRequest::blocking() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.blocking)
    return _internal_blocking();
}
inline void ContentAnalysisRequest::_internal_set_blocking(bool value)
{
    _impl_._has_bits_[0] |= 0x00000400u;
    _impl_.blocking_ = value;
}
inline void ContentAnalysisRequest::set_blocking(bool value)
{
    _internal_set_blocking(value);
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisRequest.blocking)
}

// optional bool require_metadata_verdict = 21;
inline bool ContentAnalysisRequest::_internal_has_require_metadata_verdict() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    return value;
}
inline bool ContentAnalysisRequest::has_require_metadata_verdict() const
{
    return _internal_has_require_metadata_verdict();
}
inline void ContentAnalysisRequest::clear_require_metadata_verdict()
{
    _impl_.require_metadata_verdict_ = false;
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool ContentAnalysisRequest::_internal_require_metadata_verdict() const
{
    return _impl_.require_metadata_verdict_;
}
inline bool ContentAnalysisRequest::require_metadata_verdict() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisRequest.require_metadata_verdict)
    return _internal_require_metadata_verdict();
}
inline void ContentAnalysisRequest::_internal_set_require_metadata_verdict(bool value)
{
    _impl_._has_bits_[0] |= 0x00000800u;
    _impl_.require_metadata_verdict_ = value;
}
inline void ContentAnalysisRequest::set_require_metadata_verdict(bool value)
{
    _internal_set_require_metadata_verdict(value);
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisRequest.require_metadata_verdict)
}

inline bool ContentAnalysisRequest::has_content_data() const
{
    return content_data_case() != CONTENT_DATA_NOT_SET;
}
inline void ContentAnalysisRequest::clear_has_content_data()
{
    _impl_._oneof_case_[0] = CONTENT_DATA_NOT_SET;
}
inline ContentAnalysisRequest::ContentDataCase ContentAnalysisRequest::content_data_case() const
{
    return ContentAnalysisRequest::ContentDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ContentAnalysisResponse_Result_CustomMessage

// optional string learn_more_url = 1;
inline bool ContentAnalysisResponse_Result_CustomMessage::_internal_has_learn_more_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ContentAnalysisResponse_Result_CustomMessage::has_learn_more_url() const
{
    return _internal_has_learn_more_url();
}
inline void ContentAnalysisResponse_Result_CustomMessage::clear_learn_more_url()
{
    _impl_.learn_more_url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentAnalysisResponse_Result_CustomMessage::learn_more_url() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage.learn_more_url)
    return _internal_learn_more_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ContentAnalysisResponse_Result_CustomMessage::set_learn_more_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.learn_more_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage.learn_more_url)
}
inline std::string* ContentAnalysisResponse_Result_CustomMessage::mutable_learn_more_url()
{
    std::string* _s = _internal_mutable_learn_more_url();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage.learn_more_url)
    return _s;
}
inline const std::string& ContentAnalysisResponse_Result_CustomMessage::_internal_learn_more_url() const
{
    return _impl_.learn_more_url_.Get();
}
inline void ContentAnalysisResponse_Result_CustomMessage::_internal_set_learn_more_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.learn_more_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_CustomMessage::_internal_mutable_learn_more_url()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.learn_more_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_CustomMessage::release_learn_more_url()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage.learn_more_url)
    if (!_internal_has_learn_more_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.learn_more_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.learn_more_url_.IsDefault()) {
        _impl_.learn_more_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentAnalysisResponse_Result_CustomMessage::set_allocated_learn_more_url(std::string* learn_more_url)
{
    if (learn_more_url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.learn_more_url_.SetAllocated(learn_more_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.learn_more_url_.IsDefault()) {
        _impl_.learn_more_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage.learn_more_url)
}

// optional string message = 2;
inline bool ContentAnalysisResponse_Result_CustomMessage::_internal_has_message() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ContentAnalysisResponse_Result_CustomMessage::has_message() const
{
    return _internal_has_message();
}
inline void ContentAnalysisResponse_Result_CustomMessage::clear_message()
{
    _impl_.message_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContentAnalysisResponse_Result_CustomMessage::message() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage.message)
    return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ContentAnalysisResponse_Result_CustomMessage::set_message(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.message_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage.message)
}
inline std::string* ContentAnalysisResponse_Result_CustomMessage::mutable_message()
{
    std::string* _s = _internal_mutable_message();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage.message)
    return _s;
}
inline const std::string& ContentAnalysisResponse_Result_CustomMessage::_internal_message() const
{
    return _impl_.message_.Get();
}
inline void ContentAnalysisResponse_Result_CustomMessage::_internal_set_message(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_CustomMessage::_internal_mutable_message()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_CustomMessage::release_message()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage.message)
    if (!_internal_has_message()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.message_.IsDefault()) {
        _impl_.message_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentAnalysisResponse_Result_CustomMessage::set_allocated_message(std::string* message)
{
    if (message != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.message_.IsDefault()) {
        _impl_.message_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage.message)
}

// -------------------------------------------------------------------

// ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment

// optional string text = 1;
inline bool ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::_internal_has_text() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::has_text() const
{
    return _internal_has_text();
}
inline void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::clear_text()
{
    _impl_.text_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::text() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment.text)
    return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::set_text(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.text_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment.text)
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::mutable_text()
{
    std::string* _s = _internal_mutable_text();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment.text)
    return _s;
}
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::_internal_text() const
{
    return _impl_.text_.Get();
}
inline void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::_internal_set_text(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::_internal_mutable_text()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::release_text()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment.text)
    if (!_internal_has_text()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.text_.IsDefault()) {
        _impl_.text_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::set_allocated_text(std::string* text)
{
    if (text != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.text_.IsDefault()) {
        _impl_.text_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment.text)
}

// optional string link = 2;
inline bool ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::_internal_has_link() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::has_link() const
{
    return _internal_has_link();
}
inline void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::clear_link()
{
    _impl_.link_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::link() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment.link)
    return _internal_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::set_link(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.link_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment.link)
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::mutable_link()
{
    std::string* _s = _internal_mutable_link();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment.link)
    return _s;
}
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::_internal_link() const
{
    return _impl_.link_.Get();
}
inline void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::_internal_set_link(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.link_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::_internal_mutable_link()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.link_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::release_link()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment.link)
    if (!_internal_has_link()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.link_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.link_.IsDefault()) {
        _impl_.link_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::set_allocated_link(std::string* link)
{
    if (link != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.link_.SetAllocated(link, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.link_.IsDefault()) {
        _impl_.link_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment.link)
}

// -------------------------------------------------------------------

// ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage

// repeated .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment message_segments = 1;
inline int ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::_internal_message_segments_size() const
{
    return _impl_.message_segments_.size();
}
inline int ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::message_segments_size() const
{
    return _internal_message_segments_size();
}
inline void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::clear_message_segments()
{
    _impl_.message_segments_.Clear();
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment*
ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::mutable_message_segments(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage.message_segments)
    return _impl_.message_segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment>*
ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::mutable_message_segments()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage.message_segments)
    return &_impl_.message_segments_;
}
inline const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment&
ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::_internal_message_segments(int index) const
{
    return _impl_.message_segments_.Get(index);
}
inline const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment&
ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::message_segments(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage.message_segments)
    return _internal_message_segments(index);
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment*
ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::_internal_add_message_segments()
{
    return _impl_.message_segments_.Add();
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment*
ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::add_message_segments()
{
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment* _add = _internal_add_message_segments();
    // @@protoc_insertion_point(field_add:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage.message_segments)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment>&
ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::message_segments() const
{
    // @@protoc_insertion_point(field_list:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage.message_segments)
    return _impl_.message_segments_;
}

// -------------------------------------------------------------------

// ContentAnalysisResponse_Result_TriggeredRule

// optional .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.Action action = 1;
inline bool ContentAnalysisResponse_Result_TriggeredRule::_internal_has_action() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool ContentAnalysisResponse_Result_TriggeredRule::has_action() const
{
    return _internal_has_action();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::clear_action()
{
    _impl_.action_ = 0;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::_internal_action() const
{
    return static_cast<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action>(_impl_.action_);
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::action() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.action)
    return _internal_action();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::_internal_set_action(
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action value)
{
    assert(::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.action_ = value;
}
inline void ContentAnalysisResponse_Result_TriggeredRule::set_action(::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action value)
{
    _internal_set_action(value);
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.action)
}

// optional string rule_name = 2;
inline bool ContentAnalysisResponse_Result_TriggeredRule::_internal_has_rule_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ContentAnalysisResponse_Result_TriggeredRule::has_rule_name() const
{
    return _internal_has_rule_name();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::clear_rule_name()
{
    _impl_.rule_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule::rule_name() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.rule_name)
    return _internal_rule_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ContentAnalysisResponse_Result_TriggeredRule::set_rule_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.rule_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.rule_name)
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::mutable_rule_name()
{
    std::string* _s = _internal_mutable_rule_name();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.rule_name)
    return _s;
}
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule::_internal_rule_name() const
{
    return _impl_.rule_name_.Get();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::_internal_set_rule_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.rule_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::_internal_mutable_rule_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.rule_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::release_rule_name()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.rule_name)
    if (!_internal_has_rule_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.rule_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.rule_name_.IsDefault()) {
        _impl_.rule_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentAnalysisResponse_Result_TriggeredRule::set_allocated_rule_name(std::string* rule_name)
{
    if (rule_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.rule_name_.SetAllocated(rule_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.rule_name_.IsDefault()) {
        _impl_.rule_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.rule_name)
}

// optional string rule_id = 3;
inline bool ContentAnalysisResponse_Result_TriggeredRule::_internal_has_rule_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ContentAnalysisResponse_Result_TriggeredRule::has_rule_id() const
{
    return _internal_has_rule_id();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::clear_rule_id()
{
    _impl_.rule_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule::rule_id() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.rule_id)
    return _internal_rule_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ContentAnalysisResponse_Result_TriggeredRule::set_rule_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.rule_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.rule_id)
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::mutable_rule_id()
{
    std::string* _s = _internal_mutable_rule_id();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.rule_id)
    return _s;
}
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule::_internal_rule_id() const
{
    return _impl_.rule_id_.Get();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::_internal_set_rule_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.rule_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::_internal_mutable_rule_id()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.rule_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::release_rule_id()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.rule_id)
    if (!_internal_has_rule_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.rule_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.rule_id_.IsDefault()) {
        _impl_.rule_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentAnalysisResponse_Result_TriggeredRule::set_allocated_rule_id(std::string* rule_id)
{
    if (rule_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.rule_id_.SetAllocated(rule_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.rule_id_.IsDefault()) {
        _impl_.rule_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.rule_id)
}

// optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 4 [deprecated = true];
inline bool ContentAnalysisResponse_Result_TriggeredRule::_internal_has_custom_message() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.custom_message_ != nullptr);
    return value;
}
inline bool ContentAnalysisResponse_Result_TriggeredRule::has_custom_message() const
{
    return _internal_has_custom_message();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::clear_custom_message()
{
    if (_impl_.custom_message_ != nullptr)
        _impl_.custom_message_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage&
ContentAnalysisResponse_Result_TriggeredRule::_internal_custom_message() const
{
    const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* p = _impl_.custom_message_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage&>(
                            ::enterprise_connectors::_ContentAnalysisResponse_Result_CustomMessage_default_instance_);
}
inline const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage& ContentAnalysisResponse_Result_TriggeredRule::custom_message() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.custom_message)
    return _internal_custom_message();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::unsafe_arena_set_allocated_custom_message(
    ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* custom_message)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.custom_message_);
    }
    _impl_.custom_message_ = custom_message;
    if (custom_message) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.custom_message)
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* ContentAnalysisResponse_Result_TriggeredRule::release_custom_message()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* temp = _impl_.custom_message_;
    _impl_.custom_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage*
ContentAnalysisResponse_Result_TriggeredRule::unsafe_arena_release_custom_message()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.custom_message)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* temp = _impl_.custom_message_;
    _impl_.custom_message_ = nullptr;
    return temp;
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* ContentAnalysisResponse_Result_TriggeredRule::_internal_mutable_custom_message()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.custom_message_ == nullptr) {
        auto* p = CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage>(GetArenaForAllocation());
        _impl_.custom_message_ = p;
    }
    return _impl_.custom_message_;
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* ContentAnalysisResponse_Result_TriggeredRule::mutable_custom_message()
{
    ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* _msg = _internal_mutable_custom_message();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.custom_message)
    return _msg;
}
inline void ContentAnalysisResponse_Result_TriggeredRule::set_allocated_custom_message(
    ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* custom_message)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.custom_message_;
    }
    if (custom_message) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(custom_message);
        if (message_arena != submessage_arena) {
            custom_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, custom_message, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.custom_message_ = custom_message;
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.custom_message)
}

// optional string url_category = 5;
inline bool ContentAnalysisResponse_Result_TriggeredRule::_internal_has_url_category() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ContentAnalysisResponse_Result_TriggeredRule::has_url_category() const
{
    return _internal_has_url_category();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::clear_url_category()
{
    _impl_.url_category_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule::url_category() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.url_category)
    return _internal_url_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ContentAnalysisResponse_Result_TriggeredRule::set_url_category(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.url_category_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.url_category)
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::mutable_url_category()
{
    std::string* _s = _internal_mutable_url_category();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.url_category)
    return _s;
}
inline const std::string& ContentAnalysisResponse_Result_TriggeredRule::_internal_url_category() const
{
    return _impl_.url_category_.Get();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::_internal_set_url_category(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.url_category_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::_internal_mutable_url_category()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.url_category_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result_TriggeredRule::release_url_category()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.url_category)
    if (!_internal_has_url_category()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.url_category_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_category_.IsDefault()) {
        _impl_.url_category_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentAnalysisResponse_Result_TriggeredRule::set_allocated_url_category(std::string* url_category)
{
    if (url_category != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.url_category_.SetAllocated(url_category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_category_.IsDefault()) {
        _impl_.url_category_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.url_category)
}

// optional .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage custom_rule_message = 6;
inline bool ContentAnalysisResponse_Result_TriggeredRule::_internal_has_custom_rule_message() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.custom_rule_message_ != nullptr);
    return value;
}
inline bool ContentAnalysisResponse_Result_TriggeredRule::has_custom_rule_message() const
{
    return _internal_has_custom_rule_message();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::clear_custom_rule_message()
{
    if (_impl_.custom_rule_message_ != nullptr)
        _impl_.custom_rule_message_->Clear();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage&
ContentAnalysisResponse_Result_TriggeredRule::_internal_custom_rule_message() const
{
    const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* p = _impl_.custom_rule_message_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage&>(
                            ::enterprise_connectors::_ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage_default_instance_);
}
inline const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage&
ContentAnalysisResponse_Result_TriggeredRule::custom_rule_message() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.custom_rule_message)
    return _internal_custom_rule_message();
}
inline void ContentAnalysisResponse_Result_TriggeredRule::unsafe_arena_set_allocated_custom_rule_message(
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* custom_rule_message)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.custom_rule_message_);
    }
    _impl_.custom_rule_message_ = custom_rule_message;
    if (custom_rule_message) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.custom_rule_message)
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage*
ContentAnalysisResponse_Result_TriggeredRule::release_custom_rule_message()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* temp = _impl_.custom_rule_message_;
    _impl_.custom_rule_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage*
ContentAnalysisResponse_Result_TriggeredRule::unsafe_arena_release_custom_rule_message()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.custom_rule_message)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* temp = _impl_.custom_rule_message_;
    _impl_.custom_rule_message_ = nullptr;
    return temp;
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage*
ContentAnalysisResponse_Result_TriggeredRule::_internal_mutable_custom_rule_message()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.custom_rule_message_ == nullptr) {
        auto* p = CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage>(GetArenaForAllocation());
        _impl_.custom_rule_message_ = p;
    }
    return _impl_.custom_rule_message_;
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage*
ContentAnalysisResponse_Result_TriggeredRule::mutable_custom_rule_message()
{
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* _msg = _internal_mutable_custom_rule_message();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.custom_rule_message)
    return _msg;
}
inline void ContentAnalysisResponse_Result_TriggeredRule::set_allocated_custom_rule_message(
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* custom_rule_message)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.custom_rule_message_;
    }
    if (custom_rule_message) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(custom_rule_message);
        if (message_arena != submessage_arena) {
            custom_rule_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, custom_rule_message, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.custom_rule_message_ = custom_rule_message;
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.custom_rule_message)
}

// -------------------------------------------------------------------

// ContentAnalysisResponse_Result

// optional string tag = 1;
inline bool ContentAnalysisResponse_Result::_internal_has_tag() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ContentAnalysisResponse_Result::has_tag() const
{
    return _internal_has_tag();
}
inline void ContentAnalysisResponse_Result::clear_tag()
{
    _impl_.tag_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentAnalysisResponse_Result::tag() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.tag)
    return _internal_tag();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentAnalysisResponse_Result::set_tag(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.tag_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisResponse.Result.tag)
}
inline std::string* ContentAnalysisResponse_Result::mutable_tag()
{
    std::string* _s = _internal_mutable_tag();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.Result.tag)
    return _s;
}
inline const std::string& ContentAnalysisResponse_Result::_internal_tag() const
{
    return _impl_.tag_.Get();
}
inline void ContentAnalysisResponse_Result::_internal_set_tag(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result::_internal_mutable_tag()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse_Result::release_tag()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisResponse.Result.tag)
    if (!_internal_has_tag()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.tag_.IsDefault()) {
        _impl_.tag_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentAnalysisResponse_Result::set_allocated_tag(std::string* tag)
{
    if (tag != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.tag_.IsDefault()) {
        _impl_.tag_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisResponse.Result.tag)
}

// optional .enterprise_connectors.ContentAnalysisResponse.Result.Status status = 2;
inline bool ContentAnalysisResponse_Result::_internal_has_status() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ContentAnalysisResponse_Result::has_status() const
{
    return _internal_has_status();
}
inline void ContentAnalysisResponse_Result::clear_status()
{
    _impl_.status_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result::_internal_status() const
{
    return static_cast<::enterprise_connectors::ContentAnalysisResponse_Result_Status>(_impl_.status_);
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result::status() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.status)
    return _internal_status();
}
inline void ContentAnalysisResponse_Result::_internal_set_status(::enterprise_connectors::ContentAnalysisResponse_Result_Status value)
{
    assert(::enterprise_connectors::ContentAnalysisResponse_Result_Status_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.status_ = value;
}
inline void ContentAnalysisResponse_Result::set_status(::enterprise_connectors::ContentAnalysisResponse_Result_Status value)
{
    _internal_set_status(value);
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisResponse.Result.status)
}

// repeated .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule triggered_rules = 3;
inline int ContentAnalysisResponse_Result::_internal_triggered_rules_size() const
{
    return _impl_.triggered_rules_.size();
}
inline int ContentAnalysisResponse_Result::triggered_rules_size() const
{
    return _internal_triggered_rules_size();
}
inline void ContentAnalysisResponse_Result::clear_triggered_rules()
{
    _impl_.triggered_rules_.Clear();
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule* ContentAnalysisResponse_Result::mutable_triggered_rules(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.Result.triggered_rules)
    return _impl_.triggered_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule>*
ContentAnalysisResponse_Result::mutable_triggered_rules()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_connectors.ContentAnalysisResponse.Result.triggered_rules)
    return &_impl_.triggered_rules_;
}
inline const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule& ContentAnalysisResponse_Result::_internal_triggered_rules(int index) const
{
    return _impl_.triggered_rules_.Get(index);
}
inline const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule& ContentAnalysisResponse_Result::triggered_rules(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.triggered_rules)
    return _internal_triggered_rules(index);
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule* ContentAnalysisResponse_Result::_internal_add_triggered_rules()
{
    return _impl_.triggered_rules_.Add();
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule* ContentAnalysisResponse_Result::add_triggered_rules()
{
    ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule* _add = _internal_add_triggered_rules();
    // @@protoc_insertion_point(field_add:enterprise_connectors.ContentAnalysisResponse.Result.triggered_rules)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule>&
ContentAnalysisResponse_Result::triggered_rules() const
{
    // @@protoc_insertion_point(field_list:enterprise_connectors.ContentAnalysisResponse.Result.triggered_rules)
    return _impl_.triggered_rules_;
}

// optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 7 [deprecated = true];
inline bool ContentAnalysisResponse_Result::_internal_has_custom_message() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.custom_message_ != nullptr);
    return value;
}
inline bool ContentAnalysisResponse_Result::has_custom_message() const
{
    return _internal_has_custom_message();
}
inline void ContentAnalysisResponse_Result::clear_custom_message()
{
    if (_impl_.custom_message_ != nullptr)
        _impl_.custom_message_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage& ContentAnalysisResponse_Result::_internal_custom_message() const
{
    const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* p = _impl_.custom_message_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage&>(
                            ::enterprise_connectors::_ContentAnalysisResponse_Result_CustomMessage_default_instance_);
}
inline const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage& ContentAnalysisResponse_Result::custom_message() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.custom_message)
    return _internal_custom_message();
}
inline void ContentAnalysisResponse_Result::unsafe_arena_set_allocated_custom_message(
    ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* custom_message)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.custom_message_);
    }
    _impl_.custom_message_ = custom_message;
    if (custom_message) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:enterprise_connectors.ContentAnalysisResponse.Result.custom_message)
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* ContentAnalysisResponse_Result::release_custom_message()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* temp = _impl_.custom_message_;
    _impl_.custom_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* ContentAnalysisResponse_Result::unsafe_arena_release_custom_message()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisResponse.Result.custom_message)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* temp = _impl_.custom_message_;
    _impl_.custom_message_ = nullptr;
    return temp;
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* ContentAnalysisResponse_Result::_internal_mutable_custom_message()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.custom_message_ == nullptr) {
        auto* p = CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage>(GetArenaForAllocation());
        _impl_.custom_message_ = p;
    }
    return _impl_.custom_message_;
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* ContentAnalysisResponse_Result::mutable_custom_message()
{
    ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* _msg = _internal_mutable_custom_message();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.Result.custom_message)
    return _msg;
}
inline void ContentAnalysisResponse_Result::set_allocated_custom_message(::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage* custom_message)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.custom_message_;
    }
    if (custom_message) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(custom_message);
        if (message_arena != submessage_arena) {
            custom_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, custom_message, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.custom_message_ = custom_message;
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisResponse.Result.custom_message)
}

// optional .enterprise_connectors.ContentAnalysisResponse.Result.StatusErrorMessage status_error_message = 8;
inline bool ContentAnalysisResponse_Result::_internal_has_status_error_message() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ContentAnalysisResponse_Result::has_status_error_message() const
{
    return _internal_has_status_error_message();
}
inline void ContentAnalysisResponse_Result::clear_status_error_message()
{
    _impl_.status_error_message_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_StatusErrorMessage ContentAnalysisResponse_Result::_internal_status_error_message() const
{
    return static_cast<::enterprise_connectors::ContentAnalysisResponse_Result_StatusErrorMessage>(_impl_.status_error_message_);
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result_StatusErrorMessage ContentAnalysisResponse_Result::status_error_message() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.Result.status_error_message)
    return _internal_status_error_message();
}
inline void ContentAnalysisResponse_Result::_internal_set_status_error_message(::enterprise_connectors::ContentAnalysisResponse_Result_StatusErrorMessage value)
{
    assert(::enterprise_connectors::ContentAnalysisResponse_Result_StatusErrorMessage_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.status_error_message_ = value;
}
inline void ContentAnalysisResponse_Result::set_status_error_message(::enterprise_connectors::ContentAnalysisResponse_Result_StatusErrorMessage value)
{
    _internal_set_status_error_message(value);
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisResponse.Result.status_error_message)
}

// -------------------------------------------------------------------

// ContentAnalysisResponse

// optional string request_token = 1;
inline bool ContentAnalysisResponse::_internal_has_request_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ContentAnalysisResponse::has_request_token() const
{
    return _internal_has_request_token();
}
inline void ContentAnalysisResponse::clear_request_token()
{
    _impl_.request_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentAnalysisResponse::request_token() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.request_token)
    return _internal_request_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentAnalysisResponse::set_request_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.request_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisResponse.request_token)
}
inline std::string* ContentAnalysisResponse::mutable_request_token()
{
    std::string* _s = _internal_mutable_request_token();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.request_token)
    return _s;
}
inline const std::string& ContentAnalysisResponse::_internal_request_token() const
{
    return _impl_.request_token_.Get();
}
inline void ContentAnalysisResponse::_internal_set_request_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.request_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse::_internal_mutable_request_token()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.request_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisResponse::release_request_token()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisResponse.request_token)
    if (!_internal_has_request_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.request_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.request_token_.IsDefault()) {
        _impl_.request_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentAnalysisResponse::set_allocated_request_token(std::string* request_token)
{
    if (request_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.request_token_.SetAllocated(request_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.request_token_.IsDefault()) {
        _impl_.request_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisResponse.request_token)
}

// repeated .enterprise_connectors.ContentAnalysisResponse.Result results = 4;
inline int ContentAnalysisResponse::_internal_results_size() const
{
    return _impl_.results_.size();
}
inline int ContentAnalysisResponse::results_size() const
{
    return _internal_results_size();
}
inline void ContentAnalysisResponse::clear_results()
{
    _impl_.results_.Clear();
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result* ContentAnalysisResponse::mutable_results(int index)
{
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisResponse.results)
    return _impl_.results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result>* ContentAnalysisResponse::mutable_results()
{
    // @@protoc_insertion_point(field_mutable_list:enterprise_connectors.ContentAnalysisResponse.results)
    return &_impl_.results_;
}
inline const ::enterprise_connectors::ContentAnalysisResponse_Result& ContentAnalysisResponse::_internal_results(int index) const
{
    return _impl_.results_.Get(index);
}
inline const ::enterprise_connectors::ContentAnalysisResponse_Result& ContentAnalysisResponse::results(int index) const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisResponse.results)
    return _internal_results(index);
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result* ContentAnalysisResponse::_internal_add_results()
{
    return _impl_.results_.Add();
}
inline ::enterprise_connectors::ContentAnalysisResponse_Result* ContentAnalysisResponse::add_results()
{
    ::enterprise_connectors::ContentAnalysisResponse_Result* _add = _internal_add_results();
    // @@protoc_insertion_point(field_add:enterprise_connectors.ContentAnalysisResponse.results)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::enterprise_connectors::ContentAnalysisResponse_Result>& ContentAnalysisResponse::results() const
{
    // @@protoc_insertion_point(field_list:enterprise_connectors.ContentAnalysisResponse.results)
    return _impl_.results_;
}

// -------------------------------------------------------------------

// ContentAnalysisAcknowledgement

// optional string request_token = 1;
inline bool ContentAnalysisAcknowledgement::_internal_has_request_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ContentAnalysisAcknowledgement::has_request_token() const
{
    return _internal_has_request_token();
}
inline void ContentAnalysisAcknowledgement::clear_request_token()
{
    _impl_.request_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ContentAnalysisAcknowledgement::request_token() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisAcknowledgement.request_token)
    return _internal_request_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ContentAnalysisAcknowledgement::set_request_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.request_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisAcknowledgement.request_token)
}
inline std::string* ContentAnalysisAcknowledgement::mutable_request_token()
{
    std::string* _s = _internal_mutable_request_token();
    // @@protoc_insertion_point(field_mutable:enterprise_connectors.ContentAnalysisAcknowledgement.request_token)
    return _s;
}
inline const std::string& ContentAnalysisAcknowledgement::_internal_request_token() const
{
    return _impl_.request_token_.Get();
}
inline void ContentAnalysisAcknowledgement::_internal_set_request_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.request_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ContentAnalysisAcknowledgement::_internal_mutable_request_token()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.request_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ContentAnalysisAcknowledgement::release_request_token()
{
    // @@protoc_insertion_point(field_release:enterprise_connectors.ContentAnalysisAcknowledgement.request_token)
    if (!_internal_has_request_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.request_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.request_token_.IsDefault()) {
        _impl_.request_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ContentAnalysisAcknowledgement::set_allocated_request_token(std::string* request_token)
{
    if (request_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.request_token_.SetAllocated(request_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.request_token_.IsDefault()) {
        _impl_.request_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:enterprise_connectors.ContentAnalysisAcknowledgement.request_token)
}

// optional .enterprise_connectors.ContentAnalysisAcknowledgement.Status status = 2;
inline bool ContentAnalysisAcknowledgement::_internal_has_status() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ContentAnalysisAcknowledgement::has_status() const
{
    return _internal_has_status();
}
inline void ContentAnalysisAcknowledgement::clear_status()
{
    _impl_.status_ = 1;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::enterprise_connectors::ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement::_internal_status() const
{
    return static_cast<::enterprise_connectors::ContentAnalysisAcknowledgement_Status>(_impl_.status_);
}
inline ::enterprise_connectors::ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement::status() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisAcknowledgement.status)
    return _internal_status();
}
inline void ContentAnalysisAcknowledgement::_internal_set_status(::enterprise_connectors::ContentAnalysisAcknowledgement_Status value)
{
    assert(::enterprise_connectors::ContentAnalysisAcknowledgement_Status_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.status_ = value;
}
inline void ContentAnalysisAcknowledgement::set_status(::enterprise_connectors::ContentAnalysisAcknowledgement_Status value)
{
    _internal_set_status(value);
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisAcknowledgement.status)
}

// optional .enterprise_connectors.ContentAnalysisAcknowledgement.FinalAction final_action = 3;
inline bool ContentAnalysisAcknowledgement::_internal_has_final_action() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ContentAnalysisAcknowledgement::has_final_action() const
{
    return _internal_has_final_action();
}
inline void ContentAnalysisAcknowledgement::clear_final_action()
{
    _impl_.final_action_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::_internal_final_action() const
{
    return static_cast<::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction>(_impl_.final_action_);
}
inline ::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::final_action() const
{
    // @@protoc_insertion_point(field_get:enterprise_connectors.ContentAnalysisAcknowledgement.final_action)
    return _internal_final_action();
}
inline void ContentAnalysisAcknowledgement::_internal_set_final_action(::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction value)
{
    assert(::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.final_action_ = value;
}
inline void ContentAnalysisAcknowledgement::set_final_action(::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction value)
{
    _internal_set_final_action(value);
    // @@protoc_insertion_point(field_set:enterprise_connectors.ContentAnalysisAcknowledgement.final_action)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace enterprise_connectors

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::enterprise_connectors::ContentMetaData_PrintMetadata_PrinterType> : ::std::true_type { };
template <> struct is_proto_enum<::enterprise_connectors::ContentAnalysisRequest_Reason> : ::std::true_type { };
template <> struct is_proto_enum<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action> : ::std::true_type { };
template <> struct is_proto_enum<::enterprise_connectors::ContentAnalysisResponse_Result_Status> : ::std::true_type { };
template <> struct is_proto_enum<::enterprise_connectors::ContentAnalysisResponse_Result_StatusErrorMessage> : ::std::true_type { };
template <> struct is_proto_enum<::enterprise_connectors::ContentAnalysisAcknowledgement_Status> : ::std::true_type { };
template <> struct is_proto_enum<::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction> : ::std::true_type { };
template <> struct is_proto_enum<::enterprise_connectors::AnalysisConnector> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fenterprise_2fcommon_2fproto_2fconnectors_2eproto
