// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/enterprise/common/proto/connectors.proto

#include "components/enterprise/common/proto/connectors.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace enterprise_connectors {
PROTOBUF_CONSTEXPR ContentMetaData_PrintMetadata::ContentMetaData_PrintMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.printer_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.printer_type_)*/ 0 }
{
}
struct ContentMetaData_PrintMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ContentMetaData_PrintMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ContentMetaData_PrintMetadataDefaultTypeInternal()
    {
    }
    union {
        ContentMetaData_PrintMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentMetaData_PrintMetadataDefaultTypeInternal
    _ContentMetaData_PrintMetadata_default_instance_;
PROTOBUF_CONSTEXPR ContentMetaData::ContentMetaData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.filename_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.digest_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.email_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.content_type_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.source_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.destination_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.tab_title_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.tab_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.decryption_key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.csd_)*/ nullptr,
        /*decltype(_impl_.print_metadata_)*/ nullptr }
{
}
struct ContentMetaDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ContentMetaDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ContentMetaDataDefaultTypeInternal()
    {
    }
    union {
        ContentMetaData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentMetaDataDefaultTypeInternal _ContentMetaData_default_instance_;
PROTOBUF_CONSTEXPR ClientMetadata_Browser::ClientMetadata_Browser(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.browser_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.user_agent_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.chrome_version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.machine_user_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientMetadata_BrowserDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientMetadata_BrowserDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientMetadata_BrowserDefaultTypeInternal()
    {
    }
    union {
        ClientMetadata_Browser _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientMetadata_BrowserDefaultTypeInternal
    _ClientMetadata_Browser_default_instance_;
PROTOBUF_CONSTEXPR ClientMetadata_Device::ClientMetadata_Device(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.dm_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.client_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.os_version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.os_platform_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientMetadata_DeviceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientMetadata_DeviceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientMetadata_DeviceDefaultTypeInternal()
    {
    }
    union {
        ClientMetadata_Device _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientMetadata_DeviceDefaultTypeInternal
    _ClientMetadata_Device_default_instance_;
PROTOBUF_CONSTEXPR ClientMetadata_Profile::ClientMetadata_Profile(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.dm_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.gaia_email_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.profile_path_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.profile_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.client_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientMetadata_ProfileDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientMetadata_ProfileDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientMetadata_ProfileDefaultTypeInternal()
    {
    }
    union {
        ClientMetadata_Profile _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientMetadata_ProfileDefaultTypeInternal
    _ClientMetadata_Profile_default_instance_;
PROTOBUF_CONSTEXPR ClientMetadata::ClientMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.browser_)*/ nullptr,
        /*decltype(_impl_.device_)*/ nullptr, /*decltype(_impl_.profile_)*/ nullptr, /*decltype(_impl_.is_chrome_os_managed_guest_session_)*/ false }
{
}
struct ClientMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientMetadataDefaultTypeInternal()
    {
    }
    union {
        ClientMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientMetadataDefaultTypeInternal _ClientMetadata_default_instance_;
PROTOBUF_CONSTEXPR ContentAnalysisRequest::ContentAnalysisRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.tags_)*/ {},
        /*decltype(_impl_.device_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.fcm_notification_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.request_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.user_action_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.request_data_)*/ nullptr, /*decltype(_impl_.client_metadata_)*/ nullptr, /*decltype(_impl_.analysis_connector_)*/ 0,
        /*decltype(_impl_.reason_)*/ 0, /*decltype(_impl_.expires_at_)*/ int64_t { 0 }, /*decltype(_impl_.user_action_requests_count_)*/ int64_t { 0 },
        /*decltype(_impl_.blocking_)*/ false, /*decltype(_impl_.require_metadata_verdict_)*/ false, /*decltype(_impl_.content_data_)*/ {},
        /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct ContentAnalysisRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ContentAnalysisRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ContentAnalysisRequestDefaultTypeInternal()
    {
    }
    union {
        ContentAnalysisRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentAnalysisRequestDefaultTypeInternal
    _ContentAnalysisRequest_default_instance_;
PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_CustomMessage::ContentAnalysisResponse_Result_CustomMessage(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.learn_more_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.message_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ContentAnalysisResponse_Result_CustomMessageDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_CustomMessageDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ContentAnalysisResponse_Result_CustomMessageDefaultTypeInternal()
    {
    }
    union {
        ContentAnalysisResponse_Result_CustomMessage _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentAnalysisResponse_Result_CustomMessageDefaultTypeInternal
    _ContentAnalysisResponse_Result_CustomMessage_default_instance_;
PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.text_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.link_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegmentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegmentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegmentDefaultTypeInternal()
    {
    }
    union {
        ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegmentDefaultTypeInternal
        _ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment_default_instance_;
PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.message_segments_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageDefaultTypeInternal()
    {
    }
    union {
        ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageDefaultTypeInternal
        _ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage_default_instance_;
PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_TriggeredRule::ContentAnalysisResponse_Result_TriggeredRule(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.rule_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.rule_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.url_category_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.custom_message_)*/ nullptr, /*decltype(_impl_.custom_rule_message_)*/ nullptr, /*decltype(_impl_.action_)*/ 0 }
{
}
struct ContentAnalysisResponse_Result_TriggeredRuleDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result_TriggeredRuleDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ContentAnalysisResponse_Result_TriggeredRuleDefaultTypeInternal()
    {
    }
    union {
        ContentAnalysisResponse_Result_TriggeredRule _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentAnalysisResponse_Result_TriggeredRuleDefaultTypeInternal
    _ContentAnalysisResponse_Result_TriggeredRule_default_instance_;
PROTOBUF_CONSTEXPR ContentAnalysisResponse_Result::ContentAnalysisResponse_Result(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.triggered_rules_)*/ {},
        /*decltype(_impl_.tag_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.custom_message_)*/ nullptr,
        /*decltype(_impl_.status_)*/ 0, /*decltype(_impl_.status_error_message_)*/ 0 }
{
}
struct ContentAnalysisResponse_ResultDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ContentAnalysisResponse_ResultDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ContentAnalysisResponse_ResultDefaultTypeInternal()
    {
    }
    union {
        ContentAnalysisResponse_Result _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentAnalysisResponse_ResultDefaultTypeInternal
    _ContentAnalysisResponse_Result_default_instance_;
PROTOBUF_CONSTEXPR ContentAnalysisResponse::ContentAnalysisResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.results_)*/ {},
        /*decltype(_impl_.request_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ContentAnalysisResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ContentAnalysisResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ContentAnalysisResponseDefaultTypeInternal()
    {
    }
    union {
        ContentAnalysisResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentAnalysisResponseDefaultTypeInternal
    _ContentAnalysisResponse_default_instance_;
PROTOBUF_CONSTEXPR ContentAnalysisAcknowledgement::ContentAnalysisAcknowledgement(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.request_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.final_action_)*/ 0,
        /*decltype(_impl_.status_)*/ 1 }
{
}
struct ContentAnalysisAcknowledgementDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ContentAnalysisAcknowledgementDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ContentAnalysisAcknowledgementDefaultTypeInternal()
    {
    }
    union {
        ContentAnalysisAcknowledgement _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentAnalysisAcknowledgementDefaultTypeInternal
    _ContentAnalysisAcknowledgement_default_instance_;
} // namespace enterprise_connectors
namespace enterprise_connectors {
bool ContentMetaData_PrintMetadata_PrinterType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContentMetaData_PrintMetadata_PrinterType_strings[3] = {};

static const char ContentMetaData_PrintMetadata_PrinterType_names[] = "CLOUD"
                                                                      "LOCAL"
                                                                      "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContentMetaData_PrintMetadata_PrinterType_entries[] = {
    { { ContentMetaData_PrintMetadata_PrinterType_names + 0, 5 }, 1 },
    { { ContentMetaData_PrintMetadata_PrinterType_names + 5, 5 }, 2 },
    { { ContentMetaData_PrintMetadata_PrinterType_names + 10, 7 }, 0 },
};

static const int ContentMetaData_PrintMetadata_PrinterType_entries_by_number[] = {
    2, // 0 -> UNKNOWN
    0, // 1 -> CLOUD
    1, // 2 -> LOCAL
};

const std::string& ContentMetaData_PrintMetadata_PrinterType_Name(ContentMetaData_PrintMetadata_PrinterType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ContentMetaData_PrintMetadata_PrinterType_entries,
        ContentMetaData_PrintMetadata_PrinterType_entries_by_number, 3, ContentMetaData_PrintMetadata_PrinterType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ContentMetaData_PrintMetadata_PrinterType_entries, ContentMetaData_PrintMetadata_PrinterType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ContentMetaData_PrintMetadata_PrinterType_strings[idx].get();
}
bool ContentMetaData_PrintMetadata_PrinterType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentMetaData_PrintMetadata_PrinterType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ContentMetaData_PrintMetadata_PrinterType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ContentMetaData_PrintMetadata_PrinterType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContentMetaData_PrintMetadata_PrinterType ContentMetaData_PrintMetadata::UNKNOWN;
constexpr ContentMetaData_PrintMetadata_PrinterType ContentMetaData_PrintMetadata::CLOUD;
constexpr ContentMetaData_PrintMetadata_PrinterType ContentMetaData_PrintMetadata::LOCAL;
constexpr ContentMetaData_PrintMetadata_PrinterType ContentMetaData_PrintMetadata::PrinterType_MIN;
constexpr ContentMetaData_PrintMetadata_PrinterType ContentMetaData_PrintMetadata::PrinterType_MAX;
constexpr int ContentMetaData_PrintMetadata::PrinterType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ContentAnalysisRequest_Reason_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContentAnalysisRequest_Reason_strings[8] = {};

static const char ContentAnalysisRequest_Reason_names[] = "CLIPBOARD_PASTE"
                                                          "DRAG_AND_DROP"
                                                          "FILE_PICKER_DIALOG"
                                                          "NORMAL_DOWNLOAD"
                                                          "PRINT_PREVIEW_PRINT"
                                                          "SAVE_AS_DOWNLOAD"
                                                          "SYSTEM_DIALOG_PRINT"
                                                          "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContentAnalysisRequest_Reason_entries[] = {
    { { ContentAnalysisRequest_Reason_names + 0, 15 }, 1 },
    { { ContentAnalysisRequest_Reason_names + 15, 13 }, 2 },
    { { ContentAnalysisRequest_Reason_names + 28, 18 }, 3 },
    { { ContentAnalysisRequest_Reason_names + 46, 15 }, 6 },
    { { ContentAnalysisRequest_Reason_names + 61, 19 }, 4 },
    { { ContentAnalysisRequest_Reason_names + 80, 16 }, 7 },
    { { ContentAnalysisRequest_Reason_names + 96, 19 }, 5 },
    { { ContentAnalysisRequest_Reason_names + 115, 7 }, 0 },
};

static const int ContentAnalysisRequest_Reason_entries_by_number[] = {
    7, // 0 -> UNKNOWN
    0, // 1 -> CLIPBOARD_PASTE
    1, // 2 -> DRAG_AND_DROP
    2, // 3 -> FILE_PICKER_DIALOG
    4, // 4 -> PRINT_PREVIEW_PRINT
    6, // 5 -> SYSTEM_DIALOG_PRINT
    3, // 6 -> NORMAL_DOWNLOAD
    5, // 7 -> SAVE_AS_DOWNLOAD
};

const std::string& ContentAnalysisRequest_Reason_Name(ContentAnalysisRequest_Reason value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ContentAnalysisRequest_Reason_entries, ContentAnalysisRequest_Reason_entries_by_number, 8, ContentAnalysisRequest_Reason_strings);
    (void)dummy;
    int idx
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ContentAnalysisRequest_Reason_entries, ContentAnalysisRequest_Reason_entries_by_number, 8, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ContentAnalysisRequest_Reason_strings[idx].get();
}
bool ContentAnalysisRequest_Reason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisRequest_Reason* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ContentAnalysisRequest_Reason_entries, 8, name, &int_value);
    if (success) {
        *value = static_cast<ContentAnalysisRequest_Reason>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContentAnalysisRequest_Reason ContentAnalysisRequest::UNKNOWN;
constexpr ContentAnalysisRequest_Reason ContentAnalysisRequest::CLIPBOARD_PASTE;
constexpr ContentAnalysisRequest_Reason ContentAnalysisRequest::DRAG_AND_DROP;
constexpr ContentAnalysisRequest_Reason ContentAnalysisRequest::FILE_PICKER_DIALOG;
constexpr ContentAnalysisRequest_Reason ContentAnalysisRequest::PRINT_PREVIEW_PRINT;
constexpr ContentAnalysisRequest_Reason ContentAnalysisRequest::SYSTEM_DIALOG_PRINT;
constexpr ContentAnalysisRequest_Reason ContentAnalysisRequest::NORMAL_DOWNLOAD;
constexpr ContentAnalysisRequest_Reason ContentAnalysisRequest::SAVE_AS_DOWNLOAD;
constexpr ContentAnalysisRequest_Reason ContentAnalysisRequest::Reason_MIN;
constexpr ContentAnalysisRequest_Reason ContentAnalysisRequest::Reason_MAX;
constexpr int ContentAnalysisRequest::Reason_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ContentAnalysisResponse_Result_TriggeredRule_Action_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContentAnalysisResponse_Result_TriggeredRule_Action_strings[4] = {};

static const char ContentAnalysisResponse_Result_TriggeredRule_Action_names[] = "ACTION_UNSPECIFIED"
                                                                                "BLOCK"
                                                                                "REPORT_ONLY"
                                                                                "WARN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContentAnalysisResponse_Result_TriggeredRule_Action_entries[] = {
    { { ContentAnalysisResponse_Result_TriggeredRule_Action_names + 0, 18 }, 0 },
    { { ContentAnalysisResponse_Result_TriggeredRule_Action_names + 18, 5 }, 3 },
    { { ContentAnalysisResponse_Result_TriggeredRule_Action_names + 23, 11 }, 1 },
    { { ContentAnalysisResponse_Result_TriggeredRule_Action_names + 34, 4 }, 2 },
};

static const int ContentAnalysisResponse_Result_TriggeredRule_Action_entries_by_number[] = {
    0, // 0 -> ACTION_UNSPECIFIED
    2, // 1 -> REPORT_ONLY
    3, // 2 -> WARN
    1, // 3 -> BLOCK
};

const std::string& ContentAnalysisResponse_Result_TriggeredRule_Action_Name(ContentAnalysisResponse_Result_TriggeredRule_Action value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ContentAnalysisResponse_Result_TriggeredRule_Action_entries,
        ContentAnalysisResponse_Result_TriggeredRule_Action_entries_by_number, 4, ContentAnalysisResponse_Result_TriggeredRule_Action_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ContentAnalysisResponse_Result_TriggeredRule_Action_entries, ContentAnalysisResponse_Result_TriggeredRule_Action_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ContentAnalysisResponse_Result_TriggeredRule_Action_strings[idx].get();
}
bool ContentAnalysisResponse_Result_TriggeredRule_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisResponse_Result_TriggeredRule_Action* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ContentAnalysisResponse_Result_TriggeredRule_Action_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<ContentAnalysisResponse_Result_TriggeredRule_Action>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::ACTION_UNSPECIFIED;
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::REPORT_ONLY;
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::WARN;
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::BLOCK;
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::Action_MIN;
constexpr ContentAnalysisResponse_Result_TriggeredRule_Action ContentAnalysisResponse_Result_TriggeredRule::Action_MAX;
constexpr int ContentAnalysisResponse_Result_TriggeredRule::Action_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ContentAnalysisResponse_Result_Status_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContentAnalysisResponse_Result_Status_strings[3] = {};

static const char ContentAnalysisResponse_Result_Status_names[] = "FAILURE"
                                                                  "STATUS_UNKNOWN"
                                                                  "SUCCESS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContentAnalysisResponse_Result_Status_entries[] = {
    { { ContentAnalysisResponse_Result_Status_names + 0, 7 }, 2 },
    { { ContentAnalysisResponse_Result_Status_names + 7, 14 }, 0 },
    { { ContentAnalysisResponse_Result_Status_names + 21, 7 }, 1 },
};

static const int ContentAnalysisResponse_Result_Status_entries_by_number[] = {
    1, // 0 -> STATUS_UNKNOWN
    2, // 1 -> SUCCESS
    0, // 2 -> FAILURE
};

const std::string& ContentAnalysisResponse_Result_Status_Name(ContentAnalysisResponse_Result_Status value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ContentAnalysisResponse_Result_Status_entries,
        ContentAnalysisResponse_Result_Status_entries_by_number, 3, ContentAnalysisResponse_Result_Status_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ContentAnalysisResponse_Result_Status_entries, ContentAnalysisResponse_Result_Status_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ContentAnalysisResponse_Result_Status_strings[idx].get();
}
bool ContentAnalysisResponse_Result_Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisResponse_Result_Status* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ContentAnalysisResponse_Result_Status_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ContentAnalysisResponse_Result_Status>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result::STATUS_UNKNOWN;
constexpr ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result::SUCCESS;
constexpr ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result::FAILURE;
constexpr ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result::Status_MIN;
constexpr ContentAnalysisResponse_Result_Status ContentAnalysisResponse_Result::Status_MAX;
constexpr int ContentAnalysisResponse_Result::Status_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ContentAnalysisResponse_Result_StatusErrorMessage_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContentAnalysisResponse_Result_StatusErrorMessage_strings[2] = {};

static const char ContentAnalysisResponse_Result_StatusErrorMessage_names[] = "DECRYPTION_FAILED"
                                                                              "STATUS_ERROR_MESSAGE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContentAnalysisResponse_Result_StatusErrorMessage_entries[] = {
    { { ContentAnalysisResponse_Result_StatusErrorMessage_names + 0, 17 }, 1 },
    { { ContentAnalysisResponse_Result_StatusErrorMessage_names + 17, 32 }, 0 },
};

static const int ContentAnalysisResponse_Result_StatusErrorMessage_entries_by_number[] = {
    1, // 0 -> STATUS_ERROR_MESSAGE_UNSPECIFIED
    0, // 1 -> DECRYPTION_FAILED
};

const std::string& ContentAnalysisResponse_Result_StatusErrorMessage_Name(ContentAnalysisResponse_Result_StatusErrorMessage value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ContentAnalysisResponse_Result_StatusErrorMessage_entries,
        ContentAnalysisResponse_Result_StatusErrorMessage_entries_by_number, 2, ContentAnalysisResponse_Result_StatusErrorMessage_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ContentAnalysisResponse_Result_StatusErrorMessage_entries, ContentAnalysisResponse_Result_StatusErrorMessage_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ContentAnalysisResponse_Result_StatusErrorMessage_strings[idx].get();
}
bool ContentAnalysisResponse_Result_StatusErrorMessage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisResponse_Result_StatusErrorMessage* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ContentAnalysisResponse_Result_StatusErrorMessage_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<ContentAnalysisResponse_Result_StatusErrorMessage>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContentAnalysisResponse_Result_StatusErrorMessage ContentAnalysisResponse_Result::STATUS_ERROR_MESSAGE_UNSPECIFIED;
constexpr ContentAnalysisResponse_Result_StatusErrorMessage ContentAnalysisResponse_Result::DECRYPTION_FAILED;
constexpr ContentAnalysisResponse_Result_StatusErrorMessage ContentAnalysisResponse_Result::StatusErrorMessage_MIN;
constexpr ContentAnalysisResponse_Result_StatusErrorMessage ContentAnalysisResponse_Result::StatusErrorMessage_MAX;
constexpr int ContentAnalysisResponse_Result::StatusErrorMessage_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ContentAnalysisAcknowledgement_Status_IsValid(int value)
{
    switch (value) {
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContentAnalysisAcknowledgement_Status_strings[3] = {};

static const char ContentAnalysisAcknowledgement_Status_names[] = "INVALID_RESPONSE"
                                                                  "SUCCESS"
                                                                  "TOO_LATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContentAnalysisAcknowledgement_Status_entries[] = {
    { { ContentAnalysisAcknowledgement_Status_names + 0, 16 }, 2 },
    { { ContentAnalysisAcknowledgement_Status_names + 16, 7 }, 1 },
    { { ContentAnalysisAcknowledgement_Status_names + 23, 8 }, 3 },
};

static const int ContentAnalysisAcknowledgement_Status_entries_by_number[] = {
    1, // 1 -> SUCCESS
    0, // 2 -> INVALID_RESPONSE
    2, // 3 -> TOO_LATE
};

const std::string& ContentAnalysisAcknowledgement_Status_Name(ContentAnalysisAcknowledgement_Status value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ContentAnalysisAcknowledgement_Status_entries,
        ContentAnalysisAcknowledgement_Status_entries_by_number, 3, ContentAnalysisAcknowledgement_Status_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ContentAnalysisAcknowledgement_Status_entries, ContentAnalysisAcknowledgement_Status_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ContentAnalysisAcknowledgement_Status_strings[idx].get();
}
bool ContentAnalysisAcknowledgement_Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisAcknowledgement_Status* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ContentAnalysisAcknowledgement_Status_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ContentAnalysisAcknowledgement_Status>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement::SUCCESS;
constexpr ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement::INVALID_RESPONSE;
constexpr ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement::TOO_LATE;
constexpr ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement::Status_MIN;
constexpr ContentAnalysisAcknowledgement_Status ContentAnalysisAcknowledgement::Status_MAX;
constexpr int ContentAnalysisAcknowledgement::Status_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ContentAnalysisAcknowledgement_FinalAction_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ContentAnalysisAcknowledgement_FinalAction_strings[5] = {};

static const char ContentAnalysisAcknowledgement_FinalAction_names[] = "ACTION_UNSPECIFIED"
                                                                       "ALLOW"
                                                                       "BLOCK"
                                                                       "REPORT_ONLY"
                                                                       "WARN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ContentAnalysisAcknowledgement_FinalAction_entries[] = {
    { { ContentAnalysisAcknowledgement_FinalAction_names + 0, 18 }, 0 },
    { { ContentAnalysisAcknowledgement_FinalAction_names + 18, 5 }, 1 },
    { { ContentAnalysisAcknowledgement_FinalAction_names + 23, 5 }, 4 },
    { { ContentAnalysisAcknowledgement_FinalAction_names + 28, 11 }, 2 },
    { { ContentAnalysisAcknowledgement_FinalAction_names + 39, 4 }, 3 },
};

static const int ContentAnalysisAcknowledgement_FinalAction_entries_by_number[] = {
    0, // 0 -> ACTION_UNSPECIFIED
    1, // 1 -> ALLOW
    3, // 2 -> REPORT_ONLY
    4, // 3 -> WARN
    2, // 4 -> BLOCK
};

const std::string& ContentAnalysisAcknowledgement_FinalAction_Name(ContentAnalysisAcknowledgement_FinalAction value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ContentAnalysisAcknowledgement_FinalAction_entries,
        ContentAnalysisAcknowledgement_FinalAction_entries_by_number, 5, ContentAnalysisAcknowledgement_FinalAction_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ContentAnalysisAcknowledgement_FinalAction_entries, ContentAnalysisAcknowledgement_FinalAction_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ContentAnalysisAcknowledgement_FinalAction_strings[idx].get();
}
bool ContentAnalysisAcknowledgement_FinalAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentAnalysisAcknowledgement_FinalAction* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ContentAnalysisAcknowledgement_FinalAction_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<ContentAnalysisAcknowledgement_FinalAction>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::ACTION_UNSPECIFIED;
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::ALLOW;
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::REPORT_ONLY;
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::WARN;
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::BLOCK;
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::FinalAction_MIN;
constexpr ContentAnalysisAcknowledgement_FinalAction ContentAnalysisAcknowledgement::FinalAction_MAX;
constexpr int ContentAnalysisAcknowledgement::FinalAction_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AnalysisConnector_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AnalysisConnector_strings[6] = {};

static const char AnalysisConnector_names[] = "ANALYSIS_CONNECTOR_UNSPECIFIED"
                                              "BULK_DATA_ENTRY"
                                              "FILE_ATTACHED"
                                              "FILE_DOWNLOADED"
                                              "FILE_TRANSFER"
                                              "PRINT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AnalysisConnector_entries[] = {
    { { AnalysisConnector_names + 0, 30 }, 0 },
    { { AnalysisConnector_names + 30, 15 }, 3 },
    { { AnalysisConnector_names + 45, 13 }, 2 },
    { { AnalysisConnector_names + 58, 15 }, 1 },
    { { AnalysisConnector_names + 73, 13 }, 5 },
    { { AnalysisConnector_names + 86, 5 }, 4 },
};

static const int AnalysisConnector_entries_by_number[] = {
    0, // 0 -> ANALYSIS_CONNECTOR_UNSPECIFIED
    3, // 1 -> FILE_DOWNLOADED
    2, // 2 -> FILE_ATTACHED
    1, // 3 -> BULK_DATA_ENTRY
    5, // 4 -> PRINT
    4, // 5 -> FILE_TRANSFER
};

const std::string& AnalysisConnector_Name(AnalysisConnector value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        AnalysisConnector_entries, AnalysisConnector_entries_by_number, 6, AnalysisConnector_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(AnalysisConnector_entries, AnalysisConnector_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AnalysisConnector_strings[idx].get();
}
bool AnalysisConnector_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AnalysisConnector* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AnalysisConnector_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<AnalysisConnector>(int_value);
    }
    return success;
}

// ===================================================================

class ContentMetaData_PrintMetadata::_Internal {
public:
    using HasBits = decltype(std::declval<ContentMetaData_PrintMetadata>()._impl_._has_bits_);
    static void set_has_printer_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_printer_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ContentMetaData_PrintMetadata::ContentMetaData_PrintMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentMetaData.PrintMetadata)
}
ContentMetaData_PrintMetadata::ContentMetaData_PrintMetadata(const ContentMetaData_PrintMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ContentMetaData_PrintMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.printer_name_) {},
        decltype(_impl_.printer_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.printer_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.printer_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_printer_name()) {
        _this->_impl_.printer_name_.Set(from._internal_printer_name(), _this->GetArenaForAllocation());
    }
    _this->_impl_.printer_type_ = from._impl_.printer_type_;
    // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentMetaData.PrintMetadata)
}

inline void ContentMetaData_PrintMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.printer_name_) {},
        decltype(_impl_.printer_type_) { 0 } };
    _impl_.printer_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.printer_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContentMetaData_PrintMetadata::~ContentMetaData_PrintMetadata()
{
    // @@protoc_insertion_point(destructor:enterprise_connectors.ContentMetaData.PrintMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ContentMetaData_PrintMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.printer_name_.Destroy();
}

void ContentMetaData_PrintMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ContentMetaData_PrintMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentMetaData.PrintMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.printer_name_.ClearNonDefaultToEmpty();
    }
    _impl_.printer_type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ContentMetaData_PrintMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string printer_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_printer_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ContentMetaData.PrintMetadata.PrinterType printer_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::enterprise_connectors::ContentMetaData_PrintMetadata_PrinterType_IsValid(val))) {
                    _internal_set_printer_type(static_cast<::enterprise_connectors::ContentMetaData_PrintMetadata_PrinterType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ContentMetaData_PrintMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentMetaData.PrintMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string printer_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_printer_name(), target);
    }

    // optional .enterprise_connectors.ContentMetaData.PrintMetadata.PrinterType printer_type = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_printer_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentMetaData.PrintMetadata)
    return target;
}

size_t ContentMetaData_PrintMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentMetaData.PrintMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string printer_name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_printer_name());
        }

        // optional .enterprise_connectors.ContentMetaData.PrintMetadata.PrinterType printer_type = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_printer_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ContentMetaData_PrintMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ContentMetaData_PrintMetadata*>(&from));
}

void ContentMetaData_PrintMetadata::MergeFrom(const ContentMetaData_PrintMetadata& from)
{
    ContentMetaData_PrintMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentMetaData.PrintMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_printer_name(from._internal_printer_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.printer_type_ = from._impl_.printer_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentMetaData_PrintMetadata::CopyFrom(const ContentMetaData_PrintMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentMetaData.PrintMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ContentMetaData_PrintMetadata::IsInitialized() const
{
    return true;
}

void ContentMetaData_PrintMetadata::InternalSwap(ContentMetaData_PrintMetadata* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.printer_name_, lhs_arena, &other->_impl_.printer_name_, rhs_arena);
    swap(_impl_.printer_type_, other->_impl_.printer_type_);
}

std::string ContentMetaData_PrintMetadata::GetTypeName() const
{
    return "enterprise_connectors.ContentMetaData.PrintMetadata";
}

// ===================================================================

class ContentMetaData::_Internal {
public:
    using HasBits = decltype(std::declval<ContentMetaData>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_filename(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_digest(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::safe_browsing::ClientDownloadRequest& csd(const ContentMetaData* msg);
    static void set_has_csd(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_email(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_content_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_source(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_destination(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_tab_title(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_tab_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static const ::enterprise_connectors::ContentMetaData_PrintMetadata& print_metadata(const ContentMetaData* msg);
    static void set_has_print_metadata(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_decryption_key(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
};

const ::safe_browsing::ClientDownloadRequest& ContentMetaData::_Internal::csd(const ContentMetaData* msg)
{
    return *msg->_impl_.csd_;
}
const ::enterprise_connectors::ContentMetaData_PrintMetadata& ContentMetaData::_Internal::print_metadata(const ContentMetaData* msg)
{
    return *msg->_impl_.print_metadata_;
}
void ContentMetaData::clear_csd()
{
    if (_impl_.csd_ != nullptr)
        _impl_.csd_->Clear();
    _impl_._has_bits_[0] &= ~0x00000400u;
}
ContentMetaData::ContentMetaData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentMetaData)
}
ContentMetaData::ContentMetaData(const ContentMetaData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ContentMetaData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {},
        decltype(_impl_.filename_) {}, decltype(_impl_.digest_) {}, decltype(_impl_.email_) {}, decltype(_impl_.content_type_) {}, decltype(_impl_.source_) {},
        decltype(_impl_.destination_) {}, decltype(_impl_.tab_title_) {}, decltype(_impl_.tab_url_) {}, decltype(_impl_.decryption_key_) {},
        decltype(_impl_.csd_) { nullptr }, decltype(_impl_.print_metadata_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _impl_.filename_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_filename()) {
        _this->_impl_.filename_.Set(from._internal_filename(), _this->GetArenaForAllocation());
    }
    _impl_.digest_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.digest_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_digest()) {
        _this->_impl_.digest_.Set(from._internal_digest(), _this->GetArenaForAllocation());
    }
    _impl_.email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_email()) {
        _this->_impl_.email_.Set(from._internal_email(), _this->GetArenaForAllocation());
    }
    _impl_.content_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_content_type()) {
        _this->_impl_.content_type_.Set(from._internal_content_type(), _this->GetArenaForAllocation());
    }
    _impl_.source_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_source()) {
        _this->_impl_.source_.Set(from._internal_source(), _this->GetArenaForAllocation());
    }
    _impl_.destination_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.destination_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_destination()) {
        _this->_impl_.destination_.Set(from._internal_destination(), _this->GetArenaForAllocation());
    }
    _impl_.tab_title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tab_title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_tab_title()) {
        _this->_impl_.tab_title_.Set(from._internal_tab_title(), _this->GetArenaForAllocation());
    }
    _impl_.tab_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tab_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_tab_url()) {
        _this->_impl_.tab_url_.Set(from._internal_tab_url(), _this->GetArenaForAllocation());
    }
    _impl_.decryption_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.decryption_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_decryption_key()) {
        _this->_impl_.decryption_key_.Set(from._internal_decryption_key(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_csd()) {
        _this->_impl_.csd_ = new ::safe_browsing::ClientDownloadRequest(*from._impl_.csd_);
    }
    if (from._internal_has_print_metadata()) {
        _this->_impl_.print_metadata_ = new ::enterprise_connectors::ContentMetaData_PrintMetadata(*from._impl_.print_metadata_);
    }
    // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentMetaData)
}

inline void ContentMetaData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {}, decltype(_impl_.filename_) {},
        decltype(_impl_.digest_) {}, decltype(_impl_.email_) {}, decltype(_impl_.content_type_) {}, decltype(_impl_.source_) {},
        decltype(_impl_.destination_) {}, decltype(_impl_.tab_title_) {}, decltype(_impl_.tab_url_) {}, decltype(_impl_.decryption_key_) {},
        decltype(_impl_.csd_) { nullptr }, decltype(_impl_.print_metadata_) { nullptr } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.digest_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.digest_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.source_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.destination_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.destination_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tab_title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tab_title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tab_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tab_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.decryption_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.decryption_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContentMetaData::~ContentMetaData()
{
    // @@protoc_insertion_point(destructor:enterprise_connectors.ContentMetaData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ContentMetaData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
    _impl_.filename_.Destroy();
    _impl_.digest_.Destroy();
    _impl_.email_.Destroy();
    _impl_.content_type_.Destroy();
    _impl_.source_.Destroy();
    _impl_.destination_.Destroy();
    _impl_.tab_title_.Destroy();
    _impl_.tab_url_.Destroy();
    _impl_.decryption_key_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.csd_;
    if (this != internal_default_instance())
        delete _impl_.print_metadata_;
}

void ContentMetaData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ContentMetaData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentMetaData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.filename_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.digest_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.email_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.content_type_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.source_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000040u) {
            _impl_.destination_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000080u) {
            _impl_.tab_title_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        if (cached_has_bits & 0x00000100u) {
            _impl_.tab_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000200u) {
            _impl_.decryption_key_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000400u) {
            GOOGLE_DCHECK(_impl_.csd_ != nullptr);
            _impl_.csd_->Clear();
        }
        if (cached_has_bits & 0x00000800u) {
            GOOGLE_DCHECK(_impl_.print_metadata_ != nullptr);
            _impl_.print_metadata_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ContentMetaData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string filename = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_filename();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string digest = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_digest();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest csd = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_csd(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string email = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_email();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string content_type = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_content_type();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string source = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_source();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string destination = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_destination();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string tab_title = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                auto str = _internal_mutable_tab_title();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string tab_url = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                auto str = _internal_mutable_tab_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ContentMetaData.PrintMetadata print_metadata = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_print_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes decryption_key = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                auto str = _internal_mutable_decryption_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ContentMetaData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentMetaData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // optional string filename = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_filename(), target);
    }

    // optional string digest = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_digest(), target);
    }

    // optional .safe_browsing.ClientDownloadRequest csd = 4;
    if (cached_has_bits & 0x00000400u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::csd(this), _Internal::csd(this).GetCachedSize(), target, stream);
    }

    // optional string email = 5;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_email(), target);
    }

    // optional string content_type = 6;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(6, this->_internal_content_type(), target);
    }

    // optional string source = 7;
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_source(), target);
    }

    // optional string destination = 8;
    if (cached_has_bits & 0x00000040u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_destination(), target);
    }

    // optional string tab_title = 9;
    if (cached_has_bits & 0x00000080u) {
        target = stream->WriteStringMaybeAliased(9, this->_internal_tab_title(), target);
    }

    // optional string tab_url = 10;
    if (cached_has_bits & 0x00000100u) {
        target = stream->WriteStringMaybeAliased(10, this->_internal_tab_url(), target);
    }

    // optional .enterprise_connectors.ContentMetaData.PrintMetadata print_metadata = 11;
    if (cached_has_bits & 0x00000800u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::print_metadata(this), _Internal::print_metadata(this).GetCachedSize(), target, stream);
    }

    // optional bytes decryption_key = 12;
    if (cached_has_bits & 0x00000200u) {
        target = stream->WriteBytesMaybeAliased(12, this->_internal_decryption_key(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentMetaData)
    return target;
}

size_t ContentMetaData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentMetaData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional string filename = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_filename());
        }

        // optional string digest = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_digest());
        }

        // optional string email = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_email());
        }

        // optional string content_type = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_content_type());
        }

        // optional string source = 7;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_source());
        }

        // optional string destination = 8;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_destination());
        }

        // optional string tab_title = 9;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_tab_title());
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        // optional string tab_url = 10;
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_tab_url());
        }

        // optional bytes decryption_key = 12;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_decryption_key());
        }

        // optional .safe_browsing.ClientDownloadRequest csd = 4;
        if (cached_has_bits & 0x00000400u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.csd_);
        }

        // optional .enterprise_connectors.ContentMetaData.PrintMetadata print_metadata = 11;
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.print_metadata_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ContentMetaData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ContentMetaData*>(&from));
}

void ContentMetaData::MergeFrom(const ContentMetaData& from)
{
    ContentMetaData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentMetaData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_filename(from._internal_filename());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_digest(from._internal_digest());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_email(from._internal_email());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_content_type(from._internal_content_type());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_source(from._internal_source());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_set_destination(from._internal_destination());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_set_tab_title(from._internal_tab_title());
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_set_tab_url(from._internal_tab_url());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_internal_set_decryption_key(from._internal_decryption_key());
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_internal_mutable_csd()->::safe_browsing::ClientDownloadRequest::MergeFrom(from._internal_csd());
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_internal_mutable_print_metadata()->::enterprise_connectors::ContentMetaData_PrintMetadata::MergeFrom(from._internal_print_metadata());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentMetaData::CopyFrom(const ContentMetaData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentMetaData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ContentMetaData::IsInitialized() const
{
    if (_internal_has_csd()) {
        if (!_impl_.csd_->IsInitialized())
            return false;
    }
    return true;
}

void ContentMetaData::InternalSwap(ContentMetaData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.filename_, lhs_arena, &other->_impl_.filename_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.digest_, lhs_arena, &other->_impl_.digest_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.email_, lhs_arena, &other->_impl_.email_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.content_type_, lhs_arena, &other->_impl_.content_type_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.source_, lhs_arena, &other->_impl_.source_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.destination_, lhs_arena, &other->_impl_.destination_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.tab_title_, lhs_arena, &other->_impl_.tab_title_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.tab_url_, lhs_arena, &other->_impl_.tab_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.decryption_key_, lhs_arena, &other->_impl_.decryption_key_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ContentMetaData, _impl_.print_metadata_) + sizeof(ContentMetaData::_impl_.print_metadata_)
        - PROTOBUF_FIELD_OFFSET(ContentMetaData, _impl_.csd_)>(reinterpret_cast<char*>(&_impl_.csd_), reinterpret_cast<char*>(&other->_impl_.csd_));
}

std::string ContentMetaData::GetTypeName() const
{
    return "enterprise_connectors.ContentMetaData";
}

// ===================================================================

class ClientMetadata_Browser::_Internal {
public:
    using HasBits = decltype(std::declval<ClientMetadata_Browser>()._impl_._has_bits_);
    static void set_has_browser_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_user_agent(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_chrome_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_machine_user(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

ClientMetadata_Browser::ClientMetadata_Browser(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ClientMetadata.Browser)
}
ClientMetadata_Browser::ClientMetadata_Browser(const ClientMetadata_Browser& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientMetadata_Browser* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.browser_id_) {},
        decltype(_impl_.user_agent_) {}, decltype(_impl_.chrome_version_) {}, decltype(_impl_.machine_user_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.browser_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_browser_id()) {
        _this->_impl_.browser_id_.Set(from._internal_browser_id(), _this->GetArenaForAllocation());
    }
    _impl_.user_agent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_agent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_user_agent()) {
        _this->_impl_.user_agent_.Set(from._internal_user_agent(), _this->GetArenaForAllocation());
    }
    _impl_.chrome_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chrome_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_chrome_version()) {
        _this->_impl_.chrome_version_.Set(from._internal_chrome_version(), _this->GetArenaForAllocation());
    }
    _impl_.machine_user_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_user_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_machine_user()) {
        _this->_impl_.machine_user_.Set(from._internal_machine_user(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ClientMetadata.Browser)
}

inline void ClientMetadata_Browser::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.browser_id_) {},
        decltype(_impl_.user_agent_) {}, decltype(_impl_.chrome_version_) {}, decltype(_impl_.machine_user_) {} };
    _impl_.browser_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_agent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_agent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chrome_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chrome_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_user_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.machine_user_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientMetadata_Browser::~ClientMetadata_Browser()
{
    // @@protoc_insertion_point(destructor:enterprise_connectors.ClientMetadata.Browser)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientMetadata_Browser::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.browser_id_.Destroy();
    _impl_.user_agent_.Destroy();
    _impl_.chrome_version_.Destroy();
    _impl_.machine_user_.Destroy();
}

void ClientMetadata_Browser::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientMetadata_Browser::Clear()
{
    // @@protoc_insertion_point(message_clear_start:enterprise_connectors.ClientMetadata.Browser)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.browser_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.user_agent_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.chrome_version_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.machine_user_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientMetadata_Browser::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string browser_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_browser_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string user_agent = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_user_agent();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string chrome_version = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_chrome_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string machine_user = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_machine_user();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientMetadata_Browser::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ClientMetadata.Browser)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string browser_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_browser_id(), target);
    }

    // optional string user_agent = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_user_agent(), target);
    }

    // optional string chrome_version = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_chrome_version(), target);
    }

    // optional string machine_user = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_machine_user(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ClientMetadata.Browser)
    return target;
}

size_t ClientMetadata_Browser::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ClientMetadata.Browser)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string browser_id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_browser_id());
        }

        // optional string user_agent = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_user_agent());
        }

        // optional string chrome_version = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_chrome_version());
        }

        // optional string machine_user = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_machine_user());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientMetadata_Browser::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientMetadata_Browser*>(&from));
}

void ClientMetadata_Browser::MergeFrom(const ClientMetadata_Browser& from)
{
    ClientMetadata_Browser* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ClientMetadata.Browser)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_browser_id(from._internal_browser_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_user_agent(from._internal_user_agent());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_chrome_version(from._internal_chrome_version());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_machine_user(from._internal_machine_user());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientMetadata_Browser::CopyFrom(const ClientMetadata_Browser& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ClientMetadata.Browser)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientMetadata_Browser::IsInitialized() const
{
    return true;
}

void ClientMetadata_Browser::InternalSwap(ClientMetadata_Browser* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.browser_id_, lhs_arena, &other->_impl_.browser_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.user_agent_, lhs_arena, &other->_impl_.user_agent_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.chrome_version_, lhs_arena, &other->_impl_.chrome_version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.machine_user_, lhs_arena, &other->_impl_.machine_user_, rhs_arena);
}

std::string ClientMetadata_Browser::GetTypeName() const
{
    return "enterprise_connectors.ClientMetadata.Browser";
}

// ===================================================================

class ClientMetadata_Device::_Internal {
public:
    using HasBits = decltype(std::declval<ClientMetadata_Device>()._impl_._has_bits_);
    static void set_has_dm_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_client_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_os_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_os_platform(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

ClientMetadata_Device::ClientMetadata_Device(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ClientMetadata.Device)
}
ClientMetadata_Device::ClientMetadata_Device(const ClientMetadata_Device& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientMetadata_Device* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.dm_token_) {},
        decltype(_impl_.client_id_) {}, decltype(_impl_.os_version_) {}, decltype(_impl_.os_platform_) {}, decltype(_impl_.name_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.dm_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dm_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_dm_token()) {
        _this->_impl_.dm_token_.Set(from._internal_dm_token(), _this->GetArenaForAllocation());
    }
    _impl_.client_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_client_id()) {
        _this->_impl_.client_id_.Set(from._internal_client_id(), _this->GetArenaForAllocation());
    }
    _impl_.os_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_os_version()) {
        _this->_impl_.os_version_.Set(from._internal_os_version(), _this->GetArenaForAllocation());
    }
    _impl_.os_platform_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_platform_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_os_platform()) {
        _this->_impl_.os_platform_.Set(from._internal_os_platform(), _this->GetArenaForAllocation());
    }
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ClientMetadata.Device)
}

inline void ClientMetadata_Device::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.dm_token_) {}, decltype(_impl_.client_id_) {},
        decltype(_impl_.os_version_) {}, decltype(_impl_.os_platform_) {}, decltype(_impl_.name_) {} };
    _impl_.dm_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dm_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_platform_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_platform_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientMetadata_Device::~ClientMetadata_Device()
{
    // @@protoc_insertion_point(destructor:enterprise_connectors.ClientMetadata.Device)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientMetadata_Device::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.dm_token_.Destroy();
    _impl_.client_id_.Destroy();
    _impl_.os_version_.Destroy();
    _impl_.os_platform_.Destroy();
    _impl_.name_.Destroy();
}

void ClientMetadata_Device::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientMetadata_Device::Clear()
{
    // @@protoc_insertion_point(message_clear_start:enterprise_connectors.ClientMetadata.Device)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.dm_token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.client_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.os_version_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.os_platform_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientMetadata_Device::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string dm_token = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_dm_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string client_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_client_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string os_version = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_os_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string os_platform = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_os_platform();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string name = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientMetadata_Device::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ClientMetadata.Device)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string dm_token = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_dm_token(), target);
    }

    // optional string client_id = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_client_id(), target);
    }

    // optional string os_version = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_os_version(), target);
    }

    // optional string os_platform = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_os_platform(), target);
    }

    // optional string name = 5;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_name(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ClientMetadata.Device)
    return target;
}

size_t ClientMetadata_Device::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ClientMetadata.Device)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string dm_token = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_dm_token());
        }

        // optional string client_id = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_client_id());
        }

        // optional string os_version = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_os_version());
        }

        // optional string os_platform = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_os_platform());
        }

        // optional string name = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientMetadata_Device::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientMetadata_Device*>(&from));
}

void ClientMetadata_Device::MergeFrom(const ClientMetadata_Device& from)
{
    ClientMetadata_Device* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ClientMetadata.Device)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_dm_token(from._internal_dm_token());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_client_id(from._internal_client_id());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_os_version(from._internal_os_version());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_os_platform(from._internal_os_platform());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_name(from._internal_name());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientMetadata_Device::CopyFrom(const ClientMetadata_Device& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ClientMetadata.Device)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientMetadata_Device::IsInitialized() const
{
    return true;
}

void ClientMetadata_Device::InternalSwap(ClientMetadata_Device* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.dm_token_, lhs_arena, &other->_impl_.dm_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.client_id_, lhs_arena, &other->_impl_.client_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.os_version_, lhs_arena, &other->_impl_.os_version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.os_platform_, lhs_arena, &other->_impl_.os_platform_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
}

std::string ClientMetadata_Device::GetTypeName() const
{
    return "enterprise_connectors.ClientMetadata.Device";
}

// ===================================================================

class ClientMetadata_Profile::_Internal {
public:
    using HasBits = decltype(std::declval<ClientMetadata_Profile>()._impl_._has_bits_);
    static void set_has_dm_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_gaia_email(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_profile_path(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_profile_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_client_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

ClientMetadata_Profile::ClientMetadata_Profile(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ClientMetadata.Profile)
}
ClientMetadata_Profile::ClientMetadata_Profile(const ClientMetadata_Profile& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientMetadata_Profile* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.dm_token_) {},
        decltype(_impl_.gaia_email_) {}, decltype(_impl_.profile_path_) {}, decltype(_impl_.profile_name_) {}, decltype(_impl_.client_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.dm_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dm_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_dm_token()) {
        _this->_impl_.dm_token_.Set(from._internal_dm_token(), _this->GetArenaForAllocation());
    }
    _impl_.gaia_email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gaia_email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_gaia_email()) {
        _this->_impl_.gaia_email_.Set(from._internal_gaia_email(), _this->GetArenaForAllocation());
    }
    _impl_.profile_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_profile_path()) {
        _this->_impl_.profile_path_.Set(from._internal_profile_path(), _this->GetArenaForAllocation());
    }
    _impl_.profile_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_profile_name()) {
        _this->_impl_.profile_name_.Set(from._internal_profile_name(), _this->GetArenaForAllocation());
    }
    _impl_.client_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_client_id()) {
        _this->_impl_.client_id_.Set(from._internal_client_id(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ClientMetadata.Profile)
}

inline void ClientMetadata_Profile::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.dm_token_) {}, decltype(_impl_.gaia_email_) {},
        decltype(_impl_.profile_path_) {}, decltype(_impl_.profile_name_) {}, decltype(_impl_.client_id_) {} };
    _impl_.dm_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dm_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gaia_email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gaia_email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientMetadata_Profile::~ClientMetadata_Profile()
{
    // @@protoc_insertion_point(destructor:enterprise_connectors.ClientMetadata.Profile)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientMetadata_Profile::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.dm_token_.Destroy();
    _impl_.gaia_email_.Destroy();
    _impl_.profile_path_.Destroy();
    _impl_.profile_name_.Destroy();
    _impl_.client_id_.Destroy();
}

void ClientMetadata_Profile::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientMetadata_Profile::Clear()
{
    // @@protoc_insertion_point(message_clear_start:enterprise_connectors.ClientMetadata.Profile)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.dm_token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.gaia_email_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.profile_path_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.profile_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.client_id_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientMetadata_Profile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string dm_token = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_dm_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string gaia_email = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_gaia_email();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string profile_path = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_profile_path();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string profile_name = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_profile_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string client_id = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_client_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientMetadata_Profile::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ClientMetadata.Profile)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string dm_token = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_dm_token(), target);
    }

    // optional string gaia_email = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_gaia_email(), target);
    }

    // optional string profile_path = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_profile_path(), target);
    }

    // optional string profile_name = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_profile_name(), target);
    }

    // optional string client_id = 5;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_client_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ClientMetadata.Profile)
    return target;
}

size_t ClientMetadata_Profile::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ClientMetadata.Profile)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string dm_token = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_dm_token());
        }

        // optional string gaia_email = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_gaia_email());
        }

        // optional string profile_path = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_profile_path());
        }

        // optional string profile_name = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_profile_name());
        }

        // optional string client_id = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_client_id());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientMetadata_Profile::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientMetadata_Profile*>(&from));
}

void ClientMetadata_Profile::MergeFrom(const ClientMetadata_Profile& from)
{
    ClientMetadata_Profile* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ClientMetadata.Profile)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_dm_token(from._internal_dm_token());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_gaia_email(from._internal_gaia_email());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_profile_path(from._internal_profile_path());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_profile_name(from._internal_profile_name());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_client_id(from._internal_client_id());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientMetadata_Profile::CopyFrom(const ClientMetadata_Profile& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ClientMetadata.Profile)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientMetadata_Profile::IsInitialized() const
{
    return true;
}

void ClientMetadata_Profile::InternalSwap(ClientMetadata_Profile* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.dm_token_, lhs_arena, &other->_impl_.dm_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.gaia_email_, lhs_arena, &other->_impl_.gaia_email_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.profile_path_, lhs_arena, &other->_impl_.profile_path_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.profile_name_, lhs_arena, &other->_impl_.profile_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.client_id_, lhs_arena, &other->_impl_.client_id_, rhs_arena);
}

std::string ClientMetadata_Profile::GetTypeName() const
{
    return "enterprise_connectors.ClientMetadata.Profile";
}

// ===================================================================

class ClientMetadata::_Internal {
public:
    using HasBits = decltype(std::declval<ClientMetadata>()._impl_._has_bits_);
    static const ::enterprise_connectors::ClientMetadata_Browser& browser(const ClientMetadata* msg);
    static void set_has_browser(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::enterprise_connectors::ClientMetadata_Device& device(const ClientMetadata* msg);
    static void set_has_device(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::enterprise_connectors::ClientMetadata_Profile& profile(const ClientMetadata* msg);
    static void set_has_profile(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_is_chrome_os_managed_guest_session(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::enterprise_connectors::ClientMetadata_Browser& ClientMetadata::_Internal::browser(const ClientMetadata* msg)
{
    return *msg->_impl_.browser_;
}
const ::enterprise_connectors::ClientMetadata_Device& ClientMetadata::_Internal::device(const ClientMetadata* msg)
{
    return *msg->_impl_.device_;
}
const ::enterprise_connectors::ClientMetadata_Profile& ClientMetadata::_Internal::profile(const ClientMetadata* msg)
{
    return *msg->_impl_.profile_;
}
ClientMetadata::ClientMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ClientMetadata)
}
ClientMetadata::ClientMetadata(const ClientMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.browser_) { nullptr },
        decltype(_impl_.device_) { nullptr }, decltype(_impl_.profile_) { nullptr }, decltype(_impl_.is_chrome_os_managed_guest_session_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_browser()) {
        _this->_impl_.browser_ = new ::enterprise_connectors::ClientMetadata_Browser(*from._impl_.browser_);
    }
    if (from._internal_has_device()) {
        _this->_impl_.device_ = new ::enterprise_connectors::ClientMetadata_Device(*from._impl_.device_);
    }
    if (from._internal_has_profile()) {
        _this->_impl_.profile_ = new ::enterprise_connectors::ClientMetadata_Profile(*from._impl_.profile_);
    }
    _this->_impl_.is_chrome_os_managed_guest_session_ = from._impl_.is_chrome_os_managed_guest_session_;
    // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ClientMetadata)
}

inline void ClientMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.browser_) { nullptr },
        decltype(_impl_.device_) { nullptr }, decltype(_impl_.profile_) { nullptr }, decltype(_impl_.is_chrome_os_managed_guest_session_) { false } };
}

ClientMetadata::~ClientMetadata()
{
    // @@protoc_insertion_point(destructor:enterprise_connectors.ClientMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.browser_;
    if (this != internal_default_instance())
        delete _impl_.device_;
    if (this != internal_default_instance())
        delete _impl_.profile_;
}

void ClientMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:enterprise_connectors.ClientMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.browser_ != nullptr);
            _impl_.browser_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.device_ != nullptr);
            _impl_.device_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.profile_ != nullptr);
            _impl_.profile_->Clear();
        }
    }
    _impl_.is_chrome_os_managed_guest_session_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .enterprise_connectors.ClientMetadata.Browser browser = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_browser(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ClientMetadata.Device device = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_device(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ClientMetadata.Profile profile = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_profile(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_chrome_os_managed_guest_session = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_is_chrome_os_managed_guest_session(&has_bits);
                _impl_.is_chrome_os_managed_guest_session_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ClientMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .enterprise_connectors.ClientMetadata.Browser browser = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::browser(this), _Internal::browser(this).GetCachedSize(), target, stream);
    }

    // optional .enterprise_connectors.ClientMetadata.Device device = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::device(this), _Internal::device(this).GetCachedSize(), target, stream);
    }

    // optional .enterprise_connectors.ClientMetadata.Profile profile = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::profile(this), _Internal::profile(this).GetCachedSize(), target, stream);
    }

    // optional bool is_chrome_os_managed_guest_session = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_chrome_os_managed_guest_session(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ClientMetadata)
    return target;
}

size_t ClientMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ClientMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .enterprise_connectors.ClientMetadata.Browser browser = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.browser_);
        }

        // optional .enterprise_connectors.ClientMetadata.Device device = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.device_);
        }

        // optional .enterprise_connectors.ClientMetadata.Profile profile = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.profile_);
        }

        // optional bool is_chrome_os_managed_guest_session = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientMetadata*>(&from));
}

void ClientMetadata::MergeFrom(const ClientMetadata& from)
{
    ClientMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ClientMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_browser()->::enterprise_connectors::ClientMetadata_Browser::MergeFrom(from._internal_browser());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_device()->::enterprise_connectors::ClientMetadata_Device::MergeFrom(from._internal_device());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_profile()->::enterprise_connectors::ClientMetadata_Profile::MergeFrom(from._internal_profile());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.is_chrome_os_managed_guest_session_ = from._impl_.is_chrome_os_managed_guest_session_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientMetadata::CopyFrom(const ClientMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ClientMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientMetadata::IsInitialized() const
{
    return true;
}

void ClientMetadata::InternalSwap(ClientMetadata* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientMetadata, _impl_.is_chrome_os_managed_guest_session_)
        + sizeof(ClientMetadata::_impl_.is_chrome_os_managed_guest_session_) - PROTOBUF_FIELD_OFFSET(ClientMetadata, _impl_.browser_)>(
        reinterpret_cast<char*>(&_impl_.browser_), reinterpret_cast<char*>(&other->_impl_.browser_));
}

std::string ClientMetadata::GetTypeName() const
{
    return "enterprise_connectors.ClientMetadata";
}

// ===================================================================

class ContentAnalysisRequest::_Internal {
public:
    using HasBits = decltype(std::declval<ContentAnalysisRequest>()._impl_._has_bits_);
    static void set_has_device_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_fcm_notification_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_request_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_analysis_connector(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static const ::enterprise_connectors::ContentMetaData& request_data(const ContentAnalysisRequest* msg);
    static void set_has_request_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::enterprise_connectors::ClientMetadata& client_metadata(const ContentAnalysisRequest* msg);
    static void set_has_client_metadata(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_expires_at(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_user_action_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_user_action_requests_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_reason(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_blocking(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_require_metadata_verdict(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
};

const ::enterprise_connectors::ContentMetaData& ContentAnalysisRequest::_Internal::request_data(const ContentAnalysisRequest* msg)
{
    return *msg->_impl_.request_data_;
}
const ::enterprise_connectors::ClientMetadata& ContentAnalysisRequest::_Internal::client_metadata(const ContentAnalysisRequest* msg)
{
    return *msg->_impl_.client_metadata_;
}
ContentAnalysisRequest::ContentAnalysisRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentAnalysisRequest)
}
ContentAnalysisRequest::ContentAnalysisRequest(const ContentAnalysisRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ContentAnalysisRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.tags_) { from._impl_.tags_ }, decltype(_impl_.device_token_) {}, decltype(_impl_.fcm_notification_token_) {},
        decltype(_impl_.request_token_) {}, decltype(_impl_.user_action_id_) {}, decltype(_impl_.request_data_) { nullptr },
        decltype(_impl_.client_metadata_) { nullptr }, decltype(_impl_.analysis_connector_) {}, decltype(_impl_.reason_) {}, decltype(_impl_.expires_at_) {},
        decltype(_impl_.user_action_requests_count_) {}, decltype(_impl_.blocking_) {}, decltype(_impl_.require_metadata_verdict_) {},
        decltype(_impl_.content_data_) {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.device_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_device_token()) {
        _this->_impl_.device_token_.Set(from._internal_device_token(), _this->GetArenaForAllocation());
    }
    _impl_.fcm_notification_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fcm_notification_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_fcm_notification_token()) {
        _this->_impl_.fcm_notification_token_.Set(from._internal_fcm_notification_token(), _this->GetArenaForAllocation());
    }
    _impl_.request_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_request_token()) {
        _this->_impl_.request_token_.Set(from._internal_request_token(), _this->GetArenaForAllocation());
    }
    _impl_.user_action_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_action_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_user_action_id()) {
        _this->_impl_.user_action_id_.Set(from._internal_user_action_id(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_request_data()) {
        _this->_impl_.request_data_ = new ::enterprise_connectors::ContentMetaData(*from._impl_.request_data_);
    }
    if (from._internal_has_client_metadata()) {
        _this->_impl_.client_metadata_ = new ::enterprise_connectors::ClientMetadata(*from._impl_.client_metadata_);
    }
    ::memcpy(&_impl_.analysis_connector_, &from._impl_.analysis_connector_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.require_metadata_verdict_) - reinterpret_cast<char*>(&_impl_.analysis_connector_))
            + sizeof(_impl_.require_metadata_verdict_));
    clear_has_content_data();
    switch (from.content_data_case()) {
    case kTextContent: {
        _this->_internal_set_text_content(from._internal_text_content());
        break;
    }
    case kFilePath: {
        _this->_internal_set_file_path(from._internal_file_path());
        break;
    }
    case CONTENT_DATA_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentAnalysisRequest)
}

inline void ContentAnalysisRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.tags_) { arena },
        decltype(_impl_.device_token_) {}, decltype(_impl_.fcm_notification_token_) {}, decltype(_impl_.request_token_) {}, decltype(_impl_.user_action_id_) {},
        decltype(_impl_.request_data_) { nullptr }, decltype(_impl_.client_metadata_) { nullptr }, decltype(_impl_.analysis_connector_) { 0 },
        decltype(_impl_.reason_) { 0 }, decltype(_impl_.expires_at_) { int64_t { 0 } }, decltype(_impl_.user_action_requests_count_) { int64_t { 0 } },
        decltype(_impl_.blocking_) { false }, decltype(_impl_.require_metadata_verdict_) { false }, decltype(_impl_.content_data_) {},
        /*decltype(_impl_._oneof_case_)*/ {} };
    _impl_.device_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fcm_notification_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fcm_notification_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_action_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_action_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    clear_has_content_data();
}

ContentAnalysisRequest::~ContentAnalysisRequest()
{
    // @@protoc_insertion_point(destructor:enterprise_connectors.ContentAnalysisRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ContentAnalysisRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.tags_.~RepeatedPtrField();
    _impl_.device_token_.Destroy();
    _impl_.fcm_notification_token_.Destroy();
    _impl_.request_token_.Destroy();
    _impl_.user_action_id_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.request_data_;
    if (this != internal_default_instance())
        delete _impl_.client_metadata_;
    if (has_content_data()) {
        clear_content_data();
    }
}

void ContentAnalysisRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ContentAnalysisRequest::clear_content_data()
{
    // @@protoc_insertion_point(one_of_clear_start:enterprise_connectors.ContentAnalysisRequest)
    switch (content_data_case()) {
    case kTextContent: {
        _impl_.content_data_.text_content_.Destroy();
        break;
    }
    case kFilePath: {
        _impl_.content_data_.file_path_.Destroy();
        break;
    }
    case CONTENT_DATA_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = CONTENT_DATA_NOT_SET;
}

void ContentAnalysisRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentAnalysisRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.tags_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.device_token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.fcm_notification_token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.request_token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.user_action_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.request_data_ != nullptr);
            _impl_.request_data_->Clear();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.client_metadata_ != nullptr);
            _impl_.client_metadata_->Clear();
        }
    }
    if (cached_has_bits & 0x000000c0u) {
        ::memset(&_impl_.analysis_connector_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.reason_) - reinterpret_cast<char*>(&_impl_.analysis_connector_)) + sizeof(_impl_.reason_));
    }
    if (cached_has_bits & 0x00000f00u) {
        ::memset(&_impl_.expires_at_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.require_metadata_verdict_) - reinterpret_cast<char*>(&_impl_.expires_at_))
                + sizeof(_impl_.require_metadata_verdict_));
    }
    clear_content_data();
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ContentAnalysisRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string device_token = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_device_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string fcm_notification_token = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_fcm_notification_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string request_token = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_request_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.AnalysisConnector analysis_connector = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::enterprise_connectors::AnalysisConnector_IsValid(val))) {
                    _internal_set_analysis_connector(static_cast<::enterprise_connectors::AnalysisConnector>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ContentMetaData request_data = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr = ctx->ParseMessage(_internal_mutable_request_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string tags = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_tags();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ClientMetadata client_metadata = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                ptr = ctx->ParseMessage(_internal_mutable_client_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string text_content = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                auto str = _internal_mutable_text_content();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string file_path = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                auto str = _internal_mutable_file_path();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 expires_at = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
                _Internal::set_has_expires_at(&has_bits);
                _impl_.expires_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string user_action_id = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                auto str = _internal_mutable_user_action_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 user_action_requests_count = 17;
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
                _Internal::set_has_user_action_requests_count(&has_bits);
                _impl_.user_action_requests_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ContentAnalysisRequest.Reason reason = 19;
        case 19:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::enterprise_connectors::ContentAnalysisRequest_Reason_IsValid(val))) {
                    _internal_set_reason(static_cast<::enterprise_connectors::ContentAnalysisRequest_Reason>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional bool blocking = 20;
        case 20:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
                _Internal::set_has_blocking(&has_bits);
                _impl_.blocking_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool require_metadata_verdict = 21;
        case 21:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
                _Internal::set_has_require_metadata_verdict(&has_bits);
                _impl_.require_metadata_verdict_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ContentAnalysisRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentAnalysisRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string device_token = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_device_token(), target);
    }

    // optional string fcm_notification_token = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_fcm_notification_token(), target);
    }

    // optional string request_token = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_request_token(), target);
    }

    // optional .enterprise_connectors.AnalysisConnector analysis_connector = 9;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(9, this->_internal_analysis_connector(), target);
    }

    // optional .enterprise_connectors.ContentMetaData request_data = 10;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            10, _Internal::request_data(this), _Internal::request_data(this).GetCachedSize(), target, stream);
    }

    // repeated string tags = 11;
    for (int i = 0, n = this->_internal_tags_size(); i < n; i++) {
        const auto& s = this->_internal_tags(i);
        target = stream->WriteString(11, s, target);
    }

    // optional .enterprise_connectors.ClientMetadata client_metadata = 12;
    if (cached_has_bits & 0x00000020u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            12, _Internal::client_metadata(this), _Internal::client_metadata(this).GetCachedSize(), target, stream);
    }

    switch (content_data_case()) {
    case kTextContent: {
        target = stream->WriteStringMaybeAliased(13, this->_internal_text_content(), target);
        break;
    }
    case kFilePath: {
        target = stream->WriteStringMaybeAliased(14, this->_internal_file_path(), target);
        break;
    }
    default:;
    }
    // optional int64 expires_at = 15;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(15, this->_internal_expires_at(), target);
    }

    // optional string user_action_id = 16;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(16, this->_internal_user_action_id(), target);
    }

    // optional int64 user_action_requests_count = 17;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(17, this->_internal_user_action_requests_count(), target);
    }

    // optional .enterprise_connectors.ContentAnalysisRequest.Reason reason = 19;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(19, this->_internal_reason(), target);
    }

    // optional bool blocking = 20;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_blocking(), target);
    }

    // optional bool require_metadata_verdict = 21;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_require_metadata_verdict(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentAnalysisRequest)
    return target;
}

size_t ContentAnalysisRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentAnalysisRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string tags = 11;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.tags_.size());
    for (int i = 0, n = _impl_.tags_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.tags_.Get(i));
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string device_token = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_device_token());
        }

        // optional string fcm_notification_token = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_fcm_notification_token());
        }

        // optional string request_token = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_request_token());
        }

        // optional string user_action_id = 16;
        if (cached_has_bits & 0x00000008u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_user_action_id());
        }

        // optional .enterprise_connectors.ContentMetaData request_data = 10;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.request_data_);
        }

        // optional .enterprise_connectors.ClientMetadata client_metadata = 12;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.client_metadata_);
        }

        // optional .enterprise_connectors.AnalysisConnector analysis_connector = 9;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_analysis_connector());
        }

        // optional .enterprise_connectors.ContentAnalysisRequest.Reason reason = 19;
        if (cached_has_bits & 0x00000080u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_reason());
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        // optional int64 expires_at = 15;
        if (cached_has_bits & 0x00000100u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_expires_at());
        }

        // optional int64 user_action_requests_count = 17;
        if (cached_has_bits & 0x00000200u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_user_action_requests_count());
        }

        // optional bool blocking = 20;
        if (cached_has_bits & 0x00000400u) {
            total_size += 2 + 1;
        }

        // optional bool require_metadata_verdict = 21;
        if (cached_has_bits & 0x00000800u) {
            total_size += 2 + 1;
        }
    }
    switch (content_data_case()) {
    // string text_content = 13;
    case kTextContent: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_text_content());
        break;
    }
    // string file_path = 14;
    case kFilePath: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_file_path());
        break;
    }
    case CONTENT_DATA_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ContentAnalysisRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ContentAnalysisRequest*>(&from));
}

void ContentAnalysisRequest::MergeFrom(const ContentAnalysisRequest& from)
{
    ContentAnalysisRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentAnalysisRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.tags_.MergeFrom(from._impl_.tags_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_device_token(from._internal_device_token());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_fcm_notification_token(from._internal_fcm_notification_token());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_request_token(from._internal_request_token());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_user_action_id(from._internal_user_action_id());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_request_data()->::enterprise_connectors::ContentMetaData::MergeFrom(from._internal_request_data());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_client_metadata()->::enterprise_connectors::ClientMetadata::MergeFrom(from._internal_client_metadata());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.analysis_connector_ = from._impl_.analysis_connector_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.reason_ = from._impl_.reason_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00000f00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.expires_at_ = from._impl_.expires_at_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.user_action_requests_count_ = from._impl_.user_action_requests_count_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.blocking_ = from._impl_.blocking_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.require_metadata_verdict_ = from._impl_.require_metadata_verdict_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    switch (from.content_data_case()) {
    case kTextContent: {
        _this->_internal_set_text_content(from._internal_text_content());
        break;
    }
    case kFilePath: {
        _this->_internal_set_file_path(from._internal_file_path());
        break;
    }
    case CONTENT_DATA_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentAnalysisRequest::CopyFrom(const ContentAnalysisRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentAnalysisRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ContentAnalysisRequest::IsInitialized() const
{
    if (_internal_has_request_data()) {
        if (!_impl_.request_data_->IsInitialized())
            return false;
    }
    return true;
}

void ContentAnalysisRequest::InternalSwap(ContentAnalysisRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.tags_.InternalSwap(&other->_impl_.tags_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.device_token_, lhs_arena, &other->_impl_.device_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.fcm_notification_token_, lhs_arena, &other->_impl_.fcm_notification_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.request_token_, lhs_arena, &other->_impl_.request_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.user_action_id_, lhs_arena, &other->_impl_.user_action_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ContentAnalysisRequest, _impl_.require_metadata_verdict_)
        + sizeof(ContentAnalysisRequest::_impl_.require_metadata_verdict_) - PROTOBUF_FIELD_OFFSET(ContentAnalysisRequest, _impl_.request_data_)>(
        reinterpret_cast<char*>(&_impl_.request_data_), reinterpret_cast<char*>(&other->_impl_.request_data_));
    swap(_impl_.content_data_, other->_impl_.content_data_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string ContentAnalysisRequest::GetTypeName() const
{
    return "enterprise_connectors.ContentAnalysisRequest";
}

// ===================================================================

class ContentAnalysisResponse_Result_CustomMessage::_Internal {
public:
    using HasBits = decltype(std::declval<ContentAnalysisResponse_Result_CustomMessage>()._impl_._has_bits_);
    static void set_has_learn_more_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_message(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ContentAnalysisResponse_Result_CustomMessage::ContentAnalysisResponse_Result_CustomMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
}
ContentAnalysisResponse_Result_CustomMessage::ContentAnalysisResponse_Result_CustomMessage(const ContentAnalysisResponse_Result_CustomMessage& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ContentAnalysisResponse_Result_CustomMessage* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.learn_more_url_) {},
        decltype(_impl_.message_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.learn_more_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.learn_more_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_learn_more_url()) {
        _this->_impl_.learn_more_url_.Set(from._internal_learn_more_url(), _this->GetArenaForAllocation());
    }
    _impl_.message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_message()) {
        _this->_impl_.message_.Set(from._internal_message(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
}

inline void ContentAnalysisResponse_Result_CustomMessage::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.learn_more_url_) {}, decltype(_impl_.message_) {} };
    _impl_.learn_more_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.learn_more_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContentAnalysisResponse_Result_CustomMessage::~ContentAnalysisResponse_Result_CustomMessage()
{
    // @@protoc_insertion_point(destructor:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ContentAnalysisResponse_Result_CustomMessage::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.learn_more_url_.Destroy();
    _impl_.message_.Destroy();
}

void ContentAnalysisResponse_Result_CustomMessage::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ContentAnalysisResponse_Result_CustomMessage::Clear()
{
    // @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.learn_more_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.message_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ContentAnalysisResponse_Result_CustomMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string learn_more_url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_learn_more_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string message = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_message();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ContentAnalysisResponse_Result_CustomMessage::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string learn_more_url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_learn_more_url(), target);
    }

    // optional string message = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_message(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
    return target;
}

size_t ContentAnalysisResponse_Result_CustomMessage::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string learn_more_url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_learn_more_url());
        }

        // optional string message = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_message());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ContentAnalysisResponse_Result_CustomMessage::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ContentAnalysisResponse_Result_CustomMessage*>(&from));
}

void ContentAnalysisResponse_Result_CustomMessage::MergeFrom(const ContentAnalysisResponse_Result_CustomMessage& from)
{
    ContentAnalysisResponse_Result_CustomMessage* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_learn_more_url(from._internal_learn_more_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_message(from._internal_message());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentAnalysisResponse_Result_CustomMessage::CopyFrom(const ContentAnalysisResponse_Result_CustomMessage& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ContentAnalysisResponse_Result_CustomMessage::IsInitialized() const
{
    return true;
}

void ContentAnalysisResponse_Result_CustomMessage::InternalSwap(ContentAnalysisResponse_Result_CustomMessage* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.learn_more_url_, lhs_arena, &other->_impl_.learn_more_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.message_, lhs_arena, &other->_impl_.message_, rhs_arena);
}

std::string ContentAnalysisResponse_Result_CustomMessage::GetTypeName() const
{
    return "enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage";
}

// ===================================================================

class ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::_Internal {
public:
    using HasBits = decltype(std::declval<ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment>()._impl_._has_bits_);
    static void set_has_text(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_link(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment)
}
ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment(
    const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.text_) {},
        decltype(_impl_.link_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_text()) {
        _this->_impl_.text_.Set(from._internal_text(), _this->GetArenaForAllocation());
    }
    _impl_.link_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.link_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_link()) {
        _this->_impl_.link_.Set(from._internal_link(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment)
}

inline void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.text_) {}, decltype(_impl_.link_) {} };
    _impl_.text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.link_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.link_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::~ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment()
{
    // @@protoc_insertion_point(destructor:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.text_.Destroy();
    _impl_.link_.Destroy();
}

void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::Clear()
{
    // @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.text_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.link_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string text = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_text();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string link = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_link();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string text = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_text(), target);
    }

    // optional string link = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_link(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment)
    return target;
}

size_t ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string text = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_text());
        }

        // optional string link = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_link());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment*>(&from));
}

void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::MergeFrom(
    const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment& from)
{
    ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_text(from._internal_text());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_link(from._internal_link());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::CopyFrom(
    const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::IsInitialized() const
{
    return true;
}

void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::InternalSwap(
    ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.text_, lhs_arena, &other->_impl_.text_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.link_, lhs_arena, &other->_impl_.link_, rhs_arena);
}

std::string ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment::GetTypeName() const
{
    return "enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment";
}

// ===================================================================

class ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::_Internal {
public:
};

ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage)
}
ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage(
    const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.message_segments_) { from._impl_.message_segments_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage)
}

inline void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.message_segments_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::~ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage()
{
    // @@protoc_insertion_point(destructor:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.message_segments_.~RepeatedPtrField();
}

void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::Clear()
{
    // @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.message_segments_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment message_segments = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_message_segments(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment message_segments = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_message_segments_size()); i < n; i++) {
        const auto& repfield = this->_internal_message_segments(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage)
    return target;
}

size_t ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessageSegment message_segments = 1;
    total_size += 1UL * this->_internal_message_segments_size();
    for (const auto& msg : this->_impl_.message_segments_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage*>(&from));
}

void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::MergeFrom(const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& from)
{
    ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.message_segments_.MergeFrom(from._impl_.message_segments_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::CopyFrom(const ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::IsInitialized() const
{
    return true;
}

void ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::InternalSwap(ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.message_segments_.InternalSwap(&other->_impl_.message_segments_);
}

std::string ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::GetTypeName() const
{
    return "enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage";
}

// ===================================================================

class ContentAnalysisResponse_Result_TriggeredRule::_Internal {
public:
    using HasBits = decltype(std::declval<ContentAnalysisResponse_Result_TriggeredRule>()._impl_._has_bits_);
    static void set_has_action(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_rule_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_rule_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage& custom_message(const ContentAnalysisResponse_Result_TriggeredRule* msg);
    static void set_has_custom_message(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_url_category(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage& custom_rule_message(
        const ContentAnalysisResponse_Result_TriggeredRule* msg);
    static void set_has_custom_rule_message(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage& ContentAnalysisResponse_Result_TriggeredRule::_Internal::custom_message(
    const ContentAnalysisResponse_Result_TriggeredRule* msg)
{
    return *msg->_impl_.custom_message_;
}
const ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage&
ContentAnalysisResponse_Result_TriggeredRule::_Internal::custom_rule_message(const ContentAnalysisResponse_Result_TriggeredRule* msg)
{
    return *msg->_impl_.custom_rule_message_;
}
ContentAnalysisResponse_Result_TriggeredRule::ContentAnalysisResponse_Result_TriggeredRule(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
}
ContentAnalysisResponse_Result_TriggeredRule::ContentAnalysisResponse_Result_TriggeredRule(const ContentAnalysisResponse_Result_TriggeredRule& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ContentAnalysisResponse_Result_TriggeredRule* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.rule_name_) {},
        decltype(_impl_.rule_id_) {}, decltype(_impl_.url_category_) {}, decltype(_impl_.custom_message_) { nullptr },
        decltype(_impl_.custom_rule_message_) { nullptr }, decltype(_impl_.action_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.rule_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_rule_name()) {
        _this->_impl_.rule_name_.Set(from._internal_rule_name(), _this->GetArenaForAllocation());
    }
    _impl_.rule_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_rule_id()) {
        _this->_impl_.rule_id_.Set(from._internal_rule_id(), _this->GetArenaForAllocation());
    }
    _impl_.url_category_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_category_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url_category()) {
        _this->_impl_.url_category_.Set(from._internal_url_category(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_custom_message()) {
        _this->_impl_.custom_message_ = new ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage(*from._impl_.custom_message_);
    }
    if (from._internal_has_custom_rule_message()) {
        _this->_impl_.custom_rule_message_
            = new ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage(*from._impl_.custom_rule_message_);
    }
    _this->_impl_.action_ = from._impl_.action_;
    // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
}

inline void ContentAnalysisResponse_Result_TriggeredRule::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.rule_name_) {}, decltype(_impl_.rule_id_) {},
        decltype(_impl_.url_category_) {}, decltype(_impl_.custom_message_) { nullptr }, decltype(_impl_.custom_rule_message_) { nullptr },
        decltype(_impl_.action_) { 0 } };
    _impl_.rule_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_category_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_category_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContentAnalysisResponse_Result_TriggeredRule::~ContentAnalysisResponse_Result_TriggeredRule()
{
    // @@protoc_insertion_point(destructor:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ContentAnalysisResponse_Result_TriggeredRule::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.rule_name_.Destroy();
    _impl_.rule_id_.Destroy();
    _impl_.url_category_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.custom_message_;
    if (this != internal_default_instance())
        delete _impl_.custom_rule_message_;
}

void ContentAnalysisResponse_Result_TriggeredRule::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ContentAnalysisResponse_Result_TriggeredRule::Clear()
{
    // @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.rule_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.rule_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.url_category_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.custom_message_ != nullptr);
            _impl_.custom_message_->Clear();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.custom_rule_message_ != nullptr);
            _impl_.custom_rule_message_->Clear();
        }
    }
    _impl_.action_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ContentAnalysisResponse_Result_TriggeredRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.Action action = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action_IsValid(val))) {
                    _internal_set_action(static_cast<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_Action>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string rule_name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_rule_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string rule_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_rule_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 4 [deprecated = true];
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_custom_message(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string url_category = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_url_category();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage custom_rule_message = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_custom_rule_message(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ContentAnalysisResponse_Result_TriggeredRule::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.Action action = 1;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_action(), target);
    }

    // optional string rule_name = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_rule_name(), target);
    }

    // optional string rule_id = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_rule_id(), target);
    }

    // optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 4 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::custom_message(this), _Internal::custom_message(this).GetCachedSize(), target, stream);
    }

    // optional string url_category = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_url_category(), target);
    }

    // optional .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage custom_rule_message = 6;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::custom_rule_message(this), _Internal::custom_rule_message(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
    return target;
}

size_t ContentAnalysisResponse_Result_TriggeredRule::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional string rule_name = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_rule_name());
        }

        // optional string rule_id = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_rule_id());
        }

        // optional string url_category = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url_category());
        }

        // optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 4 [deprecated = true];
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.custom_message_);
        }

        // optional .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.CustomRuleMessage custom_rule_message = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.custom_rule_message_);
        }

        // optional .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule.Action action = 1;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ContentAnalysisResponse_Result_TriggeredRule::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ContentAnalysisResponse_Result_TriggeredRule*>(&from));
}

void ContentAnalysisResponse_Result_TriggeredRule::MergeFrom(const ContentAnalysisResponse_Result_TriggeredRule& from)
{
    ContentAnalysisResponse_Result_TriggeredRule* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_rule_name(from._internal_rule_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_rule_id(from._internal_rule_id());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_url_category(from._internal_url_category());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_custom_message()->::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage::MergeFrom(
                from._internal_custom_message());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_custom_rule_message()->::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage::MergeFrom(
                from._internal_custom_rule_message());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.action_ = from._impl_.action_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentAnalysisResponse_Result_TriggeredRule::CopyFrom(const ContentAnalysisResponse_Result_TriggeredRule& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ContentAnalysisResponse_Result_TriggeredRule::IsInitialized() const
{
    return true;
}

void ContentAnalysisResponse_Result_TriggeredRule::InternalSwap(ContentAnalysisResponse_Result_TriggeredRule* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.rule_name_, lhs_arena, &other->_impl_.rule_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.rule_id_, lhs_arena, &other->_impl_.rule_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_category_, lhs_arena, &other->_impl_.url_category_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ContentAnalysisResponse_Result_TriggeredRule, _impl_.action_)
        + sizeof(ContentAnalysisResponse_Result_TriggeredRule::_impl_.action_)
        - PROTOBUF_FIELD_OFFSET(ContentAnalysisResponse_Result_TriggeredRule, _impl_.custom_message_)>(
        reinterpret_cast<char*>(&_impl_.custom_message_), reinterpret_cast<char*>(&other->_impl_.custom_message_));
}

std::string ContentAnalysisResponse_Result_TriggeredRule::GetTypeName() const
{
    return "enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule";
}

// ===================================================================

class ContentAnalysisResponse_Result::_Internal {
public:
    using HasBits = decltype(std::declval<ContentAnalysisResponse_Result>()._impl_._has_bits_);
    static void set_has_tag(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage& custom_message(const ContentAnalysisResponse_Result* msg);
    static void set_has_custom_message(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_status_error_message(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage& ContentAnalysisResponse_Result::_Internal::custom_message(
    const ContentAnalysisResponse_Result* msg)
{
    return *msg->_impl_.custom_message_;
}
ContentAnalysisResponse_Result::ContentAnalysisResponse_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentAnalysisResponse.Result)
}
ContentAnalysisResponse_Result::ContentAnalysisResponse_Result(const ContentAnalysisResponse_Result& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ContentAnalysisResponse_Result* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.triggered_rules_) { from._impl_.triggered_rules_ }, decltype(_impl_.tag_) {}, decltype(_impl_.custom_message_) { nullptr },
        decltype(_impl_.status_) {}, decltype(_impl_.status_error_message_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_tag()) {
        _this->_impl_.tag_.Set(from._internal_tag(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_custom_message()) {
        _this->_impl_.custom_message_ = new ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage(*from._impl_.custom_message_);
    }
    ::memcpy(&_impl_.status_, &from._impl_.status_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_error_message_) - reinterpret_cast<char*>(&_impl_.status_))
            + sizeof(_impl_.status_error_message_));
    // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentAnalysisResponse.Result)
}

inline void ContentAnalysisResponse_Result::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.triggered_rules_) { arena },
        decltype(_impl_.tag_) {}, decltype(_impl_.custom_message_) { nullptr }, decltype(_impl_.status_) { 0 }, decltype(_impl_.status_error_message_) { 0 } };
    _impl_.tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContentAnalysisResponse_Result::~ContentAnalysisResponse_Result()
{
    // @@protoc_insertion_point(destructor:enterprise_connectors.ContentAnalysisResponse.Result)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ContentAnalysisResponse_Result::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.triggered_rules_.~RepeatedPtrField();
    _impl_.tag_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.custom_message_;
}

void ContentAnalysisResponse_Result::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ContentAnalysisResponse_Result::Clear()
{
    // @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentAnalysisResponse.Result)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.triggered_rules_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.tag_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.custom_message_ != nullptr);
            _impl_.custom_message_->Clear();
        }
    }
    if (cached_has_bits & 0x0000000cu) {
        ::memset(&_impl_.status_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_error_message_) - reinterpret_cast<char*>(&_impl_.status_))
                + sizeof(_impl_.status_error_message_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ContentAnalysisResponse_Result::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string tag = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_tag();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ContentAnalysisResponse.Result.Status status = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::enterprise_connectors::ContentAnalysisResponse_Result_Status_IsValid(val))) {
                    _internal_set_status(static_cast<::enterprise_connectors::ContentAnalysisResponse_Result_Status>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule triggered_rules = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_triggered_rules(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 7 [deprecated = true];
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_custom_message(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ContentAnalysisResponse.Result.StatusErrorMessage status_error_message = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::enterprise_connectors::ContentAnalysisResponse_Result_StatusErrorMessage_IsValid(val))) {
                    _internal_set_status_error_message(static_cast<::enterprise_connectors::ContentAnalysisResponse_Result_StatusErrorMessage>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ContentAnalysisResponse_Result::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentAnalysisResponse.Result)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string tag = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_tag(), target);
    }

    // optional .enterprise_connectors.ContentAnalysisResponse.Result.Status status = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_status(), target);
    }

    // repeated .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule triggered_rules = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_triggered_rules_size()); i < n; i++) {
        const auto& repfield = this->_internal_triggered_rules(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 7 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::custom_message(this), _Internal::custom_message(this).GetCachedSize(), target, stream);
    }

    // optional .enterprise_connectors.ContentAnalysisResponse.Result.StatusErrorMessage status_error_message = 8;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(8, this->_internal_status_error_message(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentAnalysisResponse.Result)
    return target;
}

size_t ContentAnalysisResponse_Result::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentAnalysisResponse.Result)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .enterprise_connectors.ContentAnalysisResponse.Result.TriggeredRule triggered_rules = 3;
    total_size += 1UL * this->_internal_triggered_rules_size();
    for (const auto& msg : this->_impl_.triggered_rules_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string tag = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_tag());
        }

        // optional .enterprise_connectors.ContentAnalysisResponse.Result.CustomMessage custom_message = 7 [deprecated = true];
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.custom_message_);
        }

        // optional .enterprise_connectors.ContentAnalysisResponse.Result.Status status = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
        }

        // optional .enterprise_connectors.ContentAnalysisResponse.Result.StatusErrorMessage status_error_message = 8;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status_error_message());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ContentAnalysisResponse_Result::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ContentAnalysisResponse_Result*>(&from));
}

void ContentAnalysisResponse_Result::MergeFrom(const ContentAnalysisResponse_Result& from)
{
    ContentAnalysisResponse_Result* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentAnalysisResponse.Result)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.triggered_rules_.MergeFrom(from._impl_.triggered_rules_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_tag(from._internal_tag());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_custom_message()->::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage::MergeFrom(
                from._internal_custom_message());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.status_ = from._impl_.status_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.status_error_message_ = from._impl_.status_error_message_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentAnalysisResponse_Result::CopyFrom(const ContentAnalysisResponse_Result& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentAnalysisResponse.Result)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ContentAnalysisResponse_Result::IsInitialized() const
{
    return true;
}

void ContentAnalysisResponse_Result::InternalSwap(ContentAnalysisResponse_Result* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.triggered_rules_.InternalSwap(&other->_impl_.triggered_rules_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.tag_, lhs_arena, &other->_impl_.tag_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ContentAnalysisResponse_Result, _impl_.status_error_message_)
        + sizeof(ContentAnalysisResponse_Result::_impl_.status_error_message_) - PROTOBUF_FIELD_OFFSET(ContentAnalysisResponse_Result, _impl_.custom_message_)>(
        reinterpret_cast<char*>(&_impl_.custom_message_), reinterpret_cast<char*>(&other->_impl_.custom_message_));
}

std::string ContentAnalysisResponse_Result::GetTypeName() const
{
    return "enterprise_connectors.ContentAnalysisResponse.Result";
}

// ===================================================================

class ContentAnalysisResponse::_Internal {
public:
    using HasBits = decltype(std::declval<ContentAnalysisResponse>()._impl_._has_bits_);
    static void set_has_request_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ContentAnalysisResponse::ContentAnalysisResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentAnalysisResponse)
}
ContentAnalysisResponse::ContentAnalysisResponse(const ContentAnalysisResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ContentAnalysisResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.results_) { from._impl_.results_ }, decltype(_impl_.request_token_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.request_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_request_token()) {
        _this->_impl_.request_token_.Set(from._internal_request_token(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentAnalysisResponse)
}

inline void ContentAnalysisResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.results_) { arena },
        decltype(_impl_.request_token_) {} };
    _impl_.request_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContentAnalysisResponse::~ContentAnalysisResponse()
{
    // @@protoc_insertion_point(destructor:enterprise_connectors.ContentAnalysisResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ContentAnalysisResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.results_.~RepeatedPtrField();
    _impl_.request_token_.Destroy();
}

void ContentAnalysisResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ContentAnalysisResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentAnalysisResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.results_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.request_token_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ContentAnalysisResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string request_token = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_request_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .enterprise_connectors.ContentAnalysisResponse.Result results = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_results(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ContentAnalysisResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentAnalysisResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string request_token = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_request_token(), target);
    }

    // repeated .enterprise_connectors.ContentAnalysisResponse.Result results = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_results_size()); i < n; i++) {
        const auto& repfield = this->_internal_results(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentAnalysisResponse)
    return target;
}

size_t ContentAnalysisResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentAnalysisResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .enterprise_connectors.ContentAnalysisResponse.Result results = 4;
    total_size += 1UL * this->_internal_results_size();
    for (const auto& msg : this->_impl_.results_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional string request_token = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_request_token());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ContentAnalysisResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ContentAnalysisResponse*>(&from));
}

void ContentAnalysisResponse::MergeFrom(const ContentAnalysisResponse& from)
{
    ContentAnalysisResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentAnalysisResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.results_.MergeFrom(from._impl_.results_);
    if (from._internal_has_request_token()) {
        _this->_internal_set_request_token(from._internal_request_token());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentAnalysisResponse::CopyFrom(const ContentAnalysisResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentAnalysisResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ContentAnalysisResponse::IsInitialized() const
{
    return true;
}

void ContentAnalysisResponse::InternalSwap(ContentAnalysisResponse* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.results_.InternalSwap(&other->_impl_.results_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.request_token_, lhs_arena, &other->_impl_.request_token_, rhs_arena);
}

std::string ContentAnalysisResponse::GetTypeName() const
{
    return "enterprise_connectors.ContentAnalysisResponse";
}

// ===================================================================

class ContentAnalysisAcknowledgement::_Internal {
public:
    using HasBits = decltype(std::declval<ContentAnalysisAcknowledgement>()._impl_._has_bits_);
    static void set_has_request_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_final_action(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ContentAnalysisAcknowledgement::ContentAnalysisAcknowledgement(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:enterprise_connectors.ContentAnalysisAcknowledgement)
}
ContentAnalysisAcknowledgement::ContentAnalysisAcknowledgement(const ContentAnalysisAcknowledgement& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ContentAnalysisAcknowledgement* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.request_token_) {},
        decltype(_impl_.final_action_) {}, decltype(_impl_.status_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.request_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_request_token()) {
        _this->_impl_.request_token_.Set(from._internal_request_token(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.final_action_, &from._impl_.final_action_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) - reinterpret_cast<char*>(&_impl_.final_action_)) + sizeof(_impl_.status_));
    // @@protoc_insertion_point(copy_constructor:enterprise_connectors.ContentAnalysisAcknowledgement)
}

inline void ContentAnalysisAcknowledgement::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.request_token_) {},
        decltype(_impl_.final_action_) { 0 }, decltype(_impl_.status_) { 1 } };
    _impl_.request_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ContentAnalysisAcknowledgement::~ContentAnalysisAcknowledgement()
{
    // @@protoc_insertion_point(destructor:enterprise_connectors.ContentAnalysisAcknowledgement)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ContentAnalysisAcknowledgement::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.request_token_.Destroy();
}

void ContentAnalysisAcknowledgement::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ContentAnalysisAcknowledgement::Clear()
{
    // @@protoc_insertion_point(message_clear_start:enterprise_connectors.ContentAnalysisAcknowledgement)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.request_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        _impl_.final_action_ = 0;
        _impl_.status_ = 1;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ContentAnalysisAcknowledgement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string request_token = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_request_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ContentAnalysisAcknowledgement.Status status = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::enterprise_connectors::ContentAnalysisAcknowledgement_Status_IsValid(val))) {
                    _internal_set_status(static_cast<::enterprise_connectors::ContentAnalysisAcknowledgement_Status>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ContentAnalysisAcknowledgement.FinalAction final_action = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction_IsValid(val))) {
                    _internal_set_final_action(static_cast<::enterprise_connectors::ContentAnalysisAcknowledgement_FinalAction>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ContentAnalysisAcknowledgement::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:enterprise_connectors.ContentAnalysisAcknowledgement)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string request_token = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_request_token(), target);
    }

    // optional .enterprise_connectors.ContentAnalysisAcknowledgement.Status status = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_status(), target);
    }

    // optional .enterprise_connectors.ContentAnalysisAcknowledgement.FinalAction final_action = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_final_action(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:enterprise_connectors.ContentAnalysisAcknowledgement)
    return target;
}

size_t ContentAnalysisAcknowledgement::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:enterprise_connectors.ContentAnalysisAcknowledgement)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string request_token = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_request_token());
        }

        // optional .enterprise_connectors.ContentAnalysisAcknowledgement.FinalAction final_action = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_final_action());
        }

        // optional .enterprise_connectors.ContentAnalysisAcknowledgement.Status status = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ContentAnalysisAcknowledgement::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ContentAnalysisAcknowledgement*>(&from));
}

void ContentAnalysisAcknowledgement::MergeFrom(const ContentAnalysisAcknowledgement& from)
{
    ContentAnalysisAcknowledgement* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:enterprise_connectors.ContentAnalysisAcknowledgement)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_request_token(from._internal_request_token());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.final_action_ = from._impl_.final_action_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.status_ = from._impl_.status_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentAnalysisAcknowledgement::CopyFrom(const ContentAnalysisAcknowledgement& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:enterprise_connectors.ContentAnalysisAcknowledgement)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ContentAnalysisAcknowledgement::IsInitialized() const
{
    return true;
}

void ContentAnalysisAcknowledgement::InternalSwap(ContentAnalysisAcknowledgement* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.request_token_, lhs_arena, &other->_impl_.request_token_, rhs_arena);
    swap(_impl_.final_action_, other->_impl_.final_action_);
    swap(_impl_.status_, other->_impl_.status_);
}

std::string ContentAnalysisAcknowledgement::GetTypeName() const
{
    return "enterprise_connectors.ContentAnalysisAcknowledgement";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace enterprise_connectors
PROTOBUF_NAMESPACE_OPEN
template <>
PROTOBUF_NOINLINE ::enterprise_connectors::ContentMetaData_PrintMetadata* Arena::CreateMaybeMessage<::enterprise_connectors::ContentMetaData_PrintMetadata>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::enterprise_connectors::ContentMetaData_PrintMetadata>(arena);
}
template <> PROTOBUF_NOINLINE ::enterprise_connectors::ContentMetaData* Arena::CreateMaybeMessage<::enterprise_connectors::ContentMetaData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::enterprise_connectors::ContentMetaData>(arena);
}
template <>
PROTOBUF_NOINLINE ::enterprise_connectors::ClientMetadata_Browser* Arena::CreateMaybeMessage<::enterprise_connectors::ClientMetadata_Browser>(Arena* arena)
{
    return Arena::CreateMessageInternal<::enterprise_connectors::ClientMetadata_Browser>(arena);
}
template <>
PROTOBUF_NOINLINE ::enterprise_connectors::ClientMetadata_Device* Arena::CreateMaybeMessage<::enterprise_connectors::ClientMetadata_Device>(Arena* arena)
{
    return Arena::CreateMessageInternal<::enterprise_connectors::ClientMetadata_Device>(arena);
}
template <>
PROTOBUF_NOINLINE ::enterprise_connectors::ClientMetadata_Profile* Arena::CreateMaybeMessage<::enterprise_connectors::ClientMetadata_Profile>(Arena* arena)
{
    return Arena::CreateMessageInternal<::enterprise_connectors::ClientMetadata_Profile>(arena);
}
template <> PROTOBUF_NOINLINE ::enterprise_connectors::ClientMetadata* Arena::CreateMaybeMessage<::enterprise_connectors::ClientMetadata>(Arena* arena)
{
    return Arena::CreateMessageInternal<::enterprise_connectors::ClientMetadata>(arena);
}
template <>
PROTOBUF_NOINLINE ::enterprise_connectors::ContentAnalysisRequest* Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::enterprise_connectors::ContentAnalysisRequest>(arena);
}
template <>
PROTOBUF_NOINLINE ::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage*
Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage>(Arena* arena)
{
    return Arena::CreateMessageInternal<::enterprise_connectors::ContentAnalysisResponse_Result_CustomMessage>(arena);
}
template <>
PROTOBUF_NOINLINE ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment*
Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment>(Arena* arena)
{
    return Arena::CreateMessageInternal<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessageSegment>(arena);
}
template <>
PROTOBUF_NOINLINE ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage*
Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage>(Arena* arena)
{
    return Arena::CreateMessageInternal<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule_CustomRuleMessage>(arena);
}
template <>
PROTOBUF_NOINLINE ::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule*
Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule>(Arena* arena)
{
    return Arena::CreateMessageInternal<::enterprise_connectors::ContentAnalysisResponse_Result_TriggeredRule>(arena);
}
template <>
PROTOBUF_NOINLINE ::enterprise_connectors::ContentAnalysisResponse_Result* Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse_Result>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::enterprise_connectors::ContentAnalysisResponse_Result>(arena);
}
template <>
PROTOBUF_NOINLINE ::enterprise_connectors::ContentAnalysisResponse* Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::enterprise_connectors::ContentAnalysisResponse>(arena);
}
template <>
PROTOBUF_NOINLINE ::enterprise_connectors::ContentAnalysisAcknowledgement* Arena::CreateMaybeMessage<::enterprise_connectors::ContentAnalysisAcknowledgement>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::enterprise_connectors::ContentAnalysisAcknowledgement>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
