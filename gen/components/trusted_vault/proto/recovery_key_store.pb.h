// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: recovery_key_store.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_recovery_5fkey_5fstore_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_recovery_5fkey_5fstore_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_recovery_5fkey_5fstore_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_recovery_5fkey_5fstore_2eproto {
    static const uint32_t offsets[];
};
namespace trusted_vault_pb {
class ApplicationKey;
struct ApplicationKeyDefaultTypeInternal;
extern ApplicationKeyDefaultTypeInternal _ApplicationKey_default_instance_;
class AsymmetricKeyPair;
struct AsymmetricKeyPairDefaultTypeInternal;
extern AsymmetricKeyPairDefaultTypeInternal _AsymmetricKeyPair_default_instance_;
class ChromeOsMetadata;
struct ChromeOsMetadataDefaultTypeInternal;
extern ChromeOsMetadataDefaultTypeInternal _ChromeOsMetadata_default_instance_;
class Vault;
struct VaultDefaultTypeInternal;
extern VaultDefaultTypeInternal _Vault_default_instance_;
class VaultMetadata;
struct VaultMetadataDefaultTypeInternal;
extern VaultMetadataDefaultTypeInternal _VaultMetadata_default_instance_;
class VaultParameters;
struct VaultParametersDefaultTypeInternal;
extern VaultParametersDefaultTypeInternal _VaultParameters_default_instance_;
} // namespace trusted_vault_pb
PROTOBUF_NAMESPACE_OPEN
template <>::trusted_vault_pb::ApplicationKey* Arena::CreateMaybeMessage<::trusted_vault_pb::ApplicationKey>(Arena*);
template <>::trusted_vault_pb::AsymmetricKeyPair* Arena::CreateMaybeMessage<::trusted_vault_pb::AsymmetricKeyPair>(Arena*);
template <>::trusted_vault_pb::ChromeOsMetadata* Arena::CreateMaybeMessage<::trusted_vault_pb::ChromeOsMetadata>(Arena*);
template <>::trusted_vault_pb::Vault* Arena::CreateMaybeMessage<::trusted_vault_pb::Vault>(Arena*);
template <>::trusted_vault_pb::VaultMetadata* Arena::CreateMaybeMessage<::trusted_vault_pb::VaultMetadata>(Arena*);
template <>::trusted_vault_pb::VaultParameters* Arena::CreateMaybeMessage<::trusted_vault_pb::VaultParameters>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace trusted_vault_pb {

enum VaultMetadata_LskfType : int {
    VaultMetadata_LskfType_LSKF_TYPE_UNSPECIFIED = 0,
    VaultMetadata_LskfType_PIN = 1,
    VaultMetadata_LskfType_PASSWORD = 2,
    VaultMetadata_LskfType_VaultMetadata_LskfType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    VaultMetadata_LskfType_VaultMetadata_LskfType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VaultMetadata_LskfType_IsValid(int value);
constexpr VaultMetadata_LskfType VaultMetadata_LskfType_LskfType_MIN = VaultMetadata_LskfType_LSKF_TYPE_UNSPECIFIED;
constexpr VaultMetadata_LskfType VaultMetadata_LskfType_LskfType_MAX = VaultMetadata_LskfType_PASSWORD;
constexpr int VaultMetadata_LskfType_LskfType_ARRAYSIZE = VaultMetadata_LskfType_LskfType_MAX + 1;

const std::string& VaultMetadata_LskfType_Name(VaultMetadata_LskfType value);
template <typename T> inline const std::string& VaultMetadata_LskfType_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, VaultMetadata_LskfType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function VaultMetadata_LskfType_Name.");
    return VaultMetadata_LskfType_Name(static_cast<VaultMetadata_LskfType>(enum_t_value));
}
bool VaultMetadata_LskfType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VaultMetadata_LskfType* value);
enum VaultMetadata_HashType : int {
    VaultMetadata_HashType_HASH_TYPE_UNSPECIFIED = 0,
    VaultMetadata_HashType_SCRYPT = 3,
    VaultMetadata_HashType_PBKDF2_AES256_1234 = 4,
    VaultMetadata_HashType_SHA256_TOP_HALF = 5,
    VaultMetadata_HashType_VaultMetadata_HashType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    VaultMetadata_HashType_VaultMetadata_HashType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool VaultMetadata_HashType_IsValid(int value);
constexpr VaultMetadata_HashType VaultMetadata_HashType_HashType_MIN = VaultMetadata_HashType_HASH_TYPE_UNSPECIFIED;
constexpr VaultMetadata_HashType VaultMetadata_HashType_HashType_MAX = VaultMetadata_HashType_SHA256_TOP_HALF;
constexpr int VaultMetadata_HashType_HashType_ARRAYSIZE = VaultMetadata_HashType_HashType_MAX + 1;

const std::string& VaultMetadata_HashType_Name(VaultMetadata_HashType value);
template <typename T> inline const std::string& VaultMetadata_HashType_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, VaultMetadata_HashType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function VaultMetadata_HashType_Name.");
    return VaultMetadata_HashType_Name(static_cast<VaultMetadata_HashType>(enum_t_value));
}
bool VaultMetadata_HashType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VaultMetadata_HashType* value);
// ===================================================================

class AsymmetricKeyPair final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.AsymmetricKeyPair) */ {
public:
    inline AsymmetricKeyPair()
        : AsymmetricKeyPair(nullptr)
    {
    }
    ~AsymmetricKeyPair() override;
    explicit PROTOBUF_CONSTEXPR AsymmetricKeyPair(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AsymmetricKeyPair(const AsymmetricKeyPair& from);
    AsymmetricKeyPair(AsymmetricKeyPair&& from) noexcept
        : AsymmetricKeyPair()
    {
        *this = ::std::move(from);
    }

    inline AsymmetricKeyPair& operator=(const AsymmetricKeyPair& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AsymmetricKeyPair& operator=(AsymmetricKeyPair&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const AsymmetricKeyPair& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AsymmetricKeyPair* internal_default_instance()
    {
        return reinterpret_cast<const AsymmetricKeyPair*>(&_AsymmetricKeyPair_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(AsymmetricKeyPair& a, AsymmetricKeyPair& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AsymmetricKeyPair* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AsymmetricKeyPair* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AsymmetricKeyPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AsymmetricKeyPair>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AsymmetricKeyPair& from);
    void MergeFrom(const AsymmetricKeyPair& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AsymmetricKeyPair* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.AsymmetricKeyPair";
    }

protected:
    explicit AsymmetricKeyPair(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kPublicKeyFieldNumber = 1,
        kWrappedPrivateKeyFieldNumber = 2,
        kWrappingKeyFieldNumber = 3,
    };
    // bytes public_key = 1;
    void clear_public_key();
    const std::string& public_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_public_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_public_key();
    PROTOBUF_NODISCARD std::string* release_public_key();
    void set_allocated_public_key(std::string* public_key);

private:
    const std::string& _internal_public_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
    std::string* _internal_mutable_public_key();

public:
    // bytes wrapped_private_key = 2;
    void clear_wrapped_private_key();
    const std::string& wrapped_private_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_wrapped_private_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_wrapped_private_key();
    PROTOBUF_NODISCARD std::string* release_wrapped_private_key();
    void set_allocated_wrapped_private_key(std::string* wrapped_private_key);

private:
    const std::string& _internal_wrapped_private_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_wrapped_private_key(const std::string& value);
    std::string* _internal_mutable_wrapped_private_key();

public:
    // bytes wrapping_key = 3;
    void clear_wrapping_key();
    const std::string& wrapping_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_wrapping_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_wrapping_key();
    PROTOBUF_NODISCARD std::string* release_wrapping_key();
    void set_allocated_wrapping_key(std::string* wrapping_key);

private:
    const std::string& _internal_wrapping_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_wrapping_key(const std::string& value);
    std::string* _internal_mutable_wrapping_key();

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.AsymmetricKeyPair)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wrapped_private_key_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wrapping_key_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_recovery_5fkey_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ApplicationKey final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.ApplicationKey) */ {
public:
    inline ApplicationKey()
        : ApplicationKey(nullptr)
    {
    }
    ~ApplicationKey() override;
    explicit PROTOBUF_CONSTEXPR ApplicationKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ApplicationKey(const ApplicationKey& from);
    ApplicationKey(ApplicationKey&& from) noexcept
        : ApplicationKey()
    {
        *this = ::std::move(from);
    }

    inline ApplicationKey& operator=(const ApplicationKey& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ApplicationKey& operator=(ApplicationKey&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ApplicationKey& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ApplicationKey* internal_default_instance()
    {
        return reinterpret_cast<const ApplicationKey*>(&_ApplicationKey_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(ApplicationKey& a, ApplicationKey& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ApplicationKey* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ApplicationKey* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ApplicationKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ApplicationKey>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ApplicationKey& from);
    void MergeFrom(const ApplicationKey& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ApplicationKey* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.ApplicationKey";
    }

protected:
    explicit ApplicationKey(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kKeyNameFieldNumber = 1,
        kAsymmetricKeyPairFieldNumber = 4,
    };
    // string key_name = 1;
    void clear_key_name();
    const std::string& key_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_key_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_key_name();
    PROTOBUF_NODISCARD std::string* release_key_name();
    void set_allocated_key_name(std::string* key_name);

private:
    const std::string& _internal_key_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_name(const std::string& value);
    std::string* _internal_mutable_key_name();

public:
    // .trusted_vault_pb.AsymmetricKeyPair asymmetric_key_pair = 4;
    bool has_asymmetric_key_pair() const;

private:
    bool _internal_has_asymmetric_key_pair() const;

public:
    void clear_asymmetric_key_pair();
    const ::trusted_vault_pb::AsymmetricKeyPair& asymmetric_key_pair() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::AsymmetricKeyPair* release_asymmetric_key_pair();
    ::trusted_vault_pb::AsymmetricKeyPair* mutable_asymmetric_key_pair();
    void set_allocated_asymmetric_key_pair(::trusted_vault_pb::AsymmetricKeyPair* asymmetric_key_pair);

private:
    const ::trusted_vault_pb::AsymmetricKeyPair& _internal_asymmetric_key_pair() const;
    ::trusted_vault_pb::AsymmetricKeyPair* _internal_mutable_asymmetric_key_pair();

public:
    void unsafe_arena_set_allocated_asymmetric_key_pair(::trusted_vault_pb::AsymmetricKeyPair* asymmetric_key_pair);
    ::trusted_vault_pb::AsymmetricKeyPair* unsafe_arena_release_asymmetric_key_pair();

    // @@protoc_insertion_point(class_scope:trusted_vault_pb.ApplicationKey)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_name_;
        ::trusted_vault_pb::AsymmetricKeyPair* asymmetric_key_pair_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_recovery_5fkey_5fstore_2eproto;
};
// -------------------------------------------------------------------

class VaultParameters final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.VaultParameters) */ {
public:
    inline VaultParameters()
        : VaultParameters(nullptr)
    {
    }
    ~VaultParameters() override;
    explicit PROTOBUF_CONSTEXPR VaultParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    VaultParameters(const VaultParameters& from);
    VaultParameters(VaultParameters&& from) noexcept
        : VaultParameters()
    {
        *this = ::std::move(from);
    }

    inline VaultParameters& operator=(const VaultParameters& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline VaultParameters& operator=(VaultParameters&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const VaultParameters& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const VaultParameters* internal_default_instance()
    {
        return reinterpret_cast<const VaultParameters*>(&_VaultParameters_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(VaultParameters& a, VaultParameters& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(VaultParameters* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(VaultParameters* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    VaultParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<VaultParameters>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const VaultParameters& from);
    void MergeFrom(const VaultParameters& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(VaultParameters* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.VaultParameters";
    }

protected:
    explicit VaultParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kBackendPublicKeyFieldNumber = 1,
        kCounterIdFieldNumber = 2,
        kVaultHandleFieldNumber = 4,
        kMaxAttemptsFieldNumber = 3,
    };
    // bytes backend_public_key = 1;
    void clear_backend_public_key();
    const std::string& backend_public_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_backend_public_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_backend_public_key();
    PROTOBUF_NODISCARD std::string* release_backend_public_key();
    void set_allocated_backend_public_key(std::string* backend_public_key);

private:
    const std::string& _internal_backend_public_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_backend_public_key(const std::string& value);
    std::string* _internal_mutable_backend_public_key();

public:
    // bytes counter_id = 2;
    void clear_counter_id();
    const std::string& counter_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_counter_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_counter_id();
    PROTOBUF_NODISCARD std::string* release_counter_id();
    void set_allocated_counter_id(std::string* counter_id);

private:
    const std::string& _internal_counter_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_counter_id(const std::string& value);
    std::string* _internal_mutable_counter_id();

public:
    // bytes vault_handle = 4;
    void clear_vault_handle();
    const std::string& vault_handle() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_vault_handle(ArgT0&& arg0, ArgT... args);
    std::string* mutable_vault_handle();
    PROTOBUF_NODISCARD std::string* release_vault_handle();
    void set_allocated_vault_handle(std::string* vault_handle);

private:
    const std::string& _internal_vault_handle() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_vault_handle(const std::string& value);
    std::string* _internal_mutable_vault_handle();

public:
    // int32 max_attempts = 3;
    void clear_max_attempts();
    int32_t max_attempts() const;
    void set_max_attempts(int32_t value);

private:
    int32_t _internal_max_attempts() const;
    void _internal_set_max_attempts(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.VaultParameters)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backend_public_key_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr counter_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vault_handle_;
        int32_t max_attempts_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_recovery_5fkey_5fstore_2eproto;
};
// -------------------------------------------------------------------

class VaultMetadata final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.VaultMetadata) */ {
public:
    inline VaultMetadata()
        : VaultMetadata(nullptr)
    {
    }
    ~VaultMetadata() override;
    explicit PROTOBUF_CONSTEXPR VaultMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    VaultMetadata(const VaultMetadata& from);
    VaultMetadata(VaultMetadata&& from) noexcept
        : VaultMetadata()
    {
        *this = ::std::move(from);
    }

    inline VaultMetadata& operator=(const VaultMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline VaultMetadata& operator=(VaultMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const VaultMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const VaultMetadata* internal_default_instance()
    {
        return reinterpret_cast<const VaultMetadata*>(&_VaultMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(VaultMetadata& a, VaultMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(VaultMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(VaultMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    VaultMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<VaultMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const VaultMetadata& from);
    void MergeFrom(const VaultMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(VaultMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.VaultMetadata";
    }

protected:
    explicit VaultMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef VaultMetadata_LskfType LskfType;
    static constexpr LskfType LSKF_TYPE_UNSPECIFIED = VaultMetadata_LskfType_LSKF_TYPE_UNSPECIFIED;
    static constexpr LskfType PIN = VaultMetadata_LskfType_PIN;
    static constexpr LskfType PASSWORD = VaultMetadata_LskfType_PASSWORD;
    static inline bool LskfType_IsValid(int value)
    {
        return VaultMetadata_LskfType_IsValid(value);
    }
    static constexpr LskfType LskfType_MIN = VaultMetadata_LskfType_LskfType_MIN;
    static constexpr LskfType LskfType_MAX = VaultMetadata_LskfType_LskfType_MAX;
    static constexpr int LskfType_ARRAYSIZE = VaultMetadata_LskfType_LskfType_ARRAYSIZE;
    template <typename T> static inline const std::string& LskfType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, LskfType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function LskfType_Name.");
        return VaultMetadata_LskfType_Name(enum_t_value);
    }
    static inline bool LskfType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LskfType* value)
    {
        return VaultMetadata_LskfType_Parse(name, value);
    }

    typedef VaultMetadata_HashType HashType;
    static constexpr HashType HASH_TYPE_UNSPECIFIED = VaultMetadata_HashType_HASH_TYPE_UNSPECIFIED;
    static constexpr HashType SCRYPT = VaultMetadata_HashType_SCRYPT;
    static constexpr HashType PBKDF2_AES256_1234 = VaultMetadata_HashType_PBKDF2_AES256_1234;
    static constexpr HashType SHA256_TOP_HALF = VaultMetadata_HashType_SHA256_TOP_HALF;
    static inline bool HashType_IsValid(int value)
    {
        return VaultMetadata_HashType_IsValid(value);
    }
    static constexpr HashType HashType_MIN = VaultMetadata_HashType_HashType_MIN;
    static constexpr HashType HashType_MAX = VaultMetadata_HashType_HashType_MAX;
    static constexpr int HashType_ARRAYSIZE = VaultMetadata_HashType_HashType_ARRAYSIZE;
    template <typename T> static inline const std::string& HashType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, HashType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function HashType_Name.");
        return VaultMetadata_HashType_Name(enum_t_value);
    }
    static inline bool HashType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HashType* value)
    {
        return VaultMetadata_HashType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kHashSaltFieldNumber = 5,
        kCertPathFieldNumber = 7,
        kLskfTypeFieldNumber = 1,
        kHashTypeFieldNumber = 4,
        kHashDifficultyFieldNumber = 6,
    };
    // bytes hash_salt = 5;
    void clear_hash_salt();
    const std::string& hash_salt() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_hash_salt(ArgT0&& arg0, ArgT... args);
    std::string* mutable_hash_salt();
    PROTOBUF_NODISCARD std::string* release_hash_salt();
    void set_allocated_hash_salt(std::string* hash_salt);

private:
    const std::string& _internal_hash_salt() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash_salt(const std::string& value);
    std::string* _internal_mutable_hash_salt();

public:
    // bytes cert_path = 7;
    void clear_cert_path();
    const std::string& cert_path() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_cert_path(ArgT0&& arg0, ArgT... args);
    std::string* mutable_cert_path();
    PROTOBUF_NODISCARD std::string* release_cert_path();
    void set_allocated_cert_path(std::string* cert_path);

private:
    const std::string& _internal_cert_path() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_cert_path(const std::string& value);
    std::string* _internal_mutable_cert_path();

public:
    // .trusted_vault_pb.VaultMetadata.LskfType lskf_type = 1;
    void clear_lskf_type();
    ::trusted_vault_pb::VaultMetadata_LskfType lskf_type() const;
    void set_lskf_type(::trusted_vault_pb::VaultMetadata_LskfType value);

private:
    ::trusted_vault_pb::VaultMetadata_LskfType _internal_lskf_type() const;
    void _internal_set_lskf_type(::trusted_vault_pb::VaultMetadata_LskfType value);

public:
    // .trusted_vault_pb.VaultMetadata.HashType hash_type = 4;
    void clear_hash_type();
    ::trusted_vault_pb::VaultMetadata_HashType hash_type() const;
    void set_hash_type(::trusted_vault_pb::VaultMetadata_HashType value);

private:
    ::trusted_vault_pb::VaultMetadata_HashType _internal_hash_type() const;
    void _internal_set_hash_type(::trusted_vault_pb::VaultMetadata_HashType value);

public:
    // int32 hash_difficulty = 6;
    void clear_hash_difficulty();
    int32_t hash_difficulty() const;
    void set_hash_difficulty(int32_t value);

private:
    int32_t _internal_hash_difficulty() const;
    void _internal_set_hash_difficulty(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.VaultMetadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_salt_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cert_path_;
        int lskf_type_;
        int hash_type_;
        int32_t hash_difficulty_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_recovery_5fkey_5fstore_2eproto;
};
// -------------------------------------------------------------------

class ChromeOsMetadata final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.ChromeOsMetadata) */ {
public:
    inline ChromeOsMetadata()
        : ChromeOsMetadata(nullptr)
    {
    }
    ~ChromeOsMetadata() override;
    explicit PROTOBUF_CONSTEXPR ChromeOsMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ChromeOsMetadata(const ChromeOsMetadata& from);
    ChromeOsMetadata(ChromeOsMetadata&& from) noexcept
        : ChromeOsMetadata()
    {
        *this = ::std::move(from);
    }

    inline ChromeOsMetadata& operator=(const ChromeOsMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ChromeOsMetadata& operator=(ChromeOsMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ChromeOsMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ChromeOsMetadata* internal_default_instance()
    {
        return reinterpret_cast<const ChromeOsMetadata*>(&_ChromeOsMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(ChromeOsMetadata& a, ChromeOsMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ChromeOsMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ChromeOsMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ChromeOsMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ChromeOsMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ChromeOsMetadata& from);
    void MergeFrom(const ChromeOsMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ChromeOsMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.ChromeOsMetadata";
    }

protected:
    explicit ChromeOsMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDeviceIdFieldNumber = 1,
    };
    // bytes device_id = 1;
    void clear_device_id();
    const std::string& device_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_device_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_device_id();
    PROTOBUF_NODISCARD std::string* release_device_id();
    void set_allocated_device_id(std::string* device_id);

private:
    const std::string& _internal_device_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
    std::string* _internal_mutable_device_id();

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.ChromeOsMetadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_recovery_5fkey_5fstore_2eproto;
};
// -------------------------------------------------------------------

class Vault final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.Vault) */ {
public:
    inline Vault()
        : Vault(nullptr)
    {
    }
    ~Vault() override;
    explicit PROTOBUF_CONSTEXPR Vault(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Vault(const Vault& from);
    Vault(Vault&& from) noexcept
        : Vault()
    {
        *this = ::std::move(from);
    }

    inline Vault& operator=(const Vault& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Vault& operator=(Vault&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Vault& default_instance()
    {
        return *internal_default_instance();
    }
    enum PlatformMetadataCase {
        kChromeOsMetadata = 11,
        PLATFORM_METADATA_NOT_SET = 0,
    };

    static inline const Vault* internal_default_instance()
    {
        return reinterpret_cast<const Vault*>(&_Vault_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(Vault& a, Vault& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Vault* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Vault* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Vault* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Vault>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Vault& from);
    void MergeFrom(const Vault& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Vault* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.Vault";
    }

protected:
    explicit Vault(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kApplicationKeysFieldNumber = 5,
        kVaultMetadataFieldNumber = 3,
        kRecoveryKeyFieldNumber = 4,
        kVaultParametersFieldNumber = 2,
        kChromeOsMetadataFieldNumber = 11,
    };
    // repeated .trusted_vault_pb.ApplicationKey application_keys = 5;
    int application_keys_size() const;

private:
    int _internal_application_keys_size() const;

public:
    void clear_application_keys();
    ::trusted_vault_pb::ApplicationKey* mutable_application_keys(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::ApplicationKey>* mutable_application_keys();

private:
    const ::trusted_vault_pb::ApplicationKey& _internal_application_keys(int index) const;
    ::trusted_vault_pb::ApplicationKey* _internal_add_application_keys();

public:
    const ::trusted_vault_pb::ApplicationKey& application_keys(int index) const;
    ::trusted_vault_pb::ApplicationKey* add_application_keys();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::ApplicationKey>& application_keys() const;

    // bytes vault_metadata = 3;
    void clear_vault_metadata();
    const std::string& vault_metadata() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_vault_metadata(ArgT0&& arg0, ArgT... args);
    std::string* mutable_vault_metadata();
    PROTOBUF_NODISCARD std::string* release_vault_metadata();
    void set_allocated_vault_metadata(std::string* vault_metadata);

private:
    const std::string& _internal_vault_metadata() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_vault_metadata(const std::string& value);
    std::string* _internal_mutable_vault_metadata();

public:
    // bytes recovery_key = 4;
    void clear_recovery_key();
    const std::string& recovery_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_recovery_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_recovery_key();
    PROTOBUF_NODISCARD std::string* release_recovery_key();
    void set_allocated_recovery_key(std::string* recovery_key);

private:
    const std::string& _internal_recovery_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_recovery_key(const std::string& value);
    std::string* _internal_mutable_recovery_key();

public:
    // .trusted_vault_pb.VaultParameters vault_parameters = 2;
    bool has_vault_parameters() const;

private:
    bool _internal_has_vault_parameters() const;

public:
    void clear_vault_parameters();
    const ::trusted_vault_pb::VaultParameters& vault_parameters() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::VaultParameters* release_vault_parameters();
    ::trusted_vault_pb::VaultParameters* mutable_vault_parameters();
    void set_allocated_vault_parameters(::trusted_vault_pb::VaultParameters* vault_parameters);

private:
    const ::trusted_vault_pb::VaultParameters& _internal_vault_parameters() const;
    ::trusted_vault_pb::VaultParameters* _internal_mutable_vault_parameters();

public:
    void unsafe_arena_set_allocated_vault_parameters(::trusted_vault_pb::VaultParameters* vault_parameters);
    ::trusted_vault_pb::VaultParameters* unsafe_arena_release_vault_parameters();

    // .trusted_vault_pb.ChromeOsMetadata chrome_os_metadata = 11;
    bool has_chrome_os_metadata() const;

private:
    bool _internal_has_chrome_os_metadata() const;

public:
    void clear_chrome_os_metadata();
    const ::trusted_vault_pb::ChromeOsMetadata& chrome_os_metadata() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::ChromeOsMetadata* release_chrome_os_metadata();
    ::trusted_vault_pb::ChromeOsMetadata* mutable_chrome_os_metadata();
    void set_allocated_chrome_os_metadata(::trusted_vault_pb::ChromeOsMetadata* chrome_os_metadata);

private:
    const ::trusted_vault_pb::ChromeOsMetadata& _internal_chrome_os_metadata() const;
    ::trusted_vault_pb::ChromeOsMetadata* _internal_mutable_chrome_os_metadata();

public:
    void unsafe_arena_set_allocated_chrome_os_metadata(::trusted_vault_pb::ChromeOsMetadata* chrome_os_metadata);
    ::trusted_vault_pb::ChromeOsMetadata* unsafe_arena_release_chrome_os_metadata();

    void clear_platform_metadata();
    PlatformMetadataCase platform_metadata_case() const;
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.Vault)
private:
    class _Internal;
    void set_has_chrome_os_metadata();

    inline bool has_platform_metadata() const;
    inline void clear_has_platform_metadata();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::ApplicationKey> application_keys_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vault_metadata_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recovery_key_;
        ::trusted_vault_pb::VaultParameters* vault_parameters_;
        union PlatformMetadataUnion {
            constexpr PlatformMetadataUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::trusted_vault_pb::ChromeOsMetadata* chrome_os_metadata_;
        } platform_metadata_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_recovery_5fkey_5fstore_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// AsymmetricKeyPair

// bytes public_key = 1;
inline void AsymmetricKeyPair::clear_public_key()
{
    _impl_.public_key_.ClearToEmpty();
}
inline const std::string& AsymmetricKeyPair::public_key() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.AsymmetricKeyPair.public_key)
    return _internal_public_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AsymmetricKeyPair::set_public_key(ArgT0&& arg0, ArgT... args)
{

    _impl_.public_key_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.AsymmetricKeyPair.public_key)
}
inline std::string* AsymmetricKeyPair::mutable_public_key()
{
    std::string* _s = _internal_mutable_public_key();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.AsymmetricKeyPair.public_key)
    return _s;
}
inline const std::string& AsymmetricKeyPair::_internal_public_key() const
{
    return _impl_.public_key_.Get();
}
inline void AsymmetricKeyPair::_internal_set_public_key(const std::string& value)
{

    _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AsymmetricKeyPair::_internal_mutable_public_key()
{

    return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* AsymmetricKeyPair::release_public_key()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.AsymmetricKeyPair.public_key)
    return _impl_.public_key_.Release();
}
inline void AsymmetricKeyPair::set_allocated_public_key(std::string* public_key)
{
    if (public_key != nullptr) {

    } else {
    }
    _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.public_key_.IsDefault()) {
        _impl_.public_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.AsymmetricKeyPair.public_key)
}

// bytes wrapped_private_key = 2;
inline void AsymmetricKeyPair::clear_wrapped_private_key()
{
    _impl_.wrapped_private_key_.ClearToEmpty();
}
inline const std::string& AsymmetricKeyPair::wrapped_private_key() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.AsymmetricKeyPair.wrapped_private_key)
    return _internal_wrapped_private_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AsymmetricKeyPair::set_wrapped_private_key(ArgT0&& arg0, ArgT... args)
{

    _impl_.wrapped_private_key_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.AsymmetricKeyPair.wrapped_private_key)
}
inline std::string* AsymmetricKeyPair::mutable_wrapped_private_key()
{
    std::string* _s = _internal_mutable_wrapped_private_key();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.AsymmetricKeyPair.wrapped_private_key)
    return _s;
}
inline const std::string& AsymmetricKeyPair::_internal_wrapped_private_key() const
{
    return _impl_.wrapped_private_key_.Get();
}
inline void AsymmetricKeyPair::_internal_set_wrapped_private_key(const std::string& value)
{

    _impl_.wrapped_private_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AsymmetricKeyPair::_internal_mutable_wrapped_private_key()
{

    return _impl_.wrapped_private_key_.Mutable(GetArenaForAllocation());
}
inline std::string* AsymmetricKeyPair::release_wrapped_private_key()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.AsymmetricKeyPair.wrapped_private_key)
    return _impl_.wrapped_private_key_.Release();
}
inline void AsymmetricKeyPair::set_allocated_wrapped_private_key(std::string* wrapped_private_key)
{
    if (wrapped_private_key != nullptr) {

    } else {
    }
    _impl_.wrapped_private_key_.SetAllocated(wrapped_private_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.wrapped_private_key_.IsDefault()) {
        _impl_.wrapped_private_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.AsymmetricKeyPair.wrapped_private_key)
}

// bytes wrapping_key = 3;
inline void AsymmetricKeyPair::clear_wrapping_key()
{
    _impl_.wrapping_key_.ClearToEmpty();
}
inline const std::string& AsymmetricKeyPair::wrapping_key() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.AsymmetricKeyPair.wrapping_key)
    return _internal_wrapping_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AsymmetricKeyPair::set_wrapping_key(ArgT0&& arg0, ArgT... args)
{

    _impl_.wrapping_key_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.AsymmetricKeyPair.wrapping_key)
}
inline std::string* AsymmetricKeyPair::mutable_wrapping_key()
{
    std::string* _s = _internal_mutable_wrapping_key();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.AsymmetricKeyPair.wrapping_key)
    return _s;
}
inline const std::string& AsymmetricKeyPair::_internal_wrapping_key() const
{
    return _impl_.wrapping_key_.Get();
}
inline void AsymmetricKeyPair::_internal_set_wrapping_key(const std::string& value)
{

    _impl_.wrapping_key_.Set(value, GetArenaForAllocation());
}
inline std::string* AsymmetricKeyPair::_internal_mutable_wrapping_key()
{

    return _impl_.wrapping_key_.Mutable(GetArenaForAllocation());
}
inline std::string* AsymmetricKeyPair::release_wrapping_key()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.AsymmetricKeyPair.wrapping_key)
    return _impl_.wrapping_key_.Release();
}
inline void AsymmetricKeyPair::set_allocated_wrapping_key(std::string* wrapping_key)
{
    if (wrapping_key != nullptr) {

    } else {
    }
    _impl_.wrapping_key_.SetAllocated(wrapping_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.wrapping_key_.IsDefault()) {
        _impl_.wrapping_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.AsymmetricKeyPair.wrapping_key)
}

// -------------------------------------------------------------------

// ApplicationKey

// string key_name = 1;
inline void ApplicationKey::clear_key_name()
{
    _impl_.key_name_.ClearToEmpty();
}
inline const std::string& ApplicationKey::key_name() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.ApplicationKey.key_name)
    return _internal_key_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ApplicationKey::set_key_name(ArgT0&& arg0, ArgT... args)
{

    _impl_.key_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.ApplicationKey.key_name)
}
inline std::string* ApplicationKey::mutable_key_name()
{
    std::string* _s = _internal_mutable_key_name();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.ApplicationKey.key_name)
    return _s;
}
inline const std::string& ApplicationKey::_internal_key_name() const
{
    return _impl_.key_name_.Get();
}
inline void ApplicationKey::_internal_set_key_name(const std::string& value)
{

    _impl_.key_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ApplicationKey::_internal_mutable_key_name()
{

    return _impl_.key_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ApplicationKey::release_key_name()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.ApplicationKey.key_name)
    return _impl_.key_name_.Release();
}
inline void ApplicationKey::set_allocated_key_name(std::string* key_name)
{
    if (key_name != nullptr) {

    } else {
    }
    _impl_.key_name_.SetAllocated(key_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.key_name_.IsDefault()) {
        _impl_.key_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.ApplicationKey.key_name)
}

// .trusted_vault_pb.AsymmetricKeyPair asymmetric_key_pair = 4;
inline bool ApplicationKey::_internal_has_asymmetric_key_pair() const
{
    return this != internal_default_instance() && _impl_.asymmetric_key_pair_ != nullptr;
}
inline bool ApplicationKey::has_asymmetric_key_pair() const
{
    return _internal_has_asymmetric_key_pair();
}
inline void ApplicationKey::clear_asymmetric_key_pair()
{
    if (GetArenaForAllocation() == nullptr && _impl_.asymmetric_key_pair_ != nullptr) {
        delete _impl_.asymmetric_key_pair_;
    }
    _impl_.asymmetric_key_pair_ = nullptr;
}
inline const ::trusted_vault_pb::AsymmetricKeyPair& ApplicationKey::_internal_asymmetric_key_pair() const
{
    const ::trusted_vault_pb::AsymmetricKeyPair* p = _impl_.asymmetric_key_pair_;
    return p != nullptr ? *p : reinterpret_cast<const ::trusted_vault_pb::AsymmetricKeyPair&>(::trusted_vault_pb::_AsymmetricKeyPair_default_instance_);
}
inline const ::trusted_vault_pb::AsymmetricKeyPair& ApplicationKey::asymmetric_key_pair() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.ApplicationKey.asymmetric_key_pair)
    return _internal_asymmetric_key_pair();
}
inline void ApplicationKey::unsafe_arena_set_allocated_asymmetric_key_pair(::trusted_vault_pb::AsymmetricKeyPair* asymmetric_key_pair)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.asymmetric_key_pair_);
    }
    _impl_.asymmetric_key_pair_ = asymmetric_key_pair;
    if (asymmetric_key_pair) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.ApplicationKey.asymmetric_key_pair)
}
inline ::trusted_vault_pb::AsymmetricKeyPair* ApplicationKey::release_asymmetric_key_pair()
{

    ::trusted_vault_pb::AsymmetricKeyPair* temp = _impl_.asymmetric_key_pair_;
    _impl_.asymmetric_key_pair_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::trusted_vault_pb::AsymmetricKeyPair* ApplicationKey::unsafe_arena_release_asymmetric_key_pair()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.ApplicationKey.asymmetric_key_pair)

    ::trusted_vault_pb::AsymmetricKeyPair* temp = _impl_.asymmetric_key_pair_;
    _impl_.asymmetric_key_pair_ = nullptr;
    return temp;
}
inline ::trusted_vault_pb::AsymmetricKeyPair* ApplicationKey::_internal_mutable_asymmetric_key_pair()
{

    if (_impl_.asymmetric_key_pair_ == nullptr) {
        auto* p = CreateMaybeMessage<::trusted_vault_pb::AsymmetricKeyPair>(GetArenaForAllocation());
        _impl_.asymmetric_key_pair_ = p;
    }
    return _impl_.asymmetric_key_pair_;
}
inline ::trusted_vault_pb::AsymmetricKeyPair* ApplicationKey::mutable_asymmetric_key_pair()
{
    ::trusted_vault_pb::AsymmetricKeyPair* _msg = _internal_mutable_asymmetric_key_pair();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.ApplicationKey.asymmetric_key_pair)
    return _msg;
}
inline void ApplicationKey::set_allocated_asymmetric_key_pair(::trusted_vault_pb::AsymmetricKeyPair* asymmetric_key_pair)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.asymmetric_key_pair_;
    }
    if (asymmetric_key_pair) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(asymmetric_key_pair);
        if (message_arena != submessage_arena) {
            asymmetric_key_pair = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, asymmetric_key_pair, submessage_arena);
        }

    } else {
    }
    _impl_.asymmetric_key_pair_ = asymmetric_key_pair;
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.ApplicationKey.asymmetric_key_pair)
}

// -------------------------------------------------------------------

// VaultParameters

// bytes backend_public_key = 1;
inline void VaultParameters::clear_backend_public_key()
{
    _impl_.backend_public_key_.ClearToEmpty();
}
inline const std::string& VaultParameters::backend_public_key() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.VaultParameters.backend_public_key)
    return _internal_backend_public_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void VaultParameters::set_backend_public_key(ArgT0&& arg0, ArgT... args)
{

    _impl_.backend_public_key_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.VaultParameters.backend_public_key)
}
inline std::string* VaultParameters::mutable_backend_public_key()
{
    std::string* _s = _internal_mutable_backend_public_key();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.VaultParameters.backend_public_key)
    return _s;
}
inline const std::string& VaultParameters::_internal_backend_public_key() const
{
    return _impl_.backend_public_key_.Get();
}
inline void VaultParameters::_internal_set_backend_public_key(const std::string& value)
{

    _impl_.backend_public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* VaultParameters::_internal_mutable_backend_public_key()
{

    return _impl_.backend_public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* VaultParameters::release_backend_public_key()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.VaultParameters.backend_public_key)
    return _impl_.backend_public_key_.Release();
}
inline void VaultParameters::set_allocated_backend_public_key(std::string* backend_public_key)
{
    if (backend_public_key != nullptr) {

    } else {
    }
    _impl_.backend_public_key_.SetAllocated(backend_public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.backend_public_key_.IsDefault()) {
        _impl_.backend_public_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.VaultParameters.backend_public_key)
}

// bytes counter_id = 2;
inline void VaultParameters::clear_counter_id()
{
    _impl_.counter_id_.ClearToEmpty();
}
inline const std::string& VaultParameters::counter_id() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.VaultParameters.counter_id)
    return _internal_counter_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void VaultParameters::set_counter_id(ArgT0&& arg0, ArgT... args)
{

    _impl_.counter_id_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.VaultParameters.counter_id)
}
inline std::string* VaultParameters::mutable_counter_id()
{
    std::string* _s = _internal_mutable_counter_id();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.VaultParameters.counter_id)
    return _s;
}
inline const std::string& VaultParameters::_internal_counter_id() const
{
    return _impl_.counter_id_.Get();
}
inline void VaultParameters::_internal_set_counter_id(const std::string& value)
{

    _impl_.counter_id_.Set(value, GetArenaForAllocation());
}
inline std::string* VaultParameters::_internal_mutable_counter_id()
{

    return _impl_.counter_id_.Mutable(GetArenaForAllocation());
}
inline std::string* VaultParameters::release_counter_id()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.VaultParameters.counter_id)
    return _impl_.counter_id_.Release();
}
inline void VaultParameters::set_allocated_counter_id(std::string* counter_id)
{
    if (counter_id != nullptr) {

    } else {
    }
    _impl_.counter_id_.SetAllocated(counter_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.counter_id_.IsDefault()) {
        _impl_.counter_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.VaultParameters.counter_id)
}

// int32 max_attempts = 3;
inline void VaultParameters::clear_max_attempts()
{
    _impl_.max_attempts_ = 0;
}
inline int32_t VaultParameters::_internal_max_attempts() const
{
    return _impl_.max_attempts_;
}
inline int32_t VaultParameters::max_attempts() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.VaultParameters.max_attempts)
    return _internal_max_attempts();
}
inline void VaultParameters::_internal_set_max_attempts(int32_t value)
{

    _impl_.max_attempts_ = value;
}
inline void VaultParameters::set_max_attempts(int32_t value)
{
    _internal_set_max_attempts(value);
    // @@protoc_insertion_point(field_set:trusted_vault_pb.VaultParameters.max_attempts)
}

// bytes vault_handle = 4;
inline void VaultParameters::clear_vault_handle()
{
    _impl_.vault_handle_.ClearToEmpty();
}
inline const std::string& VaultParameters::vault_handle() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.VaultParameters.vault_handle)
    return _internal_vault_handle();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void VaultParameters::set_vault_handle(ArgT0&& arg0, ArgT... args)
{

    _impl_.vault_handle_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.VaultParameters.vault_handle)
}
inline std::string* VaultParameters::mutable_vault_handle()
{
    std::string* _s = _internal_mutable_vault_handle();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.VaultParameters.vault_handle)
    return _s;
}
inline const std::string& VaultParameters::_internal_vault_handle() const
{
    return _impl_.vault_handle_.Get();
}
inline void VaultParameters::_internal_set_vault_handle(const std::string& value)
{

    _impl_.vault_handle_.Set(value, GetArenaForAllocation());
}
inline std::string* VaultParameters::_internal_mutable_vault_handle()
{

    return _impl_.vault_handle_.Mutable(GetArenaForAllocation());
}
inline std::string* VaultParameters::release_vault_handle()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.VaultParameters.vault_handle)
    return _impl_.vault_handle_.Release();
}
inline void VaultParameters::set_allocated_vault_handle(std::string* vault_handle)
{
    if (vault_handle != nullptr) {

    } else {
    }
    _impl_.vault_handle_.SetAllocated(vault_handle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.vault_handle_.IsDefault()) {
        _impl_.vault_handle_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.VaultParameters.vault_handle)
}

// -------------------------------------------------------------------

// VaultMetadata

// .trusted_vault_pb.VaultMetadata.LskfType lskf_type = 1;
inline void VaultMetadata::clear_lskf_type()
{
    _impl_.lskf_type_ = 0;
}
inline ::trusted_vault_pb::VaultMetadata_LskfType VaultMetadata::_internal_lskf_type() const
{
    return static_cast<::trusted_vault_pb::VaultMetadata_LskfType>(_impl_.lskf_type_);
}
inline ::trusted_vault_pb::VaultMetadata_LskfType VaultMetadata::lskf_type() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.VaultMetadata.lskf_type)
    return _internal_lskf_type();
}
inline void VaultMetadata::_internal_set_lskf_type(::trusted_vault_pb::VaultMetadata_LskfType value)
{

    _impl_.lskf_type_ = value;
}
inline void VaultMetadata::set_lskf_type(::trusted_vault_pb::VaultMetadata_LskfType value)
{
    _internal_set_lskf_type(value);
    // @@protoc_insertion_point(field_set:trusted_vault_pb.VaultMetadata.lskf_type)
}

// .trusted_vault_pb.VaultMetadata.HashType hash_type = 4;
inline void VaultMetadata::clear_hash_type()
{
    _impl_.hash_type_ = 0;
}
inline ::trusted_vault_pb::VaultMetadata_HashType VaultMetadata::_internal_hash_type() const
{
    return static_cast<::trusted_vault_pb::VaultMetadata_HashType>(_impl_.hash_type_);
}
inline ::trusted_vault_pb::VaultMetadata_HashType VaultMetadata::hash_type() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.VaultMetadata.hash_type)
    return _internal_hash_type();
}
inline void VaultMetadata::_internal_set_hash_type(::trusted_vault_pb::VaultMetadata_HashType value)
{

    _impl_.hash_type_ = value;
}
inline void VaultMetadata::set_hash_type(::trusted_vault_pb::VaultMetadata_HashType value)
{
    _internal_set_hash_type(value);
    // @@protoc_insertion_point(field_set:trusted_vault_pb.VaultMetadata.hash_type)
}

// bytes hash_salt = 5;
inline void VaultMetadata::clear_hash_salt()
{
    _impl_.hash_salt_.ClearToEmpty();
}
inline const std::string& VaultMetadata::hash_salt() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.VaultMetadata.hash_salt)
    return _internal_hash_salt();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void VaultMetadata::set_hash_salt(ArgT0&& arg0, ArgT... args)
{

    _impl_.hash_salt_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.VaultMetadata.hash_salt)
}
inline std::string* VaultMetadata::mutable_hash_salt()
{
    std::string* _s = _internal_mutable_hash_salt();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.VaultMetadata.hash_salt)
    return _s;
}
inline const std::string& VaultMetadata::_internal_hash_salt() const
{
    return _impl_.hash_salt_.Get();
}
inline void VaultMetadata::_internal_set_hash_salt(const std::string& value)
{

    _impl_.hash_salt_.Set(value, GetArenaForAllocation());
}
inline std::string* VaultMetadata::_internal_mutable_hash_salt()
{

    return _impl_.hash_salt_.Mutable(GetArenaForAllocation());
}
inline std::string* VaultMetadata::release_hash_salt()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.VaultMetadata.hash_salt)
    return _impl_.hash_salt_.Release();
}
inline void VaultMetadata::set_allocated_hash_salt(std::string* hash_salt)
{
    if (hash_salt != nullptr) {

    } else {
    }
    _impl_.hash_salt_.SetAllocated(hash_salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.hash_salt_.IsDefault()) {
        _impl_.hash_salt_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.VaultMetadata.hash_salt)
}

// int32 hash_difficulty = 6;
inline void VaultMetadata::clear_hash_difficulty()
{
    _impl_.hash_difficulty_ = 0;
}
inline int32_t VaultMetadata::_internal_hash_difficulty() const
{
    return _impl_.hash_difficulty_;
}
inline int32_t VaultMetadata::hash_difficulty() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.VaultMetadata.hash_difficulty)
    return _internal_hash_difficulty();
}
inline void VaultMetadata::_internal_set_hash_difficulty(int32_t value)
{

    _impl_.hash_difficulty_ = value;
}
inline void VaultMetadata::set_hash_difficulty(int32_t value)
{
    _internal_set_hash_difficulty(value);
    // @@protoc_insertion_point(field_set:trusted_vault_pb.VaultMetadata.hash_difficulty)
}

// bytes cert_path = 7;
inline void VaultMetadata::clear_cert_path()
{
    _impl_.cert_path_.ClearToEmpty();
}
inline const std::string& VaultMetadata::cert_path() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.VaultMetadata.cert_path)
    return _internal_cert_path();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void VaultMetadata::set_cert_path(ArgT0&& arg0, ArgT... args)
{

    _impl_.cert_path_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.VaultMetadata.cert_path)
}
inline std::string* VaultMetadata::mutable_cert_path()
{
    std::string* _s = _internal_mutable_cert_path();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.VaultMetadata.cert_path)
    return _s;
}
inline const std::string& VaultMetadata::_internal_cert_path() const
{
    return _impl_.cert_path_.Get();
}
inline void VaultMetadata::_internal_set_cert_path(const std::string& value)
{

    _impl_.cert_path_.Set(value, GetArenaForAllocation());
}
inline std::string* VaultMetadata::_internal_mutable_cert_path()
{

    return _impl_.cert_path_.Mutable(GetArenaForAllocation());
}
inline std::string* VaultMetadata::release_cert_path()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.VaultMetadata.cert_path)
    return _impl_.cert_path_.Release();
}
inline void VaultMetadata::set_allocated_cert_path(std::string* cert_path)
{
    if (cert_path != nullptr) {

    } else {
    }
    _impl_.cert_path_.SetAllocated(cert_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cert_path_.IsDefault()) {
        _impl_.cert_path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.VaultMetadata.cert_path)
}

// -------------------------------------------------------------------

// ChromeOsMetadata

// bytes device_id = 1;
inline void ChromeOsMetadata::clear_device_id()
{
    _impl_.device_id_.ClearToEmpty();
}
inline const std::string& ChromeOsMetadata::device_id() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.ChromeOsMetadata.device_id)
    return _internal_device_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ChromeOsMetadata::set_device_id(ArgT0&& arg0, ArgT... args)
{

    _impl_.device_id_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.ChromeOsMetadata.device_id)
}
inline std::string* ChromeOsMetadata::mutable_device_id()
{
    std::string* _s = _internal_mutable_device_id();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.ChromeOsMetadata.device_id)
    return _s;
}
inline const std::string& ChromeOsMetadata::_internal_device_id() const
{
    return _impl_.device_id_.Get();
}
inline void ChromeOsMetadata::_internal_set_device_id(const std::string& value)
{

    _impl_.device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeOsMetadata::_internal_mutable_device_id()
{

    return _impl_.device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeOsMetadata::release_device_id()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.ChromeOsMetadata.device_id)
    return _impl_.device_id_.Release();
}
inline void ChromeOsMetadata::set_allocated_device_id(std::string* device_id)
{
    if (device_id != nullptr) {

    } else {
    }
    _impl_.device_id_.SetAllocated(device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.device_id_.IsDefault()) {
        _impl_.device_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.ChromeOsMetadata.device_id)
}

// -------------------------------------------------------------------

// Vault

// .trusted_vault_pb.VaultParameters vault_parameters = 2;
inline bool Vault::_internal_has_vault_parameters() const
{
    return this != internal_default_instance() && _impl_.vault_parameters_ != nullptr;
}
inline bool Vault::has_vault_parameters() const
{
    return _internal_has_vault_parameters();
}
inline void Vault::clear_vault_parameters()
{
    if (GetArenaForAllocation() == nullptr && _impl_.vault_parameters_ != nullptr) {
        delete _impl_.vault_parameters_;
    }
    _impl_.vault_parameters_ = nullptr;
}
inline const ::trusted_vault_pb::VaultParameters& Vault::_internal_vault_parameters() const
{
    const ::trusted_vault_pb::VaultParameters* p = _impl_.vault_parameters_;
    return p != nullptr ? *p : reinterpret_cast<const ::trusted_vault_pb::VaultParameters&>(::trusted_vault_pb::_VaultParameters_default_instance_);
}
inline const ::trusted_vault_pb::VaultParameters& Vault::vault_parameters() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.Vault.vault_parameters)
    return _internal_vault_parameters();
}
inline void Vault::unsafe_arena_set_allocated_vault_parameters(::trusted_vault_pb::VaultParameters* vault_parameters)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vault_parameters_);
    }
    _impl_.vault_parameters_ = vault_parameters;
    if (vault_parameters) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.Vault.vault_parameters)
}
inline ::trusted_vault_pb::VaultParameters* Vault::release_vault_parameters()
{

    ::trusted_vault_pb::VaultParameters* temp = _impl_.vault_parameters_;
    _impl_.vault_parameters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::trusted_vault_pb::VaultParameters* Vault::unsafe_arena_release_vault_parameters()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.Vault.vault_parameters)

    ::trusted_vault_pb::VaultParameters* temp = _impl_.vault_parameters_;
    _impl_.vault_parameters_ = nullptr;
    return temp;
}
inline ::trusted_vault_pb::VaultParameters* Vault::_internal_mutable_vault_parameters()
{

    if (_impl_.vault_parameters_ == nullptr) {
        auto* p = CreateMaybeMessage<::trusted_vault_pb::VaultParameters>(GetArenaForAllocation());
        _impl_.vault_parameters_ = p;
    }
    return _impl_.vault_parameters_;
}
inline ::trusted_vault_pb::VaultParameters* Vault::mutable_vault_parameters()
{
    ::trusted_vault_pb::VaultParameters* _msg = _internal_mutable_vault_parameters();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.Vault.vault_parameters)
    return _msg;
}
inline void Vault::set_allocated_vault_parameters(::trusted_vault_pb::VaultParameters* vault_parameters)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.vault_parameters_;
    }
    if (vault_parameters) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vault_parameters);
        if (message_arena != submessage_arena) {
            vault_parameters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, vault_parameters, submessage_arena);
        }

    } else {
    }
    _impl_.vault_parameters_ = vault_parameters;
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.Vault.vault_parameters)
}

// bytes vault_metadata = 3;
inline void Vault::clear_vault_metadata()
{
    _impl_.vault_metadata_.ClearToEmpty();
}
inline const std::string& Vault::vault_metadata() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.Vault.vault_metadata)
    return _internal_vault_metadata();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Vault::set_vault_metadata(ArgT0&& arg0, ArgT... args)
{

    _impl_.vault_metadata_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.Vault.vault_metadata)
}
inline std::string* Vault::mutable_vault_metadata()
{
    std::string* _s = _internal_mutable_vault_metadata();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.Vault.vault_metadata)
    return _s;
}
inline const std::string& Vault::_internal_vault_metadata() const
{
    return _impl_.vault_metadata_.Get();
}
inline void Vault::_internal_set_vault_metadata(const std::string& value)
{

    _impl_.vault_metadata_.Set(value, GetArenaForAllocation());
}
inline std::string* Vault::_internal_mutable_vault_metadata()
{

    return _impl_.vault_metadata_.Mutable(GetArenaForAllocation());
}
inline std::string* Vault::release_vault_metadata()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.Vault.vault_metadata)
    return _impl_.vault_metadata_.Release();
}
inline void Vault::set_allocated_vault_metadata(std::string* vault_metadata)
{
    if (vault_metadata != nullptr) {

    } else {
    }
    _impl_.vault_metadata_.SetAllocated(vault_metadata, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.vault_metadata_.IsDefault()) {
        _impl_.vault_metadata_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.Vault.vault_metadata)
}

// bytes recovery_key = 4;
inline void Vault::clear_recovery_key()
{
    _impl_.recovery_key_.ClearToEmpty();
}
inline const std::string& Vault::recovery_key() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.Vault.recovery_key)
    return _internal_recovery_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Vault::set_recovery_key(ArgT0&& arg0, ArgT... args)
{

    _impl_.recovery_key_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.Vault.recovery_key)
}
inline std::string* Vault::mutable_recovery_key()
{
    std::string* _s = _internal_mutable_recovery_key();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.Vault.recovery_key)
    return _s;
}
inline const std::string& Vault::_internal_recovery_key() const
{
    return _impl_.recovery_key_.Get();
}
inline void Vault::_internal_set_recovery_key(const std::string& value)
{

    _impl_.recovery_key_.Set(value, GetArenaForAllocation());
}
inline std::string* Vault::_internal_mutable_recovery_key()
{

    return _impl_.recovery_key_.Mutable(GetArenaForAllocation());
}
inline std::string* Vault::release_recovery_key()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.Vault.recovery_key)
    return _impl_.recovery_key_.Release();
}
inline void Vault::set_allocated_recovery_key(std::string* recovery_key)
{
    if (recovery_key != nullptr) {

    } else {
    }
    _impl_.recovery_key_.SetAllocated(recovery_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.recovery_key_.IsDefault()) {
        _impl_.recovery_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.Vault.recovery_key)
}

// repeated .trusted_vault_pb.ApplicationKey application_keys = 5;
inline int Vault::_internal_application_keys_size() const
{
    return _impl_.application_keys_.size();
}
inline int Vault::application_keys_size() const
{
    return _internal_application_keys_size();
}
inline void Vault::clear_application_keys()
{
    _impl_.application_keys_.Clear();
}
inline ::trusted_vault_pb::ApplicationKey* Vault::mutable_application_keys(int index)
{
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.Vault.application_keys)
    return _impl_.application_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::ApplicationKey>* Vault::mutable_application_keys()
{
    // @@protoc_insertion_point(field_mutable_list:trusted_vault_pb.Vault.application_keys)
    return &_impl_.application_keys_;
}
inline const ::trusted_vault_pb::ApplicationKey& Vault::_internal_application_keys(int index) const
{
    return _impl_.application_keys_.Get(index);
}
inline const ::trusted_vault_pb::ApplicationKey& Vault::application_keys(int index) const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.Vault.application_keys)
    return _internal_application_keys(index);
}
inline ::trusted_vault_pb::ApplicationKey* Vault::_internal_add_application_keys()
{
    return _impl_.application_keys_.Add();
}
inline ::trusted_vault_pb::ApplicationKey* Vault::add_application_keys()
{
    ::trusted_vault_pb::ApplicationKey* _add = _internal_add_application_keys();
    // @@protoc_insertion_point(field_add:trusted_vault_pb.Vault.application_keys)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::ApplicationKey>& Vault::application_keys() const
{
    // @@protoc_insertion_point(field_list:trusted_vault_pb.Vault.application_keys)
    return _impl_.application_keys_;
}

// .trusted_vault_pb.ChromeOsMetadata chrome_os_metadata = 11;
inline bool Vault::_internal_has_chrome_os_metadata() const
{
    return platform_metadata_case() == kChromeOsMetadata;
}
inline bool Vault::has_chrome_os_metadata() const
{
    return _internal_has_chrome_os_metadata();
}
inline void Vault::set_has_chrome_os_metadata()
{
    _impl_._oneof_case_[0] = kChromeOsMetadata;
}
inline void Vault::clear_chrome_os_metadata()
{
    if (_internal_has_chrome_os_metadata()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.platform_metadata_.chrome_os_metadata_;
        }
        clear_has_platform_metadata();
    }
}
inline ::trusted_vault_pb::ChromeOsMetadata* Vault::release_chrome_os_metadata()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.Vault.chrome_os_metadata)
    if (_internal_has_chrome_os_metadata()) {
        clear_has_platform_metadata();
        ::trusted_vault_pb::ChromeOsMetadata* temp = _impl_.platform_metadata_.chrome_os_metadata_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.platform_metadata_.chrome_os_metadata_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::trusted_vault_pb::ChromeOsMetadata& Vault::_internal_chrome_os_metadata() const
{
    return _internal_has_chrome_os_metadata()
        ? *_impl_.platform_metadata_.chrome_os_metadata_
        : reinterpret_cast<::trusted_vault_pb::ChromeOsMetadata&>(::trusted_vault_pb::_ChromeOsMetadata_default_instance_);
}
inline const ::trusted_vault_pb::ChromeOsMetadata& Vault::chrome_os_metadata() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.Vault.chrome_os_metadata)
    return _internal_chrome_os_metadata();
}
inline ::trusted_vault_pb::ChromeOsMetadata* Vault::unsafe_arena_release_chrome_os_metadata()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:trusted_vault_pb.Vault.chrome_os_metadata)
    if (_internal_has_chrome_os_metadata()) {
        clear_has_platform_metadata();
        ::trusted_vault_pb::ChromeOsMetadata* temp = _impl_.platform_metadata_.chrome_os_metadata_;
        _impl_.platform_metadata_.chrome_os_metadata_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Vault::unsafe_arena_set_allocated_chrome_os_metadata(::trusted_vault_pb::ChromeOsMetadata* chrome_os_metadata)
{
    clear_platform_metadata();
    if (chrome_os_metadata) {
        set_has_chrome_os_metadata();
        _impl_.platform_metadata_.chrome_os_metadata_ = chrome_os_metadata;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.Vault.chrome_os_metadata)
}
inline ::trusted_vault_pb::ChromeOsMetadata* Vault::_internal_mutable_chrome_os_metadata()
{
    if (!_internal_has_chrome_os_metadata()) {
        clear_platform_metadata();
        set_has_chrome_os_metadata();
        _impl_.platform_metadata_.chrome_os_metadata_ = CreateMaybeMessage<::trusted_vault_pb::ChromeOsMetadata>(GetArenaForAllocation());
    }
    return _impl_.platform_metadata_.chrome_os_metadata_;
}
inline ::trusted_vault_pb::ChromeOsMetadata* Vault::mutable_chrome_os_metadata()
{
    ::trusted_vault_pb::ChromeOsMetadata* _msg = _internal_mutable_chrome_os_metadata();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.Vault.chrome_os_metadata)
    return _msg;
}

inline bool Vault::has_platform_metadata() const
{
    return platform_metadata_case() != PLATFORM_METADATA_NOT_SET;
}
inline void Vault::clear_has_platform_metadata()
{
    _impl_._oneof_case_[0] = PLATFORM_METADATA_NOT_SET;
}
inline Vault::PlatformMetadataCase Vault::platform_metadata_case() const
{
    return Vault::PlatformMetadataCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace trusted_vault_pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::trusted_vault_pb::VaultMetadata_LskfType> : ::std::true_type { };
template <> struct is_proto_enum<::trusted_vault_pb::VaultMetadata_HashType> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_recovery_5fkey_5fstore_2eproto
