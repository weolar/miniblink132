// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vault.proto

#include "vault.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace trusted_vault_pb {
PROTOBUF_CONSTEXPR SharedMemberKey::SharedMemberKey(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.wrapped_key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.member_proof_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.epoch_)*/ 0,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SharedMemberKeyDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SharedMemberKeyDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SharedMemberKeyDefaultTypeInternal()
    {
    }
    union {
        SharedMemberKey _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SharedMemberKeyDefaultTypeInternal _SharedMemberKey_default_instance_;
PROTOBUF_CONSTEXPR RotationProof::RotationProof(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.rotation_proof_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.new_epoch_)*/ 0,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct RotationProofDefaultTypeInternal {
    PROTOBUF_CONSTEXPR RotationProofDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~RotationProofDefaultTypeInternal()
    {
    }
    union {
        RotationProof _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RotationProofDefaultTypeInternal _RotationProof_default_instance_;
PROTOBUF_CONSTEXPR SecurityDomainDetails_SyncDetails::SecurityDomainDetails_SyncDetails(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.degraded_recoverability_)*/ false, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SecurityDomainDetails_SyncDetailsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SecurityDomainDetails_SyncDetailsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SecurityDomainDetails_SyncDetailsDefaultTypeInternal()
    {
    }
    union {
        SecurityDomainDetails_SyncDetails _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecurityDomainDetails_SyncDetailsDefaultTypeInternal
    _SecurityDomainDetails_SyncDetails_default_instance_;
PROTOBUF_CONSTEXPR SecurityDomainDetails::SecurityDomainDetails(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.sync_details_)*/ nullptr, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SecurityDomainDetailsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SecurityDomainDetailsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SecurityDomainDetailsDefaultTypeInternal()
    {
    }
    union {
        SecurityDomainDetails _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecurityDomainDetailsDefaultTypeInternal
    _SecurityDomainDetails_default_instance_;
PROTOBUF_CONSTEXPR SecurityDomain::SecurityDomain(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.security_domain_details_)*/ nullptr, /*decltype(_impl_.current_epoch_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SecurityDomainDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SecurityDomainDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SecurityDomainDefaultTypeInternal()
    {
    }
    union {
        SecurityDomain _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecurityDomainDefaultTypeInternal _SecurityDomain_default_instance_;
PROTOBUF_CONSTEXPR Timestamp::Timestamp(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.seconds_)*/ int64_t { 0 }, /*decltype(_impl_.nanos_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct TimestampDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TimestampDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TimestampDefaultTypeInternal()
    {
    }
    union {
        Timestamp _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimestampDefaultTypeInternal _Timestamp_default_instance_;
PROTOBUF_CONSTEXPR PhysicalDeviceMetadata::PhysicalDeviceMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.device_type_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct PhysicalDeviceMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PhysicalDeviceMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PhysicalDeviceMetadataDefaultTypeInternal()
    {
    }
    union {
        PhysicalDeviceMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhysicalDeviceMetadataDefaultTypeInternal
    _PhysicalDeviceMetadata_default_instance_;
PROTOBUF_CONSTEXPR LskfMetadata::LskfMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.expiration_time_)*/ nullptr, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct LskfMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LskfMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LskfMetadataDefaultTypeInternal()
    {
    }
    union {
        LskfMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LskfMetadataDefaultTypeInternal _LskfMetadata_default_instance_;
PROTOBUF_CONSTEXPR GooglePasswordManagerPinMetadata::GooglePasswordManagerPinMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.encrypted_pin_hash_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.expiration_time_)*/ nullptr, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct GooglePasswordManagerPinMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GooglePasswordManagerPinMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GooglePasswordManagerPinMetadataDefaultTypeInternal()
    {
    }
    union {
        GooglePasswordManagerPinMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GooglePasswordManagerPinMetadataDefaultTypeInternal
    _GooglePasswordManagerPinMetadata_default_instance_;
PROTOBUF_CONSTEXPR SecurityDomainMember_SecurityDomainMembership::SecurityDomainMember_SecurityDomainMembership(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.keys_)*/ {}, /*decltype(_impl_.rotation_proofs_)*/ {},
        /*decltype(_impl_.security_domain_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SecurityDomainMember_SecurityDomainMembershipDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SecurityDomainMember_SecurityDomainMembershipDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SecurityDomainMember_SecurityDomainMembershipDefaultTypeInternal()
    {
    }
    union {
        SecurityDomainMember_SecurityDomainMembership _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecurityDomainMember_SecurityDomainMembershipDefaultTypeInternal
    _SecurityDomainMember_SecurityDomainMembership_default_instance_;
PROTOBUF_CONSTEXPR SecurityDomainMember_MemberMetadata::SecurityDomainMember_MemberMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.usable_for_retrieval_)*/ false, /*decltype(_impl_.member_metadata_variant_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct SecurityDomainMember_MemberMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SecurityDomainMember_MemberMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SecurityDomainMember_MemberMetadataDefaultTypeInternal()
    {
    }
    union {
        SecurityDomainMember_MemberMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecurityDomainMember_MemberMetadataDefaultTypeInternal
    _SecurityDomainMember_MemberMetadata_default_instance_;
PROTOBUF_CONSTEXPR SecurityDomainMember::SecurityDomainMember(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.memberships_)*/ {}, /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.public_key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.member_metadata_)*/ nullptr,
        /*decltype(_impl_.member_type_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SecurityDomainMemberDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SecurityDomainMemberDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SecurityDomainMemberDefaultTypeInternal()
    {
    }
    union {
        SecurityDomainMember _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SecurityDomainMemberDefaultTypeInternal
    _SecurityDomainMember_default_instance_;
PROTOBUF_CONSTEXPR JoinSecurityDomainsRequest::JoinSecurityDomainsRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.shared_member_key_)*/ {},
        /*decltype(_impl_.current_public_key_to_replace_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.security_domain_)*/ nullptr, /*decltype(_impl_.security_domain_member_)*/ nullptr, /*decltype(_impl_.member_type_hint_)*/ 0,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct JoinSecurityDomainsRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR JoinSecurityDomainsRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~JoinSecurityDomainsRequestDefaultTypeInternal()
    {
    }
    union {
        JoinSecurityDomainsRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JoinSecurityDomainsRequestDefaultTypeInternal
    _JoinSecurityDomainsRequest_default_instance_;
PROTOBUF_CONSTEXPR JoinSecurityDomainsResponse::JoinSecurityDomainsResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.security_domain_)*/ nullptr, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct JoinSecurityDomainsResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR JoinSecurityDomainsResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~JoinSecurityDomainsResponseDefaultTypeInternal()
    {
    }
    union {
        JoinSecurityDomainsResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JoinSecurityDomainsResponseDefaultTypeInternal
    _JoinSecurityDomainsResponse_default_instance_;
PROTOBUF_CONSTEXPR JoinSecurityDomainsErrorDetail::JoinSecurityDomainsErrorDetail(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.already_exists_response_)*/ nullptr, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct JoinSecurityDomainsErrorDetailDefaultTypeInternal {
    PROTOBUF_CONSTEXPR JoinSecurityDomainsErrorDetailDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~JoinSecurityDomainsErrorDetailDefaultTypeInternal()
    {
    }
    union {
        JoinSecurityDomainsErrorDetail _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 JoinSecurityDomainsErrorDetailDefaultTypeInternal
    _JoinSecurityDomainsErrorDetail_default_instance_;
PROTOBUF_CONSTEXPR ListSecurityDomainMembersResponse::ListSecurityDomainMembersResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.security_domain_members_)*/ {},
        /*decltype(_impl_.next_page_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ListSecurityDomainMembersResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ListSecurityDomainMembersResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ListSecurityDomainMembersResponseDefaultTypeInternal()
    {
    }
    union {
        ListSecurityDomainMembersResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ListSecurityDomainMembersResponseDefaultTypeInternal
    _ListSecurityDomainMembersResponse_default_instance_;
PROTOBUF_CONSTEXPR Proto3Any::Proto3Any(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.type_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct Proto3AnyDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Proto3AnyDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Proto3AnyDefaultTypeInternal()
    {
    }
    union {
        Proto3Any _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Proto3AnyDefaultTypeInternal _Proto3Any_default_instance_;
PROTOBUF_CONSTEXPR RPCStatus::RPCStatus(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.details_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct RPCStatusDefaultTypeInternal {
    PROTOBUF_CONSTEXPR RPCStatusDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~RPCStatusDefaultTypeInternal()
    {
    }
    union {
        RPCStatus _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RPCStatusDefaultTypeInternal _RPCStatus_default_instance_;
} // namespace trusted_vault_pb
namespace trusted_vault_pb {
bool PhysicalDeviceMetadata_DeviceType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PhysicalDeviceMetadata_DeviceType_strings[7] = {};

static const char PhysicalDeviceMetadata_DeviceType_names[] = "DEVICE_TYPE_ANDROID"
                                                              "DEVICE_TYPE_CHROMEOS"
                                                              "DEVICE_TYPE_IOS"
                                                              "DEVICE_TYPE_LINUX"
                                                              "DEVICE_TYPE_MAC_OS"
                                                              "DEVICE_TYPE_UNKNOWN"
                                                              "DEVICE_TYPE_WINDOWS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PhysicalDeviceMetadata_DeviceType_entries[] = {
    { { PhysicalDeviceMetadata_DeviceType_names + 0, 19 }, 1 },
    { { PhysicalDeviceMetadata_DeviceType_names + 19, 20 }, 3 },
    { { PhysicalDeviceMetadata_DeviceType_names + 39, 15 }, 2 },
    { { PhysicalDeviceMetadata_DeviceType_names + 54, 17 }, 6 },
    { { PhysicalDeviceMetadata_DeviceType_names + 71, 18 }, 5 },
    { { PhysicalDeviceMetadata_DeviceType_names + 89, 19 }, 0 },
    { { PhysicalDeviceMetadata_DeviceType_names + 108, 19 }, 4 },
};

static const int PhysicalDeviceMetadata_DeviceType_entries_by_number[] = {
    5, // 0 -> DEVICE_TYPE_UNKNOWN
    0, // 1 -> DEVICE_TYPE_ANDROID
    2, // 2 -> DEVICE_TYPE_IOS
    1, // 3 -> DEVICE_TYPE_CHROMEOS
    6, // 4 -> DEVICE_TYPE_WINDOWS
    4, // 5 -> DEVICE_TYPE_MAC_OS
    3, // 6 -> DEVICE_TYPE_LINUX
};

const std::string& PhysicalDeviceMetadata_DeviceType_Name(PhysicalDeviceMetadata_DeviceType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        PhysicalDeviceMetadata_DeviceType_entries, PhysicalDeviceMetadata_DeviceType_entries_by_number, 7, PhysicalDeviceMetadata_DeviceType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        PhysicalDeviceMetadata_DeviceType_entries, PhysicalDeviceMetadata_DeviceType_entries_by_number, 7, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : PhysicalDeviceMetadata_DeviceType_strings[idx].get();
}
bool PhysicalDeviceMetadata_DeviceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PhysicalDeviceMetadata_DeviceType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(PhysicalDeviceMetadata_DeviceType_entries, 7, name, &int_value);
    if (success) {
        *value = static_cast<PhysicalDeviceMetadata_DeviceType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PhysicalDeviceMetadata_DeviceType PhysicalDeviceMetadata::DEVICE_TYPE_UNKNOWN;
constexpr PhysicalDeviceMetadata_DeviceType PhysicalDeviceMetadata::DEVICE_TYPE_ANDROID;
constexpr PhysicalDeviceMetadata_DeviceType PhysicalDeviceMetadata::DEVICE_TYPE_IOS;
constexpr PhysicalDeviceMetadata_DeviceType PhysicalDeviceMetadata::DEVICE_TYPE_CHROMEOS;
constexpr PhysicalDeviceMetadata_DeviceType PhysicalDeviceMetadata::DEVICE_TYPE_WINDOWS;
constexpr PhysicalDeviceMetadata_DeviceType PhysicalDeviceMetadata::DEVICE_TYPE_MAC_OS;
constexpr PhysicalDeviceMetadata_DeviceType PhysicalDeviceMetadata::DEVICE_TYPE_LINUX;
constexpr PhysicalDeviceMetadata_DeviceType PhysicalDeviceMetadata::DeviceType_MIN;
constexpr PhysicalDeviceMetadata_DeviceType PhysicalDeviceMetadata::DeviceType_MAX;
constexpr int PhysicalDeviceMetadata::DeviceType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SecurityDomainMember_MemberType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SecurityDomainMember_MemberType_strings[5] = {};

static const char SecurityDomainMember_MemberType_names[] = "MEMBER_TYPE_GOOGLE_PASSWORD_MANAGER_PIN"
                                                            "MEMBER_TYPE_ICLOUD_KEYCHAIN"
                                                            "MEMBER_TYPE_LOCKSCREEN_KNOWLEDGE_FACTOR"
                                                            "MEMBER_TYPE_PHYSICAL_DEVICE"
                                                            "MEMBER_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SecurityDomainMember_MemberType_entries[] = {
    { { SecurityDomainMember_MemberType_names + 0, 39 }, 5 },
    { { SecurityDomainMember_MemberType_names + 39, 27 }, 4 },
    { { SecurityDomainMember_MemberType_names + 66, 39 }, 2 },
    { { SecurityDomainMember_MemberType_names + 105, 27 }, 1 },
    { { SecurityDomainMember_MemberType_names + 132, 23 }, 0 },
};

static const int SecurityDomainMember_MemberType_entries_by_number[] = {
    4, // 0 -> MEMBER_TYPE_UNSPECIFIED
    3, // 1 -> MEMBER_TYPE_PHYSICAL_DEVICE
    2, // 2 -> MEMBER_TYPE_LOCKSCREEN_KNOWLEDGE_FACTOR
    1, // 4 -> MEMBER_TYPE_ICLOUD_KEYCHAIN
    0, // 5 -> MEMBER_TYPE_GOOGLE_PASSWORD_MANAGER_PIN
};

const std::string& SecurityDomainMember_MemberType_Name(SecurityDomainMember_MemberType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        SecurityDomainMember_MemberType_entries, SecurityDomainMember_MemberType_entries_by_number, 5, SecurityDomainMember_MemberType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        SecurityDomainMember_MemberType_entries, SecurityDomainMember_MemberType_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : SecurityDomainMember_MemberType_strings[idx].get();
}
bool SecurityDomainMember_MemberType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SecurityDomainMember_MemberType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(SecurityDomainMember_MemberType_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<SecurityDomainMember_MemberType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SecurityDomainMember_MemberType SecurityDomainMember::MEMBER_TYPE_UNSPECIFIED;
constexpr SecurityDomainMember_MemberType SecurityDomainMember::MEMBER_TYPE_PHYSICAL_DEVICE;
constexpr SecurityDomainMember_MemberType SecurityDomainMember::MEMBER_TYPE_LOCKSCREEN_KNOWLEDGE_FACTOR;
constexpr SecurityDomainMember_MemberType SecurityDomainMember::MEMBER_TYPE_ICLOUD_KEYCHAIN;
constexpr SecurityDomainMember_MemberType SecurityDomainMember::MEMBER_TYPE_GOOGLE_PASSWORD_MANAGER_PIN;
constexpr SecurityDomainMember_MemberType SecurityDomainMember::MemberType_MIN;
constexpr SecurityDomainMember_MemberType SecurityDomainMember::MemberType_MAX;
constexpr int SecurityDomainMember::MemberType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class SharedMemberKey::_Internal {
public:
};

SharedMemberKey::SharedMemberKey(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.SharedMemberKey)
}
SharedMemberKey::SharedMemberKey(const SharedMemberKey& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SharedMemberKey* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_.wrapped_key_) {}, decltype(_impl_.member_proof_) {}, decltype(_impl_.epoch_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.wrapped_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wrapped_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_wrapped_key().empty()) {
        _this->_impl_.wrapped_key_.Set(from._internal_wrapped_key(), _this->GetArenaForAllocation());
    }
    _impl_.member_proof_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.member_proof_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_member_proof().empty()) {
        _this->_impl_.member_proof_.Set(from._internal_member_proof(), _this->GetArenaForAllocation());
    }
    _this->_impl_.epoch_ = from._impl_.epoch_;
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.SharedMemberKey)
}

inline void SharedMemberKey::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_.wrapped_key_) {}, decltype(_impl_.member_proof_) {}, decltype(_impl_.epoch_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.wrapped_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wrapped_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.member_proof_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.member_proof_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SharedMemberKey::~SharedMemberKey()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.SharedMemberKey)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SharedMemberKey::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.wrapped_key_.Destroy();
    _impl_.member_proof_.Destroy();
}

void SharedMemberKey::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SharedMemberKey::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.SharedMemberKey)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.wrapped_key_.ClearToEmpty();
    _impl_.member_proof_.ClearToEmpty();
    _impl_.epoch_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* SharedMemberKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // int32 epoch = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.epoch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bytes wrapped_key = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_wrapped_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bytes member_proof = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_member_proof();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SharedMemberKey::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.SharedMemberKey)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // int32 epoch = 1;
    if (this->_internal_epoch() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_epoch(), target);
    }

    // bytes wrapped_key = 2;
    if (!this->_internal_wrapped_key().empty()) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_wrapped_key(), target);
    }

    // bytes member_proof = 3;
    if (!this->_internal_member_proof().empty()) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_member_proof(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.SharedMemberKey)
    return target;
}

size_t SharedMemberKey::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.SharedMemberKey)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // bytes wrapped_key = 2;
    if (!this->_internal_wrapped_key().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_wrapped_key());
    }

    // bytes member_proof = 3;
    if (!this->_internal_member_proof().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_member_proof());
    }

    // int32 epoch = 1;
    if (this->_internal_epoch() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_epoch());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SharedMemberKey::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SharedMemberKey*>(&from));
}

void SharedMemberKey::MergeFrom(const SharedMemberKey& from)
{
    SharedMemberKey* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.SharedMemberKey)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_wrapped_key().empty()) {
        _this->_internal_set_wrapped_key(from._internal_wrapped_key());
    }
    if (!from._internal_member_proof().empty()) {
        _this->_internal_set_member_proof(from._internal_member_proof());
    }
    if (from._internal_epoch() != 0) {
        _this->_internal_set_epoch(from._internal_epoch());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SharedMemberKey::CopyFrom(const SharedMemberKey& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.SharedMemberKey)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SharedMemberKey::IsInitialized() const
{
    return true;
}

void SharedMemberKey::InternalSwap(SharedMemberKey* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.wrapped_key_, lhs_arena, &other->_impl_.wrapped_key_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.member_proof_, lhs_arena, &other->_impl_.member_proof_, rhs_arena);
    swap(_impl_.epoch_, other->_impl_.epoch_);
}

std::string SharedMemberKey::GetTypeName() const
{
    return "trusted_vault_pb.SharedMemberKey";
}

// ===================================================================

class RotationProof::_Internal {
public:
};

RotationProof::RotationProof(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.RotationProof)
}
RotationProof::RotationProof(const RotationProof& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    RotationProof* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.rotation_proof_) {}, decltype(_impl_.new_epoch_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.rotation_proof_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rotation_proof_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_rotation_proof().empty()) {
        _this->_impl_.rotation_proof_.Set(from._internal_rotation_proof(), _this->GetArenaForAllocation());
    }
    _this->_impl_.new_epoch_ = from._impl_.new_epoch_;
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.RotationProof)
}

inline void RotationProof::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.rotation_proof_) {}, decltype(_impl_.new_epoch_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.rotation_proof_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rotation_proof_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RotationProof::~RotationProof()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.RotationProof)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void RotationProof::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.rotation_proof_.Destroy();
}

void RotationProof::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void RotationProof::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.RotationProof)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.rotation_proof_.ClearToEmpty();
    _impl_.new_epoch_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* RotationProof::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // int32 new_epoch = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.new_epoch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bytes rotation_proof = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_rotation_proof();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* RotationProof::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.RotationProof)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // int32 new_epoch = 1;
    if (this->_internal_new_epoch() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_new_epoch(), target);
    }

    // bytes rotation_proof = 2;
    if (!this->_internal_rotation_proof().empty()) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_rotation_proof(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.RotationProof)
    return target;
}

size_t RotationProof::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.RotationProof)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // bytes rotation_proof = 2;
    if (!this->_internal_rotation_proof().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_rotation_proof());
    }

    // int32 new_epoch = 1;
    if (this->_internal_new_epoch() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_new_epoch());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void RotationProof::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const RotationProof*>(&from));
}

void RotationProof::MergeFrom(const RotationProof& from)
{
    RotationProof* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.RotationProof)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_rotation_proof().empty()) {
        _this->_internal_set_rotation_proof(from._internal_rotation_proof());
    }
    if (from._internal_new_epoch() != 0) {
        _this->_internal_set_new_epoch(from._internal_new_epoch());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RotationProof::CopyFrom(const RotationProof& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.RotationProof)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool RotationProof::IsInitialized() const
{
    return true;
}

void RotationProof::InternalSwap(RotationProof* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.rotation_proof_, lhs_arena, &other->_impl_.rotation_proof_, rhs_arena);
    swap(_impl_.new_epoch_, other->_impl_.new_epoch_);
}

std::string RotationProof::GetTypeName() const
{
    return "trusted_vault_pb.RotationProof";
}

// ===================================================================

class SecurityDomainDetails_SyncDetails::_Internal {
public:
};

SecurityDomainDetails_SyncDetails::SecurityDomainDetails_SyncDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.SecurityDomainDetails.SyncDetails)
}
SecurityDomainDetails_SyncDetails::SecurityDomainDetails_SyncDetails(const SecurityDomainDetails_SyncDetails& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SecurityDomainDetails_SyncDetails* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.degraded_recoverability_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.degraded_recoverability_ = from._impl_.degraded_recoverability_;
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.SecurityDomainDetails.SyncDetails)
}

inline void SecurityDomainDetails_SyncDetails::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.degraded_recoverability_) { false }, /*decltype(_impl_._cached_size_)*/ {} };
}

SecurityDomainDetails_SyncDetails::~SecurityDomainDetails_SyncDetails()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.SecurityDomainDetails.SyncDetails)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SecurityDomainDetails_SyncDetails::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SecurityDomainDetails_SyncDetails::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SecurityDomainDetails_SyncDetails::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.SecurityDomainDetails.SyncDetails)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.degraded_recoverability_ = false;
    _internal_metadata_.Clear<std::string>();
}

const char* SecurityDomainDetails_SyncDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // bool degraded_recoverability = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.degraded_recoverability_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SecurityDomainDetails_SyncDetails::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.SecurityDomainDetails.SyncDetails)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // bool degraded_recoverability = 1;
    if (this->_internal_degraded_recoverability() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_degraded_recoverability(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.SecurityDomainDetails.SyncDetails)
    return target;
}

size_t SecurityDomainDetails_SyncDetails::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.SecurityDomainDetails.SyncDetails)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // bool degraded_recoverability = 1;
    if (this->_internal_degraded_recoverability() != 0) {
        total_size += 1 + 1;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SecurityDomainDetails_SyncDetails::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SecurityDomainDetails_SyncDetails*>(&from));
}

void SecurityDomainDetails_SyncDetails::MergeFrom(const SecurityDomainDetails_SyncDetails& from)
{
    SecurityDomainDetails_SyncDetails* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.SecurityDomainDetails.SyncDetails)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_degraded_recoverability() != 0) {
        _this->_internal_set_degraded_recoverability(from._internal_degraded_recoverability());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SecurityDomainDetails_SyncDetails::CopyFrom(const SecurityDomainDetails_SyncDetails& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.SecurityDomainDetails.SyncDetails)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SecurityDomainDetails_SyncDetails::IsInitialized() const
{
    return true;
}

void SecurityDomainDetails_SyncDetails::InternalSwap(SecurityDomainDetails_SyncDetails* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.degraded_recoverability_, other->_impl_.degraded_recoverability_);
}

std::string SecurityDomainDetails_SyncDetails::GetTypeName() const
{
    return "trusted_vault_pb.SecurityDomainDetails.SyncDetails";
}

// ===================================================================

class SecurityDomainDetails::_Internal {
public:
    static const ::trusted_vault_pb::SecurityDomainDetails_SyncDetails& sync_details(const SecurityDomainDetails* msg);
};

const ::trusted_vault_pb::SecurityDomainDetails_SyncDetails& SecurityDomainDetails::_Internal::sync_details(const SecurityDomainDetails* msg)
{
    return *msg->_impl_.sync_details_;
}
SecurityDomainDetails::SecurityDomainDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.SecurityDomainDetails)
}
SecurityDomainDetails::SecurityDomainDetails(const SecurityDomainDetails& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SecurityDomainDetails* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.sync_details_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_sync_details()) {
        _this->_impl_.sync_details_ = new ::trusted_vault_pb::SecurityDomainDetails_SyncDetails(*from._impl_.sync_details_);
    }
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.SecurityDomainDetails)
}

inline void SecurityDomainDetails::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.sync_details_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };
}

SecurityDomainDetails::~SecurityDomainDetails()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.SecurityDomainDetails)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SecurityDomainDetails::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.sync_details_;
}

void SecurityDomainDetails::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SecurityDomainDetails::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.SecurityDomainDetails)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (GetArenaForAllocation() == nullptr && _impl_.sync_details_ != nullptr) {
        delete _impl_.sync_details_;
    }
    _impl_.sync_details_ = nullptr;
    _internal_metadata_.Clear<std::string>();
}

const char* SecurityDomainDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .trusted_vault_pb.SecurityDomainDetails.SyncDetails sync_details = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_sync_details(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SecurityDomainDetails::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.SecurityDomainDetails)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .trusted_vault_pb.SecurityDomainDetails.SyncDetails sync_details = 1;
    if (this->_internal_has_sync_details()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::sync_details(this), _Internal::sync_details(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.SecurityDomainDetails)
    return target;
}

size_t SecurityDomainDetails::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.SecurityDomainDetails)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // .trusted_vault_pb.SecurityDomainDetails.SyncDetails sync_details = 1;
    if (this->_internal_has_sync_details()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.sync_details_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SecurityDomainDetails::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SecurityDomainDetails*>(&from));
}

void SecurityDomainDetails::MergeFrom(const SecurityDomainDetails& from)
{
    SecurityDomainDetails* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.SecurityDomainDetails)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_sync_details()) {
        _this->_internal_mutable_sync_details()->::trusted_vault_pb::SecurityDomainDetails_SyncDetails::MergeFrom(from._internal_sync_details());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SecurityDomainDetails::CopyFrom(const SecurityDomainDetails& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.SecurityDomainDetails)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SecurityDomainDetails::IsInitialized() const
{
    return true;
}

void SecurityDomainDetails::InternalSwap(SecurityDomainDetails* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.sync_details_, other->_impl_.sync_details_);
}

std::string SecurityDomainDetails::GetTypeName() const
{
    return "trusted_vault_pb.SecurityDomainDetails";
}

// ===================================================================

class SecurityDomain::_Internal {
public:
    static const ::trusted_vault_pb::SecurityDomainDetails& security_domain_details(const SecurityDomain* msg);
};

const ::trusted_vault_pb::SecurityDomainDetails& SecurityDomain::_Internal::security_domain_details(const SecurityDomain* msg)
{
    return *msg->_impl_.security_domain_details_;
}
SecurityDomain::SecurityDomain(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.SecurityDomain)
}
SecurityDomain::SecurityDomain(const SecurityDomain& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SecurityDomain* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.name_) {}, decltype(_impl_.security_domain_details_) { nullptr }, decltype(_impl_.current_epoch_) {},
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_name().empty()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_security_domain_details()) {
        _this->_impl_.security_domain_details_ = new ::trusted_vault_pb::SecurityDomainDetails(*from._impl_.security_domain_details_);
    }
    _this->_impl_.current_epoch_ = from._impl_.current_epoch_;
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.SecurityDomain)
}

inline void SecurityDomain::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.name_) {}, decltype(_impl_.security_domain_details_) { nullptr }, decltype(_impl_.current_epoch_) { 0 },
        /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SecurityDomain::~SecurityDomain()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.SecurityDomain)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SecurityDomain::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.security_domain_details_;
}

void SecurityDomain::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SecurityDomain::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.SecurityDomain)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.name_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.security_domain_details_ != nullptr) {
        delete _impl_.security_domain_details_;
    }
    _impl_.security_domain_details_ = nullptr;
    _impl_.current_epoch_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* SecurityDomain::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // int32 current_epoch = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.current_epoch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .trusted_vault_pb.SecurityDomainDetails security_domain_details = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_security_domain_details(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SecurityDomain::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.SecurityDomain)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string name = 1;
    if (!this->_internal_name().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "trusted_vault_pb.SecurityDomain.name");
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // int32 current_epoch = 2;
    if (this->_internal_current_epoch() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_current_epoch(), target);
    }

    // .trusted_vault_pb.SecurityDomainDetails security_domain_details = 3;
    if (this->_internal_has_security_domain_details()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::security_domain_details(this), _Internal::security_domain_details(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.SecurityDomain)
    return target;
}

size_t SecurityDomain::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.SecurityDomain)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string name = 1;
    if (!this->_internal_name().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
    }

    // .trusted_vault_pb.SecurityDomainDetails security_domain_details = 3;
    if (this->_internal_has_security_domain_details()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.security_domain_details_);
    }

    // int32 current_epoch = 2;
    if (this->_internal_current_epoch() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_current_epoch());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SecurityDomain::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SecurityDomain*>(&from));
}

void SecurityDomain::MergeFrom(const SecurityDomain& from)
{
    SecurityDomain* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.SecurityDomain)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_name().empty()) {
        _this->_internal_set_name(from._internal_name());
    }
    if (from._internal_has_security_domain_details()) {
        _this->_internal_mutable_security_domain_details()->::trusted_vault_pb::SecurityDomainDetails::MergeFrom(from._internal_security_domain_details());
    }
    if (from._internal_current_epoch() != 0) {
        _this->_internal_set_current_epoch(from._internal_current_epoch());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SecurityDomain::CopyFrom(const SecurityDomain& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.SecurityDomain)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SecurityDomain::IsInitialized() const
{
    return true;
}

void SecurityDomain::InternalSwap(SecurityDomain* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(SecurityDomain, _impl_.current_epoch_) + sizeof(SecurityDomain::_impl_.current_epoch_)
        - PROTOBUF_FIELD_OFFSET(SecurityDomain, _impl_.security_domain_details_)>(
        reinterpret_cast<char*>(&_impl_.security_domain_details_), reinterpret_cast<char*>(&other->_impl_.security_domain_details_));
}

std::string SecurityDomain::GetTypeName() const
{
    return "trusted_vault_pb.SecurityDomain";
}

// ===================================================================

class Timestamp::_Internal {
public:
};

Timestamp::Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.Timestamp)
}
Timestamp::Timestamp(const Timestamp& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Timestamp* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.seconds_) {}, decltype(_impl_.nanos_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.seconds_, &from._impl_.seconds_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nanos_) - reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.Timestamp)
}

inline void Timestamp::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.seconds_) { int64_t { 0 } }, decltype(_impl_.nanos_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
}

Timestamp::~Timestamp()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.Timestamp)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Timestamp::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Timestamp::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Timestamp::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.Timestamp)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    ::memset(
        &_impl_.seconds_, 0, static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nanos_) - reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
    _internal_metadata_.Clear<std::string>();
}

const char* Timestamp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // int64 seconds = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // int32 nanos = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.nanos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Timestamp::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.Timestamp)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // int64 seconds = 1;
    if (this->_internal_seconds() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seconds(), target);
    }

    // int32 nanos = 2;
    if (this->_internal_nanos() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nanos(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.Timestamp)
    return target;
}

size_t Timestamp::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.Timestamp)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // int64 seconds = 1;
    if (this->_internal_seconds() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seconds());
    }

    // int32 nanos = 2;
    if (this->_internal_nanos() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nanos());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Timestamp::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Timestamp*>(&from));
}

void Timestamp::MergeFrom(const Timestamp& from)
{
    Timestamp* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.Timestamp)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_seconds() != 0) {
        _this->_internal_set_seconds(from._internal_seconds());
    }
    if (from._internal_nanos() != 0) {
        _this->_internal_set_nanos(from._internal_nanos());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Timestamp::CopyFrom(const Timestamp& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.Timestamp)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Timestamp::IsInitialized() const
{
    return true;
}

void Timestamp::InternalSwap(Timestamp* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Timestamp, _impl_.nanos_) + sizeof(Timestamp::_impl_.nanos_)
        - PROTOBUF_FIELD_OFFSET(Timestamp, _impl_.seconds_)>(reinterpret_cast<char*>(&_impl_.seconds_), reinterpret_cast<char*>(&other->_impl_.seconds_));
}

std::string Timestamp::GetTypeName() const
{
    return "trusted_vault_pb.Timestamp";
}

// ===================================================================

class PhysicalDeviceMetadata::_Internal {
public:
};

PhysicalDeviceMetadata::PhysicalDeviceMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.PhysicalDeviceMetadata)
}
PhysicalDeviceMetadata::PhysicalDeviceMetadata(const PhysicalDeviceMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PhysicalDeviceMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.device_type_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.device_type_ = from._impl_.device_type_;
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.PhysicalDeviceMetadata)
}

inline void PhysicalDeviceMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.device_type_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
}

PhysicalDeviceMetadata::~PhysicalDeviceMetadata()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.PhysicalDeviceMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PhysicalDeviceMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PhysicalDeviceMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PhysicalDeviceMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.PhysicalDeviceMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.device_type_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* PhysicalDeviceMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .trusted_vault_pb.PhysicalDeviceMetadata.DeviceType device_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_device_type(static_cast<::trusted_vault_pb::PhysicalDeviceMetadata_DeviceType>(val));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PhysicalDeviceMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.PhysicalDeviceMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .trusted_vault_pb.PhysicalDeviceMetadata.DeviceType device_type = 1;
    if (this->_internal_device_type() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_device_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.PhysicalDeviceMetadata)
    return target;
}

size_t PhysicalDeviceMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.PhysicalDeviceMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // .trusted_vault_pb.PhysicalDeviceMetadata.DeviceType device_type = 1;
    if (this->_internal_device_type() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_device_type());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PhysicalDeviceMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PhysicalDeviceMetadata*>(&from));
}

void PhysicalDeviceMetadata::MergeFrom(const PhysicalDeviceMetadata& from)
{
    PhysicalDeviceMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.PhysicalDeviceMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_device_type() != 0) {
        _this->_internal_set_device_type(from._internal_device_type());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PhysicalDeviceMetadata::CopyFrom(const PhysicalDeviceMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.PhysicalDeviceMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PhysicalDeviceMetadata::IsInitialized() const
{
    return true;
}

void PhysicalDeviceMetadata::InternalSwap(PhysicalDeviceMetadata* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.device_type_, other->_impl_.device_type_);
}

std::string PhysicalDeviceMetadata::GetTypeName() const
{
    return "trusted_vault_pb.PhysicalDeviceMetadata";
}

// ===================================================================

class LskfMetadata::_Internal {
public:
    static const ::trusted_vault_pb::Timestamp& expiration_time(const LskfMetadata* msg);
};

const ::trusted_vault_pb::Timestamp& LskfMetadata::_Internal::expiration_time(const LskfMetadata* msg)
{
    return *msg->_impl_.expiration_time_;
}
LskfMetadata::LskfMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.LskfMetadata)
}
LskfMetadata::LskfMetadata(const LskfMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LskfMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.expiration_time_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_expiration_time()) {
        _this->_impl_.expiration_time_ = new ::trusted_vault_pb::Timestamp(*from._impl_.expiration_time_);
    }
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.LskfMetadata)
}

inline void LskfMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.expiration_time_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };
}

LskfMetadata::~LskfMetadata()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.LskfMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LskfMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.expiration_time_;
}

void LskfMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LskfMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.LskfMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (GetArenaForAllocation() == nullptr && _impl_.expiration_time_ != nullptr) {
        delete _impl_.expiration_time_;
    }
    _impl_.expiration_time_ = nullptr;
    _internal_metadata_.Clear<std::string>();
}

const char* LskfMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .trusted_vault_pb.Timestamp expiration_time = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_expiration_time(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LskfMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.LskfMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .trusted_vault_pb.Timestamp expiration_time = 1;
    if (this->_internal_has_expiration_time()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::expiration_time(this), _Internal::expiration_time(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.LskfMetadata)
    return target;
}

size_t LskfMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.LskfMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // .trusted_vault_pb.Timestamp expiration_time = 1;
    if (this->_internal_has_expiration_time()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.expiration_time_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LskfMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LskfMetadata*>(&from));
}

void LskfMetadata::MergeFrom(const LskfMetadata& from)
{
    LskfMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.LskfMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_expiration_time()) {
        _this->_internal_mutable_expiration_time()->::trusted_vault_pb::Timestamp::MergeFrom(from._internal_expiration_time());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LskfMetadata::CopyFrom(const LskfMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.LskfMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LskfMetadata::IsInitialized() const
{
    return true;
}

void LskfMetadata::InternalSwap(LskfMetadata* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.expiration_time_, other->_impl_.expiration_time_);
}

std::string LskfMetadata::GetTypeName() const
{
    return "trusted_vault_pb.LskfMetadata";
}

// ===================================================================

class GooglePasswordManagerPinMetadata::_Internal {
public:
    static const ::trusted_vault_pb::Timestamp& expiration_time(const GooglePasswordManagerPinMetadata* msg);
};

const ::trusted_vault_pb::Timestamp& GooglePasswordManagerPinMetadata::_Internal::expiration_time(const GooglePasswordManagerPinMetadata* msg)
{
    return *msg->_impl_.expiration_time_;
}
GooglePasswordManagerPinMetadata::GooglePasswordManagerPinMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.GooglePasswordManagerPinMetadata)
}
GooglePasswordManagerPinMetadata::GooglePasswordManagerPinMetadata(const GooglePasswordManagerPinMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GooglePasswordManagerPinMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.encrypted_pin_hash_) {}, decltype(_impl_.expiration_time_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.encrypted_pin_hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encrypted_pin_hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_encrypted_pin_hash().empty()) {
        _this->_impl_.encrypted_pin_hash_.Set(from._internal_encrypted_pin_hash(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_expiration_time()) {
        _this->_impl_.expiration_time_ = new ::trusted_vault_pb::Timestamp(*from._impl_.expiration_time_);
    }
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.GooglePasswordManagerPinMetadata)
}

inline void GooglePasswordManagerPinMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.encrypted_pin_hash_) {}, decltype(_impl_.expiration_time_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.encrypted_pin_hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encrypted_pin_hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GooglePasswordManagerPinMetadata::~GooglePasswordManagerPinMetadata()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.GooglePasswordManagerPinMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GooglePasswordManagerPinMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.encrypted_pin_hash_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.expiration_time_;
}

void GooglePasswordManagerPinMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GooglePasswordManagerPinMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.GooglePasswordManagerPinMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.encrypted_pin_hash_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.expiration_time_ != nullptr) {
        delete _impl_.expiration_time_;
    }
    _impl_.expiration_time_ = nullptr;
    _internal_metadata_.Clear<std::string>();
}

const char* GooglePasswordManagerPinMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .trusted_vault_pb.Timestamp expiration_time = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_expiration_time(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bytes encrypted_pin_hash = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_encrypted_pin_hash();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GooglePasswordManagerPinMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.GooglePasswordManagerPinMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .trusted_vault_pb.Timestamp expiration_time = 1;
    if (this->_internal_has_expiration_time()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::expiration_time(this), _Internal::expiration_time(this).GetCachedSize(), target, stream);
    }

    // bytes encrypted_pin_hash = 2;
    if (!this->_internal_encrypted_pin_hash().empty()) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_encrypted_pin_hash(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.GooglePasswordManagerPinMetadata)
    return target;
}

size_t GooglePasswordManagerPinMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.GooglePasswordManagerPinMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // bytes encrypted_pin_hash = 2;
    if (!this->_internal_encrypted_pin_hash().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_encrypted_pin_hash());
    }

    // .trusted_vault_pb.Timestamp expiration_time = 1;
    if (this->_internal_has_expiration_time()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.expiration_time_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GooglePasswordManagerPinMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GooglePasswordManagerPinMetadata*>(&from));
}

void GooglePasswordManagerPinMetadata::MergeFrom(const GooglePasswordManagerPinMetadata& from)
{
    GooglePasswordManagerPinMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.GooglePasswordManagerPinMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_encrypted_pin_hash().empty()) {
        _this->_internal_set_encrypted_pin_hash(from._internal_encrypted_pin_hash());
    }
    if (from._internal_has_expiration_time()) {
        _this->_internal_mutable_expiration_time()->::trusted_vault_pb::Timestamp::MergeFrom(from._internal_expiration_time());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GooglePasswordManagerPinMetadata::CopyFrom(const GooglePasswordManagerPinMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.GooglePasswordManagerPinMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GooglePasswordManagerPinMetadata::IsInitialized() const
{
    return true;
}

void GooglePasswordManagerPinMetadata::InternalSwap(GooglePasswordManagerPinMetadata* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.encrypted_pin_hash_, lhs_arena, &other->_impl_.encrypted_pin_hash_, rhs_arena);
    swap(_impl_.expiration_time_, other->_impl_.expiration_time_);
}

std::string GooglePasswordManagerPinMetadata::GetTypeName() const
{
    return "trusted_vault_pb.GooglePasswordManagerPinMetadata";
}

// ===================================================================

class SecurityDomainMember_SecurityDomainMembership::_Internal {
public:
};

SecurityDomainMember_SecurityDomainMembership::SecurityDomainMember_SecurityDomainMembership(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership)
}
SecurityDomainMember_SecurityDomainMembership::SecurityDomainMember_SecurityDomainMembership(const SecurityDomainMember_SecurityDomainMembership& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SecurityDomainMember_SecurityDomainMembership* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.keys_) { from._impl_.keys_ }, decltype(_impl_.rotation_proofs_) { from._impl_.rotation_proofs_ },
        decltype(_impl_.security_domain_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.security_domain_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.security_domain_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_security_domain().empty()) {
        _this->_impl_.security_domain_.Set(from._internal_security_domain(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership)
}

inline void SecurityDomainMember_SecurityDomainMembership::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.keys_) { arena }, decltype(_impl_.rotation_proofs_) { arena }, decltype(_impl_.security_domain_) {},
        /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.security_domain_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.security_domain_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SecurityDomainMember_SecurityDomainMembership::~SecurityDomainMember_SecurityDomainMembership()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SecurityDomainMember_SecurityDomainMembership::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.keys_.~RepeatedPtrField();
    _impl_.rotation_proofs_.~RepeatedPtrField();
    _impl_.security_domain_.Destroy();
}

void SecurityDomainMember_SecurityDomainMembership::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SecurityDomainMember_SecurityDomainMembership::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.keys_.Clear();
    _impl_.rotation_proofs_.Clear();
    _impl_.security_domain_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* SecurityDomainMember_SecurityDomainMembership::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string security_domain = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_security_domain();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .trusted_vault_pb.SharedMemberKey keys = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_keys(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .trusted_vault_pb.RotationProof rotation_proofs = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_rotation_proofs(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SecurityDomainMember_SecurityDomainMembership::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string security_domain = 1;
    if (!this->_internal_security_domain().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_security_domain().data(),
            static_cast<int>(this->_internal_security_domain().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.security_domain");
        target = stream->WriteStringMaybeAliased(1, this->_internal_security_domain(), target);
    }

    // repeated .trusted_vault_pb.SharedMemberKey keys = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_keys_size()); i < n; i++) {
        const auto& repfield = this->_internal_keys(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .trusted_vault_pb.RotationProof rotation_proofs = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_rotation_proofs_size()); i < n; i++) {
        const auto& repfield = this->_internal_rotation_proofs(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership)
    return target;
}

size_t SecurityDomainMember_SecurityDomainMembership::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .trusted_vault_pb.SharedMemberKey keys = 3;
    total_size += 1UL * this->_internal_keys_size();
    for (const auto& msg : this->_impl_.keys_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .trusted_vault_pb.RotationProof rotation_proofs = 4;
    total_size += 1UL * this->_internal_rotation_proofs_size();
    for (const auto& msg : this->_impl_.rotation_proofs_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // string security_domain = 1;
    if (!this->_internal_security_domain().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_security_domain());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SecurityDomainMember_SecurityDomainMembership::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SecurityDomainMember_SecurityDomainMembership*>(&from));
}

void SecurityDomainMember_SecurityDomainMembership::MergeFrom(const SecurityDomainMember_SecurityDomainMembership& from)
{
    SecurityDomainMember_SecurityDomainMembership* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.keys_.MergeFrom(from._impl_.keys_);
    _this->_impl_.rotation_proofs_.MergeFrom(from._impl_.rotation_proofs_);
    if (!from._internal_security_domain().empty()) {
        _this->_internal_set_security_domain(from._internal_security_domain());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SecurityDomainMember_SecurityDomainMembership::CopyFrom(const SecurityDomainMember_SecurityDomainMembership& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SecurityDomainMember_SecurityDomainMembership::IsInitialized() const
{
    return true;
}

void SecurityDomainMember_SecurityDomainMembership::InternalSwap(SecurityDomainMember_SecurityDomainMembership* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.keys_.InternalSwap(&other->_impl_.keys_);
    _impl_.rotation_proofs_.InternalSwap(&other->_impl_.rotation_proofs_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.security_domain_, lhs_arena, &other->_impl_.security_domain_, rhs_arena);
}

std::string SecurityDomainMember_SecurityDomainMembership::GetTypeName() const
{
    return "trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership";
}

// ===================================================================

class SecurityDomainMember_MemberMetadata::_Internal {
public:
    static const ::trusted_vault_pb::PhysicalDeviceMetadata& physical_device_metadata(const SecurityDomainMember_MemberMetadata* msg);
    static const ::trusted_vault_pb::LskfMetadata& lskf_metadata(const SecurityDomainMember_MemberMetadata* msg);
    static const ::trusted_vault_pb::GooglePasswordManagerPinMetadata& google_password_manager_pin_metadata(const SecurityDomainMember_MemberMetadata* msg);
};

const ::trusted_vault_pb::PhysicalDeviceMetadata& SecurityDomainMember_MemberMetadata::_Internal::physical_device_metadata(
    const SecurityDomainMember_MemberMetadata* msg)
{
    return *msg->_impl_.member_metadata_variant_.physical_device_metadata_;
}
const ::trusted_vault_pb::LskfMetadata& SecurityDomainMember_MemberMetadata::_Internal::lskf_metadata(const SecurityDomainMember_MemberMetadata* msg)
{
    return *msg->_impl_.member_metadata_variant_.lskf_metadata_;
}
const ::trusted_vault_pb::GooglePasswordManagerPinMetadata& SecurityDomainMember_MemberMetadata::_Internal::google_password_manager_pin_metadata(
    const SecurityDomainMember_MemberMetadata* msg)
{
    return *msg->_impl_.member_metadata_variant_.google_password_manager_pin_metadata_;
}
void SecurityDomainMember_MemberMetadata::set_allocated_physical_device_metadata(::trusted_vault_pb::PhysicalDeviceMetadata* physical_device_metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_member_metadata_variant();
    if (physical_device_metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(physical_device_metadata);
        if (message_arena != submessage_arena) {
            physical_device_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, physical_device_metadata, submessage_arena);
        }
        set_has_physical_device_metadata();
        _impl_.member_metadata_variant_.physical_device_metadata_ = physical_device_metadata;
    }
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.SecurityDomainMember.MemberMetadata.physical_device_metadata)
}
void SecurityDomainMember_MemberMetadata::set_allocated_lskf_metadata(::trusted_vault_pb::LskfMetadata* lskf_metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_member_metadata_variant();
    if (lskf_metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lskf_metadata);
        if (message_arena != submessage_arena) {
            lskf_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, lskf_metadata, submessage_arena);
        }
        set_has_lskf_metadata();
        _impl_.member_metadata_variant_.lskf_metadata_ = lskf_metadata;
    }
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.SecurityDomainMember.MemberMetadata.lskf_metadata)
}
void SecurityDomainMember_MemberMetadata::set_allocated_google_password_manager_pin_metadata(
    ::trusted_vault_pb::GooglePasswordManagerPinMetadata* google_password_manager_pin_metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_member_metadata_variant();
    if (google_password_manager_pin_metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(google_password_manager_pin_metadata);
        if (message_arena != submessage_arena) {
            google_password_manager_pin_metadata
                = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, google_password_manager_pin_metadata, submessage_arena);
        }
        set_has_google_password_manager_pin_metadata();
        _impl_.member_metadata_variant_.google_password_manager_pin_metadata_ = google_password_manager_pin_metadata;
    }
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.SecurityDomainMember.MemberMetadata.google_password_manager_pin_metadata)
}
SecurityDomainMember_MemberMetadata::SecurityDomainMember_MemberMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.SecurityDomainMember.MemberMetadata)
}
SecurityDomainMember_MemberMetadata::SecurityDomainMember_MemberMetadata(const SecurityDomainMember_MemberMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SecurityDomainMember_MemberMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.usable_for_retrieval_) {}, decltype(_impl_.member_metadata_variant_) {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.usable_for_retrieval_ = from._impl_.usable_for_retrieval_;
    clear_has_member_metadata_variant();
    switch (from.member_metadata_variant_case()) {
    case kPhysicalDeviceMetadata: {
        _this->_internal_mutable_physical_device_metadata()->::trusted_vault_pb::PhysicalDeviceMetadata::MergeFrom(from._internal_physical_device_metadata());
        break;
    }
    case kLskfMetadata: {
        _this->_internal_mutable_lskf_metadata()->::trusted_vault_pb::LskfMetadata::MergeFrom(from._internal_lskf_metadata());
        break;
    }
    case kGooglePasswordManagerPinMetadata: {
        _this->_internal_mutable_google_password_manager_pin_metadata()->::trusted_vault_pb::GooglePasswordManagerPinMetadata::MergeFrom(
            from._internal_google_password_manager_pin_metadata());
        break;
    }
    case MEMBER_METADATA_VARIANT_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.SecurityDomainMember.MemberMetadata)
}

inline void SecurityDomainMember_MemberMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.usable_for_retrieval_) { false }, decltype(_impl_.member_metadata_variant_) {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_member_metadata_variant();
}

SecurityDomainMember_MemberMetadata::~SecurityDomainMember_MemberMetadata()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.SecurityDomainMember.MemberMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SecurityDomainMember_MemberMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_member_metadata_variant()) {
        clear_member_metadata_variant();
    }
}

void SecurityDomainMember_MemberMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SecurityDomainMember_MemberMetadata::clear_member_metadata_variant()
{
    // @@protoc_insertion_point(one_of_clear_start:trusted_vault_pb.SecurityDomainMember.MemberMetadata)
    switch (member_metadata_variant_case()) {
    case kPhysicalDeviceMetadata: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.member_metadata_variant_.physical_device_metadata_;
        }
        break;
    }
    case kLskfMetadata: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.member_metadata_variant_.lskf_metadata_;
        }
        break;
    }
    case kGooglePasswordManagerPinMetadata: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.member_metadata_variant_.google_password_manager_pin_metadata_;
        }
        break;
    }
    case MEMBER_METADATA_VARIANT_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = MEMBER_METADATA_VARIANT_NOT_SET;
}

void SecurityDomainMember_MemberMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.SecurityDomainMember.MemberMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.usable_for_retrieval_ = false;
    clear_member_metadata_variant();
    _internal_metadata_.Clear<std::string>();
}

const char* SecurityDomainMember_MemberMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // bool usable_for_retrieval = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.usable_for_retrieval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .trusted_vault_pb.PhysicalDeviceMetadata physical_device_metadata = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_physical_device_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .trusted_vault_pb.LskfMetadata lskf_metadata = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_lskf_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .trusted_vault_pb.GooglePasswordManagerPinMetadata google_password_manager_pin_metadata = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_google_password_manager_pin_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SecurityDomainMember_MemberMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.SecurityDomainMember.MemberMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // bool usable_for_retrieval = 1;
    if (this->_internal_usable_for_retrieval() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_usable_for_retrieval(), target);
    }

    // .trusted_vault_pb.PhysicalDeviceMetadata physical_device_metadata = 3;
    if (_internal_has_physical_device_metadata()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::physical_device_metadata(this), _Internal::physical_device_metadata(this).GetCachedSize(), target, stream);
    }

    // .trusted_vault_pb.LskfMetadata lskf_metadata = 4;
    if (_internal_has_lskf_metadata()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::lskf_metadata(this), _Internal::lskf_metadata(this).GetCachedSize(), target, stream);
    }

    // .trusted_vault_pb.GooglePasswordManagerPinMetadata google_password_manager_pin_metadata = 5;
    if (_internal_has_google_password_manager_pin_metadata()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::google_password_manager_pin_metadata(this), _Internal::google_password_manager_pin_metadata(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.SecurityDomainMember.MemberMetadata)
    return target;
}

size_t SecurityDomainMember_MemberMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.SecurityDomainMember.MemberMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // bool usable_for_retrieval = 1;
    if (this->_internal_usable_for_retrieval() != 0) {
        total_size += 1 + 1;
    }

    switch (member_metadata_variant_case()) {
    // .trusted_vault_pb.PhysicalDeviceMetadata physical_device_metadata = 3;
    case kPhysicalDeviceMetadata: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.member_metadata_variant_.physical_device_metadata_);
        break;
    }
    // .trusted_vault_pb.LskfMetadata lskf_metadata = 4;
    case kLskfMetadata: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.member_metadata_variant_.lskf_metadata_);
        break;
    }
    // .trusted_vault_pb.GooglePasswordManagerPinMetadata google_password_manager_pin_metadata = 5;
    case kGooglePasswordManagerPinMetadata: {
        total_size
            += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.member_metadata_variant_.google_password_manager_pin_metadata_);
        break;
    }
    case MEMBER_METADATA_VARIANT_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SecurityDomainMember_MemberMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SecurityDomainMember_MemberMetadata*>(&from));
}

void SecurityDomainMember_MemberMetadata::MergeFrom(const SecurityDomainMember_MemberMetadata& from)
{
    SecurityDomainMember_MemberMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.SecurityDomainMember.MemberMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_usable_for_retrieval() != 0) {
        _this->_internal_set_usable_for_retrieval(from._internal_usable_for_retrieval());
    }
    switch (from.member_metadata_variant_case()) {
    case kPhysicalDeviceMetadata: {
        _this->_internal_mutable_physical_device_metadata()->::trusted_vault_pb::PhysicalDeviceMetadata::MergeFrom(from._internal_physical_device_metadata());
        break;
    }
    case kLskfMetadata: {
        _this->_internal_mutable_lskf_metadata()->::trusted_vault_pb::LskfMetadata::MergeFrom(from._internal_lskf_metadata());
        break;
    }
    case kGooglePasswordManagerPinMetadata: {
        _this->_internal_mutable_google_password_manager_pin_metadata()->::trusted_vault_pb::GooglePasswordManagerPinMetadata::MergeFrom(
            from._internal_google_password_manager_pin_metadata());
        break;
    }
    case MEMBER_METADATA_VARIANT_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SecurityDomainMember_MemberMetadata::CopyFrom(const SecurityDomainMember_MemberMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.SecurityDomainMember.MemberMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SecurityDomainMember_MemberMetadata::IsInitialized() const
{
    return true;
}

void SecurityDomainMember_MemberMetadata::InternalSwap(SecurityDomainMember_MemberMetadata* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.usable_for_retrieval_, other->_impl_.usable_for_retrieval_);
    swap(_impl_.member_metadata_variant_, other->_impl_.member_metadata_variant_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string SecurityDomainMember_MemberMetadata::GetTypeName() const
{
    return "trusted_vault_pb.SecurityDomainMember.MemberMetadata";
}

// ===================================================================

class SecurityDomainMember::_Internal {
public:
    static const ::trusted_vault_pb::SecurityDomainMember_MemberMetadata& member_metadata(const SecurityDomainMember* msg);
};

const ::trusted_vault_pb::SecurityDomainMember_MemberMetadata& SecurityDomainMember::_Internal::member_metadata(const SecurityDomainMember* msg)
{
    return *msg->_impl_.member_metadata_;
}
SecurityDomainMember::SecurityDomainMember(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.SecurityDomainMember)
}
SecurityDomainMember::SecurityDomainMember(const SecurityDomainMember& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SecurityDomainMember* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.memberships_) { from._impl_.memberships_ }, decltype(_impl_.name_) {}, decltype(_impl_.public_key_) {},
        decltype(_impl_.member_metadata_) { nullptr }, decltype(_impl_.member_type_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_name().empty()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.public_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_public_key().empty()) {
        _this->_impl_.public_key_.Set(from._internal_public_key(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_member_metadata()) {
        _this->_impl_.member_metadata_ = new ::trusted_vault_pb::SecurityDomainMember_MemberMetadata(*from._impl_.member_metadata_);
    }
    _this->_impl_.member_type_ = from._impl_.member_type_;
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.SecurityDomainMember)
}

inline void SecurityDomainMember::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.memberships_) { arena }, decltype(_impl_.name_) {}, decltype(_impl_.public_key_) {},
        decltype(_impl_.member_metadata_) { nullptr }, decltype(_impl_.member_type_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SecurityDomainMember::~SecurityDomainMember()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.SecurityDomainMember)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SecurityDomainMember::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.memberships_.~RepeatedPtrField();
    _impl_.name_.Destroy();
    _impl_.public_key_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.member_metadata_;
}

void SecurityDomainMember::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SecurityDomainMember::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.SecurityDomainMember)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.memberships_.Clear();
    _impl_.name_.ClearToEmpty();
    _impl_.public_key_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.member_metadata_ != nullptr) {
        delete _impl_.member_metadata_;
    }
    _impl_.member_metadata_ = nullptr;
    _impl_.member_type_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* SecurityDomainMember::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // bytes public_key = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_public_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership memberships = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_memberships(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // .trusted_vault_pb.SecurityDomainMember.MemberType member_type = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_member_type(static_cast<::trusted_vault_pb::SecurityDomainMember_MemberType>(val));
            } else
                goto handle_unusual;
            continue;
        // .trusted_vault_pb.SecurityDomainMember.MemberMetadata member_metadata = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_member_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SecurityDomainMember::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.SecurityDomainMember)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string name = 1;
    if (!this->_internal_name().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "trusted_vault_pb.SecurityDomainMember.name");
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // bytes public_key = 2;
    if (!this->_internal_public_key().empty()) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_public_key(), target);
    }

    // repeated .trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership memberships = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_memberships_size()); i < n; i++) {
        const auto& repfield = this->_internal_memberships(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // .trusted_vault_pb.SecurityDomainMember.MemberType member_type = 4;
    if (this->_internal_member_type() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_member_type(), target);
    }

    // .trusted_vault_pb.SecurityDomainMember.MemberMetadata member_metadata = 6;
    if (this->_internal_has_member_metadata()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::member_metadata(this), _Internal::member_metadata(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.SecurityDomainMember)
    return target;
}

size_t SecurityDomainMember::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.SecurityDomainMember)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership memberships = 3;
    total_size += 1UL * this->_internal_memberships_size();
    for (const auto& msg : this->_impl_.memberships_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // string name = 1;
    if (!this->_internal_name().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
    }

    // bytes public_key = 2;
    if (!this->_internal_public_key().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_public_key());
    }

    // .trusted_vault_pb.SecurityDomainMember.MemberMetadata member_metadata = 6;
    if (this->_internal_has_member_metadata()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.member_metadata_);
    }

    // .trusted_vault_pb.SecurityDomainMember.MemberType member_type = 4;
    if (this->_internal_member_type() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_member_type());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SecurityDomainMember::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SecurityDomainMember*>(&from));
}

void SecurityDomainMember::MergeFrom(const SecurityDomainMember& from)
{
    SecurityDomainMember* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.SecurityDomainMember)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.memberships_.MergeFrom(from._impl_.memberships_);
    if (!from._internal_name().empty()) {
        _this->_internal_set_name(from._internal_name());
    }
    if (!from._internal_public_key().empty()) {
        _this->_internal_set_public_key(from._internal_public_key());
    }
    if (from._internal_has_member_metadata()) {
        _this->_internal_mutable_member_metadata()->::trusted_vault_pb::SecurityDomainMember_MemberMetadata::MergeFrom(from._internal_member_metadata());
    }
    if (from._internal_member_type() != 0) {
        _this->_internal_set_member_type(from._internal_member_type());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SecurityDomainMember::CopyFrom(const SecurityDomainMember& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.SecurityDomainMember)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SecurityDomainMember::IsInitialized() const
{
    return true;
}

void SecurityDomainMember::InternalSwap(SecurityDomainMember* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.memberships_.InternalSwap(&other->_impl_.memberships_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.public_key_, lhs_arena, &other->_impl_.public_key_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(SecurityDomainMember, _impl_.member_type_)
        + sizeof(SecurityDomainMember::_impl_.member_type_) - PROTOBUF_FIELD_OFFSET(SecurityDomainMember, _impl_.member_metadata_)>(
        reinterpret_cast<char*>(&_impl_.member_metadata_), reinterpret_cast<char*>(&other->_impl_.member_metadata_));
}

std::string SecurityDomainMember::GetTypeName() const
{
    return "trusted_vault_pb.SecurityDomainMember";
}

// ===================================================================

class JoinSecurityDomainsRequest::_Internal {
public:
    static const ::trusted_vault_pb::SecurityDomain& security_domain(const JoinSecurityDomainsRequest* msg);
    static const ::trusted_vault_pb::SecurityDomainMember& security_domain_member(const JoinSecurityDomainsRequest* msg);
};

const ::trusted_vault_pb::SecurityDomain& JoinSecurityDomainsRequest::_Internal::security_domain(const JoinSecurityDomainsRequest* msg)
{
    return *msg->_impl_.security_domain_;
}
const ::trusted_vault_pb::SecurityDomainMember& JoinSecurityDomainsRequest::_Internal::security_domain_member(const JoinSecurityDomainsRequest* msg)
{
    return *msg->_impl_.security_domain_member_;
}
JoinSecurityDomainsRequest::JoinSecurityDomainsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.JoinSecurityDomainsRequest)
}
JoinSecurityDomainsRequest::JoinSecurityDomainsRequest(const JoinSecurityDomainsRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    JoinSecurityDomainsRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.shared_member_key_) { from._impl_.shared_member_key_ }, decltype(_impl_.current_public_key_to_replace_) {},
        decltype(_impl_.security_domain_) { nullptr }, decltype(_impl_.security_domain_member_) { nullptr }, decltype(_impl_.member_type_hint_) {},
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.current_public_key_to_replace_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_public_key_to_replace_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_current_public_key_to_replace().empty()) {
        _this->_impl_.current_public_key_to_replace_.Set(from._internal_current_public_key_to_replace(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_security_domain()) {
        _this->_impl_.security_domain_ = new ::trusted_vault_pb::SecurityDomain(*from._impl_.security_domain_);
    }
    if (from._internal_has_security_domain_member()) {
        _this->_impl_.security_domain_member_ = new ::trusted_vault_pb::SecurityDomainMember(*from._impl_.security_domain_member_);
    }
    _this->_impl_.member_type_hint_ = from._impl_.member_type_hint_;
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.JoinSecurityDomainsRequest)
}

inline void JoinSecurityDomainsRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.shared_member_key_) { arena }, decltype(_impl_.current_public_key_to_replace_) {},
        decltype(_impl_.security_domain_) { nullptr }, decltype(_impl_.security_domain_member_) { nullptr }, decltype(_impl_.member_type_hint_) { 0 },
        /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.current_public_key_to_replace_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_public_key_to_replace_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

JoinSecurityDomainsRequest::~JoinSecurityDomainsRequest()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.JoinSecurityDomainsRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void JoinSecurityDomainsRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.shared_member_key_.~RepeatedPtrField();
    _impl_.current_public_key_to_replace_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.security_domain_;
    if (this != internal_default_instance())
        delete _impl_.security_domain_member_;
}

void JoinSecurityDomainsRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void JoinSecurityDomainsRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.JoinSecurityDomainsRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.shared_member_key_.Clear();
    _impl_.current_public_key_to_replace_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.security_domain_ != nullptr) {
        delete _impl_.security_domain_;
    }
    _impl_.security_domain_ = nullptr;
    if (GetArenaForAllocation() == nullptr && _impl_.security_domain_member_ != nullptr) {
        delete _impl_.security_domain_member_;
    }
    _impl_.security_domain_member_ = nullptr;
    _impl_.member_type_hint_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* JoinSecurityDomainsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .trusted_vault_pb.SecurityDomain security_domain = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_security_domain(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .trusted_vault_pb.SecurityDomainMember security_domain_member = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_security_domain_member(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .trusted_vault_pb.SharedMemberKey shared_member_key = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_shared_member_key(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // int32 member_type_hint = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _impl_.member_type_hint_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bytes current_public_key_to_replace = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_current_public_key_to_replace();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* JoinSecurityDomainsRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.JoinSecurityDomainsRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .trusted_vault_pb.SecurityDomain security_domain = 1;
    if (this->_internal_has_security_domain()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::security_domain(this), _Internal::security_domain(this).GetCachedSize(), target, stream);
    }

    // .trusted_vault_pb.SecurityDomainMember security_domain_member = 2;
    if (this->_internal_has_security_domain_member()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::security_domain_member(this), _Internal::security_domain_member(this).GetCachedSize(), target, stream);
    }

    // repeated .trusted_vault_pb.SharedMemberKey shared_member_key = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_shared_member_key_size()); i < n; i++) {
        const auto& repfield = this->_internal_shared_member_key(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // int32 member_type_hint = 4;
    if (this->_internal_member_type_hint() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_member_type_hint(), target);
    }

    // bytes current_public_key_to_replace = 5;
    if (!this->_internal_current_public_key_to_replace().empty()) {
        target = stream->WriteBytesMaybeAliased(5, this->_internal_current_public_key_to_replace(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.JoinSecurityDomainsRequest)
    return target;
}

size_t JoinSecurityDomainsRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.JoinSecurityDomainsRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .trusted_vault_pb.SharedMemberKey shared_member_key = 3;
    total_size += 1UL * this->_internal_shared_member_key_size();
    for (const auto& msg : this->_impl_.shared_member_key_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // bytes current_public_key_to_replace = 5;
    if (!this->_internal_current_public_key_to_replace().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_current_public_key_to_replace());
    }

    // .trusted_vault_pb.SecurityDomain security_domain = 1;
    if (this->_internal_has_security_domain()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.security_domain_);
    }

    // .trusted_vault_pb.SecurityDomainMember security_domain_member = 2;
    if (this->_internal_has_security_domain_member()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.security_domain_member_);
    }

    // int32 member_type_hint = 4;
    if (this->_internal_member_type_hint() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_member_type_hint());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void JoinSecurityDomainsRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const JoinSecurityDomainsRequest*>(&from));
}

void JoinSecurityDomainsRequest::MergeFrom(const JoinSecurityDomainsRequest& from)
{
    JoinSecurityDomainsRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.JoinSecurityDomainsRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.shared_member_key_.MergeFrom(from._impl_.shared_member_key_);
    if (!from._internal_current_public_key_to_replace().empty()) {
        _this->_internal_set_current_public_key_to_replace(from._internal_current_public_key_to_replace());
    }
    if (from._internal_has_security_domain()) {
        _this->_internal_mutable_security_domain()->::trusted_vault_pb::SecurityDomain::MergeFrom(from._internal_security_domain());
    }
    if (from._internal_has_security_domain_member()) {
        _this->_internal_mutable_security_domain_member()->::trusted_vault_pb::SecurityDomainMember::MergeFrom(from._internal_security_domain_member());
    }
    if (from._internal_member_type_hint() != 0) {
        _this->_internal_set_member_type_hint(from._internal_member_type_hint());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void JoinSecurityDomainsRequest::CopyFrom(const JoinSecurityDomainsRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.JoinSecurityDomainsRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool JoinSecurityDomainsRequest::IsInitialized() const
{
    return true;
}

void JoinSecurityDomainsRequest::InternalSwap(JoinSecurityDomainsRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.shared_member_key_.InternalSwap(&other->_impl_.shared_member_key_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.current_public_key_to_replace_, lhs_arena, &other->_impl_.current_public_key_to_replace_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(JoinSecurityDomainsRequest, _impl_.member_type_hint_)
        + sizeof(JoinSecurityDomainsRequest::_impl_.member_type_hint_) - PROTOBUF_FIELD_OFFSET(JoinSecurityDomainsRequest, _impl_.security_domain_)>(
        reinterpret_cast<char*>(&_impl_.security_domain_), reinterpret_cast<char*>(&other->_impl_.security_domain_));
}

std::string JoinSecurityDomainsRequest::GetTypeName() const
{
    return "trusted_vault_pb.JoinSecurityDomainsRequest";
}

// ===================================================================

class JoinSecurityDomainsResponse::_Internal {
public:
    static const ::trusted_vault_pb::SecurityDomain& security_domain(const JoinSecurityDomainsResponse* msg);
};

const ::trusted_vault_pb::SecurityDomain& JoinSecurityDomainsResponse::_Internal::security_domain(const JoinSecurityDomainsResponse* msg)
{
    return *msg->_impl_.security_domain_;
}
JoinSecurityDomainsResponse::JoinSecurityDomainsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.JoinSecurityDomainsResponse)
}
JoinSecurityDomainsResponse::JoinSecurityDomainsResponse(const JoinSecurityDomainsResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    JoinSecurityDomainsResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.security_domain_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_security_domain()) {
        _this->_impl_.security_domain_ = new ::trusted_vault_pb::SecurityDomain(*from._impl_.security_domain_);
    }
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.JoinSecurityDomainsResponse)
}

inline void JoinSecurityDomainsResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.security_domain_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };
}

JoinSecurityDomainsResponse::~JoinSecurityDomainsResponse()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.JoinSecurityDomainsResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void JoinSecurityDomainsResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.security_domain_;
}

void JoinSecurityDomainsResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void JoinSecurityDomainsResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.JoinSecurityDomainsResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (GetArenaForAllocation() == nullptr && _impl_.security_domain_ != nullptr) {
        delete _impl_.security_domain_;
    }
    _impl_.security_domain_ = nullptr;
    _internal_metadata_.Clear<std::string>();
}

const char* JoinSecurityDomainsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .trusted_vault_pb.SecurityDomain security_domain = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_security_domain(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* JoinSecurityDomainsResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.JoinSecurityDomainsResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .trusted_vault_pb.SecurityDomain security_domain = 1;
    if (this->_internal_has_security_domain()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::security_domain(this), _Internal::security_domain(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.JoinSecurityDomainsResponse)
    return target;
}

size_t JoinSecurityDomainsResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.JoinSecurityDomainsResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // .trusted_vault_pb.SecurityDomain security_domain = 1;
    if (this->_internal_has_security_domain()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.security_domain_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void JoinSecurityDomainsResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const JoinSecurityDomainsResponse*>(&from));
}

void JoinSecurityDomainsResponse::MergeFrom(const JoinSecurityDomainsResponse& from)
{
    JoinSecurityDomainsResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.JoinSecurityDomainsResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_security_domain()) {
        _this->_internal_mutable_security_domain()->::trusted_vault_pb::SecurityDomain::MergeFrom(from._internal_security_domain());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void JoinSecurityDomainsResponse::CopyFrom(const JoinSecurityDomainsResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.JoinSecurityDomainsResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool JoinSecurityDomainsResponse::IsInitialized() const
{
    return true;
}

void JoinSecurityDomainsResponse::InternalSwap(JoinSecurityDomainsResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.security_domain_, other->_impl_.security_domain_);
}

std::string JoinSecurityDomainsResponse::GetTypeName() const
{
    return "trusted_vault_pb.JoinSecurityDomainsResponse";
}

// ===================================================================

class JoinSecurityDomainsErrorDetail::_Internal {
public:
    static const ::trusted_vault_pb::JoinSecurityDomainsResponse& already_exists_response(const JoinSecurityDomainsErrorDetail* msg);
};

const ::trusted_vault_pb::JoinSecurityDomainsResponse& JoinSecurityDomainsErrorDetail::_Internal::already_exists_response(
    const JoinSecurityDomainsErrorDetail* msg)
{
    return *msg->_impl_.already_exists_response_;
}
JoinSecurityDomainsErrorDetail::JoinSecurityDomainsErrorDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.JoinSecurityDomainsErrorDetail)
}
JoinSecurityDomainsErrorDetail::JoinSecurityDomainsErrorDetail(const JoinSecurityDomainsErrorDetail& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    JoinSecurityDomainsErrorDetail* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.already_exists_response_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_already_exists_response()) {
        _this->_impl_.already_exists_response_ = new ::trusted_vault_pb::JoinSecurityDomainsResponse(*from._impl_.already_exists_response_);
    }
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.JoinSecurityDomainsErrorDetail)
}

inline void JoinSecurityDomainsErrorDetail::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.already_exists_response_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };
}

JoinSecurityDomainsErrorDetail::~JoinSecurityDomainsErrorDetail()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.JoinSecurityDomainsErrorDetail)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void JoinSecurityDomainsErrorDetail::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.already_exists_response_;
}

void JoinSecurityDomainsErrorDetail::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void JoinSecurityDomainsErrorDetail::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.JoinSecurityDomainsErrorDetail)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (GetArenaForAllocation() == nullptr && _impl_.already_exists_response_ != nullptr) {
        delete _impl_.already_exists_response_;
    }
    _impl_.already_exists_response_ = nullptr;
    _internal_metadata_.Clear<std::string>();
}

const char* JoinSecurityDomainsErrorDetail::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .trusted_vault_pb.JoinSecurityDomainsResponse already_exists_response = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_already_exists_response(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* JoinSecurityDomainsErrorDetail::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.JoinSecurityDomainsErrorDetail)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .trusted_vault_pb.JoinSecurityDomainsResponse already_exists_response = 1;
    if (this->_internal_has_already_exists_response()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::already_exists_response(this), _Internal::already_exists_response(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.JoinSecurityDomainsErrorDetail)
    return target;
}

size_t JoinSecurityDomainsErrorDetail::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.JoinSecurityDomainsErrorDetail)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // .trusted_vault_pb.JoinSecurityDomainsResponse already_exists_response = 1;
    if (this->_internal_has_already_exists_response()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.already_exists_response_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void JoinSecurityDomainsErrorDetail::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const JoinSecurityDomainsErrorDetail*>(&from));
}

void JoinSecurityDomainsErrorDetail::MergeFrom(const JoinSecurityDomainsErrorDetail& from)
{
    JoinSecurityDomainsErrorDetail* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.JoinSecurityDomainsErrorDetail)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_already_exists_response()) {
        _this->_internal_mutable_already_exists_response()->::trusted_vault_pb::JoinSecurityDomainsResponse::MergeFrom(
            from._internal_already_exists_response());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void JoinSecurityDomainsErrorDetail::CopyFrom(const JoinSecurityDomainsErrorDetail& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.JoinSecurityDomainsErrorDetail)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool JoinSecurityDomainsErrorDetail::IsInitialized() const
{
    return true;
}

void JoinSecurityDomainsErrorDetail::InternalSwap(JoinSecurityDomainsErrorDetail* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.already_exists_response_, other->_impl_.already_exists_response_);
}

std::string JoinSecurityDomainsErrorDetail::GetTypeName() const
{
    return "trusted_vault_pb.JoinSecurityDomainsErrorDetail";
}

// ===================================================================

class ListSecurityDomainMembersResponse::_Internal {
public:
};

ListSecurityDomainMembersResponse::ListSecurityDomainMembersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.ListSecurityDomainMembersResponse)
}
ListSecurityDomainMembersResponse::ListSecurityDomainMembersResponse(const ListSecurityDomainMembersResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ListSecurityDomainMembersResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.security_domain_members_) { from._impl_.security_domain_members_ }, decltype(_impl_.next_page_token_) {},
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.next_page_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_next_page_token().empty()) {
        _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.ListSecurityDomainMembersResponse)
}

inline void ListSecurityDomainMembersResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.security_domain_members_) { arena }, decltype(_impl_.next_page_token_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.next_page_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ListSecurityDomainMembersResponse::~ListSecurityDomainMembersResponse()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.ListSecurityDomainMembersResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ListSecurityDomainMembersResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.security_domain_members_.~RepeatedPtrField();
    _impl_.next_page_token_.Destroy();
}

void ListSecurityDomainMembersResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ListSecurityDomainMembersResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.ListSecurityDomainMembersResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.security_domain_members_.Clear();
    _impl_.next_page_token_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* ListSecurityDomainMembersResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .trusted_vault_pb.SecurityDomainMember security_domain_members = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_security_domain_members(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // string next_page_token = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_next_page_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ListSecurityDomainMembersResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.ListSecurityDomainMembersResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .trusted_vault_pb.SecurityDomainMember security_domain_members = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_security_domain_members_size()); i < n; i++) {
        const auto& repfield = this->_internal_security_domain_members(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    // string next_page_token = 2;
    if (!this->_internal_next_page_token().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_next_page_token().data(),
            static_cast<int>(this->_internal_next_page_token().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "trusted_vault_pb.ListSecurityDomainMembersResponse.next_page_token");
        target = stream->WriteStringMaybeAliased(2, this->_internal_next_page_token(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.ListSecurityDomainMembersResponse)
    return target;
}

size_t ListSecurityDomainMembersResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.ListSecurityDomainMembersResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .trusted_vault_pb.SecurityDomainMember security_domain_members = 1;
    total_size += 1UL * this->_internal_security_domain_members_size();
    for (const auto& msg : this->_impl_.security_domain_members_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // string next_page_token = 2;
    if (!this->_internal_next_page_token().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_next_page_token());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ListSecurityDomainMembersResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ListSecurityDomainMembersResponse*>(&from));
}

void ListSecurityDomainMembersResponse::MergeFrom(const ListSecurityDomainMembersResponse& from)
{
    ListSecurityDomainMembersResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.ListSecurityDomainMembersResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.security_domain_members_.MergeFrom(from._impl_.security_domain_members_);
    if (!from._internal_next_page_token().empty()) {
        _this->_internal_set_next_page_token(from._internal_next_page_token());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ListSecurityDomainMembersResponse::CopyFrom(const ListSecurityDomainMembersResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.ListSecurityDomainMembersResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ListSecurityDomainMembersResponse::IsInitialized() const
{
    return true;
}

void ListSecurityDomainMembersResponse::InternalSwap(ListSecurityDomainMembersResponse* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.security_domain_members_.InternalSwap(&other->_impl_.security_domain_members_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.next_page_token_, lhs_arena, &other->_impl_.next_page_token_, rhs_arena);
}

std::string ListSecurityDomainMembersResponse::GetTypeName() const
{
    return "trusted_vault_pb.ListSecurityDomainMembersResponse";
}

// ===================================================================

class Proto3Any::_Internal {
public:
};

Proto3Any::Proto3Any(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.Proto3Any)
}
Proto3Any::Proto3Any(const Proto3Any& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Proto3Any* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.type_url_) {}, decltype(_impl_.value_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.type_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_type_url().empty()) {
        _this->_impl_.type_url_.Set(from._internal_type_url(), _this->GetArenaForAllocation());
    }
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_value().empty()) {
        _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.Proto3Any)
}

inline void Proto3Any::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.type_url_) {}, decltype(_impl_.value_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.type_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.type_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Proto3Any::~Proto3Any()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.Proto3Any)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Proto3Any::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.type_url_.Destroy();
    _impl_.value_.Destroy();
}

void Proto3Any::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Proto3Any::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.Proto3Any)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.type_url_.ClearToEmpty();
    _impl_.value_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* Proto3Any::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string type_url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_type_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // bytes value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Proto3Any::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.Proto3Any)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string type_url = 1;
    if (!this->_internal_type_url().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_type_url().data(),
            static_cast<int>(this->_internal_type_url().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "trusted_vault_pb.Proto3Any.type_url");
        target = stream->WriteStringMaybeAliased(1, this->_internal_type_url(), target);
    }

    // bytes value = 2;
    if (!this->_internal_value().empty()) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_value(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.Proto3Any)
    return target;
}

size_t Proto3Any::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.Proto3Any)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string type_url = 1;
    if (!this->_internal_type_url().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_type_url());
    }

    // bytes value = 2;
    if (!this->_internal_value().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_value());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Proto3Any::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Proto3Any*>(&from));
}

void Proto3Any::MergeFrom(const Proto3Any& from)
{
    Proto3Any* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.Proto3Any)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_type_url().empty()) {
        _this->_internal_set_type_url(from._internal_type_url());
    }
    if (!from._internal_value().empty()) {
        _this->_internal_set_value(from._internal_value());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Proto3Any::CopyFrom(const Proto3Any& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.Proto3Any)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Proto3Any::IsInitialized() const
{
    return true;
}

void Proto3Any::InternalSwap(Proto3Any* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.type_url_, lhs_arena, &other->_impl_.type_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena, &other->_impl_.value_, rhs_arena);
}

std::string Proto3Any::GetTypeName() const
{
    return "trusted_vault_pb.Proto3Any";
}

// ===================================================================

class RPCStatus::_Internal {
public:
};

RPCStatus::RPCStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:trusted_vault_pb.RPCStatus)
}
RPCStatus::RPCStatus(const RPCStatus& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    RPCStatus* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.details_) { from._impl_.details_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:trusted_vault_pb.RPCStatus)
}

inline void RPCStatus::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.details_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

RPCStatus::~RPCStatus()
{
    // @@protoc_insertion_point(destructor:trusted_vault_pb.RPCStatus)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void RPCStatus::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.details_.~RepeatedPtrField();
}

void RPCStatus::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void RPCStatus::Clear()
{
    // @@protoc_insertion_point(message_clear_start:trusted_vault_pb.RPCStatus)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.details_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* RPCStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .trusted_vault_pb.Proto3Any details = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_details(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* RPCStatus::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:trusted_vault_pb.RPCStatus)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .trusted_vault_pb.Proto3Any details = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_details_size()); i < n; i++) {
        const auto& repfield = this->_internal_details(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:trusted_vault_pb.RPCStatus)
    return target;
}

size_t RPCStatus::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:trusted_vault_pb.RPCStatus)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .trusted_vault_pb.Proto3Any details = 3;
    total_size += 1UL * this->_internal_details_size();
    for (const auto& msg : this->_impl_.details_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void RPCStatus::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const RPCStatus*>(&from));
}

void RPCStatus::MergeFrom(const RPCStatus& from)
{
    RPCStatus* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:trusted_vault_pb.RPCStatus)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.details_.MergeFrom(from._impl_.details_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RPCStatus::CopyFrom(const RPCStatus& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:trusted_vault_pb.RPCStatus)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool RPCStatus::IsInitialized() const
{
    return true;
}

void RPCStatus::InternalSwap(RPCStatus* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.details_.InternalSwap(&other->_impl_.details_);
}

std::string RPCStatus::GetTypeName() const
{
    return "trusted_vault_pb.RPCStatus";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace trusted_vault_pb
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::trusted_vault_pb::SharedMemberKey* Arena::CreateMaybeMessage<::trusted_vault_pb::SharedMemberKey>(Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::SharedMemberKey>(arena);
}
template <> PROTOBUF_NOINLINE ::trusted_vault_pb::RotationProof* Arena::CreateMaybeMessage<::trusted_vault_pb::RotationProof>(Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::RotationProof>(arena);
}
template <>
PROTOBUF_NOINLINE ::trusted_vault_pb::SecurityDomainDetails_SyncDetails* Arena::CreateMaybeMessage<::trusted_vault_pb::SecurityDomainDetails_SyncDetails>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::SecurityDomainDetails_SyncDetails>(arena);
}
template <> PROTOBUF_NOINLINE ::trusted_vault_pb::SecurityDomainDetails* Arena::CreateMaybeMessage<::trusted_vault_pb::SecurityDomainDetails>(Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::SecurityDomainDetails>(arena);
}
template <> PROTOBUF_NOINLINE ::trusted_vault_pb::SecurityDomain* Arena::CreateMaybeMessage<::trusted_vault_pb::SecurityDomain>(Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::SecurityDomain>(arena);
}
template <> PROTOBUF_NOINLINE ::trusted_vault_pb::Timestamp* Arena::CreateMaybeMessage<::trusted_vault_pb::Timestamp>(Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::Timestamp>(arena);
}
template <> PROTOBUF_NOINLINE ::trusted_vault_pb::PhysicalDeviceMetadata* Arena::CreateMaybeMessage<::trusted_vault_pb::PhysicalDeviceMetadata>(Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::PhysicalDeviceMetadata>(arena);
}
template <> PROTOBUF_NOINLINE ::trusted_vault_pb::LskfMetadata* Arena::CreateMaybeMessage<::trusted_vault_pb::LskfMetadata>(Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::LskfMetadata>(arena);
}
template <>
PROTOBUF_NOINLINE ::trusted_vault_pb::GooglePasswordManagerPinMetadata* Arena::CreateMaybeMessage<::trusted_vault_pb::GooglePasswordManagerPinMetadata>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::GooglePasswordManagerPinMetadata>(arena);
}
template <>
PROTOBUF_NOINLINE ::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership*
Arena::CreateMaybeMessage<::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership>(Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership>(arena);
}
template <>
PROTOBUF_NOINLINE ::trusted_vault_pb::SecurityDomainMember_MemberMetadata* Arena::CreateMaybeMessage<::trusted_vault_pb::SecurityDomainMember_MemberMetadata>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::SecurityDomainMember_MemberMetadata>(arena);
}
template <> PROTOBUF_NOINLINE ::trusted_vault_pb::SecurityDomainMember* Arena::CreateMaybeMessage<::trusted_vault_pb::SecurityDomainMember>(Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::SecurityDomainMember>(arena);
}
template <>
PROTOBUF_NOINLINE ::trusted_vault_pb::JoinSecurityDomainsRequest* Arena::CreateMaybeMessage<::trusted_vault_pb::JoinSecurityDomainsRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::JoinSecurityDomainsRequest>(arena);
}
template <>
PROTOBUF_NOINLINE ::trusted_vault_pb::JoinSecurityDomainsResponse* Arena::CreateMaybeMessage<::trusted_vault_pb::JoinSecurityDomainsResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::JoinSecurityDomainsResponse>(arena);
}
template <>
PROTOBUF_NOINLINE ::trusted_vault_pb::JoinSecurityDomainsErrorDetail* Arena::CreateMaybeMessage<::trusted_vault_pb::JoinSecurityDomainsErrorDetail>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::JoinSecurityDomainsErrorDetail>(arena);
}
template <>
PROTOBUF_NOINLINE ::trusted_vault_pb::ListSecurityDomainMembersResponse* Arena::CreateMaybeMessage<::trusted_vault_pb::ListSecurityDomainMembersResponse>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::ListSecurityDomainMembersResponse>(arena);
}
template <> PROTOBUF_NOINLINE ::trusted_vault_pb::Proto3Any* Arena::CreateMaybeMessage<::trusted_vault_pb::Proto3Any>(Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::Proto3Any>(arena);
}
template <> PROTOBUF_NOINLINE ::trusted_vault_pb::RPCStatus* Arena::CreateMaybeMessage<::trusted_vault_pb::RPCStatus>(Arena* arena)
{
    return Arena::CreateMessageInternal<::trusted_vault_pb::RPCStatus>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
