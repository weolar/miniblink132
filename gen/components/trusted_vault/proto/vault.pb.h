// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vault.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vault_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_vault_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_vault_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vault_2eproto {
    static const uint32_t offsets[];
};
namespace trusted_vault_pb {
class GooglePasswordManagerPinMetadata;
struct GooglePasswordManagerPinMetadataDefaultTypeInternal;
extern GooglePasswordManagerPinMetadataDefaultTypeInternal _GooglePasswordManagerPinMetadata_default_instance_;
class JoinSecurityDomainsErrorDetail;
struct JoinSecurityDomainsErrorDetailDefaultTypeInternal;
extern JoinSecurityDomainsErrorDetailDefaultTypeInternal _JoinSecurityDomainsErrorDetail_default_instance_;
class JoinSecurityDomainsRequest;
struct JoinSecurityDomainsRequestDefaultTypeInternal;
extern JoinSecurityDomainsRequestDefaultTypeInternal _JoinSecurityDomainsRequest_default_instance_;
class JoinSecurityDomainsResponse;
struct JoinSecurityDomainsResponseDefaultTypeInternal;
extern JoinSecurityDomainsResponseDefaultTypeInternal _JoinSecurityDomainsResponse_default_instance_;
class ListSecurityDomainMembersResponse;
struct ListSecurityDomainMembersResponseDefaultTypeInternal;
extern ListSecurityDomainMembersResponseDefaultTypeInternal _ListSecurityDomainMembersResponse_default_instance_;
class LskfMetadata;
struct LskfMetadataDefaultTypeInternal;
extern LskfMetadataDefaultTypeInternal _LskfMetadata_default_instance_;
class PhysicalDeviceMetadata;
struct PhysicalDeviceMetadataDefaultTypeInternal;
extern PhysicalDeviceMetadataDefaultTypeInternal _PhysicalDeviceMetadata_default_instance_;
class Proto3Any;
struct Proto3AnyDefaultTypeInternal;
extern Proto3AnyDefaultTypeInternal _Proto3Any_default_instance_;
class RPCStatus;
struct RPCStatusDefaultTypeInternal;
extern RPCStatusDefaultTypeInternal _RPCStatus_default_instance_;
class RotationProof;
struct RotationProofDefaultTypeInternal;
extern RotationProofDefaultTypeInternal _RotationProof_default_instance_;
class SecurityDomain;
struct SecurityDomainDefaultTypeInternal;
extern SecurityDomainDefaultTypeInternal _SecurityDomain_default_instance_;
class SecurityDomainDetails;
struct SecurityDomainDetailsDefaultTypeInternal;
extern SecurityDomainDetailsDefaultTypeInternal _SecurityDomainDetails_default_instance_;
class SecurityDomainDetails_SyncDetails;
struct SecurityDomainDetails_SyncDetailsDefaultTypeInternal;
extern SecurityDomainDetails_SyncDetailsDefaultTypeInternal _SecurityDomainDetails_SyncDetails_default_instance_;
class SecurityDomainMember;
struct SecurityDomainMemberDefaultTypeInternal;
extern SecurityDomainMemberDefaultTypeInternal _SecurityDomainMember_default_instance_;
class SecurityDomainMember_MemberMetadata;
struct SecurityDomainMember_MemberMetadataDefaultTypeInternal;
extern SecurityDomainMember_MemberMetadataDefaultTypeInternal _SecurityDomainMember_MemberMetadata_default_instance_;
class SecurityDomainMember_SecurityDomainMembership;
struct SecurityDomainMember_SecurityDomainMembershipDefaultTypeInternal;
extern SecurityDomainMember_SecurityDomainMembershipDefaultTypeInternal _SecurityDomainMember_SecurityDomainMembership_default_instance_;
class SharedMemberKey;
struct SharedMemberKeyDefaultTypeInternal;
extern SharedMemberKeyDefaultTypeInternal _SharedMemberKey_default_instance_;
class Timestamp;
struct TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
} // namespace trusted_vault_pb
PROTOBUF_NAMESPACE_OPEN
template <>::trusted_vault_pb::GooglePasswordManagerPinMetadata* Arena::CreateMaybeMessage<::trusted_vault_pb::GooglePasswordManagerPinMetadata>(Arena*);
template <>::trusted_vault_pb::JoinSecurityDomainsErrorDetail* Arena::CreateMaybeMessage<::trusted_vault_pb::JoinSecurityDomainsErrorDetail>(Arena*);
template <>::trusted_vault_pb::JoinSecurityDomainsRequest* Arena::CreateMaybeMessage<::trusted_vault_pb::JoinSecurityDomainsRequest>(Arena*);
template <>::trusted_vault_pb::JoinSecurityDomainsResponse* Arena::CreateMaybeMessage<::trusted_vault_pb::JoinSecurityDomainsResponse>(Arena*);
template <>::trusted_vault_pb::ListSecurityDomainMembersResponse* Arena::CreateMaybeMessage<::trusted_vault_pb::ListSecurityDomainMembersResponse>(Arena*);
template <>::trusted_vault_pb::LskfMetadata* Arena::CreateMaybeMessage<::trusted_vault_pb::LskfMetadata>(Arena*);
template <>::trusted_vault_pb::PhysicalDeviceMetadata* Arena::CreateMaybeMessage<::trusted_vault_pb::PhysicalDeviceMetadata>(Arena*);
template <>::trusted_vault_pb::Proto3Any* Arena::CreateMaybeMessage<::trusted_vault_pb::Proto3Any>(Arena*);
template <>::trusted_vault_pb::RPCStatus* Arena::CreateMaybeMessage<::trusted_vault_pb::RPCStatus>(Arena*);
template <>::trusted_vault_pb::RotationProof* Arena::CreateMaybeMessage<::trusted_vault_pb::RotationProof>(Arena*);
template <>::trusted_vault_pb::SecurityDomain* Arena::CreateMaybeMessage<::trusted_vault_pb::SecurityDomain>(Arena*);
template <>::trusted_vault_pb::SecurityDomainDetails* Arena::CreateMaybeMessage<::trusted_vault_pb::SecurityDomainDetails>(Arena*);
template <>::trusted_vault_pb::SecurityDomainDetails_SyncDetails* Arena::CreateMaybeMessage<::trusted_vault_pb::SecurityDomainDetails_SyncDetails>(Arena*);
template <>::trusted_vault_pb::SecurityDomainMember* Arena::CreateMaybeMessage<::trusted_vault_pb::SecurityDomainMember>(Arena*);
template <>::trusted_vault_pb::SecurityDomainMember_MemberMetadata* Arena::CreateMaybeMessage<::trusted_vault_pb::SecurityDomainMember_MemberMetadata>(Arena*);
template <>
::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership* Arena::CreateMaybeMessage<::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership>(
    Arena*);
template <>::trusted_vault_pb::SharedMemberKey* Arena::CreateMaybeMessage<::trusted_vault_pb::SharedMemberKey>(Arena*);
template <>::trusted_vault_pb::Timestamp* Arena::CreateMaybeMessage<::trusted_vault_pb::Timestamp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace trusted_vault_pb {

enum PhysicalDeviceMetadata_DeviceType : int {
    PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_UNKNOWN = 0,
    PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_ANDROID = 1,
    PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_IOS = 2,
    PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_CHROMEOS = 3,
    PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_WINDOWS = 4,
    PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_MAC_OS = 5,
    PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_LINUX = 6,
    PhysicalDeviceMetadata_DeviceType_PhysicalDeviceMetadata_DeviceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    PhysicalDeviceMetadata_DeviceType_PhysicalDeviceMetadata_DeviceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PhysicalDeviceMetadata_DeviceType_IsValid(int value);
constexpr PhysicalDeviceMetadata_DeviceType PhysicalDeviceMetadata_DeviceType_DeviceType_MIN = PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_UNKNOWN;
constexpr PhysicalDeviceMetadata_DeviceType PhysicalDeviceMetadata_DeviceType_DeviceType_MAX = PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_LINUX;
constexpr int PhysicalDeviceMetadata_DeviceType_DeviceType_ARRAYSIZE = PhysicalDeviceMetadata_DeviceType_DeviceType_MAX + 1;

const std::string& PhysicalDeviceMetadata_DeviceType_Name(PhysicalDeviceMetadata_DeviceType value);
template <typename T> inline const std::string& PhysicalDeviceMetadata_DeviceType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, PhysicalDeviceMetadata_DeviceType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function PhysicalDeviceMetadata_DeviceType_Name.");
    return PhysicalDeviceMetadata_DeviceType_Name(static_cast<PhysicalDeviceMetadata_DeviceType>(enum_t_value));
}
bool PhysicalDeviceMetadata_DeviceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PhysicalDeviceMetadata_DeviceType* value);
enum SecurityDomainMember_MemberType : int {
    SecurityDomainMember_MemberType_MEMBER_TYPE_UNSPECIFIED = 0,
    SecurityDomainMember_MemberType_MEMBER_TYPE_PHYSICAL_DEVICE = 1,
    SecurityDomainMember_MemberType_MEMBER_TYPE_LOCKSCREEN_KNOWLEDGE_FACTOR = 2,
    SecurityDomainMember_MemberType_MEMBER_TYPE_ICLOUD_KEYCHAIN = 4,
    SecurityDomainMember_MemberType_MEMBER_TYPE_GOOGLE_PASSWORD_MANAGER_PIN = 5,
    SecurityDomainMember_MemberType_SecurityDomainMember_MemberType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    SecurityDomainMember_MemberType_SecurityDomainMember_MemberType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SecurityDomainMember_MemberType_IsValid(int value);
constexpr SecurityDomainMember_MemberType SecurityDomainMember_MemberType_MemberType_MIN = SecurityDomainMember_MemberType_MEMBER_TYPE_UNSPECIFIED;
constexpr SecurityDomainMember_MemberType SecurityDomainMember_MemberType_MemberType_MAX
    = SecurityDomainMember_MemberType_MEMBER_TYPE_GOOGLE_PASSWORD_MANAGER_PIN;
constexpr int SecurityDomainMember_MemberType_MemberType_ARRAYSIZE = SecurityDomainMember_MemberType_MemberType_MAX + 1;

const std::string& SecurityDomainMember_MemberType_Name(SecurityDomainMember_MemberType value);
template <typename T> inline const std::string& SecurityDomainMember_MemberType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, SecurityDomainMember_MemberType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function SecurityDomainMember_MemberType_Name.");
    return SecurityDomainMember_MemberType_Name(static_cast<SecurityDomainMember_MemberType>(enum_t_value));
}
bool SecurityDomainMember_MemberType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SecurityDomainMember_MemberType* value);
// ===================================================================

class SharedMemberKey final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.SharedMemberKey) */ {
public:
    inline SharedMemberKey()
        : SharedMemberKey(nullptr)
    {
    }
    ~SharedMemberKey() override;
    explicit PROTOBUF_CONSTEXPR SharedMemberKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SharedMemberKey(const SharedMemberKey& from);
    SharedMemberKey(SharedMemberKey&& from) noexcept
        : SharedMemberKey()
    {
        *this = ::std::move(from);
    }

    inline SharedMemberKey& operator=(const SharedMemberKey& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SharedMemberKey& operator=(SharedMemberKey&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SharedMemberKey& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SharedMemberKey* internal_default_instance()
    {
        return reinterpret_cast<const SharedMemberKey*>(&_SharedMemberKey_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(SharedMemberKey& a, SharedMemberKey& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SharedMemberKey* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SharedMemberKey* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SharedMemberKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SharedMemberKey>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SharedMemberKey& from);
    void MergeFrom(const SharedMemberKey& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SharedMemberKey* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.SharedMemberKey";
    }

protected:
    explicit SharedMemberKey(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kWrappedKeyFieldNumber = 2,
        kMemberProofFieldNumber = 3,
        kEpochFieldNumber = 1,
    };
    // bytes wrapped_key = 2;
    void clear_wrapped_key();
    const std::string& wrapped_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_wrapped_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_wrapped_key();
    PROTOBUF_NODISCARD std::string* release_wrapped_key();
    void set_allocated_wrapped_key(std::string* wrapped_key);

private:
    const std::string& _internal_wrapped_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_wrapped_key(const std::string& value);
    std::string* _internal_mutable_wrapped_key();

public:
    // bytes member_proof = 3;
    void clear_member_proof();
    const std::string& member_proof() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_member_proof(ArgT0&& arg0, ArgT... args);
    std::string* mutable_member_proof();
    PROTOBUF_NODISCARD std::string* release_member_proof();
    void set_allocated_member_proof(std::string* member_proof);

private:
    const std::string& _internal_member_proof() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_member_proof(const std::string& value);
    std::string* _internal_mutable_member_proof();

public:
    // int32 epoch = 1;
    void clear_epoch();
    int32_t epoch() const;
    void set_epoch(int32_t value);

private:
    int32_t _internal_epoch() const;
    void _internal_set_epoch(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.SharedMemberKey)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wrapped_key_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr member_proof_;
        int32_t epoch_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class RotationProof final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.RotationProof) */ {
public:
    inline RotationProof()
        : RotationProof(nullptr)
    {
    }
    ~RotationProof() override;
    explicit PROTOBUF_CONSTEXPR RotationProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    RotationProof(const RotationProof& from);
    RotationProof(RotationProof&& from) noexcept
        : RotationProof()
    {
        *this = ::std::move(from);
    }

    inline RotationProof& operator=(const RotationProof& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline RotationProof& operator=(RotationProof&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const RotationProof& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const RotationProof* internal_default_instance()
    {
        return reinterpret_cast<const RotationProof*>(&_RotationProof_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(RotationProof& a, RotationProof& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(RotationProof* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(RotationProof* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    RotationProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<RotationProof>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const RotationProof& from);
    void MergeFrom(const RotationProof& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RotationProof* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.RotationProof";
    }

protected:
    explicit RotationProof(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kRotationProofFieldNumber = 2,
        kNewEpochFieldNumber = 1,
    };
    // bytes rotation_proof = 2;
    void clear_rotation_proof();
    const std::string& rotation_proof() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_rotation_proof(ArgT0&& arg0, ArgT... args);
    std::string* mutable_rotation_proof();
    PROTOBUF_NODISCARD std::string* release_rotation_proof();
    void set_allocated_rotation_proof(std::string* rotation_proof);

private:
    const std::string& _internal_rotation_proof() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_rotation_proof(const std::string& value);
    std::string* _internal_mutable_rotation_proof();

public:
    // int32 new_epoch = 1;
    void clear_new_epoch();
    int32_t new_epoch() const;
    void set_new_epoch(int32_t value);

private:
    int32_t _internal_new_epoch() const;
    void _internal_set_new_epoch(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.RotationProof)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rotation_proof_;
        int32_t new_epoch_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class SecurityDomainDetails_SyncDetails final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.SecurityDomainDetails.SyncDetails) */ {
public:
    inline SecurityDomainDetails_SyncDetails()
        : SecurityDomainDetails_SyncDetails(nullptr)
    {
    }
    ~SecurityDomainDetails_SyncDetails() override;
    explicit PROTOBUF_CONSTEXPR SecurityDomainDetails_SyncDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SecurityDomainDetails_SyncDetails(const SecurityDomainDetails_SyncDetails& from);
    SecurityDomainDetails_SyncDetails(SecurityDomainDetails_SyncDetails&& from) noexcept
        : SecurityDomainDetails_SyncDetails()
    {
        *this = ::std::move(from);
    }

    inline SecurityDomainDetails_SyncDetails& operator=(const SecurityDomainDetails_SyncDetails& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SecurityDomainDetails_SyncDetails& operator=(SecurityDomainDetails_SyncDetails&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SecurityDomainDetails_SyncDetails& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SecurityDomainDetails_SyncDetails* internal_default_instance()
    {
        return reinterpret_cast<const SecurityDomainDetails_SyncDetails*>(&_SecurityDomainDetails_SyncDetails_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(SecurityDomainDetails_SyncDetails& a, SecurityDomainDetails_SyncDetails& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SecurityDomainDetails_SyncDetails* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SecurityDomainDetails_SyncDetails* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SecurityDomainDetails_SyncDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SecurityDomainDetails_SyncDetails>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SecurityDomainDetails_SyncDetails& from);
    void MergeFrom(const SecurityDomainDetails_SyncDetails& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SecurityDomainDetails_SyncDetails* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.SecurityDomainDetails.SyncDetails";
    }

protected:
    explicit SecurityDomainDetails_SyncDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDegradedRecoverabilityFieldNumber = 1,
    };
    // bool degraded_recoverability = 1;
    void clear_degraded_recoverability();
    bool degraded_recoverability() const;
    void set_degraded_recoverability(bool value);

private:
    bool _internal_degraded_recoverability() const;
    void _internal_set_degraded_recoverability(bool value);

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.SecurityDomainDetails.SyncDetails)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        bool degraded_recoverability_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class SecurityDomainDetails final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.SecurityDomainDetails) */ {
public:
    inline SecurityDomainDetails()
        : SecurityDomainDetails(nullptr)
    {
    }
    ~SecurityDomainDetails() override;
    explicit PROTOBUF_CONSTEXPR SecurityDomainDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SecurityDomainDetails(const SecurityDomainDetails& from);
    SecurityDomainDetails(SecurityDomainDetails&& from) noexcept
        : SecurityDomainDetails()
    {
        *this = ::std::move(from);
    }

    inline SecurityDomainDetails& operator=(const SecurityDomainDetails& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SecurityDomainDetails& operator=(SecurityDomainDetails&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SecurityDomainDetails& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SecurityDomainDetails* internal_default_instance()
    {
        return reinterpret_cast<const SecurityDomainDetails*>(&_SecurityDomainDetails_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(SecurityDomainDetails& a, SecurityDomainDetails& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SecurityDomainDetails* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SecurityDomainDetails* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SecurityDomainDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SecurityDomainDetails>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SecurityDomainDetails& from);
    void MergeFrom(const SecurityDomainDetails& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SecurityDomainDetails* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.SecurityDomainDetails";
    }

protected:
    explicit SecurityDomainDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef SecurityDomainDetails_SyncDetails SyncDetails;

    // accessors -------------------------------------------------------

    enum : int {
        kSyncDetailsFieldNumber = 1,
    };
    // .trusted_vault_pb.SecurityDomainDetails.SyncDetails sync_details = 1;
    bool has_sync_details() const;

private:
    bool _internal_has_sync_details() const;

public:
    void clear_sync_details();
    const ::trusted_vault_pb::SecurityDomainDetails_SyncDetails& sync_details() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::SecurityDomainDetails_SyncDetails* release_sync_details();
    ::trusted_vault_pb::SecurityDomainDetails_SyncDetails* mutable_sync_details();
    void set_allocated_sync_details(::trusted_vault_pb::SecurityDomainDetails_SyncDetails* sync_details);

private:
    const ::trusted_vault_pb::SecurityDomainDetails_SyncDetails& _internal_sync_details() const;
    ::trusted_vault_pb::SecurityDomainDetails_SyncDetails* _internal_mutable_sync_details();

public:
    void unsafe_arena_set_allocated_sync_details(::trusted_vault_pb::SecurityDomainDetails_SyncDetails* sync_details);
    ::trusted_vault_pb::SecurityDomainDetails_SyncDetails* unsafe_arena_release_sync_details();

    // @@protoc_insertion_point(class_scope:trusted_vault_pb.SecurityDomainDetails)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::trusted_vault_pb::SecurityDomainDetails_SyncDetails* sync_details_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class SecurityDomain final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.SecurityDomain) */ {
public:
    inline SecurityDomain()
        : SecurityDomain(nullptr)
    {
    }
    ~SecurityDomain() override;
    explicit PROTOBUF_CONSTEXPR SecurityDomain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SecurityDomain(const SecurityDomain& from);
    SecurityDomain(SecurityDomain&& from) noexcept
        : SecurityDomain()
    {
        *this = ::std::move(from);
    }

    inline SecurityDomain& operator=(const SecurityDomain& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SecurityDomain& operator=(SecurityDomain&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SecurityDomain& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SecurityDomain* internal_default_instance()
    {
        return reinterpret_cast<const SecurityDomain*>(&_SecurityDomain_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(SecurityDomain& a, SecurityDomain& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SecurityDomain* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SecurityDomain* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SecurityDomain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SecurityDomain>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SecurityDomain& from);
    void MergeFrom(const SecurityDomain& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SecurityDomain* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.SecurityDomain";
    }

protected:
    explicit SecurityDomain(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kNameFieldNumber = 1,
        kSecurityDomainDetailsFieldNumber = 3,
        kCurrentEpochFieldNumber = 2,
    };
    // string name = 1;
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // .trusted_vault_pb.SecurityDomainDetails security_domain_details = 3;
    bool has_security_domain_details() const;

private:
    bool _internal_has_security_domain_details() const;

public:
    void clear_security_domain_details();
    const ::trusted_vault_pb::SecurityDomainDetails& security_domain_details() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::SecurityDomainDetails* release_security_domain_details();
    ::trusted_vault_pb::SecurityDomainDetails* mutable_security_domain_details();
    void set_allocated_security_domain_details(::trusted_vault_pb::SecurityDomainDetails* security_domain_details);

private:
    const ::trusted_vault_pb::SecurityDomainDetails& _internal_security_domain_details() const;
    ::trusted_vault_pb::SecurityDomainDetails* _internal_mutable_security_domain_details();

public:
    void unsafe_arena_set_allocated_security_domain_details(::trusted_vault_pb::SecurityDomainDetails* security_domain_details);
    ::trusted_vault_pb::SecurityDomainDetails* unsafe_arena_release_security_domain_details();

    // int32 current_epoch = 2;
    void clear_current_epoch();
    int32_t current_epoch() const;
    void set_current_epoch(int32_t value);

private:
    int32_t _internal_current_epoch() const;
    void _internal_set_current_epoch(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.SecurityDomain)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::trusted_vault_pb::SecurityDomainDetails* security_domain_details_;
        int32_t current_epoch_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class Timestamp final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.Timestamp) */ {
public:
    inline Timestamp()
        : Timestamp(nullptr)
    {
    }
    ~Timestamp() override;
    explicit PROTOBUF_CONSTEXPR Timestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Timestamp(const Timestamp& from);
    Timestamp(Timestamp&& from) noexcept
        : Timestamp()
    {
        *this = ::std::move(from);
    }

    inline Timestamp& operator=(const Timestamp& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Timestamp& operator=(Timestamp&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Timestamp& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Timestamp* internal_default_instance()
    {
        return reinterpret_cast<const Timestamp*>(&_Timestamp_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(Timestamp& a, Timestamp& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Timestamp* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Timestamp* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Timestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Timestamp>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Timestamp& from);
    void MergeFrom(const Timestamp& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Timestamp* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.Timestamp";
    }

protected:
    explicit Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSecondsFieldNumber = 1,
        kNanosFieldNumber = 2,
    };
    // int64 seconds = 1;
    void clear_seconds();
    int64_t seconds() const;
    void set_seconds(int64_t value);

private:
    int64_t _internal_seconds() const;
    void _internal_set_seconds(int64_t value);

public:
    // int32 nanos = 2;
    void clear_nanos();
    int32_t nanos() const;
    void set_nanos(int32_t value);

private:
    int32_t _internal_nanos() const;
    void _internal_set_nanos(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.Timestamp)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        int64_t seconds_;
        int32_t nanos_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class PhysicalDeviceMetadata final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.PhysicalDeviceMetadata) */ {
public:
    inline PhysicalDeviceMetadata()
        : PhysicalDeviceMetadata(nullptr)
    {
    }
    ~PhysicalDeviceMetadata() override;
    explicit PROTOBUF_CONSTEXPR PhysicalDeviceMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PhysicalDeviceMetadata(const PhysicalDeviceMetadata& from);
    PhysicalDeviceMetadata(PhysicalDeviceMetadata&& from) noexcept
        : PhysicalDeviceMetadata()
    {
        *this = ::std::move(from);
    }

    inline PhysicalDeviceMetadata& operator=(const PhysicalDeviceMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline PhysicalDeviceMetadata& operator=(PhysicalDeviceMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const PhysicalDeviceMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const PhysicalDeviceMetadata* internal_default_instance()
    {
        return reinterpret_cast<const PhysicalDeviceMetadata*>(&_PhysicalDeviceMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(PhysicalDeviceMetadata& a, PhysicalDeviceMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(PhysicalDeviceMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PhysicalDeviceMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PhysicalDeviceMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<PhysicalDeviceMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const PhysicalDeviceMetadata& from);
    void MergeFrom(const PhysicalDeviceMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PhysicalDeviceMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.PhysicalDeviceMetadata";
    }

protected:
    explicit PhysicalDeviceMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef PhysicalDeviceMetadata_DeviceType DeviceType;
    static constexpr DeviceType DEVICE_TYPE_UNKNOWN = PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_UNKNOWN;
    static constexpr DeviceType DEVICE_TYPE_ANDROID = PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_ANDROID;
    static constexpr DeviceType DEVICE_TYPE_IOS = PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_IOS;
    static constexpr DeviceType DEVICE_TYPE_CHROMEOS = PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_CHROMEOS;
    static constexpr DeviceType DEVICE_TYPE_WINDOWS = PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_WINDOWS;
    static constexpr DeviceType DEVICE_TYPE_MAC_OS = PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_MAC_OS;
    static constexpr DeviceType DEVICE_TYPE_LINUX = PhysicalDeviceMetadata_DeviceType_DEVICE_TYPE_LINUX;
    static inline bool DeviceType_IsValid(int value)
    {
        return PhysicalDeviceMetadata_DeviceType_IsValid(value);
    }
    static constexpr DeviceType DeviceType_MIN = PhysicalDeviceMetadata_DeviceType_DeviceType_MIN;
    static constexpr DeviceType DeviceType_MAX = PhysicalDeviceMetadata_DeviceType_DeviceType_MAX;
    static constexpr int DeviceType_ARRAYSIZE = PhysicalDeviceMetadata_DeviceType_DeviceType_ARRAYSIZE;
    template <typename T> static inline const std::string& DeviceType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, DeviceType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function DeviceType_Name.");
        return PhysicalDeviceMetadata_DeviceType_Name(enum_t_value);
    }
    static inline bool DeviceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceType* value)
    {
        return PhysicalDeviceMetadata_DeviceType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kDeviceTypeFieldNumber = 1,
    };
    // .trusted_vault_pb.PhysicalDeviceMetadata.DeviceType device_type = 1;
    void clear_device_type();
    ::trusted_vault_pb::PhysicalDeviceMetadata_DeviceType device_type() const;
    void set_device_type(::trusted_vault_pb::PhysicalDeviceMetadata_DeviceType value);

private:
    ::trusted_vault_pb::PhysicalDeviceMetadata_DeviceType _internal_device_type() const;
    void _internal_set_device_type(::trusted_vault_pb::PhysicalDeviceMetadata_DeviceType value);

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.PhysicalDeviceMetadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        int device_type_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class LskfMetadata final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.LskfMetadata) */ {
public:
    inline LskfMetadata()
        : LskfMetadata(nullptr)
    {
    }
    ~LskfMetadata() override;
    explicit PROTOBUF_CONSTEXPR LskfMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    LskfMetadata(const LskfMetadata& from);
    LskfMetadata(LskfMetadata&& from) noexcept
        : LskfMetadata()
    {
        *this = ::std::move(from);
    }

    inline LskfMetadata& operator=(const LskfMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline LskfMetadata& operator=(LskfMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const LskfMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const LskfMetadata* internal_default_instance()
    {
        return reinterpret_cast<const LskfMetadata*>(&_LskfMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(LskfMetadata& a, LskfMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(LskfMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(LskfMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    LskfMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<LskfMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const LskfMetadata& from);
    void MergeFrom(const LskfMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(LskfMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.LskfMetadata";
    }

protected:
    explicit LskfMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kExpirationTimeFieldNumber = 1,
    };
    // .trusted_vault_pb.Timestamp expiration_time = 1;
    bool has_expiration_time() const;

private:
    bool _internal_has_expiration_time() const;

public:
    void clear_expiration_time();
    const ::trusted_vault_pb::Timestamp& expiration_time() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::Timestamp* release_expiration_time();
    ::trusted_vault_pb::Timestamp* mutable_expiration_time();
    void set_allocated_expiration_time(::trusted_vault_pb::Timestamp* expiration_time);

private:
    const ::trusted_vault_pb::Timestamp& _internal_expiration_time() const;
    ::trusted_vault_pb::Timestamp* _internal_mutable_expiration_time();

public:
    void unsafe_arena_set_allocated_expiration_time(::trusted_vault_pb::Timestamp* expiration_time);
    ::trusted_vault_pb::Timestamp* unsafe_arena_release_expiration_time();

    // @@protoc_insertion_point(class_scope:trusted_vault_pb.LskfMetadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::trusted_vault_pb::Timestamp* expiration_time_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class GooglePasswordManagerPinMetadata final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.GooglePasswordManagerPinMetadata) */ {
public:
    inline GooglePasswordManagerPinMetadata()
        : GooglePasswordManagerPinMetadata(nullptr)
    {
    }
    ~GooglePasswordManagerPinMetadata() override;
    explicit PROTOBUF_CONSTEXPR GooglePasswordManagerPinMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    GooglePasswordManagerPinMetadata(const GooglePasswordManagerPinMetadata& from);
    GooglePasswordManagerPinMetadata(GooglePasswordManagerPinMetadata&& from) noexcept
        : GooglePasswordManagerPinMetadata()
    {
        *this = ::std::move(from);
    }

    inline GooglePasswordManagerPinMetadata& operator=(const GooglePasswordManagerPinMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline GooglePasswordManagerPinMetadata& operator=(GooglePasswordManagerPinMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const GooglePasswordManagerPinMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const GooglePasswordManagerPinMetadata* internal_default_instance()
    {
        return reinterpret_cast<const GooglePasswordManagerPinMetadata*>(&_GooglePasswordManagerPinMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(GooglePasswordManagerPinMetadata& a, GooglePasswordManagerPinMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(GooglePasswordManagerPinMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(GooglePasswordManagerPinMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    GooglePasswordManagerPinMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<GooglePasswordManagerPinMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const GooglePasswordManagerPinMetadata& from);
    void MergeFrom(const GooglePasswordManagerPinMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(GooglePasswordManagerPinMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.GooglePasswordManagerPinMetadata";
    }

protected:
    explicit GooglePasswordManagerPinMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kEncryptedPinHashFieldNumber = 2,
        kExpirationTimeFieldNumber = 1,
    };
    // bytes encrypted_pin_hash = 2;
    void clear_encrypted_pin_hash();
    const std::string& encrypted_pin_hash() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_encrypted_pin_hash(ArgT0&& arg0, ArgT... args);
    std::string* mutable_encrypted_pin_hash();
    PROTOBUF_NODISCARD std::string* release_encrypted_pin_hash();
    void set_allocated_encrypted_pin_hash(std::string* encrypted_pin_hash);

private:
    const std::string& _internal_encrypted_pin_hash() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_pin_hash(const std::string& value);
    std::string* _internal_mutable_encrypted_pin_hash();

public:
    // .trusted_vault_pb.Timestamp expiration_time = 1;
    bool has_expiration_time() const;

private:
    bool _internal_has_expiration_time() const;

public:
    void clear_expiration_time();
    const ::trusted_vault_pb::Timestamp& expiration_time() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::Timestamp* release_expiration_time();
    ::trusted_vault_pb::Timestamp* mutable_expiration_time();
    void set_allocated_expiration_time(::trusted_vault_pb::Timestamp* expiration_time);

private:
    const ::trusted_vault_pb::Timestamp& _internal_expiration_time() const;
    ::trusted_vault_pb::Timestamp* _internal_mutable_expiration_time();

public:
    void unsafe_arena_set_allocated_expiration_time(::trusted_vault_pb::Timestamp* expiration_time);
    ::trusted_vault_pb::Timestamp* unsafe_arena_release_expiration_time();

    // @@protoc_insertion_point(class_scope:trusted_vault_pb.GooglePasswordManagerPinMetadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_pin_hash_;
        ::trusted_vault_pb::Timestamp* expiration_time_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class SecurityDomainMember_SecurityDomainMembership final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership) */ {
public:
    inline SecurityDomainMember_SecurityDomainMembership()
        : SecurityDomainMember_SecurityDomainMembership(nullptr)
    {
    }
    ~SecurityDomainMember_SecurityDomainMembership() override;
    explicit PROTOBUF_CONSTEXPR SecurityDomainMember_SecurityDomainMembership(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SecurityDomainMember_SecurityDomainMembership(const SecurityDomainMember_SecurityDomainMembership& from);
    SecurityDomainMember_SecurityDomainMembership(SecurityDomainMember_SecurityDomainMembership&& from) noexcept
        : SecurityDomainMember_SecurityDomainMembership()
    {
        *this = ::std::move(from);
    }

    inline SecurityDomainMember_SecurityDomainMembership& operator=(const SecurityDomainMember_SecurityDomainMembership& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SecurityDomainMember_SecurityDomainMembership& operator=(SecurityDomainMember_SecurityDomainMembership&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SecurityDomainMember_SecurityDomainMembership& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SecurityDomainMember_SecurityDomainMembership* internal_default_instance()
    {
        return reinterpret_cast<const SecurityDomainMember_SecurityDomainMembership*>(&_SecurityDomainMember_SecurityDomainMembership_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(SecurityDomainMember_SecurityDomainMembership& a, SecurityDomainMember_SecurityDomainMembership& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SecurityDomainMember_SecurityDomainMembership* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SecurityDomainMember_SecurityDomainMembership* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SecurityDomainMember_SecurityDomainMembership* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SecurityDomainMember_SecurityDomainMembership>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SecurityDomainMember_SecurityDomainMembership& from);
    void MergeFrom(const SecurityDomainMember_SecurityDomainMembership& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SecurityDomainMember_SecurityDomainMembership* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership";
    }

protected:
    explicit SecurityDomainMember_SecurityDomainMembership(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kKeysFieldNumber = 3,
        kRotationProofsFieldNumber = 4,
        kSecurityDomainFieldNumber = 1,
    };
    // repeated .trusted_vault_pb.SharedMemberKey keys = 3;
    int keys_size() const;

private:
    int _internal_keys_size() const;

public:
    void clear_keys();
    ::trusted_vault_pb::SharedMemberKey* mutable_keys(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SharedMemberKey>* mutable_keys();

private:
    const ::trusted_vault_pb::SharedMemberKey& _internal_keys(int index) const;
    ::trusted_vault_pb::SharedMemberKey* _internal_add_keys();

public:
    const ::trusted_vault_pb::SharedMemberKey& keys(int index) const;
    ::trusted_vault_pb::SharedMemberKey* add_keys();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SharedMemberKey>& keys() const;

    // repeated .trusted_vault_pb.RotationProof rotation_proofs = 4;
    int rotation_proofs_size() const;

private:
    int _internal_rotation_proofs_size() const;

public:
    void clear_rotation_proofs();
    ::trusted_vault_pb::RotationProof* mutable_rotation_proofs(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::RotationProof>* mutable_rotation_proofs();

private:
    const ::trusted_vault_pb::RotationProof& _internal_rotation_proofs(int index) const;
    ::trusted_vault_pb::RotationProof* _internal_add_rotation_proofs();

public:
    const ::trusted_vault_pb::RotationProof& rotation_proofs(int index) const;
    ::trusted_vault_pb::RotationProof* add_rotation_proofs();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::RotationProof>& rotation_proofs() const;

    // string security_domain = 1;
    void clear_security_domain();
    const std::string& security_domain() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_security_domain(ArgT0&& arg0, ArgT... args);
    std::string* mutable_security_domain();
    PROTOBUF_NODISCARD std::string* release_security_domain();
    void set_allocated_security_domain(std::string* security_domain);

private:
    const std::string& _internal_security_domain() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_security_domain(const std::string& value);
    std::string* _internal_mutable_security_domain();

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SharedMemberKey> keys_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::RotationProof> rotation_proofs_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr security_domain_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class SecurityDomainMember_MemberMetadata final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.SecurityDomainMember.MemberMetadata) */ {
public:
    inline SecurityDomainMember_MemberMetadata()
        : SecurityDomainMember_MemberMetadata(nullptr)
    {
    }
    ~SecurityDomainMember_MemberMetadata() override;
    explicit PROTOBUF_CONSTEXPR SecurityDomainMember_MemberMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SecurityDomainMember_MemberMetadata(const SecurityDomainMember_MemberMetadata& from);
    SecurityDomainMember_MemberMetadata(SecurityDomainMember_MemberMetadata&& from) noexcept
        : SecurityDomainMember_MemberMetadata()
    {
        *this = ::std::move(from);
    }

    inline SecurityDomainMember_MemberMetadata& operator=(const SecurityDomainMember_MemberMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SecurityDomainMember_MemberMetadata& operator=(SecurityDomainMember_MemberMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SecurityDomainMember_MemberMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    enum MemberMetadataVariantCase {
        kPhysicalDeviceMetadata = 3,
        kLskfMetadata = 4,
        kGooglePasswordManagerPinMetadata = 5,
        MEMBER_METADATA_VARIANT_NOT_SET = 0,
    };

    static inline const SecurityDomainMember_MemberMetadata* internal_default_instance()
    {
        return reinterpret_cast<const SecurityDomainMember_MemberMetadata*>(&_SecurityDomainMember_MemberMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 10;

    friend void swap(SecurityDomainMember_MemberMetadata& a, SecurityDomainMember_MemberMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SecurityDomainMember_MemberMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SecurityDomainMember_MemberMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SecurityDomainMember_MemberMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SecurityDomainMember_MemberMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SecurityDomainMember_MemberMetadata& from);
    void MergeFrom(const SecurityDomainMember_MemberMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SecurityDomainMember_MemberMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.SecurityDomainMember.MemberMetadata";
    }

protected:
    explicit SecurityDomainMember_MemberMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUsableForRetrievalFieldNumber = 1,
        kPhysicalDeviceMetadataFieldNumber = 3,
        kLskfMetadataFieldNumber = 4,
        kGooglePasswordManagerPinMetadataFieldNumber = 5,
    };
    // bool usable_for_retrieval = 1;
    void clear_usable_for_retrieval();
    bool usable_for_retrieval() const;
    void set_usable_for_retrieval(bool value);

private:
    bool _internal_usable_for_retrieval() const;
    void _internal_set_usable_for_retrieval(bool value);

public:
    // .trusted_vault_pb.PhysicalDeviceMetadata physical_device_metadata = 3;
    bool has_physical_device_metadata() const;

private:
    bool _internal_has_physical_device_metadata() const;

public:
    void clear_physical_device_metadata();
    const ::trusted_vault_pb::PhysicalDeviceMetadata& physical_device_metadata() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::PhysicalDeviceMetadata* release_physical_device_metadata();
    ::trusted_vault_pb::PhysicalDeviceMetadata* mutable_physical_device_metadata();
    void set_allocated_physical_device_metadata(::trusted_vault_pb::PhysicalDeviceMetadata* physical_device_metadata);

private:
    const ::trusted_vault_pb::PhysicalDeviceMetadata& _internal_physical_device_metadata() const;
    ::trusted_vault_pb::PhysicalDeviceMetadata* _internal_mutable_physical_device_metadata();

public:
    void unsafe_arena_set_allocated_physical_device_metadata(::trusted_vault_pb::PhysicalDeviceMetadata* physical_device_metadata);
    ::trusted_vault_pb::PhysicalDeviceMetadata* unsafe_arena_release_physical_device_metadata();

    // .trusted_vault_pb.LskfMetadata lskf_metadata = 4;
    bool has_lskf_metadata() const;

private:
    bool _internal_has_lskf_metadata() const;

public:
    void clear_lskf_metadata();
    const ::trusted_vault_pb::LskfMetadata& lskf_metadata() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::LskfMetadata* release_lskf_metadata();
    ::trusted_vault_pb::LskfMetadata* mutable_lskf_metadata();
    void set_allocated_lskf_metadata(::trusted_vault_pb::LskfMetadata* lskf_metadata);

private:
    const ::trusted_vault_pb::LskfMetadata& _internal_lskf_metadata() const;
    ::trusted_vault_pb::LskfMetadata* _internal_mutable_lskf_metadata();

public:
    void unsafe_arena_set_allocated_lskf_metadata(::trusted_vault_pb::LskfMetadata* lskf_metadata);
    ::trusted_vault_pb::LskfMetadata* unsafe_arena_release_lskf_metadata();

    // .trusted_vault_pb.GooglePasswordManagerPinMetadata google_password_manager_pin_metadata = 5;
    bool has_google_password_manager_pin_metadata() const;

private:
    bool _internal_has_google_password_manager_pin_metadata() const;

public:
    void clear_google_password_manager_pin_metadata();
    const ::trusted_vault_pb::GooglePasswordManagerPinMetadata& google_password_manager_pin_metadata() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::GooglePasswordManagerPinMetadata* release_google_password_manager_pin_metadata();
    ::trusted_vault_pb::GooglePasswordManagerPinMetadata* mutable_google_password_manager_pin_metadata();
    void set_allocated_google_password_manager_pin_metadata(::trusted_vault_pb::GooglePasswordManagerPinMetadata* google_password_manager_pin_metadata);

private:
    const ::trusted_vault_pb::GooglePasswordManagerPinMetadata& _internal_google_password_manager_pin_metadata() const;
    ::trusted_vault_pb::GooglePasswordManagerPinMetadata* _internal_mutable_google_password_manager_pin_metadata();

public:
    void unsafe_arena_set_allocated_google_password_manager_pin_metadata(
        ::trusted_vault_pb::GooglePasswordManagerPinMetadata* google_password_manager_pin_metadata);
    ::trusted_vault_pb::GooglePasswordManagerPinMetadata* unsafe_arena_release_google_password_manager_pin_metadata();

    void clear_member_metadata_variant();
    MemberMetadataVariantCase member_metadata_variant_case() const;
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.SecurityDomainMember.MemberMetadata)
private:
    class _Internal;
    void set_has_physical_device_metadata();
    void set_has_lskf_metadata();
    void set_has_google_password_manager_pin_metadata();

    inline bool has_member_metadata_variant() const;
    inline void clear_has_member_metadata_variant();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        bool usable_for_retrieval_;
        union MemberMetadataVariantUnion {
            constexpr MemberMetadataVariantUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::trusted_vault_pb::PhysicalDeviceMetadata* physical_device_metadata_;
            ::trusted_vault_pb::LskfMetadata* lskf_metadata_;
            ::trusted_vault_pb::GooglePasswordManagerPinMetadata* google_password_manager_pin_metadata_;
        } member_metadata_variant_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class SecurityDomainMember final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.SecurityDomainMember) */ {
public:
    inline SecurityDomainMember()
        : SecurityDomainMember(nullptr)
    {
    }
    ~SecurityDomainMember() override;
    explicit PROTOBUF_CONSTEXPR SecurityDomainMember(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SecurityDomainMember(const SecurityDomainMember& from);
    SecurityDomainMember(SecurityDomainMember&& from) noexcept
        : SecurityDomainMember()
    {
        *this = ::std::move(from);
    }

    inline SecurityDomainMember& operator=(const SecurityDomainMember& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SecurityDomainMember& operator=(SecurityDomainMember&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SecurityDomainMember& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SecurityDomainMember* internal_default_instance()
    {
        return reinterpret_cast<const SecurityDomainMember*>(&_SecurityDomainMember_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 11;

    friend void swap(SecurityDomainMember& a, SecurityDomainMember& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SecurityDomainMember* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SecurityDomainMember* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SecurityDomainMember* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SecurityDomainMember>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SecurityDomainMember& from);
    void MergeFrom(const SecurityDomainMember& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SecurityDomainMember* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.SecurityDomainMember";
    }

protected:
    explicit SecurityDomainMember(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef SecurityDomainMember_SecurityDomainMembership SecurityDomainMembership;
    typedef SecurityDomainMember_MemberMetadata MemberMetadata;

    typedef SecurityDomainMember_MemberType MemberType;
    static constexpr MemberType MEMBER_TYPE_UNSPECIFIED = SecurityDomainMember_MemberType_MEMBER_TYPE_UNSPECIFIED;
    static constexpr MemberType MEMBER_TYPE_PHYSICAL_DEVICE = SecurityDomainMember_MemberType_MEMBER_TYPE_PHYSICAL_DEVICE;
    static constexpr MemberType MEMBER_TYPE_LOCKSCREEN_KNOWLEDGE_FACTOR = SecurityDomainMember_MemberType_MEMBER_TYPE_LOCKSCREEN_KNOWLEDGE_FACTOR;
    static constexpr MemberType MEMBER_TYPE_ICLOUD_KEYCHAIN = SecurityDomainMember_MemberType_MEMBER_TYPE_ICLOUD_KEYCHAIN;
    static constexpr MemberType MEMBER_TYPE_GOOGLE_PASSWORD_MANAGER_PIN = SecurityDomainMember_MemberType_MEMBER_TYPE_GOOGLE_PASSWORD_MANAGER_PIN;
    static inline bool MemberType_IsValid(int value)
    {
        return SecurityDomainMember_MemberType_IsValid(value);
    }
    static constexpr MemberType MemberType_MIN = SecurityDomainMember_MemberType_MemberType_MIN;
    static constexpr MemberType MemberType_MAX = SecurityDomainMember_MemberType_MemberType_MAX;
    static constexpr int MemberType_ARRAYSIZE = SecurityDomainMember_MemberType_MemberType_ARRAYSIZE;
    template <typename T> static inline const std::string& MemberType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, MemberType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function MemberType_Name.");
        return SecurityDomainMember_MemberType_Name(enum_t_value);
    }
    static inline bool MemberType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MemberType* value)
    {
        return SecurityDomainMember_MemberType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kMembershipsFieldNumber = 3,
        kNameFieldNumber = 1,
        kPublicKeyFieldNumber = 2,
        kMemberMetadataFieldNumber = 6,
        kMemberTypeFieldNumber = 4,
    };
    // repeated .trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership memberships = 3;
    int memberships_size() const;

private:
    int _internal_memberships_size() const;

public:
    void clear_memberships();
    ::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership* mutable_memberships(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership>* mutable_memberships();

private:
    const ::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership& _internal_memberships(int index) const;
    ::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership* _internal_add_memberships();

public:
    const ::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership& memberships(int index) const;
    ::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership* add_memberships();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership>& memberships() const;

    // string name = 1;
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // bytes public_key = 2;
    void clear_public_key();
    const std::string& public_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_public_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_public_key();
    PROTOBUF_NODISCARD std::string* release_public_key();
    void set_allocated_public_key(std::string* public_key);

private:
    const std::string& _internal_public_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
    std::string* _internal_mutable_public_key();

public:
    // .trusted_vault_pb.SecurityDomainMember.MemberMetadata member_metadata = 6;
    bool has_member_metadata() const;

private:
    bool _internal_has_member_metadata() const;

public:
    void clear_member_metadata();
    const ::trusted_vault_pb::SecurityDomainMember_MemberMetadata& member_metadata() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::SecurityDomainMember_MemberMetadata* release_member_metadata();
    ::trusted_vault_pb::SecurityDomainMember_MemberMetadata* mutable_member_metadata();
    void set_allocated_member_metadata(::trusted_vault_pb::SecurityDomainMember_MemberMetadata* member_metadata);

private:
    const ::trusted_vault_pb::SecurityDomainMember_MemberMetadata& _internal_member_metadata() const;
    ::trusted_vault_pb::SecurityDomainMember_MemberMetadata* _internal_mutable_member_metadata();

public:
    void unsafe_arena_set_allocated_member_metadata(::trusted_vault_pb::SecurityDomainMember_MemberMetadata* member_metadata);
    ::trusted_vault_pb::SecurityDomainMember_MemberMetadata* unsafe_arena_release_member_metadata();

    // .trusted_vault_pb.SecurityDomainMember.MemberType member_type = 4;
    void clear_member_type();
    ::trusted_vault_pb::SecurityDomainMember_MemberType member_type() const;
    void set_member_type(::trusted_vault_pb::SecurityDomainMember_MemberType value);

private:
    ::trusted_vault_pb::SecurityDomainMember_MemberType _internal_member_type() const;
    void _internal_set_member_type(::trusted_vault_pb::SecurityDomainMember_MemberType value);

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.SecurityDomainMember)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership> memberships_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
        ::trusted_vault_pb::SecurityDomainMember_MemberMetadata* member_metadata_;
        int member_type_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class JoinSecurityDomainsRequest final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.JoinSecurityDomainsRequest) */ {
public:
    inline JoinSecurityDomainsRequest()
        : JoinSecurityDomainsRequest(nullptr)
    {
    }
    ~JoinSecurityDomainsRequest() override;
    explicit PROTOBUF_CONSTEXPR JoinSecurityDomainsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    JoinSecurityDomainsRequest(const JoinSecurityDomainsRequest& from);
    JoinSecurityDomainsRequest(JoinSecurityDomainsRequest&& from) noexcept
        : JoinSecurityDomainsRequest()
    {
        *this = ::std::move(from);
    }

    inline JoinSecurityDomainsRequest& operator=(const JoinSecurityDomainsRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline JoinSecurityDomainsRequest& operator=(JoinSecurityDomainsRequest&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const JoinSecurityDomainsRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const JoinSecurityDomainsRequest* internal_default_instance()
    {
        return reinterpret_cast<const JoinSecurityDomainsRequest*>(&_JoinSecurityDomainsRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 12;

    friend void swap(JoinSecurityDomainsRequest& a, JoinSecurityDomainsRequest& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(JoinSecurityDomainsRequest* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(JoinSecurityDomainsRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    JoinSecurityDomainsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<JoinSecurityDomainsRequest>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const JoinSecurityDomainsRequest& from);
    void MergeFrom(const JoinSecurityDomainsRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(JoinSecurityDomainsRequest* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.JoinSecurityDomainsRequest";
    }

protected:
    explicit JoinSecurityDomainsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSharedMemberKeyFieldNumber = 3,
        kCurrentPublicKeyToReplaceFieldNumber = 5,
        kSecurityDomainFieldNumber = 1,
        kSecurityDomainMemberFieldNumber = 2,
        kMemberTypeHintFieldNumber = 4,
    };
    // repeated .trusted_vault_pb.SharedMemberKey shared_member_key = 3;
    int shared_member_key_size() const;

private:
    int _internal_shared_member_key_size() const;

public:
    void clear_shared_member_key();
    ::trusted_vault_pb::SharedMemberKey* mutable_shared_member_key(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SharedMemberKey>* mutable_shared_member_key();

private:
    const ::trusted_vault_pb::SharedMemberKey& _internal_shared_member_key(int index) const;
    ::trusted_vault_pb::SharedMemberKey* _internal_add_shared_member_key();

public:
    const ::trusted_vault_pb::SharedMemberKey& shared_member_key(int index) const;
    ::trusted_vault_pb::SharedMemberKey* add_shared_member_key();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SharedMemberKey>& shared_member_key() const;

    // bytes current_public_key_to_replace = 5;
    void clear_current_public_key_to_replace();
    const std::string& current_public_key_to_replace() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_current_public_key_to_replace(ArgT0&& arg0, ArgT... args);
    std::string* mutable_current_public_key_to_replace();
    PROTOBUF_NODISCARD std::string* release_current_public_key_to_replace();
    void set_allocated_current_public_key_to_replace(std::string* current_public_key_to_replace);

private:
    const std::string& _internal_current_public_key_to_replace() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_public_key_to_replace(const std::string& value);
    std::string* _internal_mutable_current_public_key_to_replace();

public:
    // .trusted_vault_pb.SecurityDomain security_domain = 1;
    bool has_security_domain() const;

private:
    bool _internal_has_security_domain() const;

public:
    void clear_security_domain();
    const ::trusted_vault_pb::SecurityDomain& security_domain() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::SecurityDomain* release_security_domain();
    ::trusted_vault_pb::SecurityDomain* mutable_security_domain();
    void set_allocated_security_domain(::trusted_vault_pb::SecurityDomain* security_domain);

private:
    const ::trusted_vault_pb::SecurityDomain& _internal_security_domain() const;
    ::trusted_vault_pb::SecurityDomain* _internal_mutable_security_domain();

public:
    void unsafe_arena_set_allocated_security_domain(::trusted_vault_pb::SecurityDomain* security_domain);
    ::trusted_vault_pb::SecurityDomain* unsafe_arena_release_security_domain();

    // .trusted_vault_pb.SecurityDomainMember security_domain_member = 2;
    bool has_security_domain_member() const;

private:
    bool _internal_has_security_domain_member() const;

public:
    void clear_security_domain_member();
    const ::trusted_vault_pb::SecurityDomainMember& security_domain_member() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::SecurityDomainMember* release_security_domain_member();
    ::trusted_vault_pb::SecurityDomainMember* mutable_security_domain_member();
    void set_allocated_security_domain_member(::trusted_vault_pb::SecurityDomainMember* security_domain_member);

private:
    const ::trusted_vault_pb::SecurityDomainMember& _internal_security_domain_member() const;
    ::trusted_vault_pb::SecurityDomainMember* _internal_mutable_security_domain_member();

public:
    void unsafe_arena_set_allocated_security_domain_member(::trusted_vault_pb::SecurityDomainMember* security_domain_member);
    ::trusted_vault_pb::SecurityDomainMember* unsafe_arena_release_security_domain_member();

    // int32 member_type_hint = 4;
    void clear_member_type_hint();
    int32_t member_type_hint() const;
    void set_member_type_hint(int32_t value);

private:
    int32_t _internal_member_type_hint() const;
    void _internal_set_member_type_hint(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.JoinSecurityDomainsRequest)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SharedMemberKey> shared_member_key_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_public_key_to_replace_;
        ::trusted_vault_pb::SecurityDomain* security_domain_;
        ::trusted_vault_pb::SecurityDomainMember* security_domain_member_;
        int32_t member_type_hint_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class JoinSecurityDomainsResponse final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.JoinSecurityDomainsResponse) */ {
public:
    inline JoinSecurityDomainsResponse()
        : JoinSecurityDomainsResponse(nullptr)
    {
    }
    ~JoinSecurityDomainsResponse() override;
    explicit PROTOBUF_CONSTEXPR JoinSecurityDomainsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    JoinSecurityDomainsResponse(const JoinSecurityDomainsResponse& from);
    JoinSecurityDomainsResponse(JoinSecurityDomainsResponse&& from) noexcept
        : JoinSecurityDomainsResponse()
    {
        *this = ::std::move(from);
    }

    inline JoinSecurityDomainsResponse& operator=(const JoinSecurityDomainsResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline JoinSecurityDomainsResponse& operator=(JoinSecurityDomainsResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const JoinSecurityDomainsResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const JoinSecurityDomainsResponse* internal_default_instance()
    {
        return reinterpret_cast<const JoinSecurityDomainsResponse*>(&_JoinSecurityDomainsResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 13;

    friend void swap(JoinSecurityDomainsResponse& a, JoinSecurityDomainsResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(JoinSecurityDomainsResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(JoinSecurityDomainsResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    JoinSecurityDomainsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<JoinSecurityDomainsResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const JoinSecurityDomainsResponse& from);
    void MergeFrom(const JoinSecurityDomainsResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(JoinSecurityDomainsResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.JoinSecurityDomainsResponse";
    }

protected:
    explicit JoinSecurityDomainsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSecurityDomainFieldNumber = 1,
    };
    // .trusted_vault_pb.SecurityDomain security_domain = 1;
    bool has_security_domain() const;

private:
    bool _internal_has_security_domain() const;

public:
    void clear_security_domain();
    const ::trusted_vault_pb::SecurityDomain& security_domain() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::SecurityDomain* release_security_domain();
    ::trusted_vault_pb::SecurityDomain* mutable_security_domain();
    void set_allocated_security_domain(::trusted_vault_pb::SecurityDomain* security_domain);

private:
    const ::trusted_vault_pb::SecurityDomain& _internal_security_domain() const;
    ::trusted_vault_pb::SecurityDomain* _internal_mutable_security_domain();

public:
    void unsafe_arena_set_allocated_security_domain(::trusted_vault_pb::SecurityDomain* security_domain);
    ::trusted_vault_pb::SecurityDomain* unsafe_arena_release_security_domain();

    // @@protoc_insertion_point(class_scope:trusted_vault_pb.JoinSecurityDomainsResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::trusted_vault_pb::SecurityDomain* security_domain_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class JoinSecurityDomainsErrorDetail final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.JoinSecurityDomainsErrorDetail) */ {
public:
    inline JoinSecurityDomainsErrorDetail()
        : JoinSecurityDomainsErrorDetail(nullptr)
    {
    }
    ~JoinSecurityDomainsErrorDetail() override;
    explicit PROTOBUF_CONSTEXPR JoinSecurityDomainsErrorDetail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    JoinSecurityDomainsErrorDetail(const JoinSecurityDomainsErrorDetail& from);
    JoinSecurityDomainsErrorDetail(JoinSecurityDomainsErrorDetail&& from) noexcept
        : JoinSecurityDomainsErrorDetail()
    {
        *this = ::std::move(from);
    }

    inline JoinSecurityDomainsErrorDetail& operator=(const JoinSecurityDomainsErrorDetail& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline JoinSecurityDomainsErrorDetail& operator=(JoinSecurityDomainsErrorDetail&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const JoinSecurityDomainsErrorDetail& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const JoinSecurityDomainsErrorDetail* internal_default_instance()
    {
        return reinterpret_cast<const JoinSecurityDomainsErrorDetail*>(&_JoinSecurityDomainsErrorDetail_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 14;

    friend void swap(JoinSecurityDomainsErrorDetail& a, JoinSecurityDomainsErrorDetail& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(JoinSecurityDomainsErrorDetail* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(JoinSecurityDomainsErrorDetail* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    JoinSecurityDomainsErrorDetail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<JoinSecurityDomainsErrorDetail>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const JoinSecurityDomainsErrorDetail& from);
    void MergeFrom(const JoinSecurityDomainsErrorDetail& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(JoinSecurityDomainsErrorDetail* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.JoinSecurityDomainsErrorDetail";
    }

protected:
    explicit JoinSecurityDomainsErrorDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kAlreadyExistsResponseFieldNumber = 1,
    };
    // .trusted_vault_pb.JoinSecurityDomainsResponse already_exists_response = 1;
    bool has_already_exists_response() const;

private:
    bool _internal_has_already_exists_response() const;

public:
    void clear_already_exists_response();
    const ::trusted_vault_pb::JoinSecurityDomainsResponse& already_exists_response() const;
    PROTOBUF_NODISCARD ::trusted_vault_pb::JoinSecurityDomainsResponse* release_already_exists_response();
    ::trusted_vault_pb::JoinSecurityDomainsResponse* mutable_already_exists_response();
    void set_allocated_already_exists_response(::trusted_vault_pb::JoinSecurityDomainsResponse* already_exists_response);

private:
    const ::trusted_vault_pb::JoinSecurityDomainsResponse& _internal_already_exists_response() const;
    ::trusted_vault_pb::JoinSecurityDomainsResponse* _internal_mutable_already_exists_response();

public:
    void unsafe_arena_set_allocated_already_exists_response(::trusted_vault_pb::JoinSecurityDomainsResponse* already_exists_response);
    ::trusted_vault_pb::JoinSecurityDomainsResponse* unsafe_arena_release_already_exists_response();

    // @@protoc_insertion_point(class_scope:trusted_vault_pb.JoinSecurityDomainsErrorDetail)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::trusted_vault_pb::JoinSecurityDomainsResponse* already_exists_response_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class ListSecurityDomainMembersResponse final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.ListSecurityDomainMembersResponse) */ {
public:
    inline ListSecurityDomainMembersResponse()
        : ListSecurityDomainMembersResponse(nullptr)
    {
    }
    ~ListSecurityDomainMembersResponse() override;
    explicit PROTOBUF_CONSTEXPR ListSecurityDomainMembersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ListSecurityDomainMembersResponse(const ListSecurityDomainMembersResponse& from);
    ListSecurityDomainMembersResponse(ListSecurityDomainMembersResponse&& from) noexcept
        : ListSecurityDomainMembersResponse()
    {
        *this = ::std::move(from);
    }

    inline ListSecurityDomainMembersResponse& operator=(const ListSecurityDomainMembersResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ListSecurityDomainMembersResponse& operator=(ListSecurityDomainMembersResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ListSecurityDomainMembersResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ListSecurityDomainMembersResponse* internal_default_instance()
    {
        return reinterpret_cast<const ListSecurityDomainMembersResponse*>(&_ListSecurityDomainMembersResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 15;

    friend void swap(ListSecurityDomainMembersResponse& a, ListSecurityDomainMembersResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ListSecurityDomainMembersResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ListSecurityDomainMembersResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ListSecurityDomainMembersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ListSecurityDomainMembersResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ListSecurityDomainMembersResponse& from);
    void MergeFrom(const ListSecurityDomainMembersResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ListSecurityDomainMembersResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.ListSecurityDomainMembersResponse";
    }

protected:
    explicit ListSecurityDomainMembersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSecurityDomainMembersFieldNumber = 1,
        kNextPageTokenFieldNumber = 2,
    };
    // repeated .trusted_vault_pb.SecurityDomainMember security_domain_members = 1;
    int security_domain_members_size() const;

private:
    int _internal_security_domain_members_size() const;

public:
    void clear_security_domain_members();
    ::trusted_vault_pb::SecurityDomainMember* mutable_security_domain_members(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SecurityDomainMember>* mutable_security_domain_members();

private:
    const ::trusted_vault_pb::SecurityDomainMember& _internal_security_domain_members(int index) const;
    ::trusted_vault_pb::SecurityDomainMember* _internal_add_security_domain_members();

public:
    const ::trusted_vault_pb::SecurityDomainMember& security_domain_members(int index) const;
    ::trusted_vault_pb::SecurityDomainMember* add_security_domain_members();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SecurityDomainMember>& security_domain_members() const;

    // string next_page_token = 2;
    void clear_next_page_token();
    const std::string& next_page_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_next_page_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_next_page_token();
    PROTOBUF_NODISCARD std::string* release_next_page_token();
    void set_allocated_next_page_token(std::string* next_page_token);

private:
    const std::string& _internal_next_page_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
    std::string* _internal_mutable_next_page_token();

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.ListSecurityDomainMembersResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SecurityDomainMember> security_domain_members_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class Proto3Any final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.Proto3Any) */ {
public:
    inline Proto3Any()
        : Proto3Any(nullptr)
    {
    }
    ~Proto3Any() override;
    explicit PROTOBUF_CONSTEXPR Proto3Any(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Proto3Any(const Proto3Any& from);
    Proto3Any(Proto3Any&& from) noexcept
        : Proto3Any()
    {
        *this = ::std::move(from);
    }

    inline Proto3Any& operator=(const Proto3Any& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Proto3Any& operator=(Proto3Any&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Proto3Any& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Proto3Any* internal_default_instance()
    {
        return reinterpret_cast<const Proto3Any*>(&_Proto3Any_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 16;

    friend void swap(Proto3Any& a, Proto3Any& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Proto3Any* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Proto3Any* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Proto3Any* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Proto3Any>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Proto3Any& from);
    void MergeFrom(const Proto3Any& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Proto3Any* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.Proto3Any";
    }

protected:
    explicit Proto3Any(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTypeUrlFieldNumber = 1,
        kValueFieldNumber = 2,
    };
    // string type_url = 1;
    void clear_type_url();
    const std::string& type_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_type_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_type_url();
    PROTOBUF_NODISCARD std::string* release_type_url();
    void set_allocated_type_url(std::string* type_url);

private:
    const std::string& _internal_type_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_type_url(const std::string& value);
    std::string* _internal_mutable_type_url();

public:
    // bytes value = 2;
    void clear_value();
    const std::string& value() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_value(ArgT0&& arg0, ArgT... args);
    std::string* mutable_value();
    PROTOBUF_NODISCARD std::string* release_value();
    void set_allocated_value(std::string* value);

private:
    const std::string& _internal_value() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
    std::string* _internal_mutable_value();

public:
    // @@protoc_insertion_point(class_scope:trusted_vault_pb.Proto3Any)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_url_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// -------------------------------------------------------------------

class RPCStatus final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:trusted_vault_pb.RPCStatus) */ {
public:
    inline RPCStatus()
        : RPCStatus(nullptr)
    {
    }
    ~RPCStatus() override;
    explicit PROTOBUF_CONSTEXPR RPCStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    RPCStatus(const RPCStatus& from);
    RPCStatus(RPCStatus&& from) noexcept
        : RPCStatus()
    {
        *this = ::std::move(from);
    }

    inline RPCStatus& operator=(const RPCStatus& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline RPCStatus& operator=(RPCStatus&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const RPCStatus& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const RPCStatus* internal_default_instance()
    {
        return reinterpret_cast<const RPCStatus*>(&_RPCStatus_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 17;

    friend void swap(RPCStatus& a, RPCStatus& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(RPCStatus* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(RPCStatus* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    RPCStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<RPCStatus>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const RPCStatus& from);
    void MergeFrom(const RPCStatus& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RPCStatus* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "trusted_vault_pb.RPCStatus";
    }

protected:
    explicit RPCStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDetailsFieldNumber = 3,
    };
    // repeated .trusted_vault_pb.Proto3Any details = 3;
    int details_size() const;

private:
    int _internal_details_size() const;

public:
    void clear_details();
    ::trusted_vault_pb::Proto3Any* mutable_details(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::Proto3Any>* mutable_details();

private:
    const ::trusted_vault_pb::Proto3Any& _internal_details(int index) const;
    ::trusted_vault_pb::Proto3Any* _internal_add_details();

public:
    const ::trusted_vault_pb::Proto3Any& details(int index) const;
    ::trusted_vault_pb::Proto3Any* add_details();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::Proto3Any>& details() const;

    // @@protoc_insertion_point(class_scope:trusted_vault_pb.RPCStatus)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::Proto3Any> details_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_vault_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// SharedMemberKey

// int32 epoch = 1;
inline void SharedMemberKey::clear_epoch()
{
    _impl_.epoch_ = 0;
}
inline int32_t SharedMemberKey::_internal_epoch() const
{
    return _impl_.epoch_;
}
inline int32_t SharedMemberKey::epoch() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SharedMemberKey.epoch)
    return _internal_epoch();
}
inline void SharedMemberKey::_internal_set_epoch(int32_t value)
{

    _impl_.epoch_ = value;
}
inline void SharedMemberKey::set_epoch(int32_t value)
{
    _internal_set_epoch(value);
    // @@protoc_insertion_point(field_set:trusted_vault_pb.SharedMemberKey.epoch)
}

// bytes wrapped_key = 2;
inline void SharedMemberKey::clear_wrapped_key()
{
    _impl_.wrapped_key_.ClearToEmpty();
}
inline const std::string& SharedMemberKey::wrapped_key() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SharedMemberKey.wrapped_key)
    return _internal_wrapped_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SharedMemberKey::set_wrapped_key(ArgT0&& arg0, ArgT... args)
{

    _impl_.wrapped_key_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.SharedMemberKey.wrapped_key)
}
inline std::string* SharedMemberKey::mutable_wrapped_key()
{
    std::string* _s = _internal_mutable_wrapped_key();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SharedMemberKey.wrapped_key)
    return _s;
}
inline const std::string& SharedMemberKey::_internal_wrapped_key() const
{
    return _impl_.wrapped_key_.Get();
}
inline void SharedMemberKey::_internal_set_wrapped_key(const std::string& value)
{

    _impl_.wrapped_key_.Set(value, GetArenaForAllocation());
}
inline std::string* SharedMemberKey::_internal_mutable_wrapped_key()
{

    return _impl_.wrapped_key_.Mutable(GetArenaForAllocation());
}
inline std::string* SharedMemberKey::release_wrapped_key()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.SharedMemberKey.wrapped_key)
    return _impl_.wrapped_key_.Release();
}
inline void SharedMemberKey::set_allocated_wrapped_key(std::string* wrapped_key)
{
    if (wrapped_key != nullptr) {

    } else {
    }
    _impl_.wrapped_key_.SetAllocated(wrapped_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.wrapped_key_.IsDefault()) {
        _impl_.wrapped_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.SharedMemberKey.wrapped_key)
}

// bytes member_proof = 3;
inline void SharedMemberKey::clear_member_proof()
{
    _impl_.member_proof_.ClearToEmpty();
}
inline const std::string& SharedMemberKey::member_proof() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SharedMemberKey.member_proof)
    return _internal_member_proof();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SharedMemberKey::set_member_proof(ArgT0&& arg0, ArgT... args)
{

    _impl_.member_proof_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.SharedMemberKey.member_proof)
}
inline std::string* SharedMemberKey::mutable_member_proof()
{
    std::string* _s = _internal_mutable_member_proof();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SharedMemberKey.member_proof)
    return _s;
}
inline const std::string& SharedMemberKey::_internal_member_proof() const
{
    return _impl_.member_proof_.Get();
}
inline void SharedMemberKey::_internal_set_member_proof(const std::string& value)
{

    _impl_.member_proof_.Set(value, GetArenaForAllocation());
}
inline std::string* SharedMemberKey::_internal_mutable_member_proof()
{

    return _impl_.member_proof_.Mutable(GetArenaForAllocation());
}
inline std::string* SharedMemberKey::release_member_proof()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.SharedMemberKey.member_proof)
    return _impl_.member_proof_.Release();
}
inline void SharedMemberKey::set_allocated_member_proof(std::string* member_proof)
{
    if (member_proof != nullptr) {

    } else {
    }
    _impl_.member_proof_.SetAllocated(member_proof, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.member_proof_.IsDefault()) {
        _impl_.member_proof_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.SharedMemberKey.member_proof)
}

// -------------------------------------------------------------------

// RotationProof

// int32 new_epoch = 1;
inline void RotationProof::clear_new_epoch()
{
    _impl_.new_epoch_ = 0;
}
inline int32_t RotationProof::_internal_new_epoch() const
{
    return _impl_.new_epoch_;
}
inline int32_t RotationProof::new_epoch() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.RotationProof.new_epoch)
    return _internal_new_epoch();
}
inline void RotationProof::_internal_set_new_epoch(int32_t value)
{

    _impl_.new_epoch_ = value;
}
inline void RotationProof::set_new_epoch(int32_t value)
{
    _internal_set_new_epoch(value);
    // @@protoc_insertion_point(field_set:trusted_vault_pb.RotationProof.new_epoch)
}

// bytes rotation_proof = 2;
inline void RotationProof::clear_rotation_proof()
{
    _impl_.rotation_proof_.ClearToEmpty();
}
inline const std::string& RotationProof::rotation_proof() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.RotationProof.rotation_proof)
    return _internal_rotation_proof();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void RotationProof::set_rotation_proof(ArgT0&& arg0, ArgT... args)
{

    _impl_.rotation_proof_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.RotationProof.rotation_proof)
}
inline std::string* RotationProof::mutable_rotation_proof()
{
    std::string* _s = _internal_mutable_rotation_proof();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.RotationProof.rotation_proof)
    return _s;
}
inline const std::string& RotationProof::_internal_rotation_proof() const
{
    return _impl_.rotation_proof_.Get();
}
inline void RotationProof::_internal_set_rotation_proof(const std::string& value)
{

    _impl_.rotation_proof_.Set(value, GetArenaForAllocation());
}
inline std::string* RotationProof::_internal_mutable_rotation_proof()
{

    return _impl_.rotation_proof_.Mutable(GetArenaForAllocation());
}
inline std::string* RotationProof::release_rotation_proof()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.RotationProof.rotation_proof)
    return _impl_.rotation_proof_.Release();
}
inline void RotationProof::set_allocated_rotation_proof(std::string* rotation_proof)
{
    if (rotation_proof != nullptr) {

    } else {
    }
    _impl_.rotation_proof_.SetAllocated(rotation_proof, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.rotation_proof_.IsDefault()) {
        _impl_.rotation_proof_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.RotationProof.rotation_proof)
}

// -------------------------------------------------------------------

// SecurityDomainDetails_SyncDetails

// bool degraded_recoverability = 1;
inline void SecurityDomainDetails_SyncDetails::clear_degraded_recoverability()
{
    _impl_.degraded_recoverability_ = false;
}
inline bool SecurityDomainDetails_SyncDetails::_internal_degraded_recoverability() const
{
    return _impl_.degraded_recoverability_;
}
inline bool SecurityDomainDetails_SyncDetails::degraded_recoverability() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomainDetails.SyncDetails.degraded_recoverability)
    return _internal_degraded_recoverability();
}
inline void SecurityDomainDetails_SyncDetails::_internal_set_degraded_recoverability(bool value)
{

    _impl_.degraded_recoverability_ = value;
}
inline void SecurityDomainDetails_SyncDetails::set_degraded_recoverability(bool value)
{
    _internal_set_degraded_recoverability(value);
    // @@protoc_insertion_point(field_set:trusted_vault_pb.SecurityDomainDetails.SyncDetails.degraded_recoverability)
}

// -------------------------------------------------------------------

// SecurityDomainDetails

// .trusted_vault_pb.SecurityDomainDetails.SyncDetails sync_details = 1;
inline bool SecurityDomainDetails::_internal_has_sync_details() const
{
    return this != internal_default_instance() && _impl_.sync_details_ != nullptr;
}
inline bool SecurityDomainDetails::has_sync_details() const
{
    return _internal_has_sync_details();
}
inline void SecurityDomainDetails::clear_sync_details()
{
    if (GetArenaForAllocation() == nullptr && _impl_.sync_details_ != nullptr) {
        delete _impl_.sync_details_;
    }
    _impl_.sync_details_ = nullptr;
}
inline const ::trusted_vault_pb::SecurityDomainDetails_SyncDetails& SecurityDomainDetails::_internal_sync_details() const
{
    const ::trusted_vault_pb::SecurityDomainDetails_SyncDetails* p = _impl_.sync_details_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::trusted_vault_pb::SecurityDomainDetails_SyncDetails&>(
                            ::trusted_vault_pb::_SecurityDomainDetails_SyncDetails_default_instance_);
}
inline const ::trusted_vault_pb::SecurityDomainDetails_SyncDetails& SecurityDomainDetails::sync_details() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomainDetails.sync_details)
    return _internal_sync_details();
}
inline void SecurityDomainDetails::unsafe_arena_set_allocated_sync_details(::trusted_vault_pb::SecurityDomainDetails_SyncDetails* sync_details)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sync_details_);
    }
    _impl_.sync_details_ = sync_details;
    if (sync_details) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.SecurityDomainDetails.sync_details)
}
inline ::trusted_vault_pb::SecurityDomainDetails_SyncDetails* SecurityDomainDetails::release_sync_details()
{

    ::trusted_vault_pb::SecurityDomainDetails_SyncDetails* temp = _impl_.sync_details_;
    _impl_.sync_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::trusted_vault_pb::SecurityDomainDetails_SyncDetails* SecurityDomainDetails::unsafe_arena_release_sync_details()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.SecurityDomainDetails.sync_details)

    ::trusted_vault_pb::SecurityDomainDetails_SyncDetails* temp = _impl_.sync_details_;
    _impl_.sync_details_ = nullptr;
    return temp;
}
inline ::trusted_vault_pb::SecurityDomainDetails_SyncDetails* SecurityDomainDetails::_internal_mutable_sync_details()
{

    if (_impl_.sync_details_ == nullptr) {
        auto* p = CreateMaybeMessage<::trusted_vault_pb::SecurityDomainDetails_SyncDetails>(GetArenaForAllocation());
        _impl_.sync_details_ = p;
    }
    return _impl_.sync_details_;
}
inline ::trusted_vault_pb::SecurityDomainDetails_SyncDetails* SecurityDomainDetails::mutable_sync_details()
{
    ::trusted_vault_pb::SecurityDomainDetails_SyncDetails* _msg = _internal_mutable_sync_details();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SecurityDomainDetails.sync_details)
    return _msg;
}
inline void SecurityDomainDetails::set_allocated_sync_details(::trusted_vault_pb::SecurityDomainDetails_SyncDetails* sync_details)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.sync_details_;
    }
    if (sync_details) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sync_details);
        if (message_arena != submessage_arena) {
            sync_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, sync_details, submessage_arena);
        }

    } else {
    }
    _impl_.sync_details_ = sync_details;
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.SecurityDomainDetails.sync_details)
}

// -------------------------------------------------------------------

// SecurityDomain

// string name = 1;
inline void SecurityDomain::clear_name()
{
    _impl_.name_.ClearToEmpty();
}
inline const std::string& SecurityDomain::name() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomain.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SecurityDomain::set_name(ArgT0&& arg0, ArgT... args)
{

    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.SecurityDomain.name)
}
inline std::string* SecurityDomain::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SecurityDomain.name)
    return _s;
}
inline const std::string& SecurityDomain::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void SecurityDomain::_internal_set_name(const std::string& value)
{

    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityDomain::_internal_mutable_name()
{

    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityDomain::release_name()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.SecurityDomain.name)
    return _impl_.name_.Release();
}
inline void SecurityDomain::set_allocated_name(std::string* name)
{
    if (name != nullptr) {

    } else {
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.SecurityDomain.name)
}

// int32 current_epoch = 2;
inline void SecurityDomain::clear_current_epoch()
{
    _impl_.current_epoch_ = 0;
}
inline int32_t SecurityDomain::_internal_current_epoch() const
{
    return _impl_.current_epoch_;
}
inline int32_t SecurityDomain::current_epoch() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomain.current_epoch)
    return _internal_current_epoch();
}
inline void SecurityDomain::_internal_set_current_epoch(int32_t value)
{

    _impl_.current_epoch_ = value;
}
inline void SecurityDomain::set_current_epoch(int32_t value)
{
    _internal_set_current_epoch(value);
    // @@protoc_insertion_point(field_set:trusted_vault_pb.SecurityDomain.current_epoch)
}

// .trusted_vault_pb.SecurityDomainDetails security_domain_details = 3;
inline bool SecurityDomain::_internal_has_security_domain_details() const
{
    return this != internal_default_instance() && _impl_.security_domain_details_ != nullptr;
}
inline bool SecurityDomain::has_security_domain_details() const
{
    return _internal_has_security_domain_details();
}
inline void SecurityDomain::clear_security_domain_details()
{
    if (GetArenaForAllocation() == nullptr && _impl_.security_domain_details_ != nullptr) {
        delete _impl_.security_domain_details_;
    }
    _impl_.security_domain_details_ = nullptr;
}
inline const ::trusted_vault_pb::SecurityDomainDetails& SecurityDomain::_internal_security_domain_details() const
{
    const ::trusted_vault_pb::SecurityDomainDetails* p = _impl_.security_domain_details_;
    return p != nullptr ? *p : reinterpret_cast<const ::trusted_vault_pb::SecurityDomainDetails&>(::trusted_vault_pb::_SecurityDomainDetails_default_instance_);
}
inline const ::trusted_vault_pb::SecurityDomainDetails& SecurityDomain::security_domain_details() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomain.security_domain_details)
    return _internal_security_domain_details();
}
inline void SecurityDomain::unsafe_arena_set_allocated_security_domain_details(::trusted_vault_pb::SecurityDomainDetails* security_domain_details)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.security_domain_details_);
    }
    _impl_.security_domain_details_ = security_domain_details;
    if (security_domain_details) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.SecurityDomain.security_domain_details)
}
inline ::trusted_vault_pb::SecurityDomainDetails* SecurityDomain::release_security_domain_details()
{

    ::trusted_vault_pb::SecurityDomainDetails* temp = _impl_.security_domain_details_;
    _impl_.security_domain_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::trusted_vault_pb::SecurityDomainDetails* SecurityDomain::unsafe_arena_release_security_domain_details()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.SecurityDomain.security_domain_details)

    ::trusted_vault_pb::SecurityDomainDetails* temp = _impl_.security_domain_details_;
    _impl_.security_domain_details_ = nullptr;
    return temp;
}
inline ::trusted_vault_pb::SecurityDomainDetails* SecurityDomain::_internal_mutable_security_domain_details()
{

    if (_impl_.security_domain_details_ == nullptr) {
        auto* p = CreateMaybeMessage<::trusted_vault_pb::SecurityDomainDetails>(GetArenaForAllocation());
        _impl_.security_domain_details_ = p;
    }
    return _impl_.security_domain_details_;
}
inline ::trusted_vault_pb::SecurityDomainDetails* SecurityDomain::mutable_security_domain_details()
{
    ::trusted_vault_pb::SecurityDomainDetails* _msg = _internal_mutable_security_domain_details();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SecurityDomain.security_domain_details)
    return _msg;
}
inline void SecurityDomain::set_allocated_security_domain_details(::trusted_vault_pb::SecurityDomainDetails* security_domain_details)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.security_domain_details_;
    }
    if (security_domain_details) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(security_domain_details);
        if (message_arena != submessage_arena) {
            security_domain_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, security_domain_details, submessage_arena);
        }

    } else {
    }
    _impl_.security_domain_details_ = security_domain_details;
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.SecurityDomain.security_domain_details)
}

// -------------------------------------------------------------------

// Timestamp

// int64 seconds = 1;
inline void Timestamp::clear_seconds()
{
    _impl_.seconds_ = int64_t { 0 };
}
inline int64_t Timestamp::_internal_seconds() const
{
    return _impl_.seconds_;
}
inline int64_t Timestamp::seconds() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.Timestamp.seconds)
    return _internal_seconds();
}
inline void Timestamp::_internal_set_seconds(int64_t value)
{

    _impl_.seconds_ = value;
}
inline void Timestamp::set_seconds(int64_t value)
{
    _internal_set_seconds(value);
    // @@protoc_insertion_point(field_set:trusted_vault_pb.Timestamp.seconds)
}

// int32 nanos = 2;
inline void Timestamp::clear_nanos()
{
    _impl_.nanos_ = 0;
}
inline int32_t Timestamp::_internal_nanos() const
{
    return _impl_.nanos_;
}
inline int32_t Timestamp::nanos() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.Timestamp.nanos)
    return _internal_nanos();
}
inline void Timestamp::_internal_set_nanos(int32_t value)
{

    _impl_.nanos_ = value;
}
inline void Timestamp::set_nanos(int32_t value)
{
    _internal_set_nanos(value);
    // @@protoc_insertion_point(field_set:trusted_vault_pb.Timestamp.nanos)
}

// -------------------------------------------------------------------

// PhysicalDeviceMetadata

// .trusted_vault_pb.PhysicalDeviceMetadata.DeviceType device_type = 1;
inline void PhysicalDeviceMetadata::clear_device_type()
{
    _impl_.device_type_ = 0;
}
inline ::trusted_vault_pb::PhysicalDeviceMetadata_DeviceType PhysicalDeviceMetadata::_internal_device_type() const
{
    return static_cast<::trusted_vault_pb::PhysicalDeviceMetadata_DeviceType>(_impl_.device_type_);
}
inline ::trusted_vault_pb::PhysicalDeviceMetadata_DeviceType PhysicalDeviceMetadata::device_type() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.PhysicalDeviceMetadata.device_type)
    return _internal_device_type();
}
inline void PhysicalDeviceMetadata::_internal_set_device_type(::trusted_vault_pb::PhysicalDeviceMetadata_DeviceType value)
{

    _impl_.device_type_ = value;
}
inline void PhysicalDeviceMetadata::set_device_type(::trusted_vault_pb::PhysicalDeviceMetadata_DeviceType value)
{
    _internal_set_device_type(value);
    // @@protoc_insertion_point(field_set:trusted_vault_pb.PhysicalDeviceMetadata.device_type)
}

// -------------------------------------------------------------------

// LskfMetadata

// .trusted_vault_pb.Timestamp expiration_time = 1;
inline bool LskfMetadata::_internal_has_expiration_time() const
{
    return this != internal_default_instance() && _impl_.expiration_time_ != nullptr;
}
inline bool LskfMetadata::has_expiration_time() const
{
    return _internal_has_expiration_time();
}
inline void LskfMetadata::clear_expiration_time()
{
    if (GetArenaForAllocation() == nullptr && _impl_.expiration_time_ != nullptr) {
        delete _impl_.expiration_time_;
    }
    _impl_.expiration_time_ = nullptr;
}
inline const ::trusted_vault_pb::Timestamp& LskfMetadata::_internal_expiration_time() const
{
    const ::trusted_vault_pb::Timestamp* p = _impl_.expiration_time_;
    return p != nullptr ? *p : reinterpret_cast<const ::trusted_vault_pb::Timestamp&>(::trusted_vault_pb::_Timestamp_default_instance_);
}
inline const ::trusted_vault_pb::Timestamp& LskfMetadata::expiration_time() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.LskfMetadata.expiration_time)
    return _internal_expiration_time();
}
inline void LskfMetadata::unsafe_arena_set_allocated_expiration_time(::trusted_vault_pb::Timestamp* expiration_time)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expiration_time_);
    }
    _impl_.expiration_time_ = expiration_time;
    if (expiration_time) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.LskfMetadata.expiration_time)
}
inline ::trusted_vault_pb::Timestamp* LskfMetadata::release_expiration_time()
{

    ::trusted_vault_pb::Timestamp* temp = _impl_.expiration_time_;
    _impl_.expiration_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::trusted_vault_pb::Timestamp* LskfMetadata::unsafe_arena_release_expiration_time()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.LskfMetadata.expiration_time)

    ::trusted_vault_pb::Timestamp* temp = _impl_.expiration_time_;
    _impl_.expiration_time_ = nullptr;
    return temp;
}
inline ::trusted_vault_pb::Timestamp* LskfMetadata::_internal_mutable_expiration_time()
{

    if (_impl_.expiration_time_ == nullptr) {
        auto* p = CreateMaybeMessage<::trusted_vault_pb::Timestamp>(GetArenaForAllocation());
        _impl_.expiration_time_ = p;
    }
    return _impl_.expiration_time_;
}
inline ::trusted_vault_pb::Timestamp* LskfMetadata::mutable_expiration_time()
{
    ::trusted_vault_pb::Timestamp* _msg = _internal_mutable_expiration_time();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.LskfMetadata.expiration_time)
    return _msg;
}
inline void LskfMetadata::set_allocated_expiration_time(::trusted_vault_pb::Timestamp* expiration_time)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.expiration_time_;
    }
    if (expiration_time) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expiration_time);
        if (message_arena != submessage_arena) {
            expiration_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, expiration_time, submessage_arena);
        }

    } else {
    }
    _impl_.expiration_time_ = expiration_time;
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.LskfMetadata.expiration_time)
}

// -------------------------------------------------------------------

// GooglePasswordManagerPinMetadata

// .trusted_vault_pb.Timestamp expiration_time = 1;
inline bool GooglePasswordManagerPinMetadata::_internal_has_expiration_time() const
{
    return this != internal_default_instance() && _impl_.expiration_time_ != nullptr;
}
inline bool GooglePasswordManagerPinMetadata::has_expiration_time() const
{
    return _internal_has_expiration_time();
}
inline void GooglePasswordManagerPinMetadata::clear_expiration_time()
{
    if (GetArenaForAllocation() == nullptr && _impl_.expiration_time_ != nullptr) {
        delete _impl_.expiration_time_;
    }
    _impl_.expiration_time_ = nullptr;
}
inline const ::trusted_vault_pb::Timestamp& GooglePasswordManagerPinMetadata::_internal_expiration_time() const
{
    const ::trusted_vault_pb::Timestamp* p = _impl_.expiration_time_;
    return p != nullptr ? *p : reinterpret_cast<const ::trusted_vault_pb::Timestamp&>(::trusted_vault_pb::_Timestamp_default_instance_);
}
inline const ::trusted_vault_pb::Timestamp& GooglePasswordManagerPinMetadata::expiration_time() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.GooglePasswordManagerPinMetadata.expiration_time)
    return _internal_expiration_time();
}
inline void GooglePasswordManagerPinMetadata::unsafe_arena_set_allocated_expiration_time(::trusted_vault_pb::Timestamp* expiration_time)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expiration_time_);
    }
    _impl_.expiration_time_ = expiration_time;
    if (expiration_time) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.GooglePasswordManagerPinMetadata.expiration_time)
}
inline ::trusted_vault_pb::Timestamp* GooglePasswordManagerPinMetadata::release_expiration_time()
{

    ::trusted_vault_pb::Timestamp* temp = _impl_.expiration_time_;
    _impl_.expiration_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::trusted_vault_pb::Timestamp* GooglePasswordManagerPinMetadata::unsafe_arena_release_expiration_time()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.GooglePasswordManagerPinMetadata.expiration_time)

    ::trusted_vault_pb::Timestamp* temp = _impl_.expiration_time_;
    _impl_.expiration_time_ = nullptr;
    return temp;
}
inline ::trusted_vault_pb::Timestamp* GooglePasswordManagerPinMetadata::_internal_mutable_expiration_time()
{

    if (_impl_.expiration_time_ == nullptr) {
        auto* p = CreateMaybeMessage<::trusted_vault_pb::Timestamp>(GetArenaForAllocation());
        _impl_.expiration_time_ = p;
    }
    return _impl_.expiration_time_;
}
inline ::trusted_vault_pb::Timestamp* GooglePasswordManagerPinMetadata::mutable_expiration_time()
{
    ::trusted_vault_pb::Timestamp* _msg = _internal_mutable_expiration_time();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.GooglePasswordManagerPinMetadata.expiration_time)
    return _msg;
}
inline void GooglePasswordManagerPinMetadata::set_allocated_expiration_time(::trusted_vault_pb::Timestamp* expiration_time)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.expiration_time_;
    }
    if (expiration_time) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(expiration_time);
        if (message_arena != submessage_arena) {
            expiration_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, expiration_time, submessage_arena);
        }

    } else {
    }
    _impl_.expiration_time_ = expiration_time;
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.GooglePasswordManagerPinMetadata.expiration_time)
}

// bytes encrypted_pin_hash = 2;
inline void GooglePasswordManagerPinMetadata::clear_encrypted_pin_hash()
{
    _impl_.encrypted_pin_hash_.ClearToEmpty();
}
inline const std::string& GooglePasswordManagerPinMetadata::encrypted_pin_hash() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.GooglePasswordManagerPinMetadata.encrypted_pin_hash)
    return _internal_encrypted_pin_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void GooglePasswordManagerPinMetadata::set_encrypted_pin_hash(ArgT0&& arg0, ArgT... args)
{

    _impl_.encrypted_pin_hash_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.GooglePasswordManagerPinMetadata.encrypted_pin_hash)
}
inline std::string* GooglePasswordManagerPinMetadata::mutable_encrypted_pin_hash()
{
    std::string* _s = _internal_mutable_encrypted_pin_hash();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.GooglePasswordManagerPinMetadata.encrypted_pin_hash)
    return _s;
}
inline const std::string& GooglePasswordManagerPinMetadata::_internal_encrypted_pin_hash() const
{
    return _impl_.encrypted_pin_hash_.Get();
}
inline void GooglePasswordManagerPinMetadata::_internal_set_encrypted_pin_hash(const std::string& value)
{

    _impl_.encrypted_pin_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* GooglePasswordManagerPinMetadata::_internal_mutable_encrypted_pin_hash()
{

    return _impl_.encrypted_pin_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* GooglePasswordManagerPinMetadata::release_encrypted_pin_hash()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.GooglePasswordManagerPinMetadata.encrypted_pin_hash)
    return _impl_.encrypted_pin_hash_.Release();
}
inline void GooglePasswordManagerPinMetadata::set_allocated_encrypted_pin_hash(std::string* encrypted_pin_hash)
{
    if (encrypted_pin_hash != nullptr) {

    } else {
    }
    _impl_.encrypted_pin_hash_.SetAllocated(encrypted_pin_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.encrypted_pin_hash_.IsDefault()) {
        _impl_.encrypted_pin_hash_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.GooglePasswordManagerPinMetadata.encrypted_pin_hash)
}

// -------------------------------------------------------------------

// SecurityDomainMember_SecurityDomainMembership

// string security_domain = 1;
inline void SecurityDomainMember_SecurityDomainMembership::clear_security_domain()
{
    _impl_.security_domain_.ClearToEmpty();
}
inline const std::string& SecurityDomainMember_SecurityDomainMembership::security_domain() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.security_domain)
    return _internal_security_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void SecurityDomainMember_SecurityDomainMembership::set_security_domain(ArgT0&& arg0, ArgT... args)
{

    _impl_.security_domain_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.security_domain)
}
inline std::string* SecurityDomainMember_SecurityDomainMembership::mutable_security_domain()
{
    std::string* _s = _internal_mutable_security_domain();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.security_domain)
    return _s;
}
inline const std::string& SecurityDomainMember_SecurityDomainMembership::_internal_security_domain() const
{
    return _impl_.security_domain_.Get();
}
inline void SecurityDomainMember_SecurityDomainMembership::_internal_set_security_domain(const std::string& value)
{

    _impl_.security_domain_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityDomainMember_SecurityDomainMembership::_internal_mutable_security_domain()
{

    return _impl_.security_domain_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityDomainMember_SecurityDomainMembership::release_security_domain()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.security_domain)
    return _impl_.security_domain_.Release();
}
inline void SecurityDomainMember_SecurityDomainMembership::set_allocated_security_domain(std::string* security_domain)
{
    if (security_domain != nullptr) {

    } else {
    }
    _impl_.security_domain_.SetAllocated(security_domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.security_domain_.IsDefault()) {
        _impl_.security_domain_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.security_domain)
}

// repeated .trusted_vault_pb.SharedMemberKey keys = 3;
inline int SecurityDomainMember_SecurityDomainMembership::_internal_keys_size() const
{
    return _impl_.keys_.size();
}
inline int SecurityDomainMember_SecurityDomainMembership::keys_size() const
{
    return _internal_keys_size();
}
inline void SecurityDomainMember_SecurityDomainMembership::clear_keys()
{
    _impl_.keys_.Clear();
}
inline ::trusted_vault_pb::SharedMemberKey* SecurityDomainMember_SecurityDomainMembership::mutable_keys(int index)
{
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.keys)
    return _impl_.keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SharedMemberKey>* SecurityDomainMember_SecurityDomainMembership::mutable_keys()
{
    // @@protoc_insertion_point(field_mutable_list:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.keys)
    return &_impl_.keys_;
}
inline const ::trusted_vault_pb::SharedMemberKey& SecurityDomainMember_SecurityDomainMembership::_internal_keys(int index) const
{
    return _impl_.keys_.Get(index);
}
inline const ::trusted_vault_pb::SharedMemberKey& SecurityDomainMember_SecurityDomainMembership::keys(int index) const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.keys)
    return _internal_keys(index);
}
inline ::trusted_vault_pb::SharedMemberKey* SecurityDomainMember_SecurityDomainMembership::_internal_add_keys()
{
    return _impl_.keys_.Add();
}
inline ::trusted_vault_pb::SharedMemberKey* SecurityDomainMember_SecurityDomainMembership::add_keys()
{
    ::trusted_vault_pb::SharedMemberKey* _add = _internal_add_keys();
    // @@protoc_insertion_point(field_add:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.keys)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SharedMemberKey>& SecurityDomainMember_SecurityDomainMembership::keys() const
{
    // @@protoc_insertion_point(field_list:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.keys)
    return _impl_.keys_;
}

// repeated .trusted_vault_pb.RotationProof rotation_proofs = 4;
inline int SecurityDomainMember_SecurityDomainMembership::_internal_rotation_proofs_size() const
{
    return _impl_.rotation_proofs_.size();
}
inline int SecurityDomainMember_SecurityDomainMembership::rotation_proofs_size() const
{
    return _internal_rotation_proofs_size();
}
inline void SecurityDomainMember_SecurityDomainMembership::clear_rotation_proofs()
{
    _impl_.rotation_proofs_.Clear();
}
inline ::trusted_vault_pb::RotationProof* SecurityDomainMember_SecurityDomainMembership::mutable_rotation_proofs(int index)
{
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.rotation_proofs)
    return _impl_.rotation_proofs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::RotationProof>* SecurityDomainMember_SecurityDomainMembership::mutable_rotation_proofs()
{
    // @@protoc_insertion_point(field_mutable_list:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.rotation_proofs)
    return &_impl_.rotation_proofs_;
}
inline const ::trusted_vault_pb::RotationProof& SecurityDomainMember_SecurityDomainMembership::_internal_rotation_proofs(int index) const
{
    return _impl_.rotation_proofs_.Get(index);
}
inline const ::trusted_vault_pb::RotationProof& SecurityDomainMember_SecurityDomainMembership::rotation_proofs(int index) const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.rotation_proofs)
    return _internal_rotation_proofs(index);
}
inline ::trusted_vault_pb::RotationProof* SecurityDomainMember_SecurityDomainMembership::_internal_add_rotation_proofs()
{
    return _impl_.rotation_proofs_.Add();
}
inline ::trusted_vault_pb::RotationProof* SecurityDomainMember_SecurityDomainMembership::add_rotation_proofs()
{
    ::trusted_vault_pb::RotationProof* _add = _internal_add_rotation_proofs();
    // @@protoc_insertion_point(field_add:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.rotation_proofs)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::RotationProof>&
SecurityDomainMember_SecurityDomainMembership::rotation_proofs() const
{
    // @@protoc_insertion_point(field_list:trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership.rotation_proofs)
    return _impl_.rotation_proofs_;
}

// -------------------------------------------------------------------

// SecurityDomainMember_MemberMetadata

// bool usable_for_retrieval = 1;
inline void SecurityDomainMember_MemberMetadata::clear_usable_for_retrieval()
{
    _impl_.usable_for_retrieval_ = false;
}
inline bool SecurityDomainMember_MemberMetadata::_internal_usable_for_retrieval() const
{
    return _impl_.usable_for_retrieval_;
}
inline bool SecurityDomainMember_MemberMetadata::usable_for_retrieval() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomainMember.MemberMetadata.usable_for_retrieval)
    return _internal_usable_for_retrieval();
}
inline void SecurityDomainMember_MemberMetadata::_internal_set_usable_for_retrieval(bool value)
{

    _impl_.usable_for_retrieval_ = value;
}
inline void SecurityDomainMember_MemberMetadata::set_usable_for_retrieval(bool value)
{
    _internal_set_usable_for_retrieval(value);
    // @@protoc_insertion_point(field_set:trusted_vault_pb.SecurityDomainMember.MemberMetadata.usable_for_retrieval)
}

// .trusted_vault_pb.PhysicalDeviceMetadata physical_device_metadata = 3;
inline bool SecurityDomainMember_MemberMetadata::_internal_has_physical_device_metadata() const
{
    return member_metadata_variant_case() == kPhysicalDeviceMetadata;
}
inline bool SecurityDomainMember_MemberMetadata::has_physical_device_metadata() const
{
    return _internal_has_physical_device_metadata();
}
inline void SecurityDomainMember_MemberMetadata::set_has_physical_device_metadata()
{
    _impl_._oneof_case_[0] = kPhysicalDeviceMetadata;
}
inline void SecurityDomainMember_MemberMetadata::clear_physical_device_metadata()
{
    if (_internal_has_physical_device_metadata()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.member_metadata_variant_.physical_device_metadata_;
        }
        clear_has_member_metadata_variant();
    }
}
inline ::trusted_vault_pb::PhysicalDeviceMetadata* SecurityDomainMember_MemberMetadata::release_physical_device_metadata()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.SecurityDomainMember.MemberMetadata.physical_device_metadata)
    if (_internal_has_physical_device_metadata()) {
        clear_has_member_metadata_variant();
        ::trusted_vault_pb::PhysicalDeviceMetadata* temp = _impl_.member_metadata_variant_.physical_device_metadata_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.member_metadata_variant_.physical_device_metadata_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::trusted_vault_pb::PhysicalDeviceMetadata& SecurityDomainMember_MemberMetadata::_internal_physical_device_metadata() const
{
    return _internal_has_physical_device_metadata()
        ? *_impl_.member_metadata_variant_.physical_device_metadata_
        : reinterpret_cast<::trusted_vault_pb::PhysicalDeviceMetadata&>(::trusted_vault_pb::_PhysicalDeviceMetadata_default_instance_);
}
inline const ::trusted_vault_pb::PhysicalDeviceMetadata& SecurityDomainMember_MemberMetadata::physical_device_metadata() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomainMember.MemberMetadata.physical_device_metadata)
    return _internal_physical_device_metadata();
}
inline ::trusted_vault_pb::PhysicalDeviceMetadata* SecurityDomainMember_MemberMetadata::unsafe_arena_release_physical_device_metadata()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:trusted_vault_pb.SecurityDomainMember.MemberMetadata.physical_device_metadata)
    if (_internal_has_physical_device_metadata()) {
        clear_has_member_metadata_variant();
        ::trusted_vault_pb::PhysicalDeviceMetadata* temp = _impl_.member_metadata_variant_.physical_device_metadata_;
        _impl_.member_metadata_variant_.physical_device_metadata_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void SecurityDomainMember_MemberMetadata::unsafe_arena_set_allocated_physical_device_metadata(
    ::trusted_vault_pb::PhysicalDeviceMetadata* physical_device_metadata)
{
    clear_member_metadata_variant();
    if (physical_device_metadata) {
        set_has_physical_device_metadata();
        _impl_.member_metadata_variant_.physical_device_metadata_ = physical_device_metadata;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.SecurityDomainMember.MemberMetadata.physical_device_metadata)
}
inline ::trusted_vault_pb::PhysicalDeviceMetadata* SecurityDomainMember_MemberMetadata::_internal_mutable_physical_device_metadata()
{
    if (!_internal_has_physical_device_metadata()) {
        clear_member_metadata_variant();
        set_has_physical_device_metadata();
        _impl_.member_metadata_variant_.physical_device_metadata_ = CreateMaybeMessage<::trusted_vault_pb::PhysicalDeviceMetadata>(GetArenaForAllocation());
    }
    return _impl_.member_metadata_variant_.physical_device_metadata_;
}
inline ::trusted_vault_pb::PhysicalDeviceMetadata* SecurityDomainMember_MemberMetadata::mutable_physical_device_metadata()
{
    ::trusted_vault_pb::PhysicalDeviceMetadata* _msg = _internal_mutable_physical_device_metadata();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SecurityDomainMember.MemberMetadata.physical_device_metadata)
    return _msg;
}

// .trusted_vault_pb.LskfMetadata lskf_metadata = 4;
inline bool SecurityDomainMember_MemberMetadata::_internal_has_lskf_metadata() const
{
    return member_metadata_variant_case() == kLskfMetadata;
}
inline bool SecurityDomainMember_MemberMetadata::has_lskf_metadata() const
{
    return _internal_has_lskf_metadata();
}
inline void SecurityDomainMember_MemberMetadata::set_has_lskf_metadata()
{
    _impl_._oneof_case_[0] = kLskfMetadata;
}
inline void SecurityDomainMember_MemberMetadata::clear_lskf_metadata()
{
    if (_internal_has_lskf_metadata()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.member_metadata_variant_.lskf_metadata_;
        }
        clear_has_member_metadata_variant();
    }
}
inline ::trusted_vault_pb::LskfMetadata* SecurityDomainMember_MemberMetadata::release_lskf_metadata()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.SecurityDomainMember.MemberMetadata.lskf_metadata)
    if (_internal_has_lskf_metadata()) {
        clear_has_member_metadata_variant();
        ::trusted_vault_pb::LskfMetadata* temp = _impl_.member_metadata_variant_.lskf_metadata_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.member_metadata_variant_.lskf_metadata_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::trusted_vault_pb::LskfMetadata& SecurityDomainMember_MemberMetadata::_internal_lskf_metadata() const
{
    return _internal_has_lskf_metadata() ? *_impl_.member_metadata_variant_.lskf_metadata_
                                         : reinterpret_cast<::trusted_vault_pb::LskfMetadata&>(::trusted_vault_pb::_LskfMetadata_default_instance_);
}
inline const ::trusted_vault_pb::LskfMetadata& SecurityDomainMember_MemberMetadata::lskf_metadata() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomainMember.MemberMetadata.lskf_metadata)
    return _internal_lskf_metadata();
}
inline ::trusted_vault_pb::LskfMetadata* SecurityDomainMember_MemberMetadata::unsafe_arena_release_lskf_metadata()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:trusted_vault_pb.SecurityDomainMember.MemberMetadata.lskf_metadata)
    if (_internal_has_lskf_metadata()) {
        clear_has_member_metadata_variant();
        ::trusted_vault_pb::LskfMetadata* temp = _impl_.member_metadata_variant_.lskf_metadata_;
        _impl_.member_metadata_variant_.lskf_metadata_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void SecurityDomainMember_MemberMetadata::unsafe_arena_set_allocated_lskf_metadata(::trusted_vault_pb::LskfMetadata* lskf_metadata)
{
    clear_member_metadata_variant();
    if (lskf_metadata) {
        set_has_lskf_metadata();
        _impl_.member_metadata_variant_.lskf_metadata_ = lskf_metadata;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.SecurityDomainMember.MemberMetadata.lskf_metadata)
}
inline ::trusted_vault_pb::LskfMetadata* SecurityDomainMember_MemberMetadata::_internal_mutable_lskf_metadata()
{
    if (!_internal_has_lskf_metadata()) {
        clear_member_metadata_variant();
        set_has_lskf_metadata();
        _impl_.member_metadata_variant_.lskf_metadata_ = CreateMaybeMessage<::trusted_vault_pb::LskfMetadata>(GetArenaForAllocation());
    }
    return _impl_.member_metadata_variant_.lskf_metadata_;
}
inline ::trusted_vault_pb::LskfMetadata* SecurityDomainMember_MemberMetadata::mutable_lskf_metadata()
{
    ::trusted_vault_pb::LskfMetadata* _msg = _internal_mutable_lskf_metadata();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SecurityDomainMember.MemberMetadata.lskf_metadata)
    return _msg;
}

// .trusted_vault_pb.GooglePasswordManagerPinMetadata google_password_manager_pin_metadata = 5;
inline bool SecurityDomainMember_MemberMetadata::_internal_has_google_password_manager_pin_metadata() const
{
    return member_metadata_variant_case() == kGooglePasswordManagerPinMetadata;
}
inline bool SecurityDomainMember_MemberMetadata::has_google_password_manager_pin_metadata() const
{
    return _internal_has_google_password_manager_pin_metadata();
}
inline void SecurityDomainMember_MemberMetadata::set_has_google_password_manager_pin_metadata()
{
    _impl_._oneof_case_[0] = kGooglePasswordManagerPinMetadata;
}
inline void SecurityDomainMember_MemberMetadata::clear_google_password_manager_pin_metadata()
{
    if (_internal_has_google_password_manager_pin_metadata()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.member_metadata_variant_.google_password_manager_pin_metadata_;
        }
        clear_has_member_metadata_variant();
    }
}
inline ::trusted_vault_pb::GooglePasswordManagerPinMetadata* SecurityDomainMember_MemberMetadata::release_google_password_manager_pin_metadata()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.SecurityDomainMember.MemberMetadata.google_password_manager_pin_metadata)
    if (_internal_has_google_password_manager_pin_metadata()) {
        clear_has_member_metadata_variant();
        ::trusted_vault_pb::GooglePasswordManagerPinMetadata* temp = _impl_.member_metadata_variant_.google_password_manager_pin_metadata_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.member_metadata_variant_.google_password_manager_pin_metadata_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::trusted_vault_pb::GooglePasswordManagerPinMetadata& SecurityDomainMember_MemberMetadata::_internal_google_password_manager_pin_metadata() const
{
    return _internal_has_google_password_manager_pin_metadata()
        ? *_impl_.member_metadata_variant_.google_password_manager_pin_metadata_
        : reinterpret_cast<::trusted_vault_pb::GooglePasswordManagerPinMetadata&>(::trusted_vault_pb::_GooglePasswordManagerPinMetadata_default_instance_);
}
inline const ::trusted_vault_pb::GooglePasswordManagerPinMetadata& SecurityDomainMember_MemberMetadata::google_password_manager_pin_metadata() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomainMember.MemberMetadata.google_password_manager_pin_metadata)
    return _internal_google_password_manager_pin_metadata();
}
inline ::trusted_vault_pb::GooglePasswordManagerPinMetadata* SecurityDomainMember_MemberMetadata::unsafe_arena_release_google_password_manager_pin_metadata()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:trusted_vault_pb.SecurityDomainMember.MemberMetadata.google_password_manager_pin_metadata)
    if (_internal_has_google_password_manager_pin_metadata()) {
        clear_has_member_metadata_variant();
        ::trusted_vault_pb::GooglePasswordManagerPinMetadata* temp = _impl_.member_metadata_variant_.google_password_manager_pin_metadata_;
        _impl_.member_metadata_variant_.google_password_manager_pin_metadata_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void SecurityDomainMember_MemberMetadata::unsafe_arena_set_allocated_google_password_manager_pin_metadata(
    ::trusted_vault_pb::GooglePasswordManagerPinMetadata* google_password_manager_pin_metadata)
{
    clear_member_metadata_variant();
    if (google_password_manager_pin_metadata) {
        set_has_google_password_manager_pin_metadata();
        _impl_.member_metadata_variant_.google_password_manager_pin_metadata_ = google_password_manager_pin_metadata;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.SecurityDomainMember.MemberMetadata.google_password_manager_pin_metadata)
}
inline ::trusted_vault_pb::GooglePasswordManagerPinMetadata* SecurityDomainMember_MemberMetadata::_internal_mutable_google_password_manager_pin_metadata()
{
    if (!_internal_has_google_password_manager_pin_metadata()) {
        clear_member_metadata_variant();
        set_has_google_password_manager_pin_metadata();
        _impl_.member_metadata_variant_.google_password_manager_pin_metadata_
            = CreateMaybeMessage<::trusted_vault_pb::GooglePasswordManagerPinMetadata>(GetArenaForAllocation());
    }
    return _impl_.member_metadata_variant_.google_password_manager_pin_metadata_;
}
inline ::trusted_vault_pb::GooglePasswordManagerPinMetadata* SecurityDomainMember_MemberMetadata::mutable_google_password_manager_pin_metadata()
{
    ::trusted_vault_pb::GooglePasswordManagerPinMetadata* _msg = _internal_mutable_google_password_manager_pin_metadata();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SecurityDomainMember.MemberMetadata.google_password_manager_pin_metadata)
    return _msg;
}

inline bool SecurityDomainMember_MemberMetadata::has_member_metadata_variant() const
{
    return member_metadata_variant_case() != MEMBER_METADATA_VARIANT_NOT_SET;
}
inline void SecurityDomainMember_MemberMetadata::clear_has_member_metadata_variant()
{
    _impl_._oneof_case_[0] = MEMBER_METADATA_VARIANT_NOT_SET;
}
inline SecurityDomainMember_MemberMetadata::MemberMetadataVariantCase SecurityDomainMember_MemberMetadata::member_metadata_variant_case() const
{
    return SecurityDomainMember_MemberMetadata::MemberMetadataVariantCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SecurityDomainMember

// string name = 1;
inline void SecurityDomainMember::clear_name()
{
    _impl_.name_.ClearToEmpty();
}
inline const std::string& SecurityDomainMember::name() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomainMember.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SecurityDomainMember::set_name(ArgT0&& arg0, ArgT... args)
{

    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.SecurityDomainMember.name)
}
inline std::string* SecurityDomainMember::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SecurityDomainMember.name)
    return _s;
}
inline const std::string& SecurityDomainMember::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void SecurityDomainMember::_internal_set_name(const std::string& value)
{

    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityDomainMember::_internal_mutable_name()
{

    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityDomainMember::release_name()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.SecurityDomainMember.name)
    return _impl_.name_.Release();
}
inline void SecurityDomainMember::set_allocated_name(std::string* name)
{
    if (name != nullptr) {

    } else {
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.SecurityDomainMember.name)
}

// bytes public_key = 2;
inline void SecurityDomainMember::clear_public_key()
{
    _impl_.public_key_.ClearToEmpty();
}
inline const std::string& SecurityDomainMember::public_key() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomainMember.public_key)
    return _internal_public_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SecurityDomainMember::set_public_key(ArgT0&& arg0, ArgT... args)
{

    _impl_.public_key_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.SecurityDomainMember.public_key)
}
inline std::string* SecurityDomainMember::mutable_public_key()
{
    std::string* _s = _internal_mutable_public_key();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SecurityDomainMember.public_key)
    return _s;
}
inline const std::string& SecurityDomainMember::_internal_public_key() const
{
    return _impl_.public_key_.Get();
}
inline void SecurityDomainMember::_internal_set_public_key(const std::string& value)
{

    _impl_.public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityDomainMember::_internal_mutable_public_key()
{

    return _impl_.public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* SecurityDomainMember::release_public_key()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.SecurityDomainMember.public_key)
    return _impl_.public_key_.Release();
}
inline void SecurityDomainMember::set_allocated_public_key(std::string* public_key)
{
    if (public_key != nullptr) {

    } else {
    }
    _impl_.public_key_.SetAllocated(public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.public_key_.IsDefault()) {
        _impl_.public_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.SecurityDomainMember.public_key)
}

// repeated .trusted_vault_pb.SecurityDomainMember.SecurityDomainMembership memberships = 3;
inline int SecurityDomainMember::_internal_memberships_size() const
{
    return _impl_.memberships_.size();
}
inline int SecurityDomainMember::memberships_size() const
{
    return _internal_memberships_size();
}
inline void SecurityDomainMember::clear_memberships()
{
    _impl_.memberships_.Clear();
}
inline ::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership* SecurityDomainMember::mutable_memberships(int index)
{
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SecurityDomainMember.memberships)
    return _impl_.memberships_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership>* SecurityDomainMember::mutable_memberships()
{
    // @@protoc_insertion_point(field_mutable_list:trusted_vault_pb.SecurityDomainMember.memberships)
    return &_impl_.memberships_;
}
inline const ::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership& SecurityDomainMember::_internal_memberships(int index) const
{
    return _impl_.memberships_.Get(index);
}
inline const ::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership& SecurityDomainMember::memberships(int index) const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomainMember.memberships)
    return _internal_memberships(index);
}
inline ::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership* SecurityDomainMember::_internal_add_memberships()
{
    return _impl_.memberships_.Add();
}
inline ::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership* SecurityDomainMember::add_memberships()
{
    ::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership* _add = _internal_add_memberships();
    // @@protoc_insertion_point(field_add:trusted_vault_pb.SecurityDomainMember.memberships)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SecurityDomainMember_SecurityDomainMembership>&
SecurityDomainMember::memberships() const
{
    // @@protoc_insertion_point(field_list:trusted_vault_pb.SecurityDomainMember.memberships)
    return _impl_.memberships_;
}

// .trusted_vault_pb.SecurityDomainMember.MemberType member_type = 4;
inline void SecurityDomainMember::clear_member_type()
{
    _impl_.member_type_ = 0;
}
inline ::trusted_vault_pb::SecurityDomainMember_MemberType SecurityDomainMember::_internal_member_type() const
{
    return static_cast<::trusted_vault_pb::SecurityDomainMember_MemberType>(_impl_.member_type_);
}
inline ::trusted_vault_pb::SecurityDomainMember_MemberType SecurityDomainMember::member_type() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomainMember.member_type)
    return _internal_member_type();
}
inline void SecurityDomainMember::_internal_set_member_type(::trusted_vault_pb::SecurityDomainMember_MemberType value)
{

    _impl_.member_type_ = value;
}
inline void SecurityDomainMember::set_member_type(::trusted_vault_pb::SecurityDomainMember_MemberType value)
{
    _internal_set_member_type(value);
    // @@protoc_insertion_point(field_set:trusted_vault_pb.SecurityDomainMember.member_type)
}

// .trusted_vault_pb.SecurityDomainMember.MemberMetadata member_metadata = 6;
inline bool SecurityDomainMember::_internal_has_member_metadata() const
{
    return this != internal_default_instance() && _impl_.member_metadata_ != nullptr;
}
inline bool SecurityDomainMember::has_member_metadata() const
{
    return _internal_has_member_metadata();
}
inline void SecurityDomainMember::clear_member_metadata()
{
    if (GetArenaForAllocation() == nullptr && _impl_.member_metadata_ != nullptr) {
        delete _impl_.member_metadata_;
    }
    _impl_.member_metadata_ = nullptr;
}
inline const ::trusted_vault_pb::SecurityDomainMember_MemberMetadata& SecurityDomainMember::_internal_member_metadata() const
{
    const ::trusted_vault_pb::SecurityDomainMember_MemberMetadata* p = _impl_.member_metadata_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::trusted_vault_pb::SecurityDomainMember_MemberMetadata&>(
                            ::trusted_vault_pb::_SecurityDomainMember_MemberMetadata_default_instance_);
}
inline const ::trusted_vault_pb::SecurityDomainMember_MemberMetadata& SecurityDomainMember::member_metadata() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.SecurityDomainMember.member_metadata)
    return _internal_member_metadata();
}
inline void SecurityDomainMember::unsafe_arena_set_allocated_member_metadata(::trusted_vault_pb::SecurityDomainMember_MemberMetadata* member_metadata)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.member_metadata_);
    }
    _impl_.member_metadata_ = member_metadata;
    if (member_metadata) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.SecurityDomainMember.member_metadata)
}
inline ::trusted_vault_pb::SecurityDomainMember_MemberMetadata* SecurityDomainMember::release_member_metadata()
{

    ::trusted_vault_pb::SecurityDomainMember_MemberMetadata* temp = _impl_.member_metadata_;
    _impl_.member_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::trusted_vault_pb::SecurityDomainMember_MemberMetadata* SecurityDomainMember::unsafe_arena_release_member_metadata()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.SecurityDomainMember.member_metadata)

    ::trusted_vault_pb::SecurityDomainMember_MemberMetadata* temp = _impl_.member_metadata_;
    _impl_.member_metadata_ = nullptr;
    return temp;
}
inline ::trusted_vault_pb::SecurityDomainMember_MemberMetadata* SecurityDomainMember::_internal_mutable_member_metadata()
{

    if (_impl_.member_metadata_ == nullptr) {
        auto* p = CreateMaybeMessage<::trusted_vault_pb::SecurityDomainMember_MemberMetadata>(GetArenaForAllocation());
        _impl_.member_metadata_ = p;
    }
    return _impl_.member_metadata_;
}
inline ::trusted_vault_pb::SecurityDomainMember_MemberMetadata* SecurityDomainMember::mutable_member_metadata()
{
    ::trusted_vault_pb::SecurityDomainMember_MemberMetadata* _msg = _internal_mutable_member_metadata();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.SecurityDomainMember.member_metadata)
    return _msg;
}
inline void SecurityDomainMember::set_allocated_member_metadata(::trusted_vault_pb::SecurityDomainMember_MemberMetadata* member_metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.member_metadata_;
    }
    if (member_metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(member_metadata);
        if (message_arena != submessage_arena) {
            member_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, member_metadata, submessage_arena);
        }

    } else {
    }
    _impl_.member_metadata_ = member_metadata;
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.SecurityDomainMember.member_metadata)
}

// -------------------------------------------------------------------

// JoinSecurityDomainsRequest

// .trusted_vault_pb.SecurityDomain security_domain = 1;
inline bool JoinSecurityDomainsRequest::_internal_has_security_domain() const
{
    return this != internal_default_instance() && _impl_.security_domain_ != nullptr;
}
inline bool JoinSecurityDomainsRequest::has_security_domain() const
{
    return _internal_has_security_domain();
}
inline void JoinSecurityDomainsRequest::clear_security_domain()
{
    if (GetArenaForAllocation() == nullptr && _impl_.security_domain_ != nullptr) {
        delete _impl_.security_domain_;
    }
    _impl_.security_domain_ = nullptr;
}
inline const ::trusted_vault_pb::SecurityDomain& JoinSecurityDomainsRequest::_internal_security_domain() const
{
    const ::trusted_vault_pb::SecurityDomain* p = _impl_.security_domain_;
    return p != nullptr ? *p : reinterpret_cast<const ::trusted_vault_pb::SecurityDomain&>(::trusted_vault_pb::_SecurityDomain_default_instance_);
}
inline const ::trusted_vault_pb::SecurityDomain& JoinSecurityDomainsRequest::security_domain() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.JoinSecurityDomainsRequest.security_domain)
    return _internal_security_domain();
}
inline void JoinSecurityDomainsRequest::unsafe_arena_set_allocated_security_domain(::trusted_vault_pb::SecurityDomain* security_domain)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.security_domain_);
    }
    _impl_.security_domain_ = security_domain;
    if (security_domain) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.JoinSecurityDomainsRequest.security_domain)
}
inline ::trusted_vault_pb::SecurityDomain* JoinSecurityDomainsRequest::release_security_domain()
{

    ::trusted_vault_pb::SecurityDomain* temp = _impl_.security_domain_;
    _impl_.security_domain_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::trusted_vault_pb::SecurityDomain* JoinSecurityDomainsRequest::unsafe_arena_release_security_domain()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.JoinSecurityDomainsRequest.security_domain)

    ::trusted_vault_pb::SecurityDomain* temp = _impl_.security_domain_;
    _impl_.security_domain_ = nullptr;
    return temp;
}
inline ::trusted_vault_pb::SecurityDomain* JoinSecurityDomainsRequest::_internal_mutable_security_domain()
{

    if (_impl_.security_domain_ == nullptr) {
        auto* p = CreateMaybeMessage<::trusted_vault_pb::SecurityDomain>(GetArenaForAllocation());
        _impl_.security_domain_ = p;
    }
    return _impl_.security_domain_;
}
inline ::trusted_vault_pb::SecurityDomain* JoinSecurityDomainsRequest::mutable_security_domain()
{
    ::trusted_vault_pb::SecurityDomain* _msg = _internal_mutable_security_domain();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.JoinSecurityDomainsRequest.security_domain)
    return _msg;
}
inline void JoinSecurityDomainsRequest::set_allocated_security_domain(::trusted_vault_pb::SecurityDomain* security_domain)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.security_domain_;
    }
    if (security_domain) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(security_domain);
        if (message_arena != submessage_arena) {
            security_domain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, security_domain, submessage_arena);
        }

    } else {
    }
    _impl_.security_domain_ = security_domain;
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.JoinSecurityDomainsRequest.security_domain)
}

// .trusted_vault_pb.SecurityDomainMember security_domain_member = 2;
inline bool JoinSecurityDomainsRequest::_internal_has_security_domain_member() const
{
    return this != internal_default_instance() && _impl_.security_domain_member_ != nullptr;
}
inline bool JoinSecurityDomainsRequest::has_security_domain_member() const
{
    return _internal_has_security_domain_member();
}
inline void JoinSecurityDomainsRequest::clear_security_domain_member()
{
    if (GetArenaForAllocation() == nullptr && _impl_.security_domain_member_ != nullptr) {
        delete _impl_.security_domain_member_;
    }
    _impl_.security_domain_member_ = nullptr;
}
inline const ::trusted_vault_pb::SecurityDomainMember& JoinSecurityDomainsRequest::_internal_security_domain_member() const
{
    const ::trusted_vault_pb::SecurityDomainMember* p = _impl_.security_domain_member_;
    return p != nullptr ? *p : reinterpret_cast<const ::trusted_vault_pb::SecurityDomainMember&>(::trusted_vault_pb::_SecurityDomainMember_default_instance_);
}
inline const ::trusted_vault_pb::SecurityDomainMember& JoinSecurityDomainsRequest::security_domain_member() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.JoinSecurityDomainsRequest.security_domain_member)
    return _internal_security_domain_member();
}
inline void JoinSecurityDomainsRequest::unsafe_arena_set_allocated_security_domain_member(::trusted_vault_pb::SecurityDomainMember* security_domain_member)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.security_domain_member_);
    }
    _impl_.security_domain_member_ = security_domain_member;
    if (security_domain_member) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.JoinSecurityDomainsRequest.security_domain_member)
}
inline ::trusted_vault_pb::SecurityDomainMember* JoinSecurityDomainsRequest::release_security_domain_member()
{

    ::trusted_vault_pb::SecurityDomainMember* temp = _impl_.security_domain_member_;
    _impl_.security_domain_member_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::trusted_vault_pb::SecurityDomainMember* JoinSecurityDomainsRequest::unsafe_arena_release_security_domain_member()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.JoinSecurityDomainsRequest.security_domain_member)

    ::trusted_vault_pb::SecurityDomainMember* temp = _impl_.security_domain_member_;
    _impl_.security_domain_member_ = nullptr;
    return temp;
}
inline ::trusted_vault_pb::SecurityDomainMember* JoinSecurityDomainsRequest::_internal_mutable_security_domain_member()
{

    if (_impl_.security_domain_member_ == nullptr) {
        auto* p = CreateMaybeMessage<::trusted_vault_pb::SecurityDomainMember>(GetArenaForAllocation());
        _impl_.security_domain_member_ = p;
    }
    return _impl_.security_domain_member_;
}
inline ::trusted_vault_pb::SecurityDomainMember* JoinSecurityDomainsRequest::mutable_security_domain_member()
{
    ::trusted_vault_pb::SecurityDomainMember* _msg = _internal_mutable_security_domain_member();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.JoinSecurityDomainsRequest.security_domain_member)
    return _msg;
}
inline void JoinSecurityDomainsRequest::set_allocated_security_domain_member(::trusted_vault_pb::SecurityDomainMember* security_domain_member)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.security_domain_member_;
    }
    if (security_domain_member) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(security_domain_member);
        if (message_arena != submessage_arena) {
            security_domain_member = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, security_domain_member, submessage_arena);
        }

    } else {
    }
    _impl_.security_domain_member_ = security_domain_member;
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.JoinSecurityDomainsRequest.security_domain_member)
}

// repeated .trusted_vault_pb.SharedMemberKey shared_member_key = 3;
inline int JoinSecurityDomainsRequest::_internal_shared_member_key_size() const
{
    return _impl_.shared_member_key_.size();
}
inline int JoinSecurityDomainsRequest::shared_member_key_size() const
{
    return _internal_shared_member_key_size();
}
inline void JoinSecurityDomainsRequest::clear_shared_member_key()
{
    _impl_.shared_member_key_.Clear();
}
inline ::trusted_vault_pb::SharedMemberKey* JoinSecurityDomainsRequest::mutable_shared_member_key(int index)
{
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.JoinSecurityDomainsRequest.shared_member_key)
    return _impl_.shared_member_key_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SharedMemberKey>* JoinSecurityDomainsRequest::mutable_shared_member_key()
{
    // @@protoc_insertion_point(field_mutable_list:trusted_vault_pb.JoinSecurityDomainsRequest.shared_member_key)
    return &_impl_.shared_member_key_;
}
inline const ::trusted_vault_pb::SharedMemberKey& JoinSecurityDomainsRequest::_internal_shared_member_key(int index) const
{
    return _impl_.shared_member_key_.Get(index);
}
inline const ::trusted_vault_pb::SharedMemberKey& JoinSecurityDomainsRequest::shared_member_key(int index) const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.JoinSecurityDomainsRequest.shared_member_key)
    return _internal_shared_member_key(index);
}
inline ::trusted_vault_pb::SharedMemberKey* JoinSecurityDomainsRequest::_internal_add_shared_member_key()
{
    return _impl_.shared_member_key_.Add();
}
inline ::trusted_vault_pb::SharedMemberKey* JoinSecurityDomainsRequest::add_shared_member_key()
{
    ::trusted_vault_pb::SharedMemberKey* _add = _internal_add_shared_member_key();
    // @@protoc_insertion_point(field_add:trusted_vault_pb.JoinSecurityDomainsRequest.shared_member_key)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SharedMemberKey>& JoinSecurityDomainsRequest::shared_member_key() const
{
    // @@protoc_insertion_point(field_list:trusted_vault_pb.JoinSecurityDomainsRequest.shared_member_key)
    return _impl_.shared_member_key_;
}

// int32 member_type_hint = 4;
inline void JoinSecurityDomainsRequest::clear_member_type_hint()
{
    _impl_.member_type_hint_ = 0;
}
inline int32_t JoinSecurityDomainsRequest::_internal_member_type_hint() const
{
    return _impl_.member_type_hint_;
}
inline int32_t JoinSecurityDomainsRequest::member_type_hint() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.JoinSecurityDomainsRequest.member_type_hint)
    return _internal_member_type_hint();
}
inline void JoinSecurityDomainsRequest::_internal_set_member_type_hint(int32_t value)
{

    _impl_.member_type_hint_ = value;
}
inline void JoinSecurityDomainsRequest::set_member_type_hint(int32_t value)
{
    _internal_set_member_type_hint(value);
    // @@protoc_insertion_point(field_set:trusted_vault_pb.JoinSecurityDomainsRequest.member_type_hint)
}

// bytes current_public_key_to_replace = 5;
inline void JoinSecurityDomainsRequest::clear_current_public_key_to_replace()
{
    _impl_.current_public_key_to_replace_.ClearToEmpty();
}
inline const std::string& JoinSecurityDomainsRequest::current_public_key_to_replace() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.JoinSecurityDomainsRequest.current_public_key_to_replace)
    return _internal_current_public_key_to_replace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void JoinSecurityDomainsRequest::set_current_public_key_to_replace(ArgT0&& arg0, ArgT... args)
{

    _impl_.current_public_key_to_replace_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.JoinSecurityDomainsRequest.current_public_key_to_replace)
}
inline std::string* JoinSecurityDomainsRequest::mutable_current_public_key_to_replace()
{
    std::string* _s = _internal_mutable_current_public_key_to_replace();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.JoinSecurityDomainsRequest.current_public_key_to_replace)
    return _s;
}
inline const std::string& JoinSecurityDomainsRequest::_internal_current_public_key_to_replace() const
{
    return _impl_.current_public_key_to_replace_.Get();
}
inline void JoinSecurityDomainsRequest::_internal_set_current_public_key_to_replace(const std::string& value)
{

    _impl_.current_public_key_to_replace_.Set(value, GetArenaForAllocation());
}
inline std::string* JoinSecurityDomainsRequest::_internal_mutable_current_public_key_to_replace()
{

    return _impl_.current_public_key_to_replace_.Mutable(GetArenaForAllocation());
}
inline std::string* JoinSecurityDomainsRequest::release_current_public_key_to_replace()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.JoinSecurityDomainsRequest.current_public_key_to_replace)
    return _impl_.current_public_key_to_replace_.Release();
}
inline void JoinSecurityDomainsRequest::set_allocated_current_public_key_to_replace(std::string* current_public_key_to_replace)
{
    if (current_public_key_to_replace != nullptr) {

    } else {
    }
    _impl_.current_public_key_to_replace_.SetAllocated(current_public_key_to_replace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.current_public_key_to_replace_.IsDefault()) {
        _impl_.current_public_key_to_replace_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.JoinSecurityDomainsRequest.current_public_key_to_replace)
}

// -------------------------------------------------------------------

// JoinSecurityDomainsResponse

// .trusted_vault_pb.SecurityDomain security_domain = 1;
inline bool JoinSecurityDomainsResponse::_internal_has_security_domain() const
{
    return this != internal_default_instance() && _impl_.security_domain_ != nullptr;
}
inline bool JoinSecurityDomainsResponse::has_security_domain() const
{
    return _internal_has_security_domain();
}
inline void JoinSecurityDomainsResponse::clear_security_domain()
{
    if (GetArenaForAllocation() == nullptr && _impl_.security_domain_ != nullptr) {
        delete _impl_.security_domain_;
    }
    _impl_.security_domain_ = nullptr;
}
inline const ::trusted_vault_pb::SecurityDomain& JoinSecurityDomainsResponse::_internal_security_domain() const
{
    const ::trusted_vault_pb::SecurityDomain* p = _impl_.security_domain_;
    return p != nullptr ? *p : reinterpret_cast<const ::trusted_vault_pb::SecurityDomain&>(::trusted_vault_pb::_SecurityDomain_default_instance_);
}
inline const ::trusted_vault_pb::SecurityDomain& JoinSecurityDomainsResponse::security_domain() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.JoinSecurityDomainsResponse.security_domain)
    return _internal_security_domain();
}
inline void JoinSecurityDomainsResponse::unsafe_arena_set_allocated_security_domain(::trusted_vault_pb::SecurityDomain* security_domain)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.security_domain_);
    }
    _impl_.security_domain_ = security_domain;
    if (security_domain) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.JoinSecurityDomainsResponse.security_domain)
}
inline ::trusted_vault_pb::SecurityDomain* JoinSecurityDomainsResponse::release_security_domain()
{

    ::trusted_vault_pb::SecurityDomain* temp = _impl_.security_domain_;
    _impl_.security_domain_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::trusted_vault_pb::SecurityDomain* JoinSecurityDomainsResponse::unsafe_arena_release_security_domain()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.JoinSecurityDomainsResponse.security_domain)

    ::trusted_vault_pb::SecurityDomain* temp = _impl_.security_domain_;
    _impl_.security_domain_ = nullptr;
    return temp;
}
inline ::trusted_vault_pb::SecurityDomain* JoinSecurityDomainsResponse::_internal_mutable_security_domain()
{

    if (_impl_.security_domain_ == nullptr) {
        auto* p = CreateMaybeMessage<::trusted_vault_pb::SecurityDomain>(GetArenaForAllocation());
        _impl_.security_domain_ = p;
    }
    return _impl_.security_domain_;
}
inline ::trusted_vault_pb::SecurityDomain* JoinSecurityDomainsResponse::mutable_security_domain()
{
    ::trusted_vault_pb::SecurityDomain* _msg = _internal_mutable_security_domain();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.JoinSecurityDomainsResponse.security_domain)
    return _msg;
}
inline void JoinSecurityDomainsResponse::set_allocated_security_domain(::trusted_vault_pb::SecurityDomain* security_domain)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.security_domain_;
    }
    if (security_domain) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(security_domain);
        if (message_arena != submessage_arena) {
            security_domain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, security_domain, submessage_arena);
        }

    } else {
    }
    _impl_.security_domain_ = security_domain;
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.JoinSecurityDomainsResponse.security_domain)
}

// -------------------------------------------------------------------

// JoinSecurityDomainsErrorDetail

// .trusted_vault_pb.JoinSecurityDomainsResponse already_exists_response = 1;
inline bool JoinSecurityDomainsErrorDetail::_internal_has_already_exists_response() const
{
    return this != internal_default_instance() && _impl_.already_exists_response_ != nullptr;
}
inline bool JoinSecurityDomainsErrorDetail::has_already_exists_response() const
{
    return _internal_has_already_exists_response();
}
inline void JoinSecurityDomainsErrorDetail::clear_already_exists_response()
{
    if (GetArenaForAllocation() == nullptr && _impl_.already_exists_response_ != nullptr) {
        delete _impl_.already_exists_response_;
    }
    _impl_.already_exists_response_ = nullptr;
}
inline const ::trusted_vault_pb::JoinSecurityDomainsResponse& JoinSecurityDomainsErrorDetail::_internal_already_exists_response() const
{
    const ::trusted_vault_pb::JoinSecurityDomainsResponse* p = _impl_.already_exists_response_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::trusted_vault_pb::JoinSecurityDomainsResponse&>(::trusted_vault_pb::_JoinSecurityDomainsResponse_default_instance_);
}
inline const ::trusted_vault_pb::JoinSecurityDomainsResponse& JoinSecurityDomainsErrorDetail::already_exists_response() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.JoinSecurityDomainsErrorDetail.already_exists_response)
    return _internal_already_exists_response();
}
inline void JoinSecurityDomainsErrorDetail::unsafe_arena_set_allocated_already_exists_response(
    ::trusted_vault_pb::JoinSecurityDomainsResponse* already_exists_response)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.already_exists_response_);
    }
    _impl_.already_exists_response_ = already_exists_response;
    if (already_exists_response) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trusted_vault_pb.JoinSecurityDomainsErrorDetail.already_exists_response)
}
inline ::trusted_vault_pb::JoinSecurityDomainsResponse* JoinSecurityDomainsErrorDetail::release_already_exists_response()
{

    ::trusted_vault_pb::JoinSecurityDomainsResponse* temp = _impl_.already_exists_response_;
    _impl_.already_exists_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::trusted_vault_pb::JoinSecurityDomainsResponse* JoinSecurityDomainsErrorDetail::unsafe_arena_release_already_exists_response()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.JoinSecurityDomainsErrorDetail.already_exists_response)

    ::trusted_vault_pb::JoinSecurityDomainsResponse* temp = _impl_.already_exists_response_;
    _impl_.already_exists_response_ = nullptr;
    return temp;
}
inline ::trusted_vault_pb::JoinSecurityDomainsResponse* JoinSecurityDomainsErrorDetail::_internal_mutable_already_exists_response()
{

    if (_impl_.already_exists_response_ == nullptr) {
        auto* p = CreateMaybeMessage<::trusted_vault_pb::JoinSecurityDomainsResponse>(GetArenaForAllocation());
        _impl_.already_exists_response_ = p;
    }
    return _impl_.already_exists_response_;
}
inline ::trusted_vault_pb::JoinSecurityDomainsResponse* JoinSecurityDomainsErrorDetail::mutable_already_exists_response()
{
    ::trusted_vault_pb::JoinSecurityDomainsResponse* _msg = _internal_mutable_already_exists_response();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.JoinSecurityDomainsErrorDetail.already_exists_response)
    return _msg;
}
inline void JoinSecurityDomainsErrorDetail::set_allocated_already_exists_response(::trusted_vault_pb::JoinSecurityDomainsResponse* already_exists_response)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.already_exists_response_;
    }
    if (already_exists_response) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(already_exists_response);
        if (message_arena != submessage_arena) {
            already_exists_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, already_exists_response, submessage_arena);
        }

    } else {
    }
    _impl_.already_exists_response_ = already_exists_response;
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.JoinSecurityDomainsErrorDetail.already_exists_response)
}

// -------------------------------------------------------------------

// ListSecurityDomainMembersResponse

// repeated .trusted_vault_pb.SecurityDomainMember security_domain_members = 1;
inline int ListSecurityDomainMembersResponse::_internal_security_domain_members_size() const
{
    return _impl_.security_domain_members_.size();
}
inline int ListSecurityDomainMembersResponse::security_domain_members_size() const
{
    return _internal_security_domain_members_size();
}
inline void ListSecurityDomainMembersResponse::clear_security_domain_members()
{
    _impl_.security_domain_members_.Clear();
}
inline ::trusted_vault_pb::SecurityDomainMember* ListSecurityDomainMembersResponse::mutable_security_domain_members(int index)
{
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.ListSecurityDomainMembersResponse.security_domain_members)
    return _impl_.security_domain_members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SecurityDomainMember>* ListSecurityDomainMembersResponse::mutable_security_domain_members()
{
    // @@protoc_insertion_point(field_mutable_list:trusted_vault_pb.ListSecurityDomainMembersResponse.security_domain_members)
    return &_impl_.security_domain_members_;
}
inline const ::trusted_vault_pb::SecurityDomainMember& ListSecurityDomainMembersResponse::_internal_security_domain_members(int index) const
{
    return _impl_.security_domain_members_.Get(index);
}
inline const ::trusted_vault_pb::SecurityDomainMember& ListSecurityDomainMembersResponse::security_domain_members(int index) const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.ListSecurityDomainMembersResponse.security_domain_members)
    return _internal_security_domain_members(index);
}
inline ::trusted_vault_pb::SecurityDomainMember* ListSecurityDomainMembersResponse::_internal_add_security_domain_members()
{
    return _impl_.security_domain_members_.Add();
}
inline ::trusted_vault_pb::SecurityDomainMember* ListSecurityDomainMembersResponse::add_security_domain_members()
{
    ::trusted_vault_pb::SecurityDomainMember* _add = _internal_add_security_domain_members();
    // @@protoc_insertion_point(field_add:trusted_vault_pb.ListSecurityDomainMembersResponse.security_domain_members)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::SecurityDomainMember>&
ListSecurityDomainMembersResponse::security_domain_members() const
{
    // @@protoc_insertion_point(field_list:trusted_vault_pb.ListSecurityDomainMembersResponse.security_domain_members)
    return _impl_.security_domain_members_;
}

// string next_page_token = 2;
inline void ListSecurityDomainMembersResponse::clear_next_page_token()
{
    _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListSecurityDomainMembersResponse::next_page_token() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.ListSecurityDomainMembersResponse.next_page_token)
    return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void ListSecurityDomainMembersResponse::set_next_page_token(ArgT0&& arg0, ArgT... args)
{

    _impl_.next_page_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.ListSecurityDomainMembersResponse.next_page_token)
}
inline std::string* ListSecurityDomainMembersResponse::mutable_next_page_token()
{
    std::string* _s = _internal_mutable_next_page_token();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.ListSecurityDomainMembersResponse.next_page_token)
    return _s;
}
inline const std::string& ListSecurityDomainMembersResponse::_internal_next_page_token() const
{
    return _impl_.next_page_token_.Get();
}
inline void ListSecurityDomainMembersResponse::_internal_set_next_page_token(const std::string& value)
{

    _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListSecurityDomainMembersResponse::_internal_mutable_next_page_token()
{

    return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ListSecurityDomainMembersResponse::release_next_page_token()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.ListSecurityDomainMembersResponse.next_page_token)
    return _impl_.next_page_token_.Release();
}
inline void ListSecurityDomainMembersResponse::set_allocated_next_page_token(std::string* next_page_token)
{
    if (next_page_token != nullptr) {

    } else {
    }
    _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.next_page_token_.IsDefault()) {
        _impl_.next_page_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.ListSecurityDomainMembersResponse.next_page_token)
}

// -------------------------------------------------------------------

// Proto3Any

// string type_url = 1;
inline void Proto3Any::clear_type_url()
{
    _impl_.type_url_.ClearToEmpty();
}
inline const std::string& Proto3Any::type_url() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.Proto3Any.type_url)
    return _internal_type_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Proto3Any::set_type_url(ArgT0&& arg0, ArgT... args)
{

    _impl_.type_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.Proto3Any.type_url)
}
inline std::string* Proto3Any::mutable_type_url()
{
    std::string* _s = _internal_mutable_type_url();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.Proto3Any.type_url)
    return _s;
}
inline const std::string& Proto3Any::_internal_type_url() const
{
    return _impl_.type_url_.Get();
}
inline void Proto3Any::_internal_set_type_url(const std::string& value)
{

    _impl_.type_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Proto3Any::_internal_mutable_type_url()
{

    return _impl_.type_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Proto3Any::release_type_url()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.Proto3Any.type_url)
    return _impl_.type_url_.Release();
}
inline void Proto3Any::set_allocated_type_url(std::string* type_url)
{
    if (type_url != nullptr) {

    } else {
    }
    _impl_.type_url_.SetAllocated(type_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.type_url_.IsDefault()) {
        _impl_.type_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.Proto3Any.type_url)
}

// bytes value = 2;
inline void Proto3Any::clear_value()
{
    _impl_.value_.ClearToEmpty();
}
inline const std::string& Proto3Any::value() const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.Proto3Any.value)
    return _internal_value();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Proto3Any::set_value(ArgT0&& arg0, ArgT... args)
{

    _impl_.value_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:trusted_vault_pb.Proto3Any.value)
}
inline std::string* Proto3Any::mutable_value()
{
    std::string* _s = _internal_mutable_value();
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.Proto3Any.value)
    return _s;
}
inline const std::string& Proto3Any::_internal_value() const
{
    return _impl_.value_.Get();
}
inline void Proto3Any::_internal_set_value(const std::string& value)
{

    _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Proto3Any::_internal_mutable_value()
{

    return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Proto3Any::release_value()
{
    // @@protoc_insertion_point(field_release:trusted_vault_pb.Proto3Any.value)
    return _impl_.value_.Release();
}
inline void Proto3Any::set_allocated_value(std::string* value)
{
    if (value != nullptr) {

    } else {
    }
    _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:trusted_vault_pb.Proto3Any.value)
}

// -------------------------------------------------------------------

// RPCStatus

// repeated .trusted_vault_pb.Proto3Any details = 3;
inline int RPCStatus::_internal_details_size() const
{
    return _impl_.details_.size();
}
inline int RPCStatus::details_size() const
{
    return _internal_details_size();
}
inline void RPCStatus::clear_details()
{
    _impl_.details_.Clear();
}
inline ::trusted_vault_pb::Proto3Any* RPCStatus::mutable_details(int index)
{
    // @@protoc_insertion_point(field_mutable:trusted_vault_pb.RPCStatus.details)
    return _impl_.details_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::Proto3Any>* RPCStatus::mutable_details()
{
    // @@protoc_insertion_point(field_mutable_list:trusted_vault_pb.RPCStatus.details)
    return &_impl_.details_;
}
inline const ::trusted_vault_pb::Proto3Any& RPCStatus::_internal_details(int index) const
{
    return _impl_.details_.Get(index);
}
inline const ::trusted_vault_pb::Proto3Any& RPCStatus::details(int index) const
{
    // @@protoc_insertion_point(field_get:trusted_vault_pb.RPCStatus.details)
    return _internal_details(index);
}
inline ::trusted_vault_pb::Proto3Any* RPCStatus::_internal_add_details()
{
    return _impl_.details_.Add();
}
inline ::trusted_vault_pb::Proto3Any* RPCStatus::add_details()
{
    ::trusted_vault_pb::Proto3Any* _add = _internal_add_details();
    // @@protoc_insertion_point(field_add:trusted_vault_pb.RPCStatus.details)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::trusted_vault_pb::Proto3Any>& RPCStatus::details() const
{
    // @@protoc_insertion_point(field_list:trusted_vault_pb.RPCStatus.details)
    return _impl_.details_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace trusted_vault_pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::trusted_vault_pb::PhysicalDeviceMetadata_DeviceType> : ::std::true_type { };
template <> struct is_proto_enum<::trusted_vault_pb::SecurityDomainMember_MemberType> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_vault_2eproto
