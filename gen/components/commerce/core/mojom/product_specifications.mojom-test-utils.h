// components/commerce/core/mojom/product_specifications.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_COMMERCE_CORE_MOJOM_PRODUCT_SPECIFICATIONS_MOJOM_TEST_UTILS_H_
#define COMPONENTS_COMMERCE_CORE_MOJOM_PRODUCT_SPECIFICATIONS_MOJOM_TEST_UTILS_H_

#include "components/commerce/core/mojom/product_specifications.mojom.h"

namespace commerce::product_specifications::mojom {

class ProductSpecificationsHandlerInterceptorForTesting : public ProductSpecificationsHandler {
    virtual ProductSpecificationsHandler* GetForwardingInterface() = 0;
    void SetAcceptedDisclosureVersion(DisclosureVersion version) override;
    void MaybeShowDisclosure(
        const std::vector<::GURL>& urls, const std::string& name, const std::string& set_id, MaybeShowDisclosureCallback callback) override;
    void DeclineDisclosure() override;
    void ShowSyncSetupFlow() override;
    void GetPageTitleFromHistory(const ::GURL& url, GetPageTitleFromHistoryCallback callback) override;
    void ShowProductSpecificationsSetForUuid(const ::base::Uuid& uuid, bool in_new_tab) override;
};
class ProductSpecificationsHandlerAsyncWaiter {
public:
    explicit ProductSpecificationsHandlerAsyncWaiter(ProductSpecificationsHandler* proxy);

    ProductSpecificationsHandlerAsyncWaiter(const ProductSpecificationsHandlerAsyncWaiter&) = delete;
    ProductSpecificationsHandlerAsyncWaiter& operator=(const ProductSpecificationsHandlerAsyncWaiter&) = delete;

    ~ProductSpecificationsHandlerAsyncWaiter();
    void MaybeShowDisclosure(const std::vector<::GURL>& urls, const std::string& name, const std::string& set_id, bool* out_disclosure_shown);
    bool MaybeShowDisclosure(const std::vector<::GURL>& urls, const std::string& name, const std::string& set_id);
    void GetPageTitleFromHistory(const ::GURL& url, std::string* out_title);
    std::string GetPageTitleFromHistory(const ::GURL& url);

private:
    ProductSpecificationsHandler* const proxy_;
};

class PageInterceptorForTesting : public Page {
    virtual Page* GetForwardingInterface() = 0;
    void OnProductSpecificationsSetAdded(::commerce::shared::mojom::ProductSpecificationsSetPtr set) override;
    void OnProductSpecificationsSetUpdated(::commerce::shared::mojom::ProductSpecificationsSetPtr set) override;
    void OnProductSpecificationsSetRemoved(const ::base::Uuid& uuid) override;
};
class PageAsyncWaiter {
public:
    explicit PageAsyncWaiter(Page* proxy);

    PageAsyncWaiter(const PageAsyncWaiter&) = delete;
    PageAsyncWaiter& operator=(const PageAsyncWaiter&) = delete;

    ~PageAsyncWaiter();

private:
    Page* const proxy_;
};

class ProductSpecificationsHandlerFactoryInterceptorForTesting : public ProductSpecificationsHandlerFactory {
    virtual ProductSpecificationsHandlerFactory* GetForwardingInterface() = 0;
    void CreateProductSpecificationsHandler(::mojo::PendingRemote<Page> page, ::mojo::PendingReceiver<ProductSpecificationsHandler> handler) override;
};
class ProductSpecificationsHandlerFactoryAsyncWaiter {
public:
    explicit ProductSpecificationsHandlerFactoryAsyncWaiter(ProductSpecificationsHandlerFactory* proxy);

    ProductSpecificationsHandlerFactoryAsyncWaiter(const ProductSpecificationsHandlerFactoryAsyncWaiter&) = delete;
    ProductSpecificationsHandlerFactoryAsyncWaiter& operator=(const ProductSpecificationsHandlerFactoryAsyncWaiter&) = delete;

    ~ProductSpecificationsHandlerFactoryAsyncWaiter();

private:
    ProductSpecificationsHandlerFactory* const proxy_;
};

} // commerce::product_specifications::mojom

#endif // COMPONENTS_COMMERCE_CORE_MOJOM_PRODUCT_SPECIFICATIONS_MOJOM_TEST_UTILS_H_
