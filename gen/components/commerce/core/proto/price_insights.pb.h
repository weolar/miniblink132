// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/commerce/core/proto/price_insights.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fcommerce_2fcore_2fproto_2fprice_5finsights_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fcommerce_2fcore_2fproto_2fprice_5finsights_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fcommerce_2fcore_2fproto_2fprice_5finsights_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fcommerce_2fcore_2fproto_2fprice_5finsights_2eproto {
    static const uint32_t offsets[];
};
namespace commerce {
class PriceHistory;
struct PriceHistoryDefaultTypeInternal;
extern PriceHistoryDefaultTypeInternal _PriceHistory_default_instance_;
class PriceInsightsData;
struct PriceInsightsDataDefaultTypeInternal;
extern PriceInsightsDataDefaultTypeInternal _PriceInsightsData_default_instance_;
class PricePoint;
struct PricePointDefaultTypeInternal;
extern PricePointDefaultTypeInternal _PricePoint_default_instance_;
class PriceRange;
struct PriceRangeDefaultTypeInternal;
extern PriceRangeDefaultTypeInternal _PriceRange_default_instance_;
} // namespace commerce
PROTOBUF_NAMESPACE_OPEN
template <>::commerce::PriceHistory* Arena::CreateMaybeMessage<::commerce::PriceHistory>(Arena*);
template <>::commerce::PriceInsightsData* Arena::CreateMaybeMessage<::commerce::PriceInsightsData>(Arena*);
template <>::commerce::PricePoint* Arena::CreateMaybeMessage<::commerce::PricePoint>(Arena*);
template <>::commerce::PriceRange* Arena::CreateMaybeMessage<::commerce::PriceRange>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace commerce {

enum PriceInsightsData_PriceBucket : int {
    PriceInsightsData_PriceBucket_UNKNOWN = 0,
    PriceInsightsData_PriceBucket_LOW_PRICE = 1,
    PriceInsightsData_PriceBucket_TYPICAL_PRICE = 2,
    PriceInsightsData_PriceBucket_HIGH_PRICE = 3
};
bool PriceInsightsData_PriceBucket_IsValid(int value);
constexpr PriceInsightsData_PriceBucket PriceInsightsData_PriceBucket_PriceBucket_MIN = PriceInsightsData_PriceBucket_UNKNOWN;
constexpr PriceInsightsData_PriceBucket PriceInsightsData_PriceBucket_PriceBucket_MAX = PriceInsightsData_PriceBucket_HIGH_PRICE;
constexpr int PriceInsightsData_PriceBucket_PriceBucket_ARRAYSIZE = PriceInsightsData_PriceBucket_PriceBucket_MAX + 1;

const std::string& PriceInsightsData_PriceBucket_Name(PriceInsightsData_PriceBucket value);
template <typename T> inline const std::string& PriceInsightsData_PriceBucket_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, PriceInsightsData_PriceBucket>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function PriceInsightsData_PriceBucket_Name.");
    return PriceInsightsData_PriceBucket_Name(static_cast<PriceInsightsData_PriceBucket>(enum_t_value));
}
bool PriceInsightsData_PriceBucket_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PriceInsightsData_PriceBucket* value);
// ===================================================================

class PriceInsightsData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:commerce.PriceInsightsData) */ {
public:
    inline PriceInsightsData()
        : PriceInsightsData(nullptr)
    {
    }
    ~PriceInsightsData() override;
    explicit PROTOBUF_CONSTEXPR PriceInsightsData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PriceInsightsData(const PriceInsightsData& from);
    PriceInsightsData(PriceInsightsData&& from) noexcept
        : PriceInsightsData()
    {
        *this = ::std::move(from);
    }

    inline PriceInsightsData& operator=(const PriceInsightsData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline PriceInsightsData& operator=(PriceInsightsData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const PriceInsightsData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const PriceInsightsData* internal_default_instance()
    {
        return reinterpret_cast<const PriceInsightsData*>(&_PriceInsightsData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(PriceInsightsData& a, PriceInsightsData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(PriceInsightsData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PriceInsightsData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PriceInsightsData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<PriceInsightsData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const PriceInsightsData& from);
    void MergeFrom(const PriceInsightsData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PriceInsightsData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "commerce.PriceInsightsData";
    }

protected:
    explicit PriceInsightsData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef PriceInsightsData_PriceBucket PriceBucket;
    static constexpr PriceBucket UNKNOWN = PriceInsightsData_PriceBucket_UNKNOWN;
    static constexpr PriceBucket LOW_PRICE = PriceInsightsData_PriceBucket_LOW_PRICE;
    static constexpr PriceBucket TYPICAL_PRICE = PriceInsightsData_PriceBucket_TYPICAL_PRICE;
    static constexpr PriceBucket HIGH_PRICE = PriceInsightsData_PriceBucket_HIGH_PRICE;
    static inline bool PriceBucket_IsValid(int value)
    {
        return PriceInsightsData_PriceBucket_IsValid(value);
    }
    static constexpr PriceBucket PriceBucket_MIN = PriceInsightsData_PriceBucket_PriceBucket_MIN;
    static constexpr PriceBucket PriceBucket_MAX = PriceInsightsData_PriceBucket_PriceBucket_MAX;
    static constexpr int PriceBucket_ARRAYSIZE = PriceInsightsData_PriceBucket_PriceBucket_ARRAYSIZE;
    template <typename T> static inline const std::string& PriceBucket_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, PriceBucket>::value || ::std::is_integral<T>::value, "Incorrect type passed to function PriceBucket_Name.");
        return PriceInsightsData_PriceBucket_Name(enum_t_value);
    }
    static inline bool PriceBucket_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PriceBucket* value)
    {
        return PriceInsightsData_PriceBucket_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kPriceRangeFieldNumber = 2,
        kPriceHistoryFieldNumber = 3,
        kProductClusterIdFieldNumber = 1,
        kPriceBucketFieldNumber = 4,
        kHasMultipleCatalogsFieldNumber = 5,
    };
    // optional .commerce.PriceRange price_range = 2;
    bool has_price_range() const;

private:
    bool _internal_has_price_range() const;

public:
    void clear_price_range();
    const ::commerce::PriceRange& price_range() const;
    PROTOBUF_NODISCARD ::commerce::PriceRange* release_price_range();
    ::commerce::PriceRange* mutable_price_range();
    void set_allocated_price_range(::commerce::PriceRange* price_range);

private:
    const ::commerce::PriceRange& _internal_price_range() const;
    ::commerce::PriceRange* _internal_mutable_price_range();

public:
    void unsafe_arena_set_allocated_price_range(::commerce::PriceRange* price_range);
    ::commerce::PriceRange* unsafe_arena_release_price_range();

    // optional .commerce.PriceHistory price_history = 3;
    bool has_price_history() const;

private:
    bool _internal_has_price_history() const;

public:
    void clear_price_history();
    const ::commerce::PriceHistory& price_history() const;
    PROTOBUF_NODISCARD ::commerce::PriceHistory* release_price_history();
    ::commerce::PriceHistory* mutable_price_history();
    void set_allocated_price_history(::commerce::PriceHistory* price_history);

private:
    const ::commerce::PriceHistory& _internal_price_history() const;
    ::commerce::PriceHistory* _internal_mutable_price_history();

public:
    void unsafe_arena_set_allocated_price_history(::commerce::PriceHistory* price_history);
    ::commerce::PriceHistory* unsafe_arena_release_price_history();

    // optional uint64 product_cluster_id = 1;
    bool has_product_cluster_id() const;

private:
    bool _internal_has_product_cluster_id() const;

public:
    void clear_product_cluster_id();
    uint64_t product_cluster_id() const;
    void set_product_cluster_id(uint64_t value);

private:
    uint64_t _internal_product_cluster_id() const;
    void _internal_set_product_cluster_id(uint64_t value);

public:
    // optional .commerce.PriceInsightsData.PriceBucket price_bucket = 4;
    bool has_price_bucket() const;

private:
    bool _internal_has_price_bucket() const;

public:
    void clear_price_bucket();
    ::commerce::PriceInsightsData_PriceBucket price_bucket() const;
    void set_price_bucket(::commerce::PriceInsightsData_PriceBucket value);

private:
    ::commerce::PriceInsightsData_PriceBucket _internal_price_bucket() const;
    void _internal_set_price_bucket(::commerce::PriceInsightsData_PriceBucket value);

public:
    // optional bool has_multiple_catalogs = 5;
    bool has_has_multiple_catalogs() const;

private:
    bool _internal_has_has_multiple_catalogs() const;

public:
    void clear_has_multiple_catalogs();
    bool has_multiple_catalogs() const;
    void set_has_multiple_catalogs(bool value);

private:
    bool _internal_has_multiple_catalogs() const;
    void _internal_set_has_multiple_catalogs(bool value);

public:
    // @@protoc_insertion_point(class_scope:commerce.PriceInsightsData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::commerce::PriceRange* price_range_;
        ::commerce::PriceHistory* price_history_;
        uint64_t product_cluster_id_;
        int price_bucket_;
        bool has_multiple_catalogs_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fcommerce_2fcore_2fproto_2fprice_5finsights_2eproto;
};
// -------------------------------------------------------------------

class PriceRange final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:commerce.PriceRange) */ {
public:
    inline PriceRange()
        : PriceRange(nullptr)
    {
    }
    ~PriceRange() override;
    explicit PROTOBUF_CONSTEXPR PriceRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PriceRange(const PriceRange& from);
    PriceRange(PriceRange&& from) noexcept
        : PriceRange()
    {
        *this = ::std::move(from);
    }

    inline PriceRange& operator=(const PriceRange& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline PriceRange& operator=(PriceRange&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const PriceRange& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const PriceRange* internal_default_instance()
    {
        return reinterpret_cast<const PriceRange*>(&_PriceRange_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(PriceRange& a, PriceRange& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(PriceRange* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PriceRange* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PriceRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<PriceRange>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const PriceRange& from);
    void MergeFrom(const PriceRange& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PriceRange* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "commerce.PriceRange";
    }

protected:
    explicit PriceRange(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCurrencyCodeFieldNumber = 1,
        kLowestTypicalPriceMicrosFieldNumber = 2,
        kHighestTypicalPriceMicrosFieldNumber = 3,
    };
    // optional string currency_code = 1;
    bool has_currency_code() const;

private:
    bool _internal_has_currency_code() const;

public:
    void clear_currency_code();
    const std::string& currency_code() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_currency_code(ArgT0&& arg0, ArgT... args);
    std::string* mutable_currency_code();
    PROTOBUF_NODISCARD std::string* release_currency_code();
    void set_allocated_currency_code(std::string* currency_code);

private:
    const std::string& _internal_currency_code() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_currency_code(const std::string& value);
    std::string* _internal_mutable_currency_code();

public:
    // optional int64 lowest_typical_price_micros = 2;
    bool has_lowest_typical_price_micros() const;

private:
    bool _internal_has_lowest_typical_price_micros() const;

public:
    void clear_lowest_typical_price_micros();
    int64_t lowest_typical_price_micros() const;
    void set_lowest_typical_price_micros(int64_t value);

private:
    int64_t _internal_lowest_typical_price_micros() const;
    void _internal_set_lowest_typical_price_micros(int64_t value);

public:
    // optional int64 highest_typical_price_micros = 3;
    bool has_highest_typical_price_micros() const;

private:
    bool _internal_has_highest_typical_price_micros() const;

public:
    void clear_highest_typical_price_micros();
    int64_t highest_typical_price_micros() const;
    void set_highest_typical_price_micros(int64_t value);

private:
    int64_t _internal_highest_typical_price_micros() const;
    void _internal_set_highest_typical_price_micros(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:commerce.PriceRange)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currency_code_;
        int64_t lowest_typical_price_micros_;
        int64_t highest_typical_price_micros_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fcommerce_2fcore_2fproto_2fprice_5finsights_2eproto;
};
// -------------------------------------------------------------------

class PricePoint final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:commerce.PricePoint) */ {
public:
    inline PricePoint()
        : PricePoint(nullptr)
    {
    }
    ~PricePoint() override;
    explicit PROTOBUF_CONSTEXPR PricePoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PricePoint(const PricePoint& from);
    PricePoint(PricePoint&& from) noexcept
        : PricePoint()
    {
        *this = ::std::move(from);
    }

    inline PricePoint& operator=(const PricePoint& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline PricePoint& operator=(PricePoint&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const PricePoint& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const PricePoint* internal_default_instance()
    {
        return reinterpret_cast<const PricePoint*>(&_PricePoint_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(PricePoint& a, PricePoint& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(PricePoint* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PricePoint* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PricePoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<PricePoint>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const PricePoint& from);
    void MergeFrom(const PricePoint& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PricePoint* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "commerce.PricePoint";
    }

protected:
    explicit PricePoint(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDateFieldNumber = 1,
        kMinPriceMicrosFieldNumber = 2,
    };
    // optional string date = 1;
    bool has_date() const;

private:
    bool _internal_has_date() const;

public:
    void clear_date();
    const std::string& date() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_date(ArgT0&& arg0, ArgT... args);
    std::string* mutable_date();
    PROTOBUF_NODISCARD std::string* release_date();
    void set_allocated_date(std::string* date);

private:
    const std::string& _internal_date() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_date(const std::string& value);
    std::string* _internal_mutable_date();

public:
    // optional int64 min_price_micros = 2;
    bool has_min_price_micros() const;

private:
    bool _internal_has_min_price_micros() const;

public:
    void clear_min_price_micros();
    int64_t min_price_micros() const;
    void set_min_price_micros(int64_t value);

private:
    int64_t _internal_min_price_micros() const;
    void _internal_set_min_price_micros(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:commerce.PricePoint)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
        int64_t min_price_micros_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fcommerce_2fcore_2fproto_2fprice_5finsights_2eproto;
};
// -------------------------------------------------------------------

class PriceHistory final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:commerce.PriceHistory) */ {
public:
    inline PriceHistory()
        : PriceHistory(nullptr)
    {
    }
    ~PriceHistory() override;
    explicit PROTOBUF_CONSTEXPR PriceHistory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PriceHistory(const PriceHistory& from);
    PriceHistory(PriceHistory&& from) noexcept
        : PriceHistory()
    {
        *this = ::std::move(from);
    }

    inline PriceHistory& operator=(const PriceHistory& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline PriceHistory& operator=(PriceHistory&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const PriceHistory& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const PriceHistory* internal_default_instance()
    {
        return reinterpret_cast<const PriceHistory*>(&_PriceHistory_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(PriceHistory& a, PriceHistory& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(PriceHistory* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PriceHistory* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PriceHistory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<PriceHistory>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const PriceHistory& from);
    void MergeFrom(const PriceHistory& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PriceHistory* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "commerce.PriceHistory";
    }

protected:
    explicit PriceHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kPricePointsFieldNumber = 3,
        kCurrencyCodeFieldNumber = 1,
        kAttributesFieldNumber = 2,
        kJackpotUrlFieldNumber = 4,
    };
    // repeated .commerce.PricePoint price_points = 3;
    int price_points_size() const;

private:
    int _internal_price_points_size() const;

public:
    void clear_price_points();
    ::commerce::PricePoint* mutable_price_points(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::commerce::PricePoint>* mutable_price_points();

private:
    const ::commerce::PricePoint& _internal_price_points(int index) const;
    ::commerce::PricePoint* _internal_add_price_points();

public:
    const ::commerce::PricePoint& price_points(int index) const;
    ::commerce::PricePoint* add_price_points();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::commerce::PricePoint>& price_points() const;

    // optional string currency_code = 1;
    bool has_currency_code() const;

private:
    bool _internal_has_currency_code() const;

public:
    void clear_currency_code();
    const std::string& currency_code() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_currency_code(ArgT0&& arg0, ArgT... args);
    std::string* mutable_currency_code();
    PROTOBUF_NODISCARD std::string* release_currency_code();
    void set_allocated_currency_code(std::string* currency_code);

private:
    const std::string& _internal_currency_code() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_currency_code(const std::string& value);
    std::string* _internal_mutable_currency_code();

public:
    // optional string attributes = 2;
    bool has_attributes() const;

private:
    bool _internal_has_attributes() const;

public:
    void clear_attributes();
    const std::string& attributes() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_attributes(ArgT0&& arg0, ArgT... args);
    std::string* mutable_attributes();
    PROTOBUF_NODISCARD std::string* release_attributes();
    void set_allocated_attributes(std::string* attributes);

private:
    const std::string& _internal_attributes() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_attributes(const std::string& value);
    std::string* _internal_mutable_attributes();

public:
    // optional string jackpot_url = 4;
    bool has_jackpot_url() const;

private:
    bool _internal_has_jackpot_url() const;

public:
    void clear_jackpot_url();
    const std::string& jackpot_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_jackpot_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_jackpot_url();
    PROTOBUF_NODISCARD std::string* release_jackpot_url();
    void set_allocated_jackpot_url(std::string* jackpot_url);

private:
    const std::string& _internal_jackpot_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_jackpot_url(const std::string& value);
    std::string* _internal_mutable_jackpot_url();

public:
    // @@protoc_insertion_point(class_scope:commerce.PriceHistory)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::commerce::PricePoint> price_points_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currency_code_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attributes_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jackpot_url_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fcommerce_2fcore_2fproto_2fprice_5finsights_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// PriceInsightsData

// optional uint64 product_cluster_id = 1;
inline bool PriceInsightsData::_internal_has_product_cluster_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool PriceInsightsData::has_product_cluster_id() const
{
    return _internal_has_product_cluster_id();
}
inline void PriceInsightsData::clear_product_cluster_id()
{
    _impl_.product_cluster_id_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t PriceInsightsData::_internal_product_cluster_id() const
{
    return _impl_.product_cluster_id_;
}
inline uint64_t PriceInsightsData::product_cluster_id() const
{
    // @@protoc_insertion_point(field_get:commerce.PriceInsightsData.product_cluster_id)
    return _internal_product_cluster_id();
}
inline void PriceInsightsData::_internal_set_product_cluster_id(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.product_cluster_id_ = value;
}
inline void PriceInsightsData::set_product_cluster_id(uint64_t value)
{
    _internal_set_product_cluster_id(value);
    // @@protoc_insertion_point(field_set:commerce.PriceInsightsData.product_cluster_id)
}

// optional .commerce.PriceRange price_range = 2;
inline bool PriceInsightsData::_internal_has_price_range() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.price_range_ != nullptr);
    return value;
}
inline bool PriceInsightsData::has_price_range() const
{
    return _internal_has_price_range();
}
inline void PriceInsightsData::clear_price_range()
{
    if (_impl_.price_range_ != nullptr)
        _impl_.price_range_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::commerce::PriceRange& PriceInsightsData::_internal_price_range() const
{
    const ::commerce::PriceRange* p = _impl_.price_range_;
    return p != nullptr ? *p : reinterpret_cast<const ::commerce::PriceRange&>(::commerce::_PriceRange_default_instance_);
}
inline const ::commerce::PriceRange& PriceInsightsData::price_range() const
{
    // @@protoc_insertion_point(field_get:commerce.PriceInsightsData.price_range)
    return _internal_price_range();
}
inline void PriceInsightsData::unsafe_arena_set_allocated_price_range(::commerce::PriceRange* price_range)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.price_range_);
    }
    _impl_.price_range_ = price_range;
    if (price_range) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commerce.PriceInsightsData.price_range)
}
inline ::commerce::PriceRange* PriceInsightsData::release_price_range()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::commerce::PriceRange* temp = _impl_.price_range_;
    _impl_.price_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::commerce::PriceRange* PriceInsightsData::unsafe_arena_release_price_range()
{
    // @@protoc_insertion_point(field_release:commerce.PriceInsightsData.price_range)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::commerce::PriceRange* temp = _impl_.price_range_;
    _impl_.price_range_ = nullptr;
    return temp;
}
inline ::commerce::PriceRange* PriceInsightsData::_internal_mutable_price_range()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.price_range_ == nullptr) {
        auto* p = CreateMaybeMessage<::commerce::PriceRange>(GetArenaForAllocation());
        _impl_.price_range_ = p;
    }
    return _impl_.price_range_;
}
inline ::commerce::PriceRange* PriceInsightsData::mutable_price_range()
{
    ::commerce::PriceRange* _msg = _internal_mutable_price_range();
    // @@protoc_insertion_point(field_mutable:commerce.PriceInsightsData.price_range)
    return _msg;
}
inline void PriceInsightsData::set_allocated_price_range(::commerce::PriceRange* price_range)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.price_range_;
    }
    if (price_range) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(price_range);
        if (message_arena != submessage_arena) {
            price_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, price_range, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.price_range_ = price_range;
    // @@protoc_insertion_point(field_set_allocated:commerce.PriceInsightsData.price_range)
}

// optional .commerce.PriceHistory price_history = 3;
inline bool PriceInsightsData::_internal_has_price_history() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.price_history_ != nullptr);
    return value;
}
inline bool PriceInsightsData::has_price_history() const
{
    return _internal_has_price_history();
}
inline void PriceInsightsData::clear_price_history()
{
    if (_impl_.price_history_ != nullptr)
        _impl_.price_history_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::commerce::PriceHistory& PriceInsightsData::_internal_price_history() const
{
    const ::commerce::PriceHistory* p = _impl_.price_history_;
    return p != nullptr ? *p : reinterpret_cast<const ::commerce::PriceHistory&>(::commerce::_PriceHistory_default_instance_);
}
inline const ::commerce::PriceHistory& PriceInsightsData::price_history() const
{
    // @@protoc_insertion_point(field_get:commerce.PriceInsightsData.price_history)
    return _internal_price_history();
}
inline void PriceInsightsData::unsafe_arena_set_allocated_price_history(::commerce::PriceHistory* price_history)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.price_history_);
    }
    _impl_.price_history_ = price_history;
    if (price_history) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:commerce.PriceInsightsData.price_history)
}
inline ::commerce::PriceHistory* PriceInsightsData::release_price_history()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::commerce::PriceHistory* temp = _impl_.price_history_;
    _impl_.price_history_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::commerce::PriceHistory* PriceInsightsData::unsafe_arena_release_price_history()
{
    // @@protoc_insertion_point(field_release:commerce.PriceInsightsData.price_history)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::commerce::PriceHistory* temp = _impl_.price_history_;
    _impl_.price_history_ = nullptr;
    return temp;
}
inline ::commerce::PriceHistory* PriceInsightsData::_internal_mutable_price_history()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.price_history_ == nullptr) {
        auto* p = CreateMaybeMessage<::commerce::PriceHistory>(GetArenaForAllocation());
        _impl_.price_history_ = p;
    }
    return _impl_.price_history_;
}
inline ::commerce::PriceHistory* PriceInsightsData::mutable_price_history()
{
    ::commerce::PriceHistory* _msg = _internal_mutable_price_history();
    // @@protoc_insertion_point(field_mutable:commerce.PriceInsightsData.price_history)
    return _msg;
}
inline void PriceInsightsData::set_allocated_price_history(::commerce::PriceHistory* price_history)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.price_history_;
    }
    if (price_history) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(price_history);
        if (message_arena != submessage_arena) {
            price_history = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, price_history, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.price_history_ = price_history;
    // @@protoc_insertion_point(field_set_allocated:commerce.PriceInsightsData.price_history)
}

// optional .commerce.PriceInsightsData.PriceBucket price_bucket = 4;
inline bool PriceInsightsData::_internal_has_price_bucket() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool PriceInsightsData::has_price_bucket() const
{
    return _internal_has_price_bucket();
}
inline void PriceInsightsData::clear_price_bucket()
{
    _impl_.price_bucket_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::commerce::PriceInsightsData_PriceBucket PriceInsightsData::_internal_price_bucket() const
{
    return static_cast<::commerce::PriceInsightsData_PriceBucket>(_impl_.price_bucket_);
}
inline ::commerce::PriceInsightsData_PriceBucket PriceInsightsData::price_bucket() const
{
    // @@protoc_insertion_point(field_get:commerce.PriceInsightsData.price_bucket)
    return _internal_price_bucket();
}
inline void PriceInsightsData::_internal_set_price_bucket(::commerce::PriceInsightsData_PriceBucket value)
{
    assert(::commerce::PriceInsightsData_PriceBucket_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.price_bucket_ = value;
}
inline void PriceInsightsData::set_price_bucket(::commerce::PriceInsightsData_PriceBucket value)
{
    _internal_set_price_bucket(value);
    // @@protoc_insertion_point(field_set:commerce.PriceInsightsData.price_bucket)
}

// optional bool has_multiple_catalogs = 5;
inline bool PriceInsightsData::_internal_has_has_multiple_catalogs() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool PriceInsightsData::has_has_multiple_catalogs() const
{
    return _internal_has_has_multiple_catalogs();
}
inline void PriceInsightsData::clear_has_multiple_catalogs()
{
    _impl_.has_multiple_catalogs_ = false;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool PriceInsightsData::_internal_has_multiple_catalogs() const
{
    return _impl_.has_multiple_catalogs_;
}
inline bool PriceInsightsData::has_multiple_catalogs() const
{
    // @@protoc_insertion_point(field_get:commerce.PriceInsightsData.has_multiple_catalogs)
    return _internal_has_multiple_catalogs();
}
inline void PriceInsightsData::_internal_set_has_multiple_catalogs(bool value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.has_multiple_catalogs_ = value;
}
inline void PriceInsightsData::set_has_multiple_catalogs(bool value)
{
    _internal_set_has_multiple_catalogs(value);
    // @@protoc_insertion_point(field_set:commerce.PriceInsightsData.has_multiple_catalogs)
}

// -------------------------------------------------------------------

// PriceRange

// optional string currency_code = 1;
inline bool PriceRange::_internal_has_currency_code() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool PriceRange::has_currency_code() const
{
    return _internal_has_currency_code();
}
inline void PriceRange::clear_currency_code()
{
    _impl_.currency_code_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PriceRange::currency_code() const
{
    // @@protoc_insertion_point(field_get:commerce.PriceRange.currency_code)
    return _internal_currency_code();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PriceRange::set_currency_code(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.currency_code_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:commerce.PriceRange.currency_code)
}
inline std::string* PriceRange::mutable_currency_code()
{
    std::string* _s = _internal_mutable_currency_code();
    // @@protoc_insertion_point(field_mutable:commerce.PriceRange.currency_code)
    return _s;
}
inline const std::string& PriceRange::_internal_currency_code() const
{
    return _impl_.currency_code_.Get();
}
inline void PriceRange::_internal_set_currency_code(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.currency_code_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceRange::_internal_mutable_currency_code()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.currency_code_.Mutable(GetArenaForAllocation());
}
inline std::string* PriceRange::release_currency_code()
{
    // @@protoc_insertion_point(field_release:commerce.PriceRange.currency_code)
    if (!_internal_has_currency_code()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.currency_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.currency_code_.IsDefault()) {
        _impl_.currency_code_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void PriceRange::set_allocated_currency_code(std::string* currency_code)
{
    if (currency_code != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.currency_code_.SetAllocated(currency_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.currency_code_.IsDefault()) {
        _impl_.currency_code_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:commerce.PriceRange.currency_code)
}

// optional int64 lowest_typical_price_micros = 2;
inline bool PriceRange::_internal_has_lowest_typical_price_micros() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool PriceRange::has_lowest_typical_price_micros() const
{
    return _internal_has_lowest_typical_price_micros();
}
inline void PriceRange::clear_lowest_typical_price_micros()
{
    _impl_.lowest_typical_price_micros_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t PriceRange::_internal_lowest_typical_price_micros() const
{
    return _impl_.lowest_typical_price_micros_;
}
inline int64_t PriceRange::lowest_typical_price_micros() const
{
    // @@protoc_insertion_point(field_get:commerce.PriceRange.lowest_typical_price_micros)
    return _internal_lowest_typical_price_micros();
}
inline void PriceRange::_internal_set_lowest_typical_price_micros(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.lowest_typical_price_micros_ = value;
}
inline void PriceRange::set_lowest_typical_price_micros(int64_t value)
{
    _internal_set_lowest_typical_price_micros(value);
    // @@protoc_insertion_point(field_set:commerce.PriceRange.lowest_typical_price_micros)
}

// optional int64 highest_typical_price_micros = 3;
inline bool PriceRange::_internal_has_highest_typical_price_micros() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool PriceRange::has_highest_typical_price_micros() const
{
    return _internal_has_highest_typical_price_micros();
}
inline void PriceRange::clear_highest_typical_price_micros()
{
    _impl_.highest_typical_price_micros_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t PriceRange::_internal_highest_typical_price_micros() const
{
    return _impl_.highest_typical_price_micros_;
}
inline int64_t PriceRange::highest_typical_price_micros() const
{
    // @@protoc_insertion_point(field_get:commerce.PriceRange.highest_typical_price_micros)
    return _internal_highest_typical_price_micros();
}
inline void PriceRange::_internal_set_highest_typical_price_micros(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.highest_typical_price_micros_ = value;
}
inline void PriceRange::set_highest_typical_price_micros(int64_t value)
{
    _internal_set_highest_typical_price_micros(value);
    // @@protoc_insertion_point(field_set:commerce.PriceRange.highest_typical_price_micros)
}

// -------------------------------------------------------------------

// PricePoint

// optional string date = 1;
inline bool PricePoint::_internal_has_date() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool PricePoint::has_date() const
{
    return _internal_has_date();
}
inline void PricePoint::clear_date()
{
    _impl_.date_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PricePoint::date() const
{
    // @@protoc_insertion_point(field_get:commerce.PricePoint.date)
    return _internal_date();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PricePoint::set_date(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.date_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:commerce.PricePoint.date)
}
inline std::string* PricePoint::mutable_date()
{
    std::string* _s = _internal_mutable_date();
    // @@protoc_insertion_point(field_mutable:commerce.PricePoint.date)
    return _s;
}
inline const std::string& PricePoint::_internal_date() const
{
    return _impl_.date_.Get();
}
inline void PricePoint::_internal_set_date(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.date_.Set(value, GetArenaForAllocation());
}
inline std::string* PricePoint::_internal_mutable_date()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.date_.Mutable(GetArenaForAllocation());
}
inline std::string* PricePoint::release_date()
{
    // @@protoc_insertion_point(field_release:commerce.PricePoint.date)
    if (!_internal_has_date()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.date_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.date_.IsDefault()) {
        _impl_.date_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void PricePoint::set_allocated_date(std::string* date)
{
    if (date != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.date_.SetAllocated(date, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.date_.IsDefault()) {
        _impl_.date_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:commerce.PricePoint.date)
}

// optional int64 min_price_micros = 2;
inline bool PricePoint::_internal_has_min_price_micros() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool PricePoint::has_min_price_micros() const
{
    return _internal_has_min_price_micros();
}
inline void PricePoint::clear_min_price_micros()
{
    _impl_.min_price_micros_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t PricePoint::_internal_min_price_micros() const
{
    return _impl_.min_price_micros_;
}
inline int64_t PricePoint::min_price_micros() const
{
    // @@protoc_insertion_point(field_get:commerce.PricePoint.min_price_micros)
    return _internal_min_price_micros();
}
inline void PricePoint::_internal_set_min_price_micros(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.min_price_micros_ = value;
}
inline void PricePoint::set_min_price_micros(int64_t value)
{
    _internal_set_min_price_micros(value);
    // @@protoc_insertion_point(field_set:commerce.PricePoint.min_price_micros)
}

// -------------------------------------------------------------------

// PriceHistory

// optional string currency_code = 1;
inline bool PriceHistory::_internal_has_currency_code() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool PriceHistory::has_currency_code() const
{
    return _internal_has_currency_code();
}
inline void PriceHistory::clear_currency_code()
{
    _impl_.currency_code_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PriceHistory::currency_code() const
{
    // @@protoc_insertion_point(field_get:commerce.PriceHistory.currency_code)
    return _internal_currency_code();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PriceHistory::set_currency_code(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.currency_code_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:commerce.PriceHistory.currency_code)
}
inline std::string* PriceHistory::mutable_currency_code()
{
    std::string* _s = _internal_mutable_currency_code();
    // @@protoc_insertion_point(field_mutable:commerce.PriceHistory.currency_code)
    return _s;
}
inline const std::string& PriceHistory::_internal_currency_code() const
{
    return _impl_.currency_code_.Get();
}
inline void PriceHistory::_internal_set_currency_code(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.currency_code_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceHistory::_internal_mutable_currency_code()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.currency_code_.Mutable(GetArenaForAllocation());
}
inline std::string* PriceHistory::release_currency_code()
{
    // @@protoc_insertion_point(field_release:commerce.PriceHistory.currency_code)
    if (!_internal_has_currency_code()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.currency_code_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.currency_code_.IsDefault()) {
        _impl_.currency_code_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void PriceHistory::set_allocated_currency_code(std::string* currency_code)
{
    if (currency_code != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.currency_code_.SetAllocated(currency_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.currency_code_.IsDefault()) {
        _impl_.currency_code_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:commerce.PriceHistory.currency_code)
}

// optional string attributes = 2;
inline bool PriceHistory::_internal_has_attributes() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool PriceHistory::has_attributes() const
{
    return _internal_has_attributes();
}
inline void PriceHistory::clear_attributes()
{
    _impl_.attributes_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PriceHistory::attributes() const
{
    // @@protoc_insertion_point(field_get:commerce.PriceHistory.attributes)
    return _internal_attributes();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PriceHistory::set_attributes(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.attributes_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:commerce.PriceHistory.attributes)
}
inline std::string* PriceHistory::mutable_attributes()
{
    std::string* _s = _internal_mutable_attributes();
    // @@protoc_insertion_point(field_mutable:commerce.PriceHistory.attributes)
    return _s;
}
inline const std::string& PriceHistory::_internal_attributes() const
{
    return _impl_.attributes_.Get();
}
inline void PriceHistory::_internal_set_attributes(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.attributes_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceHistory::_internal_mutable_attributes()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.attributes_.Mutable(GetArenaForAllocation());
}
inline std::string* PriceHistory::release_attributes()
{
    // @@protoc_insertion_point(field_release:commerce.PriceHistory.attributes)
    if (!_internal_has_attributes()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.attributes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.attributes_.IsDefault()) {
        _impl_.attributes_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void PriceHistory::set_allocated_attributes(std::string* attributes)
{
    if (attributes != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.attributes_.SetAllocated(attributes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.attributes_.IsDefault()) {
        _impl_.attributes_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:commerce.PriceHistory.attributes)
}

// repeated .commerce.PricePoint price_points = 3;
inline int PriceHistory::_internal_price_points_size() const
{
    return _impl_.price_points_.size();
}
inline int PriceHistory::price_points_size() const
{
    return _internal_price_points_size();
}
inline void PriceHistory::clear_price_points()
{
    _impl_.price_points_.Clear();
}
inline ::commerce::PricePoint* PriceHistory::mutable_price_points(int index)
{
    // @@protoc_insertion_point(field_mutable:commerce.PriceHistory.price_points)
    return _impl_.price_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::commerce::PricePoint>* PriceHistory::mutable_price_points()
{
    // @@protoc_insertion_point(field_mutable_list:commerce.PriceHistory.price_points)
    return &_impl_.price_points_;
}
inline const ::commerce::PricePoint& PriceHistory::_internal_price_points(int index) const
{
    return _impl_.price_points_.Get(index);
}
inline const ::commerce::PricePoint& PriceHistory::price_points(int index) const
{
    // @@protoc_insertion_point(field_get:commerce.PriceHistory.price_points)
    return _internal_price_points(index);
}
inline ::commerce::PricePoint* PriceHistory::_internal_add_price_points()
{
    return _impl_.price_points_.Add();
}
inline ::commerce::PricePoint* PriceHistory::add_price_points()
{
    ::commerce::PricePoint* _add = _internal_add_price_points();
    // @@protoc_insertion_point(field_add:commerce.PriceHistory.price_points)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::commerce::PricePoint>& PriceHistory::price_points() const
{
    // @@protoc_insertion_point(field_list:commerce.PriceHistory.price_points)
    return _impl_.price_points_;
}

// optional string jackpot_url = 4;
inline bool PriceHistory::_internal_has_jackpot_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool PriceHistory::has_jackpot_url() const
{
    return _internal_has_jackpot_url();
}
inline void PriceHistory::clear_jackpot_url()
{
    _impl_.jackpot_url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PriceHistory::jackpot_url() const
{
    // @@protoc_insertion_point(field_get:commerce.PriceHistory.jackpot_url)
    return _internal_jackpot_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PriceHistory::set_jackpot_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.jackpot_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:commerce.PriceHistory.jackpot_url)
}
inline std::string* PriceHistory::mutable_jackpot_url()
{
    std::string* _s = _internal_mutable_jackpot_url();
    // @@protoc_insertion_point(field_mutable:commerce.PriceHistory.jackpot_url)
    return _s;
}
inline const std::string& PriceHistory::_internal_jackpot_url() const
{
    return _impl_.jackpot_url_.Get();
}
inline void PriceHistory::_internal_set_jackpot_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.jackpot_url_.Set(value, GetArenaForAllocation());
}
inline std::string* PriceHistory::_internal_mutable_jackpot_url()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.jackpot_url_.Mutable(GetArenaForAllocation());
}
inline std::string* PriceHistory::release_jackpot_url()
{
    // @@protoc_insertion_point(field_release:commerce.PriceHistory.jackpot_url)
    if (!_internal_has_jackpot_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.jackpot_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.jackpot_url_.IsDefault()) {
        _impl_.jackpot_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void PriceHistory::set_allocated_jackpot_url(std::string* jackpot_url)
{
    if (jackpot_url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.jackpot_url_.SetAllocated(jackpot_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.jackpot_url_.IsDefault()) {
        _impl_.jackpot_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:commerce.PriceHistory.jackpot_url)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace commerce

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::commerce::PriceInsightsData_PriceBucket> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fcommerce_2fcore_2fproto_2fprice_5finsights_2eproto
