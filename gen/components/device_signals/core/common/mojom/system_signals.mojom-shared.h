// components/device_signals/core/common/mojom/system_signals.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_DEVICE_SIGNALS_CORE_COMMON_MOJOM_SYSTEM_SIGNALS_MOJOM_SHARED_H_
#define COMPONENTS_DEVICE_SIGNALS_CORE_COMMON_MOJOM_SYSTEM_SIGNALS_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "components/device_signals/core/common/mojom/system_signals.mojom-shared-internal.h"
#include "sandbox/policy/mojom/context.mojom-shared.h"
#include "sandbox/policy/mojom/sandbox.mojom-shared.h"
#include "mojo/public/mojom/base/byte_string.mojom-shared.h"
#include "mojo/public/mojom/base/file_path.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"
#include "mojo/public/cpp/system/data_pipe.h"

namespace device_signals::mojom {
class ExecutableMetadataDataView;

class FileSystemItemDataView;

class FileSystemItemRequestDataView;

class AntiVirusSignalDataView;

class HotfixSignalDataView;

} // device_signals::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::device_signals::mojom::ExecutableMetadataDataView> {
    using Data = ::device_signals::mojom::internal::ExecutableMetadata_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::device_signals::mojom::FileSystemItemDataView> {
    using Data = ::device_signals::mojom::internal::FileSystemItem_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::device_signals::mojom::FileSystemItemRequestDataView> {
    using Data = ::device_signals::mojom::internal::FileSystemItemRequest_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::device_signals::mojom::AntiVirusSignalDataView> {
    using Data = ::device_signals::mojom::internal::AntiVirusSignal_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::device_signals::mojom::HotfixSignalDataView> {
    using Data = ::device_signals::mojom::internal::HotfixSignal_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

} // namespace internal
} // namespace mojo

namespace device_signals::mojom {

enum class PresenceValue : int32_t {

    kUnspecified = 0,

    kAccessDenied = 1,

    kNotFound = 2,

    kFound = 3,
    kMinValue = 0,
    kMaxValue = 3,
};

std::ostream& operator<<(std::ostream& os, PresenceValue value);
inline bool IsKnownEnumValue(PresenceValue value)
{
    return internal::PresenceValue_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class AntiVirusProductState : int32_t {

    kOn = 0,

    kOff = 1,

    kSnoozed = 2,

    kExpired = 3,
    kMinValue = 0,
    kMaxValue = 3,
};

std::ostream& operator<<(std::ostream& os, AntiVirusProductState value);
inline bool IsKnownEnumValue(AntiVirusProductState value)
{
    return internal::AntiVirusProductState_Data::IsKnownValue(static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class SystemSignalsServiceInterfaceBase { };

using SystemSignalsServicePtrDataView = mojo::InterfacePtrDataView<SystemSignalsServiceInterfaceBase>;
using SystemSignalsServiceRequestDataView = mojo::InterfaceRequestDataView<SystemSignalsServiceInterfaceBase>;
using SystemSignalsServiceAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<SystemSignalsServiceInterfaceBase>;
using SystemSignalsServiceAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<SystemSignalsServiceInterfaceBase>;

class ExecutableMetadataDataView {
public:
    ExecutableMetadataDataView() = default;

    ExecutableMetadataDataView(internal::ExecutableMetadata_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    bool is_running() const
    {
        return data_->is_running;
    }
    inline void GetPublicKeysHashesDataView(mojo::ArrayDataView<::mojo_base::mojom::ByteStringDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadPublicKeysHashes(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::ArrayDataView<::mojo_base::mojom::ByteStringDataView>, UserType>(),
            "Attempting to read the optional `public_keys_hashes` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadPublicKeysHashes` instead "
            "of `ReadPublicKeysHashes if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->public_keys_hashes.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::mojo_base::mojom::ByteStringDataView>>(pointer, output, message_);
    }
    inline void GetProductNameDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadProductName(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `product_name` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadProductName` instead "
            "of `ReadProductName if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->product_name.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetVersionDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadVersion(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `version` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadVersion` instead "
            "of `ReadVersion if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->version.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    bool is_os_verified() const
    {
        return data_->is_os_verified;
    }
    inline void GetSubjectNameDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSubjectName(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `subject_name` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadSubjectName` instead "
            "of `ReadSubjectName if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->subject_name.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }

private:
    internal::ExecutableMetadata_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class FileSystemItemDataView {
public:
    FileSystemItemDataView() = default;

    FileSystemItemDataView(internal::FileSystemItem_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetFilePathDataView(::mojo_base::mojom::FilePathDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFilePath(UserType* output)
    {

        auto* pointer = data_->file_path.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::FilePathDataView>(pointer, output, message_);
    }
    template <typename UserType> [[nodiscard]] bool ReadPresence(UserType* output) const
    {
        auto data_value = data_->presence;
        return mojo::internal::Deserialize<::device_signals::mojom::PresenceValue>(data_value, output);
    }
    PresenceValue presence() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::device_signals::mojom::PresenceValue>(data_->presence));
    }
    inline void GetSha256HashDataView(::mojo_base::mojom::ByteStringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSha256Hash(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::ByteStringDataView, UserType>(),
            "Attempting to read the optional `sha256_hash` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadSha256Hash` instead "
            "of `ReadSha256Hash if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->sha256_hash.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::ByteStringDataView>(pointer, output, message_);
    }
    inline void GetExecutableMetadataDataView(ExecutableMetadataDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadExecutableMetadata(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::device_signals::mojom::ExecutableMetadataDataView, UserType>(),
            "Attempting to read the optional `executable_metadata` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadExecutableMetadata` instead "
            "of `ReadExecutableMetadata if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->executable_metadata.Get();
        return mojo::internal::Deserialize<::device_signals::mojom::ExecutableMetadataDataView>(pointer, output, message_);
    }

private:
    internal::FileSystemItem_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class FileSystemItemRequestDataView {
public:
    FileSystemItemRequestDataView() = default;

    FileSystemItemRequestDataView(internal::FileSystemItemRequest_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetFilePathDataView(::mojo_base::mojom::FilePathDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFilePath(UserType* output)
    {

        auto* pointer = data_->file_path.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::FilePathDataView>(pointer, output, message_);
    }
    bool compute_sha256() const
    {
        return data_->compute_sha256;
    }
    bool compute_executable_metadata() const
    {
        return data_->compute_executable_metadata;
    }

private:
    internal::FileSystemItemRequest_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class AntiVirusSignalDataView {
public:
    AntiVirusSignalDataView() = default;

    AntiVirusSignalDataView(internal::AntiVirusSignal_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetDisplayNameDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadDisplayName(UserType* output)
    {

        auto* pointer = data_->display_name.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetProductIdDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadProductId(UserType* output)
    {

        auto* pointer = data_->product_id.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    template <typename UserType> [[nodiscard]] bool ReadState(UserType* output) const
    {
        auto data_value = data_->state;
        return mojo::internal::Deserialize<::device_signals::mojom::AntiVirusProductState>(data_value, output);
    }
    AntiVirusProductState state() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::device_signals::mojom::AntiVirusProductState>(data_->state));
    }

private:
    internal::AntiVirusSignal_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class HotfixSignalDataView {
public:
    HotfixSignalDataView() = default;

    HotfixSignalDataView(internal::HotfixSignal_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetHotfixIdDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadHotfixId(UserType* output)
    {

        auto* pointer = data_->hotfix_id.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }

private:
    internal::HotfixSignal_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

} // device_signals::mojom

namespace std {

template <> struct hash<::device_signals::mojom::PresenceValue> : public mojo::internal::EnumHashImpl<::device_signals::mojom::PresenceValue> { };

template <>
struct hash<::device_signals::mojom::AntiVirusProductState> : public mojo::internal::EnumHashImpl<::device_signals::mojom::AntiVirusProductState> { };

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device_signals::mojom::PresenceValue, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::device_signals::mojom::PresenceValue, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::device_signals::mojom::PresenceValue>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device_signals::mojom::AntiVirusProductState, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::device_signals::mojom::AntiVirusProductState, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::device_signals::mojom::AntiVirusProductState>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device_signals::mojom::ExecutableMetadataDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::device_signals::mojom::ExecutableMetadataDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::device_signals::mojom::internal::ExecutableMetadata_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->is_running = Traits::is_running(input);
        decltype(Traits::public_keys_hashes(input)) in_public_keys_hashes = Traits::public_keys_hashes(input);
        mojo::internal::MessageFragment<typename decltype(fragment->public_keys_hashes)::BaseType> public_keys_hashes_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& public_keys_hashes_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::mojo_base::mojom::ByteStringDataView>>(
            in_public_keys_hashes, public_keys_hashes_fragment, &public_keys_hashes_validate_params);
        fragment->public_keys_hashes.Set(public_keys_hashes_fragment.is_null() ? nullptr : public_keys_hashes_fragment.data());
        decltype(Traits::product_name(input)) in_product_name = Traits::product_name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->product_name)::BaseType> product_name_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_product_name, product_name_fragment);
        fragment->product_name.Set(product_name_fragment.is_null() ? nullptr : product_name_fragment.data());
        decltype(Traits::version(input)) in_version = Traits::version(input);
        mojo::internal::MessageFragment<typename decltype(fragment->version)::BaseType> version_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_version, version_fragment);
        fragment->version.Set(version_fragment.is_null() ? nullptr : version_fragment.data());
        fragment->is_os_verified = Traits::is_os_verified(input);
        decltype(Traits::subject_name(input)) in_subject_name = Traits::subject_name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->subject_name)::BaseType> subject_name_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_subject_name, subject_name_fragment);
        fragment->subject_name.Set(subject_name_fragment.is_null() ? nullptr : subject_name_fragment.data());
    }

    static bool Deserialize(::device_signals::mojom::internal::ExecutableMetadata_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::device_signals::mojom::ExecutableMetadataDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device_signals::mojom::FileSystemItemDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::device_signals::mojom::FileSystemItemDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::device_signals::mojom::internal::FileSystemItem_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::file_path(input)) in_file_path = Traits::file_path(input);
        mojo::internal::MessageFragment<typename decltype(fragment->file_path)::BaseType> file_path_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::FilePathDataView>(in_file_path, file_path_fragment);
        fragment->file_path.Set(file_path_fragment.is_null() ? nullptr : file_path_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->file_path.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null file_path in FileSystemItem struct");
        mojo::internal::Serialize<::device_signals::mojom::PresenceValue>(Traits::presence(input), &fragment->presence);
        decltype(Traits::sha256_hash(input)) in_sha256_hash = Traits::sha256_hash(input);
        mojo::internal::MessageFragment<typename decltype(fragment->sha256_hash)::BaseType> sha256_hash_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::ByteStringDataView>(in_sha256_hash, sha256_hash_fragment);
        fragment->sha256_hash.Set(sha256_hash_fragment.is_null() ? nullptr : sha256_hash_fragment.data());
        decltype(Traits::executable_metadata(input)) in_executable_metadata = Traits::executable_metadata(input);
        mojo::internal::MessageFragment<typename decltype(fragment->executable_metadata)::BaseType> executable_metadata_fragment(fragment.message());
        mojo::internal::Serialize<::device_signals::mojom::ExecutableMetadataDataView>(in_executable_metadata, executable_metadata_fragment);
        fragment->executable_metadata.Set(executable_metadata_fragment.is_null() ? nullptr : executable_metadata_fragment.data());
    }

    static bool Deserialize(::device_signals::mojom::internal::FileSystemItem_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::device_signals::mojom::FileSystemItemDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device_signals::mojom::FileSystemItemRequestDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::device_signals::mojom::FileSystemItemRequestDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::device_signals::mojom::internal::FileSystemItemRequest_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::file_path(input)) in_file_path = Traits::file_path(input);
        mojo::internal::MessageFragment<typename decltype(fragment->file_path)::BaseType> file_path_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::FilePathDataView>(in_file_path, file_path_fragment);
        fragment->file_path.Set(file_path_fragment.is_null() ? nullptr : file_path_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->file_path.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null file_path in FileSystemItemRequest struct");
        fragment->compute_sha256 = Traits::compute_sha256(input);
        fragment->compute_executable_metadata = Traits::compute_executable_metadata(input);
    }

    static bool Deserialize(::device_signals::mojom::internal::FileSystemItemRequest_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::device_signals::mojom::FileSystemItemRequestDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device_signals::mojom::AntiVirusSignalDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::device_signals::mojom::AntiVirusSignalDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::device_signals::mojom::internal::AntiVirusSignal_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::display_name(input)) in_display_name = Traits::display_name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->display_name)::BaseType> display_name_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_display_name, display_name_fragment);
        fragment->display_name.Set(display_name_fragment.is_null() ? nullptr : display_name_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->display_name.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null display_name in AntiVirusSignal struct");
        decltype(Traits::product_id(input)) in_product_id = Traits::product_id(input);
        mojo::internal::MessageFragment<typename decltype(fragment->product_id)::BaseType> product_id_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_product_id, product_id_fragment);
        fragment->product_id.Set(product_id_fragment.is_null() ? nullptr : product_id_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->product_id.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null product_id in AntiVirusSignal struct");
        mojo::internal::Serialize<::device_signals::mojom::AntiVirusProductState>(Traits::state(input), &fragment->state);
    }

    static bool Deserialize(::device_signals::mojom::internal::AntiVirusSignal_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::device_signals::mojom::AntiVirusSignalDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device_signals::mojom::HotfixSignalDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::device_signals::mojom::HotfixSignalDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::device_signals::mojom::internal::HotfixSignal_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::hotfix_id(input)) in_hotfix_id = Traits::hotfix_id(input);
        mojo::internal::MessageFragment<typename decltype(fragment->hotfix_id)::BaseType> hotfix_id_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_hotfix_id, hotfix_id_fragment);
        fragment->hotfix_id.Set(hotfix_id_fragment.is_null() ? nullptr : hotfix_id_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->hotfix_id.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null hotfix_id in HotfixSignal struct");
    }

    static bool Deserialize(::device_signals::mojom::internal::HotfixSignal_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::device_signals::mojom::HotfixSignalDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace device_signals::mojom {

inline void ExecutableMetadataDataView::GetPublicKeysHashesDataView(mojo::ArrayDataView<::mojo_base::mojom::ByteStringDataView>* output)
{
    auto pointer = data_->public_keys_hashes.Get();
    *output = mojo::ArrayDataView<::mojo_base::mojom::ByteStringDataView>(pointer, message_);
}
inline void ExecutableMetadataDataView::GetProductNameDataView(mojo::StringDataView* output)
{
    auto pointer = data_->product_name.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void ExecutableMetadataDataView::GetVersionDataView(mojo::StringDataView* output)
{
    auto pointer = data_->version.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void ExecutableMetadataDataView::GetSubjectNameDataView(mojo::StringDataView* output)
{
    auto pointer = data_->subject_name.Get();
    *output = mojo::StringDataView(pointer, message_);
}

inline void FileSystemItemDataView::GetFilePathDataView(::mojo_base::mojom::FilePathDataView* output)
{
    auto pointer = data_->file_path.Get();
    *output = ::mojo_base::mojom::FilePathDataView(pointer, message_);
}
inline void FileSystemItemDataView::GetSha256HashDataView(::mojo_base::mojom::ByteStringDataView* output)
{
    auto pointer = data_->sha256_hash.Get();
    *output = ::mojo_base::mojom::ByteStringDataView(pointer, message_);
}
inline void FileSystemItemDataView::GetExecutableMetadataDataView(ExecutableMetadataDataView* output)
{
    auto pointer = data_->executable_metadata.Get();
    *output = ExecutableMetadataDataView(pointer, message_);
}

inline void FileSystemItemRequestDataView::GetFilePathDataView(::mojo_base::mojom::FilePathDataView* output)
{
    auto pointer = data_->file_path.Get();
    *output = ::mojo_base::mojom::FilePathDataView(pointer, message_);
}

inline void AntiVirusSignalDataView::GetDisplayNameDataView(mojo::StringDataView* output)
{
    auto pointer = data_->display_name.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void AntiVirusSignalDataView::GetProductIdDataView(mojo::StringDataView* output)
{
    auto pointer = data_->product_id.Get();
    *output = mojo::StringDataView(pointer, message_);
}

inline void HotfixSignalDataView::GetHotfixIdDataView(mojo::StringDataView* output)
{
    auto pointer = data_->hotfix_id.Get();
    *output = mojo::StringDataView(pointer, message_);
}

} // device_signals::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <> struct TraceFormatTraits<::device_signals::mojom::PresenceValue> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::device_signals::mojom::PresenceValue value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::device_signals::mojom::AntiVirusProductState> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::device_signals::mojom::AntiVirusProductState value);
};

} // namespace perfetto

#endif // COMPONENTS_DEVICE_SIGNALS_CORE_COMMON_MOJOM_SYSTEM_SIGNALS_MOJOM_SHARED_H_
