// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/segmentation_platform/public/proto/types.proto

#include "components/segmentation_platform/public/proto/types.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace segmentation_platform {
namespace proto {
} // namespace proto
} // namespace segmentation_platform
namespace segmentation_platform {
namespace proto {
bool SignalType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SignalType_strings[5] = {};

static const char SignalType_names[] = "HISTOGRAM_ENUM"
                                       "HISTOGRAM_VALUE"
                                       "UKM_EVENT"
                                       "UNKNOWN_SIGNAL_TYPE"
                                       "USER_ACTION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SignalType_entries[] = {
    { { SignalType_names + 0, 14 }, 2 },
    { { SignalType_names + 14, 15 }, 3 },
    { { SignalType_names + 29, 9 }, 4 },
    { { SignalType_names + 38, 19 }, 0 },
    { { SignalType_names + 57, 11 }, 1 },
};

static const int SignalType_entries_by_number[] = {
    3, // 0 -> UNKNOWN_SIGNAL_TYPE
    4, // 1 -> USER_ACTION
    0, // 2 -> HISTOGRAM_ENUM
    1, // 3 -> HISTOGRAM_VALUE
    2, // 4 -> UKM_EVENT
};

const std::string& SignalType_Name(SignalType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(SignalType_entries, SignalType_entries_by_number, 5, SignalType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(SignalType_entries, SignalType_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : SignalType_strings[idx].get();
}
bool SignalType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SignalType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(SignalType_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<SignalType>(int_value);
    }
    return success;
}

// @@protoc_insertion_point(namespace_scope)
} // namespace proto
} // namespace segmentation_platform
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
