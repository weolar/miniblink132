// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/segmentation_platform/public/proto/model_metadata.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/map.h> // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
#include "components/segmentation_platform/public/proto/aggregation.pb.h"
#include "components/segmentation_platform/public/proto/output_config.pb.h"
#include "components/segmentation_platform/public/proto/types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto {
    static const uint32_t offsets[];
};
namespace segmentation_platform {
namespace proto {
class CustomInput;
struct CustomInputDefaultTypeInternal;
extern CustomInputDefaultTypeInternal _CustomInput_default_instance_;
class CustomInput_AdditionalArgsEntry_DoNotUse;
struct CustomInput_AdditionalArgsEntry_DoNotUseDefaultTypeInternal;
extern CustomInput_AdditionalArgsEntry_DoNotUseDefaultTypeInternal _CustomInput_AdditionalArgsEntry_DoNotUse_default_instance_;
class InputFeature;
struct InputFeatureDefaultTypeInternal;
extern InputFeatureDefaultTypeInternal _InputFeature_default_instance_;
class SegmentationModelMetadata;
struct SegmentationModelMetadataDefaultTypeInternal;
extern SegmentationModelMetadataDefaultTypeInternal _SegmentationModelMetadata_default_instance_;
class SegmentationModelMetadata_DiscreteMapping;
struct SegmentationModelMetadata_DiscreteMappingDefaultTypeInternal;
extern SegmentationModelMetadata_DiscreteMappingDefaultTypeInternal _SegmentationModelMetadata_DiscreteMapping_default_instance_;
class SegmentationModelMetadata_DiscreteMapping_Entry;
struct SegmentationModelMetadata_DiscreteMapping_EntryDefaultTypeInternal;
extern SegmentationModelMetadata_DiscreteMapping_EntryDefaultTypeInternal _SegmentationModelMetadata_DiscreteMapping_Entry_default_instance_;
class SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse;
struct SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUseDefaultTypeInternal;
extern SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUseDefaultTypeInternal _SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse_default_instance_;
class SignalFilterConfig;
struct SignalFilterConfigDefaultTypeInternal;
extern SignalFilterConfigDefaultTypeInternal _SignalFilterConfig_default_instance_;
class SignalFilterConfig_UkmEvent;
struct SignalFilterConfig_UkmEventDefaultTypeInternal;
extern SignalFilterConfig_UkmEventDefaultTypeInternal _SignalFilterConfig_UkmEvent_default_instance_;
class SqlFeature;
struct SqlFeatureDefaultTypeInternal;
extern SqlFeatureDefaultTypeInternal _SqlFeature_default_instance_;
class SqlFeature_BindValue;
struct SqlFeature_BindValueDefaultTypeInternal;
extern SqlFeature_BindValueDefaultTypeInternal _SqlFeature_BindValue_default_instance_;
class TrainingOutput;
struct TrainingOutputDefaultTypeInternal;
extern TrainingOutputDefaultTypeInternal _TrainingOutput_default_instance_;
class TrainingOutputs;
struct TrainingOutputsDefaultTypeInternal;
extern TrainingOutputsDefaultTypeInternal _TrainingOutputs_default_instance_;
class TrainingOutputs_TriggerConfig;
struct TrainingOutputs_TriggerConfigDefaultTypeInternal;
extern TrainingOutputs_TriggerConfigDefaultTypeInternal _TrainingOutputs_TriggerConfig_default_instance_;
class TrainingOutputs_TriggerConfig_ObservationTrigger;
struct TrainingOutputs_TriggerConfig_ObservationTriggerDefaultTypeInternal;
extern TrainingOutputs_TriggerConfig_ObservationTriggerDefaultTypeInternal _TrainingOutputs_TriggerConfig_ObservationTrigger_default_instance_;
class UMAFeature;
struct UMAFeatureDefaultTypeInternal;
extern UMAFeatureDefaultTypeInternal _UMAFeature_default_instance_;
class UMAOutput;
struct UMAOutputDefaultTypeInternal;
extern UMAOutputDefaultTypeInternal _UMAOutput_default_instance_;
class VersionInfo;
struct VersionInfoDefaultTypeInternal;
extern VersionInfoDefaultTypeInternal _VersionInfo_default_instance_;
} // namespace proto
} // namespace segmentation_platform
PROTOBUF_NAMESPACE_OPEN
template <>::segmentation_platform::proto::CustomInput* Arena::CreateMaybeMessage<::segmentation_platform::proto::CustomInput>(Arena*);
template <>
::segmentation_platform::proto::CustomInput_AdditionalArgsEntry_DoNotUse*
Arena::CreateMaybeMessage<::segmentation_platform::proto::CustomInput_AdditionalArgsEntry_DoNotUse>(Arena*);
template <>::segmentation_platform::proto::InputFeature* Arena::CreateMaybeMessage<::segmentation_platform::proto::InputFeature>(Arena*);
template <>
::segmentation_platform::proto::SegmentationModelMetadata* Arena::CreateMaybeMessage<::segmentation_platform::proto::SegmentationModelMetadata>(Arena*);
template <>
::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping*
Arena::CreateMaybeMessage<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>(Arena*);
template <>
::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry*
Arena::CreateMaybeMessage<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry>(Arena*);
template <>
::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse*
Arena::CreateMaybeMessage<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse>(Arena*);
template <>::segmentation_platform::proto::SignalFilterConfig* Arena::CreateMaybeMessage<::segmentation_platform::proto::SignalFilterConfig>(Arena*);
template <>
::segmentation_platform::proto::SignalFilterConfig_UkmEvent* Arena::CreateMaybeMessage<::segmentation_platform::proto::SignalFilterConfig_UkmEvent>(Arena*);
template <>::segmentation_platform::proto::SqlFeature* Arena::CreateMaybeMessage<::segmentation_platform::proto::SqlFeature>(Arena*);
template <>::segmentation_platform::proto::SqlFeature_BindValue* Arena::CreateMaybeMessage<::segmentation_platform::proto::SqlFeature_BindValue>(Arena*);
template <>::segmentation_platform::proto::TrainingOutput* Arena::CreateMaybeMessage<::segmentation_platform::proto::TrainingOutput>(Arena*);
template <>::segmentation_platform::proto::TrainingOutputs* Arena::CreateMaybeMessage<::segmentation_platform::proto::TrainingOutputs>(Arena*);
template <>
::segmentation_platform::proto::TrainingOutputs_TriggerConfig* Arena::CreateMaybeMessage<::segmentation_platform::proto::TrainingOutputs_TriggerConfig>(Arena*);
template <>
::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger*
Arena::CreateMaybeMessage<::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger>(Arena*);
template <>::segmentation_platform::proto::UMAFeature* Arena::CreateMaybeMessage<::segmentation_platform::proto::UMAFeature>(Arena*);
template <>::segmentation_platform::proto::UMAOutput* Arena::CreateMaybeMessage<::segmentation_platform::proto::UMAOutput>(Arena*);
template <>::segmentation_platform::proto::VersionInfo* Arena::CreateMaybeMessage<::segmentation_platform::proto::VersionInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace segmentation_platform {
namespace proto {

enum CustomInput_FillPolicy : int {
    CustomInput_FillPolicy_UNKNOWN_FILL_POLICY = 0,
    CustomInput_FillPolicy_FILL_PREDICTION_TIME = 1,
    CustomInput_FillPolicy_TIME_RANGE_BEFORE_PREDICTION = 2,
    CustomInput_FillPolicy_PRICE_TRACKING_HINTS = 3,
    CustomInput_FillPolicy_FILL_FROM_INPUT_CONTEXT = 4,
    CustomInput_FillPolicy_FILL_SYNC_DEVICE_INFO = 5,
    CustomInput_FillPolicy_FILL_DEVICE_RAM_MB = 6,
    CustomInput_FillPolicy_FILL_DEVICE_OS_VERSION_NUMBER = 7,
    CustomInput_FillPolicy_FILL_DEVICE_PPI = 8,
    CustomInput_FillPolicy_FILL_TAB_METRICS = 9,
    CustomInput_FillPolicy_FILL_RANDOM = 10,
    CustomInput_FillPolicy_FILL_FROM_SHOPPING_SERVICE = 11
};
bool CustomInput_FillPolicy_IsValid(int value);
constexpr CustomInput_FillPolicy CustomInput_FillPolicy_FillPolicy_MIN = CustomInput_FillPolicy_UNKNOWN_FILL_POLICY;
constexpr CustomInput_FillPolicy CustomInput_FillPolicy_FillPolicy_MAX = CustomInput_FillPolicy_FILL_FROM_SHOPPING_SERVICE;
constexpr int CustomInput_FillPolicy_FillPolicy_ARRAYSIZE = CustomInput_FillPolicy_FillPolicy_MAX + 1;

const std::string& CustomInput_FillPolicy_Name(CustomInput_FillPolicy value);
template <typename T> inline const std::string& CustomInput_FillPolicy_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, CustomInput_FillPolicy>::value || ::std::is_integral<T>::value, "Incorrect type passed to function CustomInput_FillPolicy_Name.");
    return CustomInput_FillPolicy_Name(static_cast<CustomInput_FillPolicy>(enum_t_value));
}
bool CustomInput_FillPolicy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CustomInput_FillPolicy* value);
enum SqlFeature_BindValue_ParamType : int {
    SqlFeature_BindValue_ParamType_UNKNOWN = 0,
    SqlFeature_BindValue_ParamType_NULL_ = 1,
    SqlFeature_BindValue_ParamType_BOOL = 2,
    SqlFeature_BindValue_ParamType_INT = 3,
    SqlFeature_BindValue_ParamType_INT64 = 4,
    SqlFeature_BindValue_ParamType_DOUBLE = 5,
    SqlFeature_BindValue_ParamType_STRING = 6,
    SqlFeature_BindValue_ParamType_TIME = 7
};
bool SqlFeature_BindValue_ParamType_IsValid(int value);
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue_ParamType_ParamType_MIN = SqlFeature_BindValue_ParamType_UNKNOWN;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue_ParamType_ParamType_MAX = SqlFeature_BindValue_ParamType_TIME;
constexpr int SqlFeature_BindValue_ParamType_ParamType_ARRAYSIZE = SqlFeature_BindValue_ParamType_ParamType_MAX + 1;

const std::string& SqlFeature_BindValue_ParamType_Name(SqlFeature_BindValue_ParamType value);
template <typename T> inline const std::string& SqlFeature_BindValue_ParamType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, SqlFeature_BindValue_ParamType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function SqlFeature_BindValue_ParamType_Name.");
    return SqlFeature_BindValue_ParamType_Name(static_cast<SqlFeature_BindValue_ParamType>(enum_t_value));
}
bool SqlFeature_BindValue_ParamType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SqlFeature_BindValue_ParamType* value);
enum TrainingOutputs_TriggerConfig_DecisionType : int {
    TrainingOutputs_TriggerConfig_DecisionType_UNKNOWN = 0,
    TrainingOutputs_TriggerConfig_DecisionType_ONDEMAND = 1,
    TrainingOutputs_TriggerConfig_DecisionType_PERIODIC = 2
};
bool TrainingOutputs_TriggerConfig_DecisionType_IsValid(int value);
constexpr TrainingOutputs_TriggerConfig_DecisionType TrainingOutputs_TriggerConfig_DecisionType_DecisionType_MIN
    = TrainingOutputs_TriggerConfig_DecisionType_UNKNOWN;
constexpr TrainingOutputs_TriggerConfig_DecisionType TrainingOutputs_TriggerConfig_DecisionType_DecisionType_MAX
    = TrainingOutputs_TriggerConfig_DecisionType_PERIODIC;
constexpr int TrainingOutputs_TriggerConfig_DecisionType_DecisionType_ARRAYSIZE = TrainingOutputs_TriggerConfig_DecisionType_DecisionType_MAX + 1;

const std::string& TrainingOutputs_TriggerConfig_DecisionType_Name(TrainingOutputs_TriggerConfig_DecisionType value);
template <typename T> inline const std::string& TrainingOutputs_TriggerConfig_DecisionType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, TrainingOutputs_TriggerConfig_DecisionType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function TrainingOutputs_TriggerConfig_DecisionType_Name.");
    return TrainingOutputs_TriggerConfig_DecisionType_Name(static_cast<TrainingOutputs_TriggerConfig_DecisionType>(enum_t_value));
}
bool TrainingOutputs_TriggerConfig_DecisionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrainingOutputs_TriggerConfig_DecisionType* value);
enum SegmentationModelMetadata_OutputDescription : int {
    SegmentationModelMetadata_OutputDescription_UNKNOWN_RETURN_TYPE = 0,
    SegmentationModelMetadata_OutputDescription_RETURN_TYPE_HEURISTIC = 1,
    SegmentationModelMetadata_OutputDescription_RETURN_TYPE_MULTISEGMENT = 2,
    SegmentationModelMetadata_OutputDescription_RETURN_TYPE_PROBABILITY = 3,
    SegmentationModelMetadata_OutputDescription_RETURN_TYPE_INTEGER = 4
};
bool SegmentationModelMetadata_OutputDescription_IsValid(int value);
constexpr SegmentationModelMetadata_OutputDescription SegmentationModelMetadata_OutputDescription_OutputDescription_MIN
    = SegmentationModelMetadata_OutputDescription_UNKNOWN_RETURN_TYPE;
constexpr SegmentationModelMetadata_OutputDescription SegmentationModelMetadata_OutputDescription_OutputDescription_MAX
    = SegmentationModelMetadata_OutputDescription_RETURN_TYPE_INTEGER;
constexpr int SegmentationModelMetadata_OutputDescription_OutputDescription_ARRAYSIZE = SegmentationModelMetadata_OutputDescription_OutputDescription_MAX + 1;

const std::string& SegmentationModelMetadata_OutputDescription_Name(SegmentationModelMetadata_OutputDescription value);
template <typename T> inline const std::string& SegmentationModelMetadata_OutputDescription_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, SegmentationModelMetadata_OutputDescription>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function SegmentationModelMetadata_OutputDescription_Name.");
    return SegmentationModelMetadata_OutputDescription_Name(static_cast<SegmentationModelMetadata_OutputDescription>(enum_t_value));
}
bool SegmentationModelMetadata_OutputDescription_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SegmentationModelMetadata_OutputDescription* value);
enum CurrentVersion : int { METADATA_VERSION = 3 };
bool CurrentVersion_IsValid(int value);
constexpr CurrentVersion CurrentVersion_MIN = METADATA_VERSION;
constexpr CurrentVersion CurrentVersion_MAX = METADATA_VERSION;
constexpr int CurrentVersion_ARRAYSIZE = CurrentVersion_MAX + 1;

const std::string& CurrentVersion_Name(CurrentVersion value);
template <typename T> inline const std::string& CurrentVersion_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, CurrentVersion>::value || ::std::is_integral<T>::value, "Incorrect type passed to function CurrentVersion_Name.");
    return CurrentVersion_Name(static_cast<CurrentVersion>(enum_t_value));
}
bool CurrentVersion_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CurrentVersion* value);
enum ModelSource : int { UNKNOWN_MODEL_SOURCE = 0, SERVER_MODEL_SOURCE = 1, DEFAULT_MODEL_SOURCE = 2 };
bool ModelSource_IsValid(int value);
constexpr ModelSource ModelSource_MIN = UNKNOWN_MODEL_SOURCE;
constexpr ModelSource ModelSource_MAX = DEFAULT_MODEL_SOURCE;
constexpr int ModelSource_ARRAYSIZE = ModelSource_MAX + 1;

const std::string& ModelSource_Name(ModelSource value);
template <typename T> inline const std::string& ModelSource_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ModelSource>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ModelSource_Name.");
    return ModelSource_Name(static_cast<ModelSource>(enum_t_value));
}
bool ModelSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelSource* value);
// ===================================================================

class VersionInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.VersionInfo) */ {
public:
    inline VersionInfo()
        : VersionInfo(nullptr)
    {
    }
    ~VersionInfo() override;
    explicit PROTOBUF_CONSTEXPR VersionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    VersionInfo(const VersionInfo& from);
    VersionInfo(VersionInfo&& from) noexcept
        : VersionInfo()
    {
        *this = ::std::move(from);
    }

    inline VersionInfo& operator=(const VersionInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline VersionInfo& operator=(VersionInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const VersionInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const VersionInfo* internal_default_instance()
    {
        return reinterpret_cast<const VersionInfo*>(&_VersionInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(VersionInfo& a, VersionInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(VersionInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(VersionInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    VersionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<VersionInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const VersionInfo& from);
    void MergeFrom(const VersionInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(VersionInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.VersionInfo";
    }

protected:
    explicit VersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kMetadataMinVersionFieldNumber = 1,
        kMetadataCurVersionFieldNumber = 2,
    };
    // optional int32 metadata_min_version = 1;
    bool has_metadata_min_version() const;

private:
    bool _internal_has_metadata_min_version() const;

public:
    void clear_metadata_min_version();
    int32_t metadata_min_version() const;
    void set_metadata_min_version(int32_t value);

private:
    int32_t _internal_metadata_min_version() const;
    void _internal_set_metadata_min_version(int32_t value);

public:
    // optional int32 metadata_cur_version = 2;
    bool has_metadata_cur_version() const;

private:
    bool _internal_has_metadata_cur_version() const;

public:
    void clear_metadata_cur_version();
    int32_t metadata_cur_version() const;
    void set_metadata_cur_version(int32_t value);

private:
    int32_t _internal_metadata_cur_version() const;
    void _internal_set_metadata_cur_version(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.VersionInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int32_t metadata_min_version_;
        int32_t metadata_cur_version_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class UMAFeature final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.UMAFeature) */ {
public:
    inline UMAFeature()
        : UMAFeature(nullptr)
    {
    }
    ~UMAFeature() override;
    explicit PROTOBUF_CONSTEXPR UMAFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    UMAFeature(const UMAFeature& from);
    UMAFeature(UMAFeature&& from) noexcept
        : UMAFeature()
    {
        *this = ::std::move(from);
    }

    inline UMAFeature& operator=(const UMAFeature& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UMAFeature& operator=(UMAFeature&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const UMAFeature& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const UMAFeature* internal_default_instance()
    {
        return reinterpret_cast<const UMAFeature*>(&_UMAFeature_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(UMAFeature& a, UMAFeature& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(UMAFeature* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UMAFeature* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UMAFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<UMAFeature>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const UMAFeature& from);
    void MergeFrom(const UMAFeature& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(UMAFeature* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.UMAFeature";
    }

protected:
    explicit UMAFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kEnumIdsFieldNumber = 7,
        kDefaultValuesFieldNumber = 8,
        kNameFieldNumber = 2,
        kNameHashFieldNumber = 3,
        kTypeFieldNumber = 1,
        kAggregationFieldNumber = 6,
        kBucketCountFieldNumber = 4,
        kTensorLengthFieldNumber = 5,
    };
    // repeated int32 enum_ids = 7;
    int enum_ids_size() const;

private:
    int _internal_enum_ids_size() const;

public:
    void clear_enum_ids();

private:
    int32_t _internal_enum_ids(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& _internal_enum_ids() const;
    void _internal_add_enum_ids(int32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* _internal_mutable_enum_ids();

public:
    int32_t enum_ids(int index) const;
    void set_enum_ids(int index, int32_t value);
    void add_enum_ids(int32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& enum_ids() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* mutable_enum_ids();

    // repeated float default_values = 8;
    int default_values_size() const;

private:
    int _internal_default_values_size() const;

public:
    void clear_default_values();

private:
    float _internal_default_values(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& _internal_default_values() const;
    void _internal_add_default_values(float value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* _internal_mutable_default_values();

public:
    float default_values(int index) const;
    void set_default_values(int index, float value);
    void add_default_values(float value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& default_values() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* mutable_default_values();

    // optional string name = 2;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // optional fixed64 name_hash = 3;
    bool has_name_hash() const;

private:
    bool _internal_has_name_hash() const;

public:
    void clear_name_hash();
    uint64_t name_hash() const;
    void set_name_hash(uint64_t value);

private:
    uint64_t _internal_name_hash() const;
    void _internal_set_name_hash(uint64_t value);

public:
    // optional .segmentation_platform.proto.SignalType type = 1;
    bool has_type() const;

private:
    bool _internal_has_type() const;

public:
    void clear_type();
    ::segmentation_platform::proto::SignalType type() const;
    void set_type(::segmentation_platform::proto::SignalType value);

private:
    ::segmentation_platform::proto::SignalType _internal_type() const;
    void _internal_set_type(::segmentation_platform::proto::SignalType value);

public:
    // optional .segmentation_platform.proto.Aggregation aggregation = 6;
    bool has_aggregation() const;

private:
    bool _internal_has_aggregation() const;

public:
    void clear_aggregation();
    ::segmentation_platform::proto::Aggregation aggregation() const;
    void set_aggregation(::segmentation_platform::proto::Aggregation value);

private:
    ::segmentation_platform::proto::Aggregation _internal_aggregation() const;
    void _internal_set_aggregation(::segmentation_platform::proto::Aggregation value);

public:
    // optional uint64 bucket_count = 4;
    bool has_bucket_count() const;

private:
    bool _internal_has_bucket_count() const;

public:
    void clear_bucket_count();
    uint64_t bucket_count() const;
    void set_bucket_count(uint64_t value);

private:
    uint64_t _internal_bucket_count() const;
    void _internal_set_bucket_count(uint64_t value);

public:
    // optional uint64 tensor_length = 5;
    bool has_tensor_length() const;

private:
    bool _internal_has_tensor_length() const;

public:
    void clear_tensor_length();
    uint64_t tensor_length() const;
    void set_tensor_length(uint64_t value);

private:
    uint64_t _internal_tensor_length() const;
    void _internal_set_tensor_length(uint64_t value);

public:
    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.UMAFeature)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t> enum_ids_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<float> default_values_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        uint64_t name_hash_;
        int type_;
        int aggregation_;
        uint64_t bucket_count_;
        uint64_t tensor_length_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class CustomInput_AdditionalArgsEntry_DoNotUse
    : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<CustomInput_AdditionalArgsEntry_DoNotUse, std::string, std::string,
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
    typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<CustomInput_AdditionalArgsEntry_DoNotUse, std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING>
        SuperType;
    CustomInput_AdditionalArgsEntry_DoNotUse();
    explicit PROTOBUF_CONSTEXPR CustomInput_AdditionalArgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
    explicit CustomInput_AdditionalArgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
    void MergeFrom(const CustomInput_AdditionalArgsEntry_DoNotUse& other);
    static const CustomInput_AdditionalArgsEntry_DoNotUse* internal_default_instance()
    {
        return reinterpret_cast<const CustomInput_AdditionalArgsEntry_DoNotUse*>(&_CustomInput_AdditionalArgsEntry_DoNotUse_default_instance_);
    }
    static bool ValidateKey(void*)
    {
        return true;
    }
    static bool ValidateValue(void*)
    {
        return true;
    }
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};

// -------------------------------------------------------------------

class CustomInput final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.CustomInput) */ {
public:
    inline CustomInput()
        : CustomInput(nullptr)
    {
    }
    ~CustomInput() override;
    explicit PROTOBUF_CONSTEXPR CustomInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CustomInput(const CustomInput& from);
    CustomInput(CustomInput&& from) noexcept
        : CustomInput()
    {
        *this = ::std::move(from);
    }

    inline CustomInput& operator=(const CustomInput& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CustomInput& operator=(CustomInput&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const CustomInput& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CustomInput* internal_default_instance()
    {
        return reinterpret_cast<const CustomInput*>(&_CustomInput_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(CustomInput& a, CustomInput& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CustomInput* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CustomInput* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CustomInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CustomInput>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CustomInput& from);
    void MergeFrom(const CustomInput& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CustomInput* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.CustomInput";
    }

protected:
    explicit CustomInput(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef CustomInput_FillPolicy FillPolicy;
    static constexpr FillPolicy UNKNOWN_FILL_POLICY = CustomInput_FillPolicy_UNKNOWN_FILL_POLICY;
    static constexpr FillPolicy FILL_PREDICTION_TIME = CustomInput_FillPolicy_FILL_PREDICTION_TIME;
    static constexpr FillPolicy TIME_RANGE_BEFORE_PREDICTION = CustomInput_FillPolicy_TIME_RANGE_BEFORE_PREDICTION;
    static constexpr FillPolicy PRICE_TRACKING_HINTS = CustomInput_FillPolicy_PRICE_TRACKING_HINTS;
    static constexpr FillPolicy FILL_FROM_INPUT_CONTEXT = CustomInput_FillPolicy_FILL_FROM_INPUT_CONTEXT;
    static constexpr FillPolicy FILL_SYNC_DEVICE_INFO = CustomInput_FillPolicy_FILL_SYNC_DEVICE_INFO;
    static constexpr FillPolicy FILL_DEVICE_RAM_MB = CustomInput_FillPolicy_FILL_DEVICE_RAM_MB;
    static constexpr FillPolicy FILL_DEVICE_OS_VERSION_NUMBER = CustomInput_FillPolicy_FILL_DEVICE_OS_VERSION_NUMBER;
    static constexpr FillPolicy FILL_DEVICE_PPI = CustomInput_FillPolicy_FILL_DEVICE_PPI;
    static constexpr FillPolicy FILL_TAB_METRICS = CustomInput_FillPolicy_FILL_TAB_METRICS;
    static constexpr FillPolicy FILL_RANDOM = CustomInput_FillPolicy_FILL_RANDOM;
    static constexpr FillPolicy FILL_FROM_SHOPPING_SERVICE = CustomInput_FillPolicy_FILL_FROM_SHOPPING_SERVICE;
    static inline bool FillPolicy_IsValid(int value)
    {
        return CustomInput_FillPolicy_IsValid(value);
    }
    static constexpr FillPolicy FillPolicy_MIN = CustomInput_FillPolicy_FillPolicy_MIN;
    static constexpr FillPolicy FillPolicy_MAX = CustomInput_FillPolicy_FillPolicy_MAX;
    static constexpr int FillPolicy_ARRAYSIZE = CustomInput_FillPolicy_FillPolicy_ARRAYSIZE;
    template <typename T> static inline const std::string& FillPolicy_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, FillPolicy>::value || ::std::is_integral<T>::value, "Incorrect type passed to function FillPolicy_Name.");
        return CustomInput_FillPolicy_Name(enum_t_value);
    }
    static inline bool FillPolicy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FillPolicy* value)
    {
        return CustomInput_FillPolicy_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kDefaultValueFieldNumber = 3,
        kAdditionalArgsFieldNumber = 4,
        kNameFieldNumber = 5,
        kTensorLengthFieldNumber = 1,
        kFillPolicyFieldNumber = 2,
    };
    // repeated float default_value = 3;
    int default_value_size() const;

private:
    int _internal_default_value_size() const;

public:
    void clear_default_value();

private:
    float _internal_default_value(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& _internal_default_value() const;
    void _internal_add_default_value(float value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* _internal_mutable_default_value();

public:
    float default_value(int index) const;
    void set_default_value(int index, float value);
    void add_default_value(float value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& default_value() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* mutable_default_value();

    // map<string, string> additional_args = 4;
    int additional_args_size() const;

private:
    int _internal_additional_args_size() const;

public:
    void clear_additional_args();

private:
    const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>& _internal_additional_args() const;
    ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>* _internal_mutable_additional_args();

public:
    const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>& additional_args() const;
    ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>* mutable_additional_args();

    // optional string name = 5;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // optional int32 tensor_length = 1;
    bool has_tensor_length() const;

private:
    bool _internal_has_tensor_length() const;

public:
    void clear_tensor_length();
    int32_t tensor_length() const;
    void set_tensor_length(int32_t value);

private:
    int32_t _internal_tensor_length() const;
    void _internal_set_tensor_length(int32_t value);

public:
    // optional .segmentation_platform.proto.CustomInput.FillPolicy fill_policy = 2;
    bool has_fill_policy() const;

private:
    bool _internal_has_fill_policy() const;

public:
    void clear_fill_policy();
    ::segmentation_platform::proto::CustomInput_FillPolicy fill_policy() const;
    void set_fill_policy(::segmentation_platform::proto::CustomInput_FillPolicy value);

private:
    ::segmentation_platform::proto::CustomInput_FillPolicy _internal_fill_policy() const;
    void _internal_set_fill_policy(::segmentation_platform::proto::CustomInput_FillPolicy value);

public:
    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.CustomInput)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<float> default_value_;
        ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<CustomInput_AdditionalArgsEntry_DoNotUse, std::string, std::string,
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING>
            additional_args_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        int32_t tensor_length_;
        int fill_policy_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SignalFilterConfig_UkmEvent final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.SignalFilterConfig.UkmEvent) */ {
public:
    inline SignalFilterConfig_UkmEvent()
        : SignalFilterConfig_UkmEvent(nullptr)
    {
    }
    ~SignalFilterConfig_UkmEvent() override;
    explicit PROTOBUF_CONSTEXPR SignalFilterConfig_UkmEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SignalFilterConfig_UkmEvent(const SignalFilterConfig_UkmEvent& from);
    SignalFilterConfig_UkmEvent(SignalFilterConfig_UkmEvent&& from) noexcept
        : SignalFilterConfig_UkmEvent()
    {
        *this = ::std::move(from);
    }

    inline SignalFilterConfig_UkmEvent& operator=(const SignalFilterConfig_UkmEvent& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SignalFilterConfig_UkmEvent& operator=(SignalFilterConfig_UkmEvent&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SignalFilterConfig_UkmEvent& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SignalFilterConfig_UkmEvent* internal_default_instance()
    {
        return reinterpret_cast<const SignalFilterConfig_UkmEvent*>(&_SignalFilterConfig_UkmEvent_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(SignalFilterConfig_UkmEvent& a, SignalFilterConfig_UkmEvent& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SignalFilterConfig_UkmEvent* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SignalFilterConfig_UkmEvent* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SignalFilterConfig_UkmEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SignalFilterConfig_UkmEvent>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SignalFilterConfig_UkmEvent& from);
    void MergeFrom(const SignalFilterConfig_UkmEvent& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SignalFilterConfig_UkmEvent* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.SignalFilterConfig.UkmEvent";
    }

protected:
    explicit SignalFilterConfig_UkmEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kMetricHashFilterFieldNumber = 2,
        kEventHashFieldNumber = 1,
    };
    // repeated uint64 metric_hash_filter = 2;
    int metric_hash_filter_size() const;

private:
    int _internal_metric_hash_filter_size() const;

public:
    void clear_metric_hash_filter();

private:
    uint64_t _internal_metric_hash_filter(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>& _internal_metric_hash_filter() const;
    void _internal_add_metric_hash_filter(uint64_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>* _internal_mutable_metric_hash_filter();

public:
    uint64_t metric_hash_filter(int index) const;
    void set_metric_hash_filter(int index, uint64_t value);
    void add_metric_hash_filter(uint64_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>& metric_hash_filter() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>* mutable_metric_hash_filter();

    // optional uint64 event_hash = 1;
    bool has_event_hash() const;

private:
    bool _internal_has_event_hash() const;

public:
    void clear_event_hash();
    uint64_t event_hash() const;
    void set_event_hash(uint64_t value);

private:
    uint64_t _internal_event_hash() const;
    void _internal_set_event_hash(uint64_t value);

public:
    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t> metric_hash_filter_;
        uint64_t event_hash_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SignalFilterConfig final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.SignalFilterConfig) */ {
public:
    inline SignalFilterConfig()
        : SignalFilterConfig(nullptr)
    {
    }
    ~SignalFilterConfig() override;
    explicit PROTOBUF_CONSTEXPR SignalFilterConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SignalFilterConfig(const SignalFilterConfig& from);
    SignalFilterConfig(SignalFilterConfig&& from) noexcept
        : SignalFilterConfig()
    {
        *this = ::std::move(from);
    }

    inline SignalFilterConfig& operator=(const SignalFilterConfig& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SignalFilterConfig& operator=(SignalFilterConfig&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SignalFilterConfig& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SignalFilterConfig* internal_default_instance()
    {
        return reinterpret_cast<const SignalFilterConfig*>(&_SignalFilterConfig_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(SignalFilterConfig& a, SignalFilterConfig& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SignalFilterConfig* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SignalFilterConfig* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SignalFilterConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SignalFilterConfig>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SignalFilterConfig& from);
    void MergeFrom(const SignalFilterConfig& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SignalFilterConfig* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.SignalFilterConfig";
    }

protected:
    explicit SignalFilterConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef SignalFilterConfig_UkmEvent UkmEvent;

    // accessors -------------------------------------------------------

    enum : int {
        kUkmEventsFieldNumber = 1,
    };
    // repeated .segmentation_platform.proto.SignalFilterConfig.UkmEvent ukm_events = 1;
    int ukm_events_size() const;

private:
    int _internal_ukm_events_size() const;

public:
    void clear_ukm_events();
    ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* mutable_ukm_events(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SignalFilterConfig_UkmEvent>* mutable_ukm_events();

private:
    const ::segmentation_platform::proto::SignalFilterConfig_UkmEvent& _internal_ukm_events(int index) const;
    ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* _internal_add_ukm_events();

public:
    const ::segmentation_platform::proto::SignalFilterConfig_UkmEvent& ukm_events(int index) const;
    ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* add_ukm_events();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SignalFilterConfig_UkmEvent>& ukm_events() const;

    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.SignalFilterConfig)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SignalFilterConfig_UkmEvent> ukm_events_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SqlFeature_BindValue final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.SqlFeature.BindValue) */ {
public:
    inline SqlFeature_BindValue()
        : SqlFeature_BindValue(nullptr)
    {
    }
    ~SqlFeature_BindValue() override;
    explicit PROTOBUF_CONSTEXPR SqlFeature_BindValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SqlFeature_BindValue(const SqlFeature_BindValue& from);
    SqlFeature_BindValue(SqlFeature_BindValue&& from) noexcept
        : SqlFeature_BindValue()
    {
        *this = ::std::move(from);
    }

    inline SqlFeature_BindValue& operator=(const SqlFeature_BindValue& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SqlFeature_BindValue& operator=(SqlFeature_BindValue&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SqlFeature_BindValue& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SqlFeature_BindValue* internal_default_instance()
    {
        return reinterpret_cast<const SqlFeature_BindValue*>(&_SqlFeature_BindValue_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(SqlFeature_BindValue& a, SqlFeature_BindValue& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SqlFeature_BindValue* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SqlFeature_BindValue* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SqlFeature_BindValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SqlFeature_BindValue>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SqlFeature_BindValue& from);
    void MergeFrom(const SqlFeature_BindValue& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SqlFeature_BindValue* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.SqlFeature.BindValue";
    }

protected:
    explicit SqlFeature_BindValue(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef SqlFeature_BindValue_ParamType ParamType;
    static constexpr ParamType UNKNOWN = SqlFeature_BindValue_ParamType_UNKNOWN;
    static constexpr ParamType NULL_ = SqlFeature_BindValue_ParamType_NULL_;
    static constexpr ParamType BOOL = SqlFeature_BindValue_ParamType_BOOL;
    static constexpr ParamType INT = SqlFeature_BindValue_ParamType_INT;
    static constexpr ParamType INT64 = SqlFeature_BindValue_ParamType_INT64;
    static constexpr ParamType DOUBLE = SqlFeature_BindValue_ParamType_DOUBLE;
    static constexpr ParamType STRING = SqlFeature_BindValue_ParamType_STRING;
    static constexpr ParamType TIME = SqlFeature_BindValue_ParamType_TIME;
    static inline bool ParamType_IsValid(int value)
    {
        return SqlFeature_BindValue_ParamType_IsValid(value);
    }
    static constexpr ParamType ParamType_MIN = SqlFeature_BindValue_ParamType_ParamType_MIN;
    static constexpr ParamType ParamType_MAX = SqlFeature_BindValue_ParamType_ParamType_MAX;
    static constexpr int ParamType_ARRAYSIZE = SqlFeature_BindValue_ParamType_ParamType_ARRAYSIZE;
    template <typename T> static inline const std::string& ParamType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ParamType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ParamType_Name.");
        return SqlFeature_BindValue_ParamType_Name(enum_t_value);
    }
    static inline bool ParamType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParamType* value)
    {
        return SqlFeature_BindValue_ParamType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kBindFieldIndexFieldNumber = 1,
        kValueFieldNumber = 3,
        kParamTypeFieldNumber = 2,
    };
    // repeated int32 bind_field_index = 1;
    int bind_field_index_size() const;

private:
    int _internal_bind_field_index_size() const;

public:
    void clear_bind_field_index();

private:
    int32_t _internal_bind_field_index(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& _internal_bind_field_index() const;
    void _internal_add_bind_field_index(int32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* _internal_mutable_bind_field_index();

public:
    int32_t bind_field_index(int index) const;
    void set_bind_field_index(int index, int32_t value);
    void add_bind_field_index(int32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& bind_field_index() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* mutable_bind_field_index();

    // optional .segmentation_platform.proto.CustomInput value = 3;
    bool has_value() const;

private:
    bool _internal_has_value() const;

public:
    void clear_value();
    const ::segmentation_platform::proto::CustomInput& value() const;
    PROTOBUF_NODISCARD ::segmentation_platform::proto::CustomInput* release_value();
    ::segmentation_platform::proto::CustomInput* mutable_value();
    void set_allocated_value(::segmentation_platform::proto::CustomInput* value);

private:
    const ::segmentation_platform::proto::CustomInput& _internal_value() const;
    ::segmentation_platform::proto::CustomInput* _internal_mutable_value();

public:
    void unsafe_arena_set_allocated_value(::segmentation_platform::proto::CustomInput* value);
    ::segmentation_platform::proto::CustomInput* unsafe_arena_release_value();

    // optional .segmentation_platform.proto.SqlFeature.BindValue.ParamType param_type = 2;
    bool has_param_type() const;

private:
    bool _internal_has_param_type() const;

public:
    void clear_param_type();
    ::segmentation_platform::proto::SqlFeature_BindValue_ParamType param_type() const;
    void set_param_type(::segmentation_platform::proto::SqlFeature_BindValue_ParamType value);

private:
    ::segmentation_platform::proto::SqlFeature_BindValue_ParamType _internal_param_type() const;
    void _internal_set_param_type(::segmentation_platform::proto::SqlFeature_BindValue_ParamType value);

public:
    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.SqlFeature.BindValue)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t> bind_field_index_;
        ::segmentation_platform::proto::CustomInput* value_;
        int param_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SqlFeature final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.SqlFeature) */ {
public:
    inline SqlFeature()
        : SqlFeature(nullptr)
    {
    }
    ~SqlFeature() override;
    explicit PROTOBUF_CONSTEXPR SqlFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SqlFeature(const SqlFeature& from);
    SqlFeature(SqlFeature&& from) noexcept
        : SqlFeature()
    {
        *this = ::std::move(from);
    }

    inline SqlFeature& operator=(const SqlFeature& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SqlFeature& operator=(SqlFeature&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SqlFeature& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SqlFeature* internal_default_instance()
    {
        return reinterpret_cast<const SqlFeature*>(&_SqlFeature_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(SqlFeature& a, SqlFeature& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SqlFeature* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SqlFeature* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SqlFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SqlFeature>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SqlFeature& from);
    void MergeFrom(const SqlFeature& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SqlFeature* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.SqlFeature";
    }

protected:
    explicit SqlFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef SqlFeature_BindValue BindValue;

    // accessors -------------------------------------------------------

    enum : int {
        kBindValuesFieldNumber = 3,
        kSqlFieldNumber = 1,
        kNameFieldNumber = 4,
        kSignalFilterFieldNumber = 2,
    };
    // repeated .segmentation_platform.proto.SqlFeature.BindValue bind_values = 3;
    int bind_values_size() const;

private:
    int _internal_bind_values_size() const;

public:
    void clear_bind_values();
    ::segmentation_platform::proto::SqlFeature_BindValue* mutable_bind_values(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SqlFeature_BindValue>* mutable_bind_values();

private:
    const ::segmentation_platform::proto::SqlFeature_BindValue& _internal_bind_values(int index) const;
    ::segmentation_platform::proto::SqlFeature_BindValue* _internal_add_bind_values();

public:
    const ::segmentation_platform::proto::SqlFeature_BindValue& bind_values(int index) const;
    ::segmentation_platform::proto::SqlFeature_BindValue* add_bind_values();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SqlFeature_BindValue>& bind_values() const;

    // optional string sql = 1;
    bool has_sql() const;

private:
    bool _internal_has_sql() const;

public:
    void clear_sql();
    const std::string& sql() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_sql(ArgT0&& arg0, ArgT... args);
    std::string* mutable_sql();
    PROTOBUF_NODISCARD std::string* release_sql();
    void set_allocated_sql(std::string* sql);

private:
    const std::string& _internal_sql() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql(const std::string& value);
    std::string* _internal_mutable_sql();

public:
    // optional string name = 4;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // optional .segmentation_platform.proto.SignalFilterConfig signal_filter = 2;
    bool has_signal_filter() const;

private:
    bool _internal_has_signal_filter() const;

public:
    void clear_signal_filter();
    const ::segmentation_platform::proto::SignalFilterConfig& signal_filter() const;
    PROTOBUF_NODISCARD ::segmentation_platform::proto::SignalFilterConfig* release_signal_filter();
    ::segmentation_platform::proto::SignalFilterConfig* mutable_signal_filter();
    void set_allocated_signal_filter(::segmentation_platform::proto::SignalFilterConfig* signal_filter);

private:
    const ::segmentation_platform::proto::SignalFilterConfig& _internal_signal_filter() const;
    ::segmentation_platform::proto::SignalFilterConfig* _internal_mutable_signal_filter();

public:
    void unsafe_arena_set_allocated_signal_filter(::segmentation_platform::proto::SignalFilterConfig* signal_filter);
    ::segmentation_platform::proto::SignalFilterConfig* unsafe_arena_release_signal_filter();

    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.SqlFeature)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SqlFeature_BindValue> bind_values_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sql_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::segmentation_platform::proto::SignalFilterConfig* signal_filter_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class InputFeature final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.InputFeature) */ {
public:
    inline InputFeature()
        : InputFeature(nullptr)
    {
    }
    ~InputFeature() override;
    explicit PROTOBUF_CONSTEXPR InputFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    InputFeature(const InputFeature& from);
    InputFeature(InputFeature&& from) noexcept
        : InputFeature()
    {
        *this = ::std::move(from);
    }

    inline InputFeature& operator=(const InputFeature& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline InputFeature& operator=(InputFeature&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const InputFeature& default_instance()
    {
        return *internal_default_instance();
    }
    enum FeatureCase {
        kUmaFeature = 1,
        kCustomInput = 2,
        kSqlFeature = 3,
        FEATURE_NOT_SET = 0,
    };

    static inline const InputFeature* internal_default_instance()
    {
        return reinterpret_cast<const InputFeature*>(&_InputFeature_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(InputFeature& a, InputFeature& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(InputFeature* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(InputFeature* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    InputFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<InputFeature>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const InputFeature& from);
    void MergeFrom(const InputFeature& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(InputFeature* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.InputFeature";
    }

protected:
    explicit InputFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUmaFeatureFieldNumber = 1,
        kCustomInputFieldNumber = 2,
        kSqlFeatureFieldNumber = 3,
    };
    // .segmentation_platform.proto.UMAFeature uma_feature = 1;
    bool has_uma_feature() const;

private:
    bool _internal_has_uma_feature() const;

public:
    void clear_uma_feature();
    const ::segmentation_platform::proto::UMAFeature& uma_feature() const;
    PROTOBUF_NODISCARD ::segmentation_platform::proto::UMAFeature* release_uma_feature();
    ::segmentation_platform::proto::UMAFeature* mutable_uma_feature();
    void set_allocated_uma_feature(::segmentation_platform::proto::UMAFeature* uma_feature);

private:
    const ::segmentation_platform::proto::UMAFeature& _internal_uma_feature() const;
    ::segmentation_platform::proto::UMAFeature* _internal_mutable_uma_feature();

public:
    void unsafe_arena_set_allocated_uma_feature(::segmentation_platform::proto::UMAFeature* uma_feature);
    ::segmentation_platform::proto::UMAFeature* unsafe_arena_release_uma_feature();

    // .segmentation_platform.proto.CustomInput custom_input = 2;
    bool has_custom_input() const;

private:
    bool _internal_has_custom_input() const;

public:
    void clear_custom_input();
    const ::segmentation_platform::proto::CustomInput& custom_input() const;
    PROTOBUF_NODISCARD ::segmentation_platform::proto::CustomInput* release_custom_input();
    ::segmentation_platform::proto::CustomInput* mutable_custom_input();
    void set_allocated_custom_input(::segmentation_platform::proto::CustomInput* custom_input);

private:
    const ::segmentation_platform::proto::CustomInput& _internal_custom_input() const;
    ::segmentation_platform::proto::CustomInput* _internal_mutable_custom_input();

public:
    void unsafe_arena_set_allocated_custom_input(::segmentation_platform::proto::CustomInput* custom_input);
    ::segmentation_platform::proto::CustomInput* unsafe_arena_release_custom_input();

    // .segmentation_platform.proto.SqlFeature sql_feature = 3;
    bool has_sql_feature() const;

private:
    bool _internal_has_sql_feature() const;

public:
    void clear_sql_feature();
    const ::segmentation_platform::proto::SqlFeature& sql_feature() const;
    PROTOBUF_NODISCARD ::segmentation_platform::proto::SqlFeature* release_sql_feature();
    ::segmentation_platform::proto::SqlFeature* mutable_sql_feature();
    void set_allocated_sql_feature(::segmentation_platform::proto::SqlFeature* sql_feature);

private:
    const ::segmentation_platform::proto::SqlFeature& _internal_sql_feature() const;
    ::segmentation_platform::proto::SqlFeature* _internal_mutable_sql_feature();

public:
    void unsafe_arena_set_allocated_sql_feature(::segmentation_platform::proto::SqlFeature* sql_feature);
    ::segmentation_platform::proto::SqlFeature* unsafe_arena_release_sql_feature();

    void clear_Feature();
    FeatureCase Feature_case() const;
    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.InputFeature)
private:
    class _Internal;
    void set_has_uma_feature();
    void set_has_custom_input();
    void set_has_sql_feature();

    inline bool has_Feature() const;
    inline void clear_has_Feature();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        union FeatureUnion {
            constexpr FeatureUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::segmentation_platform::proto::UMAFeature* uma_feature_;
            ::segmentation_platform::proto::CustomInput* custom_input_;
            ::segmentation_platform::proto::SqlFeature* sql_feature_;
        } Feature_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class TrainingOutputs_TriggerConfig_ObservationTrigger final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger) */ {
public:
    inline TrainingOutputs_TriggerConfig_ObservationTrigger()
        : TrainingOutputs_TriggerConfig_ObservationTrigger(nullptr)
    {
    }
    ~TrainingOutputs_TriggerConfig_ObservationTrigger() override;
    explicit PROTOBUF_CONSTEXPR TrainingOutputs_TriggerConfig_ObservationTrigger(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TrainingOutputs_TriggerConfig_ObservationTrigger(const TrainingOutputs_TriggerConfig_ObservationTrigger& from);
    TrainingOutputs_TriggerConfig_ObservationTrigger(TrainingOutputs_TriggerConfig_ObservationTrigger&& from) noexcept
        : TrainingOutputs_TriggerConfig_ObservationTrigger()
    {
        *this = ::std::move(from);
    }

    inline TrainingOutputs_TriggerConfig_ObservationTrigger& operator=(const TrainingOutputs_TriggerConfig_ObservationTrigger& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TrainingOutputs_TriggerConfig_ObservationTrigger& operator=(TrainingOutputs_TriggerConfig_ObservationTrigger&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const TrainingOutputs_TriggerConfig_ObservationTrigger& default_instance()
    {
        return *internal_default_instance();
    }
    enum TriggerCase {
        kDelaySec = 1,
        kUmaTrigger = 2,
        TRIGGER_NOT_SET = 0,
    };

    static inline const TrainingOutputs_TriggerConfig_ObservationTrigger* internal_default_instance()
    {
        return reinterpret_cast<const TrainingOutputs_TriggerConfig_ObservationTrigger*>(&_TrainingOutputs_TriggerConfig_ObservationTrigger_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(TrainingOutputs_TriggerConfig_ObservationTrigger& a, TrainingOutputs_TriggerConfig_ObservationTrigger& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TrainingOutputs_TriggerConfig_ObservationTrigger* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TrainingOutputs_TriggerConfig_ObservationTrigger* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TrainingOutputs_TriggerConfig_ObservationTrigger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TrainingOutputs_TriggerConfig_ObservationTrigger>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TrainingOutputs_TriggerConfig_ObservationTrigger& from);
    void MergeFrom(const TrainingOutputs_TriggerConfig_ObservationTrigger& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TrainingOutputs_TriggerConfig_ObservationTrigger* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger";
    }

protected:
    explicit TrainingOutputs_TriggerConfig_ObservationTrigger(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDelaySecFieldNumber = 1,
        kUmaTriggerFieldNumber = 2,
    };
    // uint64 delay_sec = 1;
    bool has_delay_sec() const;

private:
    bool _internal_has_delay_sec() const;

public:
    void clear_delay_sec();
    uint64_t delay_sec() const;
    void set_delay_sec(uint64_t value);

private:
    uint64_t _internal_delay_sec() const;
    void _internal_set_delay_sec(uint64_t value);

public:
    // .segmentation_platform.proto.UMAOutput uma_trigger = 2;
    bool has_uma_trigger() const;

private:
    bool _internal_has_uma_trigger() const;

public:
    void clear_uma_trigger();
    const ::segmentation_platform::proto::UMAOutput& uma_trigger() const;
    PROTOBUF_NODISCARD ::segmentation_platform::proto::UMAOutput* release_uma_trigger();
    ::segmentation_platform::proto::UMAOutput* mutable_uma_trigger();
    void set_allocated_uma_trigger(::segmentation_platform::proto::UMAOutput* uma_trigger);

private:
    const ::segmentation_platform::proto::UMAOutput& _internal_uma_trigger() const;
    ::segmentation_platform::proto::UMAOutput* _internal_mutable_uma_trigger();

public:
    void unsafe_arena_set_allocated_uma_trigger(::segmentation_platform::proto::UMAOutput* uma_trigger);
    ::segmentation_platform::proto::UMAOutput* unsafe_arena_release_uma_trigger();

    void clear_trigger();
    TriggerCase trigger_case() const;
    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger)
private:
    class _Internal;
    void set_has_delay_sec();
    void set_has_uma_trigger();

    inline bool has_trigger() const;
    inline void clear_has_trigger();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        union TriggerUnion {
            constexpr TriggerUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            uint64_t delay_sec_;
            ::segmentation_platform::proto::UMAOutput* uma_trigger_;
        } trigger_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class TrainingOutputs_TriggerConfig final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.TrainingOutputs.TriggerConfig) */ {
public:
    inline TrainingOutputs_TriggerConfig()
        : TrainingOutputs_TriggerConfig(nullptr)
    {
    }
    ~TrainingOutputs_TriggerConfig() override;
    explicit PROTOBUF_CONSTEXPR TrainingOutputs_TriggerConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TrainingOutputs_TriggerConfig(const TrainingOutputs_TriggerConfig& from);
    TrainingOutputs_TriggerConfig(TrainingOutputs_TriggerConfig&& from) noexcept
        : TrainingOutputs_TriggerConfig()
    {
        *this = ::std::move(from);
    }

    inline TrainingOutputs_TriggerConfig& operator=(const TrainingOutputs_TriggerConfig& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TrainingOutputs_TriggerConfig& operator=(TrainingOutputs_TriggerConfig&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const TrainingOutputs_TriggerConfig& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const TrainingOutputs_TriggerConfig* internal_default_instance()
    {
        return reinterpret_cast<const TrainingOutputs_TriggerConfig*>(&_TrainingOutputs_TriggerConfig_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 10;

    friend void swap(TrainingOutputs_TriggerConfig& a, TrainingOutputs_TriggerConfig& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TrainingOutputs_TriggerConfig* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TrainingOutputs_TriggerConfig* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TrainingOutputs_TriggerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TrainingOutputs_TriggerConfig>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TrainingOutputs_TriggerConfig& from);
    void MergeFrom(const TrainingOutputs_TriggerConfig& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TrainingOutputs_TriggerConfig* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.TrainingOutputs.TriggerConfig";
    }

protected:
    explicit TrainingOutputs_TriggerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef TrainingOutputs_TriggerConfig_ObservationTrigger ObservationTrigger;

    typedef TrainingOutputs_TriggerConfig_DecisionType DecisionType;
    static constexpr DecisionType UNKNOWN = TrainingOutputs_TriggerConfig_DecisionType_UNKNOWN;
    static constexpr DecisionType ONDEMAND = TrainingOutputs_TriggerConfig_DecisionType_ONDEMAND;
    static constexpr DecisionType PERIODIC = TrainingOutputs_TriggerConfig_DecisionType_PERIODIC;
    static inline bool DecisionType_IsValid(int value)
    {
        return TrainingOutputs_TriggerConfig_DecisionType_IsValid(value);
    }
    static constexpr DecisionType DecisionType_MIN = TrainingOutputs_TriggerConfig_DecisionType_DecisionType_MIN;
    static constexpr DecisionType DecisionType_MAX = TrainingOutputs_TriggerConfig_DecisionType_DecisionType_MAX;
    static constexpr int DecisionType_ARRAYSIZE = TrainingOutputs_TriggerConfig_DecisionType_DecisionType_ARRAYSIZE;
    template <typename T> static inline const std::string& DecisionType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, DecisionType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function DecisionType_Name.");
        return TrainingOutputs_TriggerConfig_DecisionType_Name(enum_t_value);
    }
    static inline bool DecisionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DecisionType* value)
    {
        return TrainingOutputs_TriggerConfig_DecisionType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kObservationTriggerFieldNumber = 2,
        kDecisionTypeFieldNumber = 1,
        kUseExactPredictionTimeFieldNumber = 3,
        kUseFlexibleObservationTimeFieldNumber = 4,
    };
    // repeated .segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger observation_trigger = 2;
    int observation_trigger_size() const;

private:
    int _internal_observation_trigger_size() const;

public:
    void clear_observation_trigger();
    ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger* mutable_observation_trigger(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger>* mutable_observation_trigger();

private:
    const ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger& _internal_observation_trigger(int index) const;
    ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger* _internal_add_observation_trigger();

public:
    const ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger& observation_trigger(int index) const;
    ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger* add_observation_trigger();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger>&
    observation_trigger() const;

    // optional .segmentation_platform.proto.TrainingOutputs.TriggerConfig.DecisionType decision_type = 1;
    bool has_decision_type() const;

private:
    bool _internal_has_decision_type() const;

public:
    void clear_decision_type();
    ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_DecisionType decision_type() const;
    void set_decision_type(::segmentation_platform::proto::TrainingOutputs_TriggerConfig_DecisionType value);

private:
    ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_DecisionType _internal_decision_type() const;
    void _internal_set_decision_type(::segmentation_platform::proto::TrainingOutputs_TriggerConfig_DecisionType value);

public:
    // optional bool use_exact_prediction_time = 3;
    bool has_use_exact_prediction_time() const;

private:
    bool _internal_has_use_exact_prediction_time() const;

public:
    void clear_use_exact_prediction_time();
    bool use_exact_prediction_time() const;
    void set_use_exact_prediction_time(bool value);

private:
    bool _internal_use_exact_prediction_time() const;
    void _internal_set_use_exact_prediction_time(bool value);

public:
    // optional bool use_flexible_observation_time = 4;
    bool has_use_flexible_observation_time() const;

private:
    bool _internal_has_use_flexible_observation_time() const;

public:
    void clear_use_flexible_observation_time();
    bool use_flexible_observation_time() const;
    void set_use_flexible_observation_time(bool value);

private:
    bool _internal_use_flexible_observation_time() const;
    void _internal_set_use_flexible_observation_time(bool value);

public:
    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.TrainingOutputs.TriggerConfig)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger> observation_trigger_;
        int decision_type_;
        bool use_exact_prediction_time_;
        bool use_flexible_observation_time_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class TrainingOutputs final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.TrainingOutputs) */ {
public:
    inline TrainingOutputs()
        : TrainingOutputs(nullptr)
    {
    }
    ~TrainingOutputs() override;
    explicit PROTOBUF_CONSTEXPR TrainingOutputs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TrainingOutputs(const TrainingOutputs& from);
    TrainingOutputs(TrainingOutputs&& from) noexcept
        : TrainingOutputs()
    {
        *this = ::std::move(from);
    }

    inline TrainingOutputs& operator=(const TrainingOutputs& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TrainingOutputs& operator=(TrainingOutputs&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const TrainingOutputs& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const TrainingOutputs* internal_default_instance()
    {
        return reinterpret_cast<const TrainingOutputs*>(&_TrainingOutputs_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 11;

    friend void swap(TrainingOutputs& a, TrainingOutputs& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TrainingOutputs* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TrainingOutputs* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TrainingOutputs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TrainingOutputs>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TrainingOutputs& from);
    void MergeFrom(const TrainingOutputs& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TrainingOutputs* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.TrainingOutputs";
    }

protected:
    explicit TrainingOutputs(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef TrainingOutputs_TriggerConfig TriggerConfig;

    // accessors -------------------------------------------------------

    enum : int {
        kOutputsFieldNumber = 1,
        kTriggerConfigFieldNumber = 2,
    };
    // repeated .segmentation_platform.proto.TrainingOutput outputs = 1;
    int outputs_size() const;

private:
    int _internal_outputs_size() const;

public:
    void clear_outputs();
    ::segmentation_platform::proto::TrainingOutput* mutable_outputs(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::TrainingOutput>* mutable_outputs();

private:
    const ::segmentation_platform::proto::TrainingOutput& _internal_outputs(int index) const;
    ::segmentation_platform::proto::TrainingOutput* _internal_add_outputs();

public:
    const ::segmentation_platform::proto::TrainingOutput& outputs(int index) const;
    ::segmentation_platform::proto::TrainingOutput* add_outputs();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::TrainingOutput>& outputs() const;

    // optional .segmentation_platform.proto.TrainingOutputs.TriggerConfig trigger_config = 2;
    bool has_trigger_config() const;

private:
    bool _internal_has_trigger_config() const;

public:
    void clear_trigger_config();
    const ::segmentation_platform::proto::TrainingOutputs_TriggerConfig& trigger_config() const;
    PROTOBUF_NODISCARD ::segmentation_platform::proto::TrainingOutputs_TriggerConfig* release_trigger_config();
    ::segmentation_platform::proto::TrainingOutputs_TriggerConfig* mutable_trigger_config();
    void set_allocated_trigger_config(::segmentation_platform::proto::TrainingOutputs_TriggerConfig* trigger_config);

private:
    const ::segmentation_platform::proto::TrainingOutputs_TriggerConfig& _internal_trigger_config() const;
    ::segmentation_platform::proto::TrainingOutputs_TriggerConfig* _internal_mutable_trigger_config();

public:
    void unsafe_arena_set_allocated_trigger_config(::segmentation_platform::proto::TrainingOutputs_TriggerConfig* trigger_config);
    ::segmentation_platform::proto::TrainingOutputs_TriggerConfig* unsafe_arena_release_trigger_config();

    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.TrainingOutputs)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::TrainingOutput> outputs_;
        ::segmentation_platform::proto::TrainingOutputs_TriggerConfig* trigger_config_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class TrainingOutput final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.TrainingOutput) */ {
public:
    inline TrainingOutput()
        : TrainingOutput(nullptr)
    {
    }
    ~TrainingOutput() override;
    explicit PROTOBUF_CONSTEXPR TrainingOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TrainingOutput(const TrainingOutput& from);
    TrainingOutput(TrainingOutput&& from) noexcept
        : TrainingOutput()
    {
        *this = ::std::move(from);
    }

    inline TrainingOutput& operator=(const TrainingOutput& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TrainingOutput& operator=(TrainingOutput&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const TrainingOutput& default_instance()
    {
        return *internal_default_instance();
    }
    enum OutputCase {
        kUmaOutput = 1,
        OUTPUT_NOT_SET = 0,
    };

    static inline const TrainingOutput* internal_default_instance()
    {
        return reinterpret_cast<const TrainingOutput*>(&_TrainingOutput_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 12;

    friend void swap(TrainingOutput& a, TrainingOutput& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TrainingOutput* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TrainingOutput* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TrainingOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TrainingOutput>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TrainingOutput& from);
    void MergeFrom(const TrainingOutput& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TrainingOutput* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.TrainingOutput";
    }

protected:
    explicit TrainingOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUmaOutputFieldNumber = 1,
    };
    // .segmentation_platform.proto.UMAOutput uma_output = 1;
    bool has_uma_output() const;

private:
    bool _internal_has_uma_output() const;

public:
    void clear_uma_output();
    const ::segmentation_platform::proto::UMAOutput& uma_output() const;
    PROTOBUF_NODISCARD ::segmentation_platform::proto::UMAOutput* release_uma_output();
    ::segmentation_platform::proto::UMAOutput* mutable_uma_output();
    void set_allocated_uma_output(::segmentation_platform::proto::UMAOutput* uma_output);

private:
    const ::segmentation_platform::proto::UMAOutput& _internal_uma_output() const;
    ::segmentation_platform::proto::UMAOutput* _internal_mutable_uma_output();

public:
    void unsafe_arena_set_allocated_uma_output(::segmentation_platform::proto::UMAOutput* uma_output);
    ::segmentation_platform::proto::UMAOutput* unsafe_arena_release_uma_output();

    void clear_output();
    OutputCase output_case() const;
    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.TrainingOutput)
private:
    class _Internal;
    void set_has_uma_output();

    inline bool has_output() const;
    inline void clear_has_output();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        union OutputUnion {
            constexpr OutputUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::segmentation_platform::proto::UMAOutput* uma_output_;
        } output_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class UMAOutput final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.UMAOutput) */ {
public:
    inline UMAOutput()
        : UMAOutput(nullptr)
    {
    }
    ~UMAOutput() override;
    explicit PROTOBUF_CONSTEXPR UMAOutput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    UMAOutput(const UMAOutput& from);
    UMAOutput(UMAOutput&& from) noexcept
        : UMAOutput()
    {
        *this = ::std::move(from);
    }

    inline UMAOutput& operator=(const UMAOutput& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UMAOutput& operator=(UMAOutput&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const UMAOutput& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const UMAOutput* internal_default_instance()
    {
        return reinterpret_cast<const UMAOutput*>(&_UMAOutput_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 13;

    friend void swap(UMAOutput& a, UMAOutput& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(UMAOutput* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UMAOutput* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UMAOutput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<UMAOutput>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const UMAOutput& from);
    void MergeFrom(const UMAOutput& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(UMAOutput* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.UMAOutput";
    }

protected:
    explicit UMAOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUmaFeatureFieldNumber = 1,
        kDurationFieldNumber = 2,
    };
    // optional .segmentation_platform.proto.UMAFeature uma_feature = 1;
    bool has_uma_feature() const;

private:
    bool _internal_has_uma_feature() const;

public:
    void clear_uma_feature();
    const ::segmentation_platform::proto::UMAFeature& uma_feature() const;
    PROTOBUF_NODISCARD ::segmentation_platform::proto::UMAFeature* release_uma_feature();
    ::segmentation_platform::proto::UMAFeature* mutable_uma_feature();
    void set_allocated_uma_feature(::segmentation_platform::proto::UMAFeature* uma_feature);

private:
    const ::segmentation_platform::proto::UMAFeature& _internal_uma_feature() const;
    ::segmentation_platform::proto::UMAFeature* _internal_mutable_uma_feature();

public:
    void unsafe_arena_set_allocated_uma_feature(::segmentation_platform::proto::UMAFeature* uma_feature);
    ::segmentation_platform::proto::UMAFeature* unsafe_arena_release_uma_feature();

    // optional uint64 duration = 2;
    bool has_duration() const;

private:
    bool _internal_has_duration() const;

public:
    void clear_duration();
    uint64_t duration() const;
    void set_duration(uint64_t value);

private:
    uint64_t _internal_duration() const;
    void _internal_set_duration(uint64_t value);

public:
    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.UMAOutput)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::segmentation_platform::proto::UMAFeature* uma_feature_;
        uint64_t duration_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SegmentationModelMetadata_DiscreteMapping_Entry final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry) */ {
public:
    inline SegmentationModelMetadata_DiscreteMapping_Entry()
        : SegmentationModelMetadata_DiscreteMapping_Entry(nullptr)
    {
    }
    ~SegmentationModelMetadata_DiscreteMapping_Entry() override;
    explicit PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMapping_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SegmentationModelMetadata_DiscreteMapping_Entry(const SegmentationModelMetadata_DiscreteMapping_Entry& from);
    SegmentationModelMetadata_DiscreteMapping_Entry(SegmentationModelMetadata_DiscreteMapping_Entry&& from) noexcept
        : SegmentationModelMetadata_DiscreteMapping_Entry()
    {
        *this = ::std::move(from);
    }

    inline SegmentationModelMetadata_DiscreteMapping_Entry& operator=(const SegmentationModelMetadata_DiscreteMapping_Entry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SegmentationModelMetadata_DiscreteMapping_Entry& operator=(SegmentationModelMetadata_DiscreteMapping_Entry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SegmentationModelMetadata_DiscreteMapping_Entry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SegmentationModelMetadata_DiscreteMapping_Entry* internal_default_instance()
    {
        return reinterpret_cast<const SegmentationModelMetadata_DiscreteMapping_Entry*>(&_SegmentationModelMetadata_DiscreteMapping_Entry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 14;

    friend void swap(SegmentationModelMetadata_DiscreteMapping_Entry& a, SegmentationModelMetadata_DiscreteMapping_Entry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SegmentationModelMetadata_DiscreteMapping_Entry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SegmentationModelMetadata_DiscreteMapping_Entry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SegmentationModelMetadata_DiscreteMapping_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SegmentationModelMetadata_DiscreteMapping_Entry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SegmentationModelMetadata_DiscreteMapping_Entry& from);
    void MergeFrom(const SegmentationModelMetadata_DiscreteMapping_Entry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SegmentationModelMetadata_DiscreteMapping_Entry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry";
    }

protected:
    explicit SegmentationModelMetadata_DiscreteMapping_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kRankFieldNumber = 2,
        kMinResultFieldNumber = 1,
    };
    // optional int64 rank = 2;
    bool has_rank() const;

private:
    bool _internal_has_rank() const;

public:
    void clear_rank();
    int64_t rank() const;
    void set_rank(int64_t value);

private:
    int64_t _internal_rank() const;
    void _internal_set_rank(int64_t value);

public:
    // optional float min_result = 1;
    bool has_min_result() const;

private:
    bool _internal_has_min_result() const;

public:
    void clear_min_result();
    float min_result() const;
    void set_min_result(float value);

private:
    float _internal_min_result() const;
    void _internal_set_min_result(float value);

public:
    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int64_t rank_;
        float min_result_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SegmentationModelMetadata_DiscreteMapping final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping) */ {
public:
    inline SegmentationModelMetadata_DiscreteMapping()
        : SegmentationModelMetadata_DiscreteMapping(nullptr)
    {
    }
    ~SegmentationModelMetadata_DiscreteMapping() override;
    explicit PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMapping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SegmentationModelMetadata_DiscreteMapping(const SegmentationModelMetadata_DiscreteMapping& from);
    SegmentationModelMetadata_DiscreteMapping(SegmentationModelMetadata_DiscreteMapping&& from) noexcept
        : SegmentationModelMetadata_DiscreteMapping()
    {
        *this = ::std::move(from);
    }

    inline SegmentationModelMetadata_DiscreteMapping& operator=(const SegmentationModelMetadata_DiscreteMapping& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SegmentationModelMetadata_DiscreteMapping& operator=(SegmentationModelMetadata_DiscreteMapping&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SegmentationModelMetadata_DiscreteMapping& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SegmentationModelMetadata_DiscreteMapping* internal_default_instance()
    {
        return reinterpret_cast<const SegmentationModelMetadata_DiscreteMapping*>(&_SegmentationModelMetadata_DiscreteMapping_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 15;

    friend void swap(SegmentationModelMetadata_DiscreteMapping& a, SegmentationModelMetadata_DiscreteMapping& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SegmentationModelMetadata_DiscreteMapping* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SegmentationModelMetadata_DiscreteMapping* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SegmentationModelMetadata_DiscreteMapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SegmentationModelMetadata_DiscreteMapping>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SegmentationModelMetadata_DiscreteMapping& from);
    void MergeFrom(const SegmentationModelMetadata_DiscreteMapping& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SegmentationModelMetadata_DiscreteMapping* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping";
    }

protected:
    explicit SegmentationModelMetadata_DiscreteMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef SegmentationModelMetadata_DiscreteMapping_Entry Entry;

    // accessors -------------------------------------------------------

    enum : int {
        kEntriesFieldNumber = 1,
    };
    // repeated .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry entries = 1;
    int entries_size() const;

private:
    int _internal_entries_size() const;

public:
    void clear_entries();
    ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* mutable_entries(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry>* mutable_entries();

private:
    const ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry& _internal_entries(int index) const;
    ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* _internal_add_entries();

public:
    const ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry& entries(int index) const;
    ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* add_entries();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry>& entries() const;

    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry> entries_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse
    : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse, std::string,
          ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
    typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse, std::string,
        ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE>
        SuperType;
    SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse();
    explicit PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
    explicit SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
    void MergeFrom(const SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse& other);
    static const SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse* internal_default_instance()
    {
        return reinterpret_cast<const SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse*>(
            &_SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse_default_instance_);
    }
    static bool ValidateKey(void*)
    {
        return true;
    }
    static bool ValidateValue(void*)
    {
        return true;
    }
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};

// -------------------------------------------------------------------

class SegmentationModelMetadata final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:segmentation_platform.proto.SegmentationModelMetadata) */ {
public:
    inline SegmentationModelMetadata()
        : SegmentationModelMetadata(nullptr)
    {
    }
    ~SegmentationModelMetadata() override;
    explicit PROTOBUF_CONSTEXPR SegmentationModelMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SegmentationModelMetadata(const SegmentationModelMetadata& from);
    SegmentationModelMetadata(SegmentationModelMetadata&& from) noexcept
        : SegmentationModelMetadata()
    {
        *this = ::std::move(from);
    }

    inline SegmentationModelMetadata& operator=(const SegmentationModelMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SegmentationModelMetadata& operator=(SegmentationModelMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SegmentationModelMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SegmentationModelMetadata* internal_default_instance()
    {
        return reinterpret_cast<const SegmentationModelMetadata*>(&_SegmentationModelMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 17;

    friend void swap(SegmentationModelMetadata& a, SegmentationModelMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SegmentationModelMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SegmentationModelMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SegmentationModelMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SegmentationModelMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SegmentationModelMetadata& from);
    void MergeFrom(const SegmentationModelMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SegmentationModelMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "segmentation_platform.proto.SegmentationModelMetadata";
    }

protected:
    explicit SegmentationModelMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef SegmentationModelMetadata_DiscreteMapping DiscreteMapping;

    typedef SegmentationModelMetadata_OutputDescription OutputDescription;
    static constexpr OutputDescription UNKNOWN_RETURN_TYPE = SegmentationModelMetadata_OutputDescription_UNKNOWN_RETURN_TYPE;
    static constexpr OutputDescription RETURN_TYPE_HEURISTIC = SegmentationModelMetadata_OutputDescription_RETURN_TYPE_HEURISTIC;
    static constexpr OutputDescription RETURN_TYPE_MULTISEGMENT = SegmentationModelMetadata_OutputDescription_RETURN_TYPE_MULTISEGMENT;
    static constexpr OutputDescription RETURN_TYPE_PROBABILITY = SegmentationModelMetadata_OutputDescription_RETURN_TYPE_PROBABILITY;
    static constexpr OutputDescription RETURN_TYPE_INTEGER = SegmentationModelMetadata_OutputDescription_RETURN_TYPE_INTEGER;
    static inline bool OutputDescription_IsValid(int value)
    {
        return SegmentationModelMetadata_OutputDescription_IsValid(value);
    }
    static constexpr OutputDescription OutputDescription_MIN = SegmentationModelMetadata_OutputDescription_OutputDescription_MIN;
    static constexpr OutputDescription OutputDescription_MAX = SegmentationModelMetadata_OutputDescription_OutputDescription_MAX;
    static constexpr int OutputDescription_ARRAYSIZE = SegmentationModelMetadata_OutputDescription_OutputDescription_ARRAYSIZE;
    template <typename T> static inline const std::string& OutputDescription_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, OutputDescription>::value || ::std::is_integral<T>::value, "Incorrect type passed to function OutputDescription_Name.");
        return SegmentationModelMetadata_OutputDescription_Name(enum_t_value);
    }
    static inline bool OutputDescription_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OutputDescription* value)
    {
        return SegmentationModelMetadata_OutputDescription_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kFeaturesFieldNumber = 1,
        kDiscreteMappingsFieldNumber = 7,
        kInputFeaturesFieldNumber = 10,
        kDefaultDiscreteMappingFieldNumber = 8,
        kVersionInfoFieldNumber = 9,
        kTrainingOutputsFieldNumber = 11,
        kOutputConfigFieldNumber = 16,
        kBucketDurationFieldNumber = 3,
        kSignalStorageLengthFieldNumber = 4,
        kMinSignalCollectionLengthFieldNumber = 5,
        kResultTimeToLiveFieldNumber = 6,
        kTimeUnitFieldNumber = 2,
        kUploadTensorsFieldNumber = 13,
        kFixedPredictionTimestampFieldNumber = 17,
        kReturnTypeFieldNumber = 14,
    };
    // repeated .segmentation_platform.proto.UMAFeature features = 1;
    int features_size() const;

private:
    int _internal_features_size() const;

public:
    void clear_features();
    ::segmentation_platform::proto::UMAFeature* mutable_features(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::UMAFeature>* mutable_features();

private:
    const ::segmentation_platform::proto::UMAFeature& _internal_features(int index) const;
    ::segmentation_platform::proto::UMAFeature* _internal_add_features();

public:
    const ::segmentation_platform::proto::UMAFeature& features(int index) const;
    ::segmentation_platform::proto::UMAFeature* add_features();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::UMAFeature>& features() const;

    // map<string, .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping> discrete_mappings = 7;
    int discrete_mappings_size() const;

private:
    int _internal_discrete_mappings_size() const;

public:
    void clear_discrete_mappings();

private:
    const ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>&
    _internal_discrete_mappings() const;
    ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>* _internal_mutable_discrete_mappings();

public:
    const ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>& discrete_mappings() const;
    ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>* mutable_discrete_mappings();

    // repeated .segmentation_platform.proto.InputFeature input_features = 10;
    int input_features_size() const;

private:
    int _internal_input_features_size() const;

public:
    void clear_input_features();
    ::segmentation_platform::proto::InputFeature* mutable_input_features(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::InputFeature>* mutable_input_features();

private:
    const ::segmentation_platform::proto::InputFeature& _internal_input_features(int index) const;
    ::segmentation_platform::proto::InputFeature* _internal_add_input_features();

public:
    const ::segmentation_platform::proto::InputFeature& input_features(int index) const;
    ::segmentation_platform::proto::InputFeature* add_input_features();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::InputFeature>& input_features() const;

    // optional string default_discrete_mapping = 8;
    bool has_default_discrete_mapping() const;

private:
    bool _internal_has_default_discrete_mapping() const;

public:
    void clear_default_discrete_mapping();
    const std::string& default_discrete_mapping() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_default_discrete_mapping(ArgT0&& arg0, ArgT... args);
    std::string* mutable_default_discrete_mapping();
    PROTOBUF_NODISCARD std::string* release_default_discrete_mapping();
    void set_allocated_default_discrete_mapping(std::string* default_discrete_mapping);

private:
    const std::string& _internal_default_discrete_mapping() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_discrete_mapping(const std::string& value);
    std::string* _internal_mutable_default_discrete_mapping();

public:
    // optional .segmentation_platform.proto.VersionInfo version_info = 9;
    bool has_version_info() const;

private:
    bool _internal_has_version_info() const;

public:
    void clear_version_info();
    const ::segmentation_platform::proto::VersionInfo& version_info() const;
    PROTOBUF_NODISCARD ::segmentation_platform::proto::VersionInfo* release_version_info();
    ::segmentation_platform::proto::VersionInfo* mutable_version_info();
    void set_allocated_version_info(::segmentation_platform::proto::VersionInfo* version_info);

private:
    const ::segmentation_platform::proto::VersionInfo& _internal_version_info() const;
    ::segmentation_platform::proto::VersionInfo* _internal_mutable_version_info();

public:
    void unsafe_arena_set_allocated_version_info(::segmentation_platform::proto::VersionInfo* version_info);
    ::segmentation_platform::proto::VersionInfo* unsafe_arena_release_version_info();

    // optional .segmentation_platform.proto.TrainingOutputs training_outputs = 11;
    bool has_training_outputs() const;

private:
    bool _internal_has_training_outputs() const;

public:
    void clear_training_outputs();
    const ::segmentation_platform::proto::TrainingOutputs& training_outputs() const;
    PROTOBUF_NODISCARD ::segmentation_platform::proto::TrainingOutputs* release_training_outputs();
    ::segmentation_platform::proto::TrainingOutputs* mutable_training_outputs();
    void set_allocated_training_outputs(::segmentation_platform::proto::TrainingOutputs* training_outputs);

private:
    const ::segmentation_platform::proto::TrainingOutputs& _internal_training_outputs() const;
    ::segmentation_platform::proto::TrainingOutputs* _internal_mutable_training_outputs();

public:
    void unsafe_arena_set_allocated_training_outputs(::segmentation_platform::proto::TrainingOutputs* training_outputs);
    ::segmentation_platform::proto::TrainingOutputs* unsafe_arena_release_training_outputs();

    // optional .segmentation_platform.proto.OutputConfig output_config = 16;
    bool has_output_config() const;

private:
    bool _internal_has_output_config() const;

public:
    void clear_output_config();
    const ::segmentation_platform::proto::OutputConfig& output_config() const;
    PROTOBUF_NODISCARD ::segmentation_platform::proto::OutputConfig* release_output_config();
    ::segmentation_platform::proto::OutputConfig* mutable_output_config();
    void set_allocated_output_config(::segmentation_platform::proto::OutputConfig* output_config);

private:
    const ::segmentation_platform::proto::OutputConfig& _internal_output_config() const;
    ::segmentation_platform::proto::OutputConfig* _internal_mutable_output_config();

public:
    void unsafe_arena_set_allocated_output_config(::segmentation_platform::proto::OutputConfig* output_config);
    ::segmentation_platform::proto::OutputConfig* unsafe_arena_release_output_config();

    // optional uint64 bucket_duration = 3;
    bool has_bucket_duration() const;

private:
    bool _internal_has_bucket_duration() const;

public:
    void clear_bucket_duration();
    uint64_t bucket_duration() const;
    void set_bucket_duration(uint64_t value);

private:
    uint64_t _internal_bucket_duration() const;
    void _internal_set_bucket_duration(uint64_t value);

public:
    // optional int64 signal_storage_length = 4;
    bool has_signal_storage_length() const;

private:
    bool _internal_has_signal_storage_length() const;

public:
    void clear_signal_storage_length();
    int64_t signal_storage_length() const;
    void set_signal_storage_length(int64_t value);

private:
    int64_t _internal_signal_storage_length() const;
    void _internal_set_signal_storage_length(int64_t value);

public:
    // optional int64 min_signal_collection_length = 5;
    bool has_min_signal_collection_length() const;

private:
    bool _internal_has_min_signal_collection_length() const;

public:
    void clear_min_signal_collection_length();
    int64_t min_signal_collection_length() const;
    void set_min_signal_collection_length(int64_t value);

private:
    int64_t _internal_min_signal_collection_length() const;
    void _internal_set_min_signal_collection_length(int64_t value);

public:
    // optional int64 result_time_to_live = 6;
    bool has_result_time_to_live() const;

private:
    bool _internal_has_result_time_to_live() const;

public:
    void clear_result_time_to_live();
    int64_t result_time_to_live() const;
    void set_result_time_to_live(int64_t value);

private:
    int64_t _internal_result_time_to_live() const;
    void _internal_set_result_time_to_live(int64_t value);

public:
    // optional .segmentation_platform.proto.TimeUnit time_unit = 2;
    bool has_time_unit() const;

private:
    bool _internal_has_time_unit() const;

public:
    void clear_time_unit();
    ::segmentation_platform::proto::TimeUnit time_unit() const;
    void set_time_unit(::segmentation_platform::proto::TimeUnit value);

private:
    ::segmentation_platform::proto::TimeUnit _internal_time_unit() const;
    void _internal_set_time_unit(::segmentation_platform::proto::TimeUnit value);

public:
    // optional bool upload_tensors = 13;
    bool has_upload_tensors() const;

private:
    bool _internal_has_upload_tensors() const;

public:
    void clear_upload_tensors();
    bool upload_tensors() const;
    void set_upload_tensors(bool value);

private:
    bool _internal_upload_tensors() const;
    void _internal_set_upload_tensors(bool value);

public:
    // optional int64 fixed_prediction_timestamp = 17;
    bool has_fixed_prediction_timestamp() const;

private:
    bool _internal_has_fixed_prediction_timestamp() const;

public:
    void clear_fixed_prediction_timestamp();
    int64_t fixed_prediction_timestamp() const;
    void set_fixed_prediction_timestamp(int64_t value);

private:
    int64_t _internal_fixed_prediction_timestamp() const;
    void _internal_set_fixed_prediction_timestamp(int64_t value);

public:
    // optional .segmentation_platform.proto.SegmentationModelMetadata.OutputDescription return_type = 14;
    bool has_return_type() const;

private:
    bool _internal_has_return_type() const;

public:
    void clear_return_type();
    ::segmentation_platform::proto::SegmentationModelMetadata_OutputDescription return_type() const;
    void set_return_type(::segmentation_platform::proto::SegmentationModelMetadata_OutputDescription value);

private:
    ::segmentation_platform::proto::SegmentationModelMetadata_OutputDescription _internal_return_type() const;
    void _internal_set_return_type(::segmentation_platform::proto::SegmentationModelMetadata_OutputDescription value);

public:
    // @@protoc_insertion_point(class_scope:segmentation_platform.proto.SegmentationModelMetadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::UMAFeature> features_;
        ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse, std::string,
            ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE>
            discrete_mappings_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::InputFeature> input_features_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_discrete_mapping_;
        ::segmentation_platform::proto::VersionInfo* version_info_;
        ::segmentation_platform::proto::TrainingOutputs* training_outputs_;
        ::segmentation_platform::proto::OutputConfig* output_config_;
        uint64_t bucket_duration_;
        int64_t signal_storage_length_;
        int64_t min_signal_collection_length_;
        int64_t result_time_to_live_;
        int time_unit_;
        bool upload_tensors_;
        int64_t fixed_prediction_timestamp_;
        int return_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// VersionInfo

// optional int32 metadata_min_version = 1;
inline bool VersionInfo::_internal_has_metadata_min_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool VersionInfo::has_metadata_min_version() const
{
    return _internal_has_metadata_min_version();
}
inline void VersionInfo::clear_metadata_min_version()
{
    _impl_.metadata_min_version_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t VersionInfo::_internal_metadata_min_version() const
{
    return _impl_.metadata_min_version_;
}
inline int32_t VersionInfo::metadata_min_version() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.VersionInfo.metadata_min_version)
    return _internal_metadata_min_version();
}
inline void VersionInfo::_internal_set_metadata_min_version(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.metadata_min_version_ = value;
}
inline void VersionInfo::set_metadata_min_version(int32_t value)
{
    _internal_set_metadata_min_version(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.VersionInfo.metadata_min_version)
}

// optional int32 metadata_cur_version = 2;
inline bool VersionInfo::_internal_has_metadata_cur_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool VersionInfo::has_metadata_cur_version() const
{
    return _internal_has_metadata_cur_version();
}
inline void VersionInfo::clear_metadata_cur_version()
{
    _impl_.metadata_cur_version_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t VersionInfo::_internal_metadata_cur_version() const
{
    return _impl_.metadata_cur_version_;
}
inline int32_t VersionInfo::metadata_cur_version() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.VersionInfo.metadata_cur_version)
    return _internal_metadata_cur_version();
}
inline void VersionInfo::_internal_set_metadata_cur_version(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.metadata_cur_version_ = value;
}
inline void VersionInfo::set_metadata_cur_version(int32_t value)
{
    _internal_set_metadata_cur_version(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.VersionInfo.metadata_cur_version)
}

// -------------------------------------------------------------------

// UMAFeature

// optional .segmentation_platform.proto.SignalType type = 1;
inline bool UMAFeature::_internal_has_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool UMAFeature::has_type() const
{
    return _internal_has_type();
}
inline void UMAFeature::clear_type()
{
    _impl_.type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::segmentation_platform::proto::SignalType UMAFeature::_internal_type() const
{
    return static_cast<::segmentation_platform::proto::SignalType>(_impl_.type_);
}
inline ::segmentation_platform::proto::SignalType UMAFeature::type() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.type)
    return _internal_type();
}
inline void UMAFeature::_internal_set_type(::segmentation_platform::proto::SignalType value)
{
    assert(::segmentation_platform::proto::SignalType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.type_ = value;
}
inline void UMAFeature::set_type(::segmentation_platform::proto::SignalType value)
{
    _internal_set_type(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.type)
}

// optional string name = 2;
inline bool UMAFeature::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool UMAFeature::has_name() const
{
    return _internal_has_name();
}
inline void UMAFeature::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UMAFeature::name() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void UMAFeature::set_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.name)
}
inline std::string* UMAFeature::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.UMAFeature.name)
    return _s;
}
inline const std::string& UMAFeature::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void UMAFeature::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UMAFeature::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UMAFeature::release_name()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.UMAFeature.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void UMAFeature::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.UMAFeature.name)
}

// optional fixed64 name_hash = 3;
inline bool UMAFeature::_internal_has_name_hash() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool UMAFeature::has_name_hash() const
{
    return _internal_has_name_hash();
}
inline void UMAFeature::clear_name_hash()
{
    _impl_.name_hash_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t UMAFeature::_internal_name_hash() const
{
    return _impl_.name_hash_;
}
inline uint64_t UMAFeature::name_hash() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.name_hash)
    return _internal_name_hash();
}
inline void UMAFeature::_internal_set_name_hash(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.name_hash_ = value;
}
inline void UMAFeature::set_name_hash(uint64_t value)
{
    _internal_set_name_hash(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.name_hash)
}

// optional uint64 bucket_count = 4;
inline bool UMAFeature::_internal_has_bucket_count() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool UMAFeature::has_bucket_count() const
{
    return _internal_has_bucket_count();
}
inline void UMAFeature::clear_bucket_count()
{
    _impl_.bucket_count_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t UMAFeature::_internal_bucket_count() const
{
    return _impl_.bucket_count_;
}
inline uint64_t UMAFeature::bucket_count() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.bucket_count)
    return _internal_bucket_count();
}
inline void UMAFeature::_internal_set_bucket_count(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.bucket_count_ = value;
}
inline void UMAFeature::set_bucket_count(uint64_t value)
{
    _internal_set_bucket_count(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.bucket_count)
}

// optional uint64 tensor_length = 5;
inline bool UMAFeature::_internal_has_tensor_length() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool UMAFeature::has_tensor_length() const
{
    return _internal_has_tensor_length();
}
inline void UMAFeature::clear_tensor_length()
{
    _impl_.tensor_length_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint64_t UMAFeature::_internal_tensor_length() const
{
    return _impl_.tensor_length_;
}
inline uint64_t UMAFeature::tensor_length() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.tensor_length)
    return _internal_tensor_length();
}
inline void UMAFeature::_internal_set_tensor_length(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.tensor_length_ = value;
}
inline void UMAFeature::set_tensor_length(uint64_t value)
{
    _internal_set_tensor_length(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.tensor_length)
}

// optional .segmentation_platform.proto.Aggregation aggregation = 6;
inline bool UMAFeature::_internal_has_aggregation() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool UMAFeature::has_aggregation() const
{
    return _internal_has_aggregation();
}
inline void UMAFeature::clear_aggregation()
{
    _impl_.aggregation_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::segmentation_platform::proto::Aggregation UMAFeature::_internal_aggregation() const
{
    return static_cast<::segmentation_platform::proto::Aggregation>(_impl_.aggregation_);
}
inline ::segmentation_platform::proto::Aggregation UMAFeature::aggregation() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.aggregation)
    return _internal_aggregation();
}
inline void UMAFeature::_internal_set_aggregation(::segmentation_platform::proto::Aggregation value)
{
    assert(::segmentation_platform::proto::Aggregation_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.aggregation_ = value;
}
inline void UMAFeature::set_aggregation(::segmentation_platform::proto::Aggregation value)
{
    _internal_set_aggregation(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.aggregation)
}

// repeated int32 enum_ids = 7;
inline int UMAFeature::_internal_enum_ids_size() const
{
    return _impl_.enum_ids_.size();
}
inline int UMAFeature::enum_ids_size() const
{
    return _internal_enum_ids_size();
}
inline void UMAFeature::clear_enum_ids()
{
    _impl_.enum_ids_.Clear();
}
inline int32_t UMAFeature::_internal_enum_ids(int index) const
{
    return _impl_.enum_ids_.Get(index);
}
inline int32_t UMAFeature::enum_ids(int index) const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.enum_ids)
    return _internal_enum_ids(index);
}
inline void UMAFeature::set_enum_ids(int index, int32_t value)
{
    _impl_.enum_ids_.Set(index, value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.enum_ids)
}
inline void UMAFeature::_internal_add_enum_ids(int32_t value)
{
    _impl_.enum_ids_.Add(value);
}
inline void UMAFeature::add_enum_ids(int32_t value)
{
    _internal_add_enum_ids(value);
    // @@protoc_insertion_point(field_add:segmentation_platform.proto.UMAFeature.enum_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& UMAFeature::_internal_enum_ids() const
{
    return _impl_.enum_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& UMAFeature::enum_ids() const
{
    // @@protoc_insertion_point(field_list:segmentation_platform.proto.UMAFeature.enum_ids)
    return _internal_enum_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* UMAFeature::_internal_mutable_enum_ids()
{
    return &_impl_.enum_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* UMAFeature::mutable_enum_ids()
{
    // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.UMAFeature.enum_ids)
    return _internal_mutable_enum_ids();
}

// repeated float default_values = 8;
inline int UMAFeature::_internal_default_values_size() const
{
    return _impl_.default_values_.size();
}
inline int UMAFeature::default_values_size() const
{
    return _internal_default_values_size();
}
inline void UMAFeature::clear_default_values()
{
    _impl_.default_values_.Clear();
}
inline float UMAFeature::_internal_default_values(int index) const
{
    return _impl_.default_values_.Get(index);
}
inline float UMAFeature::default_values(int index) const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAFeature.default_values)
    return _internal_default_values(index);
}
inline void UMAFeature::set_default_values(int index, float value)
{
    _impl_.default_values_.Set(index, value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAFeature.default_values)
}
inline void UMAFeature::_internal_add_default_values(float value)
{
    _impl_.default_values_.Add(value);
}
inline void UMAFeature::add_default_values(float value)
{
    _internal_add_default_values(value);
    // @@protoc_insertion_point(field_add:segmentation_platform.proto.UMAFeature.default_values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& UMAFeature::_internal_default_values() const
{
    return _impl_.default_values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& UMAFeature::default_values() const
{
    // @@protoc_insertion_point(field_list:segmentation_platform.proto.UMAFeature.default_values)
    return _internal_default_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* UMAFeature::_internal_mutable_default_values()
{
    return &_impl_.default_values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* UMAFeature::mutable_default_values()
{
    // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.UMAFeature.default_values)
    return _internal_mutable_default_values();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CustomInput

// optional int32 tensor_length = 1;
inline bool CustomInput::_internal_has_tensor_length() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool CustomInput::has_tensor_length() const
{
    return _internal_has_tensor_length();
}
inline void CustomInput::clear_tensor_length()
{
    _impl_.tensor_length_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CustomInput::_internal_tensor_length() const
{
    return _impl_.tensor_length_;
}
inline int32_t CustomInput::tensor_length() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.CustomInput.tensor_length)
    return _internal_tensor_length();
}
inline void CustomInput::_internal_set_tensor_length(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.tensor_length_ = value;
}
inline void CustomInput::set_tensor_length(int32_t value)
{
    _internal_set_tensor_length(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.CustomInput.tensor_length)
}

// optional .segmentation_platform.proto.CustomInput.FillPolicy fill_policy = 2;
inline bool CustomInput::_internal_has_fill_policy() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool CustomInput::has_fill_policy() const
{
    return _internal_has_fill_policy();
}
inline void CustomInput::clear_fill_policy()
{
    _impl_.fill_policy_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::segmentation_platform::proto::CustomInput_FillPolicy CustomInput::_internal_fill_policy() const
{
    return static_cast<::segmentation_platform::proto::CustomInput_FillPolicy>(_impl_.fill_policy_);
}
inline ::segmentation_platform::proto::CustomInput_FillPolicy CustomInput::fill_policy() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.CustomInput.fill_policy)
    return _internal_fill_policy();
}
inline void CustomInput::_internal_set_fill_policy(::segmentation_platform::proto::CustomInput_FillPolicy value)
{
    assert(::segmentation_platform::proto::CustomInput_FillPolicy_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.fill_policy_ = value;
}
inline void CustomInput::set_fill_policy(::segmentation_platform::proto::CustomInput_FillPolicy value)
{
    _internal_set_fill_policy(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.CustomInput.fill_policy)
}

// repeated float default_value = 3;
inline int CustomInput::_internal_default_value_size() const
{
    return _impl_.default_value_.size();
}
inline int CustomInput::default_value_size() const
{
    return _internal_default_value_size();
}
inline void CustomInput::clear_default_value()
{
    _impl_.default_value_.Clear();
}
inline float CustomInput::_internal_default_value(int index) const
{
    return _impl_.default_value_.Get(index);
}
inline float CustomInput::default_value(int index) const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.CustomInput.default_value)
    return _internal_default_value(index);
}
inline void CustomInput::set_default_value(int index, float value)
{
    _impl_.default_value_.Set(index, value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.CustomInput.default_value)
}
inline void CustomInput::_internal_add_default_value(float value)
{
    _impl_.default_value_.Add(value);
}
inline void CustomInput::add_default_value(float value)
{
    _internal_add_default_value(value);
    // @@protoc_insertion_point(field_add:segmentation_platform.proto.CustomInput.default_value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& CustomInput::_internal_default_value() const
{
    return _impl_.default_value_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>& CustomInput::default_value() const
{
    // @@protoc_insertion_point(field_list:segmentation_platform.proto.CustomInput.default_value)
    return _internal_default_value();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* CustomInput::_internal_mutable_default_value()
{
    return &_impl_.default_value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<float>* CustomInput::mutable_default_value()
{
    // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.CustomInput.default_value)
    return _internal_mutable_default_value();
}

// map<string, string> additional_args = 4;
inline int CustomInput::_internal_additional_args_size() const
{
    return _impl_.additional_args_.size();
}
inline int CustomInput::additional_args_size() const
{
    return _internal_additional_args_size();
}
inline void CustomInput::clear_additional_args()
{
    _impl_.additional_args_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>& CustomInput::_internal_additional_args() const
{
    return _impl_.additional_args_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>& CustomInput::additional_args() const
{
    // @@protoc_insertion_point(field_map:segmentation_platform.proto.CustomInput.additional_args)
    return _internal_additional_args();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>* CustomInput::_internal_mutable_additional_args()
{
    return _impl_.additional_args_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>* CustomInput::mutable_additional_args()
{
    // @@protoc_insertion_point(field_mutable_map:segmentation_platform.proto.CustomInput.additional_args)
    return _internal_mutable_additional_args();
}

// optional string name = 5;
inline bool CustomInput::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool CustomInput::has_name() const
{
    return _internal_has_name();
}
inline void CustomInput::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CustomInput::name() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.CustomInput.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CustomInput::set_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.CustomInput.name)
}
inline std::string* CustomInput::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.CustomInput.name)
    return _s;
}
inline const std::string& CustomInput::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void CustomInput::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomInput::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CustomInput::release_name()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.CustomInput.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void CustomInput::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.CustomInput.name)
}

// -------------------------------------------------------------------

// SignalFilterConfig_UkmEvent

// optional uint64 event_hash = 1;
inline bool SignalFilterConfig_UkmEvent::_internal_has_event_hash() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SignalFilterConfig_UkmEvent::has_event_hash() const
{
    return _internal_has_event_hash();
}
inline void SignalFilterConfig_UkmEvent::clear_event_hash()
{
    _impl_.event_hash_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t SignalFilterConfig_UkmEvent::_internal_event_hash() const
{
    return _impl_.event_hash_;
}
inline uint64_t SignalFilterConfig_UkmEvent::event_hash() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SignalFilterConfig.UkmEvent.event_hash)
    return _internal_event_hash();
}
inline void SignalFilterConfig_UkmEvent::_internal_set_event_hash(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.event_hash_ = value;
}
inline void SignalFilterConfig_UkmEvent::set_event_hash(uint64_t value)
{
    _internal_set_event_hash(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SignalFilterConfig.UkmEvent.event_hash)
}

// repeated uint64 metric_hash_filter = 2;
inline int SignalFilterConfig_UkmEvent::_internal_metric_hash_filter_size() const
{
    return _impl_.metric_hash_filter_.size();
}
inline int SignalFilterConfig_UkmEvent::metric_hash_filter_size() const
{
    return _internal_metric_hash_filter_size();
}
inline void SignalFilterConfig_UkmEvent::clear_metric_hash_filter()
{
    _impl_.metric_hash_filter_.Clear();
}
inline uint64_t SignalFilterConfig_UkmEvent::_internal_metric_hash_filter(int index) const
{
    return _impl_.metric_hash_filter_.Get(index);
}
inline uint64_t SignalFilterConfig_UkmEvent::metric_hash_filter(int index) const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SignalFilterConfig.UkmEvent.metric_hash_filter)
    return _internal_metric_hash_filter(index);
}
inline void SignalFilterConfig_UkmEvent::set_metric_hash_filter(int index, uint64_t value)
{
    _impl_.metric_hash_filter_.Set(index, value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SignalFilterConfig.UkmEvent.metric_hash_filter)
}
inline void SignalFilterConfig_UkmEvent::_internal_add_metric_hash_filter(uint64_t value)
{
    _impl_.metric_hash_filter_.Add(value);
}
inline void SignalFilterConfig_UkmEvent::add_metric_hash_filter(uint64_t value)
{
    _internal_add_metric_hash_filter(value);
    // @@protoc_insertion_point(field_add:segmentation_platform.proto.SignalFilterConfig.UkmEvent.metric_hash_filter)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>& SignalFilterConfig_UkmEvent::_internal_metric_hash_filter() const
{
    return _impl_.metric_hash_filter_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>& SignalFilterConfig_UkmEvent::metric_hash_filter() const
{
    // @@protoc_insertion_point(field_list:segmentation_platform.proto.SignalFilterConfig.UkmEvent.metric_hash_filter)
    return _internal_metric_hash_filter();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>* SignalFilterConfig_UkmEvent::_internal_mutable_metric_hash_filter()
{
    return &_impl_.metric_hash_filter_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>* SignalFilterConfig_UkmEvent::mutable_metric_hash_filter()
{
    // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.SignalFilterConfig.UkmEvent.metric_hash_filter)
    return _internal_mutable_metric_hash_filter();
}

// -------------------------------------------------------------------

// SignalFilterConfig

// repeated .segmentation_platform.proto.SignalFilterConfig.UkmEvent ukm_events = 1;
inline int SignalFilterConfig::_internal_ukm_events_size() const
{
    return _impl_.ukm_events_.size();
}
inline int SignalFilterConfig::ukm_events_size() const
{
    return _internal_ukm_events_size();
}
inline void SignalFilterConfig::clear_ukm_events()
{
    _impl_.ukm_events_.Clear();
}
inline ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* SignalFilterConfig::mutable_ukm_events(int index)
{
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SignalFilterConfig.ukm_events)
    return _impl_.ukm_events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SignalFilterConfig_UkmEvent>* SignalFilterConfig::mutable_ukm_events()
{
    // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.SignalFilterConfig.ukm_events)
    return &_impl_.ukm_events_;
}
inline const ::segmentation_platform::proto::SignalFilterConfig_UkmEvent& SignalFilterConfig::_internal_ukm_events(int index) const
{
    return _impl_.ukm_events_.Get(index);
}
inline const ::segmentation_platform::proto::SignalFilterConfig_UkmEvent& SignalFilterConfig::ukm_events(int index) const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SignalFilterConfig.ukm_events)
    return _internal_ukm_events(index);
}
inline ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* SignalFilterConfig::_internal_add_ukm_events()
{
    return _impl_.ukm_events_.Add();
}
inline ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* SignalFilterConfig::add_ukm_events()
{
    ::segmentation_platform::proto::SignalFilterConfig_UkmEvent* _add = _internal_add_ukm_events();
    // @@protoc_insertion_point(field_add:segmentation_platform.proto.SignalFilterConfig.ukm_events)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SignalFilterConfig_UkmEvent>& SignalFilterConfig::ukm_events() const
{
    // @@protoc_insertion_point(field_list:segmentation_platform.proto.SignalFilterConfig.ukm_events)
    return _impl_.ukm_events_;
}

// -------------------------------------------------------------------

// SqlFeature_BindValue

// repeated int32 bind_field_index = 1;
inline int SqlFeature_BindValue::_internal_bind_field_index_size() const
{
    return _impl_.bind_field_index_.size();
}
inline int SqlFeature_BindValue::bind_field_index_size() const
{
    return _internal_bind_field_index_size();
}
inline void SqlFeature_BindValue::clear_bind_field_index()
{
    _impl_.bind_field_index_.Clear();
}
inline int32_t SqlFeature_BindValue::_internal_bind_field_index(int index) const
{
    return _impl_.bind_field_index_.Get(index);
}
inline int32_t SqlFeature_BindValue::bind_field_index(int index) const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SqlFeature.BindValue.bind_field_index)
    return _internal_bind_field_index(index);
}
inline void SqlFeature_BindValue::set_bind_field_index(int index, int32_t value)
{
    _impl_.bind_field_index_.Set(index, value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SqlFeature.BindValue.bind_field_index)
}
inline void SqlFeature_BindValue::_internal_add_bind_field_index(int32_t value)
{
    _impl_.bind_field_index_.Add(value);
}
inline void SqlFeature_BindValue::add_bind_field_index(int32_t value)
{
    _internal_add_bind_field_index(value);
    // @@protoc_insertion_point(field_add:segmentation_platform.proto.SqlFeature.BindValue.bind_field_index)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& SqlFeature_BindValue::_internal_bind_field_index() const
{
    return _impl_.bind_field_index_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& SqlFeature_BindValue::bind_field_index() const
{
    // @@protoc_insertion_point(field_list:segmentation_platform.proto.SqlFeature.BindValue.bind_field_index)
    return _internal_bind_field_index();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* SqlFeature_BindValue::_internal_mutable_bind_field_index()
{
    return &_impl_.bind_field_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* SqlFeature_BindValue::mutable_bind_field_index()
{
    // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.SqlFeature.BindValue.bind_field_index)
    return _internal_mutable_bind_field_index();
}

// optional .segmentation_platform.proto.SqlFeature.BindValue.ParamType param_type = 2;
inline bool SqlFeature_BindValue::_internal_has_param_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool SqlFeature_BindValue::has_param_type() const
{
    return _internal_has_param_type();
}
inline void SqlFeature_BindValue::clear_param_type()
{
    _impl_.param_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::segmentation_platform::proto::SqlFeature_BindValue_ParamType SqlFeature_BindValue::_internal_param_type() const
{
    return static_cast<::segmentation_platform::proto::SqlFeature_BindValue_ParamType>(_impl_.param_type_);
}
inline ::segmentation_platform::proto::SqlFeature_BindValue_ParamType SqlFeature_BindValue::param_type() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SqlFeature.BindValue.param_type)
    return _internal_param_type();
}
inline void SqlFeature_BindValue::_internal_set_param_type(::segmentation_platform::proto::SqlFeature_BindValue_ParamType value)
{
    assert(::segmentation_platform::proto::SqlFeature_BindValue_ParamType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.param_type_ = value;
}
inline void SqlFeature_BindValue::set_param_type(::segmentation_platform::proto::SqlFeature_BindValue_ParamType value)
{
    _internal_set_param_type(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SqlFeature.BindValue.param_type)
}

// optional .segmentation_platform.proto.CustomInput value = 3;
inline bool SqlFeature_BindValue::_internal_has_value() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
    return value;
}
inline bool SqlFeature_BindValue::has_value() const
{
    return _internal_has_value();
}
inline void SqlFeature_BindValue::clear_value()
{
    if (_impl_.value_ != nullptr)
        _impl_.value_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::segmentation_platform::proto::CustomInput& SqlFeature_BindValue::_internal_value() const
{
    const ::segmentation_platform::proto::CustomInput* p = _impl_.value_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::segmentation_platform::proto::CustomInput&>(::segmentation_platform::proto::_CustomInput_default_instance_);
}
inline const ::segmentation_platform::proto::CustomInput& SqlFeature_BindValue::value() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SqlFeature.BindValue.value)
    return _internal_value();
}
inline void SqlFeature_BindValue::unsafe_arena_set_allocated_value(::segmentation_platform::proto::CustomInput* value)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
    }
    _impl_.value_ = value;
    if (value) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.SqlFeature.BindValue.value)
}
inline ::segmentation_platform::proto::CustomInput* SqlFeature_BindValue::release_value()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::segmentation_platform::proto::CustomInput* temp = _impl_.value_;
    _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::segmentation_platform::proto::CustomInput* SqlFeature_BindValue::unsafe_arena_release_value()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.SqlFeature.BindValue.value)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::segmentation_platform::proto::CustomInput* temp = _impl_.value_;
    _impl_.value_ = nullptr;
    return temp;
}
inline ::segmentation_platform::proto::CustomInput* SqlFeature_BindValue::_internal_mutable_value()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.value_ == nullptr) {
        auto* p = CreateMaybeMessage<::segmentation_platform::proto::CustomInput>(GetArenaForAllocation());
        _impl_.value_ = p;
    }
    return _impl_.value_;
}
inline ::segmentation_platform::proto::CustomInput* SqlFeature_BindValue::mutable_value()
{
    ::segmentation_platform::proto::CustomInput* _msg = _internal_mutable_value();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SqlFeature.BindValue.value)
    return _msg;
}
inline void SqlFeature_BindValue::set_allocated_value(::segmentation_platform::proto::CustomInput* value)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.value_;
    }
    if (value) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
        if (message_arena != submessage_arena) {
            value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, value, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.value_ = value;
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SqlFeature.BindValue.value)
}

// -------------------------------------------------------------------

// SqlFeature

// optional string sql = 1;
inline bool SqlFeature::_internal_has_sql() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SqlFeature::has_sql() const
{
    return _internal_has_sql();
}
inline void SqlFeature::clear_sql()
{
    _impl_.sql_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SqlFeature::sql() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SqlFeature.sql)
    return _internal_sql();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SqlFeature::set_sql(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.sql_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SqlFeature.sql)
}
inline std::string* SqlFeature::mutable_sql()
{
    std::string* _s = _internal_mutable_sql();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SqlFeature.sql)
    return _s;
}
inline const std::string& SqlFeature::_internal_sql() const
{
    return _impl_.sql_.Get();
}
inline void SqlFeature::_internal_set_sql(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.sql_.Set(value, GetArenaForAllocation());
}
inline std::string* SqlFeature::_internal_mutable_sql()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.sql_.Mutable(GetArenaForAllocation());
}
inline std::string* SqlFeature::release_sql()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.SqlFeature.sql)
    if (!_internal_has_sql()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.sql_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sql_.IsDefault()) {
        _impl_.sql_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SqlFeature::set_allocated_sql(std::string* sql)
{
    if (sql != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.sql_.SetAllocated(sql, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sql_.IsDefault()) {
        _impl_.sql_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SqlFeature.sql)
}

// optional .segmentation_platform.proto.SignalFilterConfig signal_filter = 2;
inline bool SqlFeature::_internal_has_signal_filter() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.signal_filter_ != nullptr);
    return value;
}
inline bool SqlFeature::has_signal_filter() const
{
    return _internal_has_signal_filter();
}
inline void SqlFeature::clear_signal_filter()
{
    if (_impl_.signal_filter_ != nullptr)
        _impl_.signal_filter_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::segmentation_platform::proto::SignalFilterConfig& SqlFeature::_internal_signal_filter() const
{
    const ::segmentation_platform::proto::SignalFilterConfig* p = _impl_.signal_filter_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::segmentation_platform::proto::SignalFilterConfig&>(::segmentation_platform::proto::_SignalFilterConfig_default_instance_);
}
inline const ::segmentation_platform::proto::SignalFilterConfig& SqlFeature::signal_filter() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SqlFeature.signal_filter)
    return _internal_signal_filter();
}
inline void SqlFeature::unsafe_arena_set_allocated_signal_filter(::segmentation_platform::proto::SignalFilterConfig* signal_filter)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signal_filter_);
    }
    _impl_.signal_filter_ = signal_filter;
    if (signal_filter) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.SqlFeature.signal_filter)
}
inline ::segmentation_platform::proto::SignalFilterConfig* SqlFeature::release_signal_filter()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::segmentation_platform::proto::SignalFilterConfig* temp = _impl_.signal_filter_;
    _impl_.signal_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::segmentation_platform::proto::SignalFilterConfig* SqlFeature::unsafe_arena_release_signal_filter()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.SqlFeature.signal_filter)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::segmentation_platform::proto::SignalFilterConfig* temp = _impl_.signal_filter_;
    _impl_.signal_filter_ = nullptr;
    return temp;
}
inline ::segmentation_platform::proto::SignalFilterConfig* SqlFeature::_internal_mutable_signal_filter()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.signal_filter_ == nullptr) {
        auto* p = CreateMaybeMessage<::segmentation_platform::proto::SignalFilterConfig>(GetArenaForAllocation());
        _impl_.signal_filter_ = p;
    }
    return _impl_.signal_filter_;
}
inline ::segmentation_platform::proto::SignalFilterConfig* SqlFeature::mutable_signal_filter()
{
    ::segmentation_platform::proto::SignalFilterConfig* _msg = _internal_mutable_signal_filter();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SqlFeature.signal_filter)
    return _msg;
}
inline void SqlFeature::set_allocated_signal_filter(::segmentation_platform::proto::SignalFilterConfig* signal_filter)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.signal_filter_;
    }
    if (signal_filter) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(signal_filter);
        if (message_arena != submessage_arena) {
            signal_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, signal_filter, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.signal_filter_ = signal_filter;
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SqlFeature.signal_filter)
}

// repeated .segmentation_platform.proto.SqlFeature.BindValue bind_values = 3;
inline int SqlFeature::_internal_bind_values_size() const
{
    return _impl_.bind_values_.size();
}
inline int SqlFeature::bind_values_size() const
{
    return _internal_bind_values_size();
}
inline void SqlFeature::clear_bind_values()
{
    _impl_.bind_values_.Clear();
}
inline ::segmentation_platform::proto::SqlFeature_BindValue* SqlFeature::mutable_bind_values(int index)
{
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SqlFeature.bind_values)
    return _impl_.bind_values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SqlFeature_BindValue>* SqlFeature::mutable_bind_values()
{
    // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.SqlFeature.bind_values)
    return &_impl_.bind_values_;
}
inline const ::segmentation_platform::proto::SqlFeature_BindValue& SqlFeature::_internal_bind_values(int index) const
{
    return _impl_.bind_values_.Get(index);
}
inline const ::segmentation_platform::proto::SqlFeature_BindValue& SqlFeature::bind_values(int index) const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SqlFeature.bind_values)
    return _internal_bind_values(index);
}
inline ::segmentation_platform::proto::SqlFeature_BindValue* SqlFeature::_internal_add_bind_values()
{
    return _impl_.bind_values_.Add();
}
inline ::segmentation_platform::proto::SqlFeature_BindValue* SqlFeature::add_bind_values()
{
    ::segmentation_platform::proto::SqlFeature_BindValue* _add = _internal_add_bind_values();
    // @@protoc_insertion_point(field_add:segmentation_platform.proto.SqlFeature.bind_values)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SqlFeature_BindValue>& SqlFeature::bind_values() const
{
    // @@protoc_insertion_point(field_list:segmentation_platform.proto.SqlFeature.bind_values)
    return _impl_.bind_values_;
}

// optional string name = 4;
inline bool SqlFeature::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool SqlFeature::has_name() const
{
    return _internal_has_name();
}
inline void SqlFeature::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SqlFeature::name() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SqlFeature.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SqlFeature::set_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SqlFeature.name)
}
inline std::string* SqlFeature::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SqlFeature.name)
    return _s;
}
inline const std::string& SqlFeature::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void SqlFeature::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SqlFeature::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SqlFeature::release_name()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.SqlFeature.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SqlFeature::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SqlFeature.name)
}

// -------------------------------------------------------------------

// InputFeature

// .segmentation_platform.proto.UMAFeature uma_feature = 1;
inline bool InputFeature::_internal_has_uma_feature() const
{
    return Feature_case() == kUmaFeature;
}
inline bool InputFeature::has_uma_feature() const
{
    return _internal_has_uma_feature();
}
inline void InputFeature::set_has_uma_feature()
{
    _impl_._oneof_case_[0] = kUmaFeature;
}
inline void InputFeature::clear_uma_feature()
{
    if (_internal_has_uma_feature()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.Feature_.uma_feature_;
        }
        clear_has_Feature();
    }
}
inline ::segmentation_platform::proto::UMAFeature* InputFeature::release_uma_feature()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.InputFeature.uma_feature)
    if (_internal_has_uma_feature()) {
        clear_has_Feature();
        ::segmentation_platform::proto::UMAFeature* temp = _impl_.Feature_.uma_feature_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.Feature_.uma_feature_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::segmentation_platform::proto::UMAFeature& InputFeature::_internal_uma_feature() const
{
    return _internal_has_uma_feature()
        ? *_impl_.Feature_.uma_feature_
        : reinterpret_cast<::segmentation_platform::proto::UMAFeature&>(::segmentation_platform::proto::_UMAFeature_default_instance_);
}
inline const ::segmentation_platform::proto::UMAFeature& InputFeature::uma_feature() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.InputFeature.uma_feature)
    return _internal_uma_feature();
}
inline ::segmentation_platform::proto::UMAFeature* InputFeature::unsafe_arena_release_uma_feature()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:segmentation_platform.proto.InputFeature.uma_feature)
    if (_internal_has_uma_feature()) {
        clear_has_Feature();
        ::segmentation_platform::proto::UMAFeature* temp = _impl_.Feature_.uma_feature_;
        _impl_.Feature_.uma_feature_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void InputFeature::unsafe_arena_set_allocated_uma_feature(::segmentation_platform::proto::UMAFeature* uma_feature)
{
    clear_Feature();
    if (uma_feature) {
        set_has_uma_feature();
        _impl_.Feature_.uma_feature_ = uma_feature;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.InputFeature.uma_feature)
}
inline ::segmentation_platform::proto::UMAFeature* InputFeature::_internal_mutable_uma_feature()
{
    if (!_internal_has_uma_feature()) {
        clear_Feature();
        set_has_uma_feature();
        _impl_.Feature_.uma_feature_ = CreateMaybeMessage<::segmentation_platform::proto::UMAFeature>(GetArenaForAllocation());
    }
    return _impl_.Feature_.uma_feature_;
}
inline ::segmentation_platform::proto::UMAFeature* InputFeature::mutable_uma_feature()
{
    ::segmentation_platform::proto::UMAFeature* _msg = _internal_mutable_uma_feature();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.InputFeature.uma_feature)
    return _msg;
}

// .segmentation_platform.proto.CustomInput custom_input = 2;
inline bool InputFeature::_internal_has_custom_input() const
{
    return Feature_case() == kCustomInput;
}
inline bool InputFeature::has_custom_input() const
{
    return _internal_has_custom_input();
}
inline void InputFeature::set_has_custom_input()
{
    _impl_._oneof_case_[0] = kCustomInput;
}
inline void InputFeature::clear_custom_input()
{
    if (_internal_has_custom_input()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.Feature_.custom_input_;
        }
        clear_has_Feature();
    }
}
inline ::segmentation_platform::proto::CustomInput* InputFeature::release_custom_input()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.InputFeature.custom_input)
    if (_internal_has_custom_input()) {
        clear_has_Feature();
        ::segmentation_platform::proto::CustomInput* temp = _impl_.Feature_.custom_input_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.Feature_.custom_input_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::segmentation_platform::proto::CustomInput& InputFeature::_internal_custom_input() const
{
    return _internal_has_custom_input()
        ? *_impl_.Feature_.custom_input_
        : reinterpret_cast<::segmentation_platform::proto::CustomInput&>(::segmentation_platform::proto::_CustomInput_default_instance_);
}
inline const ::segmentation_platform::proto::CustomInput& InputFeature::custom_input() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.InputFeature.custom_input)
    return _internal_custom_input();
}
inline ::segmentation_platform::proto::CustomInput* InputFeature::unsafe_arena_release_custom_input()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:segmentation_platform.proto.InputFeature.custom_input)
    if (_internal_has_custom_input()) {
        clear_has_Feature();
        ::segmentation_platform::proto::CustomInput* temp = _impl_.Feature_.custom_input_;
        _impl_.Feature_.custom_input_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void InputFeature::unsafe_arena_set_allocated_custom_input(::segmentation_platform::proto::CustomInput* custom_input)
{
    clear_Feature();
    if (custom_input) {
        set_has_custom_input();
        _impl_.Feature_.custom_input_ = custom_input;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.InputFeature.custom_input)
}
inline ::segmentation_platform::proto::CustomInput* InputFeature::_internal_mutable_custom_input()
{
    if (!_internal_has_custom_input()) {
        clear_Feature();
        set_has_custom_input();
        _impl_.Feature_.custom_input_ = CreateMaybeMessage<::segmentation_platform::proto::CustomInput>(GetArenaForAllocation());
    }
    return _impl_.Feature_.custom_input_;
}
inline ::segmentation_platform::proto::CustomInput* InputFeature::mutable_custom_input()
{
    ::segmentation_platform::proto::CustomInput* _msg = _internal_mutable_custom_input();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.InputFeature.custom_input)
    return _msg;
}

// .segmentation_platform.proto.SqlFeature sql_feature = 3;
inline bool InputFeature::_internal_has_sql_feature() const
{
    return Feature_case() == kSqlFeature;
}
inline bool InputFeature::has_sql_feature() const
{
    return _internal_has_sql_feature();
}
inline void InputFeature::set_has_sql_feature()
{
    _impl_._oneof_case_[0] = kSqlFeature;
}
inline void InputFeature::clear_sql_feature()
{
    if (_internal_has_sql_feature()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.Feature_.sql_feature_;
        }
        clear_has_Feature();
    }
}
inline ::segmentation_platform::proto::SqlFeature* InputFeature::release_sql_feature()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.InputFeature.sql_feature)
    if (_internal_has_sql_feature()) {
        clear_has_Feature();
        ::segmentation_platform::proto::SqlFeature* temp = _impl_.Feature_.sql_feature_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.Feature_.sql_feature_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::segmentation_platform::proto::SqlFeature& InputFeature::_internal_sql_feature() const
{
    return _internal_has_sql_feature()
        ? *_impl_.Feature_.sql_feature_
        : reinterpret_cast<::segmentation_platform::proto::SqlFeature&>(::segmentation_platform::proto::_SqlFeature_default_instance_);
}
inline const ::segmentation_platform::proto::SqlFeature& InputFeature::sql_feature() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.InputFeature.sql_feature)
    return _internal_sql_feature();
}
inline ::segmentation_platform::proto::SqlFeature* InputFeature::unsafe_arena_release_sql_feature()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:segmentation_platform.proto.InputFeature.sql_feature)
    if (_internal_has_sql_feature()) {
        clear_has_Feature();
        ::segmentation_platform::proto::SqlFeature* temp = _impl_.Feature_.sql_feature_;
        _impl_.Feature_.sql_feature_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void InputFeature::unsafe_arena_set_allocated_sql_feature(::segmentation_platform::proto::SqlFeature* sql_feature)
{
    clear_Feature();
    if (sql_feature) {
        set_has_sql_feature();
        _impl_.Feature_.sql_feature_ = sql_feature;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.InputFeature.sql_feature)
}
inline ::segmentation_platform::proto::SqlFeature* InputFeature::_internal_mutable_sql_feature()
{
    if (!_internal_has_sql_feature()) {
        clear_Feature();
        set_has_sql_feature();
        _impl_.Feature_.sql_feature_ = CreateMaybeMessage<::segmentation_platform::proto::SqlFeature>(GetArenaForAllocation());
    }
    return _impl_.Feature_.sql_feature_;
}
inline ::segmentation_platform::proto::SqlFeature* InputFeature::mutable_sql_feature()
{
    ::segmentation_platform::proto::SqlFeature* _msg = _internal_mutable_sql_feature();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.InputFeature.sql_feature)
    return _msg;
}

inline bool InputFeature::has_Feature() const
{
    return Feature_case() != FEATURE_NOT_SET;
}
inline void InputFeature::clear_has_Feature()
{
    _impl_._oneof_case_[0] = FEATURE_NOT_SET;
}
inline InputFeature::FeatureCase InputFeature::Feature_case() const
{
    return InputFeature::FeatureCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TrainingOutputs_TriggerConfig_ObservationTrigger

// uint64 delay_sec = 1;
inline bool TrainingOutputs_TriggerConfig_ObservationTrigger::_internal_has_delay_sec() const
{
    return trigger_case() == kDelaySec;
}
inline bool TrainingOutputs_TriggerConfig_ObservationTrigger::has_delay_sec() const
{
    return _internal_has_delay_sec();
}
inline void TrainingOutputs_TriggerConfig_ObservationTrigger::set_has_delay_sec()
{
    _impl_._oneof_case_[0] = kDelaySec;
}
inline void TrainingOutputs_TriggerConfig_ObservationTrigger::clear_delay_sec()
{
    if (_internal_has_delay_sec()) {
        _impl_.trigger_.delay_sec_ = uint64_t { 0u };
        clear_has_trigger();
    }
}
inline uint64_t TrainingOutputs_TriggerConfig_ObservationTrigger::_internal_delay_sec() const
{
    if (_internal_has_delay_sec()) {
        return _impl_.trigger_.delay_sec_;
    }
    return uint64_t { 0u };
}
inline void TrainingOutputs_TriggerConfig_ObservationTrigger::_internal_set_delay_sec(uint64_t value)
{
    if (!_internal_has_delay_sec()) {
        clear_trigger();
        set_has_delay_sec();
    }
    _impl_.trigger_.delay_sec_ = value;
}
inline uint64_t TrainingOutputs_TriggerConfig_ObservationTrigger::delay_sec() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger.delay_sec)
    return _internal_delay_sec();
}
inline void TrainingOutputs_TriggerConfig_ObservationTrigger::set_delay_sec(uint64_t value)
{
    _internal_set_delay_sec(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger.delay_sec)
}

// .segmentation_platform.proto.UMAOutput uma_trigger = 2;
inline bool TrainingOutputs_TriggerConfig_ObservationTrigger::_internal_has_uma_trigger() const
{
    return trigger_case() == kUmaTrigger;
}
inline bool TrainingOutputs_TriggerConfig_ObservationTrigger::has_uma_trigger() const
{
    return _internal_has_uma_trigger();
}
inline void TrainingOutputs_TriggerConfig_ObservationTrigger::set_has_uma_trigger()
{
    _impl_._oneof_case_[0] = kUmaTrigger;
}
inline void TrainingOutputs_TriggerConfig_ObservationTrigger::clear_uma_trigger()
{
    if (_internal_has_uma_trigger()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.trigger_.uma_trigger_;
        }
        clear_has_trigger();
    }
}
inline ::segmentation_platform::proto::UMAOutput* TrainingOutputs_TriggerConfig_ObservationTrigger::release_uma_trigger()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger.uma_trigger)
    if (_internal_has_uma_trigger()) {
        clear_has_trigger();
        ::segmentation_platform::proto::UMAOutput* temp = _impl_.trigger_.uma_trigger_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.trigger_.uma_trigger_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::segmentation_platform::proto::UMAOutput& TrainingOutputs_TriggerConfig_ObservationTrigger::_internal_uma_trigger() const
{
    return _internal_has_uma_trigger()
        ? *_impl_.trigger_.uma_trigger_
        : reinterpret_cast<::segmentation_platform::proto::UMAOutput&>(::segmentation_platform::proto::_UMAOutput_default_instance_);
}
inline const ::segmentation_platform::proto::UMAOutput& TrainingOutputs_TriggerConfig_ObservationTrigger::uma_trigger() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger.uma_trigger)
    return _internal_uma_trigger();
}
inline ::segmentation_platform::proto::UMAOutput* TrainingOutputs_TriggerConfig_ObservationTrigger::unsafe_arena_release_uma_trigger()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger.uma_trigger)
    if (_internal_has_uma_trigger()) {
        clear_has_trigger();
        ::segmentation_platform::proto::UMAOutput* temp = _impl_.trigger_.uma_trigger_;
        _impl_.trigger_.uma_trigger_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void TrainingOutputs_TriggerConfig_ObservationTrigger::unsafe_arena_set_allocated_uma_trigger(::segmentation_platform::proto::UMAOutput* uma_trigger)
{
    clear_trigger();
    if (uma_trigger) {
        set_has_uma_trigger();
        _impl_.trigger_.uma_trigger_ = uma_trigger;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger.uma_trigger)
}
inline ::segmentation_platform::proto::UMAOutput* TrainingOutputs_TriggerConfig_ObservationTrigger::_internal_mutable_uma_trigger()
{
    if (!_internal_has_uma_trigger()) {
        clear_trigger();
        set_has_uma_trigger();
        _impl_.trigger_.uma_trigger_ = CreateMaybeMessage<::segmentation_platform::proto::UMAOutput>(GetArenaForAllocation());
    }
    return _impl_.trigger_.uma_trigger_;
}
inline ::segmentation_platform::proto::UMAOutput* TrainingOutputs_TriggerConfig_ObservationTrigger::mutable_uma_trigger()
{
    ::segmentation_platform::proto::UMAOutput* _msg = _internal_mutable_uma_trigger();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger.uma_trigger)
    return _msg;
}

inline bool TrainingOutputs_TriggerConfig_ObservationTrigger::has_trigger() const
{
    return trigger_case() != TRIGGER_NOT_SET;
}
inline void TrainingOutputs_TriggerConfig_ObservationTrigger::clear_has_trigger()
{
    _impl_._oneof_case_[0] = TRIGGER_NOT_SET;
}
inline TrainingOutputs_TriggerConfig_ObservationTrigger::TriggerCase TrainingOutputs_TriggerConfig_ObservationTrigger::trigger_case() const
{
    return TrainingOutputs_TriggerConfig_ObservationTrigger::TriggerCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TrainingOutputs_TriggerConfig

// optional .segmentation_platform.proto.TrainingOutputs.TriggerConfig.DecisionType decision_type = 1;
inline bool TrainingOutputs_TriggerConfig::_internal_has_decision_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool TrainingOutputs_TriggerConfig::has_decision_type() const
{
    return _internal_has_decision_type();
}
inline void TrainingOutputs_TriggerConfig::clear_decision_type()
{
    _impl_.decision_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_DecisionType TrainingOutputs_TriggerConfig::_internal_decision_type() const
{
    return static_cast<::segmentation_platform::proto::TrainingOutputs_TriggerConfig_DecisionType>(_impl_.decision_type_);
}
inline ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_DecisionType TrainingOutputs_TriggerConfig::decision_type() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.TrainingOutputs.TriggerConfig.decision_type)
    return _internal_decision_type();
}
inline void TrainingOutputs_TriggerConfig::_internal_set_decision_type(::segmentation_platform::proto::TrainingOutputs_TriggerConfig_DecisionType value)
{
    assert(::segmentation_platform::proto::TrainingOutputs_TriggerConfig_DecisionType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.decision_type_ = value;
}
inline void TrainingOutputs_TriggerConfig::set_decision_type(::segmentation_platform::proto::TrainingOutputs_TriggerConfig_DecisionType value)
{
    _internal_set_decision_type(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.TrainingOutputs.TriggerConfig.decision_type)
}

// repeated .segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger observation_trigger = 2;
inline int TrainingOutputs_TriggerConfig::_internal_observation_trigger_size() const
{
    return _impl_.observation_trigger_.size();
}
inline int TrainingOutputs_TriggerConfig::observation_trigger_size() const
{
    return _internal_observation_trigger_size();
}
inline void TrainingOutputs_TriggerConfig::clear_observation_trigger()
{
    _impl_.observation_trigger_.Clear();
}
inline ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger* TrainingOutputs_TriggerConfig::mutable_observation_trigger(int index)
{
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.TrainingOutputs.TriggerConfig.observation_trigger)
    return _impl_.observation_trigger_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger>*
TrainingOutputs_TriggerConfig::mutable_observation_trigger()
{
    // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.TrainingOutputs.TriggerConfig.observation_trigger)
    return &_impl_.observation_trigger_;
}
inline const ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger& TrainingOutputs_TriggerConfig::_internal_observation_trigger(
    int index) const
{
    return _impl_.observation_trigger_.Get(index);
}
inline const ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger& TrainingOutputs_TriggerConfig::observation_trigger(
    int index) const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.TrainingOutputs.TriggerConfig.observation_trigger)
    return _internal_observation_trigger(index);
}
inline ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger* TrainingOutputs_TriggerConfig::_internal_add_observation_trigger()
{
    return _impl_.observation_trigger_.Add();
}
inline ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger* TrainingOutputs_TriggerConfig::add_observation_trigger()
{
    ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger* _add = _internal_add_observation_trigger();
    // @@protoc_insertion_point(field_add:segmentation_platform.proto.TrainingOutputs.TriggerConfig.observation_trigger)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger>&
TrainingOutputs_TriggerConfig::observation_trigger() const
{
    // @@protoc_insertion_point(field_list:segmentation_platform.proto.TrainingOutputs.TriggerConfig.observation_trigger)
    return _impl_.observation_trigger_;
}

// optional bool use_exact_prediction_time = 3;
inline bool TrainingOutputs_TriggerConfig::_internal_has_use_exact_prediction_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool TrainingOutputs_TriggerConfig::has_use_exact_prediction_time() const
{
    return _internal_has_use_exact_prediction_time();
}
inline void TrainingOutputs_TriggerConfig::clear_use_exact_prediction_time()
{
    _impl_.use_exact_prediction_time_ = false;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool TrainingOutputs_TriggerConfig::_internal_use_exact_prediction_time() const
{
    return _impl_.use_exact_prediction_time_;
}
inline bool TrainingOutputs_TriggerConfig::use_exact_prediction_time() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.TrainingOutputs.TriggerConfig.use_exact_prediction_time)
    return _internal_use_exact_prediction_time();
}
inline void TrainingOutputs_TriggerConfig::_internal_set_use_exact_prediction_time(bool value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.use_exact_prediction_time_ = value;
}
inline void TrainingOutputs_TriggerConfig::set_use_exact_prediction_time(bool value)
{
    _internal_set_use_exact_prediction_time(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.TrainingOutputs.TriggerConfig.use_exact_prediction_time)
}

// optional bool use_flexible_observation_time = 4;
inline bool TrainingOutputs_TriggerConfig::_internal_has_use_flexible_observation_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool TrainingOutputs_TriggerConfig::has_use_flexible_observation_time() const
{
    return _internal_has_use_flexible_observation_time();
}
inline void TrainingOutputs_TriggerConfig::clear_use_flexible_observation_time()
{
    _impl_.use_flexible_observation_time_ = false;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool TrainingOutputs_TriggerConfig::_internal_use_flexible_observation_time() const
{
    return _impl_.use_flexible_observation_time_;
}
inline bool TrainingOutputs_TriggerConfig::use_flexible_observation_time() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.TrainingOutputs.TriggerConfig.use_flexible_observation_time)
    return _internal_use_flexible_observation_time();
}
inline void TrainingOutputs_TriggerConfig::_internal_set_use_flexible_observation_time(bool value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.use_flexible_observation_time_ = value;
}
inline void TrainingOutputs_TriggerConfig::set_use_flexible_observation_time(bool value)
{
    _internal_set_use_flexible_observation_time(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.TrainingOutputs.TriggerConfig.use_flexible_observation_time)
}

// -------------------------------------------------------------------

// TrainingOutputs

// repeated .segmentation_platform.proto.TrainingOutput outputs = 1;
inline int TrainingOutputs::_internal_outputs_size() const
{
    return _impl_.outputs_.size();
}
inline int TrainingOutputs::outputs_size() const
{
    return _internal_outputs_size();
}
inline void TrainingOutputs::clear_outputs()
{
    _impl_.outputs_.Clear();
}
inline ::segmentation_platform::proto::TrainingOutput* TrainingOutputs::mutable_outputs(int index)
{
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.TrainingOutputs.outputs)
    return _impl_.outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::TrainingOutput>* TrainingOutputs::mutable_outputs()
{
    // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.TrainingOutputs.outputs)
    return &_impl_.outputs_;
}
inline const ::segmentation_platform::proto::TrainingOutput& TrainingOutputs::_internal_outputs(int index) const
{
    return _impl_.outputs_.Get(index);
}
inline const ::segmentation_platform::proto::TrainingOutput& TrainingOutputs::outputs(int index) const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.TrainingOutputs.outputs)
    return _internal_outputs(index);
}
inline ::segmentation_platform::proto::TrainingOutput* TrainingOutputs::_internal_add_outputs()
{
    return _impl_.outputs_.Add();
}
inline ::segmentation_platform::proto::TrainingOutput* TrainingOutputs::add_outputs()
{
    ::segmentation_platform::proto::TrainingOutput* _add = _internal_add_outputs();
    // @@protoc_insertion_point(field_add:segmentation_platform.proto.TrainingOutputs.outputs)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::TrainingOutput>& TrainingOutputs::outputs() const
{
    // @@protoc_insertion_point(field_list:segmentation_platform.proto.TrainingOutputs.outputs)
    return _impl_.outputs_;
}

// optional .segmentation_platform.proto.TrainingOutputs.TriggerConfig trigger_config = 2;
inline bool TrainingOutputs::_internal_has_trigger_config() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.trigger_config_ != nullptr);
    return value;
}
inline bool TrainingOutputs::has_trigger_config() const
{
    return _internal_has_trigger_config();
}
inline void TrainingOutputs::clear_trigger_config()
{
    if (_impl_.trigger_config_ != nullptr)
        _impl_.trigger_config_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::segmentation_platform::proto::TrainingOutputs_TriggerConfig& TrainingOutputs::_internal_trigger_config() const
{
    const ::segmentation_platform::proto::TrainingOutputs_TriggerConfig* p = _impl_.trigger_config_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::segmentation_platform::proto::TrainingOutputs_TriggerConfig&>(
                            ::segmentation_platform::proto::_TrainingOutputs_TriggerConfig_default_instance_);
}
inline const ::segmentation_platform::proto::TrainingOutputs_TriggerConfig& TrainingOutputs::trigger_config() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.TrainingOutputs.trigger_config)
    return _internal_trigger_config();
}
inline void TrainingOutputs::unsafe_arena_set_allocated_trigger_config(::segmentation_platform::proto::TrainingOutputs_TriggerConfig* trigger_config)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trigger_config_);
    }
    _impl_.trigger_config_ = trigger_config;
    if (trigger_config) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.TrainingOutputs.trigger_config)
}
inline ::segmentation_platform::proto::TrainingOutputs_TriggerConfig* TrainingOutputs::release_trigger_config()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::segmentation_platform::proto::TrainingOutputs_TriggerConfig* temp = _impl_.trigger_config_;
    _impl_.trigger_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::segmentation_platform::proto::TrainingOutputs_TriggerConfig* TrainingOutputs::unsafe_arena_release_trigger_config()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.TrainingOutputs.trigger_config)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::segmentation_platform::proto::TrainingOutputs_TriggerConfig* temp = _impl_.trigger_config_;
    _impl_.trigger_config_ = nullptr;
    return temp;
}
inline ::segmentation_platform::proto::TrainingOutputs_TriggerConfig* TrainingOutputs::_internal_mutable_trigger_config()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.trigger_config_ == nullptr) {
        auto* p = CreateMaybeMessage<::segmentation_platform::proto::TrainingOutputs_TriggerConfig>(GetArenaForAllocation());
        _impl_.trigger_config_ = p;
    }
    return _impl_.trigger_config_;
}
inline ::segmentation_platform::proto::TrainingOutputs_TriggerConfig* TrainingOutputs::mutable_trigger_config()
{
    ::segmentation_platform::proto::TrainingOutputs_TriggerConfig* _msg = _internal_mutable_trigger_config();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.TrainingOutputs.trigger_config)
    return _msg;
}
inline void TrainingOutputs::set_allocated_trigger_config(::segmentation_platform::proto::TrainingOutputs_TriggerConfig* trigger_config)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.trigger_config_;
    }
    if (trigger_config) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trigger_config);
        if (message_arena != submessage_arena) {
            trigger_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, trigger_config, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.trigger_config_ = trigger_config;
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.TrainingOutputs.trigger_config)
}

// -------------------------------------------------------------------

// TrainingOutput

// .segmentation_platform.proto.UMAOutput uma_output = 1;
inline bool TrainingOutput::_internal_has_uma_output() const
{
    return output_case() == kUmaOutput;
}
inline bool TrainingOutput::has_uma_output() const
{
    return _internal_has_uma_output();
}
inline void TrainingOutput::set_has_uma_output()
{
    _impl_._oneof_case_[0] = kUmaOutput;
}
inline void TrainingOutput::clear_uma_output()
{
    if (_internal_has_uma_output()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.output_.uma_output_;
        }
        clear_has_output();
    }
}
inline ::segmentation_platform::proto::UMAOutput* TrainingOutput::release_uma_output()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.TrainingOutput.uma_output)
    if (_internal_has_uma_output()) {
        clear_has_output();
        ::segmentation_platform::proto::UMAOutput* temp = _impl_.output_.uma_output_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.output_.uma_output_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::segmentation_platform::proto::UMAOutput& TrainingOutput::_internal_uma_output() const
{
    return _internal_has_uma_output()
        ? *_impl_.output_.uma_output_
        : reinterpret_cast<::segmentation_platform::proto::UMAOutput&>(::segmentation_platform::proto::_UMAOutput_default_instance_);
}
inline const ::segmentation_platform::proto::UMAOutput& TrainingOutput::uma_output() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.TrainingOutput.uma_output)
    return _internal_uma_output();
}
inline ::segmentation_platform::proto::UMAOutput* TrainingOutput::unsafe_arena_release_uma_output()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:segmentation_platform.proto.TrainingOutput.uma_output)
    if (_internal_has_uma_output()) {
        clear_has_output();
        ::segmentation_platform::proto::UMAOutput* temp = _impl_.output_.uma_output_;
        _impl_.output_.uma_output_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void TrainingOutput::unsafe_arena_set_allocated_uma_output(::segmentation_platform::proto::UMAOutput* uma_output)
{
    clear_output();
    if (uma_output) {
        set_has_uma_output();
        _impl_.output_.uma_output_ = uma_output;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.TrainingOutput.uma_output)
}
inline ::segmentation_platform::proto::UMAOutput* TrainingOutput::_internal_mutable_uma_output()
{
    if (!_internal_has_uma_output()) {
        clear_output();
        set_has_uma_output();
        _impl_.output_.uma_output_ = CreateMaybeMessage<::segmentation_platform::proto::UMAOutput>(GetArenaForAllocation());
    }
    return _impl_.output_.uma_output_;
}
inline ::segmentation_platform::proto::UMAOutput* TrainingOutput::mutable_uma_output()
{
    ::segmentation_platform::proto::UMAOutput* _msg = _internal_mutable_uma_output();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.TrainingOutput.uma_output)
    return _msg;
}

inline bool TrainingOutput::has_output() const
{
    return output_case() != OUTPUT_NOT_SET;
}
inline void TrainingOutput::clear_has_output()
{
    _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}
inline TrainingOutput::OutputCase TrainingOutput::output_case() const
{
    return TrainingOutput::OutputCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UMAOutput

// optional .segmentation_platform.proto.UMAFeature uma_feature = 1;
inline bool UMAOutput::_internal_has_uma_feature() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.uma_feature_ != nullptr);
    return value;
}
inline bool UMAOutput::has_uma_feature() const
{
    return _internal_has_uma_feature();
}
inline void UMAOutput::clear_uma_feature()
{
    if (_impl_.uma_feature_ != nullptr)
        _impl_.uma_feature_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::segmentation_platform::proto::UMAFeature& UMAOutput::_internal_uma_feature() const
{
    const ::segmentation_platform::proto::UMAFeature* p = _impl_.uma_feature_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::segmentation_platform::proto::UMAFeature&>(::segmentation_platform::proto::_UMAFeature_default_instance_);
}
inline const ::segmentation_platform::proto::UMAFeature& UMAOutput::uma_feature() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAOutput.uma_feature)
    return _internal_uma_feature();
}
inline void UMAOutput::unsafe_arena_set_allocated_uma_feature(::segmentation_platform::proto::UMAFeature* uma_feature)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uma_feature_);
    }
    _impl_.uma_feature_ = uma_feature;
    if (uma_feature) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.UMAOutput.uma_feature)
}
inline ::segmentation_platform::proto::UMAFeature* UMAOutput::release_uma_feature()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::segmentation_platform::proto::UMAFeature* temp = _impl_.uma_feature_;
    _impl_.uma_feature_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::segmentation_platform::proto::UMAFeature* UMAOutput::unsafe_arena_release_uma_feature()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.UMAOutput.uma_feature)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::segmentation_platform::proto::UMAFeature* temp = _impl_.uma_feature_;
    _impl_.uma_feature_ = nullptr;
    return temp;
}
inline ::segmentation_platform::proto::UMAFeature* UMAOutput::_internal_mutable_uma_feature()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.uma_feature_ == nullptr) {
        auto* p = CreateMaybeMessage<::segmentation_platform::proto::UMAFeature>(GetArenaForAllocation());
        _impl_.uma_feature_ = p;
    }
    return _impl_.uma_feature_;
}
inline ::segmentation_platform::proto::UMAFeature* UMAOutput::mutable_uma_feature()
{
    ::segmentation_platform::proto::UMAFeature* _msg = _internal_mutable_uma_feature();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.UMAOutput.uma_feature)
    return _msg;
}
inline void UMAOutput::set_allocated_uma_feature(::segmentation_platform::proto::UMAFeature* uma_feature)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.uma_feature_;
    }
    if (uma_feature) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uma_feature);
        if (message_arena != submessage_arena) {
            uma_feature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, uma_feature, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.uma_feature_ = uma_feature;
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.UMAOutput.uma_feature)
}

// optional uint64 duration = 2;
inline bool UMAOutput::_internal_has_duration() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool UMAOutput::has_duration() const
{
    return _internal_has_duration();
}
inline void UMAOutput::clear_duration()
{
    _impl_.duration_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t UMAOutput::_internal_duration() const
{
    return _impl_.duration_;
}
inline uint64_t UMAOutput::duration() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.UMAOutput.duration)
    return _internal_duration();
}
inline void UMAOutput::_internal_set_duration(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.duration_ = value;
}
inline void UMAOutput::set_duration(uint64_t value)
{
    _internal_set_duration(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.UMAOutput.duration)
}

// -------------------------------------------------------------------

// SegmentationModelMetadata_DiscreteMapping_Entry

// optional float min_result = 1;
inline bool SegmentationModelMetadata_DiscreteMapping_Entry::_internal_has_min_result() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool SegmentationModelMetadata_DiscreteMapping_Entry::has_min_result() const
{
    return _internal_has_min_result();
}
inline void SegmentationModelMetadata_DiscreteMapping_Entry::clear_min_result()
{
    _impl_.min_result_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SegmentationModelMetadata_DiscreteMapping_Entry::_internal_min_result() const
{
    return _impl_.min_result_;
}
inline float SegmentationModelMetadata_DiscreteMapping_Entry::min_result() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry.min_result)
    return _internal_min_result();
}
inline void SegmentationModelMetadata_DiscreteMapping_Entry::_internal_set_min_result(float value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.min_result_ = value;
}
inline void SegmentationModelMetadata_DiscreteMapping_Entry::set_min_result(float value)
{
    _internal_set_min_result(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry.min_result)
}

// optional int64 rank = 2;
inline bool SegmentationModelMetadata_DiscreteMapping_Entry::_internal_has_rank() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SegmentationModelMetadata_DiscreteMapping_Entry::has_rank() const
{
    return _internal_has_rank();
}
inline void SegmentationModelMetadata_DiscreteMapping_Entry::clear_rank()
{
    _impl_.rank_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t SegmentationModelMetadata_DiscreteMapping_Entry::_internal_rank() const
{
    return _impl_.rank_;
}
inline int64_t SegmentationModelMetadata_DiscreteMapping_Entry::rank() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry.rank)
    return _internal_rank();
}
inline void SegmentationModelMetadata_DiscreteMapping_Entry::_internal_set_rank(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.rank_ = value;
}
inline void SegmentationModelMetadata_DiscreteMapping_Entry::set_rank(int64_t value)
{
    _internal_set_rank(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry.rank)
}

// -------------------------------------------------------------------

// SegmentationModelMetadata_DiscreteMapping

// repeated .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry entries = 1;
inline int SegmentationModelMetadata_DiscreteMapping::_internal_entries_size() const
{
    return _impl_.entries_.size();
}
inline int SegmentationModelMetadata_DiscreteMapping::entries_size() const
{
    return _internal_entries_size();
}
inline void SegmentationModelMetadata_DiscreteMapping::clear_entries()
{
    _impl_.entries_.Clear();
}
inline ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* SegmentationModelMetadata_DiscreteMapping::mutable_entries(int index)
{
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.entries)
    return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry>*
SegmentationModelMetadata_DiscreteMapping::mutable_entries()
{
    // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.entries)
    return &_impl_.entries_;
}
inline const ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry& SegmentationModelMetadata_DiscreteMapping::_internal_entries(
    int index) const
{
    return _impl_.entries_.Get(index);
}
inline const ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry& SegmentationModelMetadata_DiscreteMapping::entries(
    int index) const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.entries)
    return _internal_entries(index);
}
inline ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* SegmentationModelMetadata_DiscreteMapping::_internal_add_entries()
{
    return _impl_.entries_.Add();
}
inline ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* SegmentationModelMetadata_DiscreteMapping::add_entries()
{
    ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry* _add = _internal_add_entries();
    // @@protoc_insertion_point(field_add:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.entries)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry>&
SegmentationModelMetadata_DiscreteMapping::entries() const
{
    // @@protoc_insertion_point(field_list:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.entries)
    return _impl_.entries_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SegmentationModelMetadata

// optional .segmentation_platform.proto.VersionInfo version_info = 9;
inline bool SegmentationModelMetadata::_internal_has_version_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.version_info_ != nullptr);
    return value;
}
inline bool SegmentationModelMetadata::has_version_info() const
{
    return _internal_has_version_info();
}
inline void SegmentationModelMetadata::clear_version_info()
{
    if (_impl_.version_info_ != nullptr)
        _impl_.version_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::segmentation_platform::proto::VersionInfo& SegmentationModelMetadata::_internal_version_info() const
{
    const ::segmentation_platform::proto::VersionInfo* p = _impl_.version_info_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::segmentation_platform::proto::VersionInfo&>(::segmentation_platform::proto::_VersionInfo_default_instance_);
}
inline const ::segmentation_platform::proto::VersionInfo& SegmentationModelMetadata::version_info() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.version_info)
    return _internal_version_info();
}
inline void SegmentationModelMetadata::unsafe_arena_set_allocated_version_info(::segmentation_platform::proto::VersionInfo* version_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_info_);
    }
    _impl_.version_info_ = version_info;
    if (version_info) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.SegmentationModelMetadata.version_info)
}
inline ::segmentation_platform::proto::VersionInfo* SegmentationModelMetadata::release_version_info()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::segmentation_platform::proto::VersionInfo* temp = _impl_.version_info_;
    _impl_.version_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::segmentation_platform::proto::VersionInfo* SegmentationModelMetadata::unsafe_arena_release_version_info()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.SegmentationModelMetadata.version_info)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::segmentation_platform::proto::VersionInfo* temp = _impl_.version_info_;
    _impl_.version_info_ = nullptr;
    return temp;
}
inline ::segmentation_platform::proto::VersionInfo* SegmentationModelMetadata::_internal_mutable_version_info()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.version_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::segmentation_platform::proto::VersionInfo>(GetArenaForAllocation());
        _impl_.version_info_ = p;
    }
    return _impl_.version_info_;
}
inline ::segmentation_platform::proto::VersionInfo* SegmentationModelMetadata::mutable_version_info()
{
    ::segmentation_platform::proto::VersionInfo* _msg = _internal_mutable_version_info();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SegmentationModelMetadata.version_info)
    return _msg;
}
inline void SegmentationModelMetadata::set_allocated_version_info(::segmentation_platform::proto::VersionInfo* version_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.version_info_;
    }
    if (version_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(version_info);
        if (message_arena != submessage_arena) {
            version_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, version_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.version_info_ = version_info;
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SegmentationModelMetadata.version_info)
}

// repeated .segmentation_platform.proto.UMAFeature features = 1;
inline int SegmentationModelMetadata::_internal_features_size() const
{
    return _impl_.features_.size();
}
inline int SegmentationModelMetadata::features_size() const
{
    return _internal_features_size();
}
inline void SegmentationModelMetadata::clear_features()
{
    _impl_.features_.Clear();
}
inline ::segmentation_platform::proto::UMAFeature* SegmentationModelMetadata::mutable_features(int index)
{
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SegmentationModelMetadata.features)
    return _impl_.features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::UMAFeature>* SegmentationModelMetadata::mutable_features()
{
    // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.SegmentationModelMetadata.features)
    return &_impl_.features_;
}
inline const ::segmentation_platform::proto::UMAFeature& SegmentationModelMetadata::_internal_features(int index) const
{
    return _impl_.features_.Get(index);
}
inline const ::segmentation_platform::proto::UMAFeature& SegmentationModelMetadata::features(int index) const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.features)
    return _internal_features(index);
}
inline ::segmentation_platform::proto::UMAFeature* SegmentationModelMetadata::_internal_add_features()
{
    return _impl_.features_.Add();
}
inline ::segmentation_platform::proto::UMAFeature* SegmentationModelMetadata::add_features()
{
    ::segmentation_platform::proto::UMAFeature* _add = _internal_add_features();
    // @@protoc_insertion_point(field_add:segmentation_platform.proto.SegmentationModelMetadata.features)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::UMAFeature>& SegmentationModelMetadata::features() const
{
    // @@protoc_insertion_point(field_list:segmentation_platform.proto.SegmentationModelMetadata.features)
    return _impl_.features_;
}

// repeated .segmentation_platform.proto.InputFeature input_features = 10;
inline int SegmentationModelMetadata::_internal_input_features_size() const
{
    return _impl_.input_features_.size();
}
inline int SegmentationModelMetadata::input_features_size() const
{
    return _internal_input_features_size();
}
inline void SegmentationModelMetadata::clear_input_features()
{
    _impl_.input_features_.Clear();
}
inline ::segmentation_platform::proto::InputFeature* SegmentationModelMetadata::mutable_input_features(int index)
{
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SegmentationModelMetadata.input_features)
    return _impl_.input_features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::InputFeature>* SegmentationModelMetadata::mutable_input_features()
{
    // @@protoc_insertion_point(field_mutable_list:segmentation_platform.proto.SegmentationModelMetadata.input_features)
    return &_impl_.input_features_;
}
inline const ::segmentation_platform::proto::InputFeature& SegmentationModelMetadata::_internal_input_features(int index) const
{
    return _impl_.input_features_.Get(index);
}
inline const ::segmentation_platform::proto::InputFeature& SegmentationModelMetadata::input_features(int index) const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.input_features)
    return _internal_input_features(index);
}
inline ::segmentation_platform::proto::InputFeature* SegmentationModelMetadata::_internal_add_input_features()
{
    return _impl_.input_features_.Add();
}
inline ::segmentation_platform::proto::InputFeature* SegmentationModelMetadata::add_input_features()
{
    ::segmentation_platform::proto::InputFeature* _add = _internal_add_input_features();
    // @@protoc_insertion_point(field_add:segmentation_platform.proto.SegmentationModelMetadata.input_features)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::segmentation_platform::proto::InputFeature>& SegmentationModelMetadata::input_features() const
{
    // @@protoc_insertion_point(field_list:segmentation_platform.proto.SegmentationModelMetadata.input_features)
    return _impl_.input_features_;
}

// optional .segmentation_platform.proto.TrainingOutputs training_outputs = 11;
inline bool SegmentationModelMetadata::_internal_has_training_outputs() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.training_outputs_ != nullptr);
    return value;
}
inline bool SegmentationModelMetadata::has_training_outputs() const
{
    return _internal_has_training_outputs();
}
inline void SegmentationModelMetadata::clear_training_outputs()
{
    if (_impl_.training_outputs_ != nullptr)
        _impl_.training_outputs_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::segmentation_platform::proto::TrainingOutputs& SegmentationModelMetadata::_internal_training_outputs() const
{
    const ::segmentation_platform::proto::TrainingOutputs* p = _impl_.training_outputs_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::segmentation_platform::proto::TrainingOutputs&>(::segmentation_platform::proto::_TrainingOutputs_default_instance_);
}
inline const ::segmentation_platform::proto::TrainingOutputs& SegmentationModelMetadata::training_outputs() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.training_outputs)
    return _internal_training_outputs();
}
inline void SegmentationModelMetadata::unsafe_arena_set_allocated_training_outputs(::segmentation_platform::proto::TrainingOutputs* training_outputs)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.training_outputs_);
    }
    _impl_.training_outputs_ = training_outputs;
    if (training_outputs) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.SegmentationModelMetadata.training_outputs)
}
inline ::segmentation_platform::proto::TrainingOutputs* SegmentationModelMetadata::release_training_outputs()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::segmentation_platform::proto::TrainingOutputs* temp = _impl_.training_outputs_;
    _impl_.training_outputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::segmentation_platform::proto::TrainingOutputs* SegmentationModelMetadata::unsafe_arena_release_training_outputs()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.SegmentationModelMetadata.training_outputs)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::segmentation_platform::proto::TrainingOutputs* temp = _impl_.training_outputs_;
    _impl_.training_outputs_ = nullptr;
    return temp;
}
inline ::segmentation_platform::proto::TrainingOutputs* SegmentationModelMetadata::_internal_mutable_training_outputs()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.training_outputs_ == nullptr) {
        auto* p = CreateMaybeMessage<::segmentation_platform::proto::TrainingOutputs>(GetArenaForAllocation());
        _impl_.training_outputs_ = p;
    }
    return _impl_.training_outputs_;
}
inline ::segmentation_platform::proto::TrainingOutputs* SegmentationModelMetadata::mutable_training_outputs()
{
    ::segmentation_platform::proto::TrainingOutputs* _msg = _internal_mutable_training_outputs();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SegmentationModelMetadata.training_outputs)
    return _msg;
}
inline void SegmentationModelMetadata::set_allocated_training_outputs(::segmentation_platform::proto::TrainingOutputs* training_outputs)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.training_outputs_;
    }
    if (training_outputs) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(training_outputs);
        if (message_arena != submessage_arena) {
            training_outputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, training_outputs, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.training_outputs_ = training_outputs;
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SegmentationModelMetadata.training_outputs)
}

// optional .segmentation_platform.proto.TimeUnit time_unit = 2;
inline bool SegmentationModelMetadata::_internal_has_time_unit() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool SegmentationModelMetadata::has_time_unit() const
{
    return _internal_has_time_unit();
}
inline void SegmentationModelMetadata::clear_time_unit()
{
    _impl_.time_unit_ = 0;
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::segmentation_platform::proto::TimeUnit SegmentationModelMetadata::_internal_time_unit() const
{
    return static_cast<::segmentation_platform::proto::TimeUnit>(_impl_.time_unit_);
}
inline ::segmentation_platform::proto::TimeUnit SegmentationModelMetadata::time_unit() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.time_unit)
    return _internal_time_unit();
}
inline void SegmentationModelMetadata::_internal_set_time_unit(::segmentation_platform::proto::TimeUnit value)
{
    assert(::segmentation_platform::proto::TimeUnit_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.time_unit_ = value;
}
inline void SegmentationModelMetadata::set_time_unit(::segmentation_platform::proto::TimeUnit value)
{
    _internal_set_time_unit(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.time_unit)
}

// optional uint64 bucket_duration = 3;
inline bool SegmentationModelMetadata::_internal_has_bucket_duration() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool SegmentationModelMetadata::has_bucket_duration() const
{
    return _internal_has_bucket_duration();
}
inline void SegmentationModelMetadata::clear_bucket_duration()
{
    _impl_.bucket_duration_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t SegmentationModelMetadata::_internal_bucket_duration() const
{
    return _impl_.bucket_duration_;
}
inline uint64_t SegmentationModelMetadata::bucket_duration() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.bucket_duration)
    return _internal_bucket_duration();
}
inline void SegmentationModelMetadata::_internal_set_bucket_duration(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.bucket_duration_ = value;
}
inline void SegmentationModelMetadata::set_bucket_duration(uint64_t value)
{
    _internal_set_bucket_duration(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.bucket_duration)
}

// optional int64 signal_storage_length = 4;
inline bool SegmentationModelMetadata::_internal_has_signal_storage_length() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool SegmentationModelMetadata::has_signal_storage_length() const
{
    return _internal_has_signal_storage_length();
}
inline void SegmentationModelMetadata::clear_signal_storage_length()
{
    _impl_.signal_storage_length_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t SegmentationModelMetadata::_internal_signal_storage_length() const
{
    return _impl_.signal_storage_length_;
}
inline int64_t SegmentationModelMetadata::signal_storage_length() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.signal_storage_length)
    return _internal_signal_storage_length();
}
inline void SegmentationModelMetadata::_internal_set_signal_storage_length(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.signal_storage_length_ = value;
}
inline void SegmentationModelMetadata::set_signal_storage_length(int64_t value)
{
    _internal_set_signal_storage_length(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.signal_storage_length)
}

// optional int64 min_signal_collection_length = 5;
inline bool SegmentationModelMetadata::_internal_has_min_signal_collection_length() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool SegmentationModelMetadata::has_min_signal_collection_length() const
{
    return _internal_has_min_signal_collection_length();
}
inline void SegmentationModelMetadata::clear_min_signal_collection_length()
{
    _impl_.min_signal_collection_length_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t SegmentationModelMetadata::_internal_min_signal_collection_length() const
{
    return _impl_.min_signal_collection_length_;
}
inline int64_t SegmentationModelMetadata::min_signal_collection_length() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.min_signal_collection_length)
    return _internal_min_signal_collection_length();
}
inline void SegmentationModelMetadata::_internal_set_min_signal_collection_length(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.min_signal_collection_length_ = value;
}
inline void SegmentationModelMetadata::set_min_signal_collection_length(int64_t value)
{
    _internal_set_min_signal_collection_length(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.min_signal_collection_length)
}

// optional int64 result_time_to_live = 6;
inline bool SegmentationModelMetadata::_internal_has_result_time_to_live() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool SegmentationModelMetadata::has_result_time_to_live() const
{
    return _internal_has_result_time_to_live();
}
inline void SegmentationModelMetadata::clear_result_time_to_live()
{
    _impl_.result_time_to_live_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t SegmentationModelMetadata::_internal_result_time_to_live() const
{
    return _impl_.result_time_to_live_;
}
inline int64_t SegmentationModelMetadata::result_time_to_live() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.result_time_to_live)
    return _internal_result_time_to_live();
}
inline void SegmentationModelMetadata::_internal_set_result_time_to_live(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.result_time_to_live_ = value;
}
inline void SegmentationModelMetadata::set_result_time_to_live(int64_t value)
{
    _internal_set_result_time_to_live(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.result_time_to_live)
}

// optional int64 fixed_prediction_timestamp = 17;
inline bool SegmentationModelMetadata::_internal_has_fixed_prediction_timestamp() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    return value;
}
inline bool SegmentationModelMetadata::has_fixed_prediction_timestamp() const
{
    return _internal_has_fixed_prediction_timestamp();
}
inline void SegmentationModelMetadata::clear_fixed_prediction_timestamp()
{
    _impl_.fixed_prediction_timestamp_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t SegmentationModelMetadata::_internal_fixed_prediction_timestamp() const
{
    return _impl_.fixed_prediction_timestamp_;
}
inline int64_t SegmentationModelMetadata::fixed_prediction_timestamp() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.fixed_prediction_timestamp)
    return _internal_fixed_prediction_timestamp();
}
inline void SegmentationModelMetadata::_internal_set_fixed_prediction_timestamp(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000400u;
    _impl_.fixed_prediction_timestamp_ = value;
}
inline void SegmentationModelMetadata::set_fixed_prediction_timestamp(int64_t value)
{
    _internal_set_fixed_prediction_timestamp(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.fixed_prediction_timestamp)
}

// map<string, .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping> discrete_mappings = 7;
inline int SegmentationModelMetadata::_internal_discrete_mappings_size() const
{
    return _impl_.discrete_mappings_.size();
}
inline int SegmentationModelMetadata::discrete_mappings_size() const
{
    return _internal_discrete_mappings_size();
}
inline void SegmentationModelMetadata::clear_discrete_mappings()
{
    _impl_.discrete_mappings_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>&
SegmentationModelMetadata::_internal_discrete_mappings() const
{
    return _impl_.discrete_mappings_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>&
SegmentationModelMetadata::discrete_mappings() const
{
    // @@protoc_insertion_point(field_map:segmentation_platform.proto.SegmentationModelMetadata.discrete_mappings)
    return _internal_discrete_mappings();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>*
SegmentationModelMetadata::_internal_mutable_discrete_mappings()
{
    return _impl_.discrete_mappings_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>*
SegmentationModelMetadata::mutable_discrete_mappings()
{
    // @@protoc_insertion_point(field_mutable_map:segmentation_platform.proto.SegmentationModelMetadata.discrete_mappings)
    return _internal_mutable_discrete_mappings();
}

// optional string default_discrete_mapping = 8;
inline bool SegmentationModelMetadata::_internal_has_default_discrete_mapping() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SegmentationModelMetadata::has_default_discrete_mapping() const
{
    return _internal_has_default_discrete_mapping();
}
inline void SegmentationModelMetadata::clear_default_discrete_mapping()
{
    _impl_.default_discrete_mapping_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SegmentationModelMetadata::default_discrete_mapping() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.default_discrete_mapping)
    return _internal_default_discrete_mapping();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void SegmentationModelMetadata::set_default_discrete_mapping(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.default_discrete_mapping_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.default_discrete_mapping)
}
inline std::string* SegmentationModelMetadata::mutable_default_discrete_mapping()
{
    std::string* _s = _internal_mutable_default_discrete_mapping();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SegmentationModelMetadata.default_discrete_mapping)
    return _s;
}
inline const std::string& SegmentationModelMetadata::_internal_default_discrete_mapping() const
{
    return _impl_.default_discrete_mapping_.Get();
}
inline void SegmentationModelMetadata::_internal_set_default_discrete_mapping(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.default_discrete_mapping_.Set(value, GetArenaForAllocation());
}
inline std::string* SegmentationModelMetadata::_internal_mutable_default_discrete_mapping()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.default_discrete_mapping_.Mutable(GetArenaForAllocation());
}
inline std::string* SegmentationModelMetadata::release_default_discrete_mapping()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.SegmentationModelMetadata.default_discrete_mapping)
    if (!_internal_has_default_discrete_mapping()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.default_discrete_mapping_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.default_discrete_mapping_.IsDefault()) {
        _impl_.default_discrete_mapping_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SegmentationModelMetadata::set_allocated_default_discrete_mapping(std::string* default_discrete_mapping)
{
    if (default_discrete_mapping != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.default_discrete_mapping_.SetAllocated(default_discrete_mapping, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.default_discrete_mapping_.IsDefault()) {
        _impl_.default_discrete_mapping_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SegmentationModelMetadata.default_discrete_mapping)
}

// optional bool upload_tensors = 13;
inline bool SegmentationModelMetadata::_internal_has_upload_tensors() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool SegmentationModelMetadata::has_upload_tensors() const
{
    return _internal_has_upload_tensors();
}
inline void SegmentationModelMetadata::clear_upload_tensors()
{
    _impl_.upload_tensors_ = false;
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool SegmentationModelMetadata::_internal_upload_tensors() const
{
    return _impl_.upload_tensors_;
}
inline bool SegmentationModelMetadata::upload_tensors() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.upload_tensors)
    return _internal_upload_tensors();
}
inline void SegmentationModelMetadata::_internal_set_upload_tensors(bool value)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.upload_tensors_ = value;
}
inline void SegmentationModelMetadata::set_upload_tensors(bool value)
{
    _internal_set_upload_tensors(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.upload_tensors)
}

// optional .segmentation_platform.proto.SegmentationModelMetadata.OutputDescription return_type = 14;
inline bool SegmentationModelMetadata::_internal_has_return_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    return value;
}
inline bool SegmentationModelMetadata::has_return_type() const
{
    return _internal_has_return_type();
}
inline void SegmentationModelMetadata::clear_return_type()
{
    _impl_.return_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::segmentation_platform::proto::SegmentationModelMetadata_OutputDescription SegmentationModelMetadata::_internal_return_type() const
{
    return static_cast<::segmentation_platform::proto::SegmentationModelMetadata_OutputDescription>(_impl_.return_type_);
}
inline ::segmentation_platform::proto::SegmentationModelMetadata_OutputDescription SegmentationModelMetadata::return_type() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.return_type)
    return _internal_return_type();
}
inline void SegmentationModelMetadata::_internal_set_return_type(::segmentation_platform::proto::SegmentationModelMetadata_OutputDescription value)
{
    assert(::segmentation_platform::proto::SegmentationModelMetadata_OutputDescription_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000800u;
    _impl_.return_type_ = value;
}
inline void SegmentationModelMetadata::set_return_type(::segmentation_platform::proto::SegmentationModelMetadata_OutputDescription value)
{
    _internal_set_return_type(value);
    // @@protoc_insertion_point(field_set:segmentation_platform.proto.SegmentationModelMetadata.return_type)
}

// optional .segmentation_platform.proto.OutputConfig output_config = 16;
inline bool SegmentationModelMetadata::_internal_has_output_config() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.output_config_ != nullptr);
    return value;
}
inline bool SegmentationModelMetadata::has_output_config() const
{
    return _internal_has_output_config();
}
inline const ::segmentation_platform::proto::OutputConfig& SegmentationModelMetadata::_internal_output_config() const
{
    const ::segmentation_platform::proto::OutputConfig* p = _impl_.output_config_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::segmentation_platform::proto::OutputConfig&>(::segmentation_platform::proto::_OutputConfig_default_instance_);
}
inline const ::segmentation_platform::proto::OutputConfig& SegmentationModelMetadata::output_config() const
{
    // @@protoc_insertion_point(field_get:segmentation_platform.proto.SegmentationModelMetadata.output_config)
    return _internal_output_config();
}
inline void SegmentationModelMetadata::unsafe_arena_set_allocated_output_config(::segmentation_platform::proto::OutputConfig* output_config)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_config_);
    }
    _impl_.output_config_ = output_config;
    if (output_config) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:segmentation_platform.proto.SegmentationModelMetadata.output_config)
}
inline ::segmentation_platform::proto::OutputConfig* SegmentationModelMetadata::release_output_config()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::segmentation_platform::proto::OutputConfig* temp = _impl_.output_config_;
    _impl_.output_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::segmentation_platform::proto::OutputConfig* SegmentationModelMetadata::unsafe_arena_release_output_config()
{
    // @@protoc_insertion_point(field_release:segmentation_platform.proto.SegmentationModelMetadata.output_config)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::segmentation_platform::proto::OutputConfig* temp = _impl_.output_config_;
    _impl_.output_config_ = nullptr;
    return temp;
}
inline ::segmentation_platform::proto::OutputConfig* SegmentationModelMetadata::_internal_mutable_output_config()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.output_config_ == nullptr) {
        auto* p = CreateMaybeMessage<::segmentation_platform::proto::OutputConfig>(GetArenaForAllocation());
        _impl_.output_config_ = p;
    }
    return _impl_.output_config_;
}
inline ::segmentation_platform::proto::OutputConfig* SegmentationModelMetadata::mutable_output_config()
{
    ::segmentation_platform::proto::OutputConfig* _msg = _internal_mutable_output_config();
    // @@protoc_insertion_point(field_mutable:segmentation_platform.proto.SegmentationModelMetadata.output_config)
    return _msg;
}
inline void SegmentationModelMetadata::set_allocated_output_config(::segmentation_platform::proto::OutputConfig* output_config)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_config_);
    }
    if (output_config) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output_config));
        if (message_arena != submessage_arena) {
            output_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, output_config, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.output_config_ = output_config;
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.SegmentationModelMetadata.output_config)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace proto
} // namespace segmentation_platform

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::segmentation_platform::proto::CustomInput_FillPolicy> : ::std::true_type { };
template <> struct is_proto_enum<::segmentation_platform::proto::SqlFeature_BindValue_ParamType> : ::std::true_type { };
template <> struct is_proto_enum<::segmentation_platform::proto::TrainingOutputs_TriggerConfig_DecisionType> : ::std::true_type { };
template <> struct is_proto_enum<::segmentation_platform::proto::SegmentationModelMetadata_OutputDescription> : ::std::true_type { };
template <> struct is_proto_enum<::segmentation_platform::proto::CurrentVersion> : ::std::true_type { };
template <> struct is_proto_enum<::segmentation_platform::proto::ModelSource> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fsegmentation_5fplatform_2fpublic_2fproto_2fmodel_5fmetadata_2eproto
