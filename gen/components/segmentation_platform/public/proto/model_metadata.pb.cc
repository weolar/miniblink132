// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/segmentation_platform/public/proto/model_metadata.proto

#include "components/segmentation_platform/public/proto/model_metadata.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace segmentation_platform {
namespace proto {
PROTOBUF_CONSTEXPR VersionInfo::VersionInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.metadata_min_version_)*/ 0,
        /*decltype(_impl_.metadata_cur_version_)*/ 0 }
{
}
struct VersionInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR VersionInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~VersionInfoDefaultTypeInternal()
    {
    }
    union {
        VersionInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VersionInfoDefaultTypeInternal _VersionInfo_default_instance_;
PROTOBUF_CONSTEXPR UMAFeature::UMAFeature(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.enum_ids_)*/ {},
        /*decltype(_impl_.default_values_)*/ {}, /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.name_hash_)*/ uint64_t { 0u }, /*decltype(_impl_.type_)*/ 0, /*decltype(_impl_.aggregation_)*/ 0,
        /*decltype(_impl_.bucket_count_)*/ uint64_t { 0u }, /*decltype(_impl_.tensor_length_)*/ uint64_t { 0u } }
{
}
struct UMAFeatureDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UMAFeatureDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UMAFeatureDefaultTypeInternal()
    {
    }
    union {
        UMAFeature _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UMAFeatureDefaultTypeInternal _UMAFeature_default_instance_;
PROTOBUF_CONSTEXPR CustomInput_AdditionalArgsEntry_DoNotUse::CustomInput_AdditionalArgsEntry_DoNotUse(::_pbi::ConstantInitialized)
{
}
struct CustomInput_AdditionalArgsEntry_DoNotUseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CustomInput_AdditionalArgsEntry_DoNotUseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CustomInput_AdditionalArgsEntry_DoNotUseDefaultTypeInternal()
    {
    }
    union {
        CustomInput_AdditionalArgsEntry_DoNotUse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CustomInput_AdditionalArgsEntry_DoNotUseDefaultTypeInternal
    _CustomInput_AdditionalArgsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR CustomInput::CustomInput(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.default_value_)*/ {},
        /*decltype(_impl_.additional_args_)*/ {}, /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.tensor_length_)*/ 0, /*decltype(_impl_.fill_policy_)*/ 0 }
{
}
struct CustomInputDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CustomInputDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CustomInputDefaultTypeInternal()
    {
    }
    union {
        CustomInput _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CustomInputDefaultTypeInternal _CustomInput_default_instance_;
PROTOBUF_CONSTEXPR SignalFilterConfig_UkmEvent::SignalFilterConfig_UkmEvent(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.metric_hash_filter_)*/ {},
        /*decltype(_impl_.event_hash_)*/ uint64_t { 0u } }
{
}
struct SignalFilterConfig_UkmEventDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SignalFilterConfig_UkmEventDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SignalFilterConfig_UkmEventDefaultTypeInternal()
    {
    }
    union {
        SignalFilterConfig_UkmEvent _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignalFilterConfig_UkmEventDefaultTypeInternal
    _SignalFilterConfig_UkmEvent_default_instance_;
PROTOBUF_CONSTEXPR SignalFilterConfig::SignalFilterConfig(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.ukm_events_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SignalFilterConfigDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SignalFilterConfigDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SignalFilterConfigDefaultTypeInternal()
    {
    }
    union {
        SignalFilterConfig _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignalFilterConfigDefaultTypeInternal _SignalFilterConfig_default_instance_;
PROTOBUF_CONSTEXPR SqlFeature_BindValue::SqlFeature_BindValue(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.bind_field_index_)*/ {},
        /*decltype(_impl_.value_)*/ nullptr, /*decltype(_impl_.param_type_)*/ 0 }
{
}
struct SqlFeature_BindValueDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SqlFeature_BindValueDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SqlFeature_BindValueDefaultTypeInternal()
    {
    }
    union {
        SqlFeature_BindValue _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SqlFeature_BindValueDefaultTypeInternal
    _SqlFeature_BindValue_default_instance_;
PROTOBUF_CONSTEXPR SqlFeature::SqlFeature(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.bind_values_)*/ {},
        /*decltype(_impl_.sql_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.signal_filter_)*/ nullptr }
{
}
struct SqlFeatureDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SqlFeatureDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SqlFeatureDefaultTypeInternal()
    {
    }
    union {
        SqlFeature _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SqlFeatureDefaultTypeInternal _SqlFeature_default_instance_;
PROTOBUF_CONSTEXPR InputFeature::InputFeature(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.Feature_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct InputFeatureDefaultTypeInternal {
    PROTOBUF_CONSTEXPR InputFeatureDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~InputFeatureDefaultTypeInternal()
    {
    }
    union {
        InputFeature _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InputFeatureDefaultTypeInternal _InputFeature_default_instance_;
PROTOBUF_CONSTEXPR TrainingOutputs_TriggerConfig_ObservationTrigger::TrainingOutputs_TriggerConfig_ObservationTrigger(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.trigger_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct TrainingOutputs_TriggerConfig_ObservationTriggerDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TrainingOutputs_TriggerConfig_ObservationTriggerDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TrainingOutputs_TriggerConfig_ObservationTriggerDefaultTypeInternal()
    {
    }
    union {
        TrainingOutputs_TriggerConfig_ObservationTrigger _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrainingOutputs_TriggerConfig_ObservationTriggerDefaultTypeInternal
    _TrainingOutputs_TriggerConfig_ObservationTrigger_default_instance_;
PROTOBUF_CONSTEXPR TrainingOutputs_TriggerConfig::TrainingOutputs_TriggerConfig(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.observation_trigger_)*/ {},
        /*decltype(_impl_.decision_type_)*/ 0, /*decltype(_impl_.use_exact_prediction_time_)*/ false,
        /*decltype(_impl_.use_flexible_observation_time_)*/ false }
{
}
struct TrainingOutputs_TriggerConfigDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TrainingOutputs_TriggerConfigDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TrainingOutputs_TriggerConfigDefaultTypeInternal()
    {
    }
    union {
        TrainingOutputs_TriggerConfig _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrainingOutputs_TriggerConfigDefaultTypeInternal
    _TrainingOutputs_TriggerConfig_default_instance_;
PROTOBUF_CONSTEXPR TrainingOutputs::TrainingOutputs(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.outputs_)*/ {},
        /*decltype(_impl_.trigger_config_)*/ nullptr }
{
}
struct TrainingOutputsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TrainingOutputsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TrainingOutputsDefaultTypeInternal()
    {
    }
    union {
        TrainingOutputs _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrainingOutputsDefaultTypeInternal _TrainingOutputs_default_instance_;
PROTOBUF_CONSTEXPR TrainingOutput::TrainingOutput(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.output_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct TrainingOutputDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TrainingOutputDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TrainingOutputDefaultTypeInternal()
    {
    }
    union {
        TrainingOutput _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrainingOutputDefaultTypeInternal _TrainingOutput_default_instance_;
PROTOBUF_CONSTEXPR UMAOutput::UMAOutput(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.uma_feature_)*/ nullptr,
        /*decltype(_impl_.duration_)*/ uint64_t { 0u } }
{
}
struct UMAOutputDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UMAOutputDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UMAOutputDefaultTypeInternal()
    {
    }
    union {
        UMAOutput _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UMAOutputDefaultTypeInternal _UMAOutput_default_instance_;
PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMapping_Entry::SegmentationModelMetadata_DiscreteMapping_Entry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.rank_)*/ int64_t { 0 },
        /*decltype(_impl_.min_result_)*/ 0 }
{
}
struct SegmentationModelMetadata_DiscreteMapping_EntryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMapping_EntryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SegmentationModelMetadata_DiscreteMapping_EntryDefaultTypeInternal()
    {
    }
    union {
        SegmentationModelMetadata_DiscreteMapping_Entry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SegmentationModelMetadata_DiscreteMapping_EntryDefaultTypeInternal
    _SegmentationModelMetadata_DiscreteMapping_Entry_default_instance_;
PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMapping::SegmentationModelMetadata_DiscreteMapping(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.entries_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SegmentationModelMetadata_DiscreteMappingDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMappingDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SegmentationModelMetadata_DiscreteMappingDefaultTypeInternal()
    {
    }
    union {
        SegmentationModelMetadata_DiscreteMapping _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SegmentationModelMetadata_DiscreteMappingDefaultTypeInternal
    _SegmentationModelMetadata_DiscreteMapping_default_instance_;
PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse(
    ::_pbi::ConstantInitialized)
{
}
struct SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUseDefaultTypeInternal()
    {
    }
    union {
        SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUseDefaultTypeInternal
    _SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR SegmentationModelMetadata::SegmentationModelMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.features_)*/ {},
        /*decltype(_impl_.discrete_mappings_)*/ {}, /*decltype(_impl_.input_features_)*/ {},
        /*decltype(_impl_.default_discrete_mapping_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.version_info_)*/ nullptr, /*decltype(_impl_.training_outputs_)*/ nullptr, /*decltype(_impl_.output_config_)*/ nullptr,
        /*decltype(_impl_.bucket_duration_)*/ uint64_t { 0u }, /*decltype(_impl_.signal_storage_length_)*/ int64_t { 0 },
        /*decltype(_impl_.min_signal_collection_length_)*/ int64_t { 0 }, /*decltype(_impl_.result_time_to_live_)*/ int64_t { 0 },
        /*decltype(_impl_.time_unit_)*/ 0, /*decltype(_impl_.upload_tensors_)*/ false, /*decltype(_impl_.fixed_prediction_timestamp_)*/ int64_t { 0 },
        /*decltype(_impl_.return_type_)*/ 0 }
{
}
struct SegmentationModelMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SegmentationModelMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SegmentationModelMetadataDefaultTypeInternal()
    {
    }
    union {
        SegmentationModelMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SegmentationModelMetadataDefaultTypeInternal
    _SegmentationModelMetadata_default_instance_;
} // namespace proto
} // namespace segmentation_platform
namespace segmentation_platform {
namespace proto {
bool CustomInput_FillPolicy_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CustomInput_FillPolicy_strings[12] = {};

static const char CustomInput_FillPolicy_names[] = "FILL_DEVICE_OS_VERSION_NUMBER"
                                                   "FILL_DEVICE_PPI"
                                                   "FILL_DEVICE_RAM_MB"
                                                   "FILL_FROM_INPUT_CONTEXT"
                                                   "FILL_FROM_SHOPPING_SERVICE"
                                                   "FILL_PREDICTION_TIME"
                                                   "FILL_RANDOM"
                                                   "FILL_SYNC_DEVICE_INFO"
                                                   "FILL_TAB_METRICS"
                                                   "PRICE_TRACKING_HINTS"
                                                   "TIME_RANGE_BEFORE_PREDICTION"
                                                   "UNKNOWN_FILL_POLICY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CustomInput_FillPolicy_entries[] = {
    { { CustomInput_FillPolicy_names + 0, 29 }, 7 },
    { { CustomInput_FillPolicy_names + 29, 15 }, 8 },
    { { CustomInput_FillPolicy_names + 44, 18 }, 6 },
    { { CustomInput_FillPolicy_names + 62, 23 }, 4 },
    { { CustomInput_FillPolicy_names + 85, 26 }, 11 },
    { { CustomInput_FillPolicy_names + 111, 20 }, 1 },
    { { CustomInput_FillPolicy_names + 131, 11 }, 10 },
    { { CustomInput_FillPolicy_names + 142, 21 }, 5 },
    { { CustomInput_FillPolicy_names + 163, 16 }, 9 },
    { { CustomInput_FillPolicy_names + 179, 20 }, 3 },
    { { CustomInput_FillPolicy_names + 199, 28 }, 2 },
    { { CustomInput_FillPolicy_names + 227, 19 }, 0 },
};

static const int CustomInput_FillPolicy_entries_by_number[] = {
    11, // 0 -> UNKNOWN_FILL_POLICY
    5, // 1 -> FILL_PREDICTION_TIME
    10, // 2 -> TIME_RANGE_BEFORE_PREDICTION
    9, // 3 -> PRICE_TRACKING_HINTS
    3, // 4 -> FILL_FROM_INPUT_CONTEXT
    7, // 5 -> FILL_SYNC_DEVICE_INFO
    2, // 6 -> FILL_DEVICE_RAM_MB
    0, // 7 -> FILL_DEVICE_OS_VERSION_NUMBER
    1, // 8 -> FILL_DEVICE_PPI
    8, // 9 -> FILL_TAB_METRICS
    6, // 10 -> FILL_RANDOM
    4, // 11 -> FILL_FROM_SHOPPING_SERVICE
};

const std::string& CustomInput_FillPolicy_Name(CustomInput_FillPolicy value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        CustomInput_FillPolicy_entries, CustomInput_FillPolicy_entries_by_number, 12, CustomInput_FillPolicy_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(CustomInput_FillPolicy_entries, CustomInput_FillPolicy_entries_by_number, 12, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : CustomInput_FillPolicy_strings[idx].get();
}
bool CustomInput_FillPolicy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CustomInput_FillPolicy* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(CustomInput_FillPolicy_entries, 12, name, &int_value);
    if (success) {
        *value = static_cast<CustomInput_FillPolicy>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CustomInput_FillPolicy CustomInput::UNKNOWN_FILL_POLICY;
constexpr CustomInput_FillPolicy CustomInput::FILL_PREDICTION_TIME;
constexpr CustomInput_FillPolicy CustomInput::TIME_RANGE_BEFORE_PREDICTION;
constexpr CustomInput_FillPolicy CustomInput::PRICE_TRACKING_HINTS;
constexpr CustomInput_FillPolicy CustomInput::FILL_FROM_INPUT_CONTEXT;
constexpr CustomInput_FillPolicy CustomInput::FILL_SYNC_DEVICE_INFO;
constexpr CustomInput_FillPolicy CustomInput::FILL_DEVICE_RAM_MB;
constexpr CustomInput_FillPolicy CustomInput::FILL_DEVICE_OS_VERSION_NUMBER;
constexpr CustomInput_FillPolicy CustomInput::FILL_DEVICE_PPI;
constexpr CustomInput_FillPolicy CustomInput::FILL_TAB_METRICS;
constexpr CustomInput_FillPolicy CustomInput::FILL_RANDOM;
constexpr CustomInput_FillPolicy CustomInput::FILL_FROM_SHOPPING_SERVICE;
constexpr CustomInput_FillPolicy CustomInput::FillPolicy_MIN;
constexpr CustomInput_FillPolicy CustomInput::FillPolicy_MAX;
constexpr int CustomInput::FillPolicy_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SqlFeature_BindValue_ParamType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SqlFeature_BindValue_ParamType_strings[8] = {};

static const char SqlFeature_BindValue_ParamType_names[] = "BOOL"
                                                           "DOUBLE"
                                                           "INT"
                                                           "INT64"
                                                           "NULL"
                                                           "STRING"
                                                           "TIME"
                                                           "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SqlFeature_BindValue_ParamType_entries[] = {
    { { SqlFeature_BindValue_ParamType_names + 0, 4 }, 2 },
    { { SqlFeature_BindValue_ParamType_names + 4, 6 }, 5 },
    { { SqlFeature_BindValue_ParamType_names + 10, 3 }, 3 },
    { { SqlFeature_BindValue_ParamType_names + 13, 5 }, 4 },
    { { SqlFeature_BindValue_ParamType_names + 18, 4 }, 1 },
    { { SqlFeature_BindValue_ParamType_names + 22, 6 }, 6 },
    { { SqlFeature_BindValue_ParamType_names + 28, 4 }, 7 },
    { { SqlFeature_BindValue_ParamType_names + 32, 7 }, 0 },
};

static const int SqlFeature_BindValue_ParamType_entries_by_number[] = {
    7, // 0 -> UNKNOWN
    4, // 1 -> NULL
    0, // 2 -> BOOL
    2, // 3 -> INT
    3, // 4 -> INT64
    1, // 5 -> DOUBLE
    5, // 6 -> STRING
    6, // 7 -> TIME
};

const std::string& SqlFeature_BindValue_ParamType_Name(SqlFeature_BindValue_ParamType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        SqlFeature_BindValue_ParamType_entries, SqlFeature_BindValue_ParamType_entries_by_number, 8, SqlFeature_BindValue_ParamType_strings);
    (void)dummy;
    int idx
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(SqlFeature_BindValue_ParamType_entries, SqlFeature_BindValue_ParamType_entries_by_number, 8, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : SqlFeature_BindValue_ParamType_strings[idx].get();
}
bool SqlFeature_BindValue_ParamType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SqlFeature_BindValue_ParamType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(SqlFeature_BindValue_ParamType_entries, 8, name, &int_value);
    if (success) {
        *value = static_cast<SqlFeature_BindValue_ParamType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::UNKNOWN;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::NULL_;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::BOOL;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::INT;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::INT64;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::DOUBLE;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::STRING;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::TIME;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::ParamType_MIN;
constexpr SqlFeature_BindValue_ParamType SqlFeature_BindValue::ParamType_MAX;
constexpr int SqlFeature_BindValue::ParamType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TrainingOutputs_TriggerConfig_DecisionType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TrainingOutputs_TriggerConfig_DecisionType_strings[3] = {};

static const char TrainingOutputs_TriggerConfig_DecisionType_names[] = "ONDEMAND"
                                                                       "PERIODIC"
                                                                       "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TrainingOutputs_TriggerConfig_DecisionType_entries[] = {
    { { TrainingOutputs_TriggerConfig_DecisionType_names + 0, 8 }, 1 },
    { { TrainingOutputs_TriggerConfig_DecisionType_names + 8, 8 }, 2 },
    { { TrainingOutputs_TriggerConfig_DecisionType_names + 16, 7 }, 0 },
};

static const int TrainingOutputs_TriggerConfig_DecisionType_entries_by_number[] = {
    2, // 0 -> UNKNOWN
    0, // 1 -> ONDEMAND
    1, // 2 -> PERIODIC
};

const std::string& TrainingOutputs_TriggerConfig_DecisionType_Name(TrainingOutputs_TriggerConfig_DecisionType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(TrainingOutputs_TriggerConfig_DecisionType_entries,
        TrainingOutputs_TriggerConfig_DecisionType_entries_by_number, 3, TrainingOutputs_TriggerConfig_DecisionType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        TrainingOutputs_TriggerConfig_DecisionType_entries, TrainingOutputs_TriggerConfig_DecisionType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : TrainingOutputs_TriggerConfig_DecisionType_strings[idx].get();
}
bool TrainingOutputs_TriggerConfig_DecisionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrainingOutputs_TriggerConfig_DecisionType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(TrainingOutputs_TriggerConfig_DecisionType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<TrainingOutputs_TriggerConfig_DecisionType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TrainingOutputs_TriggerConfig_DecisionType TrainingOutputs_TriggerConfig::UNKNOWN;
constexpr TrainingOutputs_TriggerConfig_DecisionType TrainingOutputs_TriggerConfig::ONDEMAND;
constexpr TrainingOutputs_TriggerConfig_DecisionType TrainingOutputs_TriggerConfig::PERIODIC;
constexpr TrainingOutputs_TriggerConfig_DecisionType TrainingOutputs_TriggerConfig::DecisionType_MIN;
constexpr TrainingOutputs_TriggerConfig_DecisionType TrainingOutputs_TriggerConfig::DecisionType_MAX;
constexpr int TrainingOutputs_TriggerConfig::DecisionType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool SegmentationModelMetadata_OutputDescription_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SegmentationModelMetadata_OutputDescription_strings[5] = {};

static const char SegmentationModelMetadata_OutputDescription_names[] = "RETURN_TYPE_HEURISTIC"
                                                                        "RETURN_TYPE_INTEGER"
                                                                        "RETURN_TYPE_MULTISEGMENT"
                                                                        "RETURN_TYPE_PROBABILITY"
                                                                        "UNKNOWN_RETURN_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SegmentationModelMetadata_OutputDescription_entries[] = {
    { { SegmentationModelMetadata_OutputDescription_names + 0, 21 }, 1 },
    { { SegmentationModelMetadata_OutputDescription_names + 21, 19 }, 4 },
    { { SegmentationModelMetadata_OutputDescription_names + 40, 24 }, 2 },
    { { SegmentationModelMetadata_OutputDescription_names + 64, 23 }, 3 },
    { { SegmentationModelMetadata_OutputDescription_names + 87, 19 }, 0 },
};

static const int SegmentationModelMetadata_OutputDescription_entries_by_number[] = {
    4, // 0 -> UNKNOWN_RETURN_TYPE
    0, // 1 -> RETURN_TYPE_HEURISTIC
    2, // 2 -> RETURN_TYPE_MULTISEGMENT
    3, // 3 -> RETURN_TYPE_PROBABILITY
    1, // 4 -> RETURN_TYPE_INTEGER
};

const std::string& SegmentationModelMetadata_OutputDescription_Name(SegmentationModelMetadata_OutputDescription value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(SegmentationModelMetadata_OutputDescription_entries,
        SegmentationModelMetadata_OutputDescription_entries_by_number, 5, SegmentationModelMetadata_OutputDescription_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        SegmentationModelMetadata_OutputDescription_entries, SegmentationModelMetadata_OutputDescription_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : SegmentationModelMetadata_OutputDescription_strings[idx].get();
}
bool SegmentationModelMetadata_OutputDescription_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SegmentationModelMetadata_OutputDescription* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(SegmentationModelMetadata_OutputDescription_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<SegmentationModelMetadata_OutputDescription>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SegmentationModelMetadata_OutputDescription SegmentationModelMetadata::UNKNOWN_RETURN_TYPE;
constexpr SegmentationModelMetadata_OutputDescription SegmentationModelMetadata::RETURN_TYPE_HEURISTIC;
constexpr SegmentationModelMetadata_OutputDescription SegmentationModelMetadata::RETURN_TYPE_MULTISEGMENT;
constexpr SegmentationModelMetadata_OutputDescription SegmentationModelMetadata::RETURN_TYPE_PROBABILITY;
constexpr SegmentationModelMetadata_OutputDescription SegmentationModelMetadata::RETURN_TYPE_INTEGER;
constexpr SegmentationModelMetadata_OutputDescription SegmentationModelMetadata::OutputDescription_MIN;
constexpr SegmentationModelMetadata_OutputDescription SegmentationModelMetadata::OutputDescription_MAX;
constexpr int SegmentationModelMetadata::OutputDescription_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CurrentVersion_IsValid(int value)
{
    switch (value) {
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CurrentVersion_strings[1] = {};

static const char CurrentVersion_names[] = "METADATA_VERSION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CurrentVersion_entries[] = {
    { { CurrentVersion_names + 0, 16 }, 3 },
};

static const int CurrentVersion_entries_by_number[] = {
    0, // 3 -> METADATA_VERSION
};

const std::string& CurrentVersion_Name(CurrentVersion value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(CurrentVersion_entries, CurrentVersion_entries_by_number, 1, CurrentVersion_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(CurrentVersion_entries, CurrentVersion_entries_by_number, 1, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : CurrentVersion_strings[idx].get();
}
bool CurrentVersion_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CurrentVersion* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(CurrentVersion_entries, 1, name, &int_value);
    if (success) {
        *value = static_cast<CurrentVersion>(int_value);
    }
    return success;
}
bool ModelSource_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ModelSource_strings[3] = {};

static const char ModelSource_names[] = "DEFAULT_MODEL_SOURCE"
                                        "SERVER_MODEL_SOURCE"
                                        "UNKNOWN_MODEL_SOURCE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ModelSource_entries[] = {
    { { ModelSource_names + 0, 20 }, 2 },
    { { ModelSource_names + 20, 19 }, 1 },
    { { ModelSource_names + 39, 20 }, 0 },
};

static const int ModelSource_entries_by_number[] = {
    2, // 0 -> UNKNOWN_MODEL_SOURCE
    1, // 1 -> SERVER_MODEL_SOURCE
    0, // 2 -> DEFAULT_MODEL_SOURCE
};

const std::string& ModelSource_Name(ModelSource value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ModelSource_entries, ModelSource_entries_by_number, 3, ModelSource_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ModelSource_entries, ModelSource_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ModelSource_strings[idx].get();
}
bool ModelSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelSource* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ModelSource_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ModelSource>(int_value);
    }
    return success;
}

// ===================================================================

class VersionInfo::_Internal {
public:
    using HasBits = decltype(std::declval<VersionInfo>()._impl_._has_bits_);
    static void set_has_metadata_min_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_metadata_cur_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

VersionInfo::VersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.VersionInfo)
}
VersionInfo::VersionInfo(const VersionInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    VersionInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.metadata_min_version_) {}, decltype(_impl_.metadata_cur_version_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.metadata_min_version_, &from._impl_.metadata_min_version_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.metadata_cur_version_) - reinterpret_cast<char*>(&_impl_.metadata_min_version_))
            + sizeof(_impl_.metadata_cur_version_));
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.VersionInfo)
}

inline void VersionInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.metadata_min_version_) { 0 },
        decltype(_impl_.metadata_cur_version_) { 0 } };
}

VersionInfo::~VersionInfo()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.VersionInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void VersionInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VersionInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void VersionInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.VersionInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.metadata_min_version_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.metadata_cur_version_) - reinterpret_cast<char*>(&_impl_.metadata_min_version_))
                + sizeof(_impl_.metadata_cur_version_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* VersionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 metadata_min_version = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_metadata_min_version(&has_bits);
                _impl_.metadata_min_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 metadata_cur_version = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_metadata_cur_version(&has_bits);
                _impl_.metadata_cur_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* VersionInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.VersionInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 metadata_min_version = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_metadata_min_version(), target);
    }

    // optional int32 metadata_cur_version = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_metadata_cur_version(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.VersionInfo)
    return target;
}

size_t VersionInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.VersionInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int32 metadata_min_version = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_metadata_min_version());
        }

        // optional int32 metadata_cur_version = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_metadata_cur_version());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void VersionInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const VersionInfo*>(&from));
}

void VersionInfo::MergeFrom(const VersionInfo& from)
{
    VersionInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.VersionInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.metadata_min_version_ = from._impl_.metadata_min_version_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.metadata_cur_version_ = from._impl_.metadata_cur_version_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VersionInfo::CopyFrom(const VersionInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.VersionInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool VersionInfo::IsInitialized() const
{
    return true;
}

void VersionInfo::InternalSwap(VersionInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(VersionInfo, _impl_.metadata_cur_version_)
        + sizeof(VersionInfo::_impl_.metadata_cur_version_) - PROTOBUF_FIELD_OFFSET(VersionInfo, _impl_.metadata_min_version_)>(
        reinterpret_cast<char*>(&_impl_.metadata_min_version_), reinterpret_cast<char*>(&other->_impl_.metadata_min_version_));
}

std::string VersionInfo::GetTypeName() const
{
    return "segmentation_platform.proto.VersionInfo";
}

// ===================================================================

class UMAFeature::_Internal {
public:
    using HasBits = decltype(std::declval<UMAFeature>()._impl_._has_bits_);
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_name_hash(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_bucket_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_tensor_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_aggregation(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

UMAFeature::UMAFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.UMAFeature)
}
UMAFeature::UMAFeature(const UMAFeature& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UMAFeature* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.enum_ids_) { from._impl_.enum_ids_ }, decltype(_impl_.default_values_) { from._impl_.default_values_ }, decltype(_impl_.name_) {},
        decltype(_impl_.name_hash_) {}, decltype(_impl_.type_) {}, decltype(_impl_.aggregation_) {}, decltype(_impl_.bucket_count_) {},
        decltype(_impl_.tensor_length_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.name_hash_, &from._impl_.name_hash_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tensor_length_) - reinterpret_cast<char*>(&_impl_.name_hash_)) + sizeof(_impl_.tensor_length_));
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.UMAFeature)
}

inline void UMAFeature::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.enum_ids_) { arena },
        decltype(_impl_.default_values_) { arena }, decltype(_impl_.name_) {}, decltype(_impl_.name_hash_) { uint64_t { 0u } }, decltype(_impl_.type_) { 0 },
        decltype(_impl_.aggregation_) { 0 }, decltype(_impl_.bucket_count_) { uint64_t { 0u } }, decltype(_impl_.tensor_length_) { uint64_t { 0u } } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UMAFeature::~UMAFeature()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.UMAFeature)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UMAFeature::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.enum_ids_.~RepeatedField();
    _impl_.default_values_.~RepeatedField();
    _impl_.name_.Destroy();
}

void UMAFeature::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UMAFeature::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.UMAFeature)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.enum_ids_.Clear();
    _impl_.default_values_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x0000003eu) {
        ::memset(&_impl_.name_hash_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tensor_length_) - reinterpret_cast<char*>(&_impl_.name_hash_)) + sizeof(_impl_.tensor_length_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UMAFeature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .segmentation_platform.proto.SignalType type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::segmentation_platform::proto::SignalType_IsValid(val))) {
                    _internal_set_type(static_cast<::segmentation_platform::proto::SignalType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional fixed64 name_hash = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
                _Internal::set_has_name_hash(&has_bits);
                _impl_.name_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
                ptr += sizeof(uint64_t);
            } else
                goto handle_unusual;
            continue;
        // optional uint64 bucket_count = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_bucket_count(&has_bits);
                _impl_.bucket_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint64 tensor_length = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_tensor_length(&has_bits);
                _impl_.tensor_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .segmentation_platform.proto.Aggregation aggregation = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::segmentation_platform::proto::Aggregation_IsValid(val))) {
                    _internal_set_aggregation(static_cast<::segmentation_platform::proto::Aggregation>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated int32 enum_ids = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_enum_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
            } else if (static_cast<uint8_t>(tag) == 58) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_enum_ids(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated float default_values = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_default_values(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
                    ptr += sizeof(float);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<69>(ptr));
            } else if (static_cast<uint8_t>(tag) == 66) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_default_values(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UMAFeature::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.UMAFeature)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .segmentation_platform.proto.SignalType type = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_type(), target);
    }

    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_name(), target);
    }

    // optional fixed64 name_hash = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_name_hash(), target);
    }

    // optional uint64 bucket_count = 4;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_bucket_count(), target);
    }

    // optional uint64 tensor_length = 5;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_tensor_length(), target);
    }

    // optional .segmentation_platform.proto.Aggregation aggregation = 6;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(6, this->_internal_aggregation(), target);
    }

    // repeated int32 enum_ids = 7;
    for (int i = 0, n = this->_internal_enum_ids_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_enum_ids(i), target);
    }

    // repeated float default_values = 8;
    for (int i = 0, n = this->_internal_default_values_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_default_values(i), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.UMAFeature)
    return target;
}

size_t UMAFeature::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.UMAFeature)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 enum_ids = 7;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.enum_ids_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_enum_ids_size());
        total_size += data_size;
    }

    // repeated float default_values = 8;
    {
        unsigned int count = static_cast<unsigned int>(this->_internal_default_values_size());
        size_t data_size = 4UL * count;
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_default_values_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional string name = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional fixed64 name_hash = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 8;
        }

        // optional .segmentation_platform.proto.SignalType type = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }

        // optional .segmentation_platform.proto.Aggregation aggregation = 6;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_aggregation());
        }

        // optional uint64 bucket_count = 4;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bucket_count());
        }

        // optional uint64 tensor_length = 5;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tensor_length());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UMAFeature::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UMAFeature*>(&from));
}

void UMAFeature::MergeFrom(const UMAFeature& from)
{
    UMAFeature* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.UMAFeature)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.enum_ids_.MergeFrom(from._impl_.enum_ids_);
    _this->_impl_.default_values_.MergeFrom(from._impl_.default_values_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.name_hash_ = from._impl_.name_hash_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.aggregation_ = from._impl_.aggregation_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.bucket_count_ = from._impl_.bucket_count_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.tensor_length_ = from._impl_.tensor_length_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UMAFeature::CopyFrom(const UMAFeature& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.UMAFeature)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UMAFeature::IsInitialized() const
{
    return true;
}

void UMAFeature::InternalSwap(UMAFeature* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.enum_ids_.InternalSwap(&other->_impl_.enum_ids_);
    _impl_.default_values_.InternalSwap(&other->_impl_.default_values_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(UMAFeature, _impl_.tensor_length_) + sizeof(UMAFeature::_impl_.tensor_length_)
        - PROTOBUF_FIELD_OFFSET(UMAFeature, _impl_.name_hash_)>(
        reinterpret_cast<char*>(&_impl_.name_hash_), reinterpret_cast<char*>(&other->_impl_.name_hash_));
}

std::string UMAFeature::GetTypeName() const
{
    return "segmentation_platform.proto.UMAFeature";
}

// ===================================================================

CustomInput_AdditionalArgsEntry_DoNotUse::CustomInput_AdditionalArgsEntry_DoNotUse()
{
}
CustomInput_AdditionalArgsEntry_DoNotUse::CustomInput_AdditionalArgsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena)
{
}
void CustomInput_AdditionalArgsEntry_DoNotUse::MergeFrom(const CustomInput_AdditionalArgsEntry_DoNotUse& other)
{
    MergeFromInternal(other);
}

// ===================================================================

class CustomInput::_Internal {
public:
    using HasBits = decltype(std::declval<CustomInput>()._impl_._has_bits_);
    static void set_has_tensor_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_fill_policy(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

CustomInput::CustomInput(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.CustomInput)
}
CustomInput::CustomInput(const CustomInput& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CustomInput* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.default_value_) { from._impl_.default_value_ }, /*decltype(_impl_.additional_args_)*/ {}, decltype(_impl_.name_) {},
        decltype(_impl_.tensor_length_) {}, decltype(_impl_.fill_policy_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.additional_args_.MergeFrom(from._impl_.additional_args_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.tensor_length_, &from._impl_.tensor_length_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fill_policy_) - reinterpret_cast<char*>(&_impl_.tensor_length_)) + sizeof(_impl_.fill_policy_));
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.CustomInput)
}

inline void CustomInput::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.default_value_) { arena },
        /*decltype(_impl_.additional_args_)*/ { ::_pbi::ArenaInitialized(), arena }, decltype(_impl_.name_) {}, decltype(_impl_.tensor_length_) { 0 },
        decltype(_impl_.fill_policy_) { 0 } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CustomInput::~CustomInput()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.CustomInput)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CustomInput::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.default_value_.~RepeatedField();
    _impl_.additional_args_.Destruct();
    _impl_.additional_args_.~MapFieldLite();
    _impl_.name_.Destroy();
}

void CustomInput::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CustomInput::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.CustomInput)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.default_value_.Clear();
    _impl_.additional_args_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.tensor_length_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fill_policy_) - reinterpret_cast<char*>(&_impl_.tensor_length_)) + sizeof(_impl_.fill_policy_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CustomInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 tensor_length = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_tensor_length(&has_bits);
                _impl_.tensor_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .segmentation_platform.proto.CustomInput.FillPolicy fill_policy = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::segmentation_platform::proto::CustomInput_FillPolicy_IsValid(val))) {
                    _internal_set_fill_policy(static_cast<::segmentation_platform::proto::CustomInput_FillPolicy>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated float default_value = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_default_value(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
                    ptr += sizeof(float);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<29>(ptr));
            } else if (static_cast<uint8_t>(tag) == 26) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_default_value(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // map<string, string> additional_args = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(&_impl_.additional_args_, ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string name = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CustomInput::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.CustomInput)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 tensor_length = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_tensor_length(), target);
    }

    // optional .segmentation_platform.proto.CustomInput.FillPolicy fill_policy = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_fill_policy(), target);
    }

    // repeated float default_value = 3;
    for (int i = 0, n = this->_internal_default_value_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_default_value(i), target);
    }

    // map<string, string> additional_args = 4;
    if (!this->_internal_additional_args().empty()) {
        using MapType = ::_pb::Map<std::string, std::string>;
        using WireHelper = CustomInput_AdditionalArgsEntry_DoNotUse::Funcs;
        const auto& map_field = this->_internal_additional_args();
        auto check_utf8 = [](const MapType::value_type& entry) { (void)entry; };

        if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
            for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
                target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        } else {
            for (const auto& entry : map_field) {
                target = WireHelper::InternalSerialize(4, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        }
    }

    // optional string name = 5;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_name(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.CustomInput)
    return target;
}

size_t CustomInput::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.CustomInput)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated float default_value = 3;
    {
        unsigned int count = static_cast<unsigned int>(this->_internal_default_value_size());
        size_t data_size = 4UL * count;
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_default_value_size());
        total_size += data_size;
    }

    // map<string, string> additional_args = 4;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_additional_args_size());
    for (::PROTOBUF_NAMESPACE_ID::Map<std::string, std::string>::const_iterator it = this->_internal_additional_args().begin();
         it != this->_internal_additional_args().end(); ++it) {
        total_size += CustomInput_AdditionalArgsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string name = 5;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional int32 tensor_length = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tensor_length());
        }

        // optional .segmentation_platform.proto.CustomInput.FillPolicy fill_policy = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_fill_policy());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CustomInput::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CustomInput*>(&from));
}

void CustomInput::MergeFrom(const CustomInput& from)
{
    CustomInput* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.CustomInput)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.default_value_.MergeFrom(from._impl_.default_value_);
    _this->_impl_.additional_args_.MergeFrom(from._impl_.additional_args_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.tensor_length_ = from._impl_.tensor_length_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.fill_policy_ = from._impl_.fill_policy_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CustomInput::CopyFrom(const CustomInput& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.CustomInput)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CustomInput::IsInitialized() const
{
    return true;
}

void CustomInput::InternalSwap(CustomInput* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.default_value_.InternalSwap(&other->_impl_.default_value_);
    _impl_.additional_args_.InternalSwap(&other->_impl_.additional_args_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(CustomInput, _impl_.fill_policy_) + sizeof(CustomInput::_impl_.fill_policy_)
        - PROTOBUF_FIELD_OFFSET(CustomInput, _impl_.tensor_length_)>(
        reinterpret_cast<char*>(&_impl_.tensor_length_), reinterpret_cast<char*>(&other->_impl_.tensor_length_));
}

std::string CustomInput::GetTypeName() const
{
    return "segmentation_platform.proto.CustomInput";
}

// ===================================================================

class SignalFilterConfig_UkmEvent::_Internal {
public:
    using HasBits = decltype(std::declval<SignalFilterConfig_UkmEvent>()._impl_._has_bits_);
    static void set_has_event_hash(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

SignalFilterConfig_UkmEvent::SignalFilterConfig_UkmEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
}
SignalFilterConfig_UkmEvent::SignalFilterConfig_UkmEvent(const SignalFilterConfig_UkmEvent& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SignalFilterConfig_UkmEvent* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.metric_hash_filter_) { from._impl_.metric_hash_filter_ }, decltype(_impl_.event_hash_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.event_hash_ = from._impl_.event_hash_;
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
}

inline void SignalFilterConfig_UkmEvent::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.metric_hash_filter_) { arena },
        decltype(_impl_.event_hash_) { uint64_t { 0u } } };
}

SignalFilterConfig_UkmEvent::~SignalFilterConfig_UkmEvent()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SignalFilterConfig_UkmEvent::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.metric_hash_filter_.~RepeatedField();
}

void SignalFilterConfig_UkmEvent::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SignalFilterConfig_UkmEvent::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.metric_hash_filter_.Clear();
    _impl_.event_hash_ = uint64_t { 0u };
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SignalFilterConfig_UkmEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint64 event_hash = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_event_hash(&has_bits);
                _impl_.event_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated uint64 metric_hash_filter = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_metric_hash_filter(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
            } else if (static_cast<uint8_t>(tag) == 18) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_metric_hash_filter(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SignalFilterConfig_UkmEvent::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint64 event_hash = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_event_hash(), target);
    }

    // repeated uint64 metric_hash_filter = 2;
    for (int i = 0, n = this->_internal_metric_hash_filter_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_metric_hash_filter(i), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
    return target;
}

size_t SignalFilterConfig_UkmEvent::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated uint64 metric_hash_filter = 2;
    {
        size_t data_size = ::_pbi::WireFormatLite::UInt64Size(this->_impl_.metric_hash_filter_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_metric_hash_filter_size());
        total_size += data_size;
    }

    // optional uint64 event_hash = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_event_hash());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SignalFilterConfig_UkmEvent::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SignalFilterConfig_UkmEvent*>(&from));
}

void SignalFilterConfig_UkmEvent::MergeFrom(const SignalFilterConfig_UkmEvent& from)
{
    SignalFilterConfig_UkmEvent* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.metric_hash_filter_.MergeFrom(from._impl_.metric_hash_filter_);
    if (from._internal_has_event_hash()) {
        _this->_internal_set_event_hash(from._internal_event_hash());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SignalFilterConfig_UkmEvent::CopyFrom(const SignalFilterConfig_UkmEvent& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.SignalFilterConfig.UkmEvent)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SignalFilterConfig_UkmEvent::IsInitialized() const
{
    return true;
}

void SignalFilterConfig_UkmEvent::InternalSwap(SignalFilterConfig_UkmEvent* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.metric_hash_filter_.InternalSwap(&other->_impl_.metric_hash_filter_);
    swap(_impl_.event_hash_, other->_impl_.event_hash_);
}

std::string SignalFilterConfig_UkmEvent::GetTypeName() const
{
    return "segmentation_platform.proto.SignalFilterConfig.UkmEvent";
}

// ===================================================================

class SignalFilterConfig::_Internal {
public:
};

SignalFilterConfig::SignalFilterConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.SignalFilterConfig)
}
SignalFilterConfig::SignalFilterConfig(const SignalFilterConfig& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SignalFilterConfig* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.ukm_events_) { from._impl_.ukm_events_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.SignalFilterConfig)
}

inline void SignalFilterConfig::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.ukm_events_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

SignalFilterConfig::~SignalFilterConfig()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.SignalFilterConfig)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SignalFilterConfig::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.ukm_events_.~RepeatedPtrField();
}

void SignalFilterConfig::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SignalFilterConfig::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.SignalFilterConfig)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.ukm_events_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SignalFilterConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .segmentation_platform.proto.SignalFilterConfig.UkmEvent ukm_events = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_ukm_events(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SignalFilterConfig::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.SignalFilterConfig)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .segmentation_platform.proto.SignalFilterConfig.UkmEvent ukm_events = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_ukm_events_size()); i < n; i++) {
        const auto& repfield = this->_internal_ukm_events(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.SignalFilterConfig)
    return target;
}

size_t SignalFilterConfig::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.SignalFilterConfig)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .segmentation_platform.proto.SignalFilterConfig.UkmEvent ukm_events = 1;
    total_size += 1UL * this->_internal_ukm_events_size();
    for (const auto& msg : this->_impl_.ukm_events_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SignalFilterConfig::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SignalFilterConfig*>(&from));
}

void SignalFilterConfig::MergeFrom(const SignalFilterConfig& from)
{
    SignalFilterConfig* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.SignalFilterConfig)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.ukm_events_.MergeFrom(from._impl_.ukm_events_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SignalFilterConfig::CopyFrom(const SignalFilterConfig& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.SignalFilterConfig)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SignalFilterConfig::IsInitialized() const
{
    return true;
}

void SignalFilterConfig::InternalSwap(SignalFilterConfig* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.ukm_events_.InternalSwap(&other->_impl_.ukm_events_);
}

std::string SignalFilterConfig::GetTypeName() const
{
    return "segmentation_platform.proto.SignalFilterConfig";
}

// ===================================================================

class SqlFeature_BindValue::_Internal {
public:
    using HasBits = decltype(std::declval<SqlFeature_BindValue>()._impl_._has_bits_);
    static void set_has_param_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::segmentation_platform::proto::CustomInput& value(const SqlFeature_BindValue* msg);
    static void set_has_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::segmentation_platform::proto::CustomInput& SqlFeature_BindValue::_Internal::value(const SqlFeature_BindValue* msg)
{
    return *msg->_impl_.value_;
}
SqlFeature_BindValue::SqlFeature_BindValue(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.SqlFeature.BindValue)
}
SqlFeature_BindValue::SqlFeature_BindValue(const SqlFeature_BindValue& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SqlFeature_BindValue* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.bind_field_index_) { from._impl_.bind_field_index_ }, decltype(_impl_.value_) { nullptr }, decltype(_impl_.param_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_value()) {
        _this->_impl_.value_ = new ::segmentation_platform::proto::CustomInput(*from._impl_.value_);
    }
    _this->_impl_.param_type_ = from._impl_.param_type_;
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.SqlFeature.BindValue)
}

inline void SqlFeature_BindValue::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.bind_field_index_) { arena },
        decltype(_impl_.value_) { nullptr }, decltype(_impl_.param_type_) { 0 } };
}

SqlFeature_BindValue::~SqlFeature_BindValue()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.SqlFeature.BindValue)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SqlFeature_BindValue::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.bind_field_index_.~RepeatedField();
    if (this != internal_default_instance())
        delete _impl_.value_;
}

void SqlFeature_BindValue::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SqlFeature_BindValue::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.SqlFeature.BindValue)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.bind_field_index_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.value_ != nullptr);
        _impl_.value_->Clear();
    }
    _impl_.param_type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SqlFeature_BindValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated int32 bind_field_index = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_bind_field_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
            } else if (static_cast<uint8_t>(tag) == 10) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_bind_field_index(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .segmentation_platform.proto.SqlFeature.BindValue.ParamType param_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::segmentation_platform::proto::SqlFeature_BindValue_ParamType_IsValid(val))) {
                    _internal_set_param_type(static_cast<::segmentation_platform::proto::SqlFeature_BindValue_ParamType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .segmentation_platform.proto.CustomInput value = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SqlFeature_BindValue::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.SqlFeature.BindValue)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated int32 bind_field_index = 1;
    for (int i = 0, n = this->_internal_bind_field_index_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_bind_field_index(i), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .segmentation_platform.proto.SqlFeature.BindValue.ParamType param_type = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_param_type(), target);
    }

    // optional .segmentation_platform.proto.CustomInput value = 3;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::value(this), _Internal::value(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.SqlFeature.BindValue)
    return target;
}

size_t SqlFeature_BindValue::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.SqlFeature.BindValue)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 bind_field_index = 1;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.bind_field_index_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_bind_field_index_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .segmentation_platform.proto.CustomInput value = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.value_);
        }

        // optional .segmentation_platform.proto.SqlFeature.BindValue.ParamType param_type = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_param_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SqlFeature_BindValue::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SqlFeature_BindValue*>(&from));
}

void SqlFeature_BindValue::MergeFrom(const SqlFeature_BindValue& from)
{
    SqlFeature_BindValue* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.SqlFeature.BindValue)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.bind_field_index_.MergeFrom(from._impl_.bind_field_index_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_value()->::segmentation_platform::proto::CustomInput::MergeFrom(from._internal_value());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.param_type_ = from._impl_.param_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SqlFeature_BindValue::CopyFrom(const SqlFeature_BindValue& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.SqlFeature.BindValue)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SqlFeature_BindValue::IsInitialized() const
{
    return true;
}

void SqlFeature_BindValue::InternalSwap(SqlFeature_BindValue* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.bind_field_index_.InternalSwap(&other->_impl_.bind_field_index_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(SqlFeature_BindValue, _impl_.param_type_)
        + sizeof(SqlFeature_BindValue::_impl_.param_type_) - PROTOBUF_FIELD_OFFSET(SqlFeature_BindValue, _impl_.value_)>(
        reinterpret_cast<char*>(&_impl_.value_), reinterpret_cast<char*>(&other->_impl_.value_));
}

std::string SqlFeature_BindValue::GetTypeName() const
{
    return "segmentation_platform.proto.SqlFeature.BindValue";
}

// ===================================================================

class SqlFeature::_Internal {
public:
    using HasBits = decltype(std::declval<SqlFeature>()._impl_._has_bits_);
    static void set_has_sql(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::segmentation_platform::proto::SignalFilterConfig& signal_filter(const SqlFeature* msg);
    static void set_has_signal_filter(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::segmentation_platform::proto::SignalFilterConfig& SqlFeature::_Internal::signal_filter(const SqlFeature* msg)
{
    return *msg->_impl_.signal_filter_;
}
SqlFeature::SqlFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.SqlFeature)
}
SqlFeature::SqlFeature(const SqlFeature& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SqlFeature* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.bind_values_) { from._impl_.bind_values_ }, decltype(_impl_.sql_) {}, decltype(_impl_.name_) {},
        decltype(_impl_.signal_filter_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.sql_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sql_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sql()) {
        _this->_impl_.sql_.Set(from._internal_sql(), _this->GetArenaForAllocation());
    }
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_signal_filter()) {
        _this->_impl_.signal_filter_ = new ::segmentation_platform::proto::SignalFilterConfig(*from._impl_.signal_filter_);
    }
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.SqlFeature)
}

inline void SqlFeature::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.bind_values_) { arena },
        decltype(_impl_.sql_) {}, decltype(_impl_.name_) {}, decltype(_impl_.signal_filter_) { nullptr } };
    _impl_.sql_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sql_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SqlFeature::~SqlFeature()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.SqlFeature)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SqlFeature::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.bind_values_.~RepeatedPtrField();
    _impl_.sql_.Destroy();
    _impl_.name_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.signal_filter_;
}

void SqlFeature::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SqlFeature::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.SqlFeature)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.bind_values_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.sql_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.signal_filter_ != nullptr);
            _impl_.signal_filter_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SqlFeature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string sql = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_sql();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .segmentation_platform.proto.SignalFilterConfig signal_filter = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_signal_filter(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .segmentation_platform.proto.SqlFeature.BindValue bind_values = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_bind_values(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string name = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SqlFeature::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.SqlFeature)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string sql = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_sql(), target);
    }

    // optional .segmentation_platform.proto.SignalFilterConfig signal_filter = 2;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::signal_filter(this), _Internal::signal_filter(this).GetCachedSize(), target, stream);
    }

    // repeated .segmentation_platform.proto.SqlFeature.BindValue bind_values = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_bind_values_size()); i < n; i++) {
        const auto& repfield = this->_internal_bind_values(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional string name = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_name(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.SqlFeature)
    return target;
}

size_t SqlFeature::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.SqlFeature)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .segmentation_platform.proto.SqlFeature.BindValue bind_values = 3;
    total_size += 1UL * this->_internal_bind_values_size();
    for (const auto& msg : this->_impl_.bind_values_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string sql = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_sql());
        }

        // optional string name = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional .segmentation_platform.proto.SignalFilterConfig signal_filter = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.signal_filter_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SqlFeature::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SqlFeature*>(&from));
}

void SqlFeature::MergeFrom(const SqlFeature& from)
{
    SqlFeature* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.SqlFeature)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.bind_values_.MergeFrom(from._impl_.bind_values_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_sql(from._internal_sql());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_signal_filter()->::segmentation_platform::proto::SignalFilterConfig::MergeFrom(from._internal_signal_filter());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SqlFeature::CopyFrom(const SqlFeature& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.SqlFeature)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SqlFeature::IsInitialized() const
{
    return true;
}

void SqlFeature::InternalSwap(SqlFeature* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.bind_values_.InternalSwap(&other->_impl_.bind_values_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.sql_, lhs_arena, &other->_impl_.sql_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    swap(_impl_.signal_filter_, other->_impl_.signal_filter_);
}

std::string SqlFeature::GetTypeName() const
{
    return "segmentation_platform.proto.SqlFeature";
}

// ===================================================================

class InputFeature::_Internal {
public:
    static const ::segmentation_platform::proto::UMAFeature& uma_feature(const InputFeature* msg);
    static const ::segmentation_platform::proto::CustomInput& custom_input(const InputFeature* msg);
    static const ::segmentation_platform::proto::SqlFeature& sql_feature(const InputFeature* msg);
};

const ::segmentation_platform::proto::UMAFeature& InputFeature::_Internal::uma_feature(const InputFeature* msg)
{
    return *msg->_impl_.Feature_.uma_feature_;
}
const ::segmentation_platform::proto::CustomInput& InputFeature::_Internal::custom_input(const InputFeature* msg)
{
    return *msg->_impl_.Feature_.custom_input_;
}
const ::segmentation_platform::proto::SqlFeature& InputFeature::_Internal::sql_feature(const InputFeature* msg)
{
    return *msg->_impl_.Feature_.sql_feature_;
}
void InputFeature::set_allocated_uma_feature(::segmentation_platform::proto::UMAFeature* uma_feature)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_Feature();
    if (uma_feature) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uma_feature);
        if (message_arena != submessage_arena) {
            uma_feature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, uma_feature, submessage_arena);
        }
        set_has_uma_feature();
        _impl_.Feature_.uma_feature_ = uma_feature;
    }
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.InputFeature.uma_feature)
}
void InputFeature::set_allocated_custom_input(::segmentation_platform::proto::CustomInput* custom_input)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_Feature();
    if (custom_input) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(custom_input);
        if (message_arena != submessage_arena) {
            custom_input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, custom_input, submessage_arena);
        }
        set_has_custom_input();
        _impl_.Feature_.custom_input_ = custom_input;
    }
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.InputFeature.custom_input)
}
void InputFeature::set_allocated_sql_feature(::segmentation_platform::proto::SqlFeature* sql_feature)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_Feature();
    if (sql_feature) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sql_feature);
        if (message_arena != submessage_arena) {
            sql_feature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, sql_feature, submessage_arena);
        }
        set_has_sql_feature();
        _impl_.Feature_.sql_feature_ = sql_feature;
    }
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.InputFeature.sql_feature)
}
InputFeature::InputFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.InputFeature)
}
InputFeature::InputFeature(const InputFeature& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    InputFeature* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.Feature_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_Feature();
    switch (from.Feature_case()) {
    case kUmaFeature: {
        _this->_internal_mutable_uma_feature()->::segmentation_platform::proto::UMAFeature::MergeFrom(from._internal_uma_feature());
        break;
    }
    case kCustomInput: {
        _this->_internal_mutable_custom_input()->::segmentation_platform::proto::CustomInput::MergeFrom(from._internal_custom_input());
        break;
    }
    case kSqlFeature: {
        _this->_internal_mutable_sql_feature()->::segmentation_platform::proto::SqlFeature::MergeFrom(from._internal_sql_feature());
        break;
    }
    case FEATURE_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.InputFeature)
}

inline void InputFeature::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.Feature_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_Feature();
}

InputFeature::~InputFeature()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.InputFeature)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void InputFeature::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_Feature()) {
        clear_Feature();
    }
}

void InputFeature::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void InputFeature::clear_Feature()
{
    // @@protoc_insertion_point(one_of_clear_start:segmentation_platform.proto.InputFeature)
    switch (Feature_case()) {
    case kUmaFeature: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.Feature_.uma_feature_;
        }
        break;
    }
    case kCustomInput: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.Feature_.custom_input_;
        }
        break;
    }
    case kSqlFeature: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.Feature_.sql_feature_;
        }
        break;
    }
    case FEATURE_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = FEATURE_NOT_SET;
}

void InputFeature::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.InputFeature)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_Feature();
    _internal_metadata_.Clear<std::string>();
}

const char* InputFeature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .segmentation_platform.proto.UMAFeature uma_feature = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_uma_feature(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .segmentation_platform.proto.CustomInput custom_input = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_custom_input(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .segmentation_platform.proto.SqlFeature sql_feature = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_sql_feature(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* InputFeature::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.InputFeature)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (Feature_case()) {
    case kUmaFeature: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::uma_feature(this), _Internal::uma_feature(this).GetCachedSize(), target, stream);
        break;
    }
    case kCustomInput: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::custom_input(this), _Internal::custom_input(this).GetCachedSize(), target, stream);
        break;
    }
    case kSqlFeature: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::sql_feature(this), _Internal::sql_feature(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.InputFeature)
    return target;
}

size_t InputFeature::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.InputFeature)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (Feature_case()) {
    // .segmentation_platform.proto.UMAFeature uma_feature = 1;
    case kUmaFeature: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.Feature_.uma_feature_);
        break;
    }
    // .segmentation_platform.proto.CustomInput custom_input = 2;
    case kCustomInput: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.Feature_.custom_input_);
        break;
    }
    // .segmentation_platform.proto.SqlFeature sql_feature = 3;
    case kSqlFeature: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.Feature_.sql_feature_);
        break;
    }
    case FEATURE_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void InputFeature::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const InputFeature*>(&from));
}

void InputFeature::MergeFrom(const InputFeature& from)
{
    InputFeature* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.InputFeature)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.Feature_case()) {
    case kUmaFeature: {
        _this->_internal_mutable_uma_feature()->::segmentation_platform::proto::UMAFeature::MergeFrom(from._internal_uma_feature());
        break;
    }
    case kCustomInput: {
        _this->_internal_mutable_custom_input()->::segmentation_platform::proto::CustomInput::MergeFrom(from._internal_custom_input());
        break;
    }
    case kSqlFeature: {
        _this->_internal_mutable_sql_feature()->::segmentation_platform::proto::SqlFeature::MergeFrom(from._internal_sql_feature());
        break;
    }
    case FEATURE_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InputFeature::CopyFrom(const InputFeature& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.InputFeature)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool InputFeature::IsInitialized() const
{
    return true;
}

void InputFeature::InternalSwap(InputFeature* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.Feature_, other->_impl_.Feature_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string InputFeature::GetTypeName() const
{
    return "segmentation_platform.proto.InputFeature";
}

// ===================================================================

class TrainingOutputs_TriggerConfig_ObservationTrigger::_Internal {
public:
    static const ::segmentation_platform::proto::UMAOutput& uma_trigger(const TrainingOutputs_TriggerConfig_ObservationTrigger* msg);
};

const ::segmentation_platform::proto::UMAOutput& TrainingOutputs_TriggerConfig_ObservationTrigger::_Internal::uma_trigger(
    const TrainingOutputs_TriggerConfig_ObservationTrigger* msg)
{
    return *msg->_impl_.trigger_.uma_trigger_;
}
void TrainingOutputs_TriggerConfig_ObservationTrigger::set_allocated_uma_trigger(::segmentation_platform::proto::UMAOutput* uma_trigger)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_trigger();
    if (uma_trigger) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uma_trigger);
        if (message_arena != submessage_arena) {
            uma_trigger = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, uma_trigger, submessage_arena);
        }
        set_has_uma_trigger();
        _impl_.trigger_.uma_trigger_ = uma_trigger;
    }
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger.uma_trigger)
}
TrainingOutputs_TriggerConfig_ObservationTrigger::TrainingOutputs_TriggerConfig_ObservationTrigger(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger)
}
TrainingOutputs_TriggerConfig_ObservationTrigger::TrainingOutputs_TriggerConfig_ObservationTrigger(const TrainingOutputs_TriggerConfig_ObservationTrigger& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TrainingOutputs_TriggerConfig_ObservationTrigger* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.trigger_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_trigger();
    switch (from.trigger_case()) {
    case kDelaySec: {
        _this->_internal_set_delay_sec(from._internal_delay_sec());
        break;
    }
    case kUmaTrigger: {
        _this->_internal_mutable_uma_trigger()->::segmentation_platform::proto::UMAOutput::MergeFrom(from._internal_uma_trigger());
        break;
    }
    case TRIGGER_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger)
}

inline void TrainingOutputs_TriggerConfig_ObservationTrigger::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.trigger_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_trigger();
}

TrainingOutputs_TriggerConfig_ObservationTrigger::~TrainingOutputs_TriggerConfig_ObservationTrigger()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TrainingOutputs_TriggerConfig_ObservationTrigger::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_trigger()) {
        clear_trigger();
    }
}

void TrainingOutputs_TriggerConfig_ObservationTrigger::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TrainingOutputs_TriggerConfig_ObservationTrigger::clear_trigger()
{
    // @@protoc_insertion_point(one_of_clear_start:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger)
    switch (trigger_case()) {
    case kDelaySec: {
        // No need to clear
        break;
    }
    case kUmaTrigger: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.trigger_.uma_trigger_;
        }
        break;
    }
    case TRIGGER_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = TRIGGER_NOT_SET;
}

void TrainingOutputs_TriggerConfig_ObservationTrigger::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_trigger();
    _internal_metadata_.Clear<std::string>();
}

const char* TrainingOutputs_TriggerConfig_ObservationTrigger::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // uint64 delay_sec = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _internal_set_delay_sec(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .segmentation_platform.proto.UMAOutput uma_trigger = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_uma_trigger(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TrainingOutputs_TriggerConfig_ObservationTrigger::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (trigger_case()) {
    case kDelaySec: {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_delay_sec(), target);
        break;
    }
    case kUmaTrigger: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::uma_trigger(this), _Internal::uma_trigger(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger)
    return target;
}

size_t TrainingOutputs_TriggerConfig_ObservationTrigger::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (trigger_case()) {
    // uint64 delay_sec = 1;
    case kDelaySec: {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_delay_sec());
        break;
    }
    // .segmentation_platform.proto.UMAOutput uma_trigger = 2;
    case kUmaTrigger: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.trigger_.uma_trigger_);
        break;
    }
    case TRIGGER_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TrainingOutputs_TriggerConfig_ObservationTrigger::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TrainingOutputs_TriggerConfig_ObservationTrigger*>(&from));
}

void TrainingOutputs_TriggerConfig_ObservationTrigger::MergeFrom(const TrainingOutputs_TriggerConfig_ObservationTrigger& from)
{
    TrainingOutputs_TriggerConfig_ObservationTrigger* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.trigger_case()) {
    case kDelaySec: {
        _this->_internal_set_delay_sec(from._internal_delay_sec());
        break;
    }
    case kUmaTrigger: {
        _this->_internal_mutable_uma_trigger()->::segmentation_platform::proto::UMAOutput::MergeFrom(from._internal_uma_trigger());
        break;
    }
    case TRIGGER_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TrainingOutputs_TriggerConfig_ObservationTrigger::CopyFrom(const TrainingOutputs_TriggerConfig_ObservationTrigger& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TrainingOutputs_TriggerConfig_ObservationTrigger::IsInitialized() const
{
    return true;
}

void TrainingOutputs_TriggerConfig_ObservationTrigger::InternalSwap(TrainingOutputs_TriggerConfig_ObservationTrigger* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.trigger_, other->_impl_.trigger_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string TrainingOutputs_TriggerConfig_ObservationTrigger::GetTypeName() const
{
    return "segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger";
}

// ===================================================================

class TrainingOutputs_TriggerConfig::_Internal {
public:
    using HasBits = decltype(std::declval<TrainingOutputs_TriggerConfig>()._impl_._has_bits_);
    static void set_has_decision_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_use_exact_prediction_time(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_use_flexible_observation_time(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

TrainingOutputs_TriggerConfig::TrainingOutputs_TriggerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.TrainingOutputs.TriggerConfig)
}
TrainingOutputs_TriggerConfig::TrainingOutputs_TriggerConfig(const TrainingOutputs_TriggerConfig& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TrainingOutputs_TriggerConfig* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.observation_trigger_) { from._impl_.observation_trigger_ }, decltype(_impl_.decision_type_) {},
        decltype(_impl_.use_exact_prediction_time_) {}, decltype(_impl_.use_flexible_observation_time_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.decision_type_, &from._impl_.decision_type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.use_flexible_observation_time_) - reinterpret_cast<char*>(&_impl_.decision_type_))
            + sizeof(_impl_.use_flexible_observation_time_));
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.TrainingOutputs.TriggerConfig)
}

inline void TrainingOutputs_TriggerConfig::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.observation_trigger_) { arena },
        decltype(_impl_.decision_type_) { 0 }, decltype(_impl_.use_exact_prediction_time_) { false },
        decltype(_impl_.use_flexible_observation_time_) { false } };
}

TrainingOutputs_TriggerConfig::~TrainingOutputs_TriggerConfig()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.TrainingOutputs.TriggerConfig)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TrainingOutputs_TriggerConfig::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.observation_trigger_.~RepeatedPtrField();
}

void TrainingOutputs_TriggerConfig::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TrainingOutputs_TriggerConfig::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.TrainingOutputs.TriggerConfig)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.observation_trigger_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        ::memset(&_impl_.decision_type_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.use_flexible_observation_time_) - reinterpret_cast<char*>(&_impl_.decision_type_))
                + sizeof(_impl_.use_flexible_observation_time_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* TrainingOutputs_TriggerConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .segmentation_platform.proto.TrainingOutputs.TriggerConfig.DecisionType decision_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::segmentation_platform::proto::TrainingOutputs_TriggerConfig_DecisionType_IsValid(val))) {
                    _internal_set_decision_type(static_cast<::segmentation_platform::proto::TrainingOutputs_TriggerConfig_DecisionType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated .segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger observation_trigger = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_observation_trigger(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool use_exact_prediction_time = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_use_exact_prediction_time(&has_bits);
                _impl_.use_exact_prediction_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool use_flexible_observation_time = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_use_flexible_observation_time(&has_bits);
                _impl_.use_flexible_observation_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TrainingOutputs_TriggerConfig::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.TrainingOutputs.TriggerConfig)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .segmentation_platform.proto.TrainingOutputs.TriggerConfig.DecisionType decision_type = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_decision_type(), target);
    }

    // repeated .segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger observation_trigger = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_observation_trigger_size()); i < n; i++) {
        const auto& repfield = this->_internal_observation_trigger(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bool use_exact_prediction_time = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_use_exact_prediction_time(), target);
    }

    // optional bool use_flexible_observation_time = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_use_flexible_observation_time(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.TrainingOutputs.TriggerConfig)
    return target;
}

size_t TrainingOutputs_TriggerConfig::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.TrainingOutputs.TriggerConfig)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .segmentation_platform.proto.TrainingOutputs.TriggerConfig.ObservationTrigger observation_trigger = 2;
    total_size += 1UL * this->_internal_observation_trigger_size();
    for (const auto& msg : this->_impl_.observation_trigger_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional .segmentation_platform.proto.TrainingOutputs.TriggerConfig.DecisionType decision_type = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_decision_type());
        }

        // optional bool use_exact_prediction_time = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }

        // optional bool use_flexible_observation_time = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TrainingOutputs_TriggerConfig::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TrainingOutputs_TriggerConfig*>(&from));
}

void TrainingOutputs_TriggerConfig::MergeFrom(const TrainingOutputs_TriggerConfig& from)
{
    TrainingOutputs_TriggerConfig* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.TrainingOutputs.TriggerConfig)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.observation_trigger_.MergeFrom(from._impl_.observation_trigger_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.decision_type_ = from._impl_.decision_type_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.use_exact_prediction_time_ = from._impl_.use_exact_prediction_time_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.use_flexible_observation_time_ = from._impl_.use_flexible_observation_time_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TrainingOutputs_TriggerConfig::CopyFrom(const TrainingOutputs_TriggerConfig& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.TrainingOutputs.TriggerConfig)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TrainingOutputs_TriggerConfig::IsInitialized() const
{
    return true;
}

void TrainingOutputs_TriggerConfig::InternalSwap(TrainingOutputs_TriggerConfig* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.observation_trigger_.InternalSwap(&other->_impl_.observation_trigger_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(TrainingOutputs_TriggerConfig, _impl_.use_flexible_observation_time_)
        + sizeof(TrainingOutputs_TriggerConfig::_impl_.use_flexible_observation_time_)
        - PROTOBUF_FIELD_OFFSET(TrainingOutputs_TriggerConfig, _impl_.decision_type_)>(
        reinterpret_cast<char*>(&_impl_.decision_type_), reinterpret_cast<char*>(&other->_impl_.decision_type_));
}

std::string TrainingOutputs_TriggerConfig::GetTypeName() const
{
    return "segmentation_platform.proto.TrainingOutputs.TriggerConfig";
}

// ===================================================================

class TrainingOutputs::_Internal {
public:
    using HasBits = decltype(std::declval<TrainingOutputs>()._impl_._has_bits_);
    static const ::segmentation_platform::proto::TrainingOutputs_TriggerConfig& trigger_config(const TrainingOutputs* msg);
    static void set_has_trigger_config(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::segmentation_platform::proto::TrainingOutputs_TriggerConfig& TrainingOutputs::_Internal::trigger_config(const TrainingOutputs* msg)
{
    return *msg->_impl_.trigger_config_;
}
TrainingOutputs::TrainingOutputs(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.TrainingOutputs)
}
TrainingOutputs::TrainingOutputs(const TrainingOutputs& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TrainingOutputs* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.outputs_) { from._impl_.outputs_ }, decltype(_impl_.trigger_config_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_trigger_config()) {
        _this->_impl_.trigger_config_ = new ::segmentation_platform::proto::TrainingOutputs_TriggerConfig(*from._impl_.trigger_config_);
    }
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.TrainingOutputs)
}

inline void TrainingOutputs::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.outputs_) { arena },
        decltype(_impl_.trigger_config_) { nullptr } };
}

TrainingOutputs::~TrainingOutputs()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.TrainingOutputs)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TrainingOutputs::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.outputs_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.trigger_config_;
}

void TrainingOutputs::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TrainingOutputs::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.TrainingOutputs)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.outputs_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.trigger_config_ != nullptr);
        _impl_.trigger_config_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* TrainingOutputs::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .segmentation_platform.proto.TrainingOutput outputs = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_outputs(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .segmentation_platform.proto.TrainingOutputs.TriggerConfig trigger_config = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_trigger_config(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TrainingOutputs::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.TrainingOutputs)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .segmentation_platform.proto.TrainingOutput outputs = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_outputs_size()); i < n; i++) {
        const auto& repfield = this->_internal_outputs(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .segmentation_platform.proto.TrainingOutputs.TriggerConfig trigger_config = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::trigger_config(this), _Internal::trigger_config(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.TrainingOutputs)
    return target;
}

size_t TrainingOutputs::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.TrainingOutputs)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .segmentation_platform.proto.TrainingOutput outputs = 1;
    total_size += 1UL * this->_internal_outputs_size();
    for (const auto& msg : this->_impl_.outputs_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional .segmentation_platform.proto.TrainingOutputs.TriggerConfig trigger_config = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.trigger_config_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TrainingOutputs::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TrainingOutputs*>(&from));
}

void TrainingOutputs::MergeFrom(const TrainingOutputs& from)
{
    TrainingOutputs* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.TrainingOutputs)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.outputs_.MergeFrom(from._impl_.outputs_);
    if (from._internal_has_trigger_config()) {
        _this->_internal_mutable_trigger_config()->::segmentation_platform::proto::TrainingOutputs_TriggerConfig::MergeFrom(from._internal_trigger_config());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TrainingOutputs::CopyFrom(const TrainingOutputs& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.TrainingOutputs)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TrainingOutputs::IsInitialized() const
{
    return true;
}

void TrainingOutputs::InternalSwap(TrainingOutputs* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.outputs_.InternalSwap(&other->_impl_.outputs_);
    swap(_impl_.trigger_config_, other->_impl_.trigger_config_);
}

std::string TrainingOutputs::GetTypeName() const
{
    return "segmentation_platform.proto.TrainingOutputs";
}

// ===================================================================

class TrainingOutput::_Internal {
public:
    static const ::segmentation_platform::proto::UMAOutput& uma_output(const TrainingOutput* msg);
};

const ::segmentation_platform::proto::UMAOutput& TrainingOutput::_Internal::uma_output(const TrainingOutput* msg)
{
    return *msg->_impl_.output_.uma_output_;
}
void TrainingOutput::set_allocated_uma_output(::segmentation_platform::proto::UMAOutput* uma_output)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_output();
    if (uma_output) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uma_output);
        if (message_arena != submessage_arena) {
            uma_output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, uma_output, submessage_arena);
        }
        set_has_uma_output();
        _impl_.output_.uma_output_ = uma_output;
    }
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.TrainingOutput.uma_output)
}
TrainingOutput::TrainingOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.TrainingOutput)
}
TrainingOutput::TrainingOutput(const TrainingOutput& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TrainingOutput* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.output_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_output();
    switch (from.output_case()) {
    case kUmaOutput: {
        _this->_internal_mutable_uma_output()->::segmentation_platform::proto::UMAOutput::MergeFrom(from._internal_uma_output());
        break;
    }
    case OUTPUT_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.TrainingOutput)
}

inline void TrainingOutput::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.output_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_output();
}

TrainingOutput::~TrainingOutput()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.TrainingOutput)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TrainingOutput::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_output()) {
        clear_output();
    }
}

void TrainingOutput::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TrainingOutput::clear_output()
{
    // @@protoc_insertion_point(one_of_clear_start:segmentation_platform.proto.TrainingOutput)
    switch (output_case()) {
    case kUmaOutput: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.output_.uma_output_;
        }
        break;
    }
    case OUTPUT_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = OUTPUT_NOT_SET;
}

void TrainingOutput::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.TrainingOutput)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_output();
    _internal_metadata_.Clear<std::string>();
}

const char* TrainingOutput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .segmentation_platform.proto.UMAOutput uma_output = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_uma_output(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TrainingOutput::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.TrainingOutput)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .segmentation_platform.proto.UMAOutput uma_output = 1;
    if (_internal_has_uma_output()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::uma_output(this), _Internal::uma_output(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.TrainingOutput)
    return target;
}

size_t TrainingOutput::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.TrainingOutput)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (output_case()) {
    // .segmentation_platform.proto.UMAOutput uma_output = 1;
    case kUmaOutput: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.output_.uma_output_);
        break;
    }
    case OUTPUT_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TrainingOutput::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TrainingOutput*>(&from));
}

void TrainingOutput::MergeFrom(const TrainingOutput& from)
{
    TrainingOutput* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.TrainingOutput)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.output_case()) {
    case kUmaOutput: {
        _this->_internal_mutable_uma_output()->::segmentation_platform::proto::UMAOutput::MergeFrom(from._internal_uma_output());
        break;
    }
    case OUTPUT_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TrainingOutput::CopyFrom(const TrainingOutput& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.TrainingOutput)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TrainingOutput::IsInitialized() const
{
    return true;
}

void TrainingOutput::InternalSwap(TrainingOutput* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.output_, other->_impl_.output_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string TrainingOutput::GetTypeName() const
{
    return "segmentation_platform.proto.TrainingOutput";
}

// ===================================================================

class UMAOutput::_Internal {
public:
    using HasBits = decltype(std::declval<UMAOutput>()._impl_._has_bits_);
    static const ::segmentation_platform::proto::UMAFeature& uma_feature(const UMAOutput* msg);
    static void set_has_uma_feature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_duration(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::segmentation_platform::proto::UMAFeature& UMAOutput::_Internal::uma_feature(const UMAOutput* msg)
{
    return *msg->_impl_.uma_feature_;
}
UMAOutput::UMAOutput(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.UMAOutput)
}
UMAOutput::UMAOutput(const UMAOutput& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UMAOutput* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.uma_feature_) { nullptr }, decltype(_impl_.duration_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_uma_feature()) {
        _this->_impl_.uma_feature_ = new ::segmentation_platform::proto::UMAFeature(*from._impl_.uma_feature_);
    }
    _this->_impl_.duration_ = from._impl_.duration_;
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.UMAOutput)
}

inline void UMAOutput::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.uma_feature_) { nullptr },
        decltype(_impl_.duration_) { uint64_t { 0u } } };
}

UMAOutput::~UMAOutput()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.UMAOutput)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UMAOutput::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.uma_feature_;
}

void UMAOutput::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UMAOutput::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.UMAOutput)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.uma_feature_ != nullptr);
        _impl_.uma_feature_->Clear();
    }
    _impl_.duration_ = uint64_t { 0u };
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UMAOutput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .segmentation_platform.proto.UMAFeature uma_feature = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_uma_feature(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint64 duration = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_duration(&has_bits);
                _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UMAOutput::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.UMAOutput)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .segmentation_platform.proto.UMAFeature uma_feature = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::uma_feature(this), _Internal::uma_feature(this).GetCachedSize(), target, stream);
    }

    // optional uint64 duration = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_duration(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.UMAOutput)
    return target;
}

size_t UMAOutput::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.UMAOutput)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .segmentation_platform.proto.UMAFeature uma_feature = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.uma_feature_);
        }

        // optional uint64 duration = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_duration());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UMAOutput::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UMAOutput*>(&from));
}

void UMAOutput::MergeFrom(const UMAOutput& from)
{
    UMAOutput* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.UMAOutput)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_uma_feature()->::segmentation_platform::proto::UMAFeature::MergeFrom(from._internal_uma_feature());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.duration_ = from._impl_.duration_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UMAOutput::CopyFrom(const UMAOutput& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.UMAOutput)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UMAOutput::IsInitialized() const
{
    return true;
}

void UMAOutput::InternalSwap(UMAOutput* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(UMAOutput, _impl_.duration_) + sizeof(UMAOutput::_impl_.duration_)
        - PROTOBUF_FIELD_OFFSET(UMAOutput, _impl_.uma_feature_)>(
        reinterpret_cast<char*>(&_impl_.uma_feature_), reinterpret_cast<char*>(&other->_impl_.uma_feature_));
}

std::string UMAOutput::GetTypeName() const
{
    return "segmentation_platform.proto.UMAOutput";
}

// ===================================================================

class SegmentationModelMetadata_DiscreteMapping_Entry::_Internal {
public:
    using HasBits = decltype(std::declval<SegmentationModelMetadata_DiscreteMapping_Entry>()._impl_._has_bits_);
    static void set_has_min_result(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_rank(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

SegmentationModelMetadata_DiscreteMapping_Entry::SegmentationModelMetadata_DiscreteMapping_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
}
SegmentationModelMetadata_DiscreteMapping_Entry::SegmentationModelMetadata_DiscreteMapping_Entry(const SegmentationModelMetadata_DiscreteMapping_Entry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SegmentationModelMetadata_DiscreteMapping_Entry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.rank_) {},
        decltype(_impl_.min_result_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.rank_, &from._impl_.rank_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.min_result_) - reinterpret_cast<char*>(&_impl_.rank_)) + sizeof(_impl_.min_result_));
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
}

inline void SegmentationModelMetadata_DiscreteMapping_Entry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.rank_) { int64_t { 0 } },
        decltype(_impl_.min_result_) { 0 } };
}

SegmentationModelMetadata_DiscreteMapping_Entry::~SegmentationModelMetadata_DiscreteMapping_Entry()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SegmentationModelMetadata_DiscreteMapping_Entry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SegmentationModelMetadata_DiscreteMapping_Entry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SegmentationModelMetadata_DiscreteMapping_Entry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.rank_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.min_result_) - reinterpret_cast<char*>(&_impl_.rank_)) + sizeof(_impl_.min_result_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SegmentationModelMetadata_DiscreteMapping_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional float min_result = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
                _Internal::set_has_min_result(&has_bits);
                _impl_.min_result_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional int64 rank = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_rank(&has_bits);
                _impl_.rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SegmentationModelMetadata_DiscreteMapping_Entry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional float min_result = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_min_result(), target);
    }

    // optional int64 rank = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_rank(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
    return target;
}

size_t SegmentationModelMetadata_DiscreteMapping_Entry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int64 rank = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_rank());
        }

        // optional float min_result = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 4;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SegmentationModelMetadata_DiscreteMapping_Entry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SegmentationModelMetadata_DiscreteMapping_Entry*>(&from));
}

void SegmentationModelMetadata_DiscreteMapping_Entry::MergeFrom(const SegmentationModelMetadata_DiscreteMapping_Entry& from)
{
    SegmentationModelMetadata_DiscreteMapping_Entry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.rank_ = from._impl_.rank_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.min_result_ = from._impl_.min_result_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SegmentationModelMetadata_DiscreteMapping_Entry::CopyFrom(const SegmentationModelMetadata_DiscreteMapping_Entry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SegmentationModelMetadata_DiscreteMapping_Entry::IsInitialized() const
{
    return true;
}

void SegmentationModelMetadata_DiscreteMapping_Entry::InternalSwap(SegmentationModelMetadata_DiscreteMapping_Entry* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(SegmentationModelMetadata_DiscreteMapping_Entry, _impl_.min_result_)
        + sizeof(SegmentationModelMetadata_DiscreteMapping_Entry::_impl_.min_result_)
        - PROTOBUF_FIELD_OFFSET(SegmentationModelMetadata_DiscreteMapping_Entry, _impl_.rank_)>(
        reinterpret_cast<char*>(&_impl_.rank_), reinterpret_cast<char*>(&other->_impl_.rank_));
}

std::string SegmentationModelMetadata_DiscreteMapping_Entry::GetTypeName() const
{
    return "segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry";
}

// ===================================================================

class SegmentationModelMetadata_DiscreteMapping::_Internal {
public:
};

SegmentationModelMetadata_DiscreteMapping::SegmentationModelMetadata_DiscreteMapping(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
}
SegmentationModelMetadata_DiscreteMapping::SegmentationModelMetadata_DiscreteMapping(const SegmentationModelMetadata_DiscreteMapping& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SegmentationModelMetadata_DiscreteMapping* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.entries_) { from._impl_.entries_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
}

inline void SegmentationModelMetadata_DiscreteMapping::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.entries_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

SegmentationModelMetadata_DiscreteMapping::~SegmentationModelMetadata_DiscreteMapping()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SegmentationModelMetadata_DiscreteMapping::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.entries_.~RepeatedPtrField();
}

void SegmentationModelMetadata_DiscreteMapping::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SegmentationModelMetadata_DiscreteMapping::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.entries_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SegmentationModelMetadata_DiscreteMapping::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry entries = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SegmentationModelMetadata_DiscreteMapping::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry entries = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
        const auto& repfield = this->_internal_entries(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
    return target;
}

size_t SegmentationModelMetadata_DiscreteMapping::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping.Entry entries = 1;
    total_size += 1UL * this->_internal_entries_size();
    for (const auto& msg : this->_impl_.entries_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SegmentationModelMetadata_DiscreteMapping::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SegmentationModelMetadata_DiscreteMapping*>(&from));
}

void SegmentationModelMetadata_DiscreteMapping::MergeFrom(const SegmentationModelMetadata_DiscreteMapping& from)
{
    SegmentationModelMetadata_DiscreteMapping* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SegmentationModelMetadata_DiscreteMapping::CopyFrom(const SegmentationModelMetadata_DiscreteMapping& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SegmentationModelMetadata_DiscreteMapping::IsInitialized() const
{
    return true;
}

void SegmentationModelMetadata_DiscreteMapping::InternalSwap(SegmentationModelMetadata_DiscreteMapping* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.entries_.InternalSwap(&other->_impl_.entries_);
}

std::string SegmentationModelMetadata_DiscreteMapping::GetTypeName() const
{
    return "segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping";
}

// ===================================================================

SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse()
{
}
SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena)
{
}
void SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse::MergeFrom(const SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse& other)
{
    MergeFromInternal(other);
}

// ===================================================================

class SegmentationModelMetadata::_Internal {
public:
    using HasBits = decltype(std::declval<SegmentationModelMetadata>()._impl_._has_bits_);
    static const ::segmentation_platform::proto::VersionInfo& version_info(const SegmentationModelMetadata* msg);
    static void set_has_version_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::segmentation_platform::proto::TrainingOutputs& training_outputs(const SegmentationModelMetadata* msg);
    static void set_has_training_outputs(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_time_unit(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_bucket_duration(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_signal_storage_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_min_signal_collection_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_result_time_to_live(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_fixed_prediction_timestamp(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_default_discrete_mapping(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_upload_tensors(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_return_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static const ::segmentation_platform::proto::OutputConfig& output_config(const SegmentationModelMetadata* msg);
    static void set_has_output_config(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::segmentation_platform::proto::VersionInfo& SegmentationModelMetadata::_Internal::version_info(const SegmentationModelMetadata* msg)
{
    return *msg->_impl_.version_info_;
}
const ::segmentation_platform::proto::TrainingOutputs& SegmentationModelMetadata::_Internal::training_outputs(const SegmentationModelMetadata* msg)
{
    return *msg->_impl_.training_outputs_;
}
const ::segmentation_platform::proto::OutputConfig& SegmentationModelMetadata::_Internal::output_config(const SegmentationModelMetadata* msg)
{
    return *msg->_impl_.output_config_;
}
void SegmentationModelMetadata::clear_output_config()
{
    if (_impl_.output_config_ != nullptr)
        _impl_.output_config_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
SegmentationModelMetadata::SegmentationModelMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.SegmentationModelMetadata)
}
SegmentationModelMetadata::SegmentationModelMetadata(const SegmentationModelMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SegmentationModelMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.features_) { from._impl_.features_ }, /*decltype(_impl_.discrete_mappings_)*/ {},
        decltype(_impl_.input_features_) { from._impl_.input_features_ }, decltype(_impl_.default_discrete_mapping_) {},
        decltype(_impl_.version_info_) { nullptr }, decltype(_impl_.training_outputs_) { nullptr }, decltype(_impl_.output_config_) { nullptr },
        decltype(_impl_.bucket_duration_) {}, decltype(_impl_.signal_storage_length_) {}, decltype(_impl_.min_signal_collection_length_) {},
        decltype(_impl_.result_time_to_live_) {}, decltype(_impl_.time_unit_) {}, decltype(_impl_.upload_tensors_) {},
        decltype(_impl_.fixed_prediction_timestamp_) {}, decltype(_impl_.return_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.discrete_mappings_.MergeFrom(from._impl_.discrete_mappings_);
    _impl_.default_discrete_mapping_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_discrete_mapping_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_default_discrete_mapping()) {
        _this->_impl_.default_discrete_mapping_.Set(from._internal_default_discrete_mapping(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_version_info()) {
        _this->_impl_.version_info_ = new ::segmentation_platform::proto::VersionInfo(*from._impl_.version_info_);
    }
    if (from._internal_has_training_outputs()) {
        _this->_impl_.training_outputs_ = new ::segmentation_platform::proto::TrainingOutputs(*from._impl_.training_outputs_);
    }
    if (from._internal_has_output_config()) {
        _this->_impl_.output_config_ = new ::segmentation_platform::proto::OutputConfig(*from._impl_.output_config_);
    }
    ::memcpy(&_impl_.bucket_duration_, &from._impl_.bucket_duration_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.return_type_) - reinterpret_cast<char*>(&_impl_.bucket_duration_)) + sizeof(_impl_.return_type_));
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.SegmentationModelMetadata)
}

inline void SegmentationModelMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.features_) { arena },
        /*decltype(_impl_.discrete_mappings_)*/ { ::_pbi::ArenaInitialized(), arena }, decltype(_impl_.input_features_) { arena },
        decltype(_impl_.default_discrete_mapping_) {}, decltype(_impl_.version_info_) { nullptr }, decltype(_impl_.training_outputs_) { nullptr },
        decltype(_impl_.output_config_) { nullptr }, decltype(_impl_.bucket_duration_) { uint64_t { 0u } },
        decltype(_impl_.signal_storage_length_) { int64_t { 0 } }, decltype(_impl_.min_signal_collection_length_) { int64_t { 0 } },
        decltype(_impl_.result_time_to_live_) { int64_t { 0 } }, decltype(_impl_.time_unit_) { 0 }, decltype(_impl_.upload_tensors_) { false },
        decltype(_impl_.fixed_prediction_timestamp_) { int64_t { 0 } }, decltype(_impl_.return_type_) { 0 } };
    _impl_.default_discrete_mapping_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_discrete_mapping_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SegmentationModelMetadata::~SegmentationModelMetadata()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.SegmentationModelMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SegmentationModelMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.features_.~RepeatedPtrField();
    _impl_.discrete_mappings_.Destruct();
    _impl_.discrete_mappings_.~MapFieldLite();
    _impl_.input_features_.~RepeatedPtrField();
    _impl_.default_discrete_mapping_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.version_info_;
    if (this != internal_default_instance())
        delete _impl_.training_outputs_;
    if (this != internal_default_instance())
        delete _impl_.output_config_;
}

void SegmentationModelMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SegmentationModelMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.SegmentationModelMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.features_.Clear();
    _impl_.discrete_mappings_.Clear();
    _impl_.input_features_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.default_discrete_mapping_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.version_info_ != nullptr);
            _impl_.version_info_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.training_outputs_ != nullptr);
            _impl_.training_outputs_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.output_config_ != nullptr);
            _impl_.output_config_->Clear();
        }
    }
    if (cached_has_bits & 0x000000f0u) {
        ::memset(&_impl_.bucket_duration_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.result_time_to_live_) - reinterpret_cast<char*>(&_impl_.bucket_duration_))
                + sizeof(_impl_.result_time_to_live_));
    }
    if (cached_has_bits & 0x00000f00u) {
        ::memset(&_impl_.time_unit_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.return_type_) - reinterpret_cast<char*>(&_impl_.time_unit_)) + sizeof(_impl_.return_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SegmentationModelMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .segmentation_platform.proto.UMAFeature features = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_features(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .segmentation_platform.proto.TimeUnit time_unit = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::segmentation_platform::proto::TimeUnit_IsValid(val))) {
                    _internal_set_time_unit(static_cast<::segmentation_platform::proto::TimeUnit>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional uint64 bucket_duration = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_bucket_duration(&has_bits);
                _impl_.bucket_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 signal_storage_length = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_signal_storage_length(&has_bits);
                _impl_.signal_storage_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 min_signal_collection_length = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_min_signal_collection_length(&has_bits);
                _impl_.min_signal_collection_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 result_time_to_live = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_result_time_to_live(&has_bits);
                _impl_.result_time_to_live_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // map<string, .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping> discrete_mappings = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(&_impl_.discrete_mappings_, ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string default_discrete_mapping = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_default_discrete_mapping();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .segmentation_platform.proto.VersionInfo version_info = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr = ctx->ParseMessage(_internal_mutable_version_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .segmentation_platform.proto.InputFeature input_features = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_input_features(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .segmentation_platform.proto.TrainingOutputs training_outputs = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_training_outputs(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool upload_tensors = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                _Internal::set_has_upload_tensors(&has_bits);
                _impl_.upload_tensors_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .segmentation_platform.proto.SegmentationModelMetadata.OutputDescription return_type = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::segmentation_platform::proto::SegmentationModelMetadata_OutputDescription_IsValid(val))) {
                    _internal_set_return_type(static_cast<::segmentation_platform::proto::SegmentationModelMetadata_OutputDescription>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .segmentation_platform.proto.OutputConfig output_config = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                ptr = ctx->ParseMessage(_internal_mutable_output_config(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 fixed_prediction_timestamp = 17;
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
                _Internal::set_has_fixed_prediction_timestamp(&has_bits);
                _impl_.fixed_prediction_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SegmentationModelMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.SegmentationModelMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .segmentation_platform.proto.UMAFeature features = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_features_size()); i < n; i++) {
        const auto& repfield = this->_internal_features(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .segmentation_platform.proto.TimeUnit time_unit = 2;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_time_unit(), target);
    }

    // optional uint64 bucket_duration = 3;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_bucket_duration(), target);
    }

    // optional int64 signal_storage_length = 4;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_signal_storage_length(), target);
    }

    // optional int64 min_signal_collection_length = 5;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_min_signal_collection_length(), target);
    }

    // optional int64 result_time_to_live = 6;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_result_time_to_live(), target);
    }

    // map<string, .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping> discrete_mappings = 7;
    if (!this->_internal_discrete_mappings().empty()) {
        using MapType = ::_pb::Map<std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>;
        using WireHelper = SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse::Funcs;
        const auto& map_field = this->_internal_discrete_mappings();
        auto check_utf8 = [](const MapType::value_type& entry) { (void)entry; };

        if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
            for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
                target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        } else {
            for (const auto& entry : map_field) {
                target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        }
    }

    // optional string default_discrete_mapping = 8;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_default_discrete_mapping(), target);
    }

    // optional .segmentation_platform.proto.VersionInfo version_info = 9;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            9, _Internal::version_info(this), _Internal::version_info(this).GetCachedSize(), target, stream);
    }

    // repeated .segmentation_platform.proto.InputFeature input_features = 10;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_input_features_size()); i < n; i++) {
        const auto& repfield = this->_internal_input_features(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .segmentation_platform.proto.TrainingOutputs training_outputs = 11;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::training_outputs(this), _Internal::training_outputs(this).GetCachedSize(), target, stream);
    }

    // optional bool upload_tensors = 13;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_upload_tensors(), target);
    }

    // optional .segmentation_platform.proto.SegmentationModelMetadata.OutputDescription return_type = 14;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(14, this->_internal_return_type(), target);
    }

    // optional .segmentation_platform.proto.OutputConfig output_config = 16;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            16, _Internal::output_config(this), _Internal::output_config(this).GetCachedSize(), target, stream);
    }

    // optional int64 fixed_prediction_timestamp = 17;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(17, this->_internal_fixed_prediction_timestamp(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.SegmentationModelMetadata)
    return target;
}

size_t SegmentationModelMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.SegmentationModelMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .segmentation_platform.proto.UMAFeature features = 1;
    total_size += 1UL * this->_internal_features_size();
    for (const auto& msg : this->_impl_.features_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // map<string, .segmentation_platform.proto.SegmentationModelMetadata.DiscreteMapping> discrete_mappings = 7;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_discrete_mappings_size());
    for (::PROTOBUF_NAMESPACE_ID::Map<std::string, ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>::const_iterator it
         = this->_internal_discrete_mappings().begin();
         it != this->_internal_discrete_mappings().end(); ++it) {
        total_size += SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
    }

    // repeated .segmentation_platform.proto.InputFeature input_features = 10;
    total_size += 1UL * this->_internal_input_features_size();
    for (const auto& msg : this->_impl_.input_features_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string default_discrete_mapping = 8;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_default_discrete_mapping());
        }

        // optional .segmentation_platform.proto.VersionInfo version_info = 9;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.version_info_);
        }

        // optional .segmentation_platform.proto.TrainingOutputs training_outputs = 11;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.training_outputs_);
        }

        // optional .segmentation_platform.proto.OutputConfig output_config = 16;
        if (cached_has_bits & 0x00000008u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.output_config_);
        }

        // optional uint64 bucket_duration = 3;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_bucket_duration());
        }

        // optional int64 signal_storage_length = 4;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_signal_storage_length());
        }

        // optional int64 min_signal_collection_length = 5;
        if (cached_has_bits & 0x00000040u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_min_signal_collection_length());
        }

        // optional int64 result_time_to_live = 6;
        if (cached_has_bits & 0x00000080u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_result_time_to_live());
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        // optional .segmentation_platform.proto.TimeUnit time_unit = 2;
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_time_unit());
        }

        // optional bool upload_tensors = 13;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + 1;
        }

        // optional int64 fixed_prediction_timestamp = 17;
        if (cached_has_bits & 0x00000400u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_fixed_prediction_timestamp());
        }

        // optional .segmentation_platform.proto.SegmentationModelMetadata.OutputDescription return_type = 14;
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_return_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SegmentationModelMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SegmentationModelMetadata*>(&from));
}

void SegmentationModelMetadata::MergeFrom(const SegmentationModelMetadata& from)
{
    SegmentationModelMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.SegmentationModelMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.features_.MergeFrom(from._impl_.features_);
    _this->_impl_.discrete_mappings_.MergeFrom(from._impl_.discrete_mappings_);
    _this->_impl_.input_features_.MergeFrom(from._impl_.input_features_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_default_discrete_mapping(from._internal_default_discrete_mapping());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_version_info()->::segmentation_platform::proto::VersionInfo::MergeFrom(from._internal_version_info());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_training_outputs()->::segmentation_platform::proto::TrainingOutputs::MergeFrom(from._internal_training_outputs());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_output_config()->::segmentation_platform::proto::OutputConfig::MergeFrom(from._internal_output_config());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.bucket_duration_ = from._impl_.bucket_duration_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.signal_storage_length_ = from._impl_.signal_storage_length_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.min_signal_collection_length_ = from._impl_.min_signal_collection_length_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.result_time_to_live_ = from._impl_.result_time_to_live_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00000f00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.time_unit_ = from._impl_.time_unit_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.upload_tensors_ = from._impl_.upload_tensors_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.fixed_prediction_timestamp_ = from._impl_.fixed_prediction_timestamp_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.return_type_ = from._impl_.return_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SegmentationModelMetadata::CopyFrom(const SegmentationModelMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.SegmentationModelMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SegmentationModelMetadata::IsInitialized() const
{
    return true;
}

void SegmentationModelMetadata::InternalSwap(SegmentationModelMetadata* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.features_.InternalSwap(&other->_impl_.features_);
    _impl_.discrete_mappings_.InternalSwap(&other->_impl_.discrete_mappings_);
    _impl_.input_features_.InternalSwap(&other->_impl_.input_features_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.default_discrete_mapping_, lhs_arena, &other->_impl_.default_discrete_mapping_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(SegmentationModelMetadata, _impl_.return_type_)
        + sizeof(SegmentationModelMetadata::_impl_.return_type_) - PROTOBUF_FIELD_OFFSET(SegmentationModelMetadata, _impl_.version_info_)>(
        reinterpret_cast<char*>(&_impl_.version_info_), reinterpret_cast<char*>(&other->_impl_.version_info_));
}

std::string SegmentationModelMetadata::GetTypeName() const
{
    return "segmentation_platform.proto.SegmentationModelMetadata";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace proto
} // namespace segmentation_platform
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::segmentation_platform::proto::VersionInfo* Arena::CreateMaybeMessage<::segmentation_platform::proto::VersionInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::VersionInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::segmentation_platform::proto::UMAFeature* Arena::CreateMaybeMessage<::segmentation_platform::proto::UMAFeature>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::UMAFeature>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::CustomInput_AdditionalArgsEntry_DoNotUse*
Arena::CreateMaybeMessage<::segmentation_platform::proto::CustomInput_AdditionalArgsEntry_DoNotUse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::CustomInput_AdditionalArgsEntry_DoNotUse>(arena);
}
template <> PROTOBUF_NOINLINE ::segmentation_platform::proto::CustomInput* Arena::CreateMaybeMessage<::segmentation_platform::proto::CustomInput>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::CustomInput>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::SignalFilterConfig_UkmEvent*
Arena::CreateMaybeMessage<::segmentation_platform::proto::SignalFilterConfig_UkmEvent>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::SignalFilterConfig_UkmEvent>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::SignalFilterConfig* Arena::CreateMaybeMessage<::segmentation_platform::proto::SignalFilterConfig>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::SignalFilterConfig>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::SqlFeature_BindValue* Arena::CreateMaybeMessage<::segmentation_platform::proto::SqlFeature_BindValue>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::SqlFeature_BindValue>(arena);
}
template <> PROTOBUF_NOINLINE ::segmentation_platform::proto::SqlFeature* Arena::CreateMaybeMessage<::segmentation_platform::proto::SqlFeature>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::SqlFeature>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::InputFeature* Arena::CreateMaybeMessage<::segmentation_platform::proto::InputFeature>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::InputFeature>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger*
Arena::CreateMaybeMessage<::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::TrainingOutputs_TriggerConfig_ObservationTrigger>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::TrainingOutputs_TriggerConfig*
Arena::CreateMaybeMessage<::segmentation_platform::proto::TrainingOutputs_TriggerConfig>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::TrainingOutputs_TriggerConfig>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::TrainingOutputs* Arena::CreateMaybeMessage<::segmentation_platform::proto::TrainingOutputs>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::TrainingOutputs>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::TrainingOutput* Arena::CreateMaybeMessage<::segmentation_platform::proto::TrainingOutput>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::TrainingOutput>(arena);
}
template <> PROTOBUF_NOINLINE ::segmentation_platform::proto::UMAOutput* Arena::CreateMaybeMessage<::segmentation_platform::proto::UMAOutput>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::UMAOutput>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry*
Arena::CreateMaybeMessage<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping_Entry>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping*
Arena::CreateMaybeMessage<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMapping>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse*
Arena::CreateMaybeMessage<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::SegmentationModelMetadata_DiscreteMappingsEntry_DoNotUse>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::SegmentationModelMetadata*
Arena::CreateMaybeMessage<::segmentation_platform::proto::SegmentationModelMetadata>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::SegmentationModelMetadata>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
