// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/segmentation_platform/public/proto/output_config.proto

#include "components/segmentation_platform/public/proto/output_config.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace segmentation_platform {
namespace proto {
PROTOBUF_CONSTEXPR Predictor_BinaryClassifier::Predictor_BinaryClassifier(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.positive_label_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.negative_label_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.threshold_)*/ 0 }
{
}
struct Predictor_BinaryClassifierDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Predictor_BinaryClassifierDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Predictor_BinaryClassifierDefaultTypeInternal()
    {
    }
    union {
        Predictor_BinaryClassifier _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Predictor_BinaryClassifierDefaultTypeInternal
    _Predictor_BinaryClassifier_default_instance_;
PROTOBUF_CONSTEXPR Predictor_MultiClassClassifier::Predictor_MultiClassClassifier(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.class_labels_)*/ {},
        /*decltype(_impl_.class_thresholds_)*/ {}, /*decltype(_impl_.top_k_outputs_)*/ int64_t { 0 }, /*decltype(_impl_.threshold_)*/ 0 }
{
}
struct Predictor_MultiClassClassifierDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Predictor_MultiClassClassifierDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Predictor_MultiClassClassifierDefaultTypeInternal()
    {
    }
    union {
        Predictor_MultiClassClassifier _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Predictor_MultiClassClassifierDefaultTypeInternal
    _Predictor_MultiClassClassifier_default_instance_;
PROTOBUF_CONSTEXPR Predictor_BinnedClassifier_Bin::Predictor_BinnedClassifier_Bin(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.label_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.min_range_)*/ 0 }
{
}
struct Predictor_BinnedClassifier_BinDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Predictor_BinnedClassifier_BinDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Predictor_BinnedClassifier_BinDefaultTypeInternal()
    {
    }
    union {
        Predictor_BinnedClassifier_Bin _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Predictor_BinnedClassifier_BinDefaultTypeInternal
    _Predictor_BinnedClassifier_Bin_default_instance_;
PROTOBUF_CONSTEXPR Predictor_BinnedClassifier::Predictor_BinnedClassifier(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.bins_)*/ {},
        /*decltype(_impl_.underflow_label_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct Predictor_BinnedClassifierDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Predictor_BinnedClassifierDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Predictor_BinnedClassifierDefaultTypeInternal()
    {
    }
    union {
        Predictor_BinnedClassifier _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Predictor_BinnedClassifierDefaultTypeInternal
    _Predictor_BinnedClassifier_default_instance_;
PROTOBUF_CONSTEXPR Predictor_Regressor::Predictor_Regressor(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct Predictor_RegressorDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Predictor_RegressorDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Predictor_RegressorDefaultTypeInternal()
    {
    }
    union {
        Predictor_Regressor _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Predictor_RegressorDefaultTypeInternal
    _Predictor_Regressor_default_instance_;
PROTOBUF_CONSTEXPR Predictor_GenericPredictor::Predictor_GenericPredictor(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.output_labels_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct Predictor_GenericPredictorDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Predictor_GenericPredictorDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Predictor_GenericPredictorDefaultTypeInternal()
    {
    }
    union {
        Predictor_GenericPredictor _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Predictor_GenericPredictorDefaultTypeInternal
    _Predictor_GenericPredictor_default_instance_;
PROTOBUF_CONSTEXPR Predictor::Predictor(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.PredictorType_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct PredictorDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PredictorDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PredictorDefaultTypeInternal()
    {
    }
    union {
        Predictor _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PredictorDefaultTypeInternal _Predictor_default_instance_;
PROTOBUF_CONSTEXPR PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse::PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse(::_pbi::ConstantInitialized)
{
}
struct PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUseDefaultTypeInternal()
    {
    }
    union {
        PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUseDefaultTypeInternal
    _PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR PredictedResultTTL::PredictedResultTTL(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.top_label_to_ttl_map_)*/ {},
        /*decltype(_impl_.default_ttl_)*/ uint64_t { 0u }, /*decltype(_impl_.time_unit_)*/ 0 }
{
}
struct PredictedResultTTLDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PredictedResultTTLDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PredictedResultTTLDefaultTypeInternal()
    {
    }
    union {
        PredictedResultTTL _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PredictedResultTTLDefaultTypeInternal _PredictedResultTTL_default_instance_;
PROTOBUF_CONSTEXPR OutputConfig::OutputConfig(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.predictor_)*/ nullptr,
        /*decltype(_impl_.predicted_result_ttl_)*/ nullptr, /*decltype(_impl_.ignore_previous_model_ttl_)*/ false }
{
}
struct OutputConfigDefaultTypeInternal {
    PROTOBUF_CONSTEXPR OutputConfigDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~OutputConfigDefaultTypeInternal()
    {
    }
    union {
        OutputConfig _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OutputConfigDefaultTypeInternal _OutputConfig_default_instance_;
} // namespace proto
} // namespace segmentation_platform
namespace segmentation_platform {
namespace proto {
bool TimeUnit_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TimeUnit_strings[8] = {};

static const char TimeUnit_names[] = "DAY"
                                     "HOUR"
                                     "MINUTE"
                                     "MONTH"
                                     "SECOND"
                                     "UNKNOWN_TIME_UNIT"
                                     "WEEK"
                                     "YEAR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TimeUnit_entries[] = {
    { { TimeUnit_names + 0, 3 }, 4 },
    { { TimeUnit_names + 3, 4 }, 5 },
    { { TimeUnit_names + 7, 6 }, 6 },
    { { TimeUnit_names + 13, 5 }, 2 },
    { { TimeUnit_names + 18, 6 }, 7 },
    { { TimeUnit_names + 24, 17 }, 0 },
    { { TimeUnit_names + 41, 4 }, 3 },
    { { TimeUnit_names + 45, 4 }, 1 },
};

static const int TimeUnit_entries_by_number[] = {
    5, // 0 -> UNKNOWN_TIME_UNIT
    7, // 1 -> YEAR
    3, // 2 -> MONTH
    6, // 3 -> WEEK
    0, // 4 -> DAY
    1, // 5 -> HOUR
    2, // 6 -> MINUTE
    4, // 7 -> SECOND
};

const std::string& TimeUnit_Name(TimeUnit value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(TimeUnit_entries, TimeUnit_entries_by_number, 8, TimeUnit_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(TimeUnit_entries, TimeUnit_entries_by_number, 8, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : TimeUnit_strings[idx].get();
}
bool TimeUnit_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TimeUnit* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(TimeUnit_entries, 8, name, &int_value);
    if (success) {
        *value = static_cast<TimeUnit>(int_value);
    }
    return success;
}

// ===================================================================

class Predictor_BinaryClassifier::_Internal {
public:
    using HasBits = decltype(std::declval<Predictor_BinaryClassifier>()._impl_._has_bits_);
    static void set_has_threshold(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_positive_label(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_negative_label(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

Predictor_BinaryClassifier::Predictor_BinaryClassifier(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.Predictor.BinaryClassifier)
}
Predictor_BinaryClassifier::Predictor_BinaryClassifier(const Predictor_BinaryClassifier& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Predictor_BinaryClassifier* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.positive_label_) {},
        decltype(_impl_.negative_label_) {}, decltype(_impl_.threshold_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.positive_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.positive_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_positive_label()) {
        _this->_impl_.positive_label_.Set(from._internal_positive_label(), _this->GetArenaForAllocation());
    }
    _impl_.negative_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.negative_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_negative_label()) {
        _this->_impl_.negative_label_.Set(from._internal_negative_label(), _this->GetArenaForAllocation());
    }
    _this->_impl_.threshold_ = from._impl_.threshold_;
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.Predictor.BinaryClassifier)
}

inline void Predictor_BinaryClassifier::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.positive_label_) {},
        decltype(_impl_.negative_label_) {}, decltype(_impl_.threshold_) { 0 } };
    _impl_.positive_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.positive_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.negative_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.negative_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Predictor_BinaryClassifier::~Predictor_BinaryClassifier()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.Predictor.BinaryClassifier)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Predictor_BinaryClassifier::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.positive_label_.Destroy();
    _impl_.negative_label_.Destroy();
}

void Predictor_BinaryClassifier::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Predictor_BinaryClassifier::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.Predictor.BinaryClassifier)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.positive_label_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.negative_label_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.threshold_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Predictor_BinaryClassifier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional float threshold = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
                _Internal::set_has_threshold(&has_bits);
                _impl_.threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional string positive_label = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_positive_label();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string negative_label = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_negative_label();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Predictor_BinaryClassifier::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.Predictor.BinaryClassifier)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional float threshold = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_threshold(), target);
    }

    // optional string positive_label = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_positive_label(), target);
    }

    // optional string negative_label = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_negative_label(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.Predictor.BinaryClassifier)
    return target;
}

size_t Predictor_BinaryClassifier::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.Predictor.BinaryClassifier)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string positive_label = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_positive_label());
        }

        // optional string negative_label = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_negative_label());
        }

        // optional float threshold = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 4;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Predictor_BinaryClassifier::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Predictor_BinaryClassifier*>(&from));
}

void Predictor_BinaryClassifier::MergeFrom(const Predictor_BinaryClassifier& from)
{
    Predictor_BinaryClassifier* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.Predictor.BinaryClassifier)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_positive_label(from._internal_positive_label());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_negative_label(from._internal_negative_label());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.threshold_ = from._impl_.threshold_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Predictor_BinaryClassifier::CopyFrom(const Predictor_BinaryClassifier& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.Predictor.BinaryClassifier)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Predictor_BinaryClassifier::IsInitialized() const
{
    return true;
}

void Predictor_BinaryClassifier::InternalSwap(Predictor_BinaryClassifier* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.positive_label_, lhs_arena, &other->_impl_.positive_label_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.negative_label_, lhs_arena, &other->_impl_.negative_label_, rhs_arena);
    swap(_impl_.threshold_, other->_impl_.threshold_);
}

std::string Predictor_BinaryClassifier::GetTypeName() const
{
    return "segmentation_platform.proto.Predictor.BinaryClassifier";
}

// ===================================================================

class Predictor_MultiClassClassifier::_Internal {
public:
    using HasBits = decltype(std::declval<Predictor_MultiClassClassifier>()._impl_._has_bits_);
    static void set_has_top_k_outputs(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_threshold(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

Predictor_MultiClassClassifier::Predictor_MultiClassClassifier(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.Predictor.MultiClassClassifier)
}
Predictor_MultiClassClassifier::Predictor_MultiClassClassifier(const Predictor_MultiClassClassifier& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Predictor_MultiClassClassifier* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.class_labels_) { from._impl_.class_labels_ }, decltype(_impl_.class_thresholds_) { from._impl_.class_thresholds_ },
        decltype(_impl_.top_k_outputs_) {}, decltype(_impl_.threshold_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.top_k_outputs_, &from._impl_.top_k_outputs_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.threshold_) - reinterpret_cast<char*>(&_impl_.top_k_outputs_)) + sizeof(_impl_.threshold_));
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.Predictor.MultiClassClassifier)
}

inline void Predictor_MultiClassClassifier::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.class_labels_) { arena },
        decltype(_impl_.class_thresholds_) { arena }, decltype(_impl_.top_k_outputs_) { int64_t { 0 } }, decltype(_impl_.threshold_) { 0 } };
}

Predictor_MultiClassClassifier::~Predictor_MultiClassClassifier()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.Predictor.MultiClassClassifier)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Predictor_MultiClassClassifier::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.class_labels_.~RepeatedPtrField();
    _impl_.class_thresholds_.~RepeatedField();
}

void Predictor_MultiClassClassifier::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Predictor_MultiClassClassifier::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.Predictor.MultiClassClassifier)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.class_labels_.Clear();
    _impl_.class_thresholds_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.top_k_outputs_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.threshold_) - reinterpret_cast<char*>(&_impl_.top_k_outputs_)) + sizeof(_impl_.threshold_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Predictor_MultiClassClassifier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 top_k_outputs = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_top_k_outputs(&has_bits);
                _impl_.top_k_outputs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string class_labels = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_class_labels();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional float threshold = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
                _Internal::set_has_threshold(&has_bits);
                _impl_.threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // repeated float class_thresholds = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_class_thresholds(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
                    ptr += sizeof(float);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<37>(ptr));
            } else if (static_cast<uint8_t>(tag) == 34) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_class_thresholds(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Predictor_MultiClassClassifier::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.Predictor.MultiClassClassifier)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 top_k_outputs = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_top_k_outputs(), target);
    }

    // repeated string class_labels = 2;
    for (int i = 0, n = this->_internal_class_labels_size(); i < n; i++) {
        const auto& s = this->_internal_class_labels(i);
        target = stream->WriteString(2, s, target);
    }

    // optional float threshold = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_threshold(), target);
    }

    // repeated float class_thresholds = 4;
    for (int i = 0, n = this->_internal_class_thresholds_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_class_thresholds(i), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.Predictor.MultiClassClassifier)
    return target;
}

size_t Predictor_MultiClassClassifier::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.Predictor.MultiClassClassifier)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string class_labels = 2;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.class_labels_.size());
    for (int i = 0, n = _impl_.class_labels_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.class_labels_.Get(i));
    }

    // repeated float class_thresholds = 4;
    {
        unsigned int count = static_cast<unsigned int>(this->_internal_class_thresholds_size());
        size_t data_size = 4UL * count;
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_class_thresholds_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int64 top_k_outputs = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_top_k_outputs());
        }

        // optional float threshold = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 4;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Predictor_MultiClassClassifier::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Predictor_MultiClassClassifier*>(&from));
}

void Predictor_MultiClassClassifier::MergeFrom(const Predictor_MultiClassClassifier& from)
{
    Predictor_MultiClassClassifier* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.Predictor.MultiClassClassifier)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.class_labels_.MergeFrom(from._impl_.class_labels_);
    _this->_impl_.class_thresholds_.MergeFrom(from._impl_.class_thresholds_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.top_k_outputs_ = from._impl_.top_k_outputs_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.threshold_ = from._impl_.threshold_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Predictor_MultiClassClassifier::CopyFrom(const Predictor_MultiClassClassifier& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.Predictor.MultiClassClassifier)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Predictor_MultiClassClassifier::IsInitialized() const
{
    return true;
}

void Predictor_MultiClassClassifier::InternalSwap(Predictor_MultiClassClassifier* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.class_labels_.InternalSwap(&other->_impl_.class_labels_);
    _impl_.class_thresholds_.InternalSwap(&other->_impl_.class_thresholds_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Predictor_MultiClassClassifier, _impl_.threshold_)
        + sizeof(Predictor_MultiClassClassifier::_impl_.threshold_) - PROTOBUF_FIELD_OFFSET(Predictor_MultiClassClassifier, _impl_.top_k_outputs_)>(
        reinterpret_cast<char*>(&_impl_.top_k_outputs_), reinterpret_cast<char*>(&other->_impl_.top_k_outputs_));
}

std::string Predictor_MultiClassClassifier::GetTypeName() const
{
    return "segmentation_platform.proto.Predictor.MultiClassClassifier";
}

// ===================================================================

class Predictor_BinnedClassifier_Bin::_Internal {
public:
    using HasBits = decltype(std::declval<Predictor_BinnedClassifier_Bin>()._impl_._has_bits_);
    static void set_has_min_range(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_label(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

Predictor_BinnedClassifier_Bin::Predictor_BinnedClassifier_Bin(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.Predictor.BinnedClassifier.Bin)
}
Predictor_BinnedClassifier_Bin::Predictor_BinnedClassifier_Bin(const Predictor_BinnedClassifier_Bin& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Predictor_BinnedClassifier_Bin* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.label_) {},
        decltype(_impl_.min_range_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_label()) {
        _this->_impl_.label_.Set(from._internal_label(), _this->GetArenaForAllocation());
    }
    _this->_impl_.min_range_ = from._impl_.min_range_;
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.Predictor.BinnedClassifier.Bin)
}

inline void Predictor_BinnedClassifier_Bin::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.label_) {}, decltype(_impl_.min_range_) { 0 } };
    _impl_.label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Predictor_BinnedClassifier_Bin::~Predictor_BinnedClassifier_Bin()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.Predictor.BinnedClassifier.Bin)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Predictor_BinnedClassifier_Bin::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.label_.Destroy();
}

void Predictor_BinnedClassifier_Bin::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Predictor_BinnedClassifier_Bin::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.Predictor.BinnedClassifier.Bin)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.label_.ClearNonDefaultToEmpty();
    }
    _impl_.min_range_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Predictor_BinnedClassifier_Bin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional float min_range = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
                _Internal::set_has_min_range(&has_bits);
                _impl_.min_range_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional string label = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_label();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Predictor_BinnedClassifier_Bin::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.Predictor.BinnedClassifier.Bin)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional float min_range = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_min_range(), target);
    }

    // optional string label = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_label(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.Predictor.BinnedClassifier.Bin)
    return target;
}

size_t Predictor_BinnedClassifier_Bin::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.Predictor.BinnedClassifier.Bin)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string label = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_label());
        }

        // optional float min_range = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 4;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Predictor_BinnedClassifier_Bin::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Predictor_BinnedClassifier_Bin*>(&from));
}

void Predictor_BinnedClassifier_Bin::MergeFrom(const Predictor_BinnedClassifier_Bin& from)
{
    Predictor_BinnedClassifier_Bin* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.Predictor.BinnedClassifier.Bin)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_label(from._internal_label());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.min_range_ = from._impl_.min_range_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Predictor_BinnedClassifier_Bin::CopyFrom(const Predictor_BinnedClassifier_Bin& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.Predictor.BinnedClassifier.Bin)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Predictor_BinnedClassifier_Bin::IsInitialized() const
{
    return true;
}

void Predictor_BinnedClassifier_Bin::InternalSwap(Predictor_BinnedClassifier_Bin* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.label_, lhs_arena, &other->_impl_.label_, rhs_arena);
    swap(_impl_.min_range_, other->_impl_.min_range_);
}

std::string Predictor_BinnedClassifier_Bin::GetTypeName() const
{
    return "segmentation_platform.proto.Predictor.BinnedClassifier.Bin";
}

// ===================================================================

class Predictor_BinnedClassifier::_Internal {
public:
    using HasBits = decltype(std::declval<Predictor_BinnedClassifier>()._impl_._has_bits_);
    static void set_has_underflow_label(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

Predictor_BinnedClassifier::Predictor_BinnedClassifier(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.Predictor.BinnedClassifier)
}
Predictor_BinnedClassifier::Predictor_BinnedClassifier(const Predictor_BinnedClassifier& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Predictor_BinnedClassifier* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.bins_) { from._impl_.bins_ }, decltype(_impl_.underflow_label_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.underflow_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.underflow_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_underflow_label()) {
        _this->_impl_.underflow_label_.Set(from._internal_underflow_label(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.Predictor.BinnedClassifier)
}

inline void Predictor_BinnedClassifier::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.bins_) { arena }, decltype(_impl_.underflow_label_) {} };
    _impl_.underflow_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.underflow_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Predictor_BinnedClassifier::~Predictor_BinnedClassifier()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.Predictor.BinnedClassifier)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Predictor_BinnedClassifier::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.bins_.~RepeatedPtrField();
    _impl_.underflow_label_.Destroy();
}

void Predictor_BinnedClassifier::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Predictor_BinnedClassifier::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.Predictor.BinnedClassifier)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.bins_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.underflow_label_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Predictor_BinnedClassifier::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .segmentation_platform.proto.Predictor.BinnedClassifier.Bin bins = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_bins(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string underflow_label = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_underflow_label();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Predictor_BinnedClassifier::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.Predictor.BinnedClassifier)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .segmentation_platform.proto.Predictor.BinnedClassifier.Bin bins = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_bins_size()); i < n; i++) {
        const auto& repfield = this->_internal_bins(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string underflow_label = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_underflow_label(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.Predictor.BinnedClassifier)
    return target;
}

size_t Predictor_BinnedClassifier::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.Predictor.BinnedClassifier)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .segmentation_platform.proto.Predictor.BinnedClassifier.Bin bins = 1;
    total_size += 1UL * this->_internal_bins_size();
    for (const auto& msg : this->_impl_.bins_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional string underflow_label = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_underflow_label());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Predictor_BinnedClassifier::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Predictor_BinnedClassifier*>(&from));
}

void Predictor_BinnedClassifier::MergeFrom(const Predictor_BinnedClassifier& from)
{
    Predictor_BinnedClassifier* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.Predictor.BinnedClassifier)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.bins_.MergeFrom(from._impl_.bins_);
    if (from._internal_has_underflow_label()) {
        _this->_internal_set_underflow_label(from._internal_underflow_label());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Predictor_BinnedClassifier::CopyFrom(const Predictor_BinnedClassifier& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.Predictor.BinnedClassifier)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Predictor_BinnedClassifier::IsInitialized() const
{
    return true;
}

void Predictor_BinnedClassifier::InternalSwap(Predictor_BinnedClassifier* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.bins_.InternalSwap(&other->_impl_.bins_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.underflow_label_, lhs_arena, &other->_impl_.underflow_label_, rhs_arena);
}

std::string Predictor_BinnedClassifier::GetTypeName() const
{
    return "segmentation_platform.proto.Predictor.BinnedClassifier";
}

// ===================================================================

class Predictor_Regressor::_Internal {
public:
};

Predictor_Regressor::Predictor_Regressor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.Predictor.Regressor)
}
Predictor_Regressor::Predictor_Regressor(const Predictor_Regressor& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Predictor_Regressor* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.Predictor.Regressor)
}

inline void Predictor_Regressor::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

Predictor_Regressor::~Predictor_Regressor()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.Predictor.Regressor)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Predictor_Regressor::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Predictor_Regressor::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Predictor_Regressor::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.Predictor.Regressor)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* Predictor_Regressor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Predictor_Regressor::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.Predictor.Regressor)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.Predictor.Regressor)
    return target;
}

size_t Predictor_Regressor::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.Predictor.Regressor)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Predictor_Regressor::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Predictor_Regressor*>(&from));
}

void Predictor_Regressor::MergeFrom(const Predictor_Regressor& from)
{
    Predictor_Regressor* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.Predictor.Regressor)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Predictor_Regressor::CopyFrom(const Predictor_Regressor& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.Predictor.Regressor)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Predictor_Regressor::IsInitialized() const
{
    return true;
}

void Predictor_Regressor::InternalSwap(Predictor_Regressor* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string Predictor_Regressor::GetTypeName() const
{
    return "segmentation_platform.proto.Predictor.Regressor";
}

// ===================================================================

class Predictor_GenericPredictor::_Internal {
public:
};

Predictor_GenericPredictor::Predictor_GenericPredictor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.Predictor.GenericPredictor)
}
Predictor_GenericPredictor::Predictor_GenericPredictor(const Predictor_GenericPredictor& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Predictor_GenericPredictor* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.output_labels_) { from._impl_.output_labels_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.Predictor.GenericPredictor)
}

inline void Predictor_GenericPredictor::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.output_labels_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

Predictor_GenericPredictor::~Predictor_GenericPredictor()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.Predictor.GenericPredictor)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Predictor_GenericPredictor::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.output_labels_.~RepeatedPtrField();
}

void Predictor_GenericPredictor::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Predictor_GenericPredictor::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.Predictor.GenericPredictor)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.output_labels_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Predictor_GenericPredictor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated string output_labels = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_output_labels();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Predictor_GenericPredictor::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.Predictor.GenericPredictor)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated string output_labels = 1;
    for (int i = 0, n = this->_internal_output_labels_size(); i < n; i++) {
        const auto& s = this->_internal_output_labels(i);
        target = stream->WriteString(1, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.Predictor.GenericPredictor)
    return target;
}

size_t Predictor_GenericPredictor::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.Predictor.GenericPredictor)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string output_labels = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.output_labels_.size());
    for (int i = 0, n = _impl_.output_labels_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.output_labels_.Get(i));
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Predictor_GenericPredictor::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Predictor_GenericPredictor*>(&from));
}

void Predictor_GenericPredictor::MergeFrom(const Predictor_GenericPredictor& from)
{
    Predictor_GenericPredictor* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.Predictor.GenericPredictor)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.output_labels_.MergeFrom(from._impl_.output_labels_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Predictor_GenericPredictor::CopyFrom(const Predictor_GenericPredictor& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.Predictor.GenericPredictor)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Predictor_GenericPredictor::IsInitialized() const
{
    return true;
}

void Predictor_GenericPredictor::InternalSwap(Predictor_GenericPredictor* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.output_labels_.InternalSwap(&other->_impl_.output_labels_);
}

std::string Predictor_GenericPredictor::GetTypeName() const
{
    return "segmentation_platform.proto.Predictor.GenericPredictor";
}

// ===================================================================

class Predictor::_Internal {
public:
    static const ::segmentation_platform::proto::Predictor_BinaryClassifier& binary_classifier(const Predictor* msg);
    static const ::segmentation_platform::proto::Predictor_MultiClassClassifier& multi_class_classifier(const Predictor* msg);
    static const ::segmentation_platform::proto::Predictor_BinnedClassifier& binned_classifier(const Predictor* msg);
    static const ::segmentation_platform::proto::Predictor_Regressor& regressor(const Predictor* msg);
    static const ::segmentation_platform::proto::Predictor_GenericPredictor& generic_predictor(const Predictor* msg);
};

const ::segmentation_platform::proto::Predictor_BinaryClassifier& Predictor::_Internal::binary_classifier(const Predictor* msg)
{
    return *msg->_impl_.PredictorType_.binary_classifier_;
}
const ::segmentation_platform::proto::Predictor_MultiClassClassifier& Predictor::_Internal::multi_class_classifier(const Predictor* msg)
{
    return *msg->_impl_.PredictorType_.multi_class_classifier_;
}
const ::segmentation_platform::proto::Predictor_BinnedClassifier& Predictor::_Internal::binned_classifier(const Predictor* msg)
{
    return *msg->_impl_.PredictorType_.binned_classifier_;
}
const ::segmentation_platform::proto::Predictor_Regressor& Predictor::_Internal::regressor(const Predictor* msg)
{
    return *msg->_impl_.PredictorType_.regressor_;
}
const ::segmentation_platform::proto::Predictor_GenericPredictor& Predictor::_Internal::generic_predictor(const Predictor* msg)
{
    return *msg->_impl_.PredictorType_.generic_predictor_;
}
void Predictor::set_allocated_binary_classifier(::segmentation_platform::proto::Predictor_BinaryClassifier* binary_classifier)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_PredictorType();
    if (binary_classifier) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(binary_classifier);
        if (message_arena != submessage_arena) {
            binary_classifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, binary_classifier, submessage_arena);
        }
        set_has_binary_classifier();
        _impl_.PredictorType_.binary_classifier_ = binary_classifier;
    }
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.Predictor.binary_classifier)
}
void Predictor::set_allocated_multi_class_classifier(::segmentation_platform::proto::Predictor_MultiClassClassifier* multi_class_classifier)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_PredictorType();
    if (multi_class_classifier) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(multi_class_classifier);
        if (message_arena != submessage_arena) {
            multi_class_classifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, multi_class_classifier, submessage_arena);
        }
        set_has_multi_class_classifier();
        _impl_.PredictorType_.multi_class_classifier_ = multi_class_classifier;
    }
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.Predictor.multi_class_classifier)
}
void Predictor::set_allocated_binned_classifier(::segmentation_platform::proto::Predictor_BinnedClassifier* binned_classifier)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_PredictorType();
    if (binned_classifier) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(binned_classifier);
        if (message_arena != submessage_arena) {
            binned_classifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, binned_classifier, submessage_arena);
        }
        set_has_binned_classifier();
        _impl_.PredictorType_.binned_classifier_ = binned_classifier;
    }
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.Predictor.binned_classifier)
}
void Predictor::set_allocated_regressor(::segmentation_platform::proto::Predictor_Regressor* regressor)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_PredictorType();
    if (regressor) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(regressor);
        if (message_arena != submessage_arena) {
            regressor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, regressor, submessage_arena);
        }
        set_has_regressor();
        _impl_.PredictorType_.regressor_ = regressor;
    }
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.Predictor.regressor)
}
void Predictor::set_allocated_generic_predictor(::segmentation_platform::proto::Predictor_GenericPredictor* generic_predictor)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_PredictorType();
    if (generic_predictor) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(generic_predictor);
        if (message_arena != submessage_arena) {
            generic_predictor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, generic_predictor, submessage_arena);
        }
        set_has_generic_predictor();
        _impl_.PredictorType_.generic_predictor_ = generic_predictor;
    }
    // @@protoc_insertion_point(field_set_allocated:segmentation_platform.proto.Predictor.generic_predictor)
}
Predictor::Predictor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.Predictor)
}
Predictor::Predictor(const Predictor& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Predictor* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.PredictorType_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_PredictorType();
    switch (from.PredictorType_case()) {
    case kBinaryClassifier: {
        _this->_internal_mutable_binary_classifier()->::segmentation_platform::proto::Predictor_BinaryClassifier::MergeFrom(from._internal_binary_classifier());
        break;
    }
    case kMultiClassClassifier: {
        _this->_internal_mutable_multi_class_classifier()->::segmentation_platform::proto::Predictor_MultiClassClassifier::MergeFrom(
            from._internal_multi_class_classifier());
        break;
    }
    case kBinnedClassifier: {
        _this->_internal_mutable_binned_classifier()->::segmentation_platform::proto::Predictor_BinnedClassifier::MergeFrom(from._internal_binned_classifier());
        break;
    }
    case kRegressor: {
        _this->_internal_mutable_regressor()->::segmentation_platform::proto::Predictor_Regressor::MergeFrom(from._internal_regressor());
        break;
    }
    case kGenericPredictor: {
        _this->_internal_mutable_generic_predictor()->::segmentation_platform::proto::Predictor_GenericPredictor::MergeFrom(from._internal_generic_predictor());
        break;
    }
    case PREDICTORTYPE_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.Predictor)
}

inline void Predictor::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.PredictorType_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_PredictorType();
}

Predictor::~Predictor()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.Predictor)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Predictor::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_PredictorType()) {
        clear_PredictorType();
    }
}

void Predictor::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Predictor::clear_PredictorType()
{
    // @@protoc_insertion_point(one_of_clear_start:segmentation_platform.proto.Predictor)
    switch (PredictorType_case()) {
    case kBinaryClassifier: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.PredictorType_.binary_classifier_;
        }
        break;
    }
    case kMultiClassClassifier: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.PredictorType_.multi_class_classifier_;
        }
        break;
    }
    case kBinnedClassifier: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.PredictorType_.binned_classifier_;
        }
        break;
    }
    case kRegressor: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.PredictorType_.regressor_;
        }
        break;
    }
    case kGenericPredictor: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.PredictorType_.generic_predictor_;
        }
        break;
    }
    case PREDICTORTYPE_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = PREDICTORTYPE_NOT_SET;
}

void Predictor::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.Predictor)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_PredictorType();
    _internal_metadata_.Clear<std::string>();
}

const char* Predictor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .segmentation_platform.proto.Predictor.BinaryClassifier binary_classifier = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_binary_classifier(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .segmentation_platform.proto.Predictor.MultiClassClassifier multi_class_classifier = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_multi_class_classifier(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .segmentation_platform.proto.Predictor.BinnedClassifier binned_classifier = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_binned_classifier(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .segmentation_platform.proto.Predictor.Regressor regressor = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_regressor(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .segmentation_platform.proto.Predictor.GenericPredictor generic_predictor = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_generic_predictor(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Predictor::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.Predictor)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (PredictorType_case()) {
    case kBinaryClassifier: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::binary_classifier(this), _Internal::binary_classifier(this).GetCachedSize(), target, stream);
        break;
    }
    case kMultiClassClassifier: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::multi_class_classifier(this), _Internal::multi_class_classifier(this).GetCachedSize(), target, stream);
        break;
    }
    case kBinnedClassifier: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::binned_classifier(this), _Internal::binned_classifier(this).GetCachedSize(), target, stream);
        break;
    }
    case kRegressor: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::regressor(this), _Internal::regressor(this).GetCachedSize(), target, stream);
        break;
    }
    case kGenericPredictor: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::generic_predictor(this), _Internal::generic_predictor(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.Predictor)
    return target;
}

size_t Predictor::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.Predictor)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (PredictorType_case()) {
    // .segmentation_platform.proto.Predictor.BinaryClassifier binary_classifier = 1;
    case kBinaryClassifier: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.PredictorType_.binary_classifier_);
        break;
    }
    // .segmentation_platform.proto.Predictor.MultiClassClassifier multi_class_classifier = 2;
    case kMultiClassClassifier: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.PredictorType_.multi_class_classifier_);
        break;
    }
    // .segmentation_platform.proto.Predictor.BinnedClassifier binned_classifier = 3;
    case kBinnedClassifier: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.PredictorType_.binned_classifier_);
        break;
    }
    // .segmentation_platform.proto.Predictor.Regressor regressor = 4;
    case kRegressor: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.PredictorType_.regressor_);
        break;
    }
    // .segmentation_platform.proto.Predictor.GenericPredictor generic_predictor = 5;
    case kGenericPredictor: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.PredictorType_.generic_predictor_);
        break;
    }
    case PREDICTORTYPE_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Predictor::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Predictor*>(&from));
}

void Predictor::MergeFrom(const Predictor& from)
{
    Predictor* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.Predictor)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.PredictorType_case()) {
    case kBinaryClassifier: {
        _this->_internal_mutable_binary_classifier()->::segmentation_platform::proto::Predictor_BinaryClassifier::MergeFrom(from._internal_binary_classifier());
        break;
    }
    case kMultiClassClassifier: {
        _this->_internal_mutable_multi_class_classifier()->::segmentation_platform::proto::Predictor_MultiClassClassifier::MergeFrom(
            from._internal_multi_class_classifier());
        break;
    }
    case kBinnedClassifier: {
        _this->_internal_mutable_binned_classifier()->::segmentation_platform::proto::Predictor_BinnedClassifier::MergeFrom(from._internal_binned_classifier());
        break;
    }
    case kRegressor: {
        _this->_internal_mutable_regressor()->::segmentation_platform::proto::Predictor_Regressor::MergeFrom(from._internal_regressor());
        break;
    }
    case kGenericPredictor: {
        _this->_internal_mutable_generic_predictor()->::segmentation_platform::proto::Predictor_GenericPredictor::MergeFrom(from._internal_generic_predictor());
        break;
    }
    case PREDICTORTYPE_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Predictor::CopyFrom(const Predictor& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.Predictor)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Predictor::IsInitialized() const
{
    return true;
}

void Predictor::InternalSwap(Predictor* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.PredictorType_, other->_impl_.PredictorType_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string Predictor::GetTypeName() const
{
    return "segmentation_platform.proto.Predictor";
}

// ===================================================================

PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse::PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse()
{
}
PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse::PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena)
{
}
void PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse::MergeFrom(const PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse& other)
{
    MergeFromInternal(other);
}

// ===================================================================

class PredictedResultTTL::_Internal {
public:
    using HasBits = decltype(std::declval<PredictedResultTTL>()._impl_._has_bits_);
    static void set_has_default_ttl(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_time_unit(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

PredictedResultTTL::PredictedResultTTL(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.PredictedResultTTL)
}
PredictedResultTTL::PredictedResultTTL(const PredictedResultTTL& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PredictedResultTTL* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.top_label_to_ttl_map_)*/ {}, decltype(_impl_.default_ttl_) {}, decltype(_impl_.time_unit_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.top_label_to_ttl_map_.MergeFrom(from._impl_.top_label_to_ttl_map_);
    ::memcpy(&_impl_.default_ttl_, &from._impl_.default_ttl_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.time_unit_) - reinterpret_cast<char*>(&_impl_.default_ttl_)) + sizeof(_impl_.time_unit_));
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.PredictedResultTTL)
}

inline void PredictedResultTTL::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.top_label_to_ttl_map_)*/ { ::_pbi::ArenaInitialized(), arena }, decltype(_impl_.default_ttl_) { uint64_t { 0u } },
        decltype(_impl_.time_unit_) { 0 } };
}

PredictedResultTTL::~PredictedResultTTL()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.PredictedResultTTL)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PredictedResultTTL::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.top_label_to_ttl_map_.Destruct();
    _impl_.top_label_to_ttl_map_.~MapFieldLite();
}

void PredictedResultTTL::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PredictedResultTTL::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.PredictedResultTTL)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.top_label_to_ttl_map_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.default_ttl_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.time_unit_) - reinterpret_cast<char*>(&_impl_.default_ttl_)) + sizeof(_impl_.time_unit_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PredictedResultTTL::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // map<string, uint64> top_label_to_ttl_map = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(&_impl_.top_label_to_ttl_map_, ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional uint64 default_ttl = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_default_ttl(&has_bits);
                _impl_.default_ttl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .segmentation_platform.proto.TimeUnit time_unit = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::segmentation_platform::proto::TimeUnit_IsValid(val))) {
                    _internal_set_time_unit(static_cast<::segmentation_platform::proto::TimeUnit>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PredictedResultTTL::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.PredictedResultTTL)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // map<string, uint64> top_label_to_ttl_map = 1;
    if (!this->_internal_top_label_to_ttl_map().empty()) {
        using MapType = ::_pb::Map<std::string, uint64_t>;
        using WireHelper = PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse::Funcs;
        const auto& map_field = this->_internal_top_label_to_ttl_map();
        auto check_utf8 = [](const MapType::value_type& entry) { (void)entry; };

        if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
            for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
                target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        } else {
            for (const auto& entry : map_field) {
                target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        }
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint64 default_ttl = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_default_ttl(), target);
    }

    // optional .segmentation_platform.proto.TimeUnit time_unit = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_time_unit(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.PredictedResultTTL)
    return target;
}

size_t PredictedResultTTL::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.PredictedResultTTL)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // map<string, uint64> top_label_to_ttl_map = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_top_label_to_ttl_map_size());
    for (::PROTOBUF_NAMESPACE_ID::Map<std::string, uint64_t>::const_iterator it = this->_internal_top_label_to_ttl_map().begin();
         it != this->_internal_top_label_to_ttl_map().end(); ++it) {
        total_size += PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional uint64 default_ttl = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_default_ttl());
        }

        // optional .segmentation_platform.proto.TimeUnit time_unit = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_time_unit());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PredictedResultTTL::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PredictedResultTTL*>(&from));
}

void PredictedResultTTL::MergeFrom(const PredictedResultTTL& from)
{
    PredictedResultTTL* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.PredictedResultTTL)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.top_label_to_ttl_map_.MergeFrom(from._impl_.top_label_to_ttl_map_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.default_ttl_ = from._impl_.default_ttl_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.time_unit_ = from._impl_.time_unit_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PredictedResultTTL::CopyFrom(const PredictedResultTTL& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.PredictedResultTTL)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PredictedResultTTL::IsInitialized() const
{
    return true;
}

void PredictedResultTTL::InternalSwap(PredictedResultTTL* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.top_label_to_ttl_map_.InternalSwap(&other->_impl_.top_label_to_ttl_map_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PredictedResultTTL, _impl_.time_unit_) + sizeof(PredictedResultTTL::_impl_.time_unit_)
        - PROTOBUF_FIELD_OFFSET(PredictedResultTTL, _impl_.default_ttl_)>(
        reinterpret_cast<char*>(&_impl_.default_ttl_), reinterpret_cast<char*>(&other->_impl_.default_ttl_));
}

std::string PredictedResultTTL::GetTypeName() const
{
    return "segmentation_platform.proto.PredictedResultTTL";
}

// ===================================================================

class OutputConfig::_Internal {
public:
    using HasBits = decltype(std::declval<OutputConfig>()._impl_._has_bits_);
    static const ::segmentation_platform::proto::Predictor& predictor(const OutputConfig* msg);
    static void set_has_predictor(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::segmentation_platform::proto::PredictedResultTTL& predicted_result_ttl(const OutputConfig* msg);
    static void set_has_predicted_result_ttl(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_ignore_previous_model_ttl(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::segmentation_platform::proto::Predictor& OutputConfig::_Internal::predictor(const OutputConfig* msg)
{
    return *msg->_impl_.predictor_;
}
const ::segmentation_platform::proto::PredictedResultTTL& OutputConfig::_Internal::predicted_result_ttl(const OutputConfig* msg)
{
    return *msg->_impl_.predicted_result_ttl_;
}
OutputConfig::OutputConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:segmentation_platform.proto.OutputConfig)
}
OutputConfig::OutputConfig(const OutputConfig& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    OutputConfig* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.predictor_) { nullptr }, decltype(_impl_.predicted_result_ttl_) { nullptr }, decltype(_impl_.ignore_previous_model_ttl_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_predictor()) {
        _this->_impl_.predictor_ = new ::segmentation_platform::proto::Predictor(*from._impl_.predictor_);
    }
    if (from._internal_has_predicted_result_ttl()) {
        _this->_impl_.predicted_result_ttl_ = new ::segmentation_platform::proto::PredictedResultTTL(*from._impl_.predicted_result_ttl_);
    }
    _this->_impl_.ignore_previous_model_ttl_ = from._impl_.ignore_previous_model_ttl_;
    // @@protoc_insertion_point(copy_constructor:segmentation_platform.proto.OutputConfig)
}

inline void OutputConfig::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.predictor_) { nullptr },
        decltype(_impl_.predicted_result_ttl_) { nullptr }, decltype(_impl_.ignore_previous_model_ttl_) { false } };
}

OutputConfig::~OutputConfig()
{
    // @@protoc_insertion_point(destructor:segmentation_platform.proto.OutputConfig)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void OutputConfig::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.predictor_;
    if (this != internal_default_instance())
        delete _impl_.predicted_result_ttl_;
}

void OutputConfig::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void OutputConfig::Clear()
{
    // @@protoc_insertion_point(message_clear_start:segmentation_platform.proto.OutputConfig)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.predictor_ != nullptr);
            _impl_.predictor_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.predicted_result_ttl_ != nullptr);
            _impl_.predicted_result_ttl_->Clear();
        }
    }
    _impl_.ignore_previous_model_ttl_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* OutputConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .segmentation_platform.proto.Predictor predictor = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_predictor(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .segmentation_platform.proto.PredictedResultTTL predicted_result_ttl = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_predicted_result_ttl(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool ignore_previous_model_ttl = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_ignore_previous_model_ttl(&has_bits);
                _impl_.ignore_previous_model_ttl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* OutputConfig::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:segmentation_platform.proto.OutputConfig)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .segmentation_platform.proto.Predictor predictor = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::predictor(this), _Internal::predictor(this).GetCachedSize(), target, stream);
    }

    // optional .segmentation_platform.proto.PredictedResultTTL predicted_result_ttl = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::predicted_result_ttl(this), _Internal::predicted_result_ttl(this).GetCachedSize(), target, stream);
    }

    // optional bool ignore_previous_model_ttl = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_ignore_previous_model_ttl(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:segmentation_platform.proto.OutputConfig)
    return target;
}

size_t OutputConfig::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:segmentation_platform.proto.OutputConfig)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional .segmentation_platform.proto.Predictor predictor = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.predictor_);
        }

        // optional .segmentation_platform.proto.PredictedResultTTL predicted_result_ttl = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.predicted_result_ttl_);
        }

        // optional bool ignore_previous_model_ttl = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void OutputConfig::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const OutputConfig*>(&from));
}

void OutputConfig::MergeFrom(const OutputConfig& from)
{
    OutputConfig* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:segmentation_platform.proto.OutputConfig)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_predictor()->::segmentation_platform::proto::Predictor::MergeFrom(from._internal_predictor());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_predicted_result_ttl()->::segmentation_platform::proto::PredictedResultTTL::MergeFrom(
                from._internal_predicted_result_ttl());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.ignore_previous_model_ttl_ = from._impl_.ignore_previous_model_ttl_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OutputConfig::CopyFrom(const OutputConfig& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:segmentation_platform.proto.OutputConfig)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool OutputConfig::IsInitialized() const
{
    return true;
}

void OutputConfig::InternalSwap(OutputConfig* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(OutputConfig, _impl_.ignore_previous_model_ttl_)
        + sizeof(OutputConfig::_impl_.ignore_previous_model_ttl_) - PROTOBUF_FIELD_OFFSET(OutputConfig, _impl_.predictor_)>(
        reinterpret_cast<char*>(&_impl_.predictor_), reinterpret_cast<char*>(&other->_impl_.predictor_));
}

std::string OutputConfig::GetTypeName() const
{
    return "segmentation_platform.proto.OutputConfig";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace proto
} // namespace segmentation_platform
PROTOBUF_NAMESPACE_OPEN
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::Predictor_BinaryClassifier*
Arena::CreateMaybeMessage<::segmentation_platform::proto::Predictor_BinaryClassifier>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::Predictor_BinaryClassifier>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::Predictor_MultiClassClassifier*
Arena::CreateMaybeMessage<::segmentation_platform::proto::Predictor_MultiClassClassifier>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::Predictor_MultiClassClassifier>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::Predictor_BinnedClassifier_Bin*
Arena::CreateMaybeMessage<::segmentation_platform::proto::Predictor_BinnedClassifier_Bin>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::Predictor_BinnedClassifier_Bin>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::Predictor_BinnedClassifier*
Arena::CreateMaybeMessage<::segmentation_platform::proto::Predictor_BinnedClassifier>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::Predictor_BinnedClassifier>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::Predictor_Regressor* Arena::CreateMaybeMessage<::segmentation_platform::proto::Predictor_Regressor>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::Predictor_Regressor>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::Predictor_GenericPredictor*
Arena::CreateMaybeMessage<::segmentation_platform::proto::Predictor_GenericPredictor>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::Predictor_GenericPredictor>(arena);
}
template <> PROTOBUF_NOINLINE ::segmentation_platform::proto::Predictor* Arena::CreateMaybeMessage<::segmentation_platform::proto::Predictor>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::Predictor>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse*
Arena::CreateMaybeMessage<::segmentation_platform::proto::PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::PredictedResultTTL_TopLabelToTtlMapEntry_DoNotUse>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::PredictedResultTTL* Arena::CreateMaybeMessage<::segmentation_platform::proto::PredictedResultTTL>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::PredictedResultTTL>(arena);
}
template <>
PROTOBUF_NOINLINE ::segmentation_platform::proto::OutputConfig* Arena::CreateMaybeMessage<::segmentation_platform::proto::OutputConfig>(Arena* arena)
{
    return Arena::CreateMessageInternal<::segmentation_platform::proto::OutputConfig>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
