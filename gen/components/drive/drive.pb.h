// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: drive.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_drive_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_drive_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_drive_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_drive_2eproto {
    static const uint32_t offsets[];
};
namespace drive {
class CapabilitiesInfo;
struct CapabilitiesInfoDefaultTypeInternal;
extern CapabilitiesInfoDefaultTypeInternal _CapabilitiesInfo_default_instance_;
class DirectorySpecificInfo;
struct DirectorySpecificInfoDefaultTypeInternal;
extern DirectorySpecificInfoDefaultTypeInternal _DirectorySpecificInfo_default_instance_;
class FileCacheEntry;
struct FileCacheEntryDefaultTypeInternal;
extern FileCacheEntryDefaultTypeInternal _FileCacheEntry_default_instance_;
class FileSpecificInfo;
struct FileSpecificInfoDefaultTypeInternal;
extern FileSpecificInfoDefaultTypeInternal _FileSpecificInfo_default_instance_;
class PlatformFileInfoProto;
struct PlatformFileInfoProtoDefaultTypeInternal;
extern PlatformFileInfoProtoDefaultTypeInternal _PlatformFileInfoProto_default_instance_;
class Property;
struct PropertyDefaultTypeInternal;
extern PropertyDefaultTypeInternal _Property_default_instance_;
class ResourceEntry;
struct ResourceEntryDefaultTypeInternal;
extern ResourceEntryDefaultTypeInternal _ResourceEntry_default_instance_;
class ResourceMetadataHeader;
struct ResourceMetadataHeaderDefaultTypeInternal;
extern ResourceMetadataHeaderDefaultTypeInternal _ResourceMetadataHeader_default_instance_;
class TeamDriveRootSpecificInfo;
struct TeamDriveRootSpecificInfoDefaultTypeInternal;
extern TeamDriveRootSpecificInfoDefaultTypeInternal _TeamDriveRootSpecificInfo_default_instance_;
} // namespace drive
PROTOBUF_NAMESPACE_OPEN
template <>::drive::CapabilitiesInfo* Arena::CreateMaybeMessage<::drive::CapabilitiesInfo>(Arena*);
template <>::drive::DirectorySpecificInfo* Arena::CreateMaybeMessage<::drive::DirectorySpecificInfo>(Arena*);
template <>::drive::FileCacheEntry* Arena::CreateMaybeMessage<::drive::FileCacheEntry>(Arena*);
template <>::drive::FileSpecificInfo* Arena::CreateMaybeMessage<::drive::FileSpecificInfo>(Arena*);
template <>::drive::PlatformFileInfoProto* Arena::CreateMaybeMessage<::drive::PlatformFileInfoProto>(Arena*);
template <>::drive::Property* Arena::CreateMaybeMessage<::drive::Property>(Arena*);
template <>::drive::ResourceEntry* Arena::CreateMaybeMessage<::drive::ResourceEntry>(Arena*);
template <>::drive::ResourceMetadataHeader* Arena::CreateMaybeMessage<::drive::ResourceMetadataHeader>(Arena*);
template <>::drive::TeamDriveRootSpecificInfo* Arena::CreateMaybeMessage<::drive::TeamDriveRootSpecificInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace drive {

enum Property_Visibility : int { Property_Visibility_PRIVATE = 0, Property_Visibility_PUBLIC = 1 };
bool Property_Visibility_IsValid(int value);
constexpr Property_Visibility Property_Visibility_Visibility_MIN = Property_Visibility_PRIVATE;
constexpr Property_Visibility Property_Visibility_Visibility_MAX = Property_Visibility_PUBLIC;
constexpr int Property_Visibility_Visibility_ARRAYSIZE = Property_Visibility_Visibility_MAX + 1;

const std::string& Property_Visibility_Name(Property_Visibility value);
template <typename T> inline const std::string& Property_Visibility_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Property_Visibility>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Property_Visibility_Name.");
    return Property_Visibility_Name(static_cast<Property_Visibility>(enum_t_value));
}
bool Property_Visibility_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Property_Visibility* value);
enum ResourceEntry_EditState : int { ResourceEntry_EditState_CLEAN = 0, ResourceEntry_EditState_DIRTY = 1, ResourceEntry_EditState_SYNCING = 2 };
bool ResourceEntry_EditState_IsValid(int value);
constexpr ResourceEntry_EditState ResourceEntry_EditState_EditState_MIN = ResourceEntry_EditState_CLEAN;
constexpr ResourceEntry_EditState ResourceEntry_EditState_EditState_MAX = ResourceEntry_EditState_SYNCING;
constexpr int ResourceEntry_EditState_EditState_ARRAYSIZE = ResourceEntry_EditState_EditState_MAX + 1;

const std::string& ResourceEntry_EditState_Name(ResourceEntry_EditState value);
template <typename T> inline const std::string& ResourceEntry_EditState_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, ResourceEntry_EditState>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ResourceEntry_EditState_Name.");
    return ResourceEntry_EditState_Name(static_cast<ResourceEntry_EditState>(enum_t_value));
}
bool ResourceEntry_EditState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResourceEntry_EditState* value);
// ===================================================================

class PlatformFileInfoProto final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:drive.PlatformFileInfoProto) */ {
public:
    inline PlatformFileInfoProto()
        : PlatformFileInfoProto(nullptr)
    {
    }
    ~PlatformFileInfoProto() override;
    explicit PROTOBUF_CONSTEXPR PlatformFileInfoProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PlatformFileInfoProto(const PlatformFileInfoProto& from);
    PlatformFileInfoProto(PlatformFileInfoProto&& from) noexcept
        : PlatformFileInfoProto()
    {
        *this = ::std::move(from);
    }

    inline PlatformFileInfoProto& operator=(const PlatformFileInfoProto& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline PlatformFileInfoProto& operator=(PlatformFileInfoProto&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const PlatformFileInfoProto& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const PlatformFileInfoProto* internal_default_instance()
    {
        return reinterpret_cast<const PlatformFileInfoProto*>(&_PlatformFileInfoProto_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(PlatformFileInfoProto& a, PlatformFileInfoProto& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(PlatformFileInfoProto* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PlatformFileInfoProto* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PlatformFileInfoProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<PlatformFileInfoProto>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const PlatformFileInfoProto& from);
    void MergeFrom(const PlatformFileInfoProto& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PlatformFileInfoProto* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "drive.PlatformFileInfoProto";
    }

protected:
    explicit PlatformFileInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSizeFieldNumber = 1,
        kLastModifiedFieldNumber = 4,
        kLastAccessedFieldNumber = 5,
        kCreationTimeFieldNumber = 6,
        kIsDirectoryFieldNumber = 2,
        kIsSymbolicLinkFieldNumber = 3,
        kIsTeamDriveRootFieldNumber = 7,
    };
    // optional int64 size = 1;
    bool has_size() const;

private:
    bool _internal_has_size() const;

public:
    void clear_size();
    int64_t size() const;
    void set_size(int64_t value);

private:
    int64_t _internal_size() const;
    void _internal_set_size(int64_t value);

public:
    // optional int64 last_modified = 4;
    bool has_last_modified() const;

private:
    bool _internal_has_last_modified() const;

public:
    void clear_last_modified();
    int64_t last_modified() const;
    void set_last_modified(int64_t value);

private:
    int64_t _internal_last_modified() const;
    void _internal_set_last_modified(int64_t value);

public:
    // optional int64 last_accessed = 5;
    bool has_last_accessed() const;

private:
    bool _internal_has_last_accessed() const;

public:
    void clear_last_accessed();
    int64_t last_accessed() const;
    void set_last_accessed(int64_t value);

private:
    int64_t _internal_last_accessed() const;
    void _internal_set_last_accessed(int64_t value);

public:
    // optional int64 creation_time = 6;
    bool has_creation_time() const;

private:
    bool _internal_has_creation_time() const;

public:
    void clear_creation_time();
    int64_t creation_time() const;
    void set_creation_time(int64_t value);

private:
    int64_t _internal_creation_time() const;
    void _internal_set_creation_time(int64_t value);

public:
    // optional bool is_directory = 2;
    bool has_is_directory() const;

private:
    bool _internal_has_is_directory() const;

public:
    void clear_is_directory();
    bool is_directory() const;
    void set_is_directory(bool value);

private:
    bool _internal_is_directory() const;
    void _internal_set_is_directory(bool value);

public:
    // optional bool is_symbolic_link = 3;
    bool has_is_symbolic_link() const;

private:
    bool _internal_has_is_symbolic_link() const;

public:
    void clear_is_symbolic_link();
    bool is_symbolic_link() const;
    void set_is_symbolic_link(bool value);

private:
    bool _internal_is_symbolic_link() const;
    void _internal_set_is_symbolic_link(bool value);

public:
    // optional bool is_team_drive_root = 7;
    bool has_is_team_drive_root() const;

private:
    bool _internal_has_is_team_drive_root() const;

public:
    void clear_is_team_drive_root();
    bool is_team_drive_root() const;
    void set_is_team_drive_root(bool value);

private:
    bool _internal_is_team_drive_root() const;
    void _internal_set_is_team_drive_root(bool value);

public:
    // @@protoc_insertion_point(class_scope:drive.PlatformFileInfoProto)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int64_t size_;
        int64_t last_modified_;
        int64_t last_accessed_;
        int64_t creation_time_;
        bool is_directory_;
        bool is_symbolic_link_;
        bool is_team_drive_root_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_drive_2eproto;
};
// -------------------------------------------------------------------

class Property final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:drive.Property) */ {
public:
    inline Property()
        : Property(nullptr)
    {
    }
    ~Property() override;
    explicit PROTOBUF_CONSTEXPR Property(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Property(const Property& from);
    Property(Property&& from) noexcept
        : Property()
    {
        *this = ::std::move(from);
    }

    inline Property& operator=(const Property& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Property& operator=(Property&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Property& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Property* internal_default_instance()
    {
        return reinterpret_cast<const Property*>(&_Property_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(Property& a, Property& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Property* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Property* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Property* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Property>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Property& from);
    void MergeFrom(const Property& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Property* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "drive.Property";
    }

protected:
    explicit Property(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef Property_Visibility Visibility;
    static constexpr Visibility PRIVATE = Property_Visibility_PRIVATE;
    static constexpr Visibility PUBLIC = Property_Visibility_PUBLIC;
    static inline bool Visibility_IsValid(int value)
    {
        return Property_Visibility_IsValid(value);
    }
    static constexpr Visibility Visibility_MIN = Property_Visibility_Visibility_MIN;
    static constexpr Visibility Visibility_MAX = Property_Visibility_Visibility_MAX;
    static constexpr int Visibility_ARRAYSIZE = Property_Visibility_Visibility_ARRAYSIZE;
    template <typename T> static inline const std::string& Visibility_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Visibility>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Visibility_Name.");
        return Property_Visibility_Name(enum_t_value);
    }
    static inline bool Visibility_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Visibility* value)
    {
        return Property_Visibility_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kKeyFieldNumber = 1,
        kValueFieldNumber = 2,
        kVisibilityFieldNumber = 3,
    };
    // optional string key = 1;
    bool has_key() const;

private:
    bool _internal_has_key() const;

public:
    void clear_key();
    const std::string& key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_key();
    PROTOBUF_NODISCARD std::string* release_key();
    void set_allocated_key(std::string* key);

private:
    const std::string& _internal_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
    std::string* _internal_mutable_key();

public:
    // optional string value = 2;
    bool has_value() const;

private:
    bool _internal_has_value() const;

public:
    void clear_value();
    const std::string& value() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_value(ArgT0&& arg0, ArgT... args);
    std::string* mutable_value();
    PROTOBUF_NODISCARD std::string* release_value();
    void set_allocated_value(std::string* value);

private:
    const std::string& _internal_value() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
    std::string* _internal_mutable_value();

public:
    // optional .drive.Property.Visibility visibility = 3;
    bool has_visibility() const;

private:
    bool _internal_has_visibility() const;

public:
    void clear_visibility();
    ::drive::Property_Visibility visibility() const;
    void set_visibility(::drive::Property_Visibility value);

private:
    ::drive::Property_Visibility _internal_visibility() const;
    void _internal_set_visibility(::drive::Property_Visibility value);

public:
    // @@protoc_insertion_point(class_scope:drive.Property)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
        int visibility_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_drive_2eproto;
};
// -------------------------------------------------------------------

class CapabilitiesInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:drive.CapabilitiesInfo) */ {
public:
    inline CapabilitiesInfo()
        : CapabilitiesInfo(nullptr)
    {
    }
    ~CapabilitiesInfo() override;
    explicit PROTOBUF_CONSTEXPR CapabilitiesInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CapabilitiesInfo(const CapabilitiesInfo& from);
    CapabilitiesInfo(CapabilitiesInfo&& from) noexcept
        : CapabilitiesInfo()
    {
        *this = ::std::move(from);
    }

    inline CapabilitiesInfo& operator=(const CapabilitiesInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CapabilitiesInfo& operator=(CapabilitiesInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const CapabilitiesInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CapabilitiesInfo* internal_default_instance()
    {
        return reinterpret_cast<const CapabilitiesInfo*>(&_CapabilitiesInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(CapabilitiesInfo& a, CapabilitiesInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CapabilitiesInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CapabilitiesInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CapabilitiesInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CapabilitiesInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CapabilitiesInfo& from);
    void MergeFrom(const CapabilitiesInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CapabilitiesInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "drive.CapabilitiesInfo";
    }

protected:
    explicit CapabilitiesInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCanCopyFieldNumber = 1,
        kCanDeleteFieldNumber = 2,
        kCanRenameFieldNumber = 3,
        kCanAddChildrenFieldNumber = 4,
        kCanShareFieldNumber = 5,
    };
    // optional bool can_copy = 1;
    bool has_can_copy() const;

private:
    bool _internal_has_can_copy() const;

public:
    void clear_can_copy();
    bool can_copy() const;
    void set_can_copy(bool value);

private:
    bool _internal_can_copy() const;
    void _internal_set_can_copy(bool value);

public:
    // optional bool can_delete = 2;
    bool has_can_delete() const;

private:
    bool _internal_has_can_delete() const;

public:
    void clear_can_delete();
    bool can_delete() const;
    void set_can_delete(bool value);

private:
    bool _internal_can_delete() const;
    void _internal_set_can_delete(bool value);

public:
    // optional bool can_rename = 3;
    bool has_can_rename() const;

private:
    bool _internal_has_can_rename() const;

public:
    void clear_can_rename();
    bool can_rename() const;
    void set_can_rename(bool value);

private:
    bool _internal_can_rename() const;
    void _internal_set_can_rename(bool value);

public:
    // optional bool can_add_children = 4;
    bool has_can_add_children() const;

private:
    bool _internal_has_can_add_children() const;

public:
    void clear_can_add_children();
    bool can_add_children() const;
    void set_can_add_children(bool value);

private:
    bool _internal_can_add_children() const;
    void _internal_set_can_add_children(bool value);

public:
    // optional bool can_share = 5;
    bool has_can_share() const;

private:
    bool _internal_has_can_share() const;

public:
    void clear_can_share();
    bool can_share() const;
    void set_can_share(bool value);

private:
    bool _internal_can_share() const;
    void _internal_set_can_share(bool value);

public:
    // @@protoc_insertion_point(class_scope:drive.CapabilitiesInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        bool can_copy_;
        bool can_delete_;
        bool can_rename_;
        bool can_add_children_;
        bool can_share_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_drive_2eproto;
};
// -------------------------------------------------------------------

class FileSpecificInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:drive.FileSpecificInfo) */ {
public:
    inline FileSpecificInfo()
        : FileSpecificInfo(nullptr)
    {
    }
    ~FileSpecificInfo() override;
    explicit PROTOBUF_CONSTEXPR FileSpecificInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FileSpecificInfo(const FileSpecificInfo& from);
    FileSpecificInfo(FileSpecificInfo&& from) noexcept
        : FileSpecificInfo()
    {
        *this = ::std::move(from);
    }

    inline FileSpecificInfo& operator=(const FileSpecificInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FileSpecificInfo& operator=(FileSpecificInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const FileSpecificInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FileSpecificInfo* internal_default_instance()
    {
        return reinterpret_cast<const FileSpecificInfo*>(&_FileSpecificInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(FileSpecificInfo& a, FileSpecificInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FileSpecificInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FileSpecificInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FileSpecificInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FileSpecificInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FileSpecificInfo& from);
    void MergeFrom(const FileSpecificInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FileSpecificInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "drive.FileSpecificInfo";
    }

protected:
    explicit FileSpecificInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kContentMimeTypeFieldNumber = 3,
        kMd5FieldNumber = 4,
        kDocumentExtensionFieldNumber = 5,
        kCacheStateFieldNumber = 11,
        kImageWidthFieldNumber = 8,
        kImageHeightFieldNumber = 9,
        kImageRotationFieldNumber = 10,
        kIsHostedDocumentFieldNumber = 6,
    };
    // optional string content_mime_type = 3;
    bool has_content_mime_type() const;

private:
    bool _internal_has_content_mime_type() const;

public:
    void clear_content_mime_type();
    const std::string& content_mime_type() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_content_mime_type(ArgT0&& arg0, ArgT... args);
    std::string* mutable_content_mime_type();
    PROTOBUF_NODISCARD std::string* release_content_mime_type();
    void set_allocated_content_mime_type(std::string* content_mime_type);

private:
    const std::string& _internal_content_mime_type() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_content_mime_type(const std::string& value);
    std::string* _internal_mutable_content_mime_type();

public:
    // optional string md5 = 4;
    bool has_md5() const;

private:
    bool _internal_has_md5() const;

public:
    void clear_md5();
    const std::string& md5() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_md5(ArgT0&& arg0, ArgT... args);
    std::string* mutable_md5();
    PROTOBUF_NODISCARD std::string* release_md5();
    void set_allocated_md5(std::string* md5);

private:
    const std::string& _internal_md5() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_md5(const std::string& value);
    std::string* _internal_mutable_md5();

public:
    // optional string document_extension = 5;
    bool has_document_extension() const;

private:
    bool _internal_has_document_extension() const;

public:
    void clear_document_extension();
    const std::string& document_extension() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_document_extension(ArgT0&& arg0, ArgT... args);
    std::string* mutable_document_extension();
    PROTOBUF_NODISCARD std::string* release_document_extension();
    void set_allocated_document_extension(std::string* document_extension);

private:
    const std::string& _internal_document_extension() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_document_extension(const std::string& value);
    std::string* _internal_mutable_document_extension();

public:
    // optional .drive.FileCacheEntry cache_state = 11;
    bool has_cache_state() const;

private:
    bool _internal_has_cache_state() const;

public:
    void clear_cache_state();
    const ::drive::FileCacheEntry& cache_state() const;
    PROTOBUF_NODISCARD ::drive::FileCacheEntry* release_cache_state();
    ::drive::FileCacheEntry* mutable_cache_state();
    void set_allocated_cache_state(::drive::FileCacheEntry* cache_state);

private:
    const ::drive::FileCacheEntry& _internal_cache_state() const;
    ::drive::FileCacheEntry* _internal_mutable_cache_state();

public:
    void unsafe_arena_set_allocated_cache_state(::drive::FileCacheEntry* cache_state);
    ::drive::FileCacheEntry* unsafe_arena_release_cache_state();

    // optional int64 image_width = 8;
    bool has_image_width() const;

private:
    bool _internal_has_image_width() const;

public:
    void clear_image_width();
    int64_t image_width() const;
    void set_image_width(int64_t value);

private:
    int64_t _internal_image_width() const;
    void _internal_set_image_width(int64_t value);

public:
    // optional int64 image_height = 9;
    bool has_image_height() const;

private:
    bool _internal_has_image_height() const;

public:
    void clear_image_height();
    int64_t image_height() const;
    void set_image_height(int64_t value);

private:
    int64_t _internal_image_height() const;
    void _internal_set_image_height(int64_t value);

public:
    // optional int64 image_rotation = 10;
    bool has_image_rotation() const;

private:
    bool _internal_has_image_rotation() const;

public:
    void clear_image_rotation();
    int64_t image_rotation() const;
    void set_image_rotation(int64_t value);

private:
    int64_t _internal_image_rotation() const;
    void _internal_set_image_rotation(int64_t value);

public:
    // optional bool is_hosted_document = 6;
    bool has_is_hosted_document() const;

private:
    bool _internal_has_is_hosted_document() const;

public:
    void clear_is_hosted_document();
    bool is_hosted_document() const;
    void set_is_hosted_document(bool value);

private:
    bool _internal_is_hosted_document() const;
    void _internal_set_is_hosted_document(bool value);

public:
    // @@protoc_insertion_point(class_scope:drive.FileSpecificInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_mime_type_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr md5_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr document_extension_;
        ::drive::FileCacheEntry* cache_state_;
        int64_t image_width_;
        int64_t image_height_;
        int64_t image_rotation_;
        bool is_hosted_document_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_drive_2eproto;
};
// -------------------------------------------------------------------

class TeamDriveRootSpecificInfo final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:drive.TeamDriveRootSpecificInfo) */ {
public:
    inline TeamDriveRootSpecificInfo()
        : TeamDriveRootSpecificInfo(nullptr)
    {
    }
    ~TeamDriveRootSpecificInfo() override;
    explicit PROTOBUF_CONSTEXPR TeamDriveRootSpecificInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TeamDriveRootSpecificInfo(const TeamDriveRootSpecificInfo& from);
    TeamDriveRootSpecificInfo(TeamDriveRootSpecificInfo&& from) noexcept
        : TeamDriveRootSpecificInfo()
    {
        *this = ::std::move(from);
    }

    inline TeamDriveRootSpecificInfo& operator=(const TeamDriveRootSpecificInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TeamDriveRootSpecificInfo& operator=(TeamDriveRootSpecificInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const TeamDriveRootSpecificInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const TeamDriveRootSpecificInfo* internal_default_instance()
    {
        return reinterpret_cast<const TeamDriveRootSpecificInfo*>(&_TeamDriveRootSpecificInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(TeamDriveRootSpecificInfo& a, TeamDriveRootSpecificInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TeamDriveRootSpecificInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TeamDriveRootSpecificInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TeamDriveRootSpecificInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TeamDriveRootSpecificInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TeamDriveRootSpecificInfo& from);
    void MergeFrom(const TeamDriveRootSpecificInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TeamDriveRootSpecificInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "drive.TeamDriveRootSpecificInfo";
    }

protected:
    explicit TeamDriveRootSpecificInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStartPageTokenFieldNumber = 1,
    };
    // optional string start_page_token = 1;
    bool has_start_page_token() const;

private:
    bool _internal_has_start_page_token() const;

public:
    void clear_start_page_token();
    const std::string& start_page_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_start_page_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_start_page_token();
    PROTOBUF_NODISCARD std::string* release_start_page_token();
    void set_allocated_start_page_token(std::string* start_page_token);

private:
    const std::string& _internal_start_page_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_page_token(const std::string& value);
    std::string* _internal_mutable_start_page_token();

public:
    // @@protoc_insertion_point(class_scope:drive.TeamDriveRootSpecificInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_page_token_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_drive_2eproto;
};
// -------------------------------------------------------------------

class DirectorySpecificInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:drive.DirectorySpecificInfo) */ {
public:
    inline DirectorySpecificInfo()
        : DirectorySpecificInfo(nullptr)
    {
    }
    ~DirectorySpecificInfo() override;
    explicit PROTOBUF_CONSTEXPR DirectorySpecificInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    DirectorySpecificInfo(const DirectorySpecificInfo& from);
    DirectorySpecificInfo(DirectorySpecificInfo&& from) noexcept
        : DirectorySpecificInfo()
    {
        *this = ::std::move(from);
    }

    inline DirectorySpecificInfo& operator=(const DirectorySpecificInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DirectorySpecificInfo& operator=(DirectorySpecificInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const DirectorySpecificInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DirectorySpecificInfo* internal_default_instance()
    {
        return reinterpret_cast<const DirectorySpecificInfo*>(&_DirectorySpecificInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(DirectorySpecificInfo& a, DirectorySpecificInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(DirectorySpecificInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DirectorySpecificInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DirectorySpecificInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<DirectorySpecificInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const DirectorySpecificInfo& from);
    void MergeFrom(const DirectorySpecificInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DirectorySpecificInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "drive.DirectorySpecificInfo";
    }

protected:
    explicit DirectorySpecificInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStartPageTokenFieldNumber = 2,
        kChangestampFieldNumber = 1,
        kLastReadTimeMsFieldNumber = 3,
    };
    // optional string start_page_token = 2;
    bool has_start_page_token() const;

private:
    bool _internal_has_start_page_token() const;

public:
    void clear_start_page_token();
    const std::string& start_page_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_start_page_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_start_page_token();
    PROTOBUF_NODISCARD std::string* release_start_page_token();
    void set_allocated_start_page_token(std::string* start_page_token);

private:
    const std::string& _internal_start_page_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_page_token(const std::string& value);
    std::string* _internal_mutable_start_page_token();

public:
    // optional int64 changestamp = 1 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_changestamp() const;

private:
    bool _internal_has_changestamp() const;

public:
    PROTOBUF_DEPRECATED void clear_changestamp();
    PROTOBUF_DEPRECATED int64_t changestamp() const;
    PROTOBUF_DEPRECATED void set_changestamp(int64_t value);

private:
    int64_t _internal_changestamp() const;
    void _internal_set_changestamp(int64_t value);

public:
    // optional int64 last_read_time_ms = 3;
    bool has_last_read_time_ms() const;

private:
    bool _internal_has_last_read_time_ms() const;

public:
    void clear_last_read_time_ms();
    int64_t last_read_time_ms() const;
    void set_last_read_time_ms(int64_t value);

private:
    int64_t _internal_last_read_time_ms() const;
    void _internal_set_last_read_time_ms(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:drive.DirectorySpecificInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_page_token_;
        int64_t changestamp_;
        int64_t last_read_time_ms_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_drive_2eproto;
};
// -------------------------------------------------------------------

class ResourceEntry final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:drive.ResourceEntry) */ {
public:
    inline ResourceEntry()
        : ResourceEntry(nullptr)
    {
    }
    ~ResourceEntry() override;
    explicit PROTOBUF_CONSTEXPR ResourceEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ResourceEntry(const ResourceEntry& from);
    ResourceEntry(ResourceEntry&& from) noexcept
        : ResourceEntry()
    {
        *this = ::std::move(from);
    }

    inline ResourceEntry& operator=(const ResourceEntry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ResourceEntry& operator=(ResourceEntry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ResourceEntry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ResourceEntry* internal_default_instance()
    {
        return reinterpret_cast<const ResourceEntry*>(&_ResourceEntry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(ResourceEntry& a, ResourceEntry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ResourceEntry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ResourceEntry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ResourceEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ResourceEntry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ResourceEntry& from);
    void MergeFrom(const ResourceEntry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ResourceEntry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "drive.ResourceEntry";
    }

protected:
    explicit ResourceEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ResourceEntry_EditState EditState;
    static constexpr EditState CLEAN = ResourceEntry_EditState_CLEAN;
    static constexpr EditState DIRTY = ResourceEntry_EditState_DIRTY;
    static constexpr EditState SYNCING = ResourceEntry_EditState_SYNCING;
    static inline bool EditState_IsValid(int value)
    {
        return ResourceEntry_EditState_IsValid(value);
    }
    static constexpr EditState EditState_MIN = ResourceEntry_EditState_EditState_MIN;
    static constexpr EditState EditState_MAX = ResourceEntry_EditState_EditState_MAX;
    static constexpr int EditState_ARRAYSIZE = ResourceEntry_EditState_EditState_ARRAYSIZE;
    template <typename T> static inline const std::string& EditState_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, EditState>::value || ::std::is_integral<T>::value, "Incorrect type passed to function EditState_Name.");
        return ResourceEntry_EditState_Name(enum_t_value);
    }
    static inline bool EditState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EditState* value)
    {
        return ResourceEntry_EditState_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kNewPropertiesFieldNumber = 19,
        kBaseNameFieldNumber = 2,
        kTitleFieldNumber = 3,
        kResourceIdFieldNumber = 4,
        kParentLocalIdFieldNumber = 7,
        kLocalIdFieldNumber = 15,
        kAlternateUrlFieldNumber = 22,
        kFileInfoFieldNumber = 1,
        kFileSpecificInfoFieldNumber = 9,
        kDirectorySpecificInfoFieldNumber = 13,
        kTeamDriveRootSpecificInfoFieldNumber = 23,
        kCapabilitiesInfoFieldNumber = 24,
        kDeletedFieldNumber = 11,
        kStarredFieldNumber = 20,
        kSharedWithMeFieldNumber = 14,
        kSharedFieldNumber = 17,
        kMetadataEditStateFieldNumber = 16,
        kModificationDateFieldNumber = 18,
        kLastModifiedByMeFieldNumber = 21,
    };
    // repeated .drive.Property new_properties = 19;
    int new_properties_size() const;

private:
    int _internal_new_properties_size() const;

public:
    void clear_new_properties();
    ::drive::Property* mutable_new_properties(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::drive::Property>* mutable_new_properties();

private:
    const ::drive::Property& _internal_new_properties(int index) const;
    ::drive::Property* _internal_add_new_properties();

public:
    const ::drive::Property& new_properties(int index) const;
    ::drive::Property* add_new_properties();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::drive::Property>& new_properties() const;

    // optional string base_name = 2;
    bool has_base_name() const;

private:
    bool _internal_has_base_name() const;

public:
    void clear_base_name();
    const std::string& base_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_base_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_base_name();
    PROTOBUF_NODISCARD std::string* release_base_name();
    void set_allocated_base_name(std::string* base_name);

private:
    const std::string& _internal_base_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_name(const std::string& value);
    std::string* _internal_mutable_base_name();

public:
    // optional string title = 3;
    bool has_title() const;

private:
    bool _internal_has_title() const;

public:
    void clear_title();
    const std::string& title() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_title(ArgT0&& arg0, ArgT... args);
    std::string* mutable_title();
    PROTOBUF_NODISCARD std::string* release_title();
    void set_allocated_title(std::string* title);

private:
    const std::string& _internal_title() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
    std::string* _internal_mutable_title();

public:
    // optional string resource_id = 4;
    bool has_resource_id() const;

private:
    bool _internal_has_resource_id() const;

public:
    void clear_resource_id();
    const std::string& resource_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_resource_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_resource_id();
    PROTOBUF_NODISCARD std::string* release_resource_id();
    void set_allocated_resource_id(std::string* resource_id);

private:
    const std::string& _internal_resource_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource_id(const std::string& value);
    std::string* _internal_mutable_resource_id();

public:
    // optional string parent_local_id = 7;
    bool has_parent_local_id() const;

private:
    bool _internal_has_parent_local_id() const;

public:
    void clear_parent_local_id();
    const std::string& parent_local_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_parent_local_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_parent_local_id();
    PROTOBUF_NODISCARD std::string* release_parent_local_id();
    void set_allocated_parent_local_id(std::string* parent_local_id);

private:
    const std::string& _internal_parent_local_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_local_id(const std::string& value);
    std::string* _internal_mutable_parent_local_id();

public:
    // optional string local_id = 15;
    bool has_local_id() const;

private:
    bool _internal_has_local_id() const;

public:
    void clear_local_id();
    const std::string& local_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_local_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_local_id();
    PROTOBUF_NODISCARD std::string* release_local_id();
    void set_allocated_local_id(std::string* local_id);

private:
    const std::string& _internal_local_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_id(const std::string& value);
    std::string* _internal_mutable_local_id();

public:
    // optional string alternate_url = 22;
    bool has_alternate_url() const;

private:
    bool _internal_has_alternate_url() const;

public:
    void clear_alternate_url();
    const std::string& alternate_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_alternate_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_alternate_url();
    PROTOBUF_NODISCARD std::string* release_alternate_url();
    void set_allocated_alternate_url(std::string* alternate_url);

private:
    const std::string& _internal_alternate_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_alternate_url(const std::string& value);
    std::string* _internal_mutable_alternate_url();

public:
    // optional .drive.PlatformFileInfoProto file_info = 1;
    bool has_file_info() const;

private:
    bool _internal_has_file_info() const;

public:
    void clear_file_info();
    const ::drive::PlatformFileInfoProto& file_info() const;
    PROTOBUF_NODISCARD ::drive::PlatformFileInfoProto* release_file_info();
    ::drive::PlatformFileInfoProto* mutable_file_info();
    void set_allocated_file_info(::drive::PlatformFileInfoProto* file_info);

private:
    const ::drive::PlatformFileInfoProto& _internal_file_info() const;
    ::drive::PlatformFileInfoProto* _internal_mutable_file_info();

public:
    void unsafe_arena_set_allocated_file_info(::drive::PlatformFileInfoProto* file_info);
    ::drive::PlatformFileInfoProto* unsafe_arena_release_file_info();

    // optional .drive.FileSpecificInfo file_specific_info = 9;
    bool has_file_specific_info() const;

private:
    bool _internal_has_file_specific_info() const;

public:
    void clear_file_specific_info();
    const ::drive::FileSpecificInfo& file_specific_info() const;
    PROTOBUF_NODISCARD ::drive::FileSpecificInfo* release_file_specific_info();
    ::drive::FileSpecificInfo* mutable_file_specific_info();
    void set_allocated_file_specific_info(::drive::FileSpecificInfo* file_specific_info);

private:
    const ::drive::FileSpecificInfo& _internal_file_specific_info() const;
    ::drive::FileSpecificInfo* _internal_mutable_file_specific_info();

public:
    void unsafe_arena_set_allocated_file_specific_info(::drive::FileSpecificInfo* file_specific_info);
    ::drive::FileSpecificInfo* unsafe_arena_release_file_specific_info();

    // optional .drive.DirectorySpecificInfo directory_specific_info = 13;
    bool has_directory_specific_info() const;

private:
    bool _internal_has_directory_specific_info() const;

public:
    void clear_directory_specific_info();
    const ::drive::DirectorySpecificInfo& directory_specific_info() const;
    PROTOBUF_NODISCARD ::drive::DirectorySpecificInfo* release_directory_specific_info();
    ::drive::DirectorySpecificInfo* mutable_directory_specific_info();
    void set_allocated_directory_specific_info(::drive::DirectorySpecificInfo* directory_specific_info);

private:
    const ::drive::DirectorySpecificInfo& _internal_directory_specific_info() const;
    ::drive::DirectorySpecificInfo* _internal_mutable_directory_specific_info();

public:
    void unsafe_arena_set_allocated_directory_specific_info(::drive::DirectorySpecificInfo* directory_specific_info);
    ::drive::DirectorySpecificInfo* unsafe_arena_release_directory_specific_info();

    // optional .drive.TeamDriveRootSpecificInfo team_drive_root_specific_info = 23;
    bool has_team_drive_root_specific_info() const;

private:
    bool _internal_has_team_drive_root_specific_info() const;

public:
    void clear_team_drive_root_specific_info();
    const ::drive::TeamDriveRootSpecificInfo& team_drive_root_specific_info() const;
    PROTOBUF_NODISCARD ::drive::TeamDriveRootSpecificInfo* release_team_drive_root_specific_info();
    ::drive::TeamDriveRootSpecificInfo* mutable_team_drive_root_specific_info();
    void set_allocated_team_drive_root_specific_info(::drive::TeamDriveRootSpecificInfo* team_drive_root_specific_info);

private:
    const ::drive::TeamDriveRootSpecificInfo& _internal_team_drive_root_specific_info() const;
    ::drive::TeamDriveRootSpecificInfo* _internal_mutable_team_drive_root_specific_info();

public:
    void unsafe_arena_set_allocated_team_drive_root_specific_info(::drive::TeamDriveRootSpecificInfo* team_drive_root_specific_info);
    ::drive::TeamDriveRootSpecificInfo* unsafe_arena_release_team_drive_root_specific_info();

    // optional .drive.CapabilitiesInfo capabilities_info = 24;
    bool has_capabilities_info() const;

private:
    bool _internal_has_capabilities_info() const;

public:
    void clear_capabilities_info();
    const ::drive::CapabilitiesInfo& capabilities_info() const;
    PROTOBUF_NODISCARD ::drive::CapabilitiesInfo* release_capabilities_info();
    ::drive::CapabilitiesInfo* mutable_capabilities_info();
    void set_allocated_capabilities_info(::drive::CapabilitiesInfo* capabilities_info);

private:
    const ::drive::CapabilitiesInfo& _internal_capabilities_info() const;
    ::drive::CapabilitiesInfo* _internal_mutable_capabilities_info();

public:
    void unsafe_arena_set_allocated_capabilities_info(::drive::CapabilitiesInfo* capabilities_info);
    ::drive::CapabilitiesInfo* unsafe_arena_release_capabilities_info();

    // optional bool deleted = 11;
    bool has_deleted() const;

private:
    bool _internal_has_deleted() const;

public:
    void clear_deleted();
    bool deleted() const;
    void set_deleted(bool value);

private:
    bool _internal_deleted() const;
    void _internal_set_deleted(bool value);

public:
    // optional bool starred = 20;
    bool has_starred() const;

private:
    bool _internal_has_starred() const;

public:
    void clear_starred();
    bool starred() const;
    void set_starred(bool value);

private:
    bool _internal_starred() const;
    void _internal_set_starred(bool value);

public:
    // optional bool shared_with_me = 14;
    bool has_shared_with_me() const;

private:
    bool _internal_has_shared_with_me() const;

public:
    void clear_shared_with_me();
    bool shared_with_me() const;
    void set_shared_with_me(bool value);

private:
    bool _internal_shared_with_me() const;
    void _internal_set_shared_with_me(bool value);

public:
    // optional bool shared = 17;
    bool has_shared() const;

private:
    bool _internal_has_shared() const;

public:
    void clear_shared();
    bool shared() const;
    void set_shared(bool value);

private:
    bool _internal_shared() const;
    void _internal_set_shared(bool value);

public:
    // optional .drive.ResourceEntry.EditState metadata_edit_state = 16;
    bool has_metadata_edit_state() const;

private:
    bool _internal_has_metadata_edit_state() const;

public:
    void clear_metadata_edit_state();
    ::drive::ResourceEntry_EditState metadata_edit_state() const;
    void set_metadata_edit_state(::drive::ResourceEntry_EditState value);

private:
    ::drive::ResourceEntry_EditState _internal_metadata_edit_state() const;
    void _internal_set_metadata_edit_state(::drive::ResourceEntry_EditState value);

public:
    // optional int64 modification_date = 18;
    bool has_modification_date() const;

private:
    bool _internal_has_modification_date() const;

public:
    void clear_modification_date();
    int64_t modification_date() const;
    void set_modification_date(int64_t value);

private:
    int64_t _internal_modification_date() const;
    void _internal_set_modification_date(int64_t value);

public:
    // optional int64 last_modified_by_me = 21;
    bool has_last_modified_by_me() const;

private:
    bool _internal_has_last_modified_by_me() const;

public:
    void clear_last_modified_by_me();
    int64_t last_modified_by_me() const;
    void set_last_modified_by_me(int64_t value);

private:
    int64_t _internal_last_modified_by_me() const;
    void _internal_set_last_modified_by_me(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:drive.ResourceEntry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::drive::Property> new_properties_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_local_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alternate_url_;
        ::drive::PlatformFileInfoProto* file_info_;
        ::drive::FileSpecificInfo* file_specific_info_;
        ::drive::DirectorySpecificInfo* directory_specific_info_;
        ::drive::TeamDriveRootSpecificInfo* team_drive_root_specific_info_;
        ::drive::CapabilitiesInfo* capabilities_info_;
        bool deleted_;
        bool starred_;
        bool shared_with_me_;
        bool shared_;
        int metadata_edit_state_;
        int64_t modification_date_;
        int64_t last_modified_by_me_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_drive_2eproto;
};
// -------------------------------------------------------------------

class ResourceMetadataHeader final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:drive.ResourceMetadataHeader) */ {
public:
    inline ResourceMetadataHeader()
        : ResourceMetadataHeader(nullptr)
    {
    }
    ~ResourceMetadataHeader() override;
    explicit PROTOBUF_CONSTEXPR ResourceMetadataHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ResourceMetadataHeader(const ResourceMetadataHeader& from);
    ResourceMetadataHeader(ResourceMetadataHeader&& from) noexcept
        : ResourceMetadataHeader()
    {
        *this = ::std::move(from);
    }

    inline ResourceMetadataHeader& operator=(const ResourceMetadataHeader& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ResourceMetadataHeader& operator=(ResourceMetadataHeader&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ResourceMetadataHeader& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ResourceMetadataHeader* internal_default_instance()
    {
        return reinterpret_cast<const ResourceMetadataHeader*>(&_ResourceMetadataHeader_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(ResourceMetadataHeader& a, ResourceMetadataHeader& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ResourceMetadataHeader* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ResourceMetadataHeader* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ResourceMetadataHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ResourceMetadataHeader>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ResourceMetadataHeader& from);
    void MergeFrom(const ResourceMetadataHeader& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ResourceMetadataHeader* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "drive.ResourceMetadataHeader";
    }

protected:
    explicit ResourceMetadataHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStartPageTokenFieldNumber = 4,
        kLargestChangestampFieldNumber = 2,
        kVersionFieldNumber = 1,
    };
    // optional string start_page_token = 4;
    bool has_start_page_token() const;

private:
    bool _internal_has_start_page_token() const;

public:
    void clear_start_page_token();
    const std::string& start_page_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_start_page_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_start_page_token();
    PROTOBUF_NODISCARD std::string* release_start_page_token();
    void set_allocated_start_page_token(std::string* start_page_token);

private:
    const std::string& _internal_start_page_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_page_token(const std::string& value);
    std::string* _internal_mutable_start_page_token();

public:
    // optional int64 largest_changestamp = 2 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_largest_changestamp() const;

private:
    bool _internal_has_largest_changestamp() const;

public:
    PROTOBUF_DEPRECATED void clear_largest_changestamp();
    PROTOBUF_DEPRECATED int64_t largest_changestamp() const;
    PROTOBUF_DEPRECATED void set_largest_changestamp(int64_t value);

private:
    int64_t _internal_largest_changestamp() const;
    void _internal_set_largest_changestamp(int64_t value);

public:
    // optional int32 version = 1;
    bool has_version() const;

private:
    bool _internal_has_version() const;

public:
    void clear_version();
    int32_t version() const;
    void set_version(int32_t value);

private:
    int32_t _internal_version() const;
    void _internal_set_version(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:drive.ResourceMetadataHeader)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_page_token_;
        int64_t largest_changestamp_;
        int32_t version_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_drive_2eproto;
};
// -------------------------------------------------------------------

class FileCacheEntry final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:drive.FileCacheEntry) */ {
public:
    inline FileCacheEntry()
        : FileCacheEntry(nullptr)
    {
    }
    ~FileCacheEntry() override;
    explicit PROTOBUF_CONSTEXPR FileCacheEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FileCacheEntry(const FileCacheEntry& from);
    FileCacheEntry(FileCacheEntry&& from) noexcept
        : FileCacheEntry()
    {
        *this = ::std::move(from);
    }

    inline FileCacheEntry& operator=(const FileCacheEntry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FileCacheEntry& operator=(FileCacheEntry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const FileCacheEntry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FileCacheEntry* internal_default_instance()
    {
        return reinterpret_cast<const FileCacheEntry*>(&_FileCacheEntry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(FileCacheEntry& a, FileCacheEntry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FileCacheEntry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FileCacheEntry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FileCacheEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FileCacheEntry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FileCacheEntry& from);
    void MergeFrom(const FileCacheEntry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FileCacheEntry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "drive.FileCacheEntry";
    }

protected:
    explicit FileCacheEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kMd5FieldNumber = 1,
        kIsPresentFieldNumber = 2,
        kIsPinnedFieldNumber = 3,
        kIsDirtyFieldNumber = 4,
    };
    // optional string md5 = 1;
    bool has_md5() const;

private:
    bool _internal_has_md5() const;

public:
    void clear_md5();
    const std::string& md5() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_md5(ArgT0&& arg0, ArgT... args);
    std::string* mutable_md5();
    PROTOBUF_NODISCARD std::string* release_md5();
    void set_allocated_md5(std::string* md5);

private:
    const std::string& _internal_md5() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_md5(const std::string& value);
    std::string* _internal_mutable_md5();

public:
    // optional bool is_present = 2;
    bool has_is_present() const;

private:
    bool _internal_has_is_present() const;

public:
    void clear_is_present();
    bool is_present() const;
    void set_is_present(bool value);

private:
    bool _internal_is_present() const;
    void _internal_set_is_present(bool value);

public:
    // optional bool is_pinned = 3;
    bool has_is_pinned() const;

private:
    bool _internal_has_is_pinned() const;

public:
    void clear_is_pinned();
    bool is_pinned() const;
    void set_is_pinned(bool value);

private:
    bool _internal_is_pinned() const;
    void _internal_set_is_pinned(bool value);

public:
    // optional bool is_dirty = 4;
    bool has_is_dirty() const;

private:
    bool _internal_has_is_dirty() const;

public:
    void clear_is_dirty();
    bool is_dirty() const;
    void set_is_dirty(bool value);

private:
    bool _internal_is_dirty() const;
    void _internal_set_is_dirty(bool value);

public:
    // @@protoc_insertion_point(class_scope:drive.FileCacheEntry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr md5_;
        bool is_present_;
        bool is_pinned_;
        bool is_dirty_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_drive_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// PlatformFileInfoProto

// optional int64 size = 1;
inline bool PlatformFileInfoProto::_internal_has_size() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool PlatformFileInfoProto::has_size() const
{
    return _internal_has_size();
}
inline void PlatformFileInfoProto::clear_size()
{
    _impl_.size_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t PlatformFileInfoProto::_internal_size() const
{
    return _impl_.size_;
}
inline int64_t PlatformFileInfoProto::size() const
{
    // @@protoc_insertion_point(field_get:drive.PlatformFileInfoProto.size)
    return _internal_size();
}
inline void PlatformFileInfoProto::_internal_set_size(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.size_ = value;
}
inline void PlatformFileInfoProto::set_size(int64_t value)
{
    _internal_set_size(value);
    // @@protoc_insertion_point(field_set:drive.PlatformFileInfoProto.size)
}

// optional bool is_directory = 2;
inline bool PlatformFileInfoProto::_internal_has_is_directory() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool PlatformFileInfoProto::has_is_directory() const
{
    return _internal_has_is_directory();
}
inline void PlatformFileInfoProto::clear_is_directory()
{
    _impl_.is_directory_ = false;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool PlatformFileInfoProto::_internal_is_directory() const
{
    return _impl_.is_directory_;
}
inline bool PlatformFileInfoProto::is_directory() const
{
    // @@protoc_insertion_point(field_get:drive.PlatformFileInfoProto.is_directory)
    return _internal_is_directory();
}
inline void PlatformFileInfoProto::_internal_set_is_directory(bool value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.is_directory_ = value;
}
inline void PlatformFileInfoProto::set_is_directory(bool value)
{
    _internal_set_is_directory(value);
    // @@protoc_insertion_point(field_set:drive.PlatformFileInfoProto.is_directory)
}

// optional bool is_symbolic_link = 3;
inline bool PlatformFileInfoProto::_internal_has_is_symbolic_link() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool PlatformFileInfoProto::has_is_symbolic_link() const
{
    return _internal_has_is_symbolic_link();
}
inline void PlatformFileInfoProto::clear_is_symbolic_link()
{
    _impl_.is_symbolic_link_ = false;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool PlatformFileInfoProto::_internal_is_symbolic_link() const
{
    return _impl_.is_symbolic_link_;
}
inline bool PlatformFileInfoProto::is_symbolic_link() const
{
    // @@protoc_insertion_point(field_get:drive.PlatformFileInfoProto.is_symbolic_link)
    return _internal_is_symbolic_link();
}
inline void PlatformFileInfoProto::_internal_set_is_symbolic_link(bool value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.is_symbolic_link_ = value;
}
inline void PlatformFileInfoProto::set_is_symbolic_link(bool value)
{
    _internal_set_is_symbolic_link(value);
    // @@protoc_insertion_point(field_set:drive.PlatformFileInfoProto.is_symbolic_link)
}

// optional int64 last_modified = 4;
inline bool PlatformFileInfoProto::_internal_has_last_modified() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool PlatformFileInfoProto::has_last_modified() const
{
    return _internal_has_last_modified();
}
inline void PlatformFileInfoProto::clear_last_modified()
{
    _impl_.last_modified_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t PlatformFileInfoProto::_internal_last_modified() const
{
    return _impl_.last_modified_;
}
inline int64_t PlatformFileInfoProto::last_modified() const
{
    // @@protoc_insertion_point(field_get:drive.PlatformFileInfoProto.last_modified)
    return _internal_last_modified();
}
inline void PlatformFileInfoProto::_internal_set_last_modified(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.last_modified_ = value;
}
inline void PlatformFileInfoProto::set_last_modified(int64_t value)
{
    _internal_set_last_modified(value);
    // @@protoc_insertion_point(field_set:drive.PlatformFileInfoProto.last_modified)
}

// optional int64 last_accessed = 5;
inline bool PlatformFileInfoProto::_internal_has_last_accessed() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool PlatformFileInfoProto::has_last_accessed() const
{
    return _internal_has_last_accessed();
}
inline void PlatformFileInfoProto::clear_last_accessed()
{
    _impl_.last_accessed_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t PlatformFileInfoProto::_internal_last_accessed() const
{
    return _impl_.last_accessed_;
}
inline int64_t PlatformFileInfoProto::last_accessed() const
{
    // @@protoc_insertion_point(field_get:drive.PlatformFileInfoProto.last_accessed)
    return _internal_last_accessed();
}
inline void PlatformFileInfoProto::_internal_set_last_accessed(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.last_accessed_ = value;
}
inline void PlatformFileInfoProto::set_last_accessed(int64_t value)
{
    _internal_set_last_accessed(value);
    // @@protoc_insertion_point(field_set:drive.PlatformFileInfoProto.last_accessed)
}

// optional int64 creation_time = 6;
inline bool PlatformFileInfoProto::_internal_has_creation_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool PlatformFileInfoProto::has_creation_time() const
{
    return _internal_has_creation_time();
}
inline void PlatformFileInfoProto::clear_creation_time()
{
    _impl_.creation_time_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t PlatformFileInfoProto::_internal_creation_time() const
{
    return _impl_.creation_time_;
}
inline int64_t PlatformFileInfoProto::creation_time() const
{
    // @@protoc_insertion_point(field_get:drive.PlatformFileInfoProto.creation_time)
    return _internal_creation_time();
}
inline void PlatformFileInfoProto::_internal_set_creation_time(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.creation_time_ = value;
}
inline void PlatformFileInfoProto::set_creation_time(int64_t value)
{
    _internal_set_creation_time(value);
    // @@protoc_insertion_point(field_set:drive.PlatformFileInfoProto.creation_time)
}

// optional bool is_team_drive_root = 7;
inline bool PlatformFileInfoProto::_internal_has_is_team_drive_root() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool PlatformFileInfoProto::has_is_team_drive_root() const
{
    return _internal_has_is_team_drive_root();
}
inline void PlatformFileInfoProto::clear_is_team_drive_root()
{
    _impl_.is_team_drive_root_ = false;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool PlatformFileInfoProto::_internal_is_team_drive_root() const
{
    return _impl_.is_team_drive_root_;
}
inline bool PlatformFileInfoProto::is_team_drive_root() const
{
    // @@protoc_insertion_point(field_get:drive.PlatformFileInfoProto.is_team_drive_root)
    return _internal_is_team_drive_root();
}
inline void PlatformFileInfoProto::_internal_set_is_team_drive_root(bool value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.is_team_drive_root_ = value;
}
inline void PlatformFileInfoProto::set_is_team_drive_root(bool value)
{
    _internal_set_is_team_drive_root(value);
    // @@protoc_insertion_point(field_set:drive.PlatformFileInfoProto.is_team_drive_root)
}

// -------------------------------------------------------------------

// Property

// optional string key = 1;
inline bool Property::_internal_has_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Property::has_key() const
{
    return _internal_has_key();
}
inline void Property::clear_key()
{
    _impl_.key_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Property::key() const
{
    // @@protoc_insertion_point(field_get:drive.Property.key)
    return _internal_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Property::set_key(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.key_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.Property.key)
}
inline std::string* Property::mutable_key()
{
    std::string* _s = _internal_mutable_key();
    // @@protoc_insertion_point(field_mutable:drive.Property.key)
    return _s;
}
inline const std::string& Property::_internal_key() const
{
    return _impl_.key_.Get();
}
inline void Property::_internal_set_key(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* Property::_internal_mutable_key()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* Property::release_key()
{
    // @@protoc_insertion_point(field_release:drive.Property.key)
    if (!_internal_has_key()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.key_.IsDefault()) {
        _impl_.key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Property::set_allocated_key(std::string* key)
{
    if (key != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.key_.IsDefault()) {
        _impl_.key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.Property.key)
}

// optional string value = 2;
inline bool Property::_internal_has_value() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Property::has_value() const
{
    return _internal_has_value();
}
inline void Property::clear_value()
{
    _impl_.value_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Property::value() const
{
    // @@protoc_insertion_point(field_get:drive.Property.value)
    return _internal_value();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Property::set_value(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.value_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.Property.value)
}
inline std::string* Property::mutable_value()
{
    std::string* _s = _internal_mutable_value();
    // @@protoc_insertion_point(field_mutable:drive.Property.value)
    return _s;
}
inline const std::string& Property::_internal_value() const
{
    return _impl_.value_.Get();
}
inline void Property::_internal_set_value(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Property::_internal_mutable_value()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Property::release_value()
{
    // @@protoc_insertion_point(field_release:drive.Property.value)
    if (!_internal_has_value()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Property::set_allocated_value(std::string* value)
{
    if (value != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.Property.value)
}

// optional .drive.Property.Visibility visibility = 3;
inline bool Property::_internal_has_visibility() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool Property::has_visibility() const
{
    return _internal_has_visibility();
}
inline void Property::clear_visibility()
{
    _impl_.visibility_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::drive::Property_Visibility Property::_internal_visibility() const
{
    return static_cast<::drive::Property_Visibility>(_impl_.visibility_);
}
inline ::drive::Property_Visibility Property::visibility() const
{
    // @@protoc_insertion_point(field_get:drive.Property.visibility)
    return _internal_visibility();
}
inline void Property::_internal_set_visibility(::drive::Property_Visibility value)
{
    assert(::drive::Property_Visibility_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.visibility_ = value;
}
inline void Property::set_visibility(::drive::Property_Visibility value)
{
    _internal_set_visibility(value);
    // @@protoc_insertion_point(field_set:drive.Property.visibility)
}

// -------------------------------------------------------------------

// CapabilitiesInfo

// optional bool can_copy = 1;
inline bool CapabilitiesInfo::_internal_has_can_copy() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool CapabilitiesInfo::has_can_copy() const
{
    return _internal_has_can_copy();
}
inline void CapabilitiesInfo::clear_can_copy()
{
    _impl_.can_copy_ = false;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool CapabilitiesInfo::_internal_can_copy() const
{
    return _impl_.can_copy_;
}
inline bool CapabilitiesInfo::can_copy() const
{
    // @@protoc_insertion_point(field_get:drive.CapabilitiesInfo.can_copy)
    return _internal_can_copy();
}
inline void CapabilitiesInfo::_internal_set_can_copy(bool value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.can_copy_ = value;
}
inline void CapabilitiesInfo::set_can_copy(bool value)
{
    _internal_set_can_copy(value);
    // @@protoc_insertion_point(field_set:drive.CapabilitiesInfo.can_copy)
}

// optional bool can_delete = 2;
inline bool CapabilitiesInfo::_internal_has_can_delete() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool CapabilitiesInfo::has_can_delete() const
{
    return _internal_has_can_delete();
}
inline void CapabilitiesInfo::clear_can_delete()
{
    _impl_.can_delete_ = false;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CapabilitiesInfo::_internal_can_delete() const
{
    return _impl_.can_delete_;
}
inline bool CapabilitiesInfo::can_delete() const
{
    // @@protoc_insertion_point(field_get:drive.CapabilitiesInfo.can_delete)
    return _internal_can_delete();
}
inline void CapabilitiesInfo::_internal_set_can_delete(bool value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.can_delete_ = value;
}
inline void CapabilitiesInfo::set_can_delete(bool value)
{
    _internal_set_can_delete(value);
    // @@protoc_insertion_point(field_set:drive.CapabilitiesInfo.can_delete)
}

// optional bool can_rename = 3;
inline bool CapabilitiesInfo::_internal_has_can_rename() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool CapabilitiesInfo::has_can_rename() const
{
    return _internal_has_can_rename();
}
inline void CapabilitiesInfo::clear_can_rename()
{
    _impl_.can_rename_ = false;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool CapabilitiesInfo::_internal_can_rename() const
{
    return _impl_.can_rename_;
}
inline bool CapabilitiesInfo::can_rename() const
{
    // @@protoc_insertion_point(field_get:drive.CapabilitiesInfo.can_rename)
    return _internal_can_rename();
}
inline void CapabilitiesInfo::_internal_set_can_rename(bool value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.can_rename_ = value;
}
inline void CapabilitiesInfo::set_can_rename(bool value)
{
    _internal_set_can_rename(value);
    // @@protoc_insertion_point(field_set:drive.CapabilitiesInfo.can_rename)
}

// optional bool can_add_children = 4;
inline bool CapabilitiesInfo::_internal_has_can_add_children() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool CapabilitiesInfo::has_can_add_children() const
{
    return _internal_has_can_add_children();
}
inline void CapabilitiesInfo::clear_can_add_children()
{
    _impl_.can_add_children_ = false;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool CapabilitiesInfo::_internal_can_add_children() const
{
    return _impl_.can_add_children_;
}
inline bool CapabilitiesInfo::can_add_children() const
{
    // @@protoc_insertion_point(field_get:drive.CapabilitiesInfo.can_add_children)
    return _internal_can_add_children();
}
inline void CapabilitiesInfo::_internal_set_can_add_children(bool value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.can_add_children_ = value;
}
inline void CapabilitiesInfo::set_can_add_children(bool value)
{
    _internal_set_can_add_children(value);
    // @@protoc_insertion_point(field_set:drive.CapabilitiesInfo.can_add_children)
}

// optional bool can_share = 5;
inline bool CapabilitiesInfo::_internal_has_can_share() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool CapabilitiesInfo::has_can_share() const
{
    return _internal_has_can_share();
}
inline void CapabilitiesInfo::clear_can_share()
{
    _impl_.can_share_ = false;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool CapabilitiesInfo::_internal_can_share() const
{
    return _impl_.can_share_;
}
inline bool CapabilitiesInfo::can_share() const
{
    // @@protoc_insertion_point(field_get:drive.CapabilitiesInfo.can_share)
    return _internal_can_share();
}
inline void CapabilitiesInfo::_internal_set_can_share(bool value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.can_share_ = value;
}
inline void CapabilitiesInfo::set_can_share(bool value)
{
    _internal_set_can_share(value);
    // @@protoc_insertion_point(field_set:drive.CapabilitiesInfo.can_share)
}

// -------------------------------------------------------------------

// FileSpecificInfo

// optional string content_mime_type = 3;
inline bool FileSpecificInfo::_internal_has_content_mime_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool FileSpecificInfo::has_content_mime_type() const
{
    return _internal_has_content_mime_type();
}
inline void FileSpecificInfo::clear_content_mime_type()
{
    _impl_.content_mime_type_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileSpecificInfo::content_mime_type() const
{
    // @@protoc_insertion_point(field_get:drive.FileSpecificInfo.content_mime_type)
    return _internal_content_mime_type();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FileSpecificInfo::set_content_mime_type(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.content_mime_type_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.FileSpecificInfo.content_mime_type)
}
inline std::string* FileSpecificInfo::mutable_content_mime_type()
{
    std::string* _s = _internal_mutable_content_mime_type();
    // @@protoc_insertion_point(field_mutable:drive.FileSpecificInfo.content_mime_type)
    return _s;
}
inline const std::string& FileSpecificInfo::_internal_content_mime_type() const
{
    return _impl_.content_mime_type_.Get();
}
inline void FileSpecificInfo::_internal_set_content_mime_type(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.content_mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* FileSpecificInfo::_internal_mutable_content_mime_type()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.content_mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* FileSpecificInfo::release_content_mime_type()
{
    // @@protoc_insertion_point(field_release:drive.FileSpecificInfo.content_mime_type)
    if (!_internal_has_content_mime_type()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.content_mime_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.content_mime_type_.IsDefault()) {
        _impl_.content_mime_type_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void FileSpecificInfo::set_allocated_content_mime_type(std::string* content_mime_type)
{
    if (content_mime_type != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.content_mime_type_.SetAllocated(content_mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.content_mime_type_.IsDefault()) {
        _impl_.content_mime_type_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.FileSpecificInfo.content_mime_type)
}

// optional string md5 = 4;
inline bool FileSpecificInfo::_internal_has_md5() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool FileSpecificInfo::has_md5() const
{
    return _internal_has_md5();
}
inline void FileSpecificInfo::clear_md5()
{
    _impl_.md5_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FileSpecificInfo::md5() const
{
    // @@protoc_insertion_point(field_get:drive.FileSpecificInfo.md5)
    return _internal_md5();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FileSpecificInfo::set_md5(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.md5_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.FileSpecificInfo.md5)
}
inline std::string* FileSpecificInfo::mutable_md5()
{
    std::string* _s = _internal_mutable_md5();
    // @@protoc_insertion_point(field_mutable:drive.FileSpecificInfo.md5)
    return _s;
}
inline const std::string& FileSpecificInfo::_internal_md5() const
{
    return _impl_.md5_.Get();
}
inline void FileSpecificInfo::_internal_set_md5(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.md5_.Set(value, GetArenaForAllocation());
}
inline std::string* FileSpecificInfo::_internal_mutable_md5()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.md5_.Mutable(GetArenaForAllocation());
}
inline std::string* FileSpecificInfo::release_md5()
{
    // @@protoc_insertion_point(field_release:drive.FileSpecificInfo.md5)
    if (!_internal_has_md5()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.md5_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.md5_.IsDefault()) {
        _impl_.md5_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void FileSpecificInfo::set_allocated_md5(std::string* md5)
{
    if (md5 != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.md5_.SetAllocated(md5, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.md5_.IsDefault()) {
        _impl_.md5_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.FileSpecificInfo.md5)
}

// optional string document_extension = 5;
inline bool FileSpecificInfo::_internal_has_document_extension() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool FileSpecificInfo::has_document_extension() const
{
    return _internal_has_document_extension();
}
inline void FileSpecificInfo::clear_document_extension()
{
    _impl_.document_extension_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FileSpecificInfo::document_extension() const
{
    // @@protoc_insertion_point(field_get:drive.FileSpecificInfo.document_extension)
    return _internal_document_extension();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FileSpecificInfo::set_document_extension(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.document_extension_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.FileSpecificInfo.document_extension)
}
inline std::string* FileSpecificInfo::mutable_document_extension()
{
    std::string* _s = _internal_mutable_document_extension();
    // @@protoc_insertion_point(field_mutable:drive.FileSpecificInfo.document_extension)
    return _s;
}
inline const std::string& FileSpecificInfo::_internal_document_extension() const
{
    return _impl_.document_extension_.Get();
}
inline void FileSpecificInfo::_internal_set_document_extension(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.document_extension_.Set(value, GetArenaForAllocation());
}
inline std::string* FileSpecificInfo::_internal_mutable_document_extension()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.document_extension_.Mutable(GetArenaForAllocation());
}
inline std::string* FileSpecificInfo::release_document_extension()
{
    // @@protoc_insertion_point(field_release:drive.FileSpecificInfo.document_extension)
    if (!_internal_has_document_extension()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.document_extension_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.document_extension_.IsDefault()) {
        _impl_.document_extension_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void FileSpecificInfo::set_allocated_document_extension(std::string* document_extension)
{
    if (document_extension != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.document_extension_.SetAllocated(document_extension, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.document_extension_.IsDefault()) {
        _impl_.document_extension_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.FileSpecificInfo.document_extension)
}

// optional bool is_hosted_document = 6;
inline bool FileSpecificInfo::_internal_has_is_hosted_document() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool FileSpecificInfo::has_is_hosted_document() const
{
    return _internal_has_is_hosted_document();
}
inline void FileSpecificInfo::clear_is_hosted_document()
{
    _impl_.is_hosted_document_ = false;
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool FileSpecificInfo::_internal_is_hosted_document() const
{
    return _impl_.is_hosted_document_;
}
inline bool FileSpecificInfo::is_hosted_document() const
{
    // @@protoc_insertion_point(field_get:drive.FileSpecificInfo.is_hosted_document)
    return _internal_is_hosted_document();
}
inline void FileSpecificInfo::_internal_set_is_hosted_document(bool value)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.is_hosted_document_ = value;
}
inline void FileSpecificInfo::set_is_hosted_document(bool value)
{
    _internal_set_is_hosted_document(value);
    // @@protoc_insertion_point(field_set:drive.FileSpecificInfo.is_hosted_document)
}

// optional int64 image_width = 8;
inline bool FileSpecificInfo::_internal_has_image_width() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool FileSpecificInfo::has_image_width() const
{
    return _internal_has_image_width();
}
inline void FileSpecificInfo::clear_image_width()
{
    _impl_.image_width_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t FileSpecificInfo::_internal_image_width() const
{
    return _impl_.image_width_;
}
inline int64_t FileSpecificInfo::image_width() const
{
    // @@protoc_insertion_point(field_get:drive.FileSpecificInfo.image_width)
    return _internal_image_width();
}
inline void FileSpecificInfo::_internal_set_image_width(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.image_width_ = value;
}
inline void FileSpecificInfo::set_image_width(int64_t value)
{
    _internal_set_image_width(value);
    // @@protoc_insertion_point(field_set:drive.FileSpecificInfo.image_width)
}

// optional int64 image_height = 9;
inline bool FileSpecificInfo::_internal_has_image_height() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool FileSpecificInfo::has_image_height() const
{
    return _internal_has_image_height();
}
inline void FileSpecificInfo::clear_image_height()
{
    _impl_.image_height_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t FileSpecificInfo::_internal_image_height() const
{
    return _impl_.image_height_;
}
inline int64_t FileSpecificInfo::image_height() const
{
    // @@protoc_insertion_point(field_get:drive.FileSpecificInfo.image_height)
    return _internal_image_height();
}
inline void FileSpecificInfo::_internal_set_image_height(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.image_height_ = value;
}
inline void FileSpecificInfo::set_image_height(int64_t value)
{
    _internal_set_image_height(value);
    // @@protoc_insertion_point(field_set:drive.FileSpecificInfo.image_height)
}

// optional int64 image_rotation = 10;
inline bool FileSpecificInfo::_internal_has_image_rotation() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool FileSpecificInfo::has_image_rotation() const
{
    return _internal_has_image_rotation();
}
inline void FileSpecificInfo::clear_image_rotation()
{
    _impl_.image_rotation_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t FileSpecificInfo::_internal_image_rotation() const
{
    return _impl_.image_rotation_;
}
inline int64_t FileSpecificInfo::image_rotation() const
{
    // @@protoc_insertion_point(field_get:drive.FileSpecificInfo.image_rotation)
    return _internal_image_rotation();
}
inline void FileSpecificInfo::_internal_set_image_rotation(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.image_rotation_ = value;
}
inline void FileSpecificInfo::set_image_rotation(int64_t value)
{
    _internal_set_image_rotation(value);
    // @@protoc_insertion_point(field_set:drive.FileSpecificInfo.image_rotation)
}

// optional .drive.FileCacheEntry cache_state = 11;
inline bool FileSpecificInfo::_internal_has_cache_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.cache_state_ != nullptr);
    return value;
}
inline bool FileSpecificInfo::has_cache_state() const
{
    return _internal_has_cache_state();
}
inline void FileSpecificInfo::clear_cache_state()
{
    if (_impl_.cache_state_ != nullptr)
        _impl_.cache_state_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::drive::FileCacheEntry& FileSpecificInfo::_internal_cache_state() const
{
    const ::drive::FileCacheEntry* p = _impl_.cache_state_;
    return p != nullptr ? *p : reinterpret_cast<const ::drive::FileCacheEntry&>(::drive::_FileCacheEntry_default_instance_);
}
inline const ::drive::FileCacheEntry& FileSpecificInfo::cache_state() const
{
    // @@protoc_insertion_point(field_get:drive.FileSpecificInfo.cache_state)
    return _internal_cache_state();
}
inline void FileSpecificInfo::unsafe_arena_set_allocated_cache_state(::drive::FileCacheEntry* cache_state)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cache_state_);
    }
    _impl_.cache_state_ = cache_state;
    if (cache_state) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive.FileSpecificInfo.cache_state)
}
inline ::drive::FileCacheEntry* FileSpecificInfo::release_cache_state()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::drive::FileCacheEntry* temp = _impl_.cache_state_;
    _impl_.cache_state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::drive::FileCacheEntry* FileSpecificInfo::unsafe_arena_release_cache_state()
{
    // @@protoc_insertion_point(field_release:drive.FileSpecificInfo.cache_state)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::drive::FileCacheEntry* temp = _impl_.cache_state_;
    _impl_.cache_state_ = nullptr;
    return temp;
}
inline ::drive::FileCacheEntry* FileSpecificInfo::_internal_mutable_cache_state()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.cache_state_ == nullptr) {
        auto* p = CreateMaybeMessage<::drive::FileCacheEntry>(GetArenaForAllocation());
        _impl_.cache_state_ = p;
    }
    return _impl_.cache_state_;
}
inline ::drive::FileCacheEntry* FileSpecificInfo::mutable_cache_state()
{
    ::drive::FileCacheEntry* _msg = _internal_mutable_cache_state();
    // @@protoc_insertion_point(field_mutable:drive.FileSpecificInfo.cache_state)
    return _msg;
}
inline void FileSpecificInfo::set_allocated_cache_state(::drive::FileCacheEntry* cache_state)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.cache_state_;
    }
    if (cache_state) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cache_state);
        if (message_arena != submessage_arena) {
            cache_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, cache_state, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.cache_state_ = cache_state;
    // @@protoc_insertion_point(field_set_allocated:drive.FileSpecificInfo.cache_state)
}

// -------------------------------------------------------------------

// TeamDriveRootSpecificInfo

// optional string start_page_token = 1;
inline bool TeamDriveRootSpecificInfo::_internal_has_start_page_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool TeamDriveRootSpecificInfo::has_start_page_token() const
{
    return _internal_has_start_page_token();
}
inline void TeamDriveRootSpecificInfo::clear_start_page_token()
{
    _impl_.start_page_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TeamDriveRootSpecificInfo::start_page_token() const
{
    // @@protoc_insertion_point(field_get:drive.TeamDriveRootSpecificInfo.start_page_token)
    return _internal_start_page_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void TeamDriveRootSpecificInfo::set_start_page_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.start_page_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.TeamDriveRootSpecificInfo.start_page_token)
}
inline std::string* TeamDriveRootSpecificInfo::mutable_start_page_token()
{
    std::string* _s = _internal_mutable_start_page_token();
    // @@protoc_insertion_point(field_mutable:drive.TeamDriveRootSpecificInfo.start_page_token)
    return _s;
}
inline const std::string& TeamDriveRootSpecificInfo::_internal_start_page_token() const
{
    return _impl_.start_page_token_.Get();
}
inline void TeamDriveRootSpecificInfo::_internal_set_start_page_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.start_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* TeamDriveRootSpecificInfo::_internal_mutable_start_page_token()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.start_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* TeamDriveRootSpecificInfo::release_start_page_token()
{
    // @@protoc_insertion_point(field_release:drive.TeamDriveRootSpecificInfo.start_page_token)
    if (!_internal_has_start_page_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.start_page_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.start_page_token_.IsDefault()) {
        _impl_.start_page_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void TeamDriveRootSpecificInfo::set_allocated_start_page_token(std::string* start_page_token)
{
    if (start_page_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.start_page_token_.SetAllocated(start_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.start_page_token_.IsDefault()) {
        _impl_.start_page_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.TeamDriveRootSpecificInfo.start_page_token)
}

// -------------------------------------------------------------------

// DirectorySpecificInfo

// optional int64 changestamp = 1 [deprecated = true];
inline bool DirectorySpecificInfo::_internal_has_changestamp() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool DirectorySpecificInfo::has_changestamp() const
{
    return _internal_has_changestamp();
}
inline void DirectorySpecificInfo::clear_changestamp()
{
    _impl_.changestamp_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t DirectorySpecificInfo::_internal_changestamp() const
{
    return _impl_.changestamp_;
}
inline int64_t DirectorySpecificInfo::changestamp() const
{
    // @@protoc_insertion_point(field_get:drive.DirectorySpecificInfo.changestamp)
    return _internal_changestamp();
}
inline void DirectorySpecificInfo::_internal_set_changestamp(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.changestamp_ = value;
}
inline void DirectorySpecificInfo::set_changestamp(int64_t value)
{
    _internal_set_changestamp(value);
    // @@protoc_insertion_point(field_set:drive.DirectorySpecificInfo.changestamp)
}

// optional string start_page_token = 2;
inline bool DirectorySpecificInfo::_internal_has_start_page_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool DirectorySpecificInfo::has_start_page_token() const
{
    return _internal_has_start_page_token();
}
inline void DirectorySpecificInfo::clear_start_page_token()
{
    _impl_.start_page_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DirectorySpecificInfo::start_page_token() const
{
    // @@protoc_insertion_point(field_get:drive.DirectorySpecificInfo.start_page_token)
    return _internal_start_page_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DirectorySpecificInfo::set_start_page_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.start_page_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.DirectorySpecificInfo.start_page_token)
}
inline std::string* DirectorySpecificInfo::mutable_start_page_token()
{
    std::string* _s = _internal_mutable_start_page_token();
    // @@protoc_insertion_point(field_mutable:drive.DirectorySpecificInfo.start_page_token)
    return _s;
}
inline const std::string& DirectorySpecificInfo::_internal_start_page_token() const
{
    return _impl_.start_page_token_.Get();
}
inline void DirectorySpecificInfo::_internal_set_start_page_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.start_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* DirectorySpecificInfo::_internal_mutable_start_page_token()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.start_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* DirectorySpecificInfo::release_start_page_token()
{
    // @@protoc_insertion_point(field_release:drive.DirectorySpecificInfo.start_page_token)
    if (!_internal_has_start_page_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.start_page_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.start_page_token_.IsDefault()) {
        _impl_.start_page_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DirectorySpecificInfo::set_allocated_start_page_token(std::string* start_page_token)
{
    if (start_page_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.start_page_token_.SetAllocated(start_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.start_page_token_.IsDefault()) {
        _impl_.start_page_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.DirectorySpecificInfo.start_page_token)
}

// optional int64 last_read_time_ms = 3;
inline bool DirectorySpecificInfo::_internal_has_last_read_time_ms() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool DirectorySpecificInfo::has_last_read_time_ms() const
{
    return _internal_has_last_read_time_ms();
}
inline void DirectorySpecificInfo::clear_last_read_time_ms()
{
    _impl_.last_read_time_ms_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t DirectorySpecificInfo::_internal_last_read_time_ms() const
{
    return _impl_.last_read_time_ms_;
}
inline int64_t DirectorySpecificInfo::last_read_time_ms() const
{
    // @@protoc_insertion_point(field_get:drive.DirectorySpecificInfo.last_read_time_ms)
    return _internal_last_read_time_ms();
}
inline void DirectorySpecificInfo::_internal_set_last_read_time_ms(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.last_read_time_ms_ = value;
}
inline void DirectorySpecificInfo::set_last_read_time_ms(int64_t value)
{
    _internal_set_last_read_time_ms(value);
    // @@protoc_insertion_point(field_set:drive.DirectorySpecificInfo.last_read_time_ms)
}

// -------------------------------------------------------------------

// ResourceEntry

// optional .drive.PlatformFileInfoProto file_info = 1;
inline bool ResourceEntry::_internal_has_file_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.file_info_ != nullptr);
    return value;
}
inline bool ResourceEntry::has_file_info() const
{
    return _internal_has_file_info();
}
inline void ResourceEntry::clear_file_info()
{
    if (_impl_.file_info_ != nullptr)
        _impl_.file_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::drive::PlatformFileInfoProto& ResourceEntry::_internal_file_info() const
{
    const ::drive::PlatformFileInfoProto* p = _impl_.file_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::drive::PlatformFileInfoProto&>(::drive::_PlatformFileInfoProto_default_instance_);
}
inline const ::drive::PlatformFileInfoProto& ResourceEntry::file_info() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.file_info)
    return _internal_file_info();
}
inline void ResourceEntry::unsafe_arena_set_allocated_file_info(::drive::PlatformFileInfoProto* file_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.file_info_);
    }
    _impl_.file_info_ = file_info;
    if (file_info) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive.ResourceEntry.file_info)
}
inline ::drive::PlatformFileInfoProto* ResourceEntry::release_file_info()
{
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::drive::PlatformFileInfoProto* temp = _impl_.file_info_;
    _impl_.file_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::drive::PlatformFileInfoProto* ResourceEntry::unsafe_arena_release_file_info()
{
    // @@protoc_insertion_point(field_release:drive.ResourceEntry.file_info)
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::drive::PlatformFileInfoProto* temp = _impl_.file_info_;
    _impl_.file_info_ = nullptr;
    return temp;
}
inline ::drive::PlatformFileInfoProto* ResourceEntry::_internal_mutable_file_info()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    if (_impl_.file_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::drive::PlatformFileInfoProto>(GetArenaForAllocation());
        _impl_.file_info_ = p;
    }
    return _impl_.file_info_;
}
inline ::drive::PlatformFileInfoProto* ResourceEntry::mutable_file_info()
{
    ::drive::PlatformFileInfoProto* _msg = _internal_mutable_file_info();
    // @@protoc_insertion_point(field_mutable:drive.ResourceEntry.file_info)
    return _msg;
}
inline void ResourceEntry::set_allocated_file_info(::drive::PlatformFileInfoProto* file_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.file_info_;
    }
    if (file_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(file_info);
        if (message_arena != submessage_arena) {
            file_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, file_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.file_info_ = file_info;
    // @@protoc_insertion_point(field_set_allocated:drive.ResourceEntry.file_info)
}

// optional string base_name = 2;
inline bool ResourceEntry::_internal_has_base_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ResourceEntry::has_base_name() const
{
    return _internal_has_base_name();
}
inline void ResourceEntry::clear_base_name()
{
    _impl_.base_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResourceEntry::base_name() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.base_name)
    return _internal_base_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ResourceEntry::set_base_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.base_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.ResourceEntry.base_name)
}
inline std::string* ResourceEntry::mutable_base_name()
{
    std::string* _s = _internal_mutable_base_name();
    // @@protoc_insertion_point(field_mutable:drive.ResourceEntry.base_name)
    return _s;
}
inline const std::string& ResourceEntry::_internal_base_name() const
{
    return _impl_.base_name_.Get();
}
inline void ResourceEntry::_internal_set_base_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.base_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceEntry::_internal_mutable_base_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.base_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceEntry::release_base_name()
{
    // @@protoc_insertion_point(field_release:drive.ResourceEntry.base_name)
    if (!_internal_has_base_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.base_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.base_name_.IsDefault()) {
        _impl_.base_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ResourceEntry::set_allocated_base_name(std::string* base_name)
{
    if (base_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.base_name_.SetAllocated(base_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.base_name_.IsDefault()) {
        _impl_.base_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.ResourceEntry.base_name)
}

// optional string title = 3;
inline bool ResourceEntry::_internal_has_title() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ResourceEntry::has_title() const
{
    return _internal_has_title();
}
inline void ResourceEntry::clear_title()
{
    _impl_.title_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResourceEntry::title() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.title)
    return _internal_title();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ResourceEntry::set_title(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.title_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.ResourceEntry.title)
}
inline std::string* ResourceEntry::mutable_title()
{
    std::string* _s = _internal_mutable_title();
    // @@protoc_insertion_point(field_mutable:drive.ResourceEntry.title)
    return _s;
}
inline const std::string& ResourceEntry::_internal_title() const
{
    return _impl_.title_.Get();
}
inline void ResourceEntry::_internal_set_title(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceEntry::_internal_mutable_title()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceEntry::release_title()
{
    // @@protoc_insertion_point(field_release:drive.ResourceEntry.title)
    if (!_internal_has_title()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.title_.IsDefault()) {
        _impl_.title_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ResourceEntry::set_allocated_title(std::string* title)
{
    if (title != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.title_.IsDefault()) {
        _impl_.title_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.ResourceEntry.title)
}

// optional string resource_id = 4;
inline bool ResourceEntry::_internal_has_resource_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ResourceEntry::has_resource_id() const
{
    return _internal_has_resource_id();
}
inline void ResourceEntry::clear_resource_id()
{
    _impl_.resource_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ResourceEntry::resource_id() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.resource_id)
    return _internal_resource_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ResourceEntry::set_resource_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.resource_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.ResourceEntry.resource_id)
}
inline std::string* ResourceEntry::mutable_resource_id()
{
    std::string* _s = _internal_mutable_resource_id();
    // @@protoc_insertion_point(field_mutable:drive.ResourceEntry.resource_id)
    return _s;
}
inline const std::string& ResourceEntry::_internal_resource_id() const
{
    return _impl_.resource_id_.Get();
}
inline void ResourceEntry::_internal_set_resource_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.resource_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceEntry::_internal_mutable_resource_id()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.resource_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceEntry::release_resource_id()
{
    // @@protoc_insertion_point(field_release:drive.ResourceEntry.resource_id)
    if (!_internal_has_resource_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.resource_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.resource_id_.IsDefault()) {
        _impl_.resource_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ResourceEntry::set_allocated_resource_id(std::string* resource_id)
{
    if (resource_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.resource_id_.SetAllocated(resource_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.resource_id_.IsDefault()) {
        _impl_.resource_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.ResourceEntry.resource_id)
}

// optional string local_id = 15;
inline bool ResourceEntry::_internal_has_local_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool ResourceEntry::has_local_id() const
{
    return _internal_has_local_id();
}
inline void ResourceEntry::clear_local_id()
{
    _impl_.local_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ResourceEntry::local_id() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.local_id)
    return _internal_local_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ResourceEntry::set_local_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.local_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.ResourceEntry.local_id)
}
inline std::string* ResourceEntry::mutable_local_id()
{
    std::string* _s = _internal_mutable_local_id();
    // @@protoc_insertion_point(field_mutable:drive.ResourceEntry.local_id)
    return _s;
}
inline const std::string& ResourceEntry::_internal_local_id() const
{
    return _impl_.local_id_.Get();
}
inline void ResourceEntry::_internal_set_local_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.local_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceEntry::_internal_mutable_local_id()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    return _impl_.local_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceEntry::release_local_id()
{
    // @@protoc_insertion_point(field_release:drive.ResourceEntry.local_id)
    if (!_internal_has_local_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000010u;
    auto* p = _impl_.local_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.local_id_.IsDefault()) {
        _impl_.local_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ResourceEntry::set_allocated_local_id(std::string* local_id)
{
    if (local_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.local_id_.SetAllocated(local_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.local_id_.IsDefault()) {
        _impl_.local_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.ResourceEntry.local_id)
}

// optional string parent_local_id = 7;
inline bool ResourceEntry::_internal_has_parent_local_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ResourceEntry::has_parent_local_id() const
{
    return _internal_has_parent_local_id();
}
inline void ResourceEntry::clear_parent_local_id()
{
    _impl_.parent_local_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ResourceEntry::parent_local_id() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.parent_local_id)
    return _internal_parent_local_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ResourceEntry::set_parent_local_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.parent_local_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.ResourceEntry.parent_local_id)
}
inline std::string* ResourceEntry::mutable_parent_local_id()
{
    std::string* _s = _internal_mutable_parent_local_id();
    // @@protoc_insertion_point(field_mutable:drive.ResourceEntry.parent_local_id)
    return _s;
}
inline const std::string& ResourceEntry::_internal_parent_local_id() const
{
    return _impl_.parent_local_id_.Get();
}
inline void ResourceEntry::_internal_set_parent_local_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.parent_local_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceEntry::_internal_mutable_parent_local_id()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.parent_local_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceEntry::release_parent_local_id()
{
    // @@protoc_insertion_point(field_release:drive.ResourceEntry.parent_local_id)
    if (!_internal_has_parent_local_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.parent_local_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.parent_local_id_.IsDefault()) {
        _impl_.parent_local_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ResourceEntry::set_allocated_parent_local_id(std::string* parent_local_id)
{
    if (parent_local_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.parent_local_id_.SetAllocated(parent_local_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.parent_local_id_.IsDefault()) {
        _impl_.parent_local_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.ResourceEntry.parent_local_id)
}

// optional bool deleted = 11;
inline bool ResourceEntry::_internal_has_deleted() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    return value;
}
inline bool ResourceEntry::has_deleted() const
{
    return _internal_has_deleted();
}
inline void ResourceEntry::clear_deleted()
{
    _impl_.deleted_ = false;
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool ResourceEntry::_internal_deleted() const
{
    return _impl_.deleted_;
}
inline bool ResourceEntry::deleted() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.deleted)
    return _internal_deleted();
}
inline void ResourceEntry::_internal_set_deleted(bool value)
{
    _impl_._has_bits_[0] |= 0x00000800u;
    _impl_.deleted_ = value;
}
inline void ResourceEntry::set_deleted(bool value)
{
    _internal_set_deleted(value);
    // @@protoc_insertion_point(field_set:drive.ResourceEntry.deleted)
}

// optional bool starred = 20;
inline bool ResourceEntry::_internal_has_starred() const
{
    bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
    return value;
}
inline bool ResourceEntry::has_starred() const
{
    return _internal_has_starred();
}
inline void ResourceEntry::clear_starred()
{
    _impl_.starred_ = false;
    _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool ResourceEntry::_internal_starred() const
{
    return _impl_.starred_;
}
inline bool ResourceEntry::starred() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.starred)
    return _internal_starred();
}
inline void ResourceEntry::_internal_set_starred(bool value)
{
    _impl_._has_bits_[0] |= 0x00001000u;
    _impl_.starred_ = value;
}
inline void ResourceEntry::set_starred(bool value)
{
    _internal_set_starred(value);
    // @@protoc_insertion_point(field_set:drive.ResourceEntry.starred)
}

// optional bool shared_with_me = 14;
inline bool ResourceEntry::_internal_has_shared_with_me() const
{
    bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
    return value;
}
inline bool ResourceEntry::has_shared_with_me() const
{
    return _internal_has_shared_with_me();
}
inline void ResourceEntry::clear_shared_with_me()
{
    _impl_.shared_with_me_ = false;
    _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool ResourceEntry::_internal_shared_with_me() const
{
    return _impl_.shared_with_me_;
}
inline bool ResourceEntry::shared_with_me() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.shared_with_me)
    return _internal_shared_with_me();
}
inline void ResourceEntry::_internal_set_shared_with_me(bool value)
{
    _impl_._has_bits_[0] |= 0x00002000u;
    _impl_.shared_with_me_ = value;
}
inline void ResourceEntry::set_shared_with_me(bool value)
{
    _internal_set_shared_with_me(value);
    // @@protoc_insertion_point(field_set:drive.ResourceEntry.shared_with_me)
}

// optional bool shared = 17;
inline bool ResourceEntry::_internal_has_shared() const
{
    bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
    return value;
}
inline bool ResourceEntry::has_shared() const
{
    return _internal_has_shared();
}
inline void ResourceEntry::clear_shared()
{
    _impl_.shared_ = false;
    _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool ResourceEntry::_internal_shared() const
{
    return _impl_.shared_;
}
inline bool ResourceEntry::shared() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.shared)
    return _internal_shared();
}
inline void ResourceEntry::_internal_set_shared(bool value)
{
    _impl_._has_bits_[0] |= 0x00004000u;
    _impl_.shared_ = value;
}
inline void ResourceEntry::set_shared(bool value)
{
    _internal_set_shared(value);
    // @@protoc_insertion_point(field_set:drive.ResourceEntry.shared)
}

// optional .drive.CapabilitiesInfo capabilities_info = 24;
inline bool ResourceEntry::_internal_has_capabilities_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.capabilities_info_ != nullptr);
    return value;
}
inline bool ResourceEntry::has_capabilities_info() const
{
    return _internal_has_capabilities_info();
}
inline void ResourceEntry::clear_capabilities_info()
{
    if (_impl_.capabilities_info_ != nullptr)
        _impl_.capabilities_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::drive::CapabilitiesInfo& ResourceEntry::_internal_capabilities_info() const
{
    const ::drive::CapabilitiesInfo* p = _impl_.capabilities_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::drive::CapabilitiesInfo&>(::drive::_CapabilitiesInfo_default_instance_);
}
inline const ::drive::CapabilitiesInfo& ResourceEntry::capabilities_info() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.capabilities_info)
    return _internal_capabilities_info();
}
inline void ResourceEntry::unsafe_arena_set_allocated_capabilities_info(::drive::CapabilitiesInfo* capabilities_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.capabilities_info_);
    }
    _impl_.capabilities_info_ = capabilities_info;
    if (capabilities_info) {
        _impl_._has_bits_[0] |= 0x00000400u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000400u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive.ResourceEntry.capabilities_info)
}
inline ::drive::CapabilitiesInfo* ResourceEntry::release_capabilities_info()
{
    _impl_._has_bits_[0] &= ~0x00000400u;
    ::drive::CapabilitiesInfo* temp = _impl_.capabilities_info_;
    _impl_.capabilities_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::drive::CapabilitiesInfo* ResourceEntry::unsafe_arena_release_capabilities_info()
{
    // @@protoc_insertion_point(field_release:drive.ResourceEntry.capabilities_info)
    _impl_._has_bits_[0] &= ~0x00000400u;
    ::drive::CapabilitiesInfo* temp = _impl_.capabilities_info_;
    _impl_.capabilities_info_ = nullptr;
    return temp;
}
inline ::drive::CapabilitiesInfo* ResourceEntry::_internal_mutable_capabilities_info()
{
    _impl_._has_bits_[0] |= 0x00000400u;
    if (_impl_.capabilities_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::drive::CapabilitiesInfo>(GetArenaForAllocation());
        _impl_.capabilities_info_ = p;
    }
    return _impl_.capabilities_info_;
}
inline ::drive::CapabilitiesInfo* ResourceEntry::mutable_capabilities_info()
{
    ::drive::CapabilitiesInfo* _msg = _internal_mutable_capabilities_info();
    // @@protoc_insertion_point(field_mutable:drive.ResourceEntry.capabilities_info)
    return _msg;
}
inline void ResourceEntry::set_allocated_capabilities_info(::drive::CapabilitiesInfo* capabilities_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.capabilities_info_;
    }
    if (capabilities_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(capabilities_info);
        if (message_arena != submessage_arena) {
            capabilities_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, capabilities_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000400u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000400u;
    }
    _impl_.capabilities_info_ = capabilities_info;
    // @@protoc_insertion_point(field_set_allocated:drive.ResourceEntry.capabilities_info)
}

// optional .drive.FileSpecificInfo file_specific_info = 9;
inline bool ResourceEntry::_internal_has_file_specific_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.file_specific_info_ != nullptr);
    return value;
}
inline bool ResourceEntry::has_file_specific_info() const
{
    return _internal_has_file_specific_info();
}
inline void ResourceEntry::clear_file_specific_info()
{
    if (_impl_.file_specific_info_ != nullptr)
        _impl_.file_specific_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::drive::FileSpecificInfo& ResourceEntry::_internal_file_specific_info() const
{
    const ::drive::FileSpecificInfo* p = _impl_.file_specific_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::drive::FileSpecificInfo&>(::drive::_FileSpecificInfo_default_instance_);
}
inline const ::drive::FileSpecificInfo& ResourceEntry::file_specific_info() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.file_specific_info)
    return _internal_file_specific_info();
}
inline void ResourceEntry::unsafe_arena_set_allocated_file_specific_info(::drive::FileSpecificInfo* file_specific_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.file_specific_info_);
    }
    _impl_.file_specific_info_ = file_specific_info;
    if (file_specific_info) {
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive.ResourceEntry.file_specific_info)
}
inline ::drive::FileSpecificInfo* ResourceEntry::release_file_specific_info()
{
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::drive::FileSpecificInfo* temp = _impl_.file_specific_info_;
    _impl_.file_specific_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::drive::FileSpecificInfo* ResourceEntry::unsafe_arena_release_file_specific_info()
{
    // @@protoc_insertion_point(field_release:drive.ResourceEntry.file_specific_info)
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::drive::FileSpecificInfo* temp = _impl_.file_specific_info_;
    _impl_.file_specific_info_ = nullptr;
    return temp;
}
inline ::drive::FileSpecificInfo* ResourceEntry::_internal_mutable_file_specific_info()
{
    _impl_._has_bits_[0] |= 0x00000080u;
    if (_impl_.file_specific_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::drive::FileSpecificInfo>(GetArenaForAllocation());
        _impl_.file_specific_info_ = p;
    }
    return _impl_.file_specific_info_;
}
inline ::drive::FileSpecificInfo* ResourceEntry::mutable_file_specific_info()
{
    ::drive::FileSpecificInfo* _msg = _internal_mutable_file_specific_info();
    // @@protoc_insertion_point(field_mutable:drive.ResourceEntry.file_specific_info)
    return _msg;
}
inline void ResourceEntry::set_allocated_file_specific_info(::drive::FileSpecificInfo* file_specific_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.file_specific_info_;
    }
    if (file_specific_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(file_specific_info);
        if (message_arena != submessage_arena) {
            file_specific_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, file_specific_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    _impl_.file_specific_info_ = file_specific_info;
    // @@protoc_insertion_point(field_set_allocated:drive.ResourceEntry.file_specific_info)
}

// optional .drive.DirectorySpecificInfo directory_specific_info = 13;
inline bool ResourceEntry::_internal_has_directory_specific_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.directory_specific_info_ != nullptr);
    return value;
}
inline bool ResourceEntry::has_directory_specific_info() const
{
    return _internal_has_directory_specific_info();
}
inline void ResourceEntry::clear_directory_specific_info()
{
    if (_impl_.directory_specific_info_ != nullptr)
        _impl_.directory_specific_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::drive::DirectorySpecificInfo& ResourceEntry::_internal_directory_specific_info() const
{
    const ::drive::DirectorySpecificInfo* p = _impl_.directory_specific_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::drive::DirectorySpecificInfo&>(::drive::_DirectorySpecificInfo_default_instance_);
}
inline const ::drive::DirectorySpecificInfo& ResourceEntry::directory_specific_info() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.directory_specific_info)
    return _internal_directory_specific_info();
}
inline void ResourceEntry::unsafe_arena_set_allocated_directory_specific_info(::drive::DirectorySpecificInfo* directory_specific_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.directory_specific_info_);
    }
    _impl_.directory_specific_info_ = directory_specific_info;
    if (directory_specific_info) {
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive.ResourceEntry.directory_specific_info)
}
inline ::drive::DirectorySpecificInfo* ResourceEntry::release_directory_specific_info()
{
    _impl_._has_bits_[0] &= ~0x00000100u;
    ::drive::DirectorySpecificInfo* temp = _impl_.directory_specific_info_;
    _impl_.directory_specific_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::drive::DirectorySpecificInfo* ResourceEntry::unsafe_arena_release_directory_specific_info()
{
    // @@protoc_insertion_point(field_release:drive.ResourceEntry.directory_specific_info)
    _impl_._has_bits_[0] &= ~0x00000100u;
    ::drive::DirectorySpecificInfo* temp = _impl_.directory_specific_info_;
    _impl_.directory_specific_info_ = nullptr;
    return temp;
}
inline ::drive::DirectorySpecificInfo* ResourceEntry::_internal_mutable_directory_specific_info()
{
    _impl_._has_bits_[0] |= 0x00000100u;
    if (_impl_.directory_specific_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::drive::DirectorySpecificInfo>(GetArenaForAllocation());
        _impl_.directory_specific_info_ = p;
    }
    return _impl_.directory_specific_info_;
}
inline ::drive::DirectorySpecificInfo* ResourceEntry::mutable_directory_specific_info()
{
    ::drive::DirectorySpecificInfo* _msg = _internal_mutable_directory_specific_info();
    // @@protoc_insertion_point(field_mutable:drive.ResourceEntry.directory_specific_info)
    return _msg;
}
inline void ResourceEntry::set_allocated_directory_specific_info(::drive::DirectorySpecificInfo* directory_specific_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.directory_specific_info_;
    }
    if (directory_specific_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(directory_specific_info);
        if (message_arena != submessage_arena) {
            directory_specific_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, directory_specific_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    _impl_.directory_specific_info_ = directory_specific_info;
    // @@protoc_insertion_point(field_set_allocated:drive.ResourceEntry.directory_specific_info)
}

// optional .drive.TeamDriveRootSpecificInfo team_drive_root_specific_info = 23;
inline bool ResourceEntry::_internal_has_team_drive_root_specific_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.team_drive_root_specific_info_ != nullptr);
    return value;
}
inline bool ResourceEntry::has_team_drive_root_specific_info() const
{
    return _internal_has_team_drive_root_specific_info();
}
inline void ResourceEntry::clear_team_drive_root_specific_info()
{
    if (_impl_.team_drive_root_specific_info_ != nullptr)
        _impl_.team_drive_root_specific_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::drive::TeamDriveRootSpecificInfo& ResourceEntry::_internal_team_drive_root_specific_info() const
{
    const ::drive::TeamDriveRootSpecificInfo* p = _impl_.team_drive_root_specific_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::drive::TeamDriveRootSpecificInfo&>(::drive::_TeamDriveRootSpecificInfo_default_instance_);
}
inline const ::drive::TeamDriveRootSpecificInfo& ResourceEntry::team_drive_root_specific_info() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.team_drive_root_specific_info)
    return _internal_team_drive_root_specific_info();
}
inline void ResourceEntry::unsafe_arena_set_allocated_team_drive_root_specific_info(::drive::TeamDriveRootSpecificInfo* team_drive_root_specific_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.team_drive_root_specific_info_);
    }
    _impl_.team_drive_root_specific_info_ = team_drive_root_specific_info;
    if (team_drive_root_specific_info) {
        _impl_._has_bits_[0] |= 0x00000200u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000200u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:drive.ResourceEntry.team_drive_root_specific_info)
}
inline ::drive::TeamDriveRootSpecificInfo* ResourceEntry::release_team_drive_root_specific_info()
{
    _impl_._has_bits_[0] &= ~0x00000200u;
    ::drive::TeamDriveRootSpecificInfo* temp = _impl_.team_drive_root_specific_info_;
    _impl_.team_drive_root_specific_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::drive::TeamDriveRootSpecificInfo* ResourceEntry::unsafe_arena_release_team_drive_root_specific_info()
{
    // @@protoc_insertion_point(field_release:drive.ResourceEntry.team_drive_root_specific_info)
    _impl_._has_bits_[0] &= ~0x00000200u;
    ::drive::TeamDriveRootSpecificInfo* temp = _impl_.team_drive_root_specific_info_;
    _impl_.team_drive_root_specific_info_ = nullptr;
    return temp;
}
inline ::drive::TeamDriveRootSpecificInfo* ResourceEntry::_internal_mutable_team_drive_root_specific_info()
{
    _impl_._has_bits_[0] |= 0x00000200u;
    if (_impl_.team_drive_root_specific_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::drive::TeamDriveRootSpecificInfo>(GetArenaForAllocation());
        _impl_.team_drive_root_specific_info_ = p;
    }
    return _impl_.team_drive_root_specific_info_;
}
inline ::drive::TeamDriveRootSpecificInfo* ResourceEntry::mutable_team_drive_root_specific_info()
{
    ::drive::TeamDriveRootSpecificInfo* _msg = _internal_mutable_team_drive_root_specific_info();
    // @@protoc_insertion_point(field_mutable:drive.ResourceEntry.team_drive_root_specific_info)
    return _msg;
}
inline void ResourceEntry::set_allocated_team_drive_root_specific_info(::drive::TeamDriveRootSpecificInfo* team_drive_root_specific_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.team_drive_root_specific_info_;
    }
    if (team_drive_root_specific_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(team_drive_root_specific_info);
        if (message_arena != submessage_arena) {
            team_drive_root_specific_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, team_drive_root_specific_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000200u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000200u;
    }
    _impl_.team_drive_root_specific_info_ = team_drive_root_specific_info;
    // @@protoc_insertion_point(field_set_allocated:drive.ResourceEntry.team_drive_root_specific_info)
}

// optional .drive.ResourceEntry.EditState metadata_edit_state = 16;
inline bool ResourceEntry::_internal_has_metadata_edit_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
    return value;
}
inline bool ResourceEntry::has_metadata_edit_state() const
{
    return _internal_has_metadata_edit_state();
}
inline void ResourceEntry::clear_metadata_edit_state()
{
    _impl_.metadata_edit_state_ = 0;
    _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::drive::ResourceEntry_EditState ResourceEntry::_internal_metadata_edit_state() const
{
    return static_cast<::drive::ResourceEntry_EditState>(_impl_.metadata_edit_state_);
}
inline ::drive::ResourceEntry_EditState ResourceEntry::metadata_edit_state() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.metadata_edit_state)
    return _internal_metadata_edit_state();
}
inline void ResourceEntry::_internal_set_metadata_edit_state(::drive::ResourceEntry_EditState value)
{
    assert(::drive::ResourceEntry_EditState_IsValid(value));
    _impl_._has_bits_[0] |= 0x00008000u;
    _impl_.metadata_edit_state_ = value;
}
inline void ResourceEntry::set_metadata_edit_state(::drive::ResourceEntry_EditState value)
{
    _internal_set_metadata_edit_state(value);
    // @@protoc_insertion_point(field_set:drive.ResourceEntry.metadata_edit_state)
}

// optional int64 modification_date = 18;
inline bool ResourceEntry::_internal_has_modification_date() const
{
    bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
    return value;
}
inline bool ResourceEntry::has_modification_date() const
{
    return _internal_has_modification_date();
}
inline void ResourceEntry::clear_modification_date()
{
    _impl_.modification_date_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00010000u;
}
inline int64_t ResourceEntry::_internal_modification_date() const
{
    return _impl_.modification_date_;
}
inline int64_t ResourceEntry::modification_date() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.modification_date)
    return _internal_modification_date();
}
inline void ResourceEntry::_internal_set_modification_date(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00010000u;
    _impl_.modification_date_ = value;
}
inline void ResourceEntry::set_modification_date(int64_t value)
{
    _internal_set_modification_date(value);
    // @@protoc_insertion_point(field_set:drive.ResourceEntry.modification_date)
}

// repeated .drive.Property new_properties = 19;
inline int ResourceEntry::_internal_new_properties_size() const
{
    return _impl_.new_properties_.size();
}
inline int ResourceEntry::new_properties_size() const
{
    return _internal_new_properties_size();
}
inline void ResourceEntry::clear_new_properties()
{
    _impl_.new_properties_.Clear();
}
inline ::drive::Property* ResourceEntry::mutable_new_properties(int index)
{
    // @@protoc_insertion_point(field_mutable:drive.ResourceEntry.new_properties)
    return _impl_.new_properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::drive::Property>* ResourceEntry::mutable_new_properties()
{
    // @@protoc_insertion_point(field_mutable_list:drive.ResourceEntry.new_properties)
    return &_impl_.new_properties_;
}
inline const ::drive::Property& ResourceEntry::_internal_new_properties(int index) const
{
    return _impl_.new_properties_.Get(index);
}
inline const ::drive::Property& ResourceEntry::new_properties(int index) const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.new_properties)
    return _internal_new_properties(index);
}
inline ::drive::Property* ResourceEntry::_internal_add_new_properties()
{
    return _impl_.new_properties_.Add();
}
inline ::drive::Property* ResourceEntry::add_new_properties()
{
    ::drive::Property* _add = _internal_add_new_properties();
    // @@protoc_insertion_point(field_add:drive.ResourceEntry.new_properties)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::drive::Property>& ResourceEntry::new_properties() const
{
    // @@protoc_insertion_point(field_list:drive.ResourceEntry.new_properties)
    return _impl_.new_properties_;
}

// optional int64 last_modified_by_me = 21;
inline bool ResourceEntry::_internal_has_last_modified_by_me() const
{
    bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
    return value;
}
inline bool ResourceEntry::has_last_modified_by_me() const
{
    return _internal_has_last_modified_by_me();
}
inline void ResourceEntry::clear_last_modified_by_me()
{
    _impl_.last_modified_by_me_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00020000u;
}
inline int64_t ResourceEntry::_internal_last_modified_by_me() const
{
    return _impl_.last_modified_by_me_;
}
inline int64_t ResourceEntry::last_modified_by_me() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.last_modified_by_me)
    return _internal_last_modified_by_me();
}
inline void ResourceEntry::_internal_set_last_modified_by_me(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00020000u;
    _impl_.last_modified_by_me_ = value;
}
inline void ResourceEntry::set_last_modified_by_me(int64_t value)
{
    _internal_set_last_modified_by_me(value);
    // @@protoc_insertion_point(field_set:drive.ResourceEntry.last_modified_by_me)
}

// optional string alternate_url = 22;
inline bool ResourceEntry::_internal_has_alternate_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool ResourceEntry::has_alternate_url() const
{
    return _internal_has_alternate_url();
}
inline void ResourceEntry::clear_alternate_url()
{
    _impl_.alternate_url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ResourceEntry::alternate_url() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceEntry.alternate_url)
    return _internal_alternate_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ResourceEntry::set_alternate_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.alternate_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.ResourceEntry.alternate_url)
}
inline std::string* ResourceEntry::mutable_alternate_url()
{
    std::string* _s = _internal_mutable_alternate_url();
    // @@protoc_insertion_point(field_mutable:drive.ResourceEntry.alternate_url)
    return _s;
}
inline const std::string& ResourceEntry::_internal_alternate_url() const
{
    return _impl_.alternate_url_.Get();
}
inline void ResourceEntry::_internal_set_alternate_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.alternate_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceEntry::_internal_mutable_alternate_url()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    return _impl_.alternate_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceEntry::release_alternate_url()
{
    // @@protoc_insertion_point(field_release:drive.ResourceEntry.alternate_url)
    if (!_internal_has_alternate_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000020u;
    auto* p = _impl_.alternate_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.alternate_url_.IsDefault()) {
        _impl_.alternate_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ResourceEntry::set_allocated_alternate_url(std::string* alternate_url)
{
    if (alternate_url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.alternate_url_.SetAllocated(alternate_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.alternate_url_.IsDefault()) {
        _impl_.alternate_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.ResourceEntry.alternate_url)
}

// -------------------------------------------------------------------

// ResourceMetadataHeader

// optional int32 version = 1;
inline bool ResourceMetadataHeader::_internal_has_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ResourceMetadataHeader::has_version() const
{
    return _internal_has_version();
}
inline void ResourceMetadataHeader::clear_version()
{
    _impl_.version_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t ResourceMetadataHeader::_internal_version() const
{
    return _impl_.version_;
}
inline int32_t ResourceMetadataHeader::version() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceMetadataHeader.version)
    return _internal_version();
}
inline void ResourceMetadataHeader::_internal_set_version(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.version_ = value;
}
inline void ResourceMetadataHeader::set_version(int32_t value)
{
    _internal_set_version(value);
    // @@protoc_insertion_point(field_set:drive.ResourceMetadataHeader.version)
}

// optional int64 largest_changestamp = 2 [deprecated = true];
inline bool ResourceMetadataHeader::_internal_has_largest_changestamp() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ResourceMetadataHeader::has_largest_changestamp() const
{
    return _internal_has_largest_changestamp();
}
inline void ResourceMetadataHeader::clear_largest_changestamp()
{
    _impl_.largest_changestamp_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t ResourceMetadataHeader::_internal_largest_changestamp() const
{
    return _impl_.largest_changestamp_;
}
inline int64_t ResourceMetadataHeader::largest_changestamp() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceMetadataHeader.largest_changestamp)
    return _internal_largest_changestamp();
}
inline void ResourceMetadataHeader::_internal_set_largest_changestamp(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.largest_changestamp_ = value;
}
inline void ResourceMetadataHeader::set_largest_changestamp(int64_t value)
{
    _internal_set_largest_changestamp(value);
    // @@protoc_insertion_point(field_set:drive.ResourceMetadataHeader.largest_changestamp)
}

// optional string start_page_token = 4;
inline bool ResourceMetadataHeader::_internal_has_start_page_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ResourceMetadataHeader::has_start_page_token() const
{
    return _internal_has_start_page_token();
}
inline void ResourceMetadataHeader::clear_start_page_token()
{
    _impl_.start_page_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResourceMetadataHeader::start_page_token() const
{
    // @@protoc_insertion_point(field_get:drive.ResourceMetadataHeader.start_page_token)
    return _internal_start_page_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ResourceMetadataHeader::set_start_page_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.start_page_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.ResourceMetadataHeader.start_page_token)
}
inline std::string* ResourceMetadataHeader::mutable_start_page_token()
{
    std::string* _s = _internal_mutable_start_page_token();
    // @@protoc_insertion_point(field_mutable:drive.ResourceMetadataHeader.start_page_token)
    return _s;
}
inline const std::string& ResourceMetadataHeader::_internal_start_page_token() const
{
    return _impl_.start_page_token_.Get();
}
inline void ResourceMetadataHeader::_internal_set_start_page_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.start_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceMetadataHeader::_internal_mutable_start_page_token()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.start_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceMetadataHeader::release_start_page_token()
{
    // @@protoc_insertion_point(field_release:drive.ResourceMetadataHeader.start_page_token)
    if (!_internal_has_start_page_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.start_page_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.start_page_token_.IsDefault()) {
        _impl_.start_page_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ResourceMetadataHeader::set_allocated_start_page_token(std::string* start_page_token)
{
    if (start_page_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.start_page_token_.SetAllocated(start_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.start_page_token_.IsDefault()) {
        _impl_.start_page_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.ResourceMetadataHeader.start_page_token)
}

// -------------------------------------------------------------------

// FileCacheEntry

// optional string md5 = 1;
inline bool FileCacheEntry::_internal_has_md5() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool FileCacheEntry::has_md5() const
{
    return _internal_has_md5();
}
inline void FileCacheEntry::clear_md5()
{
    _impl_.md5_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FileCacheEntry::md5() const
{
    // @@protoc_insertion_point(field_get:drive.FileCacheEntry.md5)
    return _internal_md5();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FileCacheEntry::set_md5(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.md5_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:drive.FileCacheEntry.md5)
}
inline std::string* FileCacheEntry::mutable_md5()
{
    std::string* _s = _internal_mutable_md5();
    // @@protoc_insertion_point(field_mutable:drive.FileCacheEntry.md5)
    return _s;
}
inline const std::string& FileCacheEntry::_internal_md5() const
{
    return _impl_.md5_.Get();
}
inline void FileCacheEntry::_internal_set_md5(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.md5_.Set(value, GetArenaForAllocation());
}
inline std::string* FileCacheEntry::_internal_mutable_md5()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.md5_.Mutable(GetArenaForAllocation());
}
inline std::string* FileCacheEntry::release_md5()
{
    // @@protoc_insertion_point(field_release:drive.FileCacheEntry.md5)
    if (!_internal_has_md5()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.md5_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.md5_.IsDefault()) {
        _impl_.md5_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void FileCacheEntry::set_allocated_md5(std::string* md5)
{
    if (md5 != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.md5_.SetAllocated(md5, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.md5_.IsDefault()) {
        _impl_.md5_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:drive.FileCacheEntry.md5)
}

// optional bool is_present = 2;
inline bool FileCacheEntry::_internal_has_is_present() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool FileCacheEntry::has_is_present() const
{
    return _internal_has_is_present();
}
inline void FileCacheEntry::clear_is_present()
{
    _impl_.is_present_ = false;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool FileCacheEntry::_internal_is_present() const
{
    return _impl_.is_present_;
}
inline bool FileCacheEntry::is_present() const
{
    // @@protoc_insertion_point(field_get:drive.FileCacheEntry.is_present)
    return _internal_is_present();
}
inline void FileCacheEntry::_internal_set_is_present(bool value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.is_present_ = value;
}
inline void FileCacheEntry::set_is_present(bool value)
{
    _internal_set_is_present(value);
    // @@protoc_insertion_point(field_set:drive.FileCacheEntry.is_present)
}

// optional bool is_pinned = 3;
inline bool FileCacheEntry::_internal_has_is_pinned() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool FileCacheEntry::has_is_pinned() const
{
    return _internal_has_is_pinned();
}
inline void FileCacheEntry::clear_is_pinned()
{
    _impl_.is_pinned_ = false;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool FileCacheEntry::_internal_is_pinned() const
{
    return _impl_.is_pinned_;
}
inline bool FileCacheEntry::is_pinned() const
{
    // @@protoc_insertion_point(field_get:drive.FileCacheEntry.is_pinned)
    return _internal_is_pinned();
}
inline void FileCacheEntry::_internal_set_is_pinned(bool value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.is_pinned_ = value;
}
inline void FileCacheEntry::set_is_pinned(bool value)
{
    _internal_set_is_pinned(value);
    // @@protoc_insertion_point(field_set:drive.FileCacheEntry.is_pinned)
}

// optional bool is_dirty = 4;
inline bool FileCacheEntry::_internal_has_is_dirty() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool FileCacheEntry::has_is_dirty() const
{
    return _internal_has_is_dirty();
}
inline void FileCacheEntry::clear_is_dirty()
{
    _impl_.is_dirty_ = false;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool FileCacheEntry::_internal_is_dirty() const
{
    return _impl_.is_dirty_;
}
inline bool FileCacheEntry::is_dirty() const
{
    // @@protoc_insertion_point(field_get:drive.FileCacheEntry.is_dirty)
    return _internal_is_dirty();
}
inline void FileCacheEntry::_internal_set_is_dirty(bool value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.is_dirty_ = value;
}
inline void FileCacheEntry::set_is_dirty(bool value)
{
    _internal_set_is_dirty(value);
    // @@protoc_insertion_point(field_set:drive.FileCacheEntry.is_dirty)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace drive

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::drive::Property_Visibility> : ::std::true_type { };
template <> struct is_proto_enum<::drive::ResourceEntry_EditState> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_drive_2eproto
