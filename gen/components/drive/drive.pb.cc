// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: drive.proto

#include "drive.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace drive {
PROTOBUF_CONSTEXPR PlatformFileInfoProto::PlatformFileInfoProto(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.size_)*/ int64_t { 0 },
        /*decltype(_impl_.last_modified_)*/ int64_t { 0 }, /*decltype(_impl_.last_accessed_)*/ int64_t { 0 }, /*decltype(_impl_.creation_time_)*/ int64_t { 0 },
        /*decltype(_impl_.is_directory_)*/ false, /*decltype(_impl_.is_symbolic_link_)*/ false, /*decltype(_impl_.is_team_drive_root_)*/ false }
{
}
struct PlatformFileInfoProtoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PlatformFileInfoProtoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PlatformFileInfoProtoDefaultTypeInternal()
    {
    }
    union {
        PlatformFileInfoProto _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlatformFileInfoProtoDefaultTypeInternal
    _PlatformFileInfoProto_default_instance_;
PROTOBUF_CONSTEXPR Property::Property(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.visibility_)*/ 0 }
{
}
struct PropertyDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PropertyDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PropertyDefaultTypeInternal()
    {
    }
    union {
        Property _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PropertyDefaultTypeInternal _Property_default_instance_;
PROTOBUF_CONSTEXPR CapabilitiesInfo::CapabilitiesInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.can_copy_)*/ false,
        /*decltype(_impl_.can_delete_)*/ false, /*decltype(_impl_.can_rename_)*/ false, /*decltype(_impl_.can_add_children_)*/ false,
        /*decltype(_impl_.can_share_)*/ false }
{
}
struct CapabilitiesInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CapabilitiesInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CapabilitiesInfoDefaultTypeInternal()
    {
    }
    union {
        CapabilitiesInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CapabilitiesInfoDefaultTypeInternal _CapabilitiesInfo_default_instance_;
PROTOBUF_CONSTEXPR FileSpecificInfo::FileSpecificInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.content_mime_type_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.md5_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.document_extension_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.cache_state_)*/ nullptr, /*decltype(_impl_.image_width_)*/ int64_t { 0 }, /*decltype(_impl_.image_height_)*/ int64_t { 0 },
        /*decltype(_impl_.image_rotation_)*/ int64_t { 0 }, /*decltype(_impl_.is_hosted_document_)*/ false }
{
}
struct FileSpecificInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FileSpecificInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FileSpecificInfoDefaultTypeInternal()
    {
    }
    union {
        FileSpecificInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileSpecificInfoDefaultTypeInternal _FileSpecificInfo_default_instance_;
PROTOBUF_CONSTEXPR TeamDriveRootSpecificInfo::TeamDriveRootSpecificInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.start_page_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct TeamDriveRootSpecificInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TeamDriveRootSpecificInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TeamDriveRootSpecificInfoDefaultTypeInternal()
    {
    }
    union {
        TeamDriveRootSpecificInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TeamDriveRootSpecificInfoDefaultTypeInternal
    _TeamDriveRootSpecificInfo_default_instance_;
PROTOBUF_CONSTEXPR DirectorySpecificInfo::DirectorySpecificInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.start_page_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.changestamp_)*/ int64_t { 0 }, /*decltype(_impl_.last_read_time_ms_)*/ int64_t { 0 } }
{
}
struct DirectorySpecificInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DirectorySpecificInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DirectorySpecificInfoDefaultTypeInternal()
    {
    }
    union {
        DirectorySpecificInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DirectorySpecificInfoDefaultTypeInternal
    _DirectorySpecificInfo_default_instance_;
PROTOBUF_CONSTEXPR ResourceEntry::ResourceEntry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.new_properties_)*/ {},
        /*decltype(_impl_.base_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.title_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.resource_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.parent_local_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.local_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.alternate_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.file_info_)*/ nullptr,
        /*decltype(_impl_.file_specific_info_)*/ nullptr, /*decltype(_impl_.directory_specific_info_)*/ nullptr,
        /*decltype(_impl_.team_drive_root_specific_info_)*/ nullptr, /*decltype(_impl_.capabilities_info_)*/ nullptr, /*decltype(_impl_.deleted_)*/ false,
        /*decltype(_impl_.starred_)*/ false, /*decltype(_impl_.shared_with_me_)*/ false, /*decltype(_impl_.shared_)*/ false,
        /*decltype(_impl_.metadata_edit_state_)*/ 0, /*decltype(_impl_.modification_date_)*/ int64_t { 0 },
        /*decltype(_impl_.last_modified_by_me_)*/ int64_t { 0 } }
{
}
struct ResourceEntryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ResourceEntryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ResourceEntryDefaultTypeInternal()
    {
    }
    union {
        ResourceEntry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceEntryDefaultTypeInternal _ResourceEntry_default_instance_;
PROTOBUF_CONSTEXPR ResourceMetadataHeader::ResourceMetadataHeader(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.start_page_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.largest_changestamp_)*/ int64_t { 0 }, /*decltype(_impl_.version_)*/ 0 }
{
}
struct ResourceMetadataHeaderDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ResourceMetadataHeaderDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ResourceMetadataHeaderDefaultTypeInternal()
    {
    }
    union {
        ResourceMetadataHeader _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ResourceMetadataHeaderDefaultTypeInternal
    _ResourceMetadataHeader_default_instance_;
PROTOBUF_CONSTEXPR FileCacheEntry::FileCacheEntry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.md5_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.is_present_)*/ false,
        /*decltype(_impl_.is_pinned_)*/ false, /*decltype(_impl_.is_dirty_)*/ false }
{
}
struct FileCacheEntryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FileCacheEntryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FileCacheEntryDefaultTypeInternal()
    {
    }
    union {
        FileCacheEntry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileCacheEntryDefaultTypeInternal _FileCacheEntry_default_instance_;
} // namespace drive
namespace drive {
bool Property_Visibility_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Property_Visibility_strings[2] = {};

static const char Property_Visibility_names[] = "PRIVATE"
                                                "PUBLIC";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Property_Visibility_entries[] = {
    { { Property_Visibility_names + 0, 7 }, 0 },
    { { Property_Visibility_names + 7, 6 }, 1 },
};

static const int Property_Visibility_entries_by_number[] = {
    0, // 0 -> PRIVATE
    1, // 1 -> PUBLIC
};

const std::string& Property_Visibility_Name(Property_Visibility value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        Property_Visibility_entries, Property_Visibility_entries_by_number, 2, Property_Visibility_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Property_Visibility_entries, Property_Visibility_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Property_Visibility_strings[idx].get();
}
bool Property_Visibility_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Property_Visibility* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Property_Visibility_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<Property_Visibility>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Property_Visibility Property::PRIVATE;
constexpr Property_Visibility Property::PUBLIC;
constexpr Property_Visibility Property::Visibility_MIN;
constexpr Property_Visibility Property::Visibility_MAX;
constexpr int Property::Visibility_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ResourceEntry_EditState_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ResourceEntry_EditState_strings[3] = {};

static const char ResourceEntry_EditState_names[] = "CLEAN"
                                                    "DIRTY"
                                                    "SYNCING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ResourceEntry_EditState_entries[] = {
    { { ResourceEntry_EditState_names + 0, 5 }, 0 },
    { { ResourceEntry_EditState_names + 5, 5 }, 1 },
    { { ResourceEntry_EditState_names + 10, 7 }, 2 },
};

static const int ResourceEntry_EditState_entries_by_number[] = {
    0, // 0 -> CLEAN
    1, // 1 -> DIRTY
    2, // 2 -> SYNCING
};

const std::string& ResourceEntry_EditState_Name(ResourceEntry_EditState value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ResourceEntry_EditState_entries, ResourceEntry_EditState_entries_by_number, 3, ResourceEntry_EditState_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ResourceEntry_EditState_entries, ResourceEntry_EditState_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ResourceEntry_EditState_strings[idx].get();
}
bool ResourceEntry_EditState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResourceEntry_EditState* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ResourceEntry_EditState_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ResourceEntry_EditState>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ResourceEntry_EditState ResourceEntry::CLEAN;
constexpr ResourceEntry_EditState ResourceEntry::DIRTY;
constexpr ResourceEntry_EditState ResourceEntry::SYNCING;
constexpr ResourceEntry_EditState ResourceEntry::EditState_MIN;
constexpr ResourceEntry_EditState ResourceEntry::EditState_MAX;
constexpr int ResourceEntry::EditState_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class PlatformFileInfoProto::_Internal {
public:
    using HasBits = decltype(std::declval<PlatformFileInfoProto>()._impl_._has_bits_);
    static void set_has_size(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_is_directory(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_is_symbolic_link(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_last_modified(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_last_accessed(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_creation_time(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_is_team_drive_root(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
};

PlatformFileInfoProto::PlatformFileInfoProto(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:drive.PlatformFileInfoProto)
}
PlatformFileInfoProto::PlatformFileInfoProto(const PlatformFileInfoProto& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PlatformFileInfoProto* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.size_) {},
        decltype(_impl_.last_modified_) {}, decltype(_impl_.last_accessed_) {}, decltype(_impl_.creation_time_) {}, decltype(_impl_.is_directory_) {},
        decltype(_impl_.is_symbolic_link_) {}, decltype(_impl_.is_team_drive_root_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.size_, &from._impl_.size_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_team_drive_root_) - reinterpret_cast<char*>(&_impl_.size_))
            + sizeof(_impl_.is_team_drive_root_));
    // @@protoc_insertion_point(copy_constructor:drive.PlatformFileInfoProto)
}

inline void PlatformFileInfoProto::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.size_) { int64_t { 0 } },
        decltype(_impl_.last_modified_) { int64_t { 0 } }, decltype(_impl_.last_accessed_) { int64_t { 0 } }, decltype(_impl_.creation_time_) { int64_t { 0 } },
        decltype(_impl_.is_directory_) { false }, decltype(_impl_.is_symbolic_link_) { false }, decltype(_impl_.is_team_drive_root_) { false } };
}

PlatformFileInfoProto::~PlatformFileInfoProto()
{
    // @@protoc_insertion_point(destructor:drive.PlatformFileInfoProto)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PlatformFileInfoProto::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlatformFileInfoProto::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PlatformFileInfoProto::Clear()
{
    // @@protoc_insertion_point(message_clear_start:drive.PlatformFileInfoProto)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        ::memset(&_impl_.size_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_team_drive_root_) - reinterpret_cast<char*>(&_impl_.size_))
                + sizeof(_impl_.is_team_drive_root_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PlatformFileInfoProto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 size = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_size(&has_bits);
                _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_directory = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_is_directory(&has_bits);
                _impl_.is_directory_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_symbolic_link = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_is_symbolic_link(&has_bits);
                _impl_.is_symbolic_link_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 last_modified = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_last_modified(&has_bits);
                _impl_.last_modified_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 last_accessed = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_last_accessed(&has_bits);
                _impl_.last_accessed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 creation_time = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_creation_time(&has_bits);
                _impl_.creation_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_team_drive_root = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_is_team_drive_root(&has_bits);
                _impl_.is_team_drive_root_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PlatformFileInfoProto::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:drive.PlatformFileInfoProto)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 size = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_size(), target);
    }

    // optional bool is_directory = 2;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_directory(), target);
    }

    // optional bool is_symbolic_link = 3;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_symbolic_link(), target);
    }

    // optional int64 last_modified = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_last_modified(), target);
    }

    // optional int64 last_accessed = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_last_accessed(), target);
    }

    // optional int64 creation_time = 6;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_creation_time(), target);
    }

    // optional bool is_team_drive_root = 7;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_is_team_drive_root(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:drive.PlatformFileInfoProto)
    return target;
}

size_t PlatformFileInfoProto::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:drive.PlatformFileInfoProto)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        // optional int64 size = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size());
        }

        // optional int64 last_modified = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_modified());
        }

        // optional int64 last_accessed = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_accessed());
        }

        // optional int64 creation_time = 6;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_creation_time());
        }

        // optional bool is_directory = 2;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }

        // optional bool is_symbolic_link = 3;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 1;
        }

        // optional bool is_team_drive_root = 7;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PlatformFileInfoProto::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PlatformFileInfoProto*>(&from));
}

void PlatformFileInfoProto::MergeFrom(const PlatformFileInfoProto& from)
{
    PlatformFileInfoProto* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:drive.PlatformFileInfoProto)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.size_ = from._impl_.size_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.last_modified_ = from._impl_.last_modified_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.last_accessed_ = from._impl_.last_accessed_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.creation_time_ = from._impl_.creation_time_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.is_directory_ = from._impl_.is_directory_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.is_symbolic_link_ = from._impl_.is_symbolic_link_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.is_team_drive_root_ = from._impl_.is_team_drive_root_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PlatformFileInfoProto::CopyFrom(const PlatformFileInfoProto& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:drive.PlatformFileInfoProto)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PlatformFileInfoProto::IsInitialized() const
{
    return true;
}

void PlatformFileInfoProto::InternalSwap(PlatformFileInfoProto* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PlatformFileInfoProto, _impl_.is_team_drive_root_)
        + sizeof(PlatformFileInfoProto::_impl_.is_team_drive_root_) - PROTOBUF_FIELD_OFFSET(PlatformFileInfoProto, _impl_.size_)>(
        reinterpret_cast<char*>(&_impl_.size_), reinterpret_cast<char*>(&other->_impl_.size_));
}

std::string PlatformFileInfoProto::GetTypeName() const
{
    return "drive.PlatformFileInfoProto";
}

// ===================================================================

class Property::_Internal {
public:
    using HasBits = decltype(std::declval<Property>()._impl_._has_bits_);
    static void set_has_key(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_visibility(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

Property::Property(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:drive.Property)
}
Property::Property(const Property& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Property* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.key_) {},
        decltype(_impl_.value_) {}, decltype(_impl_.visibility_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_key()) {
        _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
    }
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_value()) {
        _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
    }
    _this->_impl_.visibility_ = from._impl_.visibility_;
    // @@protoc_insertion_point(copy_constructor:drive.Property)
}

inline void Property::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.key_) {}, decltype(_impl_.value_) {},
        decltype(_impl_.visibility_) { 0 } };
    _impl_.key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Property::~Property()
{
    // @@protoc_insertion_point(destructor:drive.Property)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Property::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.key_.Destroy();
    _impl_.value_.Destroy();
}

void Property::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Property::Clear()
{
    // @@protoc_insertion_point(message_clear_start:drive.Property)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.key_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.value_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.visibility_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Property::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string key = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .drive.Property.Visibility visibility = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::drive::Property_Visibility_IsValid(val))) {
                    _internal_set_visibility(static_cast<::drive::Property_Visibility>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Property::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:drive.Property)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string key = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_key(), target);
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_value(), target);
    }

    // optional .drive.Property.Visibility visibility = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_visibility(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:drive.Property)
    return target;
}

size_t Property::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:drive.Property)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string key = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_key());
        }

        // optional string value = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_value());
        }

        // optional .drive.Property.Visibility visibility = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_visibility());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Property::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Property*>(&from));
}

void Property::MergeFrom(const Property& from)
{
    Property* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:drive.Property)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_key(from._internal_key());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_value(from._internal_value());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.visibility_ = from._impl_.visibility_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Property::CopyFrom(const Property& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:drive.Property)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Property::IsInitialized() const
{
    return true;
}

void Property::InternalSwap(Property* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena, &other->_impl_.key_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena, &other->_impl_.value_, rhs_arena);
    swap(_impl_.visibility_, other->_impl_.visibility_);
}

std::string Property::GetTypeName() const
{
    return "drive.Property";
}

// ===================================================================

class CapabilitiesInfo::_Internal {
public:
    using HasBits = decltype(std::declval<CapabilitiesInfo>()._impl_._has_bits_);
    static void set_has_can_copy(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_can_delete(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_can_rename(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_can_add_children(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_can_share(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

CapabilitiesInfo::CapabilitiesInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:drive.CapabilitiesInfo)
}
CapabilitiesInfo::CapabilitiesInfo(const CapabilitiesInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CapabilitiesInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.can_copy_) {},
        decltype(_impl_.can_delete_) {}, decltype(_impl_.can_rename_) {}, decltype(_impl_.can_add_children_) {}, decltype(_impl_.can_share_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.can_copy_, &from._impl_.can_copy_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.can_share_) - reinterpret_cast<char*>(&_impl_.can_copy_)) + sizeof(_impl_.can_share_));
    // @@protoc_insertion_point(copy_constructor:drive.CapabilitiesInfo)
}

inline void CapabilitiesInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.can_copy_) { false },
        decltype(_impl_.can_delete_) { false }, decltype(_impl_.can_rename_) { false }, decltype(_impl_.can_add_children_) { false },
        decltype(_impl_.can_share_) { false } };
}

CapabilitiesInfo::~CapabilitiesInfo()
{
    // @@protoc_insertion_point(destructor:drive.CapabilitiesInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CapabilitiesInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CapabilitiesInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CapabilitiesInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:drive.CapabilitiesInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        ::memset(&_impl_.can_copy_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.can_share_) - reinterpret_cast<char*>(&_impl_.can_copy_)) + sizeof(_impl_.can_share_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CapabilitiesInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bool can_copy = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_can_copy(&has_bits);
                _impl_.can_copy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool can_delete = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_can_delete(&has_bits);
                _impl_.can_delete_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool can_rename = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_can_rename(&has_bits);
                _impl_.can_rename_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool can_add_children = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_can_add_children(&has_bits);
                _impl_.can_add_children_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool can_share = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_can_share(&has_bits);
                _impl_.can_share_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CapabilitiesInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:drive.CapabilitiesInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool can_copy = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_can_copy(), target);
    }

    // optional bool can_delete = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_can_delete(), target);
    }

    // optional bool can_rename = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_can_rename(), target);
    }

    // optional bool can_add_children = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_can_add_children(), target);
    }

    // optional bool can_share = 5;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_can_share(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:drive.CapabilitiesInfo)
    return target;
}

size_t CapabilitiesInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:drive.CapabilitiesInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional bool can_copy = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 1;
        }

        // optional bool can_delete = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }

        // optional bool can_rename = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }

        // optional bool can_add_children = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }

        // optional bool can_share = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CapabilitiesInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CapabilitiesInfo*>(&from));
}

void CapabilitiesInfo::MergeFrom(const CapabilitiesInfo& from)
{
    CapabilitiesInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:drive.CapabilitiesInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.can_copy_ = from._impl_.can_copy_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.can_delete_ = from._impl_.can_delete_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.can_rename_ = from._impl_.can_rename_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.can_add_children_ = from._impl_.can_add_children_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.can_share_ = from._impl_.can_share_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CapabilitiesInfo::CopyFrom(const CapabilitiesInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:drive.CapabilitiesInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CapabilitiesInfo::IsInitialized() const
{
    return true;
}

void CapabilitiesInfo::InternalSwap(CapabilitiesInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(CapabilitiesInfo, _impl_.can_share_) + sizeof(CapabilitiesInfo::_impl_.can_share_)
        - PROTOBUF_FIELD_OFFSET(CapabilitiesInfo, _impl_.can_copy_)>(
        reinterpret_cast<char*>(&_impl_.can_copy_), reinterpret_cast<char*>(&other->_impl_.can_copy_));
}

std::string CapabilitiesInfo::GetTypeName() const
{
    return "drive.CapabilitiesInfo";
}

// ===================================================================

class FileSpecificInfo::_Internal {
public:
    using HasBits = decltype(std::declval<FileSpecificInfo>()._impl_._has_bits_);
    static void set_has_content_mime_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_md5(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_document_extension(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_is_hosted_document(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_image_width(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_image_height(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_image_rotation(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static const ::drive::FileCacheEntry& cache_state(const FileSpecificInfo* msg);
    static void set_has_cache_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::drive::FileCacheEntry& FileSpecificInfo::_Internal::cache_state(const FileSpecificInfo* msg)
{
    return *msg->_impl_.cache_state_;
}
FileSpecificInfo::FileSpecificInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:drive.FileSpecificInfo)
}
FileSpecificInfo::FileSpecificInfo(const FileSpecificInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    FileSpecificInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.content_mime_type_) {},
        decltype(_impl_.md5_) {}, decltype(_impl_.document_extension_) {}, decltype(_impl_.cache_state_) { nullptr }, decltype(_impl_.image_width_) {},
        decltype(_impl_.image_height_) {}, decltype(_impl_.image_rotation_) {}, decltype(_impl_.is_hosted_document_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.content_mime_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_mime_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_content_mime_type()) {
        _this->_impl_.content_mime_type_.Set(from._internal_content_mime_type(), _this->GetArenaForAllocation());
    }
    _impl_.md5_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.md5_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_md5()) {
        _this->_impl_.md5_.Set(from._internal_md5(), _this->GetArenaForAllocation());
    }
    _impl_.document_extension_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.document_extension_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_document_extension()) {
        _this->_impl_.document_extension_.Set(from._internal_document_extension(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_cache_state()) {
        _this->_impl_.cache_state_ = new ::drive::FileCacheEntry(*from._impl_.cache_state_);
    }
    ::memcpy(&_impl_.image_width_, &from._impl_.image_width_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_hosted_document_) - reinterpret_cast<char*>(&_impl_.image_width_))
            + sizeof(_impl_.is_hosted_document_));
    // @@protoc_insertion_point(copy_constructor:drive.FileSpecificInfo)
}

inline void FileSpecificInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.content_mime_type_) {},
        decltype(_impl_.md5_) {}, decltype(_impl_.document_extension_) {}, decltype(_impl_.cache_state_) { nullptr },
        decltype(_impl_.image_width_) { int64_t { 0 } }, decltype(_impl_.image_height_) { int64_t { 0 } }, decltype(_impl_.image_rotation_) { int64_t { 0 } },
        decltype(_impl_.is_hosted_document_) { false } };
    _impl_.content_mime_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_mime_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.md5_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.md5_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.document_extension_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.document_extension_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FileSpecificInfo::~FileSpecificInfo()
{
    // @@protoc_insertion_point(destructor:drive.FileSpecificInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void FileSpecificInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.content_mime_type_.Destroy();
    _impl_.md5_.Destroy();
    _impl_.document_extension_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.cache_state_;
}

void FileSpecificInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void FileSpecificInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:drive.FileSpecificInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.content_mime_type_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.md5_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.document_extension_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.cache_state_ != nullptr);
            _impl_.cache_state_->Clear();
        }
    }
    if (cached_has_bits & 0x000000f0u) {
        ::memset(&_impl_.image_width_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_hosted_document_) - reinterpret_cast<char*>(&_impl_.image_width_))
                + sizeof(_impl_.is_hosted_document_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* FileSpecificInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string content_mime_type = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_content_mime_type();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string md5 = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_md5();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string document_extension = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_document_extension();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_hosted_document = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_is_hosted_document(&has_bits);
                _impl_.is_hosted_document_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 image_width = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_image_width(&has_bits);
                _impl_.image_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 image_height = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _Internal::set_has_image_height(&has_bits);
                _impl_.image_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 image_rotation = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                _Internal::set_has_image_rotation(&has_bits);
                _impl_.image_rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .drive.FileCacheEntry cache_state = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_cache_state(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* FileSpecificInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:drive.FileSpecificInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string content_mime_type = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_content_mime_type(), target);
    }

    // optional string md5 = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_md5(), target);
    }

    // optional string document_extension = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_document_extension(), target);
    }

    // optional bool is_hosted_document = 6;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_hosted_document(), target);
    }

    // optional int64 image_width = 8;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_image_width(), target);
    }

    // optional int64 image_height = 9;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_image_height(), target);
    }

    // optional int64 image_rotation = 10;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_image_rotation(), target);
    }

    // optional .drive.FileCacheEntry cache_state = 11;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::cache_state(this), _Internal::cache_state(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:drive.FileSpecificInfo)
    return target;
}

size_t FileSpecificInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:drive.FileSpecificInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string content_mime_type = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_content_mime_type());
        }

        // optional string md5 = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_md5());
        }

        // optional string document_extension = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_document_extension());
        }

        // optional .drive.FileCacheEntry cache_state = 11;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.cache_state_);
        }

        // optional int64 image_width = 8;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_image_width());
        }

        // optional int64 image_height = 9;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_image_height());
        }

        // optional int64 image_rotation = 10;
        if (cached_has_bits & 0x00000040u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_image_rotation());
        }

        // optional bool is_hosted_document = 6;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void FileSpecificInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const FileSpecificInfo*>(&from));
}

void FileSpecificInfo::MergeFrom(const FileSpecificInfo& from)
{
    FileSpecificInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:drive.FileSpecificInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_content_mime_type(from._internal_content_mime_type());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_md5(from._internal_md5());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_document_extension(from._internal_document_extension());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_cache_state()->::drive::FileCacheEntry::MergeFrom(from._internal_cache_state());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.image_width_ = from._impl_.image_width_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.image_height_ = from._impl_.image_height_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.image_rotation_ = from._impl_.image_rotation_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.is_hosted_document_ = from._impl_.is_hosted_document_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FileSpecificInfo::CopyFrom(const FileSpecificInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:drive.FileSpecificInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FileSpecificInfo::IsInitialized() const
{
    return true;
}

void FileSpecificInfo::InternalSwap(FileSpecificInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.content_mime_type_, lhs_arena, &other->_impl_.content_mime_type_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.md5_, lhs_arena, &other->_impl_.md5_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.document_extension_, lhs_arena, &other->_impl_.document_extension_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(FileSpecificInfo, _impl_.is_hosted_document_)
        + sizeof(FileSpecificInfo::_impl_.is_hosted_document_) - PROTOBUF_FIELD_OFFSET(FileSpecificInfo, _impl_.cache_state_)>(
        reinterpret_cast<char*>(&_impl_.cache_state_), reinterpret_cast<char*>(&other->_impl_.cache_state_));
}

std::string FileSpecificInfo::GetTypeName() const
{
    return "drive.FileSpecificInfo";
}

// ===================================================================

class TeamDriveRootSpecificInfo::_Internal {
public:
    using HasBits = decltype(std::declval<TeamDriveRootSpecificInfo>()._impl_._has_bits_);
    static void set_has_start_page_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

TeamDriveRootSpecificInfo::TeamDriveRootSpecificInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:drive.TeamDriveRootSpecificInfo)
}
TeamDriveRootSpecificInfo::TeamDriveRootSpecificInfo(const TeamDriveRootSpecificInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TeamDriveRootSpecificInfo* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.start_page_token_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.start_page_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.start_page_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_start_page_token()) {
        _this->_impl_.start_page_token_.Set(from._internal_start_page_token(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:drive.TeamDriveRootSpecificInfo)
}

inline void TeamDriveRootSpecificInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.start_page_token_) {} };
    _impl_.start_page_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.start_page_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TeamDriveRootSpecificInfo::~TeamDriveRootSpecificInfo()
{
    // @@protoc_insertion_point(destructor:drive.TeamDriveRootSpecificInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TeamDriveRootSpecificInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.start_page_token_.Destroy();
}

void TeamDriveRootSpecificInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TeamDriveRootSpecificInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:drive.TeamDriveRootSpecificInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.start_page_token_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* TeamDriveRootSpecificInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string start_page_token = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_start_page_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TeamDriveRootSpecificInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:drive.TeamDriveRootSpecificInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string start_page_token = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_start_page_token(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:drive.TeamDriveRootSpecificInfo)
    return target;
}

size_t TeamDriveRootSpecificInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:drive.TeamDriveRootSpecificInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string start_page_token = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_start_page_token());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TeamDriveRootSpecificInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TeamDriveRootSpecificInfo*>(&from));
}

void TeamDriveRootSpecificInfo::MergeFrom(const TeamDriveRootSpecificInfo& from)
{
    TeamDriveRootSpecificInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:drive.TeamDriveRootSpecificInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_start_page_token()) {
        _this->_internal_set_start_page_token(from._internal_start_page_token());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TeamDriveRootSpecificInfo::CopyFrom(const TeamDriveRootSpecificInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:drive.TeamDriveRootSpecificInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TeamDriveRootSpecificInfo::IsInitialized() const
{
    return true;
}

void TeamDriveRootSpecificInfo::InternalSwap(TeamDriveRootSpecificInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.start_page_token_, lhs_arena, &other->_impl_.start_page_token_, rhs_arena);
}

std::string TeamDriveRootSpecificInfo::GetTypeName() const
{
    return "drive.TeamDriveRootSpecificInfo";
}

// ===================================================================

class DirectorySpecificInfo::_Internal {
public:
    using HasBits = decltype(std::declval<DirectorySpecificInfo>()._impl_._has_bits_);
    static void set_has_changestamp(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_start_page_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_last_read_time_ms(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

DirectorySpecificInfo::DirectorySpecificInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:drive.DirectorySpecificInfo)
}
DirectorySpecificInfo::DirectorySpecificInfo(const DirectorySpecificInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DirectorySpecificInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.start_page_token_) {},
        decltype(_impl_.changestamp_) {}, decltype(_impl_.last_read_time_ms_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.start_page_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.start_page_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_start_page_token()) {
        _this->_impl_.start_page_token_.Set(from._internal_start_page_token(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.changestamp_, &from._impl_.changestamp_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_read_time_ms_) - reinterpret_cast<char*>(&_impl_.changestamp_))
            + sizeof(_impl_.last_read_time_ms_));
    // @@protoc_insertion_point(copy_constructor:drive.DirectorySpecificInfo)
}

inline void DirectorySpecificInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.start_page_token_) {},
        decltype(_impl_.changestamp_) { int64_t { 0 } }, decltype(_impl_.last_read_time_ms_) { int64_t { 0 } } };
    _impl_.start_page_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.start_page_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DirectorySpecificInfo::~DirectorySpecificInfo()
{
    // @@protoc_insertion_point(destructor:drive.DirectorySpecificInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DirectorySpecificInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.start_page_token_.Destroy();
}

void DirectorySpecificInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DirectorySpecificInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:drive.DirectorySpecificInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.start_page_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.changestamp_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_read_time_ms_) - reinterpret_cast<char*>(&_impl_.changestamp_))
                + sizeof(_impl_.last_read_time_ms_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DirectorySpecificInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 changestamp = 1 [deprecated = true];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_changestamp(&has_bits);
                _impl_.changestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string start_page_token = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_start_page_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 last_read_time_ms = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_last_read_time_ms(&has_bits);
                _impl_.last_read_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DirectorySpecificInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:drive.DirectorySpecificInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 changestamp = 1 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_changestamp(), target);
    }

    // optional string start_page_token = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_start_page_token(), target);
    }

    // optional int64 last_read_time_ms = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_last_read_time_ms(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:drive.DirectorySpecificInfo)
    return target;
}

size_t DirectorySpecificInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:drive.DirectorySpecificInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string start_page_token = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_start_page_token());
        }

        // optional int64 changestamp = 1 [deprecated = true];
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_changestamp());
        }

        // optional int64 last_read_time_ms = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_read_time_ms());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DirectorySpecificInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DirectorySpecificInfo*>(&from));
}

void DirectorySpecificInfo::MergeFrom(const DirectorySpecificInfo& from)
{
    DirectorySpecificInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:drive.DirectorySpecificInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_start_page_token(from._internal_start_page_token());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.changestamp_ = from._impl_.changestamp_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.last_read_time_ms_ = from._impl_.last_read_time_ms_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DirectorySpecificInfo::CopyFrom(const DirectorySpecificInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:drive.DirectorySpecificInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DirectorySpecificInfo::IsInitialized() const
{
    return true;
}

void DirectorySpecificInfo::InternalSwap(DirectorySpecificInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.start_page_token_, lhs_arena, &other->_impl_.start_page_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(DirectorySpecificInfo, _impl_.last_read_time_ms_)
        + sizeof(DirectorySpecificInfo::_impl_.last_read_time_ms_) - PROTOBUF_FIELD_OFFSET(DirectorySpecificInfo, _impl_.changestamp_)>(
        reinterpret_cast<char*>(&_impl_.changestamp_), reinterpret_cast<char*>(&other->_impl_.changestamp_));
}

std::string DirectorySpecificInfo::GetTypeName() const
{
    return "drive.DirectorySpecificInfo";
}

// ===================================================================

class ResourceEntry::_Internal {
public:
    using HasBits = decltype(std::declval<ResourceEntry>()._impl_._has_bits_);
    static const ::drive::PlatformFileInfoProto& file_info(const ResourceEntry* msg);
    static void set_has_file_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_base_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_title(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_resource_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_local_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_parent_local_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_deleted(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_starred(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static void set_has_shared_with_me(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static void set_has_shared(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static const ::drive::CapabilitiesInfo& capabilities_info(const ResourceEntry* msg);
    static void set_has_capabilities_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static const ::drive::FileSpecificInfo& file_specific_info(const ResourceEntry* msg);
    static void set_has_file_specific_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static const ::drive::DirectorySpecificInfo& directory_specific_info(const ResourceEntry* msg);
    static void set_has_directory_specific_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static const ::drive::TeamDriveRootSpecificInfo& team_drive_root_specific_info(const ResourceEntry* msg);
    static void set_has_team_drive_root_specific_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_metadata_edit_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32768u;
    }
    static void set_has_modification_date(HasBits* has_bits)
    {
        (*has_bits)[0] |= 65536u;
    }
    static void set_has_last_modified_by_me(HasBits* has_bits)
    {
        (*has_bits)[0] |= 131072u;
    }
    static void set_has_alternate_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
};

const ::drive::PlatformFileInfoProto& ResourceEntry::_Internal::file_info(const ResourceEntry* msg)
{
    return *msg->_impl_.file_info_;
}
const ::drive::CapabilitiesInfo& ResourceEntry::_Internal::capabilities_info(const ResourceEntry* msg)
{
    return *msg->_impl_.capabilities_info_;
}
const ::drive::FileSpecificInfo& ResourceEntry::_Internal::file_specific_info(const ResourceEntry* msg)
{
    return *msg->_impl_.file_specific_info_;
}
const ::drive::DirectorySpecificInfo& ResourceEntry::_Internal::directory_specific_info(const ResourceEntry* msg)
{
    return *msg->_impl_.directory_specific_info_;
}
const ::drive::TeamDriveRootSpecificInfo& ResourceEntry::_Internal::team_drive_root_specific_info(const ResourceEntry* msg)
{
    return *msg->_impl_.team_drive_root_specific_info_;
}
ResourceEntry::ResourceEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:drive.ResourceEntry)
}
ResourceEntry::ResourceEntry(const ResourceEntry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ResourceEntry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.new_properties_) { from._impl_.new_properties_ }, decltype(_impl_.base_name_) {}, decltype(_impl_.title_) {},
        decltype(_impl_.resource_id_) {}, decltype(_impl_.parent_local_id_) {}, decltype(_impl_.local_id_) {}, decltype(_impl_.alternate_url_) {},
        decltype(_impl_.file_info_) { nullptr }, decltype(_impl_.file_specific_info_) { nullptr }, decltype(_impl_.directory_specific_info_) { nullptr },
        decltype(_impl_.team_drive_root_specific_info_) { nullptr }, decltype(_impl_.capabilities_info_) { nullptr }, decltype(_impl_.deleted_) {},
        decltype(_impl_.starred_) {}, decltype(_impl_.shared_with_me_) {}, decltype(_impl_.shared_) {}, decltype(_impl_.metadata_edit_state_) {},
        decltype(_impl_.modification_date_) {}, decltype(_impl_.last_modified_by_me_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.base_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_base_name()) {
        _this->_impl_.base_name_.Set(from._internal_base_name(), _this->GetArenaForAllocation());
    }
    _impl_.title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_title()) {
        _this->_impl_.title_.Set(from._internal_title(), _this->GetArenaForAllocation());
    }
    _impl_.resource_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resource_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_resource_id()) {
        _this->_impl_.resource_id_.Set(from._internal_resource_id(), _this->GetArenaForAllocation());
    }
    _impl_.parent_local_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_local_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_parent_local_id()) {
        _this->_impl_.parent_local_id_.Set(from._internal_parent_local_id(), _this->GetArenaForAllocation());
    }
    _impl_.local_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.local_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_local_id()) {
        _this->_impl_.local_id_.Set(from._internal_local_id(), _this->GetArenaForAllocation());
    }
    _impl_.alternate_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alternate_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_alternate_url()) {
        _this->_impl_.alternate_url_.Set(from._internal_alternate_url(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_file_info()) {
        _this->_impl_.file_info_ = new ::drive::PlatformFileInfoProto(*from._impl_.file_info_);
    }
    if (from._internal_has_file_specific_info()) {
        _this->_impl_.file_specific_info_ = new ::drive::FileSpecificInfo(*from._impl_.file_specific_info_);
    }
    if (from._internal_has_directory_specific_info()) {
        _this->_impl_.directory_specific_info_ = new ::drive::DirectorySpecificInfo(*from._impl_.directory_specific_info_);
    }
    if (from._internal_has_team_drive_root_specific_info()) {
        _this->_impl_.team_drive_root_specific_info_ = new ::drive::TeamDriveRootSpecificInfo(*from._impl_.team_drive_root_specific_info_);
    }
    if (from._internal_has_capabilities_info()) {
        _this->_impl_.capabilities_info_ = new ::drive::CapabilitiesInfo(*from._impl_.capabilities_info_);
    }
    ::memcpy(&_impl_.deleted_, &from._impl_.deleted_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_modified_by_me_) - reinterpret_cast<char*>(&_impl_.deleted_))
            + sizeof(_impl_.last_modified_by_me_));
    // @@protoc_insertion_point(copy_constructor:drive.ResourceEntry)
}

inline void ResourceEntry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.new_properties_) { arena },
        decltype(_impl_.base_name_) {}, decltype(_impl_.title_) {}, decltype(_impl_.resource_id_) {}, decltype(_impl_.parent_local_id_) {},
        decltype(_impl_.local_id_) {}, decltype(_impl_.alternate_url_) {}, decltype(_impl_.file_info_) { nullptr },
        decltype(_impl_.file_specific_info_) { nullptr }, decltype(_impl_.directory_specific_info_) { nullptr },
        decltype(_impl_.team_drive_root_specific_info_) { nullptr }, decltype(_impl_.capabilities_info_) { nullptr }, decltype(_impl_.deleted_) { false },
        decltype(_impl_.starred_) { false }, decltype(_impl_.shared_with_me_) { false }, decltype(_impl_.shared_) { false },
        decltype(_impl_.metadata_edit_state_) { 0 }, decltype(_impl_.modification_date_) { int64_t { 0 } },
        decltype(_impl_.last_modified_by_me_) { int64_t { 0 } } };
    _impl_.base_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.base_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resource_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.resource_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_local_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.parent_local_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.local_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.local_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alternate_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alternate_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResourceEntry::~ResourceEntry()
{
    // @@protoc_insertion_point(destructor:drive.ResourceEntry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ResourceEntry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.new_properties_.~RepeatedPtrField();
    _impl_.base_name_.Destroy();
    _impl_.title_.Destroy();
    _impl_.resource_id_.Destroy();
    _impl_.parent_local_id_.Destroy();
    _impl_.local_id_.Destroy();
    _impl_.alternate_url_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.file_info_;
    if (this != internal_default_instance())
        delete _impl_.file_specific_info_;
    if (this != internal_default_instance())
        delete _impl_.directory_specific_info_;
    if (this != internal_default_instance())
        delete _impl_.team_drive_root_specific_info_;
    if (this != internal_default_instance())
        delete _impl_.capabilities_info_;
}

void ResourceEntry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ResourceEntry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:drive.ResourceEntry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.new_properties_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.base_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.title_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.resource_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.parent_local_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.local_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.alternate_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.file_info_ != nullptr);
            _impl_.file_info_->Clear();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.file_specific_info_ != nullptr);
            _impl_.file_specific_info_->Clear();
        }
    }
    if (cached_has_bits & 0x00000700u) {
        if (cached_has_bits & 0x00000100u) {
            GOOGLE_DCHECK(_impl_.directory_specific_info_ != nullptr);
            _impl_.directory_specific_info_->Clear();
        }
        if (cached_has_bits & 0x00000200u) {
            GOOGLE_DCHECK(_impl_.team_drive_root_specific_info_ != nullptr);
            _impl_.team_drive_root_specific_info_->Clear();
        }
        if (cached_has_bits & 0x00000400u) {
            GOOGLE_DCHECK(_impl_.capabilities_info_ != nullptr);
            _impl_.capabilities_info_->Clear();
        }
    }
    if (cached_has_bits & 0x0000f800u) {
        ::memset(&_impl_.deleted_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.metadata_edit_state_) - reinterpret_cast<char*>(&_impl_.deleted_))
                + sizeof(_impl_.metadata_edit_state_));
    }
    if (cached_has_bits & 0x00030000u) {
        ::memset(&_impl_.modification_date_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_modified_by_me_) - reinterpret_cast<char*>(&_impl_.modification_date_))
                + sizeof(_impl_.last_modified_by_me_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ResourceEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .drive.PlatformFileInfoProto file_info = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_file_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string base_name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_base_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string title = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_title();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string resource_id = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_resource_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string parent_local_id = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_parent_local_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .drive.FileSpecificInfo file_specific_info = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr = ctx->ParseMessage(_internal_mutable_file_specific_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool deleted = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
                _Internal::set_has_deleted(&has_bits);
                _impl_.deleted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .drive.DirectorySpecificInfo directory_specific_info = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                ptr = ctx->ParseMessage(_internal_mutable_directory_specific_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool shared_with_me = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
                _Internal::set_has_shared_with_me(&has_bits);
                _impl_.shared_with_me_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string local_id = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
                auto str = _internal_mutable_local_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .drive.ResourceEntry.EditState metadata_edit_state = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::drive::ResourceEntry_EditState_IsValid(val))) {
                    _internal_set_metadata_edit_state(static_cast<::drive::ResourceEntry_EditState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional bool shared = 17;
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
                _Internal::set_has_shared(&has_bits);
                _impl_.shared_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 modification_date = 18;
        case 18:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
                _Internal::set_has_modification_date(&has_bits);
                _impl_.modification_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .drive.Property new_properties = 19;
        case 19:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_new_properties(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<154>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool starred = 20;
        case 20:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
                _Internal::set_has_starred(&has_bits);
                _impl_.starred_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 last_modified_by_me = 21;
        case 21:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
                _Internal::set_has_last_modified_by_me(&has_bits);
                _impl_.last_modified_by_me_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string alternate_url = 22;
        case 22:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
                auto str = _internal_mutable_alternate_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .drive.TeamDriveRootSpecificInfo team_drive_root_specific_info = 23;
        case 23:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
                ptr = ctx->ParseMessage(_internal_mutable_team_drive_root_specific_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .drive.CapabilitiesInfo capabilities_info = 24;
        case 24:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
                ptr = ctx->ParseMessage(_internal_mutable_capabilities_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ResourceEntry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:drive.ResourceEntry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .drive.PlatformFileInfoProto file_info = 1;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::file_info(this), _Internal::file_info(this).GetCachedSize(), target, stream);
    }

    // optional string base_name = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_base_name(), target);
    }

    // optional string title = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_title(), target);
    }

    // optional string resource_id = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_resource_id(), target);
    }

    // optional string parent_local_id = 7;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_parent_local_id(), target);
    }

    // optional .drive.FileSpecificInfo file_specific_info = 9;
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            9, _Internal::file_specific_info(this), _Internal::file_specific_info(this).GetCachedSize(), target, stream);
    }

    // optional bool deleted = 11;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_deleted(), target);
    }

    // optional .drive.DirectorySpecificInfo directory_specific_info = 13;
    if (cached_has_bits & 0x00000100u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            13, _Internal::directory_specific_info(this), _Internal::directory_specific_info(this).GetCachedSize(), target, stream);
    }

    // optional bool shared_with_me = 14;
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_shared_with_me(), target);
    }

    // optional string local_id = 15;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(15, this->_internal_local_id(), target);
    }

    // optional .drive.ResourceEntry.EditState metadata_edit_state = 16;
    if (cached_has_bits & 0x00008000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(16, this->_internal_metadata_edit_state(), target);
    }

    // optional bool shared = 17;
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_shared(), target);
    }

    // optional int64 modification_date = 18;
    if (cached_has_bits & 0x00010000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(18, this->_internal_modification_date(), target);
    }

    // repeated .drive.Property new_properties = 19;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_new_properties_size()); i < n; i++) {
        const auto& repfield = this->_internal_new_properties(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(19, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bool starred = 20;
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_starred(), target);
    }

    // optional int64 last_modified_by_me = 21;
    if (cached_has_bits & 0x00020000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(21, this->_internal_last_modified_by_me(), target);
    }

    // optional string alternate_url = 22;
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteStringMaybeAliased(22, this->_internal_alternate_url(), target);
    }

    // optional .drive.TeamDriveRootSpecificInfo team_drive_root_specific_info = 23;
    if (cached_has_bits & 0x00000200u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            23, _Internal::team_drive_root_specific_info(this), _Internal::team_drive_root_specific_info(this).GetCachedSize(), target, stream);
    }

    // optional .drive.CapabilitiesInfo capabilities_info = 24;
    if (cached_has_bits & 0x00000400u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            24, _Internal::capabilities_info(this), _Internal::capabilities_info(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:drive.ResourceEntry)
    return target;
}

size_t ResourceEntry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:drive.ResourceEntry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .drive.Property new_properties = 19;
    total_size += 2UL * this->_internal_new_properties_size();
    for (const auto& msg : this->_impl_.new_properties_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string base_name = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_base_name());
        }

        // optional string title = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_title());
        }

        // optional string resource_id = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_resource_id());
        }

        // optional string parent_local_id = 7;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_parent_local_id());
        }

        // optional string local_id = 15;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_local_id());
        }

        // optional string alternate_url = 22;
        if (cached_has_bits & 0x00000020u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_alternate_url());
        }

        // optional .drive.PlatformFileInfoProto file_info = 1;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.file_info_);
        }

        // optional .drive.FileSpecificInfo file_specific_info = 9;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.file_specific_info_);
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        // optional .drive.DirectorySpecificInfo directory_specific_info = 13;
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.directory_specific_info_);
        }

        // optional .drive.TeamDriveRootSpecificInfo team_drive_root_specific_info = 23;
        if (cached_has_bits & 0x00000200u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.team_drive_root_specific_info_);
        }

        // optional .drive.CapabilitiesInfo capabilities_info = 24;
        if (cached_has_bits & 0x00000400u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.capabilities_info_);
        }

        // optional bool deleted = 11;
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + 1;
        }

        // optional bool starred = 20;
        if (cached_has_bits & 0x00001000u) {
            total_size += 2 + 1;
        }

        // optional bool shared_with_me = 14;
        if (cached_has_bits & 0x00002000u) {
            total_size += 1 + 1;
        }

        // optional bool shared = 17;
        if (cached_has_bits & 0x00004000u) {
            total_size += 2 + 1;
        }

        // optional .drive.ResourceEntry.EditState metadata_edit_state = 16;
        if (cached_has_bits & 0x00008000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_metadata_edit_state());
        }
    }
    if (cached_has_bits & 0x00030000u) {
        // optional int64 modification_date = 18;
        if (cached_has_bits & 0x00010000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_modification_date());
        }

        // optional int64 last_modified_by_me = 21;
        if (cached_has_bits & 0x00020000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_last_modified_by_me());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ResourceEntry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ResourceEntry*>(&from));
}

void ResourceEntry::MergeFrom(const ResourceEntry& from)
{
    ResourceEntry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:drive.ResourceEntry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.new_properties_.MergeFrom(from._impl_.new_properties_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_base_name(from._internal_base_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_title(from._internal_title());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_resource_id(from._internal_resource_id());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_parent_local_id(from._internal_parent_local_id());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_local_id(from._internal_local_id());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_alternate_url(from._internal_alternate_url());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_file_info()->::drive::PlatformFileInfoProto::MergeFrom(from._internal_file_info());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_file_specific_info()->::drive::FileSpecificInfo::MergeFrom(from._internal_file_specific_info());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_mutable_directory_specific_info()->::drive::DirectorySpecificInfo::MergeFrom(from._internal_directory_specific_info());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_internal_mutable_team_drive_root_specific_info()->::drive::TeamDriveRootSpecificInfo::MergeFrom(
                from._internal_team_drive_root_specific_info());
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_internal_mutable_capabilities_info()->::drive::CapabilitiesInfo::MergeFrom(from._internal_capabilities_info());
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.deleted_ = from._impl_.deleted_;
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.starred_ = from._impl_.starred_;
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.shared_with_me_ = from._impl_.shared_with_me_;
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.shared_ = from._impl_.shared_;
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_impl_.metadata_edit_state_ = from._impl_.metadata_edit_state_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00030000u) {
        if (cached_has_bits & 0x00010000u) {
            _this->_impl_.modification_date_ = from._impl_.modification_date_;
        }
        if (cached_has_bits & 0x00020000u) {
            _this->_impl_.last_modified_by_me_ = from._impl_.last_modified_by_me_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ResourceEntry::CopyFrom(const ResourceEntry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:drive.ResourceEntry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ResourceEntry::IsInitialized() const
{
    return true;
}

void ResourceEntry::InternalSwap(ResourceEntry* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.new_properties_.InternalSwap(&other->_impl_.new_properties_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.base_name_, lhs_arena, &other->_impl_.base_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.title_, lhs_arena, &other->_impl_.title_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.resource_id_, lhs_arena, &other->_impl_.resource_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.parent_local_id_, lhs_arena, &other->_impl_.parent_local_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.local_id_, lhs_arena, &other->_impl_.local_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.alternate_url_, lhs_arena, &other->_impl_.alternate_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ResourceEntry, _impl_.last_modified_by_me_)
        + sizeof(ResourceEntry::_impl_.last_modified_by_me_) - PROTOBUF_FIELD_OFFSET(ResourceEntry, _impl_.file_info_)>(
        reinterpret_cast<char*>(&_impl_.file_info_), reinterpret_cast<char*>(&other->_impl_.file_info_));
}

std::string ResourceEntry::GetTypeName() const
{
    return "drive.ResourceEntry";
}

// ===================================================================

class ResourceMetadataHeader::_Internal {
public:
    using HasBits = decltype(std::declval<ResourceMetadataHeader>()._impl_._has_bits_);
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_largest_changestamp(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_start_page_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ResourceMetadataHeader::ResourceMetadataHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:drive.ResourceMetadataHeader)
}
ResourceMetadataHeader::ResourceMetadataHeader(const ResourceMetadataHeader& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ResourceMetadataHeader* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.start_page_token_) {},
        decltype(_impl_.largest_changestamp_) {}, decltype(_impl_.version_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.start_page_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.start_page_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_start_page_token()) {
        _this->_impl_.start_page_token_.Set(from._internal_start_page_token(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.largest_changestamp_, &from._impl_.largest_changestamp_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.version_) - reinterpret_cast<char*>(&_impl_.largest_changestamp_)) + sizeof(_impl_.version_));
    // @@protoc_insertion_point(copy_constructor:drive.ResourceMetadataHeader)
}

inline void ResourceMetadataHeader::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.start_page_token_) {},
        decltype(_impl_.largest_changestamp_) { int64_t { 0 } }, decltype(_impl_.version_) { 0 } };
    _impl_.start_page_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.start_page_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ResourceMetadataHeader::~ResourceMetadataHeader()
{
    // @@protoc_insertion_point(destructor:drive.ResourceMetadataHeader)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ResourceMetadataHeader::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.start_page_token_.Destroy();
}

void ResourceMetadataHeader::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ResourceMetadataHeader::Clear()
{
    // @@protoc_insertion_point(message_clear_start:drive.ResourceMetadataHeader)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.start_page_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.largest_changestamp_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.version_) - reinterpret_cast<char*>(&_impl_.largest_changestamp_)) + sizeof(_impl_.version_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ResourceMetadataHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 version = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_version(&has_bits);
                _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 largest_changestamp = 2 [deprecated = true];
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_largest_changestamp(&has_bits);
                _impl_.largest_changestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string start_page_token = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_start_page_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ResourceMetadataHeader::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:drive.ResourceMetadataHeader)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 version = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_version(), target);
    }

    // optional int64 largest_changestamp = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_largest_changestamp(), target);
    }

    // optional string start_page_token = 4;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_start_page_token(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:drive.ResourceMetadataHeader)
    return target;
}

size_t ResourceMetadataHeader::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:drive.ResourceMetadataHeader)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string start_page_token = 4;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_start_page_token());
        }

        // optional int64 largest_changestamp = 2 [deprecated = true];
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_largest_changestamp());
        }

        // optional int32 version = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_version());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ResourceMetadataHeader::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ResourceMetadataHeader*>(&from));
}

void ResourceMetadataHeader::MergeFrom(const ResourceMetadataHeader& from)
{
    ResourceMetadataHeader* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:drive.ResourceMetadataHeader)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_start_page_token(from._internal_start_page_token());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.largest_changestamp_ = from._impl_.largest_changestamp_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.version_ = from._impl_.version_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ResourceMetadataHeader::CopyFrom(const ResourceMetadataHeader& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:drive.ResourceMetadataHeader)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ResourceMetadataHeader::IsInitialized() const
{
    return true;
}

void ResourceMetadataHeader::InternalSwap(ResourceMetadataHeader* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.start_page_token_, lhs_arena, &other->_impl_.start_page_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ResourceMetadataHeader, _impl_.version_) + sizeof(ResourceMetadataHeader::_impl_.version_)
        - PROTOBUF_FIELD_OFFSET(ResourceMetadataHeader, _impl_.largest_changestamp_)>(
        reinterpret_cast<char*>(&_impl_.largest_changestamp_), reinterpret_cast<char*>(&other->_impl_.largest_changestamp_));
}

std::string ResourceMetadataHeader::GetTypeName() const
{
    return "drive.ResourceMetadataHeader";
}

// ===================================================================

class FileCacheEntry::_Internal {
public:
    using HasBits = decltype(std::declval<FileCacheEntry>()._impl_._has_bits_);
    static void set_has_md5(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_is_present(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_is_pinned(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_is_dirty(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

FileCacheEntry::FileCacheEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:drive.FileCacheEntry)
}
FileCacheEntry::FileCacheEntry(const FileCacheEntry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    FileCacheEntry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.md5_) {},
        decltype(_impl_.is_present_) {}, decltype(_impl_.is_pinned_) {}, decltype(_impl_.is_dirty_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.md5_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.md5_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_md5()) {
        _this->_impl_.md5_.Set(from._internal_md5(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.is_present_, &from._impl_.is_present_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_dirty_) - reinterpret_cast<char*>(&_impl_.is_present_)) + sizeof(_impl_.is_dirty_));
    // @@protoc_insertion_point(copy_constructor:drive.FileCacheEntry)
}

inline void FileCacheEntry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.md5_) {},
        decltype(_impl_.is_present_) { false }, decltype(_impl_.is_pinned_) { false }, decltype(_impl_.is_dirty_) { false } };
    _impl_.md5_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.md5_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FileCacheEntry::~FileCacheEntry()
{
    // @@protoc_insertion_point(destructor:drive.FileCacheEntry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void FileCacheEntry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.md5_.Destroy();
}

void FileCacheEntry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void FileCacheEntry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:drive.FileCacheEntry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.md5_.ClearNonDefaultToEmpty();
    }
    ::memset(&_impl_.is_present_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_dirty_) - reinterpret_cast<char*>(&_impl_.is_present_)) + sizeof(_impl_.is_dirty_));
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* FileCacheEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string md5 = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_md5();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_present = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_is_present(&has_bits);
                _impl_.is_present_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_pinned = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_is_pinned(&has_bits);
                _impl_.is_pinned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_dirty = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_is_dirty(&has_bits);
                _impl_.is_dirty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* FileCacheEntry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:drive.FileCacheEntry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string md5 = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_md5(), target);
    }

    // optional bool is_present = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_present(), target);
    }

    // optional bool is_pinned = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_pinned(), target);
    }

    // optional bool is_dirty = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_dirty(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:drive.FileCacheEntry)
    return target;
}

size_t FileCacheEntry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:drive.FileCacheEntry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string md5 = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_md5());
        }

        // optional bool is_present = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }

        // optional bool is_pinned = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }

        // optional bool is_dirty = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void FileCacheEntry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const FileCacheEntry*>(&from));
}

void FileCacheEntry::MergeFrom(const FileCacheEntry& from)
{
    FileCacheEntry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:drive.FileCacheEntry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_md5(from._internal_md5());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.is_present_ = from._impl_.is_present_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.is_pinned_ = from._impl_.is_pinned_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.is_dirty_ = from._impl_.is_dirty_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FileCacheEntry::CopyFrom(const FileCacheEntry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:drive.FileCacheEntry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FileCacheEntry::IsInitialized() const
{
    return true;
}

void FileCacheEntry::InternalSwap(FileCacheEntry* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.md5_, lhs_arena, &other->_impl_.md5_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(FileCacheEntry, _impl_.is_dirty_) + sizeof(FileCacheEntry::_impl_.is_dirty_)
        - PROTOBUF_FIELD_OFFSET(FileCacheEntry, _impl_.is_present_)>(
        reinterpret_cast<char*>(&_impl_.is_present_), reinterpret_cast<char*>(&other->_impl_.is_present_));
}

std::string FileCacheEntry::GetTypeName() const
{
    return "drive.FileCacheEntry";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace drive
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::drive::PlatformFileInfoProto* Arena::CreateMaybeMessage<::drive::PlatformFileInfoProto>(Arena* arena)
{
    return Arena::CreateMessageInternal<::drive::PlatformFileInfoProto>(arena);
}
template <> PROTOBUF_NOINLINE ::drive::Property* Arena::CreateMaybeMessage<::drive::Property>(Arena* arena)
{
    return Arena::CreateMessageInternal<::drive::Property>(arena);
}
template <> PROTOBUF_NOINLINE ::drive::CapabilitiesInfo* Arena::CreateMaybeMessage<::drive::CapabilitiesInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::drive::CapabilitiesInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::drive::FileSpecificInfo* Arena::CreateMaybeMessage<::drive::FileSpecificInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::drive::FileSpecificInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::drive::TeamDriveRootSpecificInfo* Arena::CreateMaybeMessage<::drive::TeamDriveRootSpecificInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::drive::TeamDriveRootSpecificInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::drive::DirectorySpecificInfo* Arena::CreateMaybeMessage<::drive::DirectorySpecificInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::drive::DirectorySpecificInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::drive::ResourceEntry* Arena::CreateMaybeMessage<::drive::ResourceEntry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::drive::ResourceEntry>(arena);
}
template <> PROTOBUF_NOINLINE ::drive::ResourceMetadataHeader* Arena::CreateMaybeMessage<::drive::ResourceMetadataHeader>(Arena* arena)
{
    return Arena::CreateMessageInternal<::drive::ResourceMetadataHeader>(arena);
}
template <> PROTOBUF_NOINLINE ::drive::FileCacheEntry* Arena::CreateMaybeMessage<::drive::FileCacheEntry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::drive::FileCacheEntry>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
