// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: prediction_model_metadata.proto

#include "prediction_model_metadata.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace permissions {
PROTOBUF_CONSTEXPR WebPermissionPredictionsModelMetadata_LikelihoodThresholds::WebPermissionPredictionsModelMetadata_LikelihoodThresholds(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.max_very_unlikely_)*/ 0,
        /*decltype(_impl_.max_unlikely_)*/ 0, /*decltype(_impl_.max_neutral_)*/ 0, /*decltype(_impl_.max_likely_)*/ 0 }
{
}
struct WebPermissionPredictionsModelMetadata_LikelihoodThresholdsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WebPermissionPredictionsModelMetadata_LikelihoodThresholdsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WebPermissionPredictionsModelMetadata_LikelihoodThresholdsDefaultTypeInternal()
    {
    }
    union {
        WebPermissionPredictionsModelMetadata_LikelihoodThresholds _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WebPermissionPredictionsModelMetadata_LikelihoodThresholdsDefaultTypeInternal
    _WebPermissionPredictionsModelMetadata_LikelihoodThresholds_default_instance_;
PROTOBUF_CONSTEXPR WebPermissionPredictionsModelMetadata::WebPermissionPredictionsModelMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.model_features_)*/ {},
        /*decltype(_impl_._model_features_cached_byte_size_)*/ { 0 }, /*decltype(_impl_.not_grant_thresholds_)*/ nullptr,
        /*decltype(_impl_.permission_type_)*/ 0, /*decltype(_impl_.version_)*/ 0, /*decltype(_impl_.holdback_probability_)*/ 0 }
{
}
struct WebPermissionPredictionsModelMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WebPermissionPredictionsModelMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WebPermissionPredictionsModelMetadataDefaultTypeInternal()
    {
    }
    union {
        WebPermissionPredictionsModelMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WebPermissionPredictionsModelMetadataDefaultTypeInternal
    _WebPermissionPredictionsModelMetadata_default_instance_;
PROTOBUF_CONSTEXPR WebPermissionPredictionsClientInfo::WebPermissionPredictionsClientInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.milestone_)*/ 0 }
{
}
struct WebPermissionPredictionsClientInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WebPermissionPredictionsClientInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WebPermissionPredictionsClientInfoDefaultTypeInternal()
    {
    }
    union {
        WebPermissionPredictionsClientInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WebPermissionPredictionsClientInfoDefaultTypeInternal
    _WebPermissionPredictionsClientInfo_default_instance_;
} // namespace permissions
namespace permissions {
bool WebPermissionPredictionsModelMetadata_ModelFeature_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WebPermissionPredictionsModelMetadata_ModelFeature_strings[13] = {};

static const char WebPermissionPredictionsModelMetadata_ModelFeature_names[] = "AVG_CLIENT_DENY_RATE"
                                                                               "AVG_CLIENT_DISMISS_RATE"
                                                                               "AVG_CLIENT_GRANT_RATE"
                                                                               "AVG_CLIENT_IGNORE_RATE"
                                                                               "AVG_CLIENT_PERMISSION_DENY_RATE"
                                                                               "AVG_CLIENT_PERMISSION_DISMISS_RATE"
                                                                               "AVG_CLIENT_PERMISSION_GRANT_RATE"
                                                                               "AVG_CLIENT_PERMISSION_IGNORE_RATE"
                                                                               "CLIENT_TOTAL_PERMISSION_PROMPTS"
                                                                               "CLIENT_TOTAL_PROMPTS"
                                                                               "GESTURE_ENUM"
                                                                               "MODEL_FEATURE_UNSPECIFIED"
                                                                               "PLATFORM_ENUM";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WebPermissionPredictionsModelMetadata_ModelFeature_entries[] = {
    { { WebPermissionPredictionsModelMetadata_ModelFeature_names + 0, 20 }, 4 },
    { { WebPermissionPredictionsModelMetadata_ModelFeature_names + 20, 23 }, 5 },
    { { WebPermissionPredictionsModelMetadata_ModelFeature_names + 43, 21 }, 3 },
    { { WebPermissionPredictionsModelMetadata_ModelFeature_names + 64, 22 }, 6 },
    { { WebPermissionPredictionsModelMetadata_ModelFeature_names + 86, 31 }, 9 },
    { { WebPermissionPredictionsModelMetadata_ModelFeature_names + 117, 34 }, 10 },
    { { WebPermissionPredictionsModelMetadata_ModelFeature_names + 151, 32 }, 8 },
    { { WebPermissionPredictionsModelMetadata_ModelFeature_names + 183, 33 }, 11 },
    { { WebPermissionPredictionsModelMetadata_ModelFeature_names + 216, 31 }, 12 },
    { { WebPermissionPredictionsModelMetadata_ModelFeature_names + 247, 20 }, 7 },
    { { WebPermissionPredictionsModelMetadata_ModelFeature_names + 267, 12 }, 2 },
    { { WebPermissionPredictionsModelMetadata_ModelFeature_names + 279, 25 }, 0 },
    { { WebPermissionPredictionsModelMetadata_ModelFeature_names + 304, 13 }, 1 },
};

static const int WebPermissionPredictionsModelMetadata_ModelFeature_entries_by_number[] = {
    11, // 0 -> MODEL_FEATURE_UNSPECIFIED
    12, // 1 -> PLATFORM_ENUM
    10, // 2 -> GESTURE_ENUM
    2, // 3 -> AVG_CLIENT_GRANT_RATE
    0, // 4 -> AVG_CLIENT_DENY_RATE
    1, // 5 -> AVG_CLIENT_DISMISS_RATE
    3, // 6 -> AVG_CLIENT_IGNORE_RATE
    9, // 7 -> CLIENT_TOTAL_PROMPTS
    6, // 8 -> AVG_CLIENT_PERMISSION_GRANT_RATE
    4, // 9 -> AVG_CLIENT_PERMISSION_DENY_RATE
    5, // 10 -> AVG_CLIENT_PERMISSION_DISMISS_RATE
    7, // 11 -> AVG_CLIENT_PERMISSION_IGNORE_RATE
    8, // 12 -> CLIENT_TOTAL_PERMISSION_PROMPTS
};

const std::string& WebPermissionPredictionsModelMetadata_ModelFeature_Name(WebPermissionPredictionsModelMetadata_ModelFeature value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(WebPermissionPredictionsModelMetadata_ModelFeature_entries,
        WebPermissionPredictionsModelMetadata_ModelFeature_entries_by_number, 13, WebPermissionPredictionsModelMetadata_ModelFeature_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        WebPermissionPredictionsModelMetadata_ModelFeature_entries, WebPermissionPredictionsModelMetadata_ModelFeature_entries_by_number, 13, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : WebPermissionPredictionsModelMetadata_ModelFeature_strings[idx].get();
}
bool WebPermissionPredictionsModelMetadata_ModelFeature_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WebPermissionPredictionsModelMetadata_ModelFeature* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(WebPermissionPredictionsModelMetadata_ModelFeature_entries, 13, name, &int_value);
    if (success) {
        *value = static_cast<WebPermissionPredictionsModelMetadata_ModelFeature>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::MODEL_FEATURE_UNSPECIFIED;
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::PLATFORM_ENUM;
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::GESTURE_ENUM;
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::AVG_CLIENT_GRANT_RATE;
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::AVG_CLIENT_DENY_RATE;
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::AVG_CLIENT_DISMISS_RATE;
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::AVG_CLIENT_IGNORE_RATE;
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::CLIENT_TOTAL_PROMPTS;
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::AVG_CLIENT_PERMISSION_GRANT_RATE;
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::AVG_CLIENT_PERMISSION_DENY_RATE;
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::AVG_CLIENT_PERMISSION_DISMISS_RATE;
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::AVG_CLIENT_PERMISSION_IGNORE_RATE;
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::CLIENT_TOTAL_PERMISSION_PROMPTS;
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::ModelFeature_MIN;
constexpr WebPermissionPredictionsModelMetadata_ModelFeature WebPermissionPredictionsModelMetadata::ModelFeature_MAX;
constexpr int WebPermissionPredictionsModelMetadata::ModelFeature_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool WebPermissionPredictionsModelMetadata_PermissionType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WebPermissionPredictionsModelMetadata_PermissionType_strings[3] = {};

static const char WebPermissionPredictionsModelMetadata_PermissionType_names[] = "GEOLOCATION_PERMISSION"
                                                                                 "NOTIFICATIONS_PERMISSION"
                                                                                 "PERMISSION_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WebPermissionPredictionsModelMetadata_PermissionType_entries[] = {
    { { WebPermissionPredictionsModelMetadata_PermissionType_names + 0, 22 }, 2 },
    { { WebPermissionPredictionsModelMetadata_PermissionType_names + 22, 24 }, 1 },
    { { WebPermissionPredictionsModelMetadata_PermissionType_names + 46, 27 }, 0 },
};

static const int WebPermissionPredictionsModelMetadata_PermissionType_entries_by_number[] = {
    2, // 0 -> PERMISSION_TYPE_UNSPECIFIED
    1, // 1 -> NOTIFICATIONS_PERMISSION
    0, // 2 -> GEOLOCATION_PERMISSION
};

const std::string& WebPermissionPredictionsModelMetadata_PermissionType_Name(WebPermissionPredictionsModelMetadata_PermissionType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(WebPermissionPredictionsModelMetadata_PermissionType_entries,
        WebPermissionPredictionsModelMetadata_PermissionType_entries_by_number, 3, WebPermissionPredictionsModelMetadata_PermissionType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        WebPermissionPredictionsModelMetadata_PermissionType_entries, WebPermissionPredictionsModelMetadata_PermissionType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : WebPermissionPredictionsModelMetadata_PermissionType_strings[idx].get();
}
bool WebPermissionPredictionsModelMetadata_PermissionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WebPermissionPredictionsModelMetadata_PermissionType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(WebPermissionPredictionsModelMetadata_PermissionType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<WebPermissionPredictionsModelMetadata_PermissionType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr WebPermissionPredictionsModelMetadata_PermissionType WebPermissionPredictionsModelMetadata::PERMISSION_TYPE_UNSPECIFIED;
constexpr WebPermissionPredictionsModelMetadata_PermissionType WebPermissionPredictionsModelMetadata::NOTIFICATIONS_PERMISSION;
constexpr WebPermissionPredictionsModelMetadata_PermissionType WebPermissionPredictionsModelMetadata::GEOLOCATION_PERMISSION;
constexpr WebPermissionPredictionsModelMetadata_PermissionType WebPermissionPredictionsModelMetadata::PermissionType_MIN;
constexpr WebPermissionPredictionsModelMetadata_PermissionType WebPermissionPredictionsModelMetadata::PermissionType_MAX;
constexpr int WebPermissionPredictionsModelMetadata::PermissionType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class WebPermissionPredictionsModelMetadata_LikelihoodThresholds::_Internal {
public:
    using HasBits = decltype(std::declval<WebPermissionPredictionsModelMetadata_LikelihoodThresholds>()._impl_._has_bits_);
    static void set_has_max_very_unlikely(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_max_unlikely(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_max_neutral(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_max_likely(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

WebPermissionPredictionsModelMetadata_LikelihoodThresholds::WebPermissionPredictionsModelMetadata_LikelihoodThresholds(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.WebPermissionPredictionsModelMetadata.LikelihoodThresholds)
}
WebPermissionPredictionsModelMetadata_LikelihoodThresholds::WebPermissionPredictionsModelMetadata_LikelihoodThresholds(
    const WebPermissionPredictionsModelMetadata_LikelihoodThresholds& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WebPermissionPredictionsModelMetadata_LikelihoodThresholds* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.max_very_unlikely_) {},
        decltype(_impl_.max_unlikely_) {}, decltype(_impl_.max_neutral_) {}, decltype(_impl_.max_likely_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.max_very_unlikely_, &from._impl_.max_very_unlikely_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_likely_) - reinterpret_cast<char*>(&_impl_.max_very_unlikely_)) + sizeof(_impl_.max_likely_));
    // @@protoc_insertion_point(copy_constructor:permissions.WebPermissionPredictionsModelMetadata.LikelihoodThresholds)
}

inline void WebPermissionPredictionsModelMetadata_LikelihoodThresholds::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.max_very_unlikely_) { 0 },
        decltype(_impl_.max_unlikely_) { 0 }, decltype(_impl_.max_neutral_) { 0 }, decltype(_impl_.max_likely_) { 0 } };
}

WebPermissionPredictionsModelMetadata_LikelihoodThresholds::~WebPermissionPredictionsModelMetadata_LikelihoodThresholds()
{
    // @@protoc_insertion_point(destructor:permissions.WebPermissionPredictionsModelMetadata.LikelihoodThresholds)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WebPermissionPredictionsModelMetadata_LikelihoodThresholds::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WebPermissionPredictionsModelMetadata_LikelihoodThresholds::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WebPermissionPredictionsModelMetadata_LikelihoodThresholds::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.WebPermissionPredictionsModelMetadata.LikelihoodThresholds)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        ::memset(&_impl_.max_very_unlikely_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_likely_) - reinterpret_cast<char*>(&_impl_.max_very_unlikely_))
                + sizeof(_impl_.max_likely_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WebPermissionPredictionsModelMetadata_LikelihoodThresholds::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional float max_very_unlikely = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
                _Internal::set_has_max_very_unlikely(&has_bits);
                _impl_.max_very_unlikely_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float max_unlikely = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
                _Internal::set_has_max_unlikely(&has_bits);
                _impl_.max_unlikely_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float max_neutral = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
                _Internal::set_has_max_neutral(&has_bits);
                _impl_.max_neutral_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float max_likely = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
                _Internal::set_has_max_likely(&has_bits);
                _impl_.max_likely_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WebPermissionPredictionsModelMetadata_LikelihoodThresholds::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.WebPermissionPredictionsModelMetadata.LikelihoodThresholds)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional float max_very_unlikely = 1;
    if (_internal_has_max_very_unlikely()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_max_very_unlikely(), target);
    }

    // optional float max_unlikely = 2;
    if (_internal_has_max_unlikely()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_max_unlikely(), target);
    }

    // optional float max_neutral = 3;
    if (_internal_has_max_neutral()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_max_neutral(), target);
    }

    // optional float max_likely = 4;
    if (_internal_has_max_likely()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_max_likely(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.WebPermissionPredictionsModelMetadata.LikelihoodThresholds)
    return target;
}

size_t WebPermissionPredictionsModelMetadata_LikelihoodThresholds::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.WebPermissionPredictionsModelMetadata.LikelihoodThresholds)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional float max_very_unlikely = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 4;
        }

        // optional float max_unlikely = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 4;
        }

        // optional float max_neutral = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 4;
        }

        // optional float max_likely = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 4;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WebPermissionPredictionsModelMetadata_LikelihoodThresholds::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WebPermissionPredictionsModelMetadata_LikelihoodThresholds*>(&from));
}

void WebPermissionPredictionsModelMetadata_LikelihoodThresholds::MergeFrom(const WebPermissionPredictionsModelMetadata_LikelihoodThresholds& from)
{
    WebPermissionPredictionsModelMetadata_LikelihoodThresholds* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.WebPermissionPredictionsModelMetadata.LikelihoodThresholds)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.max_very_unlikely_ = from._impl_.max_very_unlikely_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.max_unlikely_ = from._impl_.max_unlikely_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.max_neutral_ = from._impl_.max_neutral_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.max_likely_ = from._impl_.max_likely_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WebPermissionPredictionsModelMetadata_LikelihoodThresholds::CopyFrom(const WebPermissionPredictionsModelMetadata_LikelihoodThresholds& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.WebPermissionPredictionsModelMetadata.LikelihoodThresholds)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WebPermissionPredictionsModelMetadata_LikelihoodThresholds::IsInitialized() const
{
    return true;
}

void WebPermissionPredictionsModelMetadata_LikelihoodThresholds::InternalSwap(WebPermissionPredictionsModelMetadata_LikelihoodThresholds* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(WebPermissionPredictionsModelMetadata_LikelihoodThresholds, _impl_.max_likely_)
        + sizeof(WebPermissionPredictionsModelMetadata_LikelihoodThresholds::_impl_.max_likely_)
        - PROTOBUF_FIELD_OFFSET(WebPermissionPredictionsModelMetadata_LikelihoodThresholds, _impl_.max_very_unlikely_)>(
        reinterpret_cast<char*>(&_impl_.max_very_unlikely_), reinterpret_cast<char*>(&other->_impl_.max_very_unlikely_));
}

std::string WebPermissionPredictionsModelMetadata_LikelihoodThresholds::GetTypeName() const
{
    return "permissions.WebPermissionPredictionsModelMetadata.LikelihoodThresholds";
}

// ===================================================================

class WebPermissionPredictionsModelMetadata::_Internal {
public:
    using HasBits = decltype(std::declval<WebPermissionPredictionsModelMetadata>()._impl_._has_bits_);
    static void set_has_permission_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_holdback_probability(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::permissions::WebPermissionPredictionsModelMetadata_LikelihoodThresholds& not_grant_thresholds(
        const WebPermissionPredictionsModelMetadata* msg);
    static void set_has_not_grant_thresholds(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::permissions::WebPermissionPredictionsModelMetadata_LikelihoodThresholds& WebPermissionPredictionsModelMetadata::_Internal::not_grant_thresholds(
    const WebPermissionPredictionsModelMetadata* msg)
{
    return *msg->_impl_.not_grant_thresholds_;
}
WebPermissionPredictionsModelMetadata::WebPermissionPredictionsModelMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.WebPermissionPredictionsModelMetadata)
}
WebPermissionPredictionsModelMetadata::WebPermissionPredictionsModelMetadata(const WebPermissionPredictionsModelMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WebPermissionPredictionsModelMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.model_features_) { from._impl_.model_features_ }, /*decltype(_impl_._model_features_cached_byte_size_)*/ { 0 },
        decltype(_impl_.not_grant_thresholds_) { nullptr }, decltype(_impl_.permission_type_) {}, decltype(_impl_.version_) {},
        decltype(_impl_.holdback_probability_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_not_grant_thresholds()) {
        _this->_impl_.not_grant_thresholds_ = new ::permissions::WebPermissionPredictionsModelMetadata_LikelihoodThresholds(*from._impl_.not_grant_thresholds_);
    }
    ::memcpy(&_impl_.permission_type_, &from._impl_.permission_type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.holdback_probability_) - reinterpret_cast<char*>(&_impl_.permission_type_))
            + sizeof(_impl_.holdback_probability_));
    // @@protoc_insertion_point(copy_constructor:permissions.WebPermissionPredictionsModelMetadata)
}

inline void WebPermissionPredictionsModelMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.model_features_) { arena },
        /*decltype(_impl_._model_features_cached_byte_size_)*/ { 0 }, decltype(_impl_.not_grant_thresholds_) { nullptr },
        decltype(_impl_.permission_type_) { 0 }, decltype(_impl_.version_) { 0 }, decltype(_impl_.holdback_probability_) { 0 } };
}

WebPermissionPredictionsModelMetadata::~WebPermissionPredictionsModelMetadata()
{
    // @@protoc_insertion_point(destructor:permissions.WebPermissionPredictionsModelMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WebPermissionPredictionsModelMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.model_features_.~RepeatedField();
    if (this != internal_default_instance())
        delete _impl_.not_grant_thresholds_;
}

void WebPermissionPredictionsModelMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WebPermissionPredictionsModelMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.WebPermissionPredictionsModelMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.model_features_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.not_grant_thresholds_ != nullptr);
        _impl_.not_grant_thresholds_->Clear();
    }
    if (cached_has_bits & 0x0000000eu) {
        ::memset(&_impl_.permission_type_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.holdback_probability_) - reinterpret_cast<char*>(&_impl_.permission_type_))
                + sizeof(_impl_.holdback_probability_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WebPermissionPredictionsModelMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .permissions.WebPermissionPredictionsModelMetadata.ModelFeature model_features = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_model_features(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 8) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_add_model_features(static_cast<::permissions::WebPermissionPredictionsModelMetadata_ModelFeature>(val));
            } else
                goto handle_unusual;
            continue;
        // optional .permissions.WebPermissionPredictionsModelMetadata.PermissionType permission_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_permission_type(static_cast<::permissions::WebPermissionPredictionsModelMetadata_PermissionType>(val));
            } else
                goto handle_unusual;
            continue;
        // optional int32 version = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_version(&has_bits);
                _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional float holdback_probability = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
                _Internal::set_has_holdback_probability(&has_bits);
                _impl_.holdback_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional .permissions.WebPermissionPredictionsModelMetadata.LikelihoodThresholds not_grant_thresholds = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_not_grant_thresholds(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WebPermissionPredictionsModelMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.WebPermissionPredictionsModelMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .permissions.WebPermissionPredictionsModelMetadata.ModelFeature model_features = 1;
    {
        int byte_size = _impl_._model_features_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteEnumPacked(1, _impl_.model_features_, byte_size, target);
        }
    }

    // optional .permissions.WebPermissionPredictionsModelMetadata.PermissionType permission_type = 2;
    if (_internal_has_permission_type()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_permission_type(), target);
    }

    // optional int32 version = 3;
    if (_internal_has_version()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_version(), target);
    }

    // optional float holdback_probability = 4;
    if (_internal_has_holdback_probability()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_holdback_probability(), target);
    }

    // optional .permissions.WebPermissionPredictionsModelMetadata.LikelihoodThresholds not_grant_thresholds = 5;
    if (_internal_has_not_grant_thresholds()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::not_grant_thresholds(this), _Internal::not_grant_thresholds(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.WebPermissionPredictionsModelMetadata)
    return target;
}

size_t WebPermissionPredictionsModelMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.WebPermissionPredictionsModelMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .permissions.WebPermissionPredictionsModelMetadata.ModelFeature model_features = 1;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_model_features_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_model_features(static_cast<int>(i)));
        }
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._model_features_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .permissions.WebPermissionPredictionsModelMetadata.LikelihoodThresholds not_grant_thresholds = 5;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.not_grant_thresholds_);
        }

        // optional .permissions.WebPermissionPredictionsModelMetadata.PermissionType permission_type = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_permission_type());
        }

        // optional int32 version = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_version());
        }

        // optional float holdback_probability = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 4;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WebPermissionPredictionsModelMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WebPermissionPredictionsModelMetadata*>(&from));
}

void WebPermissionPredictionsModelMetadata::MergeFrom(const WebPermissionPredictionsModelMetadata& from)
{
    WebPermissionPredictionsModelMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.WebPermissionPredictionsModelMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.model_features_.MergeFrom(from._impl_.model_features_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_not_grant_thresholds()->::permissions::WebPermissionPredictionsModelMetadata_LikelihoodThresholds::MergeFrom(
                from._internal_not_grant_thresholds());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.permission_type_ = from._impl_.permission_type_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.version_ = from._impl_.version_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.holdback_probability_ = from._impl_.holdback_probability_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WebPermissionPredictionsModelMetadata::CopyFrom(const WebPermissionPredictionsModelMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.WebPermissionPredictionsModelMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WebPermissionPredictionsModelMetadata::IsInitialized() const
{
    return true;
}

void WebPermissionPredictionsModelMetadata::InternalSwap(WebPermissionPredictionsModelMetadata* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.model_features_.InternalSwap(&other->_impl_.model_features_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(WebPermissionPredictionsModelMetadata, _impl_.holdback_probability_)
        + sizeof(WebPermissionPredictionsModelMetadata::_impl_.holdback_probability_)
        - PROTOBUF_FIELD_OFFSET(WebPermissionPredictionsModelMetadata, _impl_.not_grant_thresholds_)>(
        reinterpret_cast<char*>(&_impl_.not_grant_thresholds_), reinterpret_cast<char*>(&other->_impl_.not_grant_thresholds_));
}

std::string WebPermissionPredictionsModelMetadata::GetTypeName() const
{
    return "permissions.WebPermissionPredictionsModelMetadata";
}

// ===================================================================

class WebPermissionPredictionsClientInfo::_Internal {
public:
    using HasBits = decltype(std::declval<WebPermissionPredictionsClientInfo>()._impl_._has_bits_);
    static void set_has_milestone(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

WebPermissionPredictionsClientInfo::WebPermissionPredictionsClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.WebPermissionPredictionsClientInfo)
}
WebPermissionPredictionsClientInfo::WebPermissionPredictionsClientInfo(const WebPermissionPredictionsClientInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WebPermissionPredictionsClientInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.milestone_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.milestone_ = from._impl_.milestone_;
    // @@protoc_insertion_point(copy_constructor:permissions.WebPermissionPredictionsClientInfo)
}

inline void WebPermissionPredictionsClientInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.milestone_) { 0 } };
}

WebPermissionPredictionsClientInfo::~WebPermissionPredictionsClientInfo()
{
    // @@protoc_insertion_point(destructor:permissions.WebPermissionPredictionsClientInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WebPermissionPredictionsClientInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void WebPermissionPredictionsClientInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WebPermissionPredictionsClientInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.WebPermissionPredictionsClientInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.milestone_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WebPermissionPredictionsClientInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 milestone = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_milestone(&has_bits);
                _impl_.milestone_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WebPermissionPredictionsClientInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.WebPermissionPredictionsClientInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional int32 milestone = 1;
    if (_internal_has_milestone()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_milestone(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.WebPermissionPredictionsClientInfo)
    return target;
}

size_t WebPermissionPredictionsClientInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.WebPermissionPredictionsClientInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional int32 milestone = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_milestone());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WebPermissionPredictionsClientInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WebPermissionPredictionsClientInfo*>(&from));
}

void WebPermissionPredictionsClientInfo::MergeFrom(const WebPermissionPredictionsClientInfo& from)
{
    WebPermissionPredictionsClientInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.WebPermissionPredictionsClientInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_milestone()) {
        _this->_internal_set_milestone(from._internal_milestone());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WebPermissionPredictionsClientInfo::CopyFrom(const WebPermissionPredictionsClientInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.WebPermissionPredictionsClientInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WebPermissionPredictionsClientInfo::IsInitialized() const
{
    return true;
}

void WebPermissionPredictionsClientInfo::InternalSwap(WebPermissionPredictionsClientInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.milestone_, other->_impl_.milestone_);
}

std::string WebPermissionPredictionsClientInfo::GetTypeName() const
{
    return "permissions.WebPermissionPredictionsClientInfo";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace permissions
PROTOBUF_NAMESPACE_OPEN
template <>
PROTOBUF_NOINLINE ::permissions::WebPermissionPredictionsModelMetadata_LikelihoodThresholds*
Arena::CreateMaybeMessage<::permissions::WebPermissionPredictionsModelMetadata_LikelihoodThresholds>(Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::WebPermissionPredictionsModelMetadata_LikelihoodThresholds>(arena);
}
template <>
PROTOBUF_NOINLINE ::permissions::WebPermissionPredictionsModelMetadata* Arena::CreateMaybeMessage<::permissions::WebPermissionPredictionsModelMetadata>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::WebPermissionPredictionsModelMetadata>(arena);
}
template <>
PROTOBUF_NOINLINE ::permissions::WebPermissionPredictionsClientInfo* Arena::CreateMaybeMessage<::permissions::WebPermissionPredictionsClientInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::WebPermissionPredictionsClientInfo>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
