// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: prediction_service_messages.proto

#include "prediction_service_messages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace permissions {
PROTOBUF_CONSTEXPR SiteFeatures::SiteFeatures(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.origin_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct SiteFeaturesDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SiteFeaturesDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SiteFeaturesDefaultTypeInternal()
    {
    }
    union {
        SiteFeatures _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SiteFeaturesDefaultTypeInternal _SiteFeatures_default_instance_;
PROTOBUF_CONSTEXPR StatsFeatures::StatsFeatures(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.avg_deny_rate_)*/ 0,
        /*decltype(_impl_.avg_grant_rate_)*/ 0, /*decltype(_impl_.avg_dismiss_rate_)*/ 0, /*decltype(_impl_.avg_ignore_rate_)*/ 0,
        /*decltype(_impl_.prompts_count_)*/ 0 }
{
}
struct StatsFeaturesDefaultTypeInternal {
    PROTOBUF_CONSTEXPR StatsFeaturesDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~StatsFeaturesDefaultTypeInternal()
    {
    }
    union {
        StatsFeatures _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatsFeaturesDefaultTypeInternal _StatsFeatures_default_instance_;
PROTOBUF_CONSTEXPR ClientFeatures_ExperimentConfig::ClientFeatures_ExperimentConfig(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.experiment_id_)*/ 0 }
{
}
struct ClientFeatures_ExperimentConfigDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientFeatures_ExperimentConfigDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientFeatures_ExperimentConfigDefaultTypeInternal()
    {
    }
    union {
        ClientFeatures_ExperimentConfig _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientFeatures_ExperimentConfigDefaultTypeInternal
    _ClientFeatures_ExperimentConfig_default_instance_;
PROTOBUF_CONSTEXPR ClientFeatures::ClientFeatures(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.client_stats_)*/ nullptr,
        /*decltype(_impl_.experiment_config_)*/ nullptr, /*decltype(_impl_.platform_)*/ 0, /*decltype(_impl_.gesture_)*/ 0,
        /*decltype(_impl_.gesture_enum_)*/ 0, /*decltype(_impl_.platform_enum_)*/ 0 }
{
}
struct ClientFeaturesDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientFeaturesDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientFeaturesDefaultTypeInternal()
    {
    }
    union {
        ClientFeatures _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientFeaturesDefaultTypeInternal _ClientFeatures_default_instance_;
PROTOBUF_CONSTEXPR PermissionFeatures_NotificationPermission::PermissionFeatures_NotificationPermission(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct PermissionFeatures_NotificationPermissionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PermissionFeatures_NotificationPermissionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PermissionFeatures_NotificationPermissionDefaultTypeInternal()
    {
    }
    union {
        PermissionFeatures_NotificationPermission _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionFeatures_NotificationPermissionDefaultTypeInternal
    _PermissionFeatures_NotificationPermission_default_instance_;
PROTOBUF_CONSTEXPR PermissionFeatures_GeolocationPermission::PermissionFeatures_GeolocationPermission(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct PermissionFeatures_GeolocationPermissionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PermissionFeatures_GeolocationPermissionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PermissionFeatures_GeolocationPermissionDefaultTypeInternal()
    {
    }
    union {
        PermissionFeatures_GeolocationPermission _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionFeatures_GeolocationPermissionDefaultTypeInternal
    _PermissionFeatures_GeolocationPermission_default_instance_;
PROTOBUF_CONSTEXPR PermissionFeatures::PermissionFeatures(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.permission_stats_)*/ nullptr,
        /*decltype(_impl_.permission_type_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct PermissionFeaturesDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PermissionFeaturesDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PermissionFeaturesDefaultTypeInternal()
    {
    }
    union {
        PermissionFeatures _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionFeaturesDefaultTypeInternal _PermissionFeatures_default_instance_;
PROTOBUF_CONSTEXPR PermissionPrediction_NotificationPrediction::PermissionPrediction_NotificationPrediction(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct PermissionPrediction_NotificationPredictionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PermissionPrediction_NotificationPredictionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PermissionPrediction_NotificationPredictionDefaultTypeInternal()
    {
    }
    union {
        PermissionPrediction_NotificationPrediction _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionPrediction_NotificationPredictionDefaultTypeInternal
    _PermissionPrediction_NotificationPrediction_default_instance_;
PROTOBUF_CONSTEXPR PermissionPrediction_GeolocationPrediction::PermissionPrediction_GeolocationPrediction(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct PermissionPrediction_GeolocationPredictionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PermissionPrediction_GeolocationPredictionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PermissionPrediction_GeolocationPredictionDefaultTypeInternal()
    {
    }
    union {
        PermissionPrediction_GeolocationPrediction _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionPrediction_GeolocationPredictionDefaultTypeInternal
    _PermissionPrediction_GeolocationPrediction_default_instance_;
PROTOBUF_CONSTEXPR PermissionPrediction_Likelihood::PermissionPrediction_Likelihood(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.discretized_likelihood_)*/ 0 }
{
}
struct PermissionPrediction_LikelihoodDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PermissionPrediction_LikelihoodDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PermissionPrediction_LikelihoodDefaultTypeInternal()
    {
    }
    union {
        PermissionPrediction_Likelihood _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionPrediction_LikelihoodDefaultTypeInternal
    _PermissionPrediction_Likelihood_default_instance_;
PROTOBUF_CONSTEXPR PermissionPrediction::PermissionPrediction(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.grant_likelihood_)*/ nullptr,
        /*decltype(_impl_.prediction_type_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct PermissionPredictionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PermissionPredictionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PermissionPredictionDefaultTypeInternal()
    {
    }
    union {
        PermissionPrediction _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PermissionPredictionDefaultTypeInternal
    _PermissionPrediction_default_instance_;
PROTOBUF_CONSTEXPR GeneratePredictionsRequest::GeneratePredictionsRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.permission_features_)*/ {},
        /*decltype(_impl_.client_features_)*/ nullptr, /*decltype(_impl_.site_features_)*/ nullptr }
{
}
struct GeneratePredictionsRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GeneratePredictionsRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GeneratePredictionsRequestDefaultTypeInternal()
    {
    }
    union {
        GeneratePredictionsRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeneratePredictionsRequestDefaultTypeInternal
    _GeneratePredictionsRequest_default_instance_;
PROTOBUF_CONSTEXPR GeneratePredictionsResponse::GeneratePredictionsResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.prediction_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct GeneratePredictionsResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GeneratePredictionsResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GeneratePredictionsResponseDefaultTypeInternal()
    {
    }
    union {
        GeneratePredictionsResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GeneratePredictionsResponseDefaultTypeInternal
    _GeneratePredictionsResponse_default_instance_;
} // namespace permissions
namespace permissions {
bool ClientFeatures_Platform_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientFeatures_Platform_strings[3] = {};

static const char ClientFeatures_Platform_names[] = "PLATFORM_DESKTOP"
                                                    "PLATFORM_MOBILE"
                                                    "PLATFORM_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientFeatures_Platform_entries[] = {
    { { ClientFeatures_Platform_names + 0, 16 }, 2 },
    { { ClientFeatures_Platform_names + 16, 15 }, 1 },
    { { ClientFeatures_Platform_names + 31, 20 }, 0 },
};

static const int ClientFeatures_Platform_entries_by_number[] = {
    2, // 0 -> PLATFORM_UNSPECIFIED
    1, // 1 -> PLATFORM_MOBILE
    0, // 2 -> PLATFORM_DESKTOP
};

const std::string& ClientFeatures_Platform_Name(ClientFeatures_Platform value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ClientFeatures_Platform_entries, ClientFeatures_Platform_entries_by_number, 3, ClientFeatures_Platform_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientFeatures_Platform_entries, ClientFeatures_Platform_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientFeatures_Platform_strings[idx].get();
}
bool ClientFeatures_Platform_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFeatures_Platform* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientFeatures_Platform_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ClientFeatures_Platform>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientFeatures_Platform ClientFeatures::PLATFORM_UNSPECIFIED;
constexpr ClientFeatures_Platform ClientFeatures::PLATFORM_MOBILE;
constexpr ClientFeatures_Platform ClientFeatures::PLATFORM_DESKTOP;
constexpr ClientFeatures_Platform ClientFeatures::Platform_MIN;
constexpr ClientFeatures_Platform ClientFeatures::Platform_MAX;
constexpr int ClientFeatures::Platform_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientFeatures_Gesture_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientFeatures_Gesture_strings[3] = {};

static const char ClientFeatures_Gesture_names[] = "GESTURE"
                                                   "GESTURE_UNSPECIFIED"
                                                   "NO_GESTURE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientFeatures_Gesture_entries[] = {
    { { ClientFeatures_Gesture_names + 0, 7 }, 2 },
    { { ClientFeatures_Gesture_names + 7, 19 }, 0 },
    { { ClientFeatures_Gesture_names + 26, 10 }, 1 },
};

static const int ClientFeatures_Gesture_entries_by_number[] = {
    1, // 0 -> GESTURE_UNSPECIFIED
    2, // 1 -> NO_GESTURE
    0, // 2 -> GESTURE
};

const std::string& ClientFeatures_Gesture_Name(ClientFeatures_Gesture value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ClientFeatures_Gesture_entries, ClientFeatures_Gesture_entries_by_number, 3, ClientFeatures_Gesture_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientFeatures_Gesture_entries, ClientFeatures_Gesture_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientFeatures_Gesture_strings[idx].get();
}
bool ClientFeatures_Gesture_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFeatures_Gesture* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientFeatures_Gesture_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ClientFeatures_Gesture>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientFeatures_Gesture ClientFeatures::GESTURE_UNSPECIFIED;
constexpr ClientFeatures_Gesture ClientFeatures::NO_GESTURE;
constexpr ClientFeatures_Gesture ClientFeatures::GESTURE;
constexpr ClientFeatures_Gesture ClientFeatures::Gesture_MIN;
constexpr ClientFeatures_Gesture ClientFeatures::Gesture_MAX;
constexpr int ClientFeatures::Gesture_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientFeatures_GestureEnum_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientFeatures_GestureEnum_strings[2] = {};

static const char ClientFeatures_GestureEnum_names[] = "GESTURE_UNSPECIFIED_V2"
                                                       "GESTURE_V2";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientFeatures_GestureEnum_entries[] = {
    { { ClientFeatures_GestureEnum_names + 0, 22 }, 1 },
    { { ClientFeatures_GestureEnum_names + 22, 10 }, 0 },
};

static const int ClientFeatures_GestureEnum_entries_by_number[] = {
    1, // 0 -> GESTURE_V2
    0, // 1 -> GESTURE_UNSPECIFIED_V2
};

const std::string& ClientFeatures_GestureEnum_Name(ClientFeatures_GestureEnum value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ClientFeatures_GestureEnum_entries, ClientFeatures_GestureEnum_entries_by_number, 2, ClientFeatures_GestureEnum_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientFeatures_GestureEnum_entries, ClientFeatures_GestureEnum_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientFeatures_GestureEnum_strings[idx].get();
}
bool ClientFeatures_GestureEnum_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFeatures_GestureEnum* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientFeatures_GestureEnum_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<ClientFeatures_GestureEnum>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientFeatures_GestureEnum ClientFeatures::GESTURE_V2;
constexpr ClientFeatures_GestureEnum ClientFeatures::GESTURE_UNSPECIFIED_V2;
constexpr ClientFeatures_GestureEnum ClientFeatures::GestureEnum_MIN;
constexpr ClientFeatures_GestureEnum ClientFeatures::GestureEnum_MAX;
constexpr int ClientFeatures::GestureEnum_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientFeatures_PlatformEnum_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientFeatures_PlatformEnum_strings[3] = {};

static const char ClientFeatures_PlatformEnum_names[] = "PLATFORM_DESKTOP_V2"
                                                        "PLATFORM_MOBILE_V2"
                                                        "PLATFORM_UNSPECIFIED_V2";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientFeatures_PlatformEnum_entries[] = {
    { { ClientFeatures_PlatformEnum_names + 0, 19 }, 1 },
    { { ClientFeatures_PlatformEnum_names + 19, 18 }, 0 },
    { { ClientFeatures_PlatformEnum_names + 37, 23 }, 3 },
};

static const int ClientFeatures_PlatformEnum_entries_by_number[] = {
    1, // 0 -> PLATFORM_MOBILE_V2
    0, // 1 -> PLATFORM_DESKTOP_V2
    2, // 3 -> PLATFORM_UNSPECIFIED_V2
};

const std::string& ClientFeatures_PlatformEnum_Name(ClientFeatures_PlatformEnum value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ClientFeatures_PlatformEnum_entries, ClientFeatures_PlatformEnum_entries_by_number, 3, ClientFeatures_PlatformEnum_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientFeatures_PlatformEnum_entries, ClientFeatures_PlatformEnum_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientFeatures_PlatformEnum_strings[idx].get();
}
bool ClientFeatures_PlatformEnum_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientFeatures_PlatformEnum* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientFeatures_PlatformEnum_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ClientFeatures_PlatformEnum>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientFeatures_PlatformEnum ClientFeatures::PLATFORM_MOBILE_V2;
constexpr ClientFeatures_PlatformEnum ClientFeatures::PLATFORM_DESKTOP_V2;
constexpr ClientFeatures_PlatformEnum ClientFeatures::PLATFORM_UNSPECIFIED_V2;
constexpr ClientFeatures_PlatformEnum ClientFeatures::PlatformEnum_MIN;
constexpr ClientFeatures_PlatformEnum ClientFeatures::PlatformEnum_MAX;
constexpr int ClientFeatures::PlatformEnum_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PermissionPrediction_Likelihood_DiscretizedLikelihood_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PermissionPrediction_Likelihood_DiscretizedLikelihood_strings[6] = {};

static const char PermissionPrediction_Likelihood_DiscretizedLikelihood_names[] = "DISCRETIZED_LIKELIHOOD_UNSPECIFIED"
                                                                                  "LIKELY"
                                                                                  "NEUTRAL"
                                                                                  "UNLIKELY"
                                                                                  "VERY_LIKELY"
                                                                                  "VERY_UNLIKELY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PermissionPrediction_Likelihood_DiscretizedLikelihood_entries[] = {
    { { PermissionPrediction_Likelihood_DiscretizedLikelihood_names + 0, 34 }, 0 },
    { { PermissionPrediction_Likelihood_DiscretizedLikelihood_names + 34, 6 }, 4 },
    { { PermissionPrediction_Likelihood_DiscretizedLikelihood_names + 40, 7 }, 3 },
    { { PermissionPrediction_Likelihood_DiscretizedLikelihood_names + 47, 8 }, 2 },
    { { PermissionPrediction_Likelihood_DiscretizedLikelihood_names + 55, 11 }, 5 },
    { { PermissionPrediction_Likelihood_DiscretizedLikelihood_names + 66, 13 }, 1 },
};

static const int PermissionPrediction_Likelihood_DiscretizedLikelihood_entries_by_number[] = {
    0, // 0 -> DISCRETIZED_LIKELIHOOD_UNSPECIFIED
    5, // 1 -> VERY_UNLIKELY
    3, // 2 -> UNLIKELY
    2, // 3 -> NEUTRAL
    1, // 4 -> LIKELY
    4, // 5 -> VERY_LIKELY
};

const std::string& PermissionPrediction_Likelihood_DiscretizedLikelihood_Name(PermissionPrediction_Likelihood_DiscretizedLikelihood value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(PermissionPrediction_Likelihood_DiscretizedLikelihood_entries,
        PermissionPrediction_Likelihood_DiscretizedLikelihood_entries_by_number, 6, PermissionPrediction_Likelihood_DiscretizedLikelihood_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        PermissionPrediction_Likelihood_DiscretizedLikelihood_entries, PermissionPrediction_Likelihood_DiscretizedLikelihood_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : PermissionPrediction_Likelihood_DiscretizedLikelihood_strings[idx].get();
}
bool PermissionPrediction_Likelihood_DiscretizedLikelihood_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PermissionPrediction_Likelihood_DiscretizedLikelihood* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(PermissionPrediction_Likelihood_DiscretizedLikelihood_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<PermissionPrediction_Likelihood_DiscretizedLikelihood>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::DISCRETIZED_LIKELIHOOD_UNSPECIFIED;
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::VERY_UNLIKELY;
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::UNLIKELY;
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::NEUTRAL;
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::LIKELY;
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::VERY_LIKELY;
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::DiscretizedLikelihood_MIN;
constexpr PermissionPrediction_Likelihood_DiscretizedLikelihood PermissionPrediction_Likelihood::DiscretizedLikelihood_MAX;
constexpr int PermissionPrediction_Likelihood::DiscretizedLikelihood_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class SiteFeatures::_Internal {
public:
    using HasBits = decltype(std::declval<SiteFeatures>()._impl_._has_bits_);
    static void set_has_origin(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

SiteFeatures::SiteFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.SiteFeatures)
}
SiteFeatures::SiteFeatures(const SiteFeatures& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SiteFeatures* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.origin_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.origin_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_origin()) {
        _this->_impl_.origin_.Set(from._internal_origin(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:permissions.SiteFeatures)
}

inline void SiteFeatures::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.origin_) {} };
    _impl_.origin_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SiteFeatures::~SiteFeatures()
{
    // @@protoc_insertion_point(destructor:permissions.SiteFeatures)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SiteFeatures::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.origin_.Destroy();
}

void SiteFeatures::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SiteFeatures::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.SiteFeatures)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.origin_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SiteFeatures::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string origin = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_origin();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SiteFeatures::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.SiteFeatures)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string origin = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_origin(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.SiteFeatures)
    return target;
}

size_t SiteFeatures::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.SiteFeatures)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string origin = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_origin());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SiteFeatures::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SiteFeatures*>(&from));
}

void SiteFeatures::MergeFrom(const SiteFeatures& from)
{
    SiteFeatures* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.SiteFeatures)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_origin()) {
        _this->_internal_set_origin(from._internal_origin());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SiteFeatures::CopyFrom(const SiteFeatures& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.SiteFeatures)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SiteFeatures::IsInitialized() const
{
    return true;
}

void SiteFeatures::InternalSwap(SiteFeatures* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.origin_, lhs_arena, &other->_impl_.origin_, rhs_arena);
}

std::string SiteFeatures::GetTypeName() const
{
    return "permissions.SiteFeatures";
}

// ===================================================================

class StatsFeatures::_Internal {
public:
    using HasBits = decltype(std::declval<StatsFeatures>()._impl_._has_bits_);
    static void set_has_avg_deny_rate(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_avg_grant_rate(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_avg_dismiss_rate(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_avg_ignore_rate(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_prompts_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

StatsFeatures::StatsFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.StatsFeatures)
}
StatsFeatures::StatsFeatures(const StatsFeatures& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    StatsFeatures* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.avg_deny_rate_) {},
        decltype(_impl_.avg_grant_rate_) {}, decltype(_impl_.avg_dismiss_rate_) {}, decltype(_impl_.avg_ignore_rate_) {}, decltype(_impl_.prompts_count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.avg_deny_rate_, &from._impl_.avg_deny_rate_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prompts_count_) - reinterpret_cast<char*>(&_impl_.avg_deny_rate_)) + sizeof(_impl_.prompts_count_));
    // @@protoc_insertion_point(copy_constructor:permissions.StatsFeatures)
}

inline void StatsFeatures::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.avg_deny_rate_) { 0 },
        decltype(_impl_.avg_grant_rate_) { 0 }, decltype(_impl_.avg_dismiss_rate_) { 0 }, decltype(_impl_.avg_ignore_rate_) { 0 },
        decltype(_impl_.prompts_count_) { 0 } };
}

StatsFeatures::~StatsFeatures()
{
    // @@protoc_insertion_point(destructor:permissions.StatsFeatures)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void StatsFeatures::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StatsFeatures::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void StatsFeatures::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.StatsFeatures)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        ::memset(&_impl_.avg_deny_rate_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.prompts_count_) - reinterpret_cast<char*>(&_impl_.avg_deny_rate_))
                + sizeof(_impl_.prompts_count_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* StatsFeatures::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional float avg_deny_rate = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
                _Internal::set_has_avg_deny_rate(&has_bits);
                _impl_.avg_deny_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float avg_grant_rate = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
                _Internal::set_has_avg_grant_rate(&has_bits);
                _impl_.avg_grant_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float avg_dismiss_rate = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
                _Internal::set_has_avg_dismiss_rate(&has_bits);
                _impl_.avg_dismiss_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float avg_ignore_rate = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
                _Internal::set_has_avg_ignore_rate(&has_bits);
                _impl_.avg_ignore_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional int32 prompts_count = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_prompts_count(&has_bits);
                _impl_.prompts_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* StatsFeatures::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.StatsFeatures)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional float avg_deny_rate = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_avg_deny_rate(), target);
    }

    // optional float avg_grant_rate = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_avg_grant_rate(), target);
    }

    // optional float avg_dismiss_rate = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_avg_dismiss_rate(), target);
    }

    // optional float avg_ignore_rate = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_avg_ignore_rate(), target);
    }

    // optional int32 prompts_count = 5;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_prompts_count(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.StatsFeatures)
    return target;
}

size_t StatsFeatures::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.StatsFeatures)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional float avg_deny_rate = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 4;
        }

        // optional float avg_grant_rate = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 4;
        }

        // optional float avg_dismiss_rate = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 4;
        }

        // optional float avg_ignore_rate = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 4;
        }

        // optional int32 prompts_count = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prompts_count());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void StatsFeatures::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const StatsFeatures*>(&from));
}

void StatsFeatures::MergeFrom(const StatsFeatures& from)
{
    StatsFeatures* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.StatsFeatures)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.avg_deny_rate_ = from._impl_.avg_deny_rate_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.avg_grant_rate_ = from._impl_.avg_grant_rate_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.avg_dismiss_rate_ = from._impl_.avg_dismiss_rate_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.avg_ignore_rate_ = from._impl_.avg_ignore_rate_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.prompts_count_ = from._impl_.prompts_count_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StatsFeatures::CopyFrom(const StatsFeatures& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.StatsFeatures)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool StatsFeatures::IsInitialized() const
{
    return true;
}

void StatsFeatures::InternalSwap(StatsFeatures* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(StatsFeatures, _impl_.prompts_count_) + sizeof(StatsFeatures::_impl_.prompts_count_)
        - PROTOBUF_FIELD_OFFSET(StatsFeatures, _impl_.avg_deny_rate_)>(
        reinterpret_cast<char*>(&_impl_.avg_deny_rate_), reinterpret_cast<char*>(&other->_impl_.avg_deny_rate_));
}

std::string StatsFeatures::GetTypeName() const
{
    return "permissions.StatsFeatures";
}

// ===================================================================

class ClientFeatures_ExperimentConfig::_Internal {
public:
    using HasBits = decltype(std::declval<ClientFeatures_ExperimentConfig>()._impl_._has_bits_);
    static void set_has_experiment_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ClientFeatures_ExperimentConfig::ClientFeatures_ExperimentConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.ClientFeatures.ExperimentConfig)
}
ClientFeatures_ExperimentConfig::ClientFeatures_ExperimentConfig(const ClientFeatures_ExperimentConfig& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientFeatures_ExperimentConfig* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.experiment_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.experiment_id_ = from._impl_.experiment_id_;
    // @@protoc_insertion_point(copy_constructor:permissions.ClientFeatures.ExperimentConfig)
}

inline void ClientFeatures_ExperimentConfig::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.experiment_id_) { 0 } };
}

ClientFeatures_ExperimentConfig::~ClientFeatures_ExperimentConfig()
{
    // @@protoc_insertion_point(destructor:permissions.ClientFeatures.ExperimentConfig)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientFeatures_ExperimentConfig::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientFeatures_ExperimentConfig::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientFeatures_ExperimentConfig::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.ClientFeatures.ExperimentConfig)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.experiment_id_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientFeatures_ExperimentConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 experiment_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_experiment_id(&has_bits);
                _impl_.experiment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientFeatures_ExperimentConfig::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.ClientFeatures.ExperimentConfig)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 experiment_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_experiment_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.ClientFeatures.ExperimentConfig)
    return target;
}

size_t ClientFeatures_ExperimentConfig::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.ClientFeatures.ExperimentConfig)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional int32 experiment_id = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_experiment_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientFeatures_ExperimentConfig::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientFeatures_ExperimentConfig*>(&from));
}

void ClientFeatures_ExperimentConfig::MergeFrom(const ClientFeatures_ExperimentConfig& from)
{
    ClientFeatures_ExperimentConfig* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.ClientFeatures.ExperimentConfig)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_experiment_id()) {
        _this->_internal_set_experiment_id(from._internal_experiment_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientFeatures_ExperimentConfig::CopyFrom(const ClientFeatures_ExperimentConfig& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.ClientFeatures.ExperimentConfig)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientFeatures_ExperimentConfig::IsInitialized() const
{
    return true;
}

void ClientFeatures_ExperimentConfig::InternalSwap(ClientFeatures_ExperimentConfig* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.experiment_id_, other->_impl_.experiment_id_);
}

std::string ClientFeatures_ExperimentConfig::GetTypeName() const
{
    return "permissions.ClientFeatures.ExperimentConfig";
}

// ===================================================================

class ClientFeatures::_Internal {
public:
    using HasBits = decltype(std::declval<ClientFeatures>()._impl_._has_bits_);
    static const ::permissions::StatsFeatures& client_stats(const ClientFeatures* msg);
    static void set_has_client_stats(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_platform(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_gesture(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_gesture_enum(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_platform_enum(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::permissions::ClientFeatures_ExperimentConfig& experiment_config(const ClientFeatures* msg);
    static void set_has_experiment_config(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::permissions::StatsFeatures& ClientFeatures::_Internal::client_stats(const ClientFeatures* msg)
{
    return *msg->_impl_.client_stats_;
}
const ::permissions::ClientFeatures_ExperimentConfig& ClientFeatures::_Internal::experiment_config(const ClientFeatures* msg)
{
    return *msg->_impl_.experiment_config_;
}
ClientFeatures::ClientFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.ClientFeatures)
}
ClientFeatures::ClientFeatures(const ClientFeatures& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientFeatures* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.client_stats_) { nullptr }, decltype(_impl_.experiment_config_) { nullptr }, decltype(_impl_.platform_) {},
        decltype(_impl_.gesture_) {}, decltype(_impl_.gesture_enum_) {}, decltype(_impl_.platform_enum_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_client_stats()) {
        _this->_impl_.client_stats_ = new ::permissions::StatsFeatures(*from._impl_.client_stats_);
    }
    if (from._internal_has_experiment_config()) {
        _this->_impl_.experiment_config_ = new ::permissions::ClientFeatures_ExperimentConfig(*from._impl_.experiment_config_);
    }
    ::memcpy(&_impl_.platform_, &from._impl_.platform_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.platform_enum_) - reinterpret_cast<char*>(&_impl_.platform_)) + sizeof(_impl_.platform_enum_));
    // @@protoc_insertion_point(copy_constructor:permissions.ClientFeatures)
}

inline void ClientFeatures::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.client_stats_) { nullptr },
        decltype(_impl_.experiment_config_) { nullptr }, decltype(_impl_.platform_) { 0 }, decltype(_impl_.gesture_) { 0 },
        decltype(_impl_.gesture_enum_) { 0 }, decltype(_impl_.platform_enum_) { 0 } };
}

ClientFeatures::~ClientFeatures()
{
    // @@protoc_insertion_point(destructor:permissions.ClientFeatures)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientFeatures::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.client_stats_;
    if (this != internal_default_instance())
        delete _impl_.experiment_config_;
}

void ClientFeatures::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientFeatures::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.ClientFeatures)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.client_stats_ != nullptr);
            _impl_.client_stats_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.experiment_config_ != nullptr);
            _impl_.experiment_config_->Clear();
        }
    }
    if (cached_has_bits & 0x0000003cu) {
        ::memset(&_impl_.platform_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.platform_enum_) - reinterpret_cast<char*>(&_impl_.platform_)) + sizeof(_impl_.platform_enum_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientFeatures::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .permissions.StatsFeatures client_stats = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_client_stats(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .permissions.ClientFeatures.Platform platform = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::permissions::ClientFeatures_Platform_IsValid(val))) {
                    _internal_set_platform(static_cast<::permissions::ClientFeatures_Platform>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .permissions.ClientFeatures.Gesture gesture = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::permissions::ClientFeatures_Gesture_IsValid(val))) {
                    _internal_set_gesture(static_cast<::permissions::ClientFeatures_Gesture>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .permissions.ClientFeatures.GestureEnum gesture_enum = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::permissions::ClientFeatures_GestureEnum_IsValid(val))) {
                    _internal_set_gesture_enum(static_cast<::permissions::ClientFeatures_GestureEnum>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .permissions.ClientFeatures.PlatformEnum platform_enum = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::permissions::ClientFeatures_PlatformEnum_IsValid(val))) {
                    _internal_set_platform_enum(static_cast<::permissions::ClientFeatures_PlatformEnum>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .permissions.ClientFeatures.ExperimentConfig experiment_config = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_experiment_config(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientFeatures::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.ClientFeatures)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .permissions.StatsFeatures client_stats = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::client_stats(this), _Internal::client_stats(this).GetCachedSize(), target, stream);
    }

    // optional .permissions.ClientFeatures.Platform platform = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_platform(), target);
    }

    // optional .permissions.ClientFeatures.Gesture gesture = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_gesture(), target);
    }

    // optional .permissions.ClientFeatures.GestureEnum gesture_enum = 4;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_gesture_enum(), target);
    }

    // optional .permissions.ClientFeatures.PlatformEnum platform_enum = 5;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_platform_enum(), target);
    }

    // optional .permissions.ClientFeatures.ExperimentConfig experiment_config = 6;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::experiment_config(this), _Internal::experiment_config(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.ClientFeatures)
    return target;
}

size_t ClientFeatures::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.ClientFeatures)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional .permissions.StatsFeatures client_stats = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.client_stats_);
        }

        // optional .permissions.ClientFeatures.ExperimentConfig experiment_config = 6;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.experiment_config_);
        }

        // optional .permissions.ClientFeatures.Platform platform = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_platform());
        }

        // optional .permissions.ClientFeatures.Gesture gesture = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_gesture());
        }

        // optional .permissions.ClientFeatures.GestureEnum gesture_enum = 4;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_gesture_enum());
        }

        // optional .permissions.ClientFeatures.PlatformEnum platform_enum = 5;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_platform_enum());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientFeatures::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientFeatures*>(&from));
}

void ClientFeatures::MergeFrom(const ClientFeatures& from)
{
    ClientFeatures* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.ClientFeatures)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_client_stats()->::permissions::StatsFeatures::MergeFrom(from._internal_client_stats());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_experiment_config()->::permissions::ClientFeatures_ExperimentConfig::MergeFrom(from._internal_experiment_config());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.platform_ = from._impl_.platform_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.gesture_ = from._impl_.gesture_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.gesture_enum_ = from._impl_.gesture_enum_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.platform_enum_ = from._impl_.platform_enum_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientFeatures::CopyFrom(const ClientFeatures& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.ClientFeatures)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientFeatures::IsInitialized() const
{
    return true;
}

void ClientFeatures::InternalSwap(ClientFeatures* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientFeatures, _impl_.platform_enum_) + sizeof(ClientFeatures::_impl_.platform_enum_)
        - PROTOBUF_FIELD_OFFSET(ClientFeatures, _impl_.client_stats_)>(
        reinterpret_cast<char*>(&_impl_.client_stats_), reinterpret_cast<char*>(&other->_impl_.client_stats_));
}

std::string ClientFeatures::GetTypeName() const
{
    return "permissions.ClientFeatures";
}

// ===================================================================

class PermissionFeatures_NotificationPermission::_Internal {
public:
};

PermissionFeatures_NotificationPermission::PermissionFeatures_NotificationPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.PermissionFeatures.NotificationPermission)
}
PermissionFeatures_NotificationPermission::PermissionFeatures_NotificationPermission(const PermissionFeatures_NotificationPermission& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PermissionFeatures_NotificationPermission* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:permissions.PermissionFeatures.NotificationPermission)
}

inline void PermissionFeatures_NotificationPermission::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

PermissionFeatures_NotificationPermission::~PermissionFeatures_NotificationPermission()
{
    // @@protoc_insertion_point(destructor:permissions.PermissionFeatures.NotificationPermission)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PermissionFeatures_NotificationPermission::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PermissionFeatures_NotificationPermission::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PermissionFeatures_NotificationPermission::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.PermissionFeatures.NotificationPermission)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* PermissionFeatures_NotificationPermission::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PermissionFeatures_NotificationPermission::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.PermissionFeatures.NotificationPermission)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.PermissionFeatures.NotificationPermission)
    return target;
}

size_t PermissionFeatures_NotificationPermission::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.PermissionFeatures.NotificationPermission)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PermissionFeatures_NotificationPermission::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PermissionFeatures_NotificationPermission*>(&from));
}

void PermissionFeatures_NotificationPermission::MergeFrom(const PermissionFeatures_NotificationPermission& from)
{
    PermissionFeatures_NotificationPermission* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.PermissionFeatures.NotificationPermission)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionFeatures_NotificationPermission::CopyFrom(const PermissionFeatures_NotificationPermission& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.PermissionFeatures.NotificationPermission)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PermissionFeatures_NotificationPermission::IsInitialized() const
{
    return true;
}

void PermissionFeatures_NotificationPermission::InternalSwap(PermissionFeatures_NotificationPermission* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string PermissionFeatures_NotificationPermission::GetTypeName() const
{
    return "permissions.PermissionFeatures.NotificationPermission";
}

// ===================================================================

class PermissionFeatures_GeolocationPermission::_Internal {
public:
};

PermissionFeatures_GeolocationPermission::PermissionFeatures_GeolocationPermission(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.PermissionFeatures.GeolocationPermission)
}
PermissionFeatures_GeolocationPermission::PermissionFeatures_GeolocationPermission(const PermissionFeatures_GeolocationPermission& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PermissionFeatures_GeolocationPermission* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:permissions.PermissionFeatures.GeolocationPermission)
}

inline void PermissionFeatures_GeolocationPermission::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

PermissionFeatures_GeolocationPermission::~PermissionFeatures_GeolocationPermission()
{
    // @@protoc_insertion_point(destructor:permissions.PermissionFeatures.GeolocationPermission)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PermissionFeatures_GeolocationPermission::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PermissionFeatures_GeolocationPermission::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PermissionFeatures_GeolocationPermission::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.PermissionFeatures.GeolocationPermission)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* PermissionFeatures_GeolocationPermission::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PermissionFeatures_GeolocationPermission::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.PermissionFeatures.GeolocationPermission)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.PermissionFeatures.GeolocationPermission)
    return target;
}

size_t PermissionFeatures_GeolocationPermission::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.PermissionFeatures.GeolocationPermission)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PermissionFeatures_GeolocationPermission::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PermissionFeatures_GeolocationPermission*>(&from));
}

void PermissionFeatures_GeolocationPermission::MergeFrom(const PermissionFeatures_GeolocationPermission& from)
{
    PermissionFeatures_GeolocationPermission* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.PermissionFeatures.GeolocationPermission)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionFeatures_GeolocationPermission::CopyFrom(const PermissionFeatures_GeolocationPermission& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.PermissionFeatures.GeolocationPermission)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PermissionFeatures_GeolocationPermission::IsInitialized() const
{
    return true;
}

void PermissionFeatures_GeolocationPermission::InternalSwap(PermissionFeatures_GeolocationPermission* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string PermissionFeatures_GeolocationPermission::GetTypeName() const
{
    return "permissions.PermissionFeatures.GeolocationPermission";
}

// ===================================================================

class PermissionFeatures::_Internal {
public:
    using HasBits = decltype(std::declval<PermissionFeatures>()._impl_._has_bits_);
    static const ::permissions::StatsFeatures& permission_stats(const PermissionFeatures* msg);
    static void set_has_permission_stats(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::permissions::PermissionFeatures_NotificationPermission& notification_permission(const PermissionFeatures* msg);
    static const ::permissions::PermissionFeatures_GeolocationPermission& geolocation_permission(const PermissionFeatures* msg);
};

const ::permissions::StatsFeatures& PermissionFeatures::_Internal::permission_stats(const PermissionFeatures* msg)
{
    return *msg->_impl_.permission_stats_;
}
const ::permissions::PermissionFeatures_NotificationPermission& PermissionFeatures::_Internal::notification_permission(const PermissionFeatures* msg)
{
    return *msg->_impl_.permission_type_.notification_permission_;
}
const ::permissions::PermissionFeatures_GeolocationPermission& PermissionFeatures::_Internal::geolocation_permission(const PermissionFeatures* msg)
{
    return *msg->_impl_.permission_type_.geolocation_permission_;
}
void PermissionFeatures::set_allocated_notification_permission(::permissions::PermissionFeatures_NotificationPermission* notification_permission)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_permission_type();
    if (notification_permission) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(notification_permission);
        if (message_arena != submessage_arena) {
            notification_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, notification_permission, submessage_arena);
        }
        set_has_notification_permission();
        _impl_.permission_type_.notification_permission_ = notification_permission;
    }
    // @@protoc_insertion_point(field_set_allocated:permissions.PermissionFeatures.notification_permission)
}
void PermissionFeatures::set_allocated_geolocation_permission(::permissions::PermissionFeatures_GeolocationPermission* geolocation_permission)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_permission_type();
    if (geolocation_permission) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geolocation_permission);
        if (message_arena != submessage_arena) {
            geolocation_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, geolocation_permission, submessage_arena);
        }
        set_has_geolocation_permission();
        _impl_.permission_type_.geolocation_permission_ = geolocation_permission;
    }
    // @@protoc_insertion_point(field_set_allocated:permissions.PermissionFeatures.geolocation_permission)
}
PermissionFeatures::PermissionFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.PermissionFeatures)
}
PermissionFeatures::PermissionFeatures(const PermissionFeatures& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PermissionFeatures* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.permission_stats_) { nullptr }, decltype(_impl_.permission_type_) {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_permission_stats()) {
        _this->_impl_.permission_stats_ = new ::permissions::StatsFeatures(*from._impl_.permission_stats_);
    }
    clear_has_permission_type();
    switch (from.permission_type_case()) {
    case kNotificationPermission: {
        _this->_internal_mutable_notification_permission()->::permissions::PermissionFeatures_NotificationPermission::MergeFrom(
            from._internal_notification_permission());
        break;
    }
    case kGeolocationPermission: {
        _this->_internal_mutable_geolocation_permission()->::permissions::PermissionFeatures_GeolocationPermission::MergeFrom(
            from._internal_geolocation_permission());
        break;
    }
    case PERMISSION_TYPE_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:permissions.PermissionFeatures)
}

inline void PermissionFeatures::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.permission_stats_) { nullptr },
        decltype(_impl_.permission_type_) {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_permission_type();
}

PermissionFeatures::~PermissionFeatures()
{
    // @@protoc_insertion_point(destructor:permissions.PermissionFeatures)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PermissionFeatures::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.permission_stats_;
    if (has_permission_type()) {
        clear_permission_type();
    }
}

void PermissionFeatures::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PermissionFeatures::clear_permission_type()
{
    // @@protoc_insertion_point(one_of_clear_start:permissions.PermissionFeatures)
    switch (permission_type_case()) {
    case kNotificationPermission: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.permission_type_.notification_permission_;
        }
        break;
    }
    case kGeolocationPermission: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.permission_type_.geolocation_permission_;
        }
        break;
    }
    case PERMISSION_TYPE_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = PERMISSION_TYPE_NOT_SET;
}

void PermissionFeatures::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.PermissionFeatures)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.permission_stats_ != nullptr);
        _impl_.permission_stats_->Clear();
    }
    clear_permission_type();
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PermissionFeatures::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .permissions.StatsFeatures permission_stats = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_permission_stats(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .permissions.PermissionFeatures.NotificationPermission notification_permission = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_notification_permission(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .permissions.PermissionFeatures.GeolocationPermission geolocation_permission = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_geolocation_permission(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PermissionFeatures::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.PermissionFeatures)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .permissions.StatsFeatures permission_stats = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::permission_stats(this), _Internal::permission_stats(this).GetCachedSize(), target, stream);
    }

    switch (permission_type_case()) {
    case kNotificationPermission: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::notification_permission(this), _Internal::notification_permission(this).GetCachedSize(), target, stream);
        break;
    }
    case kGeolocationPermission: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::geolocation_permission(this), _Internal::geolocation_permission(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.PermissionFeatures)
    return target;
}

size_t PermissionFeatures::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.PermissionFeatures)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .permissions.StatsFeatures permission_stats = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.permission_stats_);
    }

    switch (permission_type_case()) {
    // .permissions.PermissionFeatures.NotificationPermission notification_permission = 2;
    case kNotificationPermission: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.permission_type_.notification_permission_);
        break;
    }
    // .permissions.PermissionFeatures.GeolocationPermission geolocation_permission = 3;
    case kGeolocationPermission: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.permission_type_.geolocation_permission_);
        break;
    }
    case PERMISSION_TYPE_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PermissionFeatures::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PermissionFeatures*>(&from));
}

void PermissionFeatures::MergeFrom(const PermissionFeatures& from)
{
    PermissionFeatures* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.PermissionFeatures)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_permission_stats()) {
        _this->_internal_mutable_permission_stats()->::permissions::StatsFeatures::MergeFrom(from._internal_permission_stats());
    }
    switch (from.permission_type_case()) {
    case kNotificationPermission: {
        _this->_internal_mutable_notification_permission()->::permissions::PermissionFeatures_NotificationPermission::MergeFrom(
            from._internal_notification_permission());
        break;
    }
    case kGeolocationPermission: {
        _this->_internal_mutable_geolocation_permission()->::permissions::PermissionFeatures_GeolocationPermission::MergeFrom(
            from._internal_geolocation_permission());
        break;
    }
    case PERMISSION_TYPE_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionFeatures::CopyFrom(const PermissionFeatures& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.PermissionFeatures)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PermissionFeatures::IsInitialized() const
{
    return true;
}

void PermissionFeatures::InternalSwap(PermissionFeatures* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.permission_stats_, other->_impl_.permission_stats_);
    swap(_impl_.permission_type_, other->_impl_.permission_type_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string PermissionFeatures::GetTypeName() const
{
    return "permissions.PermissionFeatures";
}

// ===================================================================

class PermissionPrediction_NotificationPrediction::_Internal {
public:
};

PermissionPrediction_NotificationPrediction::PermissionPrediction_NotificationPrediction(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.PermissionPrediction.NotificationPrediction)
}
PermissionPrediction_NotificationPrediction::PermissionPrediction_NotificationPrediction(const PermissionPrediction_NotificationPrediction& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PermissionPrediction_NotificationPrediction* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:permissions.PermissionPrediction.NotificationPrediction)
}

inline void PermissionPrediction_NotificationPrediction::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

PermissionPrediction_NotificationPrediction::~PermissionPrediction_NotificationPrediction()
{
    // @@protoc_insertion_point(destructor:permissions.PermissionPrediction.NotificationPrediction)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PermissionPrediction_NotificationPrediction::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PermissionPrediction_NotificationPrediction::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PermissionPrediction_NotificationPrediction::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.PermissionPrediction.NotificationPrediction)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* PermissionPrediction_NotificationPrediction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PermissionPrediction_NotificationPrediction::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.PermissionPrediction.NotificationPrediction)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.PermissionPrediction.NotificationPrediction)
    return target;
}

size_t PermissionPrediction_NotificationPrediction::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.PermissionPrediction.NotificationPrediction)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PermissionPrediction_NotificationPrediction::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PermissionPrediction_NotificationPrediction*>(&from));
}

void PermissionPrediction_NotificationPrediction::MergeFrom(const PermissionPrediction_NotificationPrediction& from)
{
    PermissionPrediction_NotificationPrediction* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.PermissionPrediction.NotificationPrediction)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionPrediction_NotificationPrediction::CopyFrom(const PermissionPrediction_NotificationPrediction& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.PermissionPrediction.NotificationPrediction)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PermissionPrediction_NotificationPrediction::IsInitialized() const
{
    return true;
}

void PermissionPrediction_NotificationPrediction::InternalSwap(PermissionPrediction_NotificationPrediction* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string PermissionPrediction_NotificationPrediction::GetTypeName() const
{
    return "permissions.PermissionPrediction.NotificationPrediction";
}

// ===================================================================

class PermissionPrediction_GeolocationPrediction::_Internal {
public:
};

PermissionPrediction_GeolocationPrediction::PermissionPrediction_GeolocationPrediction(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.PermissionPrediction.GeolocationPrediction)
}
PermissionPrediction_GeolocationPrediction::PermissionPrediction_GeolocationPrediction(const PermissionPrediction_GeolocationPrediction& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PermissionPrediction_GeolocationPrediction* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:permissions.PermissionPrediction.GeolocationPrediction)
}

inline void PermissionPrediction_GeolocationPrediction::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

PermissionPrediction_GeolocationPrediction::~PermissionPrediction_GeolocationPrediction()
{
    // @@protoc_insertion_point(destructor:permissions.PermissionPrediction.GeolocationPrediction)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PermissionPrediction_GeolocationPrediction::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PermissionPrediction_GeolocationPrediction::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PermissionPrediction_GeolocationPrediction::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.PermissionPrediction.GeolocationPrediction)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* PermissionPrediction_GeolocationPrediction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PermissionPrediction_GeolocationPrediction::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.PermissionPrediction.GeolocationPrediction)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.PermissionPrediction.GeolocationPrediction)
    return target;
}

size_t PermissionPrediction_GeolocationPrediction::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.PermissionPrediction.GeolocationPrediction)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PermissionPrediction_GeolocationPrediction::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PermissionPrediction_GeolocationPrediction*>(&from));
}

void PermissionPrediction_GeolocationPrediction::MergeFrom(const PermissionPrediction_GeolocationPrediction& from)
{
    PermissionPrediction_GeolocationPrediction* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.PermissionPrediction.GeolocationPrediction)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionPrediction_GeolocationPrediction::CopyFrom(const PermissionPrediction_GeolocationPrediction& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.PermissionPrediction.GeolocationPrediction)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PermissionPrediction_GeolocationPrediction::IsInitialized() const
{
    return true;
}

void PermissionPrediction_GeolocationPrediction::InternalSwap(PermissionPrediction_GeolocationPrediction* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string PermissionPrediction_GeolocationPrediction::GetTypeName() const
{
    return "permissions.PermissionPrediction.GeolocationPrediction";
}

// ===================================================================

class PermissionPrediction_Likelihood::_Internal {
public:
    using HasBits = decltype(std::declval<PermissionPrediction_Likelihood>()._impl_._has_bits_);
    static void set_has_discretized_likelihood(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

PermissionPrediction_Likelihood::PermissionPrediction_Likelihood(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.PermissionPrediction.Likelihood)
}
PermissionPrediction_Likelihood::PermissionPrediction_Likelihood(const PermissionPrediction_Likelihood& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PermissionPrediction_Likelihood* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.discretized_likelihood_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.discretized_likelihood_ = from._impl_.discretized_likelihood_;
    // @@protoc_insertion_point(copy_constructor:permissions.PermissionPrediction.Likelihood)
}

inline void PermissionPrediction_Likelihood::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.discretized_likelihood_) { 0 } };
}

PermissionPrediction_Likelihood::~PermissionPrediction_Likelihood()
{
    // @@protoc_insertion_point(destructor:permissions.PermissionPrediction.Likelihood)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PermissionPrediction_Likelihood::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PermissionPrediction_Likelihood::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PermissionPrediction_Likelihood::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.PermissionPrediction.Likelihood)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.discretized_likelihood_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PermissionPrediction_Likelihood::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .permissions.PermissionPrediction.Likelihood.DiscretizedLikelihood discretized_likelihood = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::permissions::PermissionPrediction_Likelihood_DiscretizedLikelihood_IsValid(val))) {
                    _internal_set_discretized_likelihood(static_cast<::permissions::PermissionPrediction_Likelihood_DiscretizedLikelihood>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PermissionPrediction_Likelihood::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.PermissionPrediction.Likelihood)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .permissions.PermissionPrediction.Likelihood.DiscretizedLikelihood discretized_likelihood = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_discretized_likelihood(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.PermissionPrediction.Likelihood)
    return target;
}

size_t PermissionPrediction_Likelihood::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.PermissionPrediction.Likelihood)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .permissions.PermissionPrediction.Likelihood.DiscretizedLikelihood discretized_likelihood = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_discretized_likelihood());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PermissionPrediction_Likelihood::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PermissionPrediction_Likelihood*>(&from));
}

void PermissionPrediction_Likelihood::MergeFrom(const PermissionPrediction_Likelihood& from)
{
    PermissionPrediction_Likelihood* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.PermissionPrediction.Likelihood)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_discretized_likelihood()) {
        _this->_internal_set_discretized_likelihood(from._internal_discretized_likelihood());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionPrediction_Likelihood::CopyFrom(const PermissionPrediction_Likelihood& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.PermissionPrediction.Likelihood)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PermissionPrediction_Likelihood::IsInitialized() const
{
    return true;
}

void PermissionPrediction_Likelihood::InternalSwap(PermissionPrediction_Likelihood* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.discretized_likelihood_, other->_impl_.discretized_likelihood_);
}

std::string PermissionPrediction_Likelihood::GetTypeName() const
{
    return "permissions.PermissionPrediction.Likelihood";
}

// ===================================================================

class PermissionPrediction::_Internal {
public:
    using HasBits = decltype(std::declval<PermissionPrediction>()._impl_._has_bits_);
    static const ::permissions::PermissionPrediction_NotificationPrediction& notification_prediction(const PermissionPrediction* msg);
    static const ::permissions::PermissionPrediction_GeolocationPrediction& geolocation_prediction(const PermissionPrediction* msg);
    static const ::permissions::PermissionPrediction_Likelihood& grant_likelihood(const PermissionPrediction* msg);
    static void set_has_grant_likelihood(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::permissions::PermissionPrediction_NotificationPrediction& PermissionPrediction::_Internal::notification_prediction(const PermissionPrediction* msg)
{
    return *msg->_impl_.prediction_type_.notification_prediction_;
}
const ::permissions::PermissionPrediction_GeolocationPrediction& PermissionPrediction::_Internal::geolocation_prediction(const PermissionPrediction* msg)
{
    return *msg->_impl_.prediction_type_.geolocation_prediction_;
}
const ::permissions::PermissionPrediction_Likelihood& PermissionPrediction::_Internal::grant_likelihood(const PermissionPrediction* msg)
{
    return *msg->_impl_.grant_likelihood_;
}
void PermissionPrediction::set_allocated_notification_prediction(::permissions::PermissionPrediction_NotificationPrediction* notification_prediction)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_prediction_type();
    if (notification_prediction) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(notification_prediction);
        if (message_arena != submessage_arena) {
            notification_prediction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, notification_prediction, submessage_arena);
        }
        set_has_notification_prediction();
        _impl_.prediction_type_.notification_prediction_ = notification_prediction;
    }
    // @@protoc_insertion_point(field_set_allocated:permissions.PermissionPrediction.notification_prediction)
}
void PermissionPrediction::set_allocated_geolocation_prediction(::permissions::PermissionPrediction_GeolocationPrediction* geolocation_prediction)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_prediction_type();
    if (geolocation_prediction) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(geolocation_prediction);
        if (message_arena != submessage_arena) {
            geolocation_prediction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, geolocation_prediction, submessage_arena);
        }
        set_has_geolocation_prediction();
        _impl_.prediction_type_.geolocation_prediction_ = geolocation_prediction;
    }
    // @@protoc_insertion_point(field_set_allocated:permissions.PermissionPrediction.geolocation_prediction)
}
PermissionPrediction::PermissionPrediction(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.PermissionPrediction)
}
PermissionPrediction::PermissionPrediction(const PermissionPrediction& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PermissionPrediction* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.grant_likelihood_) { nullptr }, decltype(_impl_.prediction_type_) {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_grant_likelihood()) {
        _this->_impl_.grant_likelihood_ = new ::permissions::PermissionPrediction_Likelihood(*from._impl_.grant_likelihood_);
    }
    clear_has_prediction_type();
    switch (from.prediction_type_case()) {
    case kNotificationPrediction: {
        _this->_internal_mutable_notification_prediction()->::permissions::PermissionPrediction_NotificationPrediction::MergeFrom(
            from._internal_notification_prediction());
        break;
    }
    case kGeolocationPrediction: {
        _this->_internal_mutable_geolocation_prediction()->::permissions::PermissionPrediction_GeolocationPrediction::MergeFrom(
            from._internal_geolocation_prediction());
        break;
    }
    case PREDICTION_TYPE_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:permissions.PermissionPrediction)
}

inline void PermissionPrediction::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.grant_likelihood_) { nullptr },
        decltype(_impl_.prediction_type_) {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_prediction_type();
}

PermissionPrediction::~PermissionPrediction()
{
    // @@protoc_insertion_point(destructor:permissions.PermissionPrediction)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PermissionPrediction::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.grant_likelihood_;
    if (has_prediction_type()) {
        clear_prediction_type();
    }
}

void PermissionPrediction::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PermissionPrediction::clear_prediction_type()
{
    // @@protoc_insertion_point(one_of_clear_start:permissions.PermissionPrediction)
    switch (prediction_type_case()) {
    case kNotificationPrediction: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.prediction_type_.notification_prediction_;
        }
        break;
    }
    case kGeolocationPrediction: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.prediction_type_.geolocation_prediction_;
        }
        break;
    }
    case PREDICTION_TYPE_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = PREDICTION_TYPE_NOT_SET;
}

void PermissionPrediction::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.PermissionPrediction)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.grant_likelihood_ != nullptr);
        _impl_.grant_likelihood_->Clear();
    }
    clear_prediction_type();
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PermissionPrediction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .permissions.PermissionPrediction.NotificationPrediction notification_prediction = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_notification_prediction(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .permissions.PermissionPrediction.Likelihood grant_likelihood = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_grant_likelihood(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .permissions.PermissionPrediction.GeolocationPrediction geolocation_prediction = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_geolocation_prediction(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PermissionPrediction::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.PermissionPrediction)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .permissions.PermissionPrediction.NotificationPrediction notification_prediction = 1;
    if (_internal_has_notification_prediction()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::notification_prediction(this), _Internal::notification_prediction(this).GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .permissions.PermissionPrediction.Likelihood grant_likelihood = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::grant_likelihood(this), _Internal::grant_likelihood(this).GetCachedSize(), target, stream);
    }

    // .permissions.PermissionPrediction.GeolocationPrediction geolocation_prediction = 3;
    if (_internal_has_geolocation_prediction()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::geolocation_prediction(this), _Internal::geolocation_prediction(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.PermissionPrediction)
    return target;
}

size_t PermissionPrediction::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.PermissionPrediction)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .permissions.PermissionPrediction.Likelihood grant_likelihood = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.grant_likelihood_);
    }

    switch (prediction_type_case()) {
    // .permissions.PermissionPrediction.NotificationPrediction notification_prediction = 1;
    case kNotificationPrediction: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.prediction_type_.notification_prediction_);
        break;
    }
    // .permissions.PermissionPrediction.GeolocationPrediction geolocation_prediction = 3;
    case kGeolocationPrediction: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.prediction_type_.geolocation_prediction_);
        break;
    }
    case PREDICTION_TYPE_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PermissionPrediction::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PermissionPrediction*>(&from));
}

void PermissionPrediction::MergeFrom(const PermissionPrediction& from)
{
    PermissionPrediction* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.PermissionPrediction)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_grant_likelihood()) {
        _this->_internal_mutable_grant_likelihood()->::permissions::PermissionPrediction_Likelihood::MergeFrom(from._internal_grant_likelihood());
    }
    switch (from.prediction_type_case()) {
    case kNotificationPrediction: {
        _this->_internal_mutable_notification_prediction()->::permissions::PermissionPrediction_NotificationPrediction::MergeFrom(
            from._internal_notification_prediction());
        break;
    }
    case kGeolocationPrediction: {
        _this->_internal_mutable_geolocation_prediction()->::permissions::PermissionPrediction_GeolocationPrediction::MergeFrom(
            from._internal_geolocation_prediction());
        break;
    }
    case PREDICTION_TYPE_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PermissionPrediction::CopyFrom(const PermissionPrediction& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.PermissionPrediction)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PermissionPrediction::IsInitialized() const
{
    return true;
}

void PermissionPrediction::InternalSwap(PermissionPrediction* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.grant_likelihood_, other->_impl_.grant_likelihood_);
    swap(_impl_.prediction_type_, other->_impl_.prediction_type_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string PermissionPrediction::GetTypeName() const
{
    return "permissions.PermissionPrediction";
}

// ===================================================================

class GeneratePredictionsRequest::_Internal {
public:
    using HasBits = decltype(std::declval<GeneratePredictionsRequest>()._impl_._has_bits_);
    static const ::permissions::ClientFeatures& client_features(const GeneratePredictionsRequest* msg);
    static void set_has_client_features(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::permissions::SiteFeatures& site_features(const GeneratePredictionsRequest* msg);
    static void set_has_site_features(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::permissions::ClientFeatures& GeneratePredictionsRequest::_Internal::client_features(const GeneratePredictionsRequest* msg)
{
    return *msg->_impl_.client_features_;
}
const ::permissions::SiteFeatures& GeneratePredictionsRequest::_Internal::site_features(const GeneratePredictionsRequest* msg)
{
    return *msg->_impl_.site_features_;
}
GeneratePredictionsRequest::GeneratePredictionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.GeneratePredictionsRequest)
}
GeneratePredictionsRequest::GeneratePredictionsRequest(const GeneratePredictionsRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GeneratePredictionsRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.permission_features_) { from._impl_.permission_features_ }, decltype(_impl_.client_features_) { nullptr },
        decltype(_impl_.site_features_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_client_features()) {
        _this->_impl_.client_features_ = new ::permissions::ClientFeatures(*from._impl_.client_features_);
    }
    if (from._internal_has_site_features()) {
        _this->_impl_.site_features_ = new ::permissions::SiteFeatures(*from._impl_.site_features_);
    }
    // @@protoc_insertion_point(copy_constructor:permissions.GeneratePredictionsRequest)
}

inline void GeneratePredictionsRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.permission_features_) { arena },
        decltype(_impl_.client_features_) { nullptr }, decltype(_impl_.site_features_) { nullptr } };
}

GeneratePredictionsRequest::~GeneratePredictionsRequest()
{
    // @@protoc_insertion_point(destructor:permissions.GeneratePredictionsRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GeneratePredictionsRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.permission_features_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.client_features_;
    if (this != internal_default_instance())
        delete _impl_.site_features_;
}

void GeneratePredictionsRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GeneratePredictionsRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.GeneratePredictionsRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.permission_features_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.client_features_ != nullptr);
            _impl_.client_features_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.site_features_ != nullptr);
            _impl_.site_features_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* GeneratePredictionsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .permissions.ClientFeatures client_features = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_client_features(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .permissions.SiteFeatures site_features = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_site_features(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .permissions.PermissionFeatures permission_features = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_permission_features(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GeneratePredictionsRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.GeneratePredictionsRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .permissions.ClientFeatures client_features = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::client_features(this), _Internal::client_features(this).GetCachedSize(), target, stream);
    }

    // optional .permissions.SiteFeatures site_features = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::site_features(this), _Internal::site_features(this).GetCachedSize(), target, stream);
    }

    // repeated .permissions.PermissionFeatures permission_features = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_permission_features_size()); i < n; i++) {
        const auto& repfield = this->_internal_permission_features(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.GeneratePredictionsRequest)
    return target;
}

size_t GeneratePredictionsRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.GeneratePredictionsRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .permissions.PermissionFeatures permission_features = 3;
    total_size += 1UL * this->_internal_permission_features_size();
    for (const auto& msg : this->_impl_.permission_features_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .permissions.ClientFeatures client_features = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.client_features_);
        }

        // optional .permissions.SiteFeatures site_features = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.site_features_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GeneratePredictionsRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GeneratePredictionsRequest*>(&from));
}

void GeneratePredictionsRequest::MergeFrom(const GeneratePredictionsRequest& from)
{
    GeneratePredictionsRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.GeneratePredictionsRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.permission_features_.MergeFrom(from._impl_.permission_features_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_client_features()->::permissions::ClientFeatures::MergeFrom(from._internal_client_features());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_site_features()->::permissions::SiteFeatures::MergeFrom(from._internal_site_features());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GeneratePredictionsRequest::CopyFrom(const GeneratePredictionsRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.GeneratePredictionsRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GeneratePredictionsRequest::IsInitialized() const
{
    return true;
}

void GeneratePredictionsRequest::InternalSwap(GeneratePredictionsRequest* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.permission_features_.InternalSwap(&other->_impl_.permission_features_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(GeneratePredictionsRequest, _impl_.site_features_)
        + sizeof(GeneratePredictionsRequest::_impl_.site_features_) - PROTOBUF_FIELD_OFFSET(GeneratePredictionsRequest, _impl_.client_features_)>(
        reinterpret_cast<char*>(&_impl_.client_features_), reinterpret_cast<char*>(&other->_impl_.client_features_));
}

std::string GeneratePredictionsRequest::GetTypeName() const
{
    return "permissions.GeneratePredictionsRequest";
}

// ===================================================================

class GeneratePredictionsResponse::_Internal {
public:
};

GeneratePredictionsResponse::GeneratePredictionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:permissions.GeneratePredictionsResponse)
}
GeneratePredictionsResponse::GeneratePredictionsResponse(const GeneratePredictionsResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GeneratePredictionsResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.prediction_) { from._impl_.prediction_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:permissions.GeneratePredictionsResponse)
}

inline void GeneratePredictionsResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.prediction_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

GeneratePredictionsResponse::~GeneratePredictionsResponse()
{
    // @@protoc_insertion_point(destructor:permissions.GeneratePredictionsResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GeneratePredictionsResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.prediction_.~RepeatedPtrField();
}

void GeneratePredictionsResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GeneratePredictionsResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:permissions.GeneratePredictionsResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.prediction_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* GeneratePredictionsResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .permissions.PermissionPrediction prediction = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_prediction(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GeneratePredictionsResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:permissions.GeneratePredictionsResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .permissions.PermissionPrediction prediction = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_prediction_size()); i < n; i++) {
        const auto& repfield = this->_internal_prediction(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:permissions.GeneratePredictionsResponse)
    return target;
}

size_t GeneratePredictionsResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:permissions.GeneratePredictionsResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .permissions.PermissionPrediction prediction = 1;
    total_size += 1UL * this->_internal_prediction_size();
    for (const auto& msg : this->_impl_.prediction_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GeneratePredictionsResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GeneratePredictionsResponse*>(&from));
}

void GeneratePredictionsResponse::MergeFrom(const GeneratePredictionsResponse& from)
{
    GeneratePredictionsResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:permissions.GeneratePredictionsResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.prediction_.MergeFrom(from._impl_.prediction_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GeneratePredictionsResponse::CopyFrom(const GeneratePredictionsResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:permissions.GeneratePredictionsResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GeneratePredictionsResponse::IsInitialized() const
{
    return true;
}

void GeneratePredictionsResponse::InternalSwap(GeneratePredictionsResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.prediction_.InternalSwap(&other->_impl_.prediction_);
}

std::string GeneratePredictionsResponse::GetTypeName() const
{
    return "permissions.GeneratePredictionsResponse";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace permissions
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::permissions::SiteFeatures* Arena::CreateMaybeMessage<::permissions::SiteFeatures>(Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::SiteFeatures>(arena);
}
template <> PROTOBUF_NOINLINE ::permissions::StatsFeatures* Arena::CreateMaybeMessage<::permissions::StatsFeatures>(Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::StatsFeatures>(arena);
}
template <>
PROTOBUF_NOINLINE ::permissions::ClientFeatures_ExperimentConfig* Arena::CreateMaybeMessage<::permissions::ClientFeatures_ExperimentConfig>(Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::ClientFeatures_ExperimentConfig>(arena);
}
template <> PROTOBUF_NOINLINE ::permissions::ClientFeatures* Arena::CreateMaybeMessage<::permissions::ClientFeatures>(Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::ClientFeatures>(arena);
}
template <>
PROTOBUF_NOINLINE ::permissions::PermissionFeatures_NotificationPermission* Arena::CreateMaybeMessage<::permissions::PermissionFeatures_NotificationPermission>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::PermissionFeatures_NotificationPermission>(arena);
}
template <>
PROTOBUF_NOINLINE ::permissions::PermissionFeatures_GeolocationPermission* Arena::CreateMaybeMessage<::permissions::PermissionFeatures_GeolocationPermission>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::PermissionFeatures_GeolocationPermission>(arena);
}
template <> PROTOBUF_NOINLINE ::permissions::PermissionFeatures* Arena::CreateMaybeMessage<::permissions::PermissionFeatures>(Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::PermissionFeatures>(arena);
}
template <>
PROTOBUF_NOINLINE ::permissions::PermissionPrediction_NotificationPrediction*
Arena::CreateMaybeMessage<::permissions::PermissionPrediction_NotificationPrediction>(Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::PermissionPrediction_NotificationPrediction>(arena);
}
template <>
PROTOBUF_NOINLINE ::permissions::PermissionPrediction_GeolocationPrediction*
Arena::CreateMaybeMessage<::permissions::PermissionPrediction_GeolocationPrediction>(Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::PermissionPrediction_GeolocationPrediction>(arena);
}
template <>
PROTOBUF_NOINLINE ::permissions::PermissionPrediction_Likelihood* Arena::CreateMaybeMessage<::permissions::PermissionPrediction_Likelihood>(Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::PermissionPrediction_Likelihood>(arena);
}
template <> PROTOBUF_NOINLINE ::permissions::PermissionPrediction* Arena::CreateMaybeMessage<::permissions::PermissionPrediction>(Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::PermissionPrediction>(arena);
}
template <> PROTOBUF_NOINLINE ::permissions::GeneratePredictionsRequest* Arena::CreateMaybeMessage<::permissions::GeneratePredictionsRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::GeneratePredictionsRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::permissions::GeneratePredictionsResponse* Arena::CreateMaybeMessage<::permissions::GeneratePredictionsResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::permissions::GeneratePredictionsResponse>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
