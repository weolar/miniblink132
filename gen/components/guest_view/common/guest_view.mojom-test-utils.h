// components/guest_view/common/guest_view.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_GUEST_VIEW_COMMON_GUEST_VIEW_MOJOM_TEST_UTILS_H_
#define COMPONENTS_GUEST_VIEW_COMMON_GUEST_VIEW_MOJOM_TEST_UTILS_H_

#include "components/guest_view/common/guest_view.mojom.h"

namespace guest_view::mojom {

class ViewHandleInterceptorForTesting : public ViewHandle {
    virtual ViewHandle* GetForwardingInterface() = 0;
};
class ViewHandleAsyncWaiter {
public:
    explicit ViewHandleAsyncWaiter(ViewHandle* proxy);

    ViewHandleAsyncWaiter(const ViewHandleAsyncWaiter&) = delete;
    ViewHandleAsyncWaiter& operator=(const ViewHandleAsyncWaiter&) = delete;

    ~ViewHandleAsyncWaiter();

private:
    ViewHandle* const proxy_;
};

class GuestViewHostInterceptorForTesting : public GuestViewHost {
    virtual GuestViewHost* GetForwardingInterface() = 0;
    void AttachToEmbedderFrame(
        int32_t element_instance_id, int32_t guest_instance_id, ::base::Value::Dict params, AttachToEmbedderFrameCallback callback) override;
    void ViewCreated(int32_t view_instance_id, const std::string& view_type, ::mojo::PendingReceiver<ViewHandle> keep_alive_handle_receiver) override;
};
class GuestViewHostAsyncWaiter {
public:
    explicit GuestViewHostAsyncWaiter(GuestViewHost* proxy);

    GuestViewHostAsyncWaiter(const GuestViewHostAsyncWaiter&) = delete;
    GuestViewHostAsyncWaiter& operator=(const GuestViewHostAsyncWaiter&) = delete;

    ~GuestViewHostAsyncWaiter();
    void AttachToEmbedderFrame(int32_t element_instance_id, int32_t guest_instance_id, ::base::Value::Dict params);

private:
    GuestViewHost* const proxy_;
};

} // guest_view::mojom

#endif // COMPONENTS_GUEST_VIEW_COMMON_GUEST_VIEW_MOJOM_TEST_UTILS_H_
