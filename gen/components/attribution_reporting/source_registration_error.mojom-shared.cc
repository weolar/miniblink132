// components/attribution_reporting/source_registration_error.mojom-shared.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "components/attribution_reporting/source_registration_error.mojom-shared.h"

// Used to support stream output operator for enums.
// TODO(dcheng): Consider omitting this somehow if not needed.
#include <ostream>
#include <utility>

#include "base/strings/stringprintf.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "components/attribution_reporting/source_registration_error.mojom-params-data.h"
namespace attribution_reporting {
namespace mojom {

NOINLINE static const char* SourceRegistrationErrorToStringHelper(SourceRegistrationError value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case SourceRegistrationError::kInvalidJson:
        return "kInvalidJson";
    case SourceRegistrationError::kRootWrongType:
        return "kRootWrongType";
    case SourceRegistrationError::kDestinationMissing:
        return "kDestinationMissing";
    case SourceRegistrationError::kDestinationWrongType:
        return "kDestinationWrongType";
    case SourceRegistrationError::kDestinationUntrustworthy:
        return "kDestinationUntrustworthy";
    case SourceRegistrationError::kDestinationListUntrustworthy:
        return "kDestinationListUntrustworthy";
    case SourceRegistrationError::kFilterDataKeyTooLong:
        return "kFilterDataKeyTooLong";
    case SourceRegistrationError::kFilterDataKeyReserved:
        return "kFilterDataKeyReserved";
    case SourceRegistrationError::kFilterDataDictInvalid:
        return "kFilterDataDictInvalid";
    case SourceRegistrationError::kFilterDataListInvalid:
        return "kFilterDataListInvalid";
    case SourceRegistrationError::kFilterDataListValueInvalid:
        return "kFilterDataListValueInvalid";
    case SourceRegistrationError::kAggregationKeysKeyTooLong:
        return "kAggregationKeysKeyTooLong";
    case SourceRegistrationError::kAggregationKeysDictInvalid:
        return "kAggregationKeysDictInvalid";
    case SourceRegistrationError::kAggregationKeysValueInvalid:
        return "kAggregationKeysValueInvalid";
    case SourceRegistrationError::kSourceEventIdValueInvalid:
        return "kSourceEventIdValueInvalid";
    case SourceRegistrationError::kPriorityValueInvalid:
        return "kPriorityValueInvalid";
    case SourceRegistrationError::kExpiryValueInvalid:
        return "kExpiryValueInvalid";
    case SourceRegistrationError::kEventReportWindowValueInvalid:
        return "kEventReportWindowValueInvalid";
    case SourceRegistrationError::kAggregatableReportWindowValueInvalid:
        return "kAggregatableReportWindowValueInvalid";
    case SourceRegistrationError::kMaxEventLevelReportsValueInvalid:
        return "kMaxEventLevelReportsValueInvalid";
    case SourceRegistrationError::kEventReportWindowsWrongType:
        return "kEventReportWindowsWrongType";
    case SourceRegistrationError::kEventReportWindowsEndTimesMissing:
        return "kEventReportWindowsEndTimesMissing";
    case SourceRegistrationError::kEventReportWindowsEndTimeDurationLTEStart:
        return "kEventReportWindowsEndTimeDurationLTEStart";
    case SourceRegistrationError::kBothEventReportWindowFieldsFound:
        return "kBothEventReportWindowFieldsFound";
    case SourceRegistrationError::kEventReportWindowsEndTimesListInvalid:
        return "kEventReportWindowsEndTimesListInvalid";
    case SourceRegistrationError::kEventReportWindowsStartTimeInvalid:
        return "kEventReportWindowsStartTimeInvalid";
    case SourceRegistrationError::kEventReportWindowsEndTimeValueInvalid:
        return "kEventReportWindowsEndTimeValueInvalid";
    case SourceRegistrationError::kTriggerDataMatchingValueInvalid:
        return "kTriggerDataMatchingValueInvalid";
    case SourceRegistrationError::kTriggerSpecsWrongType:
        return "kTriggerSpecsWrongType";
    case SourceRegistrationError::kTriggerSpecTriggerDataMissing:
        return "kTriggerSpecTriggerDataMissing";
    case SourceRegistrationError::kTriggerSpecTriggerDataListInvalid:
        return "kTriggerSpecTriggerDataListInvalid";
    case SourceRegistrationError::kTriggerDataListInvalid:
        return "kTriggerDataListInvalid";
    case SourceRegistrationError::kDuplicateTriggerData:
        return "kDuplicateTriggerData";
    case SourceRegistrationError::kTriggerSpecDuplicateTriggerData:
        return "kTriggerSpecDuplicateTriggerData";
    case SourceRegistrationError::kExcessiveTriggerData:
        return "kExcessiveTriggerData";
    case SourceRegistrationError::kTriggerSpecExcessiveTriggerData:
        return "kTriggerSpecExcessiveTriggerData";
    case SourceRegistrationError::kInvalidTriggerDataForMatchingMode:
        return "kInvalidTriggerDataForMatchingMode";
    case SourceRegistrationError::kTopLevelTriggerDataAndTriggerSpecs:
        return "kTopLevelTriggerDataAndTriggerSpecs";
    case SourceRegistrationError::kSummaryOperatorValueInvalid:
        return "kSummaryOperatorValueInvalid";
    case SourceRegistrationError::kSummaryBucketsListInvalid:
        return "kSummaryBucketsListInvalid";
    case SourceRegistrationError::kSummaryBucketsValueInvalid:
        return "kSummaryBucketsValueInvalid";
    case SourceRegistrationError::kEventLevelEpsilonValueInvalid:
        return "kEventLevelEpsilonValueInvalid";
    case SourceRegistrationError::kDestinationLimitPriorityInvalid:
        return "kDestinationLimitPriorityInvalid";
    case SourceRegistrationError::kAttributionScopeLimitInvalid:
        return "kAttributionScopeLimitInvalid";
    case SourceRegistrationError::kAttributionScopeLimitRequired:
        return "kAttributionScopeLimitRequired";
    case SourceRegistrationError::kMaxEventStatesInvalid:
        return "kMaxEventStatesInvalid";
    case SourceRegistrationError::kAttributionScopesInvalid:
        return "kAttributionScopesInvalid";
    case SourceRegistrationError::kAttributionScopesListInvalid:
        return "kAttributionScopesListInvalid";
    case SourceRegistrationError::kAttributionScopesListValueInvalid:
        return "kAttributionScopesListValueInvalid";
    case SourceRegistrationError::kAggregatableNamedBudgetsDictInvalid:
        return "kAggregatableNamedBudgetsDictInvalid";
    case SourceRegistrationError::kAggregatableNamedBudgetsKeyTooLong:
        return "kAggregatableNamedBudgetsKeyTooLong";
    case SourceRegistrationError::kAggregatableNamedBudgetsValueInvalid:
        return "kAggregatableNamedBudgetsValueInvalid";
    default:
        return nullptr;
    }
}

std::string SourceRegistrationErrorToString(SourceRegistrationError value)
{
    const char* str = SourceRegistrationErrorToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown SourceRegistrationError value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, SourceRegistrationError value)
{
    return os << SourceRegistrationErrorToString(value);
}

namespace internal {

} // namespace internal
} // namespace mojom
} // namespace attribution_reporting

namespace perfetto {

// static
void TraceFormatTraits<::attribution_reporting::mojom::SourceRegistrationError>::WriteIntoTrace(
    perfetto::TracedValue context, ::attribution_reporting::mojom::SourceRegistrationError value)
{
    return std::move(context).WriteString(::attribution_reporting::mojom::SourceRegistrationErrorToString(value));
}

} // namespace perfetto