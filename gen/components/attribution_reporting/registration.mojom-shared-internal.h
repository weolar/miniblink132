// components/attribution_reporting/registration.mojom-shared-internal.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_ATTRIBUTION_REPORTING_REGISTRATION_MOJOM_SHARED_INTERNAL_H_
#define COMPONENTS_ATTRIBUTION_REPORTING_REGISTRATION_MOJOM_SHARED_INTERNAL_H_
#include "mojo/public/cpp/bindings/lib/array_internal.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/buffer.h"
#include "components/attribution_reporting/source_registration_time_config.mojom-shared-internal.h"
#include "components/attribution_reporting/trigger_data_matching.mojom-shared-internal.h"
#include "components/attribution_reporting/debug_types.mojom-shared-internal.h"
#include "mojo/public/mojom/base/int128.mojom-shared-internal.h"
#include "mojo/public/mojom/base/time.mojom-shared-internal.h"
#include "services/network/public/mojom/schemeful_site.mojom-shared-internal.h"
#include "url/mojom/origin.mojom-shared-internal.h"
#include "url/mojom/url.mojom-shared-internal.h"
#include "mojo/public/cpp/bindings/lib/native_enum_data.h"
#include "mojo/public/interfaces/bindings/native_struct.mojom-shared-internal.h"

namespace mojo {
namespace internal {
class ValidationContext;
}
}

namespace attribution_reporting::mojom {
namespace internal {
class SuitableOrigin_Data;
class FilterData_Data;
class FilterConfig_Data;
class FilterPair_Data;
class AggregationKeys_Data;
class AggregatableTriggerData_Data;
class DestinationSet_Data;
class EventReportWindows_Data;
class TriggerSpec_Data;
class TriggerSpecs_Data;
class AggregatableDebugReportingContribution_Data;
class AggregatableDebugReportingConfig_Data;
class SourceAggregatableDebugReportingConfig_Data;
class AttributionScopesSet_Data;
class AttributionScopesData_Data;
class AggregatableNamedBudgetDefs_Data;
class SourceRegistration_Data;
class EventTriggerData_Data;
class AggregatableDedupKey_Data;
class AggregatableValuesValue_Data;
class AggregatableValues_Data;
class AggregatableNamedBudgetCandidate_Data;
class TriggerRegistration_Data;
class OsRegistrationItem_Data;
class OsRegistration_Data;

#pragma pack(push, 1)
class SuitableOrigin_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::url::mojom::internal::Origin_Data> origin;

private:
    friend class mojo::internal::MessageFragment<SuitableOrigin_Data>;

    SuitableOrigin_Data();
    ~SuitableOrigin_Data() = delete;
};
static_assert(sizeof(SuitableOrigin_Data) == 16, "Bad sizeof(SuitableOrigin_Data)");
// Used by SuitableOrigin::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct SuitableOrigin_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    SuitableOrigin_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~SuitableOrigin_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<SuitableOrigin_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag SuitableOrigin_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class FilterData_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>,
        mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::String_Data>>>>>
        filter_values;

private:
    friend class mojo::internal::MessageFragment<FilterData_Data>;

    FilterData_Data();
    ~FilterData_Data() = delete;
};
static_assert(sizeof(FilterData_Data) == 16, "Bad sizeof(FilterData_Data)");
// Used by FilterData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct FilterData_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    FilterData_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~FilterData_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<FilterData_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag FilterData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class FilterConfig_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::TimeDelta_Data> lookback_window;
    mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>,
        mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::String_Data>>>>>
        filter_values;

private:
    friend class mojo::internal::MessageFragment<FilterConfig_Data>;

    FilterConfig_Data();
    ~FilterConfig_Data() = delete;
};
static_assert(sizeof(FilterConfig_Data) == 24, "Bad sizeof(FilterConfig_Data)");
// Used by FilterConfig::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct FilterConfig_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    FilterConfig_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~FilterConfig_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<FilterConfig_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag FilterConfig_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class FilterPair_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::FilterConfig_Data>>> positive;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::FilterConfig_Data>>> negative;

private:
    friend class mojo::internal::MessageFragment<FilterPair_Data>;

    FilterPair_Data();
    ~FilterPair_Data() = delete;
};
static_assert(sizeof(FilterPair_Data) == 24, "Bad sizeof(FilterPair_Data)");
// Used by FilterPair::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct FilterPair_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    FilterPair_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~FilterPair_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<FilterPair_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag FilterPair_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class AggregationKeys_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<
        mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<::mojo_base::mojom::internal::Uint128_Data>>>
        keys;

private:
    friend class mojo::internal::MessageFragment<AggregationKeys_Data>;

    AggregationKeys_Data();
    ~AggregationKeys_Data() = delete;
};
static_assert(sizeof(AggregationKeys_Data) == 16, "Bad sizeof(AggregationKeys_Data)");
// Used by AggregationKeys::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct AggregationKeys_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AggregationKeys_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AggregationKeys_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AggregationKeys_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AggregationKeys_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class AggregatableTriggerData_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::Uint128_Data> key_piece;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::String_Data>>> source_keys;
    mojo::internal::Pointer<internal::FilterPair_Data> filters;

private:
    friend class mojo::internal::MessageFragment<AggregatableTriggerData_Data>;

    AggregatableTriggerData_Data();
    ~AggregatableTriggerData_Data() = delete;
};
static_assert(sizeof(AggregatableTriggerData_Data) == 32, "Bad sizeof(AggregatableTriggerData_Data)");
// Used by AggregatableTriggerData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct AggregatableTriggerData_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AggregatableTriggerData_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AggregatableTriggerData_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AggregatableTriggerData_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AggregatableTriggerData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class DestinationSet_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<::network::mojom::internal::SchemefulSite_Data>>> destinations;

private:
    friend class mojo::internal::MessageFragment<DestinationSet_Data>;

    DestinationSet_Data();
    ~DestinationSet_Data() = delete;
};
static_assert(sizeof(DestinationSet_Data) == 16, "Bad sizeof(DestinationSet_Data)");
// Used by DestinationSet::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct DestinationSet_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    DestinationSet_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~DestinationSet_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<DestinationSet_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag DestinationSet_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class EventReportWindows_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::TimeDelta_Data> start_time;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<::mojo_base::mojom::internal::TimeDelta_Data>>> end_times;

private:
    friend class mojo::internal::MessageFragment<EventReportWindows_Data>;

    EventReportWindows_Data();
    ~EventReportWindows_Data() = delete;
};
static_assert(sizeof(EventReportWindows_Data) == 24, "Bad sizeof(EventReportWindows_Data)");
// Used by EventReportWindows::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct EventReportWindows_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    EventReportWindows_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~EventReportWindows_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<EventReportWindows_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag EventReportWindows_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class TriggerSpec_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<internal::EventReportWindows_Data> event_report_windows;

private:
    friend class mojo::internal::MessageFragment<TriggerSpec_Data>;

    TriggerSpec_Data();
    ~TriggerSpec_Data() = delete;
};
static_assert(sizeof(TriggerSpec_Data) == 16, "Bad sizeof(TriggerSpec_Data)");
// Used by TriggerSpec::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct TriggerSpec_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    TriggerSpec_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~TriggerSpec_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<TriggerSpec_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag TriggerSpec_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class TriggerSpecs_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::TriggerSpec_Data>>> specs;
    mojo::internal::Pointer<mojo::internal::Map_Data<uint32_t, uint8_t>> trigger_data_indices;
    int32_t max_event_level_reports;
    uint8_t padfinal_[4];

private:
    friend class mojo::internal::MessageFragment<TriggerSpecs_Data>;

    TriggerSpecs_Data();
    ~TriggerSpecs_Data() = delete;
};
static_assert(sizeof(TriggerSpecs_Data) == 32, "Bad sizeof(TriggerSpecs_Data)");
// Used by TriggerSpecs::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct TriggerSpecs_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    TriggerSpecs_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~TriggerSpecs_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<TriggerSpecs_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag TriggerSpecs_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class AggregatableDebugReportingContribution_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::Uint128_Data> key_piece;
    uint32_t value;
    uint8_t padfinal_[4];

private:
    friend class mojo::internal::MessageFragment<AggregatableDebugReportingContribution_Data>;

    AggregatableDebugReportingContribution_Data();
    ~AggregatableDebugReportingContribution_Data() = delete;
};
static_assert(sizeof(AggregatableDebugReportingContribution_Data) == 24, "Bad sizeof(AggregatableDebugReportingContribution_Data)");
// Used by AggregatableDebugReportingContribution::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct AggregatableDebugReportingContribution_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AggregatableDebugReportingContribution_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AggregatableDebugReportingContribution_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AggregatableDebugReportingContribution_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AggregatableDebugReportingContribution_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class AggregatableDebugReportingConfig_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::Uint128_Data> key_piece;
    mojo::internal::Pointer<mojo::internal::Map_Data<int32_t, mojo::internal::Pointer<internal::AggregatableDebugReportingContribution_Data>>> debug_data;
    mojo::internal::Pointer<internal::SuitableOrigin_Data> aggregation_coordinator_origin;

private:
    friend class mojo::internal::MessageFragment<AggregatableDebugReportingConfig_Data>;

    AggregatableDebugReportingConfig_Data();
    ~AggregatableDebugReportingConfig_Data() = delete;
};
static_assert(sizeof(AggregatableDebugReportingConfig_Data) == 32, "Bad sizeof(AggregatableDebugReportingConfig_Data)");
// Used by AggregatableDebugReportingConfig::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct AggregatableDebugReportingConfig_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AggregatableDebugReportingConfig_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AggregatableDebugReportingConfig_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AggregatableDebugReportingConfig_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AggregatableDebugReportingConfig_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class SourceAggregatableDebugReportingConfig_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    int32_t budget;
    uint8_t pad0_[4];
    mojo::internal::Pointer<internal::AggregatableDebugReportingConfig_Data> config;

private:
    friend class mojo::internal::MessageFragment<SourceAggregatableDebugReportingConfig_Data>;

    SourceAggregatableDebugReportingConfig_Data();
    ~SourceAggregatableDebugReportingConfig_Data() = delete;
};
static_assert(sizeof(SourceAggregatableDebugReportingConfig_Data) == 24, "Bad sizeof(SourceAggregatableDebugReportingConfig_Data)");
// Used by SourceAggregatableDebugReportingConfig::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct SourceAggregatableDebugReportingConfig_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    SourceAggregatableDebugReportingConfig_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~SourceAggregatableDebugReportingConfig_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<SourceAggregatableDebugReportingConfig_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag SourceAggregatableDebugReportingConfig_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class AttributionScopesSet_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<mojo::internal::String_Data>>> scopes;

private:
    friend class mojo::internal::MessageFragment<AttributionScopesSet_Data>;

    AttributionScopesSet_Data();
    ~AttributionScopesSet_Data() = delete;
};
static_assert(sizeof(AttributionScopesSet_Data) == 16, "Bad sizeof(AttributionScopesSet_Data)");
// Used by AttributionScopesSet::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct AttributionScopesSet_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AttributionScopesSet_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AttributionScopesSet_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AttributionScopesSet_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AttributionScopesSet_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class AttributionScopesData_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<internal::AttributionScopesSet_Data> attribution_scopes_set;
    uint32_t attribution_scope_limit;
    uint32_t max_event_states;

private:
    friend class mojo::internal::MessageFragment<AttributionScopesData_Data>;

    AttributionScopesData_Data();
    ~AttributionScopesData_Data() = delete;
};
static_assert(sizeof(AttributionScopesData_Data) == 24, "Bad sizeof(AttributionScopesData_Data)");
// Used by AttributionScopesData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct AttributionScopesData_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AttributionScopesData_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AttributionScopesData_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AttributionScopesData_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AttributionScopesData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class AggregatableNamedBudgetDefs_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, int32_t>> budgets;

private:
    friend class mojo::internal::MessageFragment<AggregatableNamedBudgetDefs_Data>;

    AggregatableNamedBudgetDefs_Data();
    ~AggregatableNamedBudgetDefs_Data() = delete;
};
static_assert(sizeof(AggregatableNamedBudgetDefs_Data) == 16, "Bad sizeof(AggregatableNamedBudgetDefs_Data)");
// Used by AggregatableNamedBudgetDefs::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct AggregatableNamedBudgetDefs_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AggregatableNamedBudgetDefs_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AggregatableNamedBudgetDefs_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AggregatableNamedBudgetDefs_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AggregatableNamedBudgetDefs_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class SourceRegistration_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<internal::DestinationSet_Data> destinations;
    uint64_t source_event_id;
    mojo::internal::Pointer<::mojo_base::mojom::internal::TimeDelta_Data> expiry;
    mojo::internal::Pointer<internal::TriggerSpecs_Data> trigger_specs;
    mojo::internal::Pointer<::mojo_base::mojom::internal::TimeDelta_Data> aggregatable_report_window;
    int64_t priority;
    uint8_t debug_key_$flag : 1;
    uint8_t debug_reporting : 1;
    uint8_t pad7_[3];
    int32_t trigger_data_matching;
    uint64_t debug_key_$value;
    mojo::internal::Pointer<internal::FilterData_Data> filter_data;
    mojo::internal::Pointer<internal::AggregationKeys_Data> aggregation_keys;
    double event_level_epsilon;
    mojo::internal::Pointer<internal::SourceAggregatableDebugReportingConfig_Data> aggregatable_debug_reporting_config;
    int64_t destination_limit_priority;
    mojo::internal::Pointer<internal::AttributionScopesData_Data> attribution_scopes_data;
    mojo::internal::Pointer<internal::AggregatableNamedBudgetDefs_Data> aggregatable_named_budget_defs;

private:
    friend class mojo::internal::MessageFragment<SourceRegistration_Data>;

    SourceRegistration_Data();
    ~SourceRegistration_Data() = delete;
};
static_assert(sizeof(SourceRegistration_Data) == 128, "Bad sizeof(SourceRegistration_Data)");
// Used by SourceRegistration::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct SourceRegistration_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    SourceRegistration_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~SourceRegistration_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<SourceRegistration_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag SourceRegistration_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class EventTriggerData_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    uint64_t data;
    int64_t priority;
    uint8_t dedup_key_$flag : 1;
    uint8_t pad2_[7];
    uint64_t dedup_key_$value;
    mojo::internal::Pointer<internal::FilterPair_Data> filters;

private:
    friend class mojo::internal::MessageFragment<EventTriggerData_Data>;

    EventTriggerData_Data();
    ~EventTriggerData_Data() = delete;
};
static_assert(sizeof(EventTriggerData_Data) == 48, "Bad sizeof(EventTriggerData_Data)");
// Used by EventTriggerData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct EventTriggerData_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    EventTriggerData_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~EventTriggerData_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<EventTriggerData_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag EventTriggerData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class AggregatableDedupKey_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    uint8_t dedup_key_$flag : 1;
    uint8_t pad0_[7];
    uint64_t dedup_key_$value;
    mojo::internal::Pointer<internal::FilterPair_Data> filters;

private:
    friend class mojo::internal::MessageFragment<AggregatableDedupKey_Data>;

    AggregatableDedupKey_Data();
    ~AggregatableDedupKey_Data() = delete;
};
static_assert(sizeof(AggregatableDedupKey_Data) == 32, "Bad sizeof(AggregatableDedupKey_Data)");
// Used by AggregatableDedupKey::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct AggregatableDedupKey_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AggregatableDedupKey_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AggregatableDedupKey_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AggregatableDedupKey_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AggregatableDedupKey_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class AggregatableValuesValue_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    uint32_t value;
    uint8_t pad0_[4];
    uint64_t filtering_id;

private:
    friend class mojo::internal::MessageFragment<AggregatableValuesValue_Data>;

    AggregatableValuesValue_Data();
    ~AggregatableValuesValue_Data() = delete;
};
static_assert(sizeof(AggregatableValuesValue_Data) == 24, "Bad sizeof(AggregatableValuesValue_Data)");
// Used by AggregatableValuesValue::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct AggregatableValuesValue_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AggregatableValuesValue_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AggregatableValuesValue_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AggregatableValuesValue_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AggregatableValuesValue_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class AggregatableValues_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<
        mojo::internal::Map_Data<mojo::internal::Pointer<mojo::internal::String_Data>, mojo::internal::Pointer<internal::AggregatableValuesValue_Data>>>
        values;
    mojo::internal::Pointer<internal::FilterPair_Data> filters;

private:
    friend class mojo::internal::MessageFragment<AggregatableValues_Data>;

    AggregatableValues_Data();
    ~AggregatableValues_Data() = delete;
};
static_assert(sizeof(AggregatableValues_Data) == 24, "Bad sizeof(AggregatableValues_Data)");
// Used by AggregatableValues::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct AggregatableValues_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AggregatableValues_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AggregatableValues_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AggregatableValues_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AggregatableValues_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class AggregatableNamedBudgetCandidate_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::String_Data> name;
    mojo::internal::Pointer<internal::FilterPair_Data> filters;

private:
    friend class mojo::internal::MessageFragment<AggregatableNamedBudgetCandidate_Data>;

    AggregatableNamedBudgetCandidate_Data();
    ~AggregatableNamedBudgetCandidate_Data() = delete;
};
static_assert(sizeof(AggregatableNamedBudgetCandidate_Data) == 24, "Bad sizeof(AggregatableNamedBudgetCandidate_Data)");
// Used by AggregatableNamedBudgetCandidate::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct AggregatableNamedBudgetCandidate_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AggregatableNamedBudgetCandidate_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AggregatableNamedBudgetCandidate_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AggregatableNamedBudgetCandidate_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AggregatableNamedBudgetCandidate_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class TriggerRegistration_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::EventTriggerData_Data>>> event_triggers;
    mojo::internal::Pointer<internal::FilterPair_Data> filters;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::AggregatableTriggerData_Data>>> aggregatable_trigger_data;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::AggregatableValues_Data>>> aggregatable_values;
    uint8_t debug_key_$flag : 1;
    uint8_t debug_reporting : 1;
    uint8_t aggregatable_filtering_id_max_bytes;
    uint8_t pad6_[2];
    int32_t source_registration_time_config;
    uint64_t debug_key_$value;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::AggregatableDedupKey_Data>>> aggregatable_dedup_keys;
    mojo::internal::Pointer<internal::SuitableOrigin_Data> aggregation_coordinator_origin;
    mojo::internal::Pointer<mojo::internal::String_Data> trigger_context_id;
    mojo::internal::Pointer<internal::AggregatableDebugReportingConfig_Data> aggregatable_debug_reporting_config;
    mojo::internal::Pointer<internal::AttributionScopesSet_Data> attribution_scopes;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::AggregatableNamedBudgetCandidate_Data>>>
        aggregatable_named_budget_candidates;

private:
    friend class mojo::internal::MessageFragment<TriggerRegistration_Data>;

    TriggerRegistration_Data();
    ~TriggerRegistration_Data() = delete;
};
static_assert(sizeof(TriggerRegistration_Data) == 104, "Bad sizeof(TriggerRegistration_Data)");
// Used by TriggerRegistration::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct TriggerRegistration_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    TriggerRegistration_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~TriggerRegistration_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<TriggerRegistration_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag TriggerRegistration_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class OsRegistrationItem_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::url::mojom::internal::Url_Data> url;
    uint8_t debug_reporting : 1;
    uint8_t padfinal_[7];

private:
    friend class mojo::internal::MessageFragment<OsRegistrationItem_Data>;

    OsRegistrationItem_Data();
    ~OsRegistrationItem_Data() = delete;
};
static_assert(sizeof(OsRegistrationItem_Data) == 24, "Bad sizeof(OsRegistrationItem_Data)");
// Used by OsRegistrationItem::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct OsRegistrationItem_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    OsRegistrationItem_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~OsRegistrationItem_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<OsRegistrationItem_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag OsRegistrationItem_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class OsRegistration_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::OsRegistrationItem_Data>>> items;

private:
    friend class mojo::internal::MessageFragment<OsRegistration_Data>;

    OsRegistration_Data();
    ~OsRegistration_Data() = delete;
};
static_assert(sizeof(OsRegistration_Data) == 16, "Bad sizeof(OsRegistration_Data)");
// Used by OsRegistration::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct OsRegistration_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    OsRegistration_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~OsRegistration_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<OsRegistration_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag OsRegistration_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};

#pragma pack(pop)

} // namespace internal

} // attribution_reporting::mojom

#endif // COMPONENTS_ATTRIBUTION_REPORTING_REGISTRATION_MOJOM_SHARED_INTERNAL_H_
