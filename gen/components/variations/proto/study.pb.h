// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: study.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_study_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_study_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "layer.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_study_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_study_2eproto {
    static const uint32_t offsets[];
};
namespace variations {
class Study;
struct StudyDefaultTypeInternal;
extern StudyDefaultTypeInternal _Study_default_instance_;
class Study_Experiment;
struct Study_ExperimentDefaultTypeInternal;
extern Study_ExperimentDefaultTypeInternal _Study_Experiment_default_instance_;
class Study_Experiment_FeatureAssociation;
struct Study_Experiment_FeatureAssociationDefaultTypeInternal;
extern Study_Experiment_FeatureAssociationDefaultTypeInternal _Study_Experiment_FeatureAssociation_default_instance_;
class Study_Experiment_OverrideUIString;
struct Study_Experiment_OverrideUIStringDefaultTypeInternal;
extern Study_Experiment_OverrideUIStringDefaultTypeInternal _Study_Experiment_OverrideUIString_default_instance_;
class Study_Experiment_Param;
struct Study_Experiment_ParamDefaultTypeInternal;
extern Study_Experiment_ParamDefaultTypeInternal _Study_Experiment_Param_default_instance_;
class Study_Filter;
struct Study_FilterDefaultTypeInternal;
extern Study_FilterDefaultTypeInternal _Study_Filter_default_instance_;
} // namespace variations
PROTOBUF_NAMESPACE_OPEN
template <>::variations::Study* Arena::CreateMaybeMessage<::variations::Study>(Arena*);
template <>::variations::Study_Experiment* Arena::CreateMaybeMessage<::variations::Study_Experiment>(Arena*);
template <>::variations::Study_Experiment_FeatureAssociation* Arena::CreateMaybeMessage<::variations::Study_Experiment_FeatureAssociation>(Arena*);
template <>::variations::Study_Experiment_OverrideUIString* Arena::CreateMaybeMessage<::variations::Study_Experiment_OverrideUIString>(Arena*);
template <>::variations::Study_Experiment_Param* Arena::CreateMaybeMessage<::variations::Study_Experiment_Param>(Arena*);
template <>::variations::Study_Filter* Arena::CreateMaybeMessage<::variations::Study_Filter>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace variations {

enum Study_Experiment_Type : int {
    Study_Experiment_Type_NORMAL = 0,
    Study_Experiment_Type_IGNORE_CHANGE = 1,
    Study_Experiment_Type_KILL_BEST_EFFORT = 2,
    Study_Experiment_Type_KILL_CRITICAL = 3
};
bool Study_Experiment_Type_IsValid(int value);
constexpr Study_Experiment_Type Study_Experiment_Type_Type_MIN = Study_Experiment_Type_NORMAL;
constexpr Study_Experiment_Type Study_Experiment_Type_Type_MAX = Study_Experiment_Type_KILL_CRITICAL;
constexpr int Study_Experiment_Type_Type_ARRAYSIZE = Study_Experiment_Type_Type_MAX + 1;

const std::string& Study_Experiment_Type_Name(Study_Experiment_Type value);
template <typename T> inline const std::string& Study_Experiment_Type_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, Study_Experiment_Type>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Study_Experiment_Type_Name.");
    return Study_Experiment_Type_Name(static_cast<Study_Experiment_Type>(enum_t_value));
}
bool Study_Experiment_Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Experiment_Type* value);
enum Study_Consistency : int { Study_Consistency_SESSION = 0, Study_Consistency_PERMANENT = 1 };
bool Study_Consistency_IsValid(int value);
constexpr Study_Consistency Study_Consistency_Consistency_MIN = Study_Consistency_SESSION;
constexpr Study_Consistency Study_Consistency_Consistency_MAX = Study_Consistency_PERMANENT;
constexpr int Study_Consistency_Consistency_ARRAYSIZE = Study_Consistency_Consistency_MAX + 1;

const std::string& Study_Consistency_Name(Study_Consistency value);
template <typename T> inline const std::string& Study_Consistency_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Study_Consistency>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Study_Consistency_Name.");
    return Study_Consistency_Name(static_cast<Study_Consistency>(enum_t_value));
}
bool Study_Consistency_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Consistency* value);
enum Study_GoogleWebVisibility : int { Study_GoogleWebVisibility_ANY = 0, Study_GoogleWebVisibility_FIRST_PARTY = 1 };
bool Study_GoogleWebVisibility_IsValid(int value);
constexpr Study_GoogleWebVisibility Study_GoogleWebVisibility_GoogleWebVisibility_MIN = Study_GoogleWebVisibility_ANY;
constexpr Study_GoogleWebVisibility Study_GoogleWebVisibility_GoogleWebVisibility_MAX = Study_GoogleWebVisibility_FIRST_PARTY;
constexpr int Study_GoogleWebVisibility_GoogleWebVisibility_ARRAYSIZE = Study_GoogleWebVisibility_GoogleWebVisibility_MAX + 1;

const std::string& Study_GoogleWebVisibility_Name(Study_GoogleWebVisibility value);
template <typename T> inline const std::string& Study_GoogleWebVisibility_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Study_GoogleWebVisibility>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function Study_GoogleWebVisibility_Name.");
    return Study_GoogleWebVisibility_Name(static_cast<Study_GoogleWebVisibility>(enum_t_value));
}
bool Study_GoogleWebVisibility_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_GoogleWebVisibility* value);
enum Study_Channel : int { Study_Channel_UNKNOWN = -1, Study_Channel_CANARY = 0, Study_Channel_DEV = 1, Study_Channel_BETA = 2, Study_Channel_STABLE = 3 };
bool Study_Channel_IsValid(int value);
constexpr Study_Channel Study_Channel_Channel_MIN = Study_Channel_UNKNOWN;
constexpr Study_Channel Study_Channel_Channel_MAX = Study_Channel_STABLE;
constexpr int Study_Channel_Channel_ARRAYSIZE = Study_Channel_Channel_MAX + 1;

const std::string& Study_Channel_Name(Study_Channel value);
template <typename T> inline const std::string& Study_Channel_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Study_Channel>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Study_Channel_Name.");
    return Study_Channel_Name(static_cast<Study_Channel>(enum_t_value));
}
bool Study_Channel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Channel* value);
enum Study_Platform : int {
    Study_Platform_PLATFORM_WINDOWS = 0,
    Study_Platform_PLATFORM_MAC = 1,
    Study_Platform_PLATFORM_LINUX = 2,
    Study_Platform_PLATFORM_CHROMEOS = 3,
    Study_Platform_PLATFORM_ANDROID = 4,
    Study_Platform_PLATFORM_IOS = 5,
    Study_Platform_PLATFORM_ANDROID_WEBVIEW = 6,
    Study_Platform_PLATFORM_FUCHSIA = 7,
    Study_Platform_PLATFORM_ANDROID_WEBLAYER = 8,
    Study_Platform_PLATFORM_CHROMEOS_LACROS = 9
};
bool Study_Platform_IsValid(int value);
constexpr Study_Platform Study_Platform_Platform_MIN = Study_Platform_PLATFORM_WINDOWS;
constexpr Study_Platform Study_Platform_Platform_MAX = Study_Platform_PLATFORM_CHROMEOS_LACROS;
constexpr int Study_Platform_Platform_ARRAYSIZE = Study_Platform_Platform_MAX + 1;

const std::string& Study_Platform_Name(Study_Platform value);
template <typename T> inline const std::string& Study_Platform_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Study_Platform>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Study_Platform_Name.");
    return Study_Platform_Name(static_cast<Study_Platform>(enum_t_value));
}
bool Study_Platform_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Platform* value);
enum Study_FormFactor : int {
    Study_FormFactor_DESKTOP = 0,
    Study_FormFactor_PHONE = 1,
    Study_FormFactor_TABLET = 2,
    Study_FormFactor_KIOSK = 3,
    Study_FormFactor_MEET_DEVICE = 4,
    Study_FormFactor_TV = 5,
    Study_FormFactor_AUTOMOTIVE = 6,
    Study_FormFactor_FOLDABLE = 7
};
bool Study_FormFactor_IsValid(int value);
constexpr Study_FormFactor Study_FormFactor_FormFactor_MIN = Study_FormFactor_DESKTOP;
constexpr Study_FormFactor Study_FormFactor_FormFactor_MAX = Study_FormFactor_FOLDABLE;
constexpr int Study_FormFactor_FormFactor_ARRAYSIZE = Study_FormFactor_FormFactor_MAX + 1;

const std::string& Study_FormFactor_Name(Study_FormFactor value);
template <typename T> inline const std::string& Study_FormFactor_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Study_FormFactor>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Study_FormFactor_Name.");
    return Study_FormFactor_Name(static_cast<Study_FormFactor>(enum_t_value));
}
bool Study_FormFactor_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_FormFactor* value);
enum Study_CpuArchitecture : int {
    Study_CpuArchitecture_X86_64 = 0,
    Study_CpuArchitecture_ARM64 = 1,
    Study_CpuArchitecture_X86_32 = 2,
    Study_CpuArchitecture_ARM32 = 3,
    Study_CpuArchitecture_TRANSLATED_X86_64 = 4
};
bool Study_CpuArchitecture_IsValid(int value);
constexpr Study_CpuArchitecture Study_CpuArchitecture_CpuArchitecture_MIN = Study_CpuArchitecture_X86_64;
constexpr Study_CpuArchitecture Study_CpuArchitecture_CpuArchitecture_MAX = Study_CpuArchitecture_TRANSLATED_X86_64;
constexpr int Study_CpuArchitecture_CpuArchitecture_ARRAYSIZE = Study_CpuArchitecture_CpuArchitecture_MAX + 1;

const std::string& Study_CpuArchitecture_Name(Study_CpuArchitecture value);
template <typename T> inline const std::string& Study_CpuArchitecture_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, Study_CpuArchitecture>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Study_CpuArchitecture_Name.");
    return Study_CpuArchitecture_Name(static_cast<Study_CpuArchitecture>(enum_t_value));
}
bool Study_CpuArchitecture_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_CpuArchitecture* value);
enum Study_OptionalBool : int {
    Study_OptionalBool_OPTIONAL_BOOL_MISSING = 0,
    Study_OptionalBool_OPTIONAL_BOOL_TRUE = 1,
    Study_OptionalBool_OPTIONAL_BOOL_FALSE = 2
};
bool Study_OptionalBool_IsValid(int value);
constexpr Study_OptionalBool Study_OptionalBool_OptionalBool_MIN = Study_OptionalBool_OPTIONAL_BOOL_MISSING;
constexpr Study_OptionalBool Study_OptionalBool_OptionalBool_MAX = Study_OptionalBool_OPTIONAL_BOOL_FALSE;
constexpr int Study_OptionalBool_OptionalBool_ARRAYSIZE = Study_OptionalBool_OptionalBool_MAX + 1;

const std::string& Study_OptionalBool_Name(Study_OptionalBool value);
template <typename T> inline const std::string& Study_OptionalBool_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Study_OptionalBool>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Study_OptionalBool_Name.");
    return Study_OptionalBool_Name(static_cast<Study_OptionalBool>(enum_t_value));
}
bool Study_OptionalBool_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_OptionalBool* value);
enum Study_PolicyRestriction : int { Study_PolicyRestriction_NONE = 0, Study_PolicyRestriction_CRITICAL = 1, Study_PolicyRestriction_CRITICAL_ONLY = 2 };
bool Study_PolicyRestriction_IsValid(int value);
constexpr Study_PolicyRestriction Study_PolicyRestriction_PolicyRestriction_MIN = Study_PolicyRestriction_NONE;
constexpr Study_PolicyRestriction Study_PolicyRestriction_PolicyRestriction_MAX = Study_PolicyRestriction_CRITICAL_ONLY;
constexpr int Study_PolicyRestriction_PolicyRestriction_ARRAYSIZE = Study_PolicyRestriction_PolicyRestriction_MAX + 1;

const std::string& Study_PolicyRestriction_Name(Study_PolicyRestriction value);
template <typename T> inline const std::string& Study_PolicyRestriction_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, Study_PolicyRestriction>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Study_PolicyRestriction_Name.");
    return Study_PolicyRestriction_Name(static_cast<Study_PolicyRestriction>(enum_t_value));
}
bool Study_PolicyRestriction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_PolicyRestriction* value);
enum Study_ActivationType : int { Study_ActivationType_ACTIVATE_ON_QUERY = 0, Study_ActivationType_ACTIVATE_ON_STARTUP = 1 };
bool Study_ActivationType_IsValid(int value);
constexpr Study_ActivationType Study_ActivationType_ActivationType_MIN = Study_ActivationType_ACTIVATE_ON_QUERY;
constexpr Study_ActivationType Study_ActivationType_ActivationType_MAX = Study_ActivationType_ACTIVATE_ON_STARTUP;
constexpr int Study_ActivationType_ActivationType_ARRAYSIZE = Study_ActivationType_ActivationType_MAX + 1;

const std::string& Study_ActivationType_Name(Study_ActivationType value);
template <typename T> inline const std::string& Study_ActivationType_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, Study_ActivationType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Study_ActivationType_Name.");
    return Study_ActivationType_Name(static_cast<Study_ActivationType>(enum_t_value));
}
bool Study_ActivationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_ActivationType* value);
// ===================================================================

class Study_Experiment_Param final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:variations.Study.Experiment.Param) */ {
public:
    inline Study_Experiment_Param()
        : Study_Experiment_Param(nullptr)
    {
    }
    ~Study_Experiment_Param() override;
    explicit PROTOBUF_CONSTEXPR Study_Experiment_Param(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Study_Experiment_Param(const Study_Experiment_Param& from);
    Study_Experiment_Param(Study_Experiment_Param&& from) noexcept
        : Study_Experiment_Param()
    {
        *this = ::std::move(from);
    }

    inline Study_Experiment_Param& operator=(const Study_Experiment_Param& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Study_Experiment_Param& operator=(Study_Experiment_Param&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Study_Experiment_Param& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Study_Experiment_Param* internal_default_instance()
    {
        return reinterpret_cast<const Study_Experiment_Param*>(&_Study_Experiment_Param_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(Study_Experiment_Param& a, Study_Experiment_Param& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Study_Experiment_Param* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Study_Experiment_Param* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Study_Experiment_Param* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Study_Experiment_Param>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Study_Experiment_Param& from);
    void MergeFrom(const Study_Experiment_Param& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Study_Experiment_Param* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "variations.Study.Experiment.Param";
    }

protected:
    explicit Study_Experiment_Param(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kNameFieldNumber = 1,
        kValueFieldNumber = 2,
    };
    // optional string name = 1;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // optional string value = 2;
    bool has_value() const;

private:
    bool _internal_has_value() const;

public:
    void clear_value();
    const std::string& value() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_value(ArgT0&& arg0, ArgT... args);
    std::string* mutable_value();
    PROTOBUF_NODISCARD std::string* release_value();
    void set_allocated_value(std::string* value);

private:
    const std::string& _internal_value() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
    std::string* _internal_mutable_value();

public:
    // @@protoc_insertion_point(class_scope:variations.Study.Experiment.Param)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_study_2eproto;
};
// -------------------------------------------------------------------

class Study_Experiment_FeatureAssociation final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:variations.Study.Experiment.FeatureAssociation) */ {
public:
    inline Study_Experiment_FeatureAssociation()
        : Study_Experiment_FeatureAssociation(nullptr)
    {
    }
    ~Study_Experiment_FeatureAssociation() override;
    explicit PROTOBUF_CONSTEXPR Study_Experiment_FeatureAssociation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Study_Experiment_FeatureAssociation(const Study_Experiment_FeatureAssociation& from);
    Study_Experiment_FeatureAssociation(Study_Experiment_FeatureAssociation&& from) noexcept
        : Study_Experiment_FeatureAssociation()
    {
        *this = ::std::move(from);
    }

    inline Study_Experiment_FeatureAssociation& operator=(const Study_Experiment_FeatureAssociation& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Study_Experiment_FeatureAssociation& operator=(Study_Experiment_FeatureAssociation&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Study_Experiment_FeatureAssociation& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Study_Experiment_FeatureAssociation* internal_default_instance()
    {
        return reinterpret_cast<const Study_Experiment_FeatureAssociation*>(&_Study_Experiment_FeatureAssociation_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(Study_Experiment_FeatureAssociation& a, Study_Experiment_FeatureAssociation& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Study_Experiment_FeatureAssociation* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Study_Experiment_FeatureAssociation* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Study_Experiment_FeatureAssociation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Study_Experiment_FeatureAssociation>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Study_Experiment_FeatureAssociation& from);
    void MergeFrom(const Study_Experiment_FeatureAssociation& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Study_Experiment_FeatureAssociation* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "variations.Study.Experiment.FeatureAssociation";
    }

protected:
    explicit Study_Experiment_FeatureAssociation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kEnableFeatureFieldNumber = 1,
        kDisableFeatureFieldNumber = 2,
        kForcingFeatureOnFieldNumber = 3,
        kForcingFeatureOffFieldNumber = 4,
    };
    // repeated string enable_feature = 1;
    int enable_feature_size() const;

private:
    int _internal_enable_feature_size() const;

public:
    void clear_enable_feature();
    const std::string& enable_feature(int index) const;
    std::string* mutable_enable_feature(int index);
    void set_enable_feature(int index, const std::string& value);
    void set_enable_feature(int index, std::string&& value);
    void set_enable_feature(int index, const char* value);
    void set_enable_feature(int index, const char* value, size_t size);
    std::string* add_enable_feature();
    void add_enable_feature(const std::string& value);
    void add_enable_feature(std::string&& value);
    void add_enable_feature(const char* value);
    void add_enable_feature(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& enable_feature() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_enable_feature();

private:
    const std::string& _internal_enable_feature(int index) const;
    std::string* _internal_add_enable_feature();

public:
    // repeated string disable_feature = 2;
    int disable_feature_size() const;

private:
    int _internal_disable_feature_size() const;

public:
    void clear_disable_feature();
    const std::string& disable_feature(int index) const;
    std::string* mutable_disable_feature(int index);
    void set_disable_feature(int index, const std::string& value);
    void set_disable_feature(int index, std::string&& value);
    void set_disable_feature(int index, const char* value);
    void set_disable_feature(int index, const char* value, size_t size);
    std::string* add_disable_feature();
    void add_disable_feature(const std::string& value);
    void add_disable_feature(std::string&& value);
    void add_disable_feature(const char* value);
    void add_disable_feature(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& disable_feature() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_disable_feature();

private:
    const std::string& _internal_disable_feature(int index) const;
    std::string* _internal_add_disable_feature();

public:
    // optional string forcing_feature_on = 3;
    bool has_forcing_feature_on() const;

private:
    bool _internal_has_forcing_feature_on() const;

public:
    void clear_forcing_feature_on();
    const std::string& forcing_feature_on() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_forcing_feature_on(ArgT0&& arg0, ArgT... args);
    std::string* mutable_forcing_feature_on();
    PROTOBUF_NODISCARD std::string* release_forcing_feature_on();
    void set_allocated_forcing_feature_on(std::string* forcing_feature_on);

private:
    const std::string& _internal_forcing_feature_on() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_forcing_feature_on(const std::string& value);
    std::string* _internal_mutable_forcing_feature_on();

public:
    // optional string forcing_feature_off = 4;
    bool has_forcing_feature_off() const;

private:
    bool _internal_has_forcing_feature_off() const;

public:
    void clear_forcing_feature_off();
    const std::string& forcing_feature_off() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_forcing_feature_off(ArgT0&& arg0, ArgT... args);
    std::string* mutable_forcing_feature_off();
    PROTOBUF_NODISCARD std::string* release_forcing_feature_off();
    void set_allocated_forcing_feature_off(std::string* forcing_feature_off);

private:
    const std::string& _internal_forcing_feature_off() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_forcing_feature_off(const std::string& value);
    std::string* _internal_mutable_forcing_feature_off();

public:
    // @@protoc_insertion_point(class_scope:variations.Study.Experiment.FeatureAssociation)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> enable_feature_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> disable_feature_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr forcing_feature_on_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr forcing_feature_off_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_study_2eproto;
};
// -------------------------------------------------------------------

class Study_Experiment_OverrideUIString final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:variations.Study.Experiment.OverrideUIString) */ {
public:
    inline Study_Experiment_OverrideUIString()
        : Study_Experiment_OverrideUIString(nullptr)
    {
    }
    ~Study_Experiment_OverrideUIString() override;
    explicit PROTOBUF_CONSTEXPR Study_Experiment_OverrideUIString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Study_Experiment_OverrideUIString(const Study_Experiment_OverrideUIString& from);
    Study_Experiment_OverrideUIString(Study_Experiment_OverrideUIString&& from) noexcept
        : Study_Experiment_OverrideUIString()
    {
        *this = ::std::move(from);
    }

    inline Study_Experiment_OverrideUIString& operator=(const Study_Experiment_OverrideUIString& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Study_Experiment_OverrideUIString& operator=(Study_Experiment_OverrideUIString&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Study_Experiment_OverrideUIString& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Study_Experiment_OverrideUIString* internal_default_instance()
    {
        return reinterpret_cast<const Study_Experiment_OverrideUIString*>(&_Study_Experiment_OverrideUIString_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(Study_Experiment_OverrideUIString& a, Study_Experiment_OverrideUIString& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Study_Experiment_OverrideUIString* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Study_Experiment_OverrideUIString* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Study_Experiment_OverrideUIString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Study_Experiment_OverrideUIString>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Study_Experiment_OverrideUIString& from);
    void MergeFrom(const Study_Experiment_OverrideUIString& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Study_Experiment_OverrideUIString* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "variations.Study.Experiment.OverrideUIString";
    }

protected:
    explicit Study_Experiment_OverrideUIString(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kValueFieldNumber = 2,
        kNameHashFieldNumber = 1,
    };
    // optional string value = 2;
    bool has_value() const;

private:
    bool _internal_has_value() const;

public:
    void clear_value();
    const std::string& value() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_value(ArgT0&& arg0, ArgT... args);
    std::string* mutable_value();
    PROTOBUF_NODISCARD std::string* release_value();
    void set_allocated_value(std::string* value);

private:
    const std::string& _internal_value() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
    std::string* _internal_mutable_value();

public:
    // optional fixed32 name_hash = 1;
    bool has_name_hash() const;

private:
    bool _internal_has_name_hash() const;

public:
    void clear_name_hash();
    uint32_t name_hash() const;
    void set_name_hash(uint32_t value);

private:
    uint32_t _internal_name_hash() const;
    void _internal_set_name_hash(uint32_t value);

public:
    // @@protoc_insertion_point(class_scope:variations.Study.Experiment.OverrideUIString)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
        uint32_t name_hash_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_study_2eproto;
};
// -------------------------------------------------------------------

class Study_Experiment final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:variations.Study.Experiment) */ {
public:
    inline Study_Experiment()
        : Study_Experiment(nullptr)
    {
    }
    ~Study_Experiment() override;
    explicit PROTOBUF_CONSTEXPR Study_Experiment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Study_Experiment(const Study_Experiment& from);
    Study_Experiment(Study_Experiment&& from) noexcept
        : Study_Experiment()
    {
        *this = ::std::move(from);
    }

    inline Study_Experiment& operator=(const Study_Experiment& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Study_Experiment& operator=(Study_Experiment&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Study_Experiment& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Study_Experiment* internal_default_instance()
    {
        return reinterpret_cast<const Study_Experiment*>(&_Study_Experiment_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(Study_Experiment& a, Study_Experiment& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Study_Experiment* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Study_Experiment* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Study_Experiment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Study_Experiment>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Study_Experiment& from);
    void MergeFrom(const Study_Experiment& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Study_Experiment* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "variations.Study.Experiment";
    }

protected:
    explicit Study_Experiment(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef Study_Experiment_Param Param;
    typedef Study_Experiment_FeatureAssociation FeatureAssociation;
    typedef Study_Experiment_OverrideUIString OverrideUIString;

    typedef Study_Experiment_Type Type;
    static constexpr Type NORMAL = Study_Experiment_Type_NORMAL;
    static constexpr Type IGNORE_CHANGE = Study_Experiment_Type_IGNORE_CHANGE;
    static constexpr Type KILL_BEST_EFFORT = Study_Experiment_Type_KILL_BEST_EFFORT;
    static constexpr Type KILL_CRITICAL = Study_Experiment_Type_KILL_CRITICAL;
    static inline bool Type_IsValid(int value)
    {
        return Study_Experiment_Type_IsValid(value);
    }
    static constexpr Type Type_MIN = Study_Experiment_Type_Type_MIN;
    static constexpr Type Type_MAX = Study_Experiment_Type_Type_MAX;
    static constexpr int Type_ARRAYSIZE = Study_Experiment_Type_Type_ARRAYSIZE;
    template <typename T> static inline const std::string& Type_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Type>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Type_Name.");
        return Study_Experiment_Type_Name(enum_t_value);
    }
    static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type* value)
    {
        return Study_Experiment_Type_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kParamFieldNumber = 6,
        kOverrideUiStringFieldNumber = 9,
        kNameFieldNumber = 1,
        kForcingFlagFieldNumber = 5,
        kFeatureAssociationFieldNumber = 12,
        kGoogleWebExperimentIdFieldNumber = 3,
        kProbabilityWeightFieldNumber = 2,
        kTypeFieldNumber = 7,
        kGoogleWebTriggerExperimentIdFieldNumber = 8,
        kGoogleAppExperimentIdFieldNumber = 15,
        kGoogleWebVisibilityFieldNumber = 16,
    };
    // repeated .variations.Study.Experiment.Param param = 6;
    int param_size() const;

private:
    int _internal_param_size() const;

public:
    void clear_param();
    ::variations::Study_Experiment_Param* mutable_param(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment_Param>* mutable_param();

private:
    const ::variations::Study_Experiment_Param& _internal_param(int index) const;
    ::variations::Study_Experiment_Param* _internal_add_param();

public:
    const ::variations::Study_Experiment_Param& param(int index) const;
    ::variations::Study_Experiment_Param* add_param();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment_Param>& param() const;

    // repeated .variations.Study.Experiment.OverrideUIString override_ui_string = 9;
    int override_ui_string_size() const;

private:
    int _internal_override_ui_string_size() const;

public:
    void clear_override_ui_string();
    ::variations::Study_Experiment_OverrideUIString* mutable_override_ui_string(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment_OverrideUIString>* mutable_override_ui_string();

private:
    const ::variations::Study_Experiment_OverrideUIString& _internal_override_ui_string(int index) const;
    ::variations::Study_Experiment_OverrideUIString* _internal_add_override_ui_string();

public:
    const ::variations::Study_Experiment_OverrideUIString& override_ui_string(int index) const;
    ::variations::Study_Experiment_OverrideUIString* add_override_ui_string();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment_OverrideUIString>& override_ui_string() const;

    // required string name = 1;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // optional string forcing_flag = 5;
    bool has_forcing_flag() const;

private:
    bool _internal_has_forcing_flag() const;

public:
    void clear_forcing_flag();
    const std::string& forcing_flag() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_forcing_flag(ArgT0&& arg0, ArgT... args);
    std::string* mutable_forcing_flag();
    PROTOBUF_NODISCARD std::string* release_forcing_flag();
    void set_allocated_forcing_flag(std::string* forcing_flag);

private:
    const std::string& _internal_forcing_flag() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_forcing_flag(const std::string& value);
    std::string* _internal_mutable_forcing_flag();

public:
    // optional .variations.Study.Experiment.FeatureAssociation feature_association = 12;
    bool has_feature_association() const;

private:
    bool _internal_has_feature_association() const;

public:
    void clear_feature_association();
    const ::variations::Study_Experiment_FeatureAssociation& feature_association() const;
    PROTOBUF_NODISCARD ::variations::Study_Experiment_FeatureAssociation* release_feature_association();
    ::variations::Study_Experiment_FeatureAssociation* mutable_feature_association();
    void set_allocated_feature_association(::variations::Study_Experiment_FeatureAssociation* feature_association);

private:
    const ::variations::Study_Experiment_FeatureAssociation& _internal_feature_association() const;
    ::variations::Study_Experiment_FeatureAssociation* _internal_mutable_feature_association();

public:
    void unsafe_arena_set_allocated_feature_association(::variations::Study_Experiment_FeatureAssociation* feature_association);
    ::variations::Study_Experiment_FeatureAssociation* unsafe_arena_release_feature_association();

    // optional uint64 google_web_experiment_id = 3;
    bool has_google_web_experiment_id() const;

private:
    bool _internal_has_google_web_experiment_id() const;

public:
    void clear_google_web_experiment_id();
    uint64_t google_web_experiment_id() const;
    void set_google_web_experiment_id(uint64_t value);

private:
    uint64_t _internal_google_web_experiment_id() const;
    void _internal_set_google_web_experiment_id(uint64_t value);

public:
    // required uint32 probability_weight = 2;
    bool has_probability_weight() const;

private:
    bool _internal_has_probability_weight() const;

public:
    void clear_probability_weight();
    uint32_t probability_weight() const;
    void set_probability_weight(uint32_t value);

private:
    uint32_t _internal_probability_weight() const;
    void _internal_set_probability_weight(uint32_t value);

public:
    // optional .variations.Study.Experiment.Type type = 7 [default = NORMAL];
    bool has_type() const;

private:
    bool _internal_has_type() const;

public:
    void clear_type();
    ::variations::Study_Experiment_Type type() const;
    void set_type(::variations::Study_Experiment_Type value);

private:
    ::variations::Study_Experiment_Type _internal_type() const;
    void _internal_set_type(::variations::Study_Experiment_Type value);

public:
    // optional uint64 google_web_trigger_experiment_id = 8;
    bool has_google_web_trigger_experiment_id() const;

private:
    bool _internal_has_google_web_trigger_experiment_id() const;

public:
    void clear_google_web_trigger_experiment_id();
    uint64_t google_web_trigger_experiment_id() const;
    void set_google_web_trigger_experiment_id(uint64_t value);

private:
    uint64_t _internal_google_web_trigger_experiment_id() const;
    void _internal_set_google_web_trigger_experiment_id(uint64_t value);

public:
    // optional uint64 google_app_experiment_id = 15;
    bool has_google_app_experiment_id() const;

private:
    bool _internal_has_google_app_experiment_id() const;

public:
    void clear_google_app_experiment_id();
    uint64_t google_app_experiment_id() const;
    void set_google_app_experiment_id(uint64_t value);

private:
    uint64_t _internal_google_app_experiment_id() const;
    void _internal_set_google_app_experiment_id(uint64_t value);

public:
    // optional .variations.Study.GoogleWebVisibility google_web_visibility = 16;
    bool has_google_web_visibility() const;

private:
    bool _internal_has_google_web_visibility() const;

public:
    void clear_google_web_visibility();
    ::variations::Study_GoogleWebVisibility google_web_visibility() const;
    void set_google_web_visibility(::variations::Study_GoogleWebVisibility value);

private:
    ::variations::Study_GoogleWebVisibility _internal_google_web_visibility() const;
    void _internal_set_google_web_visibility(::variations::Study_GoogleWebVisibility value);

public:
    // @@protoc_insertion_point(class_scope:variations.Study.Experiment)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment_Param> param_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment_OverrideUIString> override_ui_string_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr forcing_flag_;
        ::variations::Study_Experiment_FeatureAssociation* feature_association_;
        uint64_t google_web_experiment_id_;
        uint32_t probability_weight_;
        int type_;
        uint64_t google_web_trigger_experiment_id_;
        uint64_t google_app_experiment_id_;
        int google_web_visibility_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_study_2eproto;
};
// -------------------------------------------------------------------

class Study_Filter final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:variations.Study.Filter) */ {
public:
    inline Study_Filter()
        : Study_Filter(nullptr)
    {
    }
    ~Study_Filter() override;
    explicit PROTOBUF_CONSTEXPR Study_Filter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Study_Filter(const Study_Filter& from);
    Study_Filter(Study_Filter&& from) noexcept
        : Study_Filter()
    {
        *this = ::std::move(from);
    }

    inline Study_Filter& operator=(const Study_Filter& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Study_Filter& operator=(Study_Filter&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Study_Filter& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Study_Filter* internal_default_instance()
    {
        return reinterpret_cast<const Study_Filter*>(&_Study_Filter_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(Study_Filter& a, Study_Filter& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Study_Filter* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Study_Filter* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Study_Filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Study_Filter>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Study_Filter& from);
    void MergeFrom(const Study_Filter& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Study_Filter* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "variations.Study.Filter";
    }

protected:
    explicit Study_Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kChannelFieldNumber = 4,
        kPlatformFieldNumber = 5,
        kLocaleFieldNumber = 6,
        kFormFactorFieldNumber = 7,
        kHardwareClassFieldNumber = 8,
        kExcludeHardwareClassFieldNumber = 9,
        kCountryFieldNumber = 10,
        kExcludeCountryFieldNumber = 11,
        kExcludeLocaleFieldNumber = 12,
        kExcludeFormFactorFieldNumber = 14,
        kCpuArchitectureFieldNumber = 20,
        kExcludeCpuArchitectureFieldNumber = 21,
        kGoogleGroupFieldNumber = 22,
        kExcludeGoogleGroupFieldNumber = 23,
        kMinVersionFieldNumber = 2,
        kMaxVersionFieldNumber = 3,
        kMinOsVersionFieldNumber = 16,
        kMaxOsVersionFieldNumber = 17,
        kStartDateFieldNumber = 1,
        kEndDateFieldNumber = 13,
        kIsLowEndDeviceFieldNumber = 15,
        kIsEnterpriseFieldNumber = 18,
        kPolicyRestrictionFieldNumber = 19,
    };
    // repeated .variations.Study.Channel channel = 4;
    int channel_size() const;

private:
    int _internal_channel_size() const;

public:
    void clear_channel();

private:
    ::variations::Study_Channel _internal_channel(int index) const;
    void _internal_add_channel(::variations::Study_Channel value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_channel();

public:
    ::variations::Study_Channel channel(int index) const;
    void set_channel(int index, ::variations::Study_Channel value);
    void add_channel(::variations::Study_Channel value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& channel() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_channel();

    // repeated .variations.Study.Platform platform = 5;
    int platform_size() const;

private:
    int _internal_platform_size() const;

public:
    void clear_platform();

private:
    ::variations::Study_Platform _internal_platform(int index) const;
    void _internal_add_platform(::variations::Study_Platform value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_platform();

public:
    ::variations::Study_Platform platform(int index) const;
    void set_platform(int index, ::variations::Study_Platform value);
    void add_platform(::variations::Study_Platform value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& platform() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_platform();

    // repeated string locale = 6;
    int locale_size() const;

private:
    int _internal_locale_size() const;

public:
    void clear_locale();
    const std::string& locale(int index) const;
    std::string* mutable_locale(int index);
    void set_locale(int index, const std::string& value);
    void set_locale(int index, std::string&& value);
    void set_locale(int index, const char* value);
    void set_locale(int index, const char* value, size_t size);
    std::string* add_locale();
    void add_locale(const std::string& value);
    void add_locale(std::string&& value);
    void add_locale(const char* value);
    void add_locale(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& locale() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_locale();

private:
    const std::string& _internal_locale(int index) const;
    std::string* _internal_add_locale();

public:
    // repeated .variations.Study.FormFactor form_factor = 7;
    int form_factor_size() const;

private:
    int _internal_form_factor_size() const;

public:
    void clear_form_factor();

private:
    ::variations::Study_FormFactor _internal_form_factor(int index) const;
    void _internal_add_form_factor(::variations::Study_FormFactor value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_form_factor();

public:
    ::variations::Study_FormFactor form_factor(int index) const;
    void set_form_factor(int index, ::variations::Study_FormFactor value);
    void add_form_factor(::variations::Study_FormFactor value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& form_factor() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_form_factor();

    // repeated string hardware_class = 8;
    int hardware_class_size() const;

private:
    int _internal_hardware_class_size() const;

public:
    void clear_hardware_class();
    const std::string& hardware_class(int index) const;
    std::string* mutable_hardware_class(int index);
    void set_hardware_class(int index, const std::string& value);
    void set_hardware_class(int index, std::string&& value);
    void set_hardware_class(int index, const char* value);
    void set_hardware_class(int index, const char* value, size_t size);
    std::string* add_hardware_class();
    void add_hardware_class(const std::string& value);
    void add_hardware_class(std::string&& value);
    void add_hardware_class(const char* value);
    void add_hardware_class(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hardware_class() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hardware_class();

private:
    const std::string& _internal_hardware_class(int index) const;
    std::string* _internal_add_hardware_class();

public:
    // repeated string exclude_hardware_class = 9;
    int exclude_hardware_class_size() const;

private:
    int _internal_exclude_hardware_class_size() const;

public:
    void clear_exclude_hardware_class();
    const std::string& exclude_hardware_class(int index) const;
    std::string* mutable_exclude_hardware_class(int index);
    void set_exclude_hardware_class(int index, const std::string& value);
    void set_exclude_hardware_class(int index, std::string&& value);
    void set_exclude_hardware_class(int index, const char* value);
    void set_exclude_hardware_class(int index, const char* value, size_t size);
    std::string* add_exclude_hardware_class();
    void add_exclude_hardware_class(const std::string& value);
    void add_exclude_hardware_class(std::string&& value);
    void add_exclude_hardware_class(const char* value);
    void add_exclude_hardware_class(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& exclude_hardware_class() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_exclude_hardware_class();

private:
    const std::string& _internal_exclude_hardware_class(int index) const;
    std::string* _internal_add_exclude_hardware_class();

public:
    // repeated string country = 10;
    int country_size() const;

private:
    int _internal_country_size() const;

public:
    void clear_country();
    const std::string& country(int index) const;
    std::string* mutable_country(int index);
    void set_country(int index, const std::string& value);
    void set_country(int index, std::string&& value);
    void set_country(int index, const char* value);
    void set_country(int index, const char* value, size_t size);
    std::string* add_country();
    void add_country(const std::string& value);
    void add_country(std::string&& value);
    void add_country(const char* value);
    void add_country(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& country() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_country();

private:
    const std::string& _internal_country(int index) const;
    std::string* _internal_add_country();

public:
    // repeated string exclude_country = 11;
    int exclude_country_size() const;

private:
    int _internal_exclude_country_size() const;

public:
    void clear_exclude_country();
    const std::string& exclude_country(int index) const;
    std::string* mutable_exclude_country(int index);
    void set_exclude_country(int index, const std::string& value);
    void set_exclude_country(int index, std::string&& value);
    void set_exclude_country(int index, const char* value);
    void set_exclude_country(int index, const char* value, size_t size);
    std::string* add_exclude_country();
    void add_exclude_country(const std::string& value);
    void add_exclude_country(std::string&& value);
    void add_exclude_country(const char* value);
    void add_exclude_country(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& exclude_country() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_exclude_country();

private:
    const std::string& _internal_exclude_country(int index) const;
    std::string* _internal_add_exclude_country();

public:
    // repeated string exclude_locale = 12;
    int exclude_locale_size() const;

private:
    int _internal_exclude_locale_size() const;

public:
    void clear_exclude_locale();
    const std::string& exclude_locale(int index) const;
    std::string* mutable_exclude_locale(int index);
    void set_exclude_locale(int index, const std::string& value);
    void set_exclude_locale(int index, std::string&& value);
    void set_exclude_locale(int index, const char* value);
    void set_exclude_locale(int index, const char* value, size_t size);
    std::string* add_exclude_locale();
    void add_exclude_locale(const std::string& value);
    void add_exclude_locale(std::string&& value);
    void add_exclude_locale(const char* value);
    void add_exclude_locale(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& exclude_locale() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_exclude_locale();

private:
    const std::string& _internal_exclude_locale(int index) const;
    std::string* _internal_add_exclude_locale();

public:
    // repeated .variations.Study.FormFactor exclude_form_factor = 14;
    int exclude_form_factor_size() const;

private:
    int _internal_exclude_form_factor_size() const;

public:
    void clear_exclude_form_factor();

private:
    ::variations::Study_FormFactor _internal_exclude_form_factor(int index) const;
    void _internal_add_exclude_form_factor(::variations::Study_FormFactor value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_exclude_form_factor();

public:
    ::variations::Study_FormFactor exclude_form_factor(int index) const;
    void set_exclude_form_factor(int index, ::variations::Study_FormFactor value);
    void add_exclude_form_factor(::variations::Study_FormFactor value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& exclude_form_factor() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_exclude_form_factor();

    // repeated .variations.Study.CpuArchitecture cpu_architecture = 20;
    int cpu_architecture_size() const;

private:
    int _internal_cpu_architecture_size() const;

public:
    void clear_cpu_architecture();

private:
    ::variations::Study_CpuArchitecture _internal_cpu_architecture(int index) const;
    void _internal_add_cpu_architecture(::variations::Study_CpuArchitecture value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_cpu_architecture();

public:
    ::variations::Study_CpuArchitecture cpu_architecture(int index) const;
    void set_cpu_architecture(int index, ::variations::Study_CpuArchitecture value);
    void add_cpu_architecture(::variations::Study_CpuArchitecture value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& cpu_architecture() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_cpu_architecture();

    // repeated .variations.Study.CpuArchitecture exclude_cpu_architecture = 21;
    int exclude_cpu_architecture_size() const;

private:
    int _internal_exclude_cpu_architecture_size() const;

public:
    void clear_exclude_cpu_architecture();

private:
    ::variations::Study_CpuArchitecture _internal_exclude_cpu_architecture(int index) const;
    void _internal_add_exclude_cpu_architecture(::variations::Study_CpuArchitecture value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_exclude_cpu_architecture();

public:
    ::variations::Study_CpuArchitecture exclude_cpu_architecture(int index) const;
    void set_exclude_cpu_architecture(int index, ::variations::Study_CpuArchitecture value);
    void add_exclude_cpu_architecture(::variations::Study_CpuArchitecture value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& exclude_cpu_architecture() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_exclude_cpu_architecture();

    // repeated int64 google_group = 22 [packed = true];
    int google_group_size() const;

private:
    int _internal_google_group_size() const;

public:
    void clear_google_group();

private:
    int64_t _internal_google_group(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>& _internal_google_group() const;
    void _internal_add_google_group(int64_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>* _internal_mutable_google_group();

public:
    int64_t google_group(int index) const;
    void set_google_group(int index, int64_t value);
    void add_google_group(int64_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>& google_group() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>* mutable_google_group();

    // repeated int64 exclude_google_group = 23 [packed = true];
    int exclude_google_group_size() const;

private:
    int _internal_exclude_google_group_size() const;

public:
    void clear_exclude_google_group();

private:
    int64_t _internal_exclude_google_group(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>& _internal_exclude_google_group() const;
    void _internal_add_exclude_google_group(int64_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>* _internal_mutable_exclude_google_group();

public:
    int64_t exclude_google_group(int index) const;
    void set_exclude_google_group(int index, int64_t value);
    void add_exclude_google_group(int64_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>& exclude_google_group() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>* mutable_exclude_google_group();

    // optional string min_version = 2;
    bool has_min_version() const;

private:
    bool _internal_has_min_version() const;

public:
    void clear_min_version();
    const std::string& min_version() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_min_version(ArgT0&& arg0, ArgT... args);
    std::string* mutable_min_version();
    PROTOBUF_NODISCARD std::string* release_min_version();
    void set_allocated_min_version(std::string* min_version);

private:
    const std::string& _internal_min_version() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_version(const std::string& value);
    std::string* _internal_mutable_min_version();

public:
    // optional string max_version = 3;
    bool has_max_version() const;

private:
    bool _internal_has_max_version() const;

public:
    void clear_max_version();
    const std::string& max_version() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_max_version(ArgT0&& arg0, ArgT... args);
    std::string* mutable_max_version();
    PROTOBUF_NODISCARD std::string* release_max_version();
    void set_allocated_max_version(std::string* max_version);

private:
    const std::string& _internal_max_version() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_version(const std::string& value);
    std::string* _internal_mutable_max_version();

public:
    // optional string min_os_version = 16;
    bool has_min_os_version() const;

private:
    bool _internal_has_min_os_version() const;

public:
    void clear_min_os_version();
    const std::string& min_os_version() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_min_os_version(ArgT0&& arg0, ArgT... args);
    std::string* mutable_min_os_version();
    PROTOBUF_NODISCARD std::string* release_min_os_version();
    void set_allocated_min_os_version(std::string* min_os_version);

private:
    const std::string& _internal_min_os_version() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_min_os_version(const std::string& value);
    std::string* _internal_mutable_min_os_version();

public:
    // optional string max_os_version = 17;
    bool has_max_os_version() const;

private:
    bool _internal_has_max_os_version() const;

public:
    void clear_max_os_version();
    const std::string& max_os_version() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_max_os_version(ArgT0&& arg0, ArgT... args);
    std::string* mutable_max_os_version();
    PROTOBUF_NODISCARD std::string* release_max_os_version();
    void set_allocated_max_os_version(std::string* max_os_version);

private:
    const std::string& _internal_max_os_version() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_max_os_version(const std::string& value);
    std::string* _internal_mutable_max_os_version();

public:
    // optional int64 start_date = 1;
    bool has_start_date() const;

private:
    bool _internal_has_start_date() const;

public:
    void clear_start_date();
    int64_t start_date() const;
    void set_start_date(int64_t value);

private:
    int64_t _internal_start_date() const;
    void _internal_set_start_date(int64_t value);

public:
    // optional int64 end_date = 13;
    bool has_end_date() const;

private:
    bool _internal_has_end_date() const;

public:
    void clear_end_date();
    int64_t end_date() const;
    void set_end_date(int64_t value);

private:
    int64_t _internal_end_date() const;
    void _internal_set_end_date(int64_t value);

public:
    // optional bool is_low_end_device = 15;
    bool has_is_low_end_device() const;

private:
    bool _internal_has_is_low_end_device() const;

public:
    void clear_is_low_end_device();
    bool is_low_end_device() const;
    void set_is_low_end_device(bool value);

private:
    bool _internal_is_low_end_device() const;
    void _internal_set_is_low_end_device(bool value);

public:
    // optional bool is_enterprise = 18;
    bool has_is_enterprise() const;

private:
    bool _internal_has_is_enterprise() const;

public:
    void clear_is_enterprise();
    bool is_enterprise() const;
    void set_is_enterprise(bool value);

private:
    bool _internal_is_enterprise() const;
    void _internal_set_is_enterprise(bool value);

public:
    // optional .variations.Study.PolicyRestriction policy_restriction = 19 [default = NONE];
    bool has_policy_restriction() const;

private:
    bool _internal_has_policy_restriction() const;

public:
    void clear_policy_restriction();
    ::variations::Study_PolicyRestriction policy_restriction() const;
    void set_policy_restriction(::variations::Study_PolicyRestriction value);

private:
    ::variations::Study_PolicyRestriction _internal_policy_restriction() const;
    void _internal_set_policy_restriction(::variations::Study_PolicyRestriction value);

public:
    // @@protoc_insertion_point(class_scope:variations.Study.Filter)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> channel_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> platform_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> locale_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> form_factor_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hardware_class_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> exclude_hardware_class_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> country_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> exclude_country_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> exclude_locale_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> exclude_form_factor_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> cpu_architecture_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> exclude_cpu_architecture_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t> google_group_;
        mutable std::atomic<int> _google_group_cached_byte_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t> exclude_google_group_;
        mutable std::atomic<int> _exclude_google_group_cached_byte_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_version_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_version_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_os_version_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_os_version_;
        int64_t start_date_;
        int64_t end_date_;
        bool is_low_end_device_;
        bool is_enterprise_;
        int policy_restriction_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_study_2eproto;
};
// -------------------------------------------------------------------

class Study final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:variations.Study) */ {
public:
    inline Study()
        : Study(nullptr)
    {
    }
    ~Study() override;
    explicit PROTOBUF_CONSTEXPR Study(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Study(const Study& from);
    Study(Study&& from) noexcept
        : Study()
    {
        *this = ::std::move(from);
    }

    inline Study& operator=(const Study& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Study& operator=(Study&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Study& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Study* internal_default_instance()
    {
        return reinterpret_cast<const Study*>(&_Study_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(Study& a, Study& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Study* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Study* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Study* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Study>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Study& from);
    void MergeFrom(const Study& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Study* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "variations.Study";
    }

protected:
    explicit Study(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef Study_Experiment Experiment;
    typedef Study_Filter Filter;

    typedef Study_Consistency Consistency;
    static constexpr Consistency SESSION = Study_Consistency_SESSION;
    static constexpr Consistency PERMANENT = Study_Consistency_PERMANENT;
    static inline bool Consistency_IsValid(int value)
    {
        return Study_Consistency_IsValid(value);
    }
    static constexpr Consistency Consistency_MIN = Study_Consistency_Consistency_MIN;
    static constexpr Consistency Consistency_MAX = Study_Consistency_Consistency_MAX;
    static constexpr int Consistency_ARRAYSIZE = Study_Consistency_Consistency_ARRAYSIZE;
    template <typename T> static inline const std::string& Consistency_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Consistency>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Consistency_Name.");
        return Study_Consistency_Name(enum_t_value);
    }
    static inline bool Consistency_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Consistency* value)
    {
        return Study_Consistency_Parse(name, value);
    }

    typedef Study_GoogleWebVisibility GoogleWebVisibility;
    static constexpr GoogleWebVisibility ANY = Study_GoogleWebVisibility_ANY;
    static constexpr GoogleWebVisibility FIRST_PARTY = Study_GoogleWebVisibility_FIRST_PARTY;
    static inline bool GoogleWebVisibility_IsValid(int value)
    {
        return Study_GoogleWebVisibility_IsValid(value);
    }
    static constexpr GoogleWebVisibility GoogleWebVisibility_MIN = Study_GoogleWebVisibility_GoogleWebVisibility_MIN;
    static constexpr GoogleWebVisibility GoogleWebVisibility_MAX = Study_GoogleWebVisibility_GoogleWebVisibility_MAX;
    static constexpr int GoogleWebVisibility_ARRAYSIZE = Study_GoogleWebVisibility_GoogleWebVisibility_ARRAYSIZE;
    template <typename T> static inline const std::string& GoogleWebVisibility_Name(T enum_t_value)
    {
        static_assert(
            ::std::is_same<T, GoogleWebVisibility>::value || ::std::is_integral<T>::value, "Incorrect type passed to function GoogleWebVisibility_Name.");
        return Study_GoogleWebVisibility_Name(enum_t_value);
    }
    static inline bool GoogleWebVisibility_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GoogleWebVisibility* value)
    {
        return Study_GoogleWebVisibility_Parse(name, value);
    }

    typedef Study_Channel Channel;
    static constexpr Channel UNKNOWN = Study_Channel_UNKNOWN;
    static constexpr Channel CANARY = Study_Channel_CANARY;
    static constexpr Channel DEV = Study_Channel_DEV;
    static constexpr Channel BETA = Study_Channel_BETA;
    static constexpr Channel STABLE = Study_Channel_STABLE;
    static inline bool Channel_IsValid(int value)
    {
        return Study_Channel_IsValid(value);
    }
    static constexpr Channel Channel_MIN = Study_Channel_Channel_MIN;
    static constexpr Channel Channel_MAX = Study_Channel_Channel_MAX;
    static constexpr int Channel_ARRAYSIZE = Study_Channel_Channel_ARRAYSIZE;
    template <typename T> static inline const std::string& Channel_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Channel>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Channel_Name.");
        return Study_Channel_Name(enum_t_value);
    }
    static inline bool Channel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Channel* value)
    {
        return Study_Channel_Parse(name, value);
    }

    typedef Study_Platform Platform;
    static constexpr Platform PLATFORM_WINDOWS = Study_Platform_PLATFORM_WINDOWS;
    static constexpr Platform PLATFORM_MAC = Study_Platform_PLATFORM_MAC;
    static constexpr Platform PLATFORM_LINUX = Study_Platform_PLATFORM_LINUX;
    static constexpr Platform PLATFORM_CHROMEOS = Study_Platform_PLATFORM_CHROMEOS;
    static constexpr Platform PLATFORM_ANDROID = Study_Platform_PLATFORM_ANDROID;
    static constexpr Platform PLATFORM_IOS = Study_Platform_PLATFORM_IOS;
    static constexpr Platform PLATFORM_ANDROID_WEBVIEW = Study_Platform_PLATFORM_ANDROID_WEBVIEW;
    static constexpr Platform PLATFORM_FUCHSIA = Study_Platform_PLATFORM_FUCHSIA;
    static constexpr Platform PLATFORM_ANDROID_WEBLAYER = Study_Platform_PLATFORM_ANDROID_WEBLAYER;
    static constexpr Platform PLATFORM_CHROMEOS_LACROS = Study_Platform_PLATFORM_CHROMEOS_LACROS;
    static inline bool Platform_IsValid(int value)
    {
        return Study_Platform_IsValid(value);
    }
    static constexpr Platform Platform_MIN = Study_Platform_Platform_MIN;
    static constexpr Platform Platform_MAX = Study_Platform_Platform_MAX;
    static constexpr int Platform_ARRAYSIZE = Study_Platform_Platform_ARRAYSIZE;
    template <typename T> static inline const std::string& Platform_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Platform>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Platform_Name.");
        return Study_Platform_Name(enum_t_value);
    }
    static inline bool Platform_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Platform* value)
    {
        return Study_Platform_Parse(name, value);
    }

    typedef Study_FormFactor FormFactor;
    static constexpr FormFactor DESKTOP = Study_FormFactor_DESKTOP;
    static constexpr FormFactor PHONE = Study_FormFactor_PHONE;
    static constexpr FormFactor TABLET = Study_FormFactor_TABLET;
    static constexpr FormFactor KIOSK = Study_FormFactor_KIOSK;
    static constexpr FormFactor MEET_DEVICE = Study_FormFactor_MEET_DEVICE;
    static constexpr FormFactor TV = Study_FormFactor_TV;
    static constexpr FormFactor AUTOMOTIVE = Study_FormFactor_AUTOMOTIVE;
    static constexpr FormFactor FOLDABLE = Study_FormFactor_FOLDABLE;
    static inline bool FormFactor_IsValid(int value)
    {
        return Study_FormFactor_IsValid(value);
    }
    static constexpr FormFactor FormFactor_MIN = Study_FormFactor_FormFactor_MIN;
    static constexpr FormFactor FormFactor_MAX = Study_FormFactor_FormFactor_MAX;
    static constexpr int FormFactor_ARRAYSIZE = Study_FormFactor_FormFactor_ARRAYSIZE;
    template <typename T> static inline const std::string& FormFactor_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, FormFactor>::value || ::std::is_integral<T>::value, "Incorrect type passed to function FormFactor_Name.");
        return Study_FormFactor_Name(enum_t_value);
    }
    static inline bool FormFactor_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FormFactor* value)
    {
        return Study_FormFactor_Parse(name, value);
    }

    typedef Study_CpuArchitecture CpuArchitecture;
    static constexpr CpuArchitecture X86_64 = Study_CpuArchitecture_X86_64;
    static constexpr CpuArchitecture ARM64 = Study_CpuArchitecture_ARM64;
    static constexpr CpuArchitecture X86_32 = Study_CpuArchitecture_X86_32;
    static constexpr CpuArchitecture ARM32 = Study_CpuArchitecture_ARM32;
    static constexpr CpuArchitecture TRANSLATED_X86_64 = Study_CpuArchitecture_TRANSLATED_X86_64;
    static inline bool CpuArchitecture_IsValid(int value)
    {
        return Study_CpuArchitecture_IsValid(value);
    }
    static constexpr CpuArchitecture CpuArchitecture_MIN = Study_CpuArchitecture_CpuArchitecture_MIN;
    static constexpr CpuArchitecture CpuArchitecture_MAX = Study_CpuArchitecture_CpuArchitecture_MAX;
    static constexpr int CpuArchitecture_ARRAYSIZE = Study_CpuArchitecture_CpuArchitecture_ARRAYSIZE;
    template <typename T> static inline const std::string& CpuArchitecture_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, CpuArchitecture>::value || ::std::is_integral<T>::value, "Incorrect type passed to function CpuArchitecture_Name.");
        return Study_CpuArchitecture_Name(enum_t_value);
    }
    static inline bool CpuArchitecture_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CpuArchitecture* value)
    {
        return Study_CpuArchitecture_Parse(name, value);
    }

    typedef Study_OptionalBool OptionalBool;
    static constexpr OptionalBool OPTIONAL_BOOL_MISSING = Study_OptionalBool_OPTIONAL_BOOL_MISSING;
    static constexpr OptionalBool OPTIONAL_BOOL_TRUE = Study_OptionalBool_OPTIONAL_BOOL_TRUE;
    static constexpr OptionalBool OPTIONAL_BOOL_FALSE = Study_OptionalBool_OPTIONAL_BOOL_FALSE;
    static inline bool OptionalBool_IsValid(int value)
    {
        return Study_OptionalBool_IsValid(value);
    }
    static constexpr OptionalBool OptionalBool_MIN = Study_OptionalBool_OptionalBool_MIN;
    static constexpr OptionalBool OptionalBool_MAX = Study_OptionalBool_OptionalBool_MAX;
    static constexpr int OptionalBool_ARRAYSIZE = Study_OptionalBool_OptionalBool_ARRAYSIZE;
    template <typename T> static inline const std::string& OptionalBool_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, OptionalBool>::value || ::std::is_integral<T>::value, "Incorrect type passed to function OptionalBool_Name.");
        return Study_OptionalBool_Name(enum_t_value);
    }
    static inline bool OptionalBool_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OptionalBool* value)
    {
        return Study_OptionalBool_Parse(name, value);
    }

    typedef Study_PolicyRestriction PolicyRestriction;
    static constexpr PolicyRestriction NONE = Study_PolicyRestriction_NONE;
    static constexpr PolicyRestriction CRITICAL = Study_PolicyRestriction_CRITICAL;
    static constexpr PolicyRestriction CRITICAL_ONLY = Study_PolicyRestriction_CRITICAL_ONLY;
    static inline bool PolicyRestriction_IsValid(int value)
    {
        return Study_PolicyRestriction_IsValid(value);
    }
    static constexpr PolicyRestriction PolicyRestriction_MIN = Study_PolicyRestriction_PolicyRestriction_MIN;
    static constexpr PolicyRestriction PolicyRestriction_MAX = Study_PolicyRestriction_PolicyRestriction_MAX;
    static constexpr int PolicyRestriction_ARRAYSIZE = Study_PolicyRestriction_PolicyRestriction_ARRAYSIZE;
    template <typename T> static inline const std::string& PolicyRestriction_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, PolicyRestriction>::value || ::std::is_integral<T>::value, "Incorrect type passed to function PolicyRestriction_Name.");
        return Study_PolicyRestriction_Name(enum_t_value);
    }
    static inline bool PolicyRestriction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PolicyRestriction* value)
    {
        return Study_PolicyRestriction_Parse(name, value);
    }

    typedef Study_ActivationType ActivationType;
    static constexpr ActivationType ACTIVATE_ON_QUERY = Study_ActivationType_ACTIVATE_ON_QUERY;
    static constexpr ActivationType ACTIVATE_ON_STARTUP = Study_ActivationType_ACTIVATE_ON_STARTUP;
    static inline bool ActivationType_IsValid(int value)
    {
        return Study_ActivationType_IsValid(value);
    }
    static constexpr ActivationType ActivationType_MIN = Study_ActivationType_ActivationType_MIN;
    static constexpr ActivationType ActivationType_MAX = Study_ActivationType_ActivationType_MAX;
    static constexpr int ActivationType_ARRAYSIZE = Study_ActivationType_ActivationType_ARRAYSIZE;
    template <typename T> static inline const std::string& ActivationType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ActivationType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ActivationType_Name.");
        return Study_ActivationType_Name(enum_t_value);
    }
    static inline bool ActivationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActivationType* value)
    {
        return Study_ActivationType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kExperimentFieldNumber = 9,
        kNameFieldNumber = 1,
        kDefaultExperimentNameFieldNumber = 8,
        kFilterFieldNumber = 10,
        kLayerFieldNumber = 16,
        kExpiryDateFieldNumber = 3,
        kConsistencyFieldNumber = 7,
        kRandomizationSeedFieldNumber = 11,
        kActivationTypeFieldNumber = 12,
    };
    // repeated .variations.Study.Experiment experiment = 9;
    int experiment_size() const;

private:
    int _internal_experiment_size() const;

public:
    void clear_experiment();
    ::variations::Study_Experiment* mutable_experiment(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment>* mutable_experiment();

private:
    const ::variations::Study_Experiment& _internal_experiment(int index) const;
    ::variations::Study_Experiment* _internal_add_experiment();

public:
    const ::variations::Study_Experiment& experiment(int index) const;
    ::variations::Study_Experiment* add_experiment();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment>& experiment() const;

    // required string name = 1;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // optional string default_experiment_name = 8;
    bool has_default_experiment_name() const;

private:
    bool _internal_has_default_experiment_name() const;

public:
    void clear_default_experiment_name();
    const std::string& default_experiment_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_default_experiment_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_default_experiment_name();
    PROTOBUF_NODISCARD std::string* release_default_experiment_name();
    void set_allocated_default_experiment_name(std::string* default_experiment_name);

private:
    const std::string& _internal_default_experiment_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_experiment_name(const std::string& value);
    std::string* _internal_mutable_default_experiment_name();

public:
    // optional .variations.Study.Filter filter = 10;
    bool has_filter() const;

private:
    bool _internal_has_filter() const;

public:
    void clear_filter();
    const ::variations::Study_Filter& filter() const;
    PROTOBUF_NODISCARD ::variations::Study_Filter* release_filter();
    ::variations::Study_Filter* mutable_filter();
    void set_allocated_filter(::variations::Study_Filter* filter);

private:
    const ::variations::Study_Filter& _internal_filter() const;
    ::variations::Study_Filter* _internal_mutable_filter();

public:
    void unsafe_arena_set_allocated_filter(::variations::Study_Filter* filter);
    ::variations::Study_Filter* unsafe_arena_release_filter();

    // optional .variations.LayerMemberReference layer = 16;
    bool has_layer() const;

private:
    bool _internal_has_layer() const;

public:
    void clear_layer();
    const ::variations::LayerMemberReference& layer() const;
    PROTOBUF_NODISCARD ::variations::LayerMemberReference* release_layer();
    ::variations::LayerMemberReference* mutable_layer();
    void set_allocated_layer(::variations::LayerMemberReference* layer);

private:
    const ::variations::LayerMemberReference& _internal_layer() const;
    ::variations::LayerMemberReference* _internal_mutable_layer();

public:
    void unsafe_arena_set_allocated_layer(::variations::LayerMemberReference* layer);
    ::variations::LayerMemberReference* unsafe_arena_release_layer();

    // optional int64 expiry_date = 3;
    bool has_expiry_date() const;

private:
    bool _internal_has_expiry_date() const;

public:
    void clear_expiry_date();
    int64_t expiry_date() const;
    void set_expiry_date(int64_t value);

private:
    int64_t _internal_expiry_date() const;
    void _internal_set_expiry_date(int64_t value);

public:
    // optional .variations.Study.Consistency consistency = 7 [default = SESSION];
    bool has_consistency() const;

private:
    bool _internal_has_consistency() const;

public:
    void clear_consistency();
    ::variations::Study_Consistency consistency() const;
    void set_consistency(::variations::Study_Consistency value);

private:
    ::variations::Study_Consistency _internal_consistency() const;
    void _internal_set_consistency(::variations::Study_Consistency value);

public:
    // optional uint32 randomization_seed = 11;
    bool has_randomization_seed() const;

private:
    bool _internal_has_randomization_seed() const;

public:
    void clear_randomization_seed();
    uint32_t randomization_seed() const;
    void set_randomization_seed(uint32_t value);

private:
    uint32_t _internal_randomization_seed() const;
    void _internal_set_randomization_seed(uint32_t value);

public:
    // optional .variations.Study.ActivationType activation_type = 12;
    bool has_activation_type() const;

private:
    bool _internal_has_activation_type() const;

public:
    void clear_activation_type();
    ::variations::Study_ActivationType activation_type() const;
    void set_activation_type(::variations::Study_ActivationType value);

private:
    ::variations::Study_ActivationType _internal_activation_type() const;
    void _internal_set_activation_type(::variations::Study_ActivationType value);

public:
    // @@protoc_insertion_point(class_scope:variations.Study)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment> experiment_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_experiment_name_;
        ::variations::Study_Filter* filter_;
        ::variations::LayerMemberReference* layer_;
        int64_t expiry_date_;
        int consistency_;
        uint32_t randomization_seed_;
        int activation_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_study_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// Study_Experiment_Param

// optional string name = 1;
inline bool Study_Experiment_Param::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Study_Experiment_Param::has_name() const
{
    return _internal_has_name();
}
inline void Study_Experiment_Param::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Study_Experiment_Param::name() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.Param.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Study_Experiment_Param::set_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.Param.name)
}
inline std::string* Study_Experiment_Param::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:variations.Study.Experiment.Param.name)
    return _s;
}
inline const std::string& Study_Experiment_Param::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void Study_Experiment_Param::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Study_Experiment_Param::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Study_Experiment_Param::release_name()
{
    // @@protoc_insertion_point(field_release:variations.Study.Experiment.Param.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Study_Experiment_Param::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:variations.Study.Experiment.Param.name)
}

// optional string value = 2;
inline bool Study_Experiment_Param::_internal_has_value() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Study_Experiment_Param::has_value() const
{
    return _internal_has_value();
}
inline void Study_Experiment_Param::clear_value()
{
    _impl_.value_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Study_Experiment_Param::value() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.Param.value)
    return _internal_value();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Study_Experiment_Param::set_value(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.value_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.Param.value)
}
inline std::string* Study_Experiment_Param::mutable_value()
{
    std::string* _s = _internal_mutable_value();
    // @@protoc_insertion_point(field_mutable:variations.Study.Experiment.Param.value)
    return _s;
}
inline const std::string& Study_Experiment_Param::_internal_value() const
{
    return _impl_.value_.Get();
}
inline void Study_Experiment_Param::_internal_set_value(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Study_Experiment_Param::_internal_mutable_value()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Study_Experiment_Param::release_value()
{
    // @@protoc_insertion_point(field_release:variations.Study.Experiment.Param.value)
    if (!_internal_has_value()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Study_Experiment_Param::set_allocated_value(std::string* value)
{
    if (value != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:variations.Study.Experiment.Param.value)
}

// -------------------------------------------------------------------

// Study_Experiment_FeatureAssociation

// repeated string enable_feature = 1;
inline int Study_Experiment_FeatureAssociation::_internal_enable_feature_size() const
{
    return _impl_.enable_feature_.size();
}
inline int Study_Experiment_FeatureAssociation::enable_feature_size() const
{
    return _internal_enable_feature_size();
}
inline void Study_Experiment_FeatureAssociation::clear_enable_feature()
{
    _impl_.enable_feature_.Clear();
}
inline std::string* Study_Experiment_FeatureAssociation::add_enable_feature()
{
    std::string* _s = _internal_add_enable_feature();
    // @@protoc_insertion_point(field_add_mutable:variations.Study.Experiment.FeatureAssociation.enable_feature)
    return _s;
}
inline const std::string& Study_Experiment_FeatureAssociation::_internal_enable_feature(int index) const
{
    return _impl_.enable_feature_.Get(index);
}
inline const std::string& Study_Experiment_FeatureAssociation::enable_feature(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.FeatureAssociation.enable_feature)
    return _internal_enable_feature(index);
}
inline std::string* Study_Experiment_FeatureAssociation::mutable_enable_feature(int index)
{
    // @@protoc_insertion_point(field_mutable:variations.Study.Experiment.FeatureAssociation.enable_feature)
    return _impl_.enable_feature_.Mutable(index);
}
inline void Study_Experiment_FeatureAssociation::set_enable_feature(int index, const std::string& value)
{
    _impl_.enable_feature_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.FeatureAssociation.enable_feature)
}
inline void Study_Experiment_FeatureAssociation::set_enable_feature(int index, std::string&& value)
{
    _impl_.enable_feature_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.FeatureAssociation.enable_feature)
}
inline void Study_Experiment_FeatureAssociation::set_enable_feature(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.enable_feature_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:variations.Study.Experiment.FeatureAssociation.enable_feature)
}
inline void Study_Experiment_FeatureAssociation::set_enable_feature(int index, const char* value, size_t size)
{
    _impl_.enable_feature_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:variations.Study.Experiment.FeatureAssociation.enable_feature)
}
inline std::string* Study_Experiment_FeatureAssociation::_internal_add_enable_feature()
{
    return _impl_.enable_feature_.Add();
}
inline void Study_Experiment_FeatureAssociation::add_enable_feature(const std::string& value)
{
    _impl_.enable_feature_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:variations.Study.Experiment.FeatureAssociation.enable_feature)
}
inline void Study_Experiment_FeatureAssociation::add_enable_feature(std::string&& value)
{
    _impl_.enable_feature_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:variations.Study.Experiment.FeatureAssociation.enable_feature)
}
inline void Study_Experiment_FeatureAssociation::add_enable_feature(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.enable_feature_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:variations.Study.Experiment.FeatureAssociation.enable_feature)
}
inline void Study_Experiment_FeatureAssociation::add_enable_feature(const char* value, size_t size)
{
    _impl_.enable_feature_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:variations.Study.Experiment.FeatureAssociation.enable_feature)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& Study_Experiment_FeatureAssociation::enable_feature() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Experiment.FeatureAssociation.enable_feature)
    return _impl_.enable_feature_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Study_Experiment_FeatureAssociation::mutable_enable_feature()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Experiment.FeatureAssociation.enable_feature)
    return &_impl_.enable_feature_;
}

// repeated string disable_feature = 2;
inline int Study_Experiment_FeatureAssociation::_internal_disable_feature_size() const
{
    return _impl_.disable_feature_.size();
}
inline int Study_Experiment_FeatureAssociation::disable_feature_size() const
{
    return _internal_disable_feature_size();
}
inline void Study_Experiment_FeatureAssociation::clear_disable_feature()
{
    _impl_.disable_feature_.Clear();
}
inline std::string* Study_Experiment_FeatureAssociation::add_disable_feature()
{
    std::string* _s = _internal_add_disable_feature();
    // @@protoc_insertion_point(field_add_mutable:variations.Study.Experiment.FeatureAssociation.disable_feature)
    return _s;
}
inline const std::string& Study_Experiment_FeatureAssociation::_internal_disable_feature(int index) const
{
    return _impl_.disable_feature_.Get(index);
}
inline const std::string& Study_Experiment_FeatureAssociation::disable_feature(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.FeatureAssociation.disable_feature)
    return _internal_disable_feature(index);
}
inline std::string* Study_Experiment_FeatureAssociation::mutable_disable_feature(int index)
{
    // @@protoc_insertion_point(field_mutable:variations.Study.Experiment.FeatureAssociation.disable_feature)
    return _impl_.disable_feature_.Mutable(index);
}
inline void Study_Experiment_FeatureAssociation::set_disable_feature(int index, const std::string& value)
{
    _impl_.disable_feature_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.FeatureAssociation.disable_feature)
}
inline void Study_Experiment_FeatureAssociation::set_disable_feature(int index, std::string&& value)
{
    _impl_.disable_feature_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.FeatureAssociation.disable_feature)
}
inline void Study_Experiment_FeatureAssociation::set_disable_feature(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.disable_feature_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:variations.Study.Experiment.FeatureAssociation.disable_feature)
}
inline void Study_Experiment_FeatureAssociation::set_disable_feature(int index, const char* value, size_t size)
{
    _impl_.disable_feature_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:variations.Study.Experiment.FeatureAssociation.disable_feature)
}
inline std::string* Study_Experiment_FeatureAssociation::_internal_add_disable_feature()
{
    return _impl_.disable_feature_.Add();
}
inline void Study_Experiment_FeatureAssociation::add_disable_feature(const std::string& value)
{
    _impl_.disable_feature_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:variations.Study.Experiment.FeatureAssociation.disable_feature)
}
inline void Study_Experiment_FeatureAssociation::add_disable_feature(std::string&& value)
{
    _impl_.disable_feature_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:variations.Study.Experiment.FeatureAssociation.disable_feature)
}
inline void Study_Experiment_FeatureAssociation::add_disable_feature(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.disable_feature_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:variations.Study.Experiment.FeatureAssociation.disable_feature)
}
inline void Study_Experiment_FeatureAssociation::add_disable_feature(const char* value, size_t size)
{
    _impl_.disable_feature_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:variations.Study.Experiment.FeatureAssociation.disable_feature)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& Study_Experiment_FeatureAssociation::disable_feature() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Experiment.FeatureAssociation.disable_feature)
    return _impl_.disable_feature_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Study_Experiment_FeatureAssociation::mutable_disable_feature()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Experiment.FeatureAssociation.disable_feature)
    return &_impl_.disable_feature_;
}

// optional string forcing_feature_on = 3;
inline bool Study_Experiment_FeatureAssociation::_internal_has_forcing_feature_on() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Study_Experiment_FeatureAssociation::has_forcing_feature_on() const
{
    return _internal_has_forcing_feature_on();
}
inline void Study_Experiment_FeatureAssociation::clear_forcing_feature_on()
{
    _impl_.forcing_feature_on_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Study_Experiment_FeatureAssociation::forcing_feature_on() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.FeatureAssociation.forcing_feature_on)
    return _internal_forcing_feature_on();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void Study_Experiment_FeatureAssociation::set_forcing_feature_on(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.forcing_feature_on_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.FeatureAssociation.forcing_feature_on)
}
inline std::string* Study_Experiment_FeatureAssociation::mutable_forcing_feature_on()
{
    std::string* _s = _internal_mutable_forcing_feature_on();
    // @@protoc_insertion_point(field_mutable:variations.Study.Experiment.FeatureAssociation.forcing_feature_on)
    return _s;
}
inline const std::string& Study_Experiment_FeatureAssociation::_internal_forcing_feature_on() const
{
    return _impl_.forcing_feature_on_.Get();
}
inline void Study_Experiment_FeatureAssociation::_internal_set_forcing_feature_on(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.forcing_feature_on_.Set(value, GetArenaForAllocation());
}
inline std::string* Study_Experiment_FeatureAssociation::_internal_mutable_forcing_feature_on()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.forcing_feature_on_.Mutable(GetArenaForAllocation());
}
inline std::string* Study_Experiment_FeatureAssociation::release_forcing_feature_on()
{
    // @@protoc_insertion_point(field_release:variations.Study.Experiment.FeatureAssociation.forcing_feature_on)
    if (!_internal_has_forcing_feature_on()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.forcing_feature_on_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.forcing_feature_on_.IsDefault()) {
        _impl_.forcing_feature_on_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Study_Experiment_FeatureAssociation::set_allocated_forcing_feature_on(std::string* forcing_feature_on)
{
    if (forcing_feature_on != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.forcing_feature_on_.SetAllocated(forcing_feature_on, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.forcing_feature_on_.IsDefault()) {
        _impl_.forcing_feature_on_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:variations.Study.Experiment.FeatureAssociation.forcing_feature_on)
}

// optional string forcing_feature_off = 4;
inline bool Study_Experiment_FeatureAssociation::_internal_has_forcing_feature_off() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Study_Experiment_FeatureAssociation::has_forcing_feature_off() const
{
    return _internal_has_forcing_feature_off();
}
inline void Study_Experiment_FeatureAssociation::clear_forcing_feature_off()
{
    _impl_.forcing_feature_off_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Study_Experiment_FeatureAssociation::forcing_feature_off() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.FeatureAssociation.forcing_feature_off)
    return _internal_forcing_feature_off();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void Study_Experiment_FeatureAssociation::set_forcing_feature_off(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.forcing_feature_off_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.FeatureAssociation.forcing_feature_off)
}
inline std::string* Study_Experiment_FeatureAssociation::mutable_forcing_feature_off()
{
    std::string* _s = _internal_mutable_forcing_feature_off();
    // @@protoc_insertion_point(field_mutable:variations.Study.Experiment.FeatureAssociation.forcing_feature_off)
    return _s;
}
inline const std::string& Study_Experiment_FeatureAssociation::_internal_forcing_feature_off() const
{
    return _impl_.forcing_feature_off_.Get();
}
inline void Study_Experiment_FeatureAssociation::_internal_set_forcing_feature_off(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.forcing_feature_off_.Set(value, GetArenaForAllocation());
}
inline std::string* Study_Experiment_FeatureAssociation::_internal_mutable_forcing_feature_off()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.forcing_feature_off_.Mutable(GetArenaForAllocation());
}
inline std::string* Study_Experiment_FeatureAssociation::release_forcing_feature_off()
{
    // @@protoc_insertion_point(field_release:variations.Study.Experiment.FeatureAssociation.forcing_feature_off)
    if (!_internal_has_forcing_feature_off()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.forcing_feature_off_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.forcing_feature_off_.IsDefault()) {
        _impl_.forcing_feature_off_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Study_Experiment_FeatureAssociation::set_allocated_forcing_feature_off(std::string* forcing_feature_off)
{
    if (forcing_feature_off != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.forcing_feature_off_.SetAllocated(forcing_feature_off, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.forcing_feature_off_.IsDefault()) {
        _impl_.forcing_feature_off_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:variations.Study.Experiment.FeatureAssociation.forcing_feature_off)
}

// -------------------------------------------------------------------

// Study_Experiment_OverrideUIString

// optional fixed32 name_hash = 1;
inline bool Study_Experiment_OverrideUIString::_internal_has_name_hash() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Study_Experiment_OverrideUIString::has_name_hash() const
{
    return _internal_has_name_hash();
}
inline void Study_Experiment_OverrideUIString::clear_name_hash()
{
    _impl_.name_hash_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t Study_Experiment_OverrideUIString::_internal_name_hash() const
{
    return _impl_.name_hash_;
}
inline uint32_t Study_Experiment_OverrideUIString::name_hash() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.OverrideUIString.name_hash)
    return _internal_name_hash();
}
inline void Study_Experiment_OverrideUIString::_internal_set_name_hash(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.name_hash_ = value;
}
inline void Study_Experiment_OverrideUIString::set_name_hash(uint32_t value)
{
    _internal_set_name_hash(value);
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.OverrideUIString.name_hash)
}

// optional string value = 2;
inline bool Study_Experiment_OverrideUIString::_internal_has_value() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Study_Experiment_OverrideUIString::has_value() const
{
    return _internal_has_value();
}
inline void Study_Experiment_OverrideUIString::clear_value()
{
    _impl_.value_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Study_Experiment_OverrideUIString::value() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.OverrideUIString.value)
    return _internal_value();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Study_Experiment_OverrideUIString::set_value(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.value_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.OverrideUIString.value)
}
inline std::string* Study_Experiment_OverrideUIString::mutable_value()
{
    std::string* _s = _internal_mutable_value();
    // @@protoc_insertion_point(field_mutable:variations.Study.Experiment.OverrideUIString.value)
    return _s;
}
inline const std::string& Study_Experiment_OverrideUIString::_internal_value() const
{
    return _impl_.value_.Get();
}
inline void Study_Experiment_OverrideUIString::_internal_set_value(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Study_Experiment_OverrideUIString::_internal_mutable_value()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Study_Experiment_OverrideUIString::release_value()
{
    // @@protoc_insertion_point(field_release:variations.Study.Experiment.OverrideUIString.value)
    if (!_internal_has_value()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Study_Experiment_OverrideUIString::set_allocated_value(std::string* value)
{
    if (value != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:variations.Study.Experiment.OverrideUIString.value)
}

// -------------------------------------------------------------------

// Study_Experiment

// required string name = 1;
inline bool Study_Experiment::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Study_Experiment::has_name() const
{
    return _internal_has_name();
}
inline void Study_Experiment::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Study_Experiment::name() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Study_Experiment::set_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.name)
}
inline std::string* Study_Experiment::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:variations.Study.Experiment.name)
    return _s;
}
inline const std::string& Study_Experiment::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void Study_Experiment::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Study_Experiment::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Study_Experiment::release_name()
{
    // @@protoc_insertion_point(field_release:variations.Study.Experiment.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Study_Experiment::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:variations.Study.Experiment.name)
}

// required uint32 probability_weight = 2;
inline bool Study_Experiment::_internal_has_probability_weight() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool Study_Experiment::has_probability_weight() const
{
    return _internal_has_probability_weight();
}
inline void Study_Experiment::clear_probability_weight()
{
    _impl_.probability_weight_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t Study_Experiment::_internal_probability_weight() const
{
    return _impl_.probability_weight_;
}
inline uint32_t Study_Experiment::probability_weight() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.probability_weight)
    return _internal_probability_weight();
}
inline void Study_Experiment::_internal_set_probability_weight(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.probability_weight_ = value;
}
inline void Study_Experiment::set_probability_weight(uint32_t value)
{
    _internal_set_probability_weight(value);
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.probability_weight)
}

// optional uint64 google_web_experiment_id = 3;
inline bool Study_Experiment::_internal_has_google_web_experiment_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool Study_Experiment::has_google_web_experiment_id() const
{
    return _internal_has_google_web_experiment_id();
}
inline void Study_Experiment::clear_google_web_experiment_id()
{
    _impl_.google_web_experiment_id_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint64_t Study_Experiment::_internal_google_web_experiment_id() const
{
    return _impl_.google_web_experiment_id_;
}
inline uint64_t Study_Experiment::google_web_experiment_id() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.google_web_experiment_id)
    return _internal_google_web_experiment_id();
}
inline void Study_Experiment::_internal_set_google_web_experiment_id(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.google_web_experiment_id_ = value;
}
inline void Study_Experiment::set_google_web_experiment_id(uint64_t value)
{
    _internal_set_google_web_experiment_id(value);
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.google_web_experiment_id)
}

// optional uint64 google_web_trigger_experiment_id = 8;
inline bool Study_Experiment::_internal_has_google_web_trigger_experiment_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool Study_Experiment::has_google_web_trigger_experiment_id() const
{
    return _internal_has_google_web_trigger_experiment_id();
}
inline void Study_Experiment::clear_google_web_trigger_experiment_id()
{
    _impl_.google_web_trigger_experiment_id_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint64_t Study_Experiment::_internal_google_web_trigger_experiment_id() const
{
    return _impl_.google_web_trigger_experiment_id_;
}
inline uint64_t Study_Experiment::google_web_trigger_experiment_id() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.google_web_trigger_experiment_id)
    return _internal_google_web_trigger_experiment_id();
}
inline void Study_Experiment::_internal_set_google_web_trigger_experiment_id(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.google_web_trigger_experiment_id_ = value;
}
inline void Study_Experiment::set_google_web_trigger_experiment_id(uint64_t value)
{
    _internal_set_google_web_trigger_experiment_id(value);
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.google_web_trigger_experiment_id)
}

// optional .variations.Study.GoogleWebVisibility google_web_visibility = 16;
inline bool Study_Experiment::_internal_has_google_web_visibility() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool Study_Experiment::has_google_web_visibility() const
{
    return _internal_has_google_web_visibility();
}
inline void Study_Experiment::clear_google_web_visibility()
{
    _impl_.google_web_visibility_ = 0;
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::variations::Study_GoogleWebVisibility Study_Experiment::_internal_google_web_visibility() const
{
    return static_cast<::variations::Study_GoogleWebVisibility>(_impl_.google_web_visibility_);
}
inline ::variations::Study_GoogleWebVisibility Study_Experiment::google_web_visibility() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.google_web_visibility)
    return _internal_google_web_visibility();
}
inline void Study_Experiment::_internal_set_google_web_visibility(::variations::Study_GoogleWebVisibility value)
{
    assert(::variations::Study_GoogleWebVisibility_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.google_web_visibility_ = value;
}
inline void Study_Experiment::set_google_web_visibility(::variations::Study_GoogleWebVisibility value)
{
    _internal_set_google_web_visibility(value);
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.google_web_visibility)
}

// optional uint64 google_app_experiment_id = 15;
inline bool Study_Experiment::_internal_has_google_app_experiment_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool Study_Experiment::has_google_app_experiment_id() const
{
    return _internal_has_google_app_experiment_id();
}
inline void Study_Experiment::clear_google_app_experiment_id()
{
    _impl_.google_app_experiment_id_ = uint64_t { 0u };
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint64_t Study_Experiment::_internal_google_app_experiment_id() const
{
    return _impl_.google_app_experiment_id_;
}
inline uint64_t Study_Experiment::google_app_experiment_id() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.google_app_experiment_id)
    return _internal_google_app_experiment_id();
}
inline void Study_Experiment::_internal_set_google_app_experiment_id(uint64_t value)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.google_app_experiment_id_ = value;
}
inline void Study_Experiment::set_google_app_experiment_id(uint64_t value)
{
    _internal_set_google_app_experiment_id(value);
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.google_app_experiment_id)
}

// optional .variations.Study.Experiment.FeatureAssociation feature_association = 12;
inline bool Study_Experiment::_internal_has_feature_association() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.feature_association_ != nullptr);
    return value;
}
inline bool Study_Experiment::has_feature_association() const
{
    return _internal_has_feature_association();
}
inline void Study_Experiment::clear_feature_association()
{
    if (_impl_.feature_association_ != nullptr)
        _impl_.feature_association_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::variations::Study_Experiment_FeatureAssociation& Study_Experiment::_internal_feature_association() const
{
    const ::variations::Study_Experiment_FeatureAssociation* p = _impl_.feature_association_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::variations::Study_Experiment_FeatureAssociation&>(::variations::_Study_Experiment_FeatureAssociation_default_instance_);
}
inline const ::variations::Study_Experiment_FeatureAssociation& Study_Experiment::feature_association() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.feature_association)
    return _internal_feature_association();
}
inline void Study_Experiment::unsafe_arena_set_allocated_feature_association(::variations::Study_Experiment_FeatureAssociation* feature_association)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.feature_association_);
    }
    _impl_.feature_association_ = feature_association;
    if (feature_association) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:variations.Study.Experiment.feature_association)
}
inline ::variations::Study_Experiment_FeatureAssociation* Study_Experiment::release_feature_association()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::variations::Study_Experiment_FeatureAssociation* temp = _impl_.feature_association_;
    _impl_.feature_association_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::variations::Study_Experiment_FeatureAssociation* Study_Experiment::unsafe_arena_release_feature_association()
{
    // @@protoc_insertion_point(field_release:variations.Study.Experiment.feature_association)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::variations::Study_Experiment_FeatureAssociation* temp = _impl_.feature_association_;
    _impl_.feature_association_ = nullptr;
    return temp;
}
inline ::variations::Study_Experiment_FeatureAssociation* Study_Experiment::_internal_mutable_feature_association()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.feature_association_ == nullptr) {
        auto* p = CreateMaybeMessage<::variations::Study_Experiment_FeatureAssociation>(GetArenaForAllocation());
        _impl_.feature_association_ = p;
    }
    return _impl_.feature_association_;
}
inline ::variations::Study_Experiment_FeatureAssociation* Study_Experiment::mutable_feature_association()
{
    ::variations::Study_Experiment_FeatureAssociation* _msg = _internal_mutable_feature_association();
    // @@protoc_insertion_point(field_mutable:variations.Study.Experiment.feature_association)
    return _msg;
}
inline void Study_Experiment::set_allocated_feature_association(::variations::Study_Experiment_FeatureAssociation* feature_association)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.feature_association_;
    }
    if (feature_association) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feature_association);
        if (message_arena != submessage_arena) {
            feature_association = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, feature_association, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.feature_association_ = feature_association;
    // @@protoc_insertion_point(field_set_allocated:variations.Study.Experiment.feature_association)
}

// optional string forcing_flag = 5;
inline bool Study_Experiment::_internal_has_forcing_flag() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Study_Experiment::has_forcing_flag() const
{
    return _internal_has_forcing_flag();
}
inline void Study_Experiment::clear_forcing_flag()
{
    _impl_.forcing_flag_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Study_Experiment::forcing_flag() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.forcing_flag)
    return _internal_forcing_flag();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Study_Experiment::set_forcing_flag(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.forcing_flag_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.forcing_flag)
}
inline std::string* Study_Experiment::mutable_forcing_flag()
{
    std::string* _s = _internal_mutable_forcing_flag();
    // @@protoc_insertion_point(field_mutable:variations.Study.Experiment.forcing_flag)
    return _s;
}
inline const std::string& Study_Experiment::_internal_forcing_flag() const
{
    return _impl_.forcing_flag_.Get();
}
inline void Study_Experiment::_internal_set_forcing_flag(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.forcing_flag_.Set(value, GetArenaForAllocation());
}
inline std::string* Study_Experiment::_internal_mutable_forcing_flag()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.forcing_flag_.Mutable(GetArenaForAllocation());
}
inline std::string* Study_Experiment::release_forcing_flag()
{
    // @@protoc_insertion_point(field_release:variations.Study.Experiment.forcing_flag)
    if (!_internal_has_forcing_flag()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.forcing_flag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.forcing_flag_.IsDefault()) {
        _impl_.forcing_flag_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Study_Experiment::set_allocated_forcing_flag(std::string* forcing_flag)
{
    if (forcing_flag != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.forcing_flag_.SetAllocated(forcing_flag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.forcing_flag_.IsDefault()) {
        _impl_.forcing_flag_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:variations.Study.Experiment.forcing_flag)
}

// repeated .variations.Study.Experiment.Param param = 6;
inline int Study_Experiment::_internal_param_size() const
{
    return _impl_.param_.size();
}
inline int Study_Experiment::param_size() const
{
    return _internal_param_size();
}
inline void Study_Experiment::clear_param()
{
    _impl_.param_.Clear();
}
inline ::variations::Study_Experiment_Param* Study_Experiment::mutable_param(int index)
{
    // @@protoc_insertion_point(field_mutable:variations.Study.Experiment.param)
    return _impl_.param_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment_Param>* Study_Experiment::mutable_param()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Experiment.param)
    return &_impl_.param_;
}
inline const ::variations::Study_Experiment_Param& Study_Experiment::_internal_param(int index) const
{
    return _impl_.param_.Get(index);
}
inline const ::variations::Study_Experiment_Param& Study_Experiment::param(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.param)
    return _internal_param(index);
}
inline ::variations::Study_Experiment_Param* Study_Experiment::_internal_add_param()
{
    return _impl_.param_.Add();
}
inline ::variations::Study_Experiment_Param* Study_Experiment::add_param()
{
    ::variations::Study_Experiment_Param* _add = _internal_add_param();
    // @@protoc_insertion_point(field_add:variations.Study.Experiment.param)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment_Param>& Study_Experiment::param() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Experiment.param)
    return _impl_.param_;
}

// optional .variations.Study.Experiment.Type type = 7 [default = NORMAL];
inline bool Study_Experiment::_internal_has_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool Study_Experiment::has_type() const
{
    return _internal_has_type();
}
inline void Study_Experiment::clear_type()
{
    _impl_.type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::variations::Study_Experiment_Type Study_Experiment::_internal_type() const
{
    return static_cast<::variations::Study_Experiment_Type>(_impl_.type_);
}
inline ::variations::Study_Experiment_Type Study_Experiment::type() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.type)
    return _internal_type();
}
inline void Study_Experiment::_internal_set_type(::variations::Study_Experiment_Type value)
{
    assert(::variations::Study_Experiment_Type_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.type_ = value;
}
inline void Study_Experiment::set_type(::variations::Study_Experiment_Type value)
{
    _internal_set_type(value);
    // @@protoc_insertion_point(field_set:variations.Study.Experiment.type)
}

// repeated .variations.Study.Experiment.OverrideUIString override_ui_string = 9;
inline int Study_Experiment::_internal_override_ui_string_size() const
{
    return _impl_.override_ui_string_.size();
}
inline int Study_Experiment::override_ui_string_size() const
{
    return _internal_override_ui_string_size();
}
inline void Study_Experiment::clear_override_ui_string()
{
    _impl_.override_ui_string_.Clear();
}
inline ::variations::Study_Experiment_OverrideUIString* Study_Experiment::mutable_override_ui_string(int index)
{
    // @@protoc_insertion_point(field_mutable:variations.Study.Experiment.override_ui_string)
    return _impl_.override_ui_string_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment_OverrideUIString>* Study_Experiment::mutable_override_ui_string()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Experiment.override_ui_string)
    return &_impl_.override_ui_string_;
}
inline const ::variations::Study_Experiment_OverrideUIString& Study_Experiment::_internal_override_ui_string(int index) const
{
    return _impl_.override_ui_string_.Get(index);
}
inline const ::variations::Study_Experiment_OverrideUIString& Study_Experiment::override_ui_string(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Experiment.override_ui_string)
    return _internal_override_ui_string(index);
}
inline ::variations::Study_Experiment_OverrideUIString* Study_Experiment::_internal_add_override_ui_string()
{
    return _impl_.override_ui_string_.Add();
}
inline ::variations::Study_Experiment_OverrideUIString* Study_Experiment::add_override_ui_string()
{
    ::variations::Study_Experiment_OverrideUIString* _add = _internal_add_override_ui_string();
    // @@protoc_insertion_point(field_add:variations.Study.Experiment.override_ui_string)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment_OverrideUIString>& Study_Experiment::override_ui_string() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Experiment.override_ui_string)
    return _impl_.override_ui_string_;
}

// -------------------------------------------------------------------

// Study_Filter

// optional int64 start_date = 1;
inline bool Study_Filter::_internal_has_start_date() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool Study_Filter::has_start_date() const
{
    return _internal_has_start_date();
}
inline void Study_Filter::clear_start_date()
{
    _impl_.start_date_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t Study_Filter::_internal_start_date() const
{
    return _impl_.start_date_;
}
inline int64_t Study_Filter::start_date() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.start_date)
    return _internal_start_date();
}
inline void Study_Filter::_internal_set_start_date(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.start_date_ = value;
}
inline void Study_Filter::set_start_date(int64_t value)
{
    _internal_set_start_date(value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.start_date)
}

// optional int64 end_date = 13;
inline bool Study_Filter::_internal_has_end_date() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool Study_Filter::has_end_date() const
{
    return _internal_has_end_date();
}
inline void Study_Filter::clear_end_date()
{
    _impl_.end_date_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t Study_Filter::_internal_end_date() const
{
    return _impl_.end_date_;
}
inline int64_t Study_Filter::end_date() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.end_date)
    return _internal_end_date();
}
inline void Study_Filter::_internal_set_end_date(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.end_date_ = value;
}
inline void Study_Filter::set_end_date(int64_t value)
{
    _internal_set_end_date(value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.end_date)
}

// optional string min_version = 2;
inline bool Study_Filter::_internal_has_min_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Study_Filter::has_min_version() const
{
    return _internal_has_min_version();
}
inline void Study_Filter::clear_min_version()
{
    _impl_.min_version_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Study_Filter::min_version() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.min_version)
    return _internal_min_version();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Study_Filter::set_min_version(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.min_version_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:variations.Study.Filter.min_version)
}
inline std::string* Study_Filter::mutable_min_version()
{
    std::string* _s = _internal_mutable_min_version();
    // @@protoc_insertion_point(field_mutable:variations.Study.Filter.min_version)
    return _s;
}
inline const std::string& Study_Filter::_internal_min_version() const
{
    return _impl_.min_version_.Get();
}
inline void Study_Filter::_internal_set_min_version(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.min_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Study_Filter::_internal_mutable_min_version()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.min_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Study_Filter::release_min_version()
{
    // @@protoc_insertion_point(field_release:variations.Study.Filter.min_version)
    if (!_internal_has_min_version()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.min_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.min_version_.IsDefault()) {
        _impl_.min_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Study_Filter::set_allocated_min_version(std::string* min_version)
{
    if (min_version != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.min_version_.SetAllocated(min_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.min_version_.IsDefault()) {
        _impl_.min_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:variations.Study.Filter.min_version)
}

// optional string max_version = 3;
inline bool Study_Filter::_internal_has_max_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Study_Filter::has_max_version() const
{
    return _internal_has_max_version();
}
inline void Study_Filter::clear_max_version()
{
    _impl_.max_version_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Study_Filter::max_version() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.max_version)
    return _internal_max_version();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Study_Filter::set_max_version(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.max_version_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:variations.Study.Filter.max_version)
}
inline std::string* Study_Filter::mutable_max_version()
{
    std::string* _s = _internal_mutable_max_version();
    // @@protoc_insertion_point(field_mutable:variations.Study.Filter.max_version)
    return _s;
}
inline const std::string& Study_Filter::_internal_max_version() const
{
    return _impl_.max_version_.Get();
}
inline void Study_Filter::_internal_set_max_version(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.max_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Study_Filter::_internal_mutable_max_version()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.max_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Study_Filter::release_max_version()
{
    // @@protoc_insertion_point(field_release:variations.Study.Filter.max_version)
    if (!_internal_has_max_version()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.max_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.max_version_.IsDefault()) {
        _impl_.max_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Study_Filter::set_allocated_max_version(std::string* max_version)
{
    if (max_version != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.max_version_.SetAllocated(max_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.max_version_.IsDefault()) {
        _impl_.max_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:variations.Study.Filter.max_version)
}

// optional string min_os_version = 16;
inline bool Study_Filter::_internal_has_min_os_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool Study_Filter::has_min_os_version() const
{
    return _internal_has_min_os_version();
}
inline void Study_Filter::clear_min_os_version()
{
    _impl_.min_os_version_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Study_Filter::min_os_version() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.min_os_version)
    return _internal_min_os_version();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Study_Filter::set_min_os_version(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.min_os_version_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:variations.Study.Filter.min_os_version)
}
inline std::string* Study_Filter::mutable_min_os_version()
{
    std::string* _s = _internal_mutable_min_os_version();
    // @@protoc_insertion_point(field_mutable:variations.Study.Filter.min_os_version)
    return _s;
}
inline const std::string& Study_Filter::_internal_min_os_version() const
{
    return _impl_.min_os_version_.Get();
}
inline void Study_Filter::_internal_set_min_os_version(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.min_os_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Study_Filter::_internal_mutable_min_os_version()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.min_os_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Study_Filter::release_min_os_version()
{
    // @@protoc_insertion_point(field_release:variations.Study.Filter.min_os_version)
    if (!_internal_has_min_os_version()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.min_os_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.min_os_version_.IsDefault()) {
        _impl_.min_os_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Study_Filter::set_allocated_min_os_version(std::string* min_os_version)
{
    if (min_os_version != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.min_os_version_.SetAllocated(min_os_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.min_os_version_.IsDefault()) {
        _impl_.min_os_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:variations.Study.Filter.min_os_version)
}

// optional string max_os_version = 17;
inline bool Study_Filter::_internal_has_max_os_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool Study_Filter::has_max_os_version() const
{
    return _internal_has_max_os_version();
}
inline void Study_Filter::clear_max_os_version()
{
    _impl_.max_os_version_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Study_Filter::max_os_version() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.max_os_version)
    return _internal_max_os_version();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Study_Filter::set_max_os_version(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.max_os_version_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:variations.Study.Filter.max_os_version)
}
inline std::string* Study_Filter::mutable_max_os_version()
{
    std::string* _s = _internal_mutable_max_os_version();
    // @@protoc_insertion_point(field_mutable:variations.Study.Filter.max_os_version)
    return _s;
}
inline const std::string& Study_Filter::_internal_max_os_version() const
{
    return _impl_.max_os_version_.Get();
}
inline void Study_Filter::_internal_set_max_os_version(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.max_os_version_.Set(value, GetArenaForAllocation());
}
inline std::string* Study_Filter::_internal_mutable_max_os_version()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.max_os_version_.Mutable(GetArenaForAllocation());
}
inline std::string* Study_Filter::release_max_os_version()
{
    // @@protoc_insertion_point(field_release:variations.Study.Filter.max_os_version)
    if (!_internal_has_max_os_version()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.max_os_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.max_os_version_.IsDefault()) {
        _impl_.max_os_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Study_Filter::set_allocated_max_os_version(std::string* max_os_version)
{
    if (max_os_version != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.max_os_version_.SetAllocated(max_os_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.max_os_version_.IsDefault()) {
        _impl_.max_os_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:variations.Study.Filter.max_os_version)
}

// repeated .variations.Study.Channel channel = 4;
inline int Study_Filter::_internal_channel_size() const
{
    return _impl_.channel_.size();
}
inline int Study_Filter::channel_size() const
{
    return _internal_channel_size();
}
inline void Study_Filter::clear_channel()
{
    _impl_.channel_.Clear();
}
inline ::variations::Study_Channel Study_Filter::_internal_channel(int index) const
{
    return static_cast<::variations::Study_Channel>(_impl_.channel_.Get(index));
}
inline ::variations::Study_Channel Study_Filter::channel(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.channel)
    return _internal_channel(index);
}
inline void Study_Filter::set_channel(int index, ::variations::Study_Channel value)
{
    assert(::variations::Study_Channel_IsValid(value));
    _impl_.channel_.Set(index, value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.channel)
}
inline void Study_Filter::_internal_add_channel(::variations::Study_Channel value)
{
    assert(::variations::Study_Channel_IsValid(value));
    _impl_.channel_.Add(value);
}
inline void Study_Filter::add_channel(::variations::Study_Channel value)
{
    _internal_add_channel(value);
    // @@protoc_insertion_point(field_add:variations.Study.Filter.channel)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& Study_Filter::channel() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Filter.channel)
    return _impl_.channel_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Study_Filter::_internal_mutable_channel()
{
    return &_impl_.channel_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Study_Filter::mutable_channel()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Filter.channel)
    return _internal_mutable_channel();
}

// repeated .variations.Study.Platform platform = 5;
inline int Study_Filter::_internal_platform_size() const
{
    return _impl_.platform_.size();
}
inline int Study_Filter::platform_size() const
{
    return _internal_platform_size();
}
inline void Study_Filter::clear_platform()
{
    _impl_.platform_.Clear();
}
inline ::variations::Study_Platform Study_Filter::_internal_platform(int index) const
{
    return static_cast<::variations::Study_Platform>(_impl_.platform_.Get(index));
}
inline ::variations::Study_Platform Study_Filter::platform(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.platform)
    return _internal_platform(index);
}
inline void Study_Filter::set_platform(int index, ::variations::Study_Platform value)
{
    assert(::variations::Study_Platform_IsValid(value));
    _impl_.platform_.Set(index, value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.platform)
}
inline void Study_Filter::_internal_add_platform(::variations::Study_Platform value)
{
    assert(::variations::Study_Platform_IsValid(value));
    _impl_.platform_.Add(value);
}
inline void Study_Filter::add_platform(::variations::Study_Platform value)
{
    _internal_add_platform(value);
    // @@protoc_insertion_point(field_add:variations.Study.Filter.platform)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& Study_Filter::platform() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Filter.platform)
    return _impl_.platform_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Study_Filter::_internal_mutable_platform()
{
    return &_impl_.platform_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Study_Filter::mutable_platform()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Filter.platform)
    return _internal_mutable_platform();
}

// repeated string locale = 6;
inline int Study_Filter::_internal_locale_size() const
{
    return _impl_.locale_.size();
}
inline int Study_Filter::locale_size() const
{
    return _internal_locale_size();
}
inline void Study_Filter::clear_locale()
{
    _impl_.locale_.Clear();
}
inline std::string* Study_Filter::add_locale()
{
    std::string* _s = _internal_add_locale();
    // @@protoc_insertion_point(field_add_mutable:variations.Study.Filter.locale)
    return _s;
}
inline const std::string& Study_Filter::_internal_locale(int index) const
{
    return _impl_.locale_.Get(index);
}
inline const std::string& Study_Filter::locale(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.locale)
    return _internal_locale(index);
}
inline std::string* Study_Filter::mutable_locale(int index)
{
    // @@protoc_insertion_point(field_mutable:variations.Study.Filter.locale)
    return _impl_.locale_.Mutable(index);
}
inline void Study_Filter::set_locale(int index, const std::string& value)
{
    _impl_.locale_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.locale)
}
inline void Study_Filter::set_locale(int index, std::string&& value)
{
    _impl_.locale_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:variations.Study.Filter.locale)
}
inline void Study_Filter::set_locale(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.locale_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:variations.Study.Filter.locale)
}
inline void Study_Filter::set_locale(int index, const char* value, size_t size)
{
    _impl_.locale_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:variations.Study.Filter.locale)
}
inline std::string* Study_Filter::_internal_add_locale()
{
    return _impl_.locale_.Add();
}
inline void Study_Filter::add_locale(const std::string& value)
{
    _impl_.locale_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:variations.Study.Filter.locale)
}
inline void Study_Filter::add_locale(std::string&& value)
{
    _impl_.locale_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:variations.Study.Filter.locale)
}
inline void Study_Filter::add_locale(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.locale_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:variations.Study.Filter.locale)
}
inline void Study_Filter::add_locale(const char* value, size_t size)
{
    _impl_.locale_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:variations.Study.Filter.locale)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& Study_Filter::locale() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Filter.locale)
    return _impl_.locale_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Study_Filter::mutable_locale()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Filter.locale)
    return &_impl_.locale_;
}

// repeated string exclude_locale = 12;
inline int Study_Filter::_internal_exclude_locale_size() const
{
    return _impl_.exclude_locale_.size();
}
inline int Study_Filter::exclude_locale_size() const
{
    return _internal_exclude_locale_size();
}
inline void Study_Filter::clear_exclude_locale()
{
    _impl_.exclude_locale_.Clear();
}
inline std::string* Study_Filter::add_exclude_locale()
{
    std::string* _s = _internal_add_exclude_locale();
    // @@protoc_insertion_point(field_add_mutable:variations.Study.Filter.exclude_locale)
    return _s;
}
inline const std::string& Study_Filter::_internal_exclude_locale(int index) const
{
    return _impl_.exclude_locale_.Get(index);
}
inline const std::string& Study_Filter::exclude_locale(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.exclude_locale)
    return _internal_exclude_locale(index);
}
inline std::string* Study_Filter::mutable_exclude_locale(int index)
{
    // @@protoc_insertion_point(field_mutable:variations.Study.Filter.exclude_locale)
    return _impl_.exclude_locale_.Mutable(index);
}
inline void Study_Filter::set_exclude_locale(int index, const std::string& value)
{
    _impl_.exclude_locale_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.exclude_locale)
}
inline void Study_Filter::set_exclude_locale(int index, std::string&& value)
{
    _impl_.exclude_locale_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:variations.Study.Filter.exclude_locale)
}
inline void Study_Filter::set_exclude_locale(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.exclude_locale_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:variations.Study.Filter.exclude_locale)
}
inline void Study_Filter::set_exclude_locale(int index, const char* value, size_t size)
{
    _impl_.exclude_locale_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:variations.Study.Filter.exclude_locale)
}
inline std::string* Study_Filter::_internal_add_exclude_locale()
{
    return _impl_.exclude_locale_.Add();
}
inline void Study_Filter::add_exclude_locale(const std::string& value)
{
    _impl_.exclude_locale_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:variations.Study.Filter.exclude_locale)
}
inline void Study_Filter::add_exclude_locale(std::string&& value)
{
    _impl_.exclude_locale_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:variations.Study.Filter.exclude_locale)
}
inline void Study_Filter::add_exclude_locale(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.exclude_locale_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:variations.Study.Filter.exclude_locale)
}
inline void Study_Filter::add_exclude_locale(const char* value, size_t size)
{
    _impl_.exclude_locale_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:variations.Study.Filter.exclude_locale)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& Study_Filter::exclude_locale() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Filter.exclude_locale)
    return _impl_.exclude_locale_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Study_Filter::mutable_exclude_locale()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Filter.exclude_locale)
    return &_impl_.exclude_locale_;
}

// repeated .variations.Study.FormFactor form_factor = 7;
inline int Study_Filter::_internal_form_factor_size() const
{
    return _impl_.form_factor_.size();
}
inline int Study_Filter::form_factor_size() const
{
    return _internal_form_factor_size();
}
inline void Study_Filter::clear_form_factor()
{
    _impl_.form_factor_.Clear();
}
inline ::variations::Study_FormFactor Study_Filter::_internal_form_factor(int index) const
{
    return static_cast<::variations::Study_FormFactor>(_impl_.form_factor_.Get(index));
}
inline ::variations::Study_FormFactor Study_Filter::form_factor(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.form_factor)
    return _internal_form_factor(index);
}
inline void Study_Filter::set_form_factor(int index, ::variations::Study_FormFactor value)
{
    assert(::variations::Study_FormFactor_IsValid(value));
    _impl_.form_factor_.Set(index, value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.form_factor)
}
inline void Study_Filter::_internal_add_form_factor(::variations::Study_FormFactor value)
{
    assert(::variations::Study_FormFactor_IsValid(value));
    _impl_.form_factor_.Add(value);
}
inline void Study_Filter::add_form_factor(::variations::Study_FormFactor value)
{
    _internal_add_form_factor(value);
    // @@protoc_insertion_point(field_add:variations.Study.Filter.form_factor)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& Study_Filter::form_factor() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Filter.form_factor)
    return _impl_.form_factor_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Study_Filter::_internal_mutable_form_factor()
{
    return &_impl_.form_factor_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Study_Filter::mutable_form_factor()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Filter.form_factor)
    return _internal_mutable_form_factor();
}

// repeated .variations.Study.FormFactor exclude_form_factor = 14;
inline int Study_Filter::_internal_exclude_form_factor_size() const
{
    return _impl_.exclude_form_factor_.size();
}
inline int Study_Filter::exclude_form_factor_size() const
{
    return _internal_exclude_form_factor_size();
}
inline void Study_Filter::clear_exclude_form_factor()
{
    _impl_.exclude_form_factor_.Clear();
}
inline ::variations::Study_FormFactor Study_Filter::_internal_exclude_form_factor(int index) const
{
    return static_cast<::variations::Study_FormFactor>(_impl_.exclude_form_factor_.Get(index));
}
inline ::variations::Study_FormFactor Study_Filter::exclude_form_factor(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.exclude_form_factor)
    return _internal_exclude_form_factor(index);
}
inline void Study_Filter::set_exclude_form_factor(int index, ::variations::Study_FormFactor value)
{
    assert(::variations::Study_FormFactor_IsValid(value));
    _impl_.exclude_form_factor_.Set(index, value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.exclude_form_factor)
}
inline void Study_Filter::_internal_add_exclude_form_factor(::variations::Study_FormFactor value)
{
    assert(::variations::Study_FormFactor_IsValid(value));
    _impl_.exclude_form_factor_.Add(value);
}
inline void Study_Filter::add_exclude_form_factor(::variations::Study_FormFactor value)
{
    _internal_add_exclude_form_factor(value);
    // @@protoc_insertion_point(field_add:variations.Study.Filter.exclude_form_factor)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& Study_Filter::exclude_form_factor() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Filter.exclude_form_factor)
    return _impl_.exclude_form_factor_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Study_Filter::_internal_mutable_exclude_form_factor()
{
    return &_impl_.exclude_form_factor_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Study_Filter::mutable_exclude_form_factor()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Filter.exclude_form_factor)
    return _internal_mutable_exclude_form_factor();
}

// repeated string hardware_class = 8;
inline int Study_Filter::_internal_hardware_class_size() const
{
    return _impl_.hardware_class_.size();
}
inline int Study_Filter::hardware_class_size() const
{
    return _internal_hardware_class_size();
}
inline void Study_Filter::clear_hardware_class()
{
    _impl_.hardware_class_.Clear();
}
inline std::string* Study_Filter::add_hardware_class()
{
    std::string* _s = _internal_add_hardware_class();
    // @@protoc_insertion_point(field_add_mutable:variations.Study.Filter.hardware_class)
    return _s;
}
inline const std::string& Study_Filter::_internal_hardware_class(int index) const
{
    return _impl_.hardware_class_.Get(index);
}
inline const std::string& Study_Filter::hardware_class(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.hardware_class)
    return _internal_hardware_class(index);
}
inline std::string* Study_Filter::mutable_hardware_class(int index)
{
    // @@protoc_insertion_point(field_mutable:variations.Study.Filter.hardware_class)
    return _impl_.hardware_class_.Mutable(index);
}
inline void Study_Filter::set_hardware_class(int index, const std::string& value)
{
    _impl_.hardware_class_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.hardware_class)
}
inline void Study_Filter::set_hardware_class(int index, std::string&& value)
{
    _impl_.hardware_class_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:variations.Study.Filter.hardware_class)
}
inline void Study_Filter::set_hardware_class(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.hardware_class_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:variations.Study.Filter.hardware_class)
}
inline void Study_Filter::set_hardware_class(int index, const char* value, size_t size)
{
    _impl_.hardware_class_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:variations.Study.Filter.hardware_class)
}
inline std::string* Study_Filter::_internal_add_hardware_class()
{
    return _impl_.hardware_class_.Add();
}
inline void Study_Filter::add_hardware_class(const std::string& value)
{
    _impl_.hardware_class_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:variations.Study.Filter.hardware_class)
}
inline void Study_Filter::add_hardware_class(std::string&& value)
{
    _impl_.hardware_class_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:variations.Study.Filter.hardware_class)
}
inline void Study_Filter::add_hardware_class(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.hardware_class_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:variations.Study.Filter.hardware_class)
}
inline void Study_Filter::add_hardware_class(const char* value, size_t size)
{
    _impl_.hardware_class_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:variations.Study.Filter.hardware_class)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& Study_Filter::hardware_class() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Filter.hardware_class)
    return _impl_.hardware_class_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Study_Filter::mutable_hardware_class()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Filter.hardware_class)
    return &_impl_.hardware_class_;
}

// repeated string exclude_hardware_class = 9;
inline int Study_Filter::_internal_exclude_hardware_class_size() const
{
    return _impl_.exclude_hardware_class_.size();
}
inline int Study_Filter::exclude_hardware_class_size() const
{
    return _internal_exclude_hardware_class_size();
}
inline void Study_Filter::clear_exclude_hardware_class()
{
    _impl_.exclude_hardware_class_.Clear();
}
inline std::string* Study_Filter::add_exclude_hardware_class()
{
    std::string* _s = _internal_add_exclude_hardware_class();
    // @@protoc_insertion_point(field_add_mutable:variations.Study.Filter.exclude_hardware_class)
    return _s;
}
inline const std::string& Study_Filter::_internal_exclude_hardware_class(int index) const
{
    return _impl_.exclude_hardware_class_.Get(index);
}
inline const std::string& Study_Filter::exclude_hardware_class(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.exclude_hardware_class)
    return _internal_exclude_hardware_class(index);
}
inline std::string* Study_Filter::mutable_exclude_hardware_class(int index)
{
    // @@protoc_insertion_point(field_mutable:variations.Study.Filter.exclude_hardware_class)
    return _impl_.exclude_hardware_class_.Mutable(index);
}
inline void Study_Filter::set_exclude_hardware_class(int index, const std::string& value)
{
    _impl_.exclude_hardware_class_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.exclude_hardware_class)
}
inline void Study_Filter::set_exclude_hardware_class(int index, std::string&& value)
{
    _impl_.exclude_hardware_class_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:variations.Study.Filter.exclude_hardware_class)
}
inline void Study_Filter::set_exclude_hardware_class(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.exclude_hardware_class_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:variations.Study.Filter.exclude_hardware_class)
}
inline void Study_Filter::set_exclude_hardware_class(int index, const char* value, size_t size)
{
    _impl_.exclude_hardware_class_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:variations.Study.Filter.exclude_hardware_class)
}
inline std::string* Study_Filter::_internal_add_exclude_hardware_class()
{
    return _impl_.exclude_hardware_class_.Add();
}
inline void Study_Filter::add_exclude_hardware_class(const std::string& value)
{
    _impl_.exclude_hardware_class_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:variations.Study.Filter.exclude_hardware_class)
}
inline void Study_Filter::add_exclude_hardware_class(std::string&& value)
{
    _impl_.exclude_hardware_class_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:variations.Study.Filter.exclude_hardware_class)
}
inline void Study_Filter::add_exclude_hardware_class(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.exclude_hardware_class_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:variations.Study.Filter.exclude_hardware_class)
}
inline void Study_Filter::add_exclude_hardware_class(const char* value, size_t size)
{
    _impl_.exclude_hardware_class_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:variations.Study.Filter.exclude_hardware_class)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& Study_Filter::exclude_hardware_class() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Filter.exclude_hardware_class)
    return _impl_.exclude_hardware_class_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Study_Filter::mutable_exclude_hardware_class()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Filter.exclude_hardware_class)
    return &_impl_.exclude_hardware_class_;
}

// repeated string country = 10;
inline int Study_Filter::_internal_country_size() const
{
    return _impl_.country_.size();
}
inline int Study_Filter::country_size() const
{
    return _internal_country_size();
}
inline void Study_Filter::clear_country()
{
    _impl_.country_.Clear();
}
inline std::string* Study_Filter::add_country()
{
    std::string* _s = _internal_add_country();
    // @@protoc_insertion_point(field_add_mutable:variations.Study.Filter.country)
    return _s;
}
inline const std::string& Study_Filter::_internal_country(int index) const
{
    return _impl_.country_.Get(index);
}
inline const std::string& Study_Filter::country(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.country)
    return _internal_country(index);
}
inline std::string* Study_Filter::mutable_country(int index)
{
    // @@protoc_insertion_point(field_mutable:variations.Study.Filter.country)
    return _impl_.country_.Mutable(index);
}
inline void Study_Filter::set_country(int index, const std::string& value)
{
    _impl_.country_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.country)
}
inline void Study_Filter::set_country(int index, std::string&& value)
{
    _impl_.country_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:variations.Study.Filter.country)
}
inline void Study_Filter::set_country(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.country_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:variations.Study.Filter.country)
}
inline void Study_Filter::set_country(int index, const char* value, size_t size)
{
    _impl_.country_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:variations.Study.Filter.country)
}
inline std::string* Study_Filter::_internal_add_country()
{
    return _impl_.country_.Add();
}
inline void Study_Filter::add_country(const std::string& value)
{
    _impl_.country_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:variations.Study.Filter.country)
}
inline void Study_Filter::add_country(std::string&& value)
{
    _impl_.country_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:variations.Study.Filter.country)
}
inline void Study_Filter::add_country(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.country_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:variations.Study.Filter.country)
}
inline void Study_Filter::add_country(const char* value, size_t size)
{
    _impl_.country_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:variations.Study.Filter.country)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& Study_Filter::country() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Filter.country)
    return _impl_.country_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Study_Filter::mutable_country()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Filter.country)
    return &_impl_.country_;
}

// repeated string exclude_country = 11;
inline int Study_Filter::_internal_exclude_country_size() const
{
    return _impl_.exclude_country_.size();
}
inline int Study_Filter::exclude_country_size() const
{
    return _internal_exclude_country_size();
}
inline void Study_Filter::clear_exclude_country()
{
    _impl_.exclude_country_.Clear();
}
inline std::string* Study_Filter::add_exclude_country()
{
    std::string* _s = _internal_add_exclude_country();
    // @@protoc_insertion_point(field_add_mutable:variations.Study.Filter.exclude_country)
    return _s;
}
inline const std::string& Study_Filter::_internal_exclude_country(int index) const
{
    return _impl_.exclude_country_.Get(index);
}
inline const std::string& Study_Filter::exclude_country(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.exclude_country)
    return _internal_exclude_country(index);
}
inline std::string* Study_Filter::mutable_exclude_country(int index)
{
    // @@protoc_insertion_point(field_mutable:variations.Study.Filter.exclude_country)
    return _impl_.exclude_country_.Mutable(index);
}
inline void Study_Filter::set_exclude_country(int index, const std::string& value)
{
    _impl_.exclude_country_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.exclude_country)
}
inline void Study_Filter::set_exclude_country(int index, std::string&& value)
{
    _impl_.exclude_country_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:variations.Study.Filter.exclude_country)
}
inline void Study_Filter::set_exclude_country(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.exclude_country_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:variations.Study.Filter.exclude_country)
}
inline void Study_Filter::set_exclude_country(int index, const char* value, size_t size)
{
    _impl_.exclude_country_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:variations.Study.Filter.exclude_country)
}
inline std::string* Study_Filter::_internal_add_exclude_country()
{
    return _impl_.exclude_country_.Add();
}
inline void Study_Filter::add_exclude_country(const std::string& value)
{
    _impl_.exclude_country_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:variations.Study.Filter.exclude_country)
}
inline void Study_Filter::add_exclude_country(std::string&& value)
{
    _impl_.exclude_country_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:variations.Study.Filter.exclude_country)
}
inline void Study_Filter::add_exclude_country(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.exclude_country_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:variations.Study.Filter.exclude_country)
}
inline void Study_Filter::add_exclude_country(const char* value, size_t size)
{
    _impl_.exclude_country_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:variations.Study.Filter.exclude_country)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& Study_Filter::exclude_country() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Filter.exclude_country)
    return _impl_.exclude_country_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Study_Filter::mutable_exclude_country()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Filter.exclude_country)
    return &_impl_.exclude_country_;
}

// optional bool is_low_end_device = 15;
inline bool Study_Filter::_internal_has_is_low_end_device() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool Study_Filter::has_is_low_end_device() const
{
    return _internal_has_is_low_end_device();
}
inline void Study_Filter::clear_is_low_end_device()
{
    _impl_.is_low_end_device_ = false;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool Study_Filter::_internal_is_low_end_device() const
{
    return _impl_.is_low_end_device_;
}
inline bool Study_Filter::is_low_end_device() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.is_low_end_device)
    return _internal_is_low_end_device();
}
inline void Study_Filter::_internal_set_is_low_end_device(bool value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.is_low_end_device_ = value;
}
inline void Study_Filter::set_is_low_end_device(bool value)
{
    _internal_set_is_low_end_device(value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.is_low_end_device)
}

// optional bool is_enterprise = 18;
inline bool Study_Filter::_internal_has_is_enterprise() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool Study_Filter::has_is_enterprise() const
{
    return _internal_has_is_enterprise();
}
inline void Study_Filter::clear_is_enterprise()
{
    _impl_.is_enterprise_ = false;
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool Study_Filter::_internal_is_enterprise() const
{
    return _impl_.is_enterprise_;
}
inline bool Study_Filter::is_enterprise() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.is_enterprise)
    return _internal_is_enterprise();
}
inline void Study_Filter::_internal_set_is_enterprise(bool value)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.is_enterprise_ = value;
}
inline void Study_Filter::set_is_enterprise(bool value)
{
    _internal_set_is_enterprise(value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.is_enterprise)
}

// optional .variations.Study.PolicyRestriction policy_restriction = 19 [default = NONE];
inline bool Study_Filter::_internal_has_policy_restriction() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool Study_Filter::has_policy_restriction() const
{
    return _internal_has_policy_restriction();
}
inline void Study_Filter::clear_policy_restriction()
{
    _impl_.policy_restriction_ = 0;
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::variations::Study_PolicyRestriction Study_Filter::_internal_policy_restriction() const
{
    return static_cast<::variations::Study_PolicyRestriction>(_impl_.policy_restriction_);
}
inline ::variations::Study_PolicyRestriction Study_Filter::policy_restriction() const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.policy_restriction)
    return _internal_policy_restriction();
}
inline void Study_Filter::_internal_set_policy_restriction(::variations::Study_PolicyRestriction value)
{
    assert(::variations::Study_PolicyRestriction_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.policy_restriction_ = value;
}
inline void Study_Filter::set_policy_restriction(::variations::Study_PolicyRestriction value)
{
    _internal_set_policy_restriction(value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.policy_restriction)
}

// repeated .variations.Study.CpuArchitecture cpu_architecture = 20;
inline int Study_Filter::_internal_cpu_architecture_size() const
{
    return _impl_.cpu_architecture_.size();
}
inline int Study_Filter::cpu_architecture_size() const
{
    return _internal_cpu_architecture_size();
}
inline void Study_Filter::clear_cpu_architecture()
{
    _impl_.cpu_architecture_.Clear();
}
inline ::variations::Study_CpuArchitecture Study_Filter::_internal_cpu_architecture(int index) const
{
    return static_cast<::variations::Study_CpuArchitecture>(_impl_.cpu_architecture_.Get(index));
}
inline ::variations::Study_CpuArchitecture Study_Filter::cpu_architecture(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.cpu_architecture)
    return _internal_cpu_architecture(index);
}
inline void Study_Filter::set_cpu_architecture(int index, ::variations::Study_CpuArchitecture value)
{
    assert(::variations::Study_CpuArchitecture_IsValid(value));
    _impl_.cpu_architecture_.Set(index, value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.cpu_architecture)
}
inline void Study_Filter::_internal_add_cpu_architecture(::variations::Study_CpuArchitecture value)
{
    assert(::variations::Study_CpuArchitecture_IsValid(value));
    _impl_.cpu_architecture_.Add(value);
}
inline void Study_Filter::add_cpu_architecture(::variations::Study_CpuArchitecture value)
{
    _internal_add_cpu_architecture(value);
    // @@protoc_insertion_point(field_add:variations.Study.Filter.cpu_architecture)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& Study_Filter::cpu_architecture() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Filter.cpu_architecture)
    return _impl_.cpu_architecture_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Study_Filter::_internal_mutable_cpu_architecture()
{
    return &_impl_.cpu_architecture_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Study_Filter::mutable_cpu_architecture()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Filter.cpu_architecture)
    return _internal_mutable_cpu_architecture();
}

// repeated .variations.Study.CpuArchitecture exclude_cpu_architecture = 21;
inline int Study_Filter::_internal_exclude_cpu_architecture_size() const
{
    return _impl_.exclude_cpu_architecture_.size();
}
inline int Study_Filter::exclude_cpu_architecture_size() const
{
    return _internal_exclude_cpu_architecture_size();
}
inline void Study_Filter::clear_exclude_cpu_architecture()
{
    _impl_.exclude_cpu_architecture_.Clear();
}
inline ::variations::Study_CpuArchitecture Study_Filter::_internal_exclude_cpu_architecture(int index) const
{
    return static_cast<::variations::Study_CpuArchitecture>(_impl_.exclude_cpu_architecture_.Get(index));
}
inline ::variations::Study_CpuArchitecture Study_Filter::exclude_cpu_architecture(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.exclude_cpu_architecture)
    return _internal_exclude_cpu_architecture(index);
}
inline void Study_Filter::set_exclude_cpu_architecture(int index, ::variations::Study_CpuArchitecture value)
{
    assert(::variations::Study_CpuArchitecture_IsValid(value));
    _impl_.exclude_cpu_architecture_.Set(index, value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.exclude_cpu_architecture)
}
inline void Study_Filter::_internal_add_exclude_cpu_architecture(::variations::Study_CpuArchitecture value)
{
    assert(::variations::Study_CpuArchitecture_IsValid(value));
    _impl_.exclude_cpu_architecture_.Add(value);
}
inline void Study_Filter::add_exclude_cpu_architecture(::variations::Study_CpuArchitecture value)
{
    _internal_add_exclude_cpu_architecture(value);
    // @@protoc_insertion_point(field_add:variations.Study.Filter.exclude_cpu_architecture)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& Study_Filter::exclude_cpu_architecture() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Filter.exclude_cpu_architecture)
    return _impl_.exclude_cpu_architecture_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Study_Filter::_internal_mutable_exclude_cpu_architecture()
{
    return &_impl_.exclude_cpu_architecture_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* Study_Filter::mutable_exclude_cpu_architecture()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Filter.exclude_cpu_architecture)
    return _internal_mutable_exclude_cpu_architecture();
}

// repeated int64 google_group = 22 [packed = true];
inline int Study_Filter::_internal_google_group_size() const
{
    return _impl_.google_group_.size();
}
inline int Study_Filter::google_group_size() const
{
    return _internal_google_group_size();
}
inline void Study_Filter::clear_google_group()
{
    _impl_.google_group_.Clear();
}
inline int64_t Study_Filter::_internal_google_group(int index) const
{
    return _impl_.google_group_.Get(index);
}
inline int64_t Study_Filter::google_group(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.google_group)
    return _internal_google_group(index);
}
inline void Study_Filter::set_google_group(int index, int64_t value)
{
    _impl_.google_group_.Set(index, value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.google_group)
}
inline void Study_Filter::_internal_add_google_group(int64_t value)
{
    _impl_.google_group_.Add(value);
}
inline void Study_Filter::add_google_group(int64_t value)
{
    _internal_add_google_group(value);
    // @@protoc_insertion_point(field_add:variations.Study.Filter.google_group)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>& Study_Filter::_internal_google_group() const
{
    return _impl_.google_group_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>& Study_Filter::google_group() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Filter.google_group)
    return _internal_google_group();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>* Study_Filter::_internal_mutable_google_group()
{
    return &_impl_.google_group_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>* Study_Filter::mutable_google_group()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Filter.google_group)
    return _internal_mutable_google_group();
}

// repeated int64 exclude_google_group = 23 [packed = true];
inline int Study_Filter::_internal_exclude_google_group_size() const
{
    return _impl_.exclude_google_group_.size();
}
inline int Study_Filter::exclude_google_group_size() const
{
    return _internal_exclude_google_group_size();
}
inline void Study_Filter::clear_exclude_google_group()
{
    _impl_.exclude_google_group_.Clear();
}
inline int64_t Study_Filter::_internal_exclude_google_group(int index) const
{
    return _impl_.exclude_google_group_.Get(index);
}
inline int64_t Study_Filter::exclude_google_group(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.Filter.exclude_google_group)
    return _internal_exclude_google_group(index);
}
inline void Study_Filter::set_exclude_google_group(int index, int64_t value)
{
    _impl_.exclude_google_group_.Set(index, value);
    // @@protoc_insertion_point(field_set:variations.Study.Filter.exclude_google_group)
}
inline void Study_Filter::_internal_add_exclude_google_group(int64_t value)
{
    _impl_.exclude_google_group_.Add(value);
}
inline void Study_Filter::add_exclude_google_group(int64_t value)
{
    _internal_add_exclude_google_group(value);
    // @@protoc_insertion_point(field_add:variations.Study.Filter.exclude_google_group)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>& Study_Filter::_internal_exclude_google_group() const
{
    return _impl_.exclude_google_group_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>& Study_Filter::exclude_google_group() const
{
    // @@protoc_insertion_point(field_list:variations.Study.Filter.exclude_google_group)
    return _internal_exclude_google_group();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>* Study_Filter::_internal_mutable_exclude_google_group()
{
    return &_impl_.exclude_google_group_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>* Study_Filter::mutable_exclude_google_group()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.Filter.exclude_google_group)
    return _internal_mutable_exclude_google_group();
}

// -------------------------------------------------------------------

// Study

// required string name = 1;
inline bool Study::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Study::has_name() const
{
    return _internal_has_name();
}
inline void Study::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Study::name() const
{
    // @@protoc_insertion_point(field_get:variations.Study.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Study::set_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:variations.Study.name)
}
inline std::string* Study::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:variations.Study.name)
    return _s;
}
inline const std::string& Study::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void Study::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Study::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Study::release_name()
{
    // @@protoc_insertion_point(field_release:variations.Study.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Study::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:variations.Study.name)
}

// optional int64 expiry_date = 3;
inline bool Study::_internal_has_expiry_date() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool Study::has_expiry_date() const
{
    return _internal_has_expiry_date();
}
inline void Study::clear_expiry_date()
{
    _impl_.expiry_date_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t Study::_internal_expiry_date() const
{
    return _impl_.expiry_date_;
}
inline int64_t Study::expiry_date() const
{
    // @@protoc_insertion_point(field_get:variations.Study.expiry_date)
    return _internal_expiry_date();
}
inline void Study::_internal_set_expiry_date(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.expiry_date_ = value;
}
inline void Study::set_expiry_date(int64_t value)
{
    _internal_set_expiry_date(value);
    // @@protoc_insertion_point(field_set:variations.Study.expiry_date)
}

// optional .variations.Study.Consistency consistency = 7 [default = SESSION];
inline bool Study::_internal_has_consistency() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool Study::has_consistency() const
{
    return _internal_has_consistency();
}
inline void Study::clear_consistency()
{
    _impl_.consistency_ = 0;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::variations::Study_Consistency Study::_internal_consistency() const
{
    return static_cast<::variations::Study_Consistency>(_impl_.consistency_);
}
inline ::variations::Study_Consistency Study::consistency() const
{
    // @@protoc_insertion_point(field_get:variations.Study.consistency)
    return _internal_consistency();
}
inline void Study::_internal_set_consistency(::variations::Study_Consistency value)
{
    assert(::variations::Study_Consistency_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.consistency_ = value;
}
inline void Study::set_consistency(::variations::Study_Consistency value)
{
    _internal_set_consistency(value);
    // @@protoc_insertion_point(field_set:variations.Study.consistency)
}

// optional .variations.LayerMemberReference layer = 16;
inline bool Study::_internal_has_layer() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.layer_ != nullptr);
    return value;
}
inline bool Study::has_layer() const
{
    return _internal_has_layer();
}
inline const ::variations::LayerMemberReference& Study::_internal_layer() const
{
    const ::variations::LayerMemberReference* p = _impl_.layer_;
    return p != nullptr ? *p : reinterpret_cast<const ::variations::LayerMemberReference&>(::variations::_LayerMemberReference_default_instance_);
}
inline const ::variations::LayerMemberReference& Study::layer() const
{
    // @@protoc_insertion_point(field_get:variations.Study.layer)
    return _internal_layer();
}
inline void Study::unsafe_arena_set_allocated_layer(::variations::LayerMemberReference* layer)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.layer_);
    }
    _impl_.layer_ = layer;
    if (layer) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:variations.Study.layer)
}
inline ::variations::LayerMemberReference* Study::release_layer()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::variations::LayerMemberReference* temp = _impl_.layer_;
    _impl_.layer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::variations::LayerMemberReference* Study::unsafe_arena_release_layer()
{
    // @@protoc_insertion_point(field_release:variations.Study.layer)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::variations::LayerMemberReference* temp = _impl_.layer_;
    _impl_.layer_ = nullptr;
    return temp;
}
inline ::variations::LayerMemberReference* Study::_internal_mutable_layer()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.layer_ == nullptr) {
        auto* p = CreateMaybeMessage<::variations::LayerMemberReference>(GetArenaForAllocation());
        _impl_.layer_ = p;
    }
    return _impl_.layer_;
}
inline ::variations::LayerMemberReference* Study::mutable_layer()
{
    ::variations::LayerMemberReference* _msg = _internal_mutable_layer();
    // @@protoc_insertion_point(field_mutable:variations.Study.layer)
    return _msg;
}
inline void Study::set_allocated_layer(::variations::LayerMemberReference* layer)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.layer_);
    }
    if (layer) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(layer));
        if (message_arena != submessage_arena) {
            layer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, layer, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.layer_ = layer;
    // @@protoc_insertion_point(field_set_allocated:variations.Study.layer)
}

// optional string default_experiment_name = 8;
inline bool Study::_internal_has_default_experiment_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Study::has_default_experiment_name() const
{
    return _internal_has_default_experiment_name();
}
inline void Study::clear_default_experiment_name()
{
    _impl_.default_experiment_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Study::default_experiment_name() const
{
    // @@protoc_insertion_point(field_get:variations.Study.default_experiment_name)
    return _internal_default_experiment_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Study::set_default_experiment_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.default_experiment_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:variations.Study.default_experiment_name)
}
inline std::string* Study::mutable_default_experiment_name()
{
    std::string* _s = _internal_mutable_default_experiment_name();
    // @@protoc_insertion_point(field_mutable:variations.Study.default_experiment_name)
    return _s;
}
inline const std::string& Study::_internal_default_experiment_name() const
{
    return _impl_.default_experiment_name_.Get();
}
inline void Study::_internal_set_default_experiment_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.default_experiment_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Study::_internal_mutable_default_experiment_name()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.default_experiment_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Study::release_default_experiment_name()
{
    // @@protoc_insertion_point(field_release:variations.Study.default_experiment_name)
    if (!_internal_has_default_experiment_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.default_experiment_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.default_experiment_name_.IsDefault()) {
        _impl_.default_experiment_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Study::set_allocated_default_experiment_name(std::string* default_experiment_name)
{
    if (default_experiment_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.default_experiment_name_.SetAllocated(default_experiment_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.default_experiment_name_.IsDefault()) {
        _impl_.default_experiment_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:variations.Study.default_experiment_name)
}

// repeated .variations.Study.Experiment experiment = 9;
inline int Study::_internal_experiment_size() const
{
    return _impl_.experiment_.size();
}
inline int Study::experiment_size() const
{
    return _internal_experiment_size();
}
inline void Study::clear_experiment()
{
    _impl_.experiment_.Clear();
}
inline ::variations::Study_Experiment* Study::mutable_experiment(int index)
{
    // @@protoc_insertion_point(field_mutable:variations.Study.experiment)
    return _impl_.experiment_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment>* Study::mutable_experiment()
{
    // @@protoc_insertion_point(field_mutable_list:variations.Study.experiment)
    return &_impl_.experiment_;
}
inline const ::variations::Study_Experiment& Study::_internal_experiment(int index) const
{
    return _impl_.experiment_.Get(index);
}
inline const ::variations::Study_Experiment& Study::experiment(int index) const
{
    // @@protoc_insertion_point(field_get:variations.Study.experiment)
    return _internal_experiment(index);
}
inline ::variations::Study_Experiment* Study::_internal_add_experiment()
{
    return _impl_.experiment_.Add();
}
inline ::variations::Study_Experiment* Study::add_experiment()
{
    ::variations::Study_Experiment* _add = _internal_add_experiment();
    // @@protoc_insertion_point(field_add:variations.Study.experiment)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::variations::Study_Experiment>& Study::experiment() const
{
    // @@protoc_insertion_point(field_list:variations.Study.experiment)
    return _impl_.experiment_;
}

// optional .variations.Study.Filter filter = 10;
inline bool Study::_internal_has_filter() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
    return value;
}
inline bool Study::has_filter() const
{
    return _internal_has_filter();
}
inline void Study::clear_filter()
{
    if (_impl_.filter_ != nullptr)
        _impl_.filter_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::variations::Study_Filter& Study::_internal_filter() const
{
    const ::variations::Study_Filter* p = _impl_.filter_;
    return p != nullptr ? *p : reinterpret_cast<const ::variations::Study_Filter&>(::variations::_Study_Filter_default_instance_);
}
inline const ::variations::Study_Filter& Study::filter() const
{
    // @@protoc_insertion_point(field_get:variations.Study.filter)
    return _internal_filter();
}
inline void Study::unsafe_arena_set_allocated_filter(::variations::Study_Filter* filter)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
    }
    _impl_.filter_ = filter;
    if (filter) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:variations.Study.filter)
}
inline ::variations::Study_Filter* Study::release_filter()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::variations::Study_Filter* temp = _impl_.filter_;
    _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::variations::Study_Filter* Study::unsafe_arena_release_filter()
{
    // @@protoc_insertion_point(field_release:variations.Study.filter)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::variations::Study_Filter* temp = _impl_.filter_;
    _impl_.filter_ = nullptr;
    return temp;
}
inline ::variations::Study_Filter* Study::_internal_mutable_filter()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.filter_ == nullptr) {
        auto* p = CreateMaybeMessage<::variations::Study_Filter>(GetArenaForAllocation());
        _impl_.filter_ = p;
    }
    return _impl_.filter_;
}
inline ::variations::Study_Filter* Study::mutable_filter()
{
    ::variations::Study_Filter* _msg = _internal_mutable_filter();
    // @@protoc_insertion_point(field_mutable:variations.Study.filter)
    return _msg;
}
inline void Study::set_allocated_filter(::variations::Study_Filter* filter)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.filter_;
    }
    if (filter) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
        if (message_arena != submessage_arena) {
            filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, filter, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.filter_ = filter;
    // @@protoc_insertion_point(field_set_allocated:variations.Study.filter)
}

// optional uint32 randomization_seed = 11;
inline bool Study::_internal_has_randomization_seed() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool Study::has_randomization_seed() const
{
    return _internal_has_randomization_seed();
}
inline void Study::clear_randomization_seed()
{
    _impl_.randomization_seed_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t Study::_internal_randomization_seed() const
{
    return _impl_.randomization_seed_;
}
inline uint32_t Study::randomization_seed() const
{
    // @@protoc_insertion_point(field_get:variations.Study.randomization_seed)
    return _internal_randomization_seed();
}
inline void Study::_internal_set_randomization_seed(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.randomization_seed_ = value;
}
inline void Study::set_randomization_seed(uint32_t value)
{
    _internal_set_randomization_seed(value);
    // @@protoc_insertion_point(field_set:variations.Study.randomization_seed)
}

// optional .variations.Study.ActivationType activation_type = 12;
inline bool Study::_internal_has_activation_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool Study::has_activation_type() const
{
    return _internal_has_activation_type();
}
inline void Study::clear_activation_type()
{
    _impl_.activation_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::variations::Study_ActivationType Study::_internal_activation_type() const
{
    return static_cast<::variations::Study_ActivationType>(_impl_.activation_type_);
}
inline ::variations::Study_ActivationType Study::activation_type() const
{
    // @@protoc_insertion_point(field_get:variations.Study.activation_type)
    return _internal_activation_type();
}
inline void Study::_internal_set_activation_type(::variations::Study_ActivationType value)
{
    assert(::variations::Study_ActivationType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.activation_type_ = value;
}
inline void Study::set_activation_type(::variations::Study_ActivationType value)
{
    _internal_set_activation_type(value);
    // @@protoc_insertion_point(field_set:variations.Study.activation_type)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace variations

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::variations::Study_Experiment_Type> : ::std::true_type { };
template <> struct is_proto_enum<::variations::Study_Consistency> : ::std::true_type { };
template <> struct is_proto_enum<::variations::Study_GoogleWebVisibility> : ::std::true_type { };
template <> struct is_proto_enum<::variations::Study_Channel> : ::std::true_type { };
template <> struct is_proto_enum<::variations::Study_Platform> : ::std::true_type { };
template <> struct is_proto_enum<::variations::Study_FormFactor> : ::std::true_type { };
template <> struct is_proto_enum<::variations::Study_CpuArchitecture> : ::std::true_type { };
template <> struct is_proto_enum<::variations::Study_OptionalBool> : ::std::true_type { };
template <> struct is_proto_enum<::variations::Study_PolicyRestriction> : ::std::true_type { };
template <> struct is_proto_enum<::variations::Study_ActivationType> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_study_2eproto
