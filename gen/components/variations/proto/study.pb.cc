// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: study.proto

#include "study.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace variations {
PROTOBUF_CONSTEXPR Study_Experiment_Param::Study_Experiment_Param(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct Study_Experiment_ParamDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Study_Experiment_ParamDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Study_Experiment_ParamDefaultTypeInternal()
    {
    }
    union {
        Study_Experiment_Param _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_Experiment_ParamDefaultTypeInternal
    _Study_Experiment_Param_default_instance_;
PROTOBUF_CONSTEXPR Study_Experiment_FeatureAssociation::Study_Experiment_FeatureAssociation(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.enable_feature_)*/ {},
        /*decltype(_impl_.disable_feature_)*/ {},
        /*decltype(_impl_.forcing_feature_on_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.forcing_feature_off_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct Study_Experiment_FeatureAssociationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Study_Experiment_FeatureAssociationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Study_Experiment_FeatureAssociationDefaultTypeInternal()
    {
    }
    union {
        Study_Experiment_FeatureAssociation _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_Experiment_FeatureAssociationDefaultTypeInternal
    _Study_Experiment_FeatureAssociation_default_instance_;
PROTOBUF_CONSTEXPR Study_Experiment_OverrideUIString::Study_Experiment_OverrideUIString(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.name_hash_)*/ 0u }
{
}
struct Study_Experiment_OverrideUIStringDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Study_Experiment_OverrideUIStringDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Study_Experiment_OverrideUIStringDefaultTypeInternal()
    {
    }
    union {
        Study_Experiment_OverrideUIString _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_Experiment_OverrideUIStringDefaultTypeInternal
    _Study_Experiment_OverrideUIString_default_instance_;
PROTOBUF_CONSTEXPR Study_Experiment::Study_Experiment(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.param_)*/ {},
        /*decltype(_impl_.override_ui_string_)*/ {}, /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.forcing_flag_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.feature_association_)*/ nullptr, /*decltype(_impl_.google_web_experiment_id_)*/ uint64_t { 0u },
        /*decltype(_impl_.probability_weight_)*/ 0u, /*decltype(_impl_.type_)*/ 0, /*decltype(_impl_.google_web_trigger_experiment_id_)*/ uint64_t { 0u },
        /*decltype(_impl_.google_app_experiment_id_)*/ uint64_t { 0u }, /*decltype(_impl_.google_web_visibility_)*/ 0 }
{
}
struct Study_ExperimentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Study_ExperimentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Study_ExperimentDefaultTypeInternal()
    {
    }
    union {
        Study_Experiment _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_ExperimentDefaultTypeInternal _Study_Experiment_default_instance_;
PROTOBUF_CONSTEXPR Study_Filter::Study_Filter(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.channel_)*/ {}, /*decltype(_impl_.platform_)*/ {},
        /*decltype(_impl_.locale_)*/ {}, /*decltype(_impl_.form_factor_)*/ {}, /*decltype(_impl_.hardware_class_)*/ {},
        /*decltype(_impl_.exclude_hardware_class_)*/ {}, /*decltype(_impl_.country_)*/ {}, /*decltype(_impl_.exclude_country_)*/ {},
        /*decltype(_impl_.exclude_locale_)*/ {}, /*decltype(_impl_.exclude_form_factor_)*/ {}, /*decltype(_impl_.cpu_architecture_)*/ {},
        /*decltype(_impl_.exclude_cpu_architecture_)*/ {}, /*decltype(_impl_.google_group_)*/ {}, /*decltype(_impl_._google_group_cached_byte_size_)*/ { 0 },
        /*decltype(_impl_.exclude_google_group_)*/ {}, /*decltype(_impl_._exclude_google_group_cached_byte_size_)*/ { 0 },
        /*decltype(_impl_.min_version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.max_version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.min_os_version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.max_os_version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.start_date_)*/ int64_t { 0 }, /*decltype(_impl_.end_date_)*/ int64_t { 0 }, /*decltype(_impl_.is_low_end_device_)*/ false,
        /*decltype(_impl_.is_enterprise_)*/ false, /*decltype(_impl_.policy_restriction_)*/ 0 }
{
}
struct Study_FilterDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Study_FilterDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Study_FilterDefaultTypeInternal()
    {
    }
    union {
        Study_Filter _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_FilterDefaultTypeInternal _Study_Filter_default_instance_;
PROTOBUF_CONSTEXPR Study::Study(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.experiment_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.default_experiment_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.filter_)*/ nullptr, /*decltype(_impl_.layer_)*/ nullptr, /*decltype(_impl_.expiry_date_)*/ int64_t { 0 },
        /*decltype(_impl_.consistency_)*/ 0, /*decltype(_impl_.randomization_seed_)*/ 0u, /*decltype(_impl_.activation_type_)*/ 0 }
{
}
struct StudyDefaultTypeInternal {
    PROTOBUF_CONSTEXPR StudyDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~StudyDefaultTypeInternal()
    {
    }
    union {
        Study _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StudyDefaultTypeInternal _Study_default_instance_;
} // namespace variations
namespace variations {
bool Study_Experiment_Type_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_Experiment_Type_strings[4] = {};

static const char Study_Experiment_Type_names[] = "IGNORE_CHANGE"
                                                  "KILL_BEST_EFFORT"
                                                  "KILL_CRITICAL"
                                                  "NORMAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_Experiment_Type_entries[] = {
    { { Study_Experiment_Type_names + 0, 13 }, 1 },
    { { Study_Experiment_Type_names + 13, 16 }, 2 },
    { { Study_Experiment_Type_names + 29, 13 }, 3 },
    { { Study_Experiment_Type_names + 42, 6 }, 0 },
};

static const int Study_Experiment_Type_entries_by_number[] = {
    3, // 0 -> NORMAL
    0, // 1 -> IGNORE_CHANGE
    1, // 2 -> KILL_BEST_EFFORT
    2, // 3 -> KILL_CRITICAL
};

const std::string& Study_Experiment_Type_Name(Study_Experiment_Type value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        Study_Experiment_Type_entries, Study_Experiment_Type_entries_by_number, 4, Study_Experiment_Type_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Study_Experiment_Type_entries, Study_Experiment_Type_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Study_Experiment_Type_strings[idx].get();
}
bool Study_Experiment_Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Experiment_Type* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Study_Experiment_Type_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<Study_Experiment_Type>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_Experiment_Type Study_Experiment::NORMAL;
constexpr Study_Experiment_Type Study_Experiment::IGNORE_CHANGE;
constexpr Study_Experiment_Type Study_Experiment::KILL_BEST_EFFORT;
constexpr Study_Experiment_Type Study_Experiment::KILL_CRITICAL;
constexpr Study_Experiment_Type Study_Experiment::Type_MIN;
constexpr Study_Experiment_Type Study_Experiment::Type_MAX;
constexpr int Study_Experiment::Type_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_Consistency_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_Consistency_strings[2] = {};

static const char Study_Consistency_names[] = "PERMANENT"
                                              "SESSION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_Consistency_entries[] = {
    { { Study_Consistency_names + 0, 9 }, 1 },
    { { Study_Consistency_names + 9, 7 }, 0 },
};

static const int Study_Consistency_entries_by_number[] = {
    1, // 0 -> SESSION
    0, // 1 -> PERMANENT
};

const std::string& Study_Consistency_Name(Study_Consistency value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        Study_Consistency_entries, Study_Consistency_entries_by_number, 2, Study_Consistency_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Study_Consistency_entries, Study_Consistency_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Study_Consistency_strings[idx].get();
}
bool Study_Consistency_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Consistency* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Study_Consistency_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<Study_Consistency>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_Consistency Study::SESSION;
constexpr Study_Consistency Study::PERMANENT;
constexpr Study_Consistency Study::Consistency_MIN;
constexpr Study_Consistency Study::Consistency_MAX;
constexpr int Study::Consistency_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_GoogleWebVisibility_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_GoogleWebVisibility_strings[2] = {};

static const char Study_GoogleWebVisibility_names[] = "ANY"
                                                      "FIRST_PARTY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_GoogleWebVisibility_entries[] = {
    { { Study_GoogleWebVisibility_names + 0, 3 }, 0 },
    { { Study_GoogleWebVisibility_names + 3, 11 }, 1 },
};

static const int Study_GoogleWebVisibility_entries_by_number[] = {
    0, // 0 -> ANY
    1, // 1 -> FIRST_PARTY
};

const std::string& Study_GoogleWebVisibility_Name(Study_GoogleWebVisibility value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        Study_GoogleWebVisibility_entries, Study_GoogleWebVisibility_entries_by_number, 2, Study_GoogleWebVisibility_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Study_GoogleWebVisibility_entries, Study_GoogleWebVisibility_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Study_GoogleWebVisibility_strings[idx].get();
}
bool Study_GoogleWebVisibility_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_GoogleWebVisibility* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Study_GoogleWebVisibility_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<Study_GoogleWebVisibility>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_GoogleWebVisibility Study::ANY;
constexpr Study_GoogleWebVisibility Study::FIRST_PARTY;
constexpr Study_GoogleWebVisibility Study::GoogleWebVisibility_MIN;
constexpr Study_GoogleWebVisibility Study::GoogleWebVisibility_MAX;
constexpr int Study::GoogleWebVisibility_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_Channel_IsValid(int value)
{
    switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_Channel_strings[5] = {};

static const char Study_Channel_names[] = "BETA"
                                          "CANARY"
                                          "DEV"
                                          "STABLE"
                                          "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_Channel_entries[] = {
    { { Study_Channel_names + 0, 4 }, 2 },
    { { Study_Channel_names + 4, 6 }, 0 },
    { { Study_Channel_names + 10, 3 }, 1 },
    { { Study_Channel_names + 13, 6 }, 3 },
    { { Study_Channel_names + 19, 7 }, -1 },
};

static const int Study_Channel_entries_by_number[] = {
    4, // -1 -> UNKNOWN
    1, // 0 -> CANARY
    2, // 1 -> DEV
    0, // 2 -> BETA
    3, // 3 -> STABLE
};

const std::string& Study_Channel_Name(Study_Channel value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(Study_Channel_entries, Study_Channel_entries_by_number, 5, Study_Channel_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Study_Channel_entries, Study_Channel_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Study_Channel_strings[idx].get();
}
bool Study_Channel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Channel* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Study_Channel_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<Study_Channel>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_Channel Study::UNKNOWN;
constexpr Study_Channel Study::CANARY;
constexpr Study_Channel Study::DEV;
constexpr Study_Channel Study::BETA;
constexpr Study_Channel Study::STABLE;
constexpr Study_Channel Study::Channel_MIN;
constexpr Study_Channel Study::Channel_MAX;
constexpr int Study::Channel_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_Platform_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_Platform_strings[10] = {};

static const char Study_Platform_names[] = "PLATFORM_ANDROID"
                                           "PLATFORM_ANDROID_WEBLAYER"
                                           "PLATFORM_ANDROID_WEBVIEW"
                                           "PLATFORM_CHROMEOS"
                                           "PLATFORM_CHROMEOS_LACROS"
                                           "PLATFORM_FUCHSIA"
                                           "PLATFORM_IOS"
                                           "PLATFORM_LINUX"
                                           "PLATFORM_MAC"
                                           "PLATFORM_WINDOWS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_Platform_entries[] = {
    { { Study_Platform_names + 0, 16 }, 4 },
    { { Study_Platform_names + 16, 25 }, 8 },
    { { Study_Platform_names + 41, 24 }, 6 },
    { { Study_Platform_names + 65, 17 }, 3 },
    { { Study_Platform_names + 82, 24 }, 9 },
    { { Study_Platform_names + 106, 16 }, 7 },
    { { Study_Platform_names + 122, 12 }, 5 },
    { { Study_Platform_names + 134, 14 }, 2 },
    { { Study_Platform_names + 148, 12 }, 1 },
    { { Study_Platform_names + 160, 16 }, 0 },
};

static const int Study_Platform_entries_by_number[] = {
    9, // 0 -> PLATFORM_WINDOWS
    8, // 1 -> PLATFORM_MAC
    7, // 2 -> PLATFORM_LINUX
    3, // 3 -> PLATFORM_CHROMEOS
    0, // 4 -> PLATFORM_ANDROID
    6, // 5 -> PLATFORM_IOS
    2, // 6 -> PLATFORM_ANDROID_WEBVIEW
    5, // 7 -> PLATFORM_FUCHSIA
    1, // 8 -> PLATFORM_ANDROID_WEBLAYER
    4, // 9 -> PLATFORM_CHROMEOS_LACROS
};

const std::string& Study_Platform_Name(Study_Platform value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(Study_Platform_entries, Study_Platform_entries_by_number, 10, Study_Platform_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Study_Platform_entries, Study_Platform_entries_by_number, 10, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Study_Platform_strings[idx].get();
}
bool Study_Platform_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Platform* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Study_Platform_entries, 10, name, &int_value);
    if (success) {
        *value = static_cast<Study_Platform>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_Platform Study::PLATFORM_WINDOWS;
constexpr Study_Platform Study::PLATFORM_MAC;
constexpr Study_Platform Study::PLATFORM_LINUX;
constexpr Study_Platform Study::PLATFORM_CHROMEOS;
constexpr Study_Platform Study::PLATFORM_ANDROID;
constexpr Study_Platform Study::PLATFORM_IOS;
constexpr Study_Platform Study::PLATFORM_ANDROID_WEBVIEW;
constexpr Study_Platform Study::PLATFORM_FUCHSIA;
constexpr Study_Platform Study::PLATFORM_ANDROID_WEBLAYER;
constexpr Study_Platform Study::PLATFORM_CHROMEOS_LACROS;
constexpr Study_Platform Study::Platform_MIN;
constexpr Study_Platform Study::Platform_MAX;
constexpr int Study::Platform_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_FormFactor_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_FormFactor_strings[8] = {};

static const char Study_FormFactor_names[] = "AUTOMOTIVE"
                                             "DESKTOP"
                                             "FOLDABLE"
                                             "KIOSK"
                                             "MEET_DEVICE"
                                             "PHONE"
                                             "TABLET"
                                             "TV";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_FormFactor_entries[] = {
    { { Study_FormFactor_names + 0, 10 }, 6 },
    { { Study_FormFactor_names + 10, 7 }, 0 },
    { { Study_FormFactor_names + 17, 8 }, 7 },
    { { Study_FormFactor_names + 25, 5 }, 3 },
    { { Study_FormFactor_names + 30, 11 }, 4 },
    { { Study_FormFactor_names + 41, 5 }, 1 },
    { { Study_FormFactor_names + 46, 6 }, 2 },
    { { Study_FormFactor_names + 52, 2 }, 5 },
};

static const int Study_FormFactor_entries_by_number[] = {
    1, // 0 -> DESKTOP
    5, // 1 -> PHONE
    6, // 2 -> TABLET
    3, // 3 -> KIOSK
    4, // 4 -> MEET_DEVICE
    7, // 5 -> TV
    0, // 6 -> AUTOMOTIVE
    2, // 7 -> FOLDABLE
};

const std::string& Study_FormFactor_Name(Study_FormFactor value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(Study_FormFactor_entries, Study_FormFactor_entries_by_number, 8, Study_FormFactor_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Study_FormFactor_entries, Study_FormFactor_entries_by_number, 8, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Study_FormFactor_strings[idx].get();
}
bool Study_FormFactor_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_FormFactor* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Study_FormFactor_entries, 8, name, &int_value);
    if (success) {
        *value = static_cast<Study_FormFactor>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_FormFactor Study::DESKTOP;
constexpr Study_FormFactor Study::PHONE;
constexpr Study_FormFactor Study::TABLET;
constexpr Study_FormFactor Study::KIOSK;
constexpr Study_FormFactor Study::MEET_DEVICE;
constexpr Study_FormFactor Study::TV;
constexpr Study_FormFactor Study::AUTOMOTIVE;
constexpr Study_FormFactor Study::FOLDABLE;
constexpr Study_FormFactor Study::FormFactor_MIN;
constexpr Study_FormFactor Study::FormFactor_MAX;
constexpr int Study::FormFactor_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_CpuArchitecture_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_CpuArchitecture_strings[5] = {};

static const char Study_CpuArchitecture_names[] = "ARM32"
                                                  "ARM64"
                                                  "TRANSLATED_X86_64"
                                                  "X86_32"
                                                  "X86_64";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_CpuArchitecture_entries[] = {
    { { Study_CpuArchitecture_names + 0, 5 }, 3 },
    { { Study_CpuArchitecture_names + 5, 5 }, 1 },
    { { Study_CpuArchitecture_names + 10, 17 }, 4 },
    { { Study_CpuArchitecture_names + 27, 6 }, 2 },
    { { Study_CpuArchitecture_names + 33, 6 }, 0 },
};

static const int Study_CpuArchitecture_entries_by_number[] = {
    4, // 0 -> X86_64
    1, // 1 -> ARM64
    3, // 2 -> X86_32
    0, // 3 -> ARM32
    2, // 4 -> TRANSLATED_X86_64
};

const std::string& Study_CpuArchitecture_Name(Study_CpuArchitecture value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        Study_CpuArchitecture_entries, Study_CpuArchitecture_entries_by_number, 5, Study_CpuArchitecture_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Study_CpuArchitecture_entries, Study_CpuArchitecture_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Study_CpuArchitecture_strings[idx].get();
}
bool Study_CpuArchitecture_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_CpuArchitecture* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Study_CpuArchitecture_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<Study_CpuArchitecture>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_CpuArchitecture Study::X86_64;
constexpr Study_CpuArchitecture Study::ARM64;
constexpr Study_CpuArchitecture Study::X86_32;
constexpr Study_CpuArchitecture Study::ARM32;
constexpr Study_CpuArchitecture Study::TRANSLATED_X86_64;
constexpr Study_CpuArchitecture Study::CpuArchitecture_MIN;
constexpr Study_CpuArchitecture Study::CpuArchitecture_MAX;
constexpr int Study::CpuArchitecture_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_OptionalBool_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_OptionalBool_strings[3] = {};

static const char Study_OptionalBool_names[] = "OPTIONAL_BOOL_FALSE"
                                               "OPTIONAL_BOOL_MISSING"
                                               "OPTIONAL_BOOL_TRUE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_OptionalBool_entries[] = {
    { { Study_OptionalBool_names + 0, 19 }, 2 },
    { { Study_OptionalBool_names + 19, 21 }, 0 },
    { { Study_OptionalBool_names + 40, 18 }, 1 },
};

static const int Study_OptionalBool_entries_by_number[] = {
    1, // 0 -> OPTIONAL_BOOL_MISSING
    2, // 1 -> OPTIONAL_BOOL_TRUE
    0, // 2 -> OPTIONAL_BOOL_FALSE
};

const std::string& Study_OptionalBool_Name(Study_OptionalBool value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        Study_OptionalBool_entries, Study_OptionalBool_entries_by_number, 3, Study_OptionalBool_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Study_OptionalBool_entries, Study_OptionalBool_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Study_OptionalBool_strings[idx].get();
}
bool Study_OptionalBool_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_OptionalBool* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Study_OptionalBool_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<Study_OptionalBool>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_OptionalBool Study::OPTIONAL_BOOL_MISSING;
constexpr Study_OptionalBool Study::OPTIONAL_BOOL_TRUE;
constexpr Study_OptionalBool Study::OPTIONAL_BOOL_FALSE;
constexpr Study_OptionalBool Study::OptionalBool_MIN;
constexpr Study_OptionalBool Study::OptionalBool_MAX;
constexpr int Study::OptionalBool_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_PolicyRestriction_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_PolicyRestriction_strings[3] = {};

static const char Study_PolicyRestriction_names[] = "CRITICAL"
                                                    "CRITICAL_ONLY"
                                                    "NONE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_PolicyRestriction_entries[] = {
    { { Study_PolicyRestriction_names + 0, 8 }, 1 },
    { { Study_PolicyRestriction_names + 8, 13 }, 2 },
    { { Study_PolicyRestriction_names + 21, 4 }, 0 },
};

static const int Study_PolicyRestriction_entries_by_number[] = {
    2, // 0 -> NONE
    0, // 1 -> CRITICAL
    1, // 2 -> CRITICAL_ONLY
};

const std::string& Study_PolicyRestriction_Name(Study_PolicyRestriction value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        Study_PolicyRestriction_entries, Study_PolicyRestriction_entries_by_number, 3, Study_PolicyRestriction_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Study_PolicyRestriction_entries, Study_PolicyRestriction_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Study_PolicyRestriction_strings[idx].get();
}
bool Study_PolicyRestriction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_PolicyRestriction* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Study_PolicyRestriction_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<Study_PolicyRestriction>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_PolicyRestriction Study::NONE;
constexpr Study_PolicyRestriction Study::CRITICAL;
constexpr Study_PolicyRestriction Study::CRITICAL_ONLY;
constexpr Study_PolicyRestriction Study::PolicyRestriction_MIN;
constexpr Study_PolicyRestriction Study::PolicyRestriction_MAX;
constexpr int Study::PolicyRestriction_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_ActivationType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_ActivationType_strings[2] = {};

static const char Study_ActivationType_names[] = "ACTIVATE_ON_QUERY"
                                                 "ACTIVATE_ON_STARTUP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_ActivationType_entries[] = {
    { { Study_ActivationType_names + 0, 17 }, 0 },
    { { Study_ActivationType_names + 17, 19 }, 1 },
};

static const int Study_ActivationType_entries_by_number[] = {
    0, // 0 -> ACTIVATE_ON_QUERY
    1, // 1 -> ACTIVATE_ON_STARTUP
};

const std::string& Study_ActivationType_Name(Study_ActivationType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        Study_ActivationType_entries, Study_ActivationType_entries_by_number, 2, Study_ActivationType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Study_ActivationType_entries, Study_ActivationType_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Study_ActivationType_strings[idx].get();
}
bool Study_ActivationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_ActivationType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Study_ActivationType_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<Study_ActivationType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_ActivationType Study::ACTIVATE_ON_QUERY;
constexpr Study_ActivationType Study::ACTIVATE_ON_STARTUP;
constexpr Study_ActivationType Study::ActivationType_MIN;
constexpr Study_ActivationType Study::ActivationType_MAX;
constexpr int Study::ActivationType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Study_Experiment_Param::_Internal {
public:
    using HasBits = decltype(std::declval<Study_Experiment_Param>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

Study_Experiment_Param::Study_Experiment_Param(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:variations.Study.Experiment.Param)
}
Study_Experiment_Param::Study_Experiment_Param(const Study_Experiment_Param& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Study_Experiment_Param* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {},
        decltype(_impl_.value_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_value()) {
        _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:variations.Study.Experiment.Param)
}

inline void Study_Experiment_Param::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {}, decltype(_impl_.value_) {} };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Study_Experiment_Param::~Study_Experiment_Param()
{
    // @@protoc_insertion_point(destructor:variations.Study.Experiment.Param)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Study_Experiment_Param::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_.Destroy();
    _impl_.value_.Destroy();
}

void Study_Experiment_Param::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Study_Experiment_Param::Clear()
{
    // @@protoc_insertion_point(message_clear_start:variations.Study.Experiment.Param)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.value_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Study_Experiment_Param::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Study_Experiment_Param::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Experiment.Param)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_value(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Experiment.Param)
    return target;
}

size_t Study_Experiment_Param::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:variations.Study.Experiment.Param)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string value = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_value());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Study_Experiment_Param::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Study_Experiment_Param*>(&from));
}

void Study_Experiment_Param::MergeFrom(const Study_Experiment_Param& from)
{
    Study_Experiment_Param* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Experiment.Param)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_value(from._internal_value());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Experiment_Param::CopyFrom(const Study_Experiment_Param& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Experiment.Param)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Study_Experiment_Param::IsInitialized() const
{
    return true;
}

void Study_Experiment_Param::InternalSwap(Study_Experiment_Param* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena, &other->_impl_.value_, rhs_arena);
}

std::string Study_Experiment_Param::GetTypeName() const
{
    return "variations.Study.Experiment.Param";
}

// ===================================================================

class Study_Experiment_FeatureAssociation::_Internal {
public:
    using HasBits = decltype(std::declval<Study_Experiment_FeatureAssociation>()._impl_._has_bits_);
    static void set_has_forcing_feature_on(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_forcing_feature_off(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

Study_Experiment_FeatureAssociation::Study_Experiment_FeatureAssociation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:variations.Study.Experiment.FeatureAssociation)
}
Study_Experiment_FeatureAssociation::Study_Experiment_FeatureAssociation(const Study_Experiment_FeatureAssociation& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Study_Experiment_FeatureAssociation* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.enable_feature_) { from._impl_.enable_feature_ }, decltype(_impl_.disable_feature_) { from._impl_.disable_feature_ },
        decltype(_impl_.forcing_feature_on_) {}, decltype(_impl_.forcing_feature_off_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.forcing_feature_on_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forcing_feature_on_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_forcing_feature_on()) {
        _this->_impl_.forcing_feature_on_.Set(from._internal_forcing_feature_on(), _this->GetArenaForAllocation());
    }
    _impl_.forcing_feature_off_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forcing_feature_off_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_forcing_feature_off()) {
        _this->_impl_.forcing_feature_off_.Set(from._internal_forcing_feature_off(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:variations.Study.Experiment.FeatureAssociation)
}

inline void Study_Experiment_FeatureAssociation::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.enable_feature_) { arena },
        decltype(_impl_.disable_feature_) { arena }, decltype(_impl_.forcing_feature_on_) {}, decltype(_impl_.forcing_feature_off_) {} };
    _impl_.forcing_feature_on_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forcing_feature_on_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forcing_feature_off_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forcing_feature_off_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Study_Experiment_FeatureAssociation::~Study_Experiment_FeatureAssociation()
{
    // @@protoc_insertion_point(destructor:variations.Study.Experiment.FeatureAssociation)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Study_Experiment_FeatureAssociation::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.enable_feature_.~RepeatedPtrField();
    _impl_.disable_feature_.~RepeatedPtrField();
    _impl_.forcing_feature_on_.Destroy();
    _impl_.forcing_feature_off_.Destroy();
}

void Study_Experiment_FeatureAssociation::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Study_Experiment_FeatureAssociation::Clear()
{
    // @@protoc_insertion_point(message_clear_start:variations.Study.Experiment.FeatureAssociation)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.enable_feature_.Clear();
    _impl_.disable_feature_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.forcing_feature_on_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.forcing_feature_off_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Study_Experiment_FeatureAssociation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated string enable_feature = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_enable_feature();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string disable_feature = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_disable_feature();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string forcing_feature_on = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_forcing_feature_on();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string forcing_feature_off = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_forcing_feature_off();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Study_Experiment_FeatureAssociation::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Experiment.FeatureAssociation)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated string enable_feature = 1;
    for (int i = 0, n = this->_internal_enable_feature_size(); i < n; i++) {
        const auto& s = this->_internal_enable_feature(i);
        target = stream->WriteString(1, s, target);
    }

    // repeated string disable_feature = 2;
    for (int i = 0, n = this->_internal_disable_feature_size(); i < n; i++) {
        const auto& s = this->_internal_disable_feature(i);
        target = stream->WriteString(2, s, target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string forcing_feature_on = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_forcing_feature_on(), target);
    }

    // optional string forcing_feature_off = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_forcing_feature_off(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Experiment.FeatureAssociation)
    return target;
}

size_t Study_Experiment_FeatureAssociation::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:variations.Study.Experiment.FeatureAssociation)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string enable_feature = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.enable_feature_.size());
    for (int i = 0, n = _impl_.enable_feature_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.enable_feature_.Get(i));
    }

    // repeated string disable_feature = 2;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.disable_feature_.size());
    for (int i = 0, n = _impl_.disable_feature_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.disable_feature_.Get(i));
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string forcing_feature_on = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_forcing_feature_on());
        }

        // optional string forcing_feature_off = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_forcing_feature_off());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Study_Experiment_FeatureAssociation::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Study_Experiment_FeatureAssociation*>(&from));
}

void Study_Experiment_FeatureAssociation::MergeFrom(const Study_Experiment_FeatureAssociation& from)
{
    Study_Experiment_FeatureAssociation* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Experiment.FeatureAssociation)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.enable_feature_.MergeFrom(from._impl_.enable_feature_);
    _this->_impl_.disable_feature_.MergeFrom(from._impl_.disable_feature_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_forcing_feature_on(from._internal_forcing_feature_on());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_forcing_feature_off(from._internal_forcing_feature_off());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Experiment_FeatureAssociation::CopyFrom(const Study_Experiment_FeatureAssociation& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Experiment.FeatureAssociation)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Study_Experiment_FeatureAssociation::IsInitialized() const
{
    return true;
}

void Study_Experiment_FeatureAssociation::InternalSwap(Study_Experiment_FeatureAssociation* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.enable_feature_.InternalSwap(&other->_impl_.enable_feature_);
    _impl_.disable_feature_.InternalSwap(&other->_impl_.disable_feature_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.forcing_feature_on_, lhs_arena, &other->_impl_.forcing_feature_on_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.forcing_feature_off_, lhs_arena, &other->_impl_.forcing_feature_off_, rhs_arena);
}

std::string Study_Experiment_FeatureAssociation::GetTypeName() const
{
    return "variations.Study.Experiment.FeatureAssociation";
}

// ===================================================================

class Study_Experiment_OverrideUIString::_Internal {
public:
    using HasBits = decltype(std::declval<Study_Experiment_OverrideUIString>()._impl_._has_bits_);
    static void set_has_name_hash(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

Study_Experiment_OverrideUIString::Study_Experiment_OverrideUIString(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:variations.Study.Experiment.OverrideUIString)
}
Study_Experiment_OverrideUIString::Study_Experiment_OverrideUIString(const Study_Experiment_OverrideUIString& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Study_Experiment_OverrideUIString* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.value_) {},
        decltype(_impl_.name_hash_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_value()) {
        _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
    }
    _this->_impl_.name_hash_ = from._impl_.name_hash_;
    // @@protoc_insertion_point(copy_constructor:variations.Study.Experiment.OverrideUIString)
}

inline void Study_Experiment_OverrideUIString::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.value_) {}, decltype(_impl_.name_hash_) { 0u } };
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Study_Experiment_OverrideUIString::~Study_Experiment_OverrideUIString()
{
    // @@protoc_insertion_point(destructor:variations.Study.Experiment.OverrideUIString)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Study_Experiment_OverrideUIString::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.value_.Destroy();
}

void Study_Experiment_OverrideUIString::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Study_Experiment_OverrideUIString::Clear()
{
    // @@protoc_insertion_point(message_clear_start:variations.Study.Experiment.OverrideUIString)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.value_.ClearNonDefaultToEmpty();
    }
    _impl_.name_hash_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Study_Experiment_OverrideUIString::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional fixed32 name_hash = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
                _Internal::set_has_name_hash(&has_bits);
                _impl_.name_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
                ptr += sizeof(uint32_t);
            } else
                goto handle_unusual;
            continue;
        // optional string value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Study_Experiment_OverrideUIString::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Experiment.OverrideUIString)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional fixed32 name_hash = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_name_hash(), target);
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_value(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Experiment.OverrideUIString)
    return target;
}

size_t Study_Experiment_OverrideUIString::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:variations.Study.Experiment.OverrideUIString)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string value = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_value());
        }

        // optional fixed32 name_hash = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 4;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Study_Experiment_OverrideUIString::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Study_Experiment_OverrideUIString*>(&from));
}

void Study_Experiment_OverrideUIString::MergeFrom(const Study_Experiment_OverrideUIString& from)
{
    Study_Experiment_OverrideUIString* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Experiment.OverrideUIString)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_value(from._internal_value());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.name_hash_ = from._impl_.name_hash_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Experiment_OverrideUIString::CopyFrom(const Study_Experiment_OverrideUIString& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Experiment.OverrideUIString)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Study_Experiment_OverrideUIString::IsInitialized() const
{
    return true;
}

void Study_Experiment_OverrideUIString::InternalSwap(Study_Experiment_OverrideUIString* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena, &other->_impl_.value_, rhs_arena);
    swap(_impl_.name_hash_, other->_impl_.name_hash_);
}

std::string Study_Experiment_OverrideUIString::GetTypeName() const
{
    return "variations.Study.Experiment.OverrideUIString";
}

// ===================================================================

class Study_Experiment::_Internal {
public:
    using HasBits = decltype(std::declval<Study_Experiment>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_probability_weight(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_google_web_experiment_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_google_web_trigger_experiment_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_google_web_visibility(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_google_app_experiment_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static const ::variations::Study_Experiment_FeatureAssociation& feature_association(const Study_Experiment* msg);
    static void set_has_feature_association(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_forcing_flag(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000011) ^ 0x00000011) != 0;
    }
};

const ::variations::Study_Experiment_FeatureAssociation& Study_Experiment::_Internal::feature_association(const Study_Experiment* msg)
{
    return *msg->_impl_.feature_association_;
}
Study_Experiment::Study_Experiment(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:variations.Study.Experiment)
}
Study_Experiment::Study_Experiment(const Study_Experiment& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Study_Experiment* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.param_) { from._impl_.param_ }, decltype(_impl_.override_ui_string_) { from._impl_.override_ui_string_ }, decltype(_impl_.name_) {},
        decltype(_impl_.forcing_flag_) {}, decltype(_impl_.feature_association_) { nullptr }, decltype(_impl_.google_web_experiment_id_) {},
        decltype(_impl_.probability_weight_) {}, decltype(_impl_.type_) {}, decltype(_impl_.google_web_trigger_experiment_id_) {},
        decltype(_impl_.google_app_experiment_id_) {}, decltype(_impl_.google_web_visibility_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.forcing_flag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forcing_flag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_forcing_flag()) {
        _this->_impl_.forcing_flag_.Set(from._internal_forcing_flag(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_feature_association()) {
        _this->_impl_.feature_association_ = new ::variations::Study_Experiment_FeatureAssociation(*from._impl_.feature_association_);
    }
    ::memcpy(&_impl_.google_web_experiment_id_, &from._impl_.google_web_experiment_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.google_web_visibility_) - reinterpret_cast<char*>(&_impl_.google_web_experiment_id_))
            + sizeof(_impl_.google_web_visibility_));
    // @@protoc_insertion_point(copy_constructor:variations.Study.Experiment)
}

inline void Study_Experiment::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.param_) { arena },
        decltype(_impl_.override_ui_string_) { arena }, decltype(_impl_.name_) {}, decltype(_impl_.forcing_flag_) {},
        decltype(_impl_.feature_association_) { nullptr }, decltype(_impl_.google_web_experiment_id_) { uint64_t { 0u } },
        decltype(_impl_.probability_weight_) { 0u }, decltype(_impl_.type_) { 0 }, decltype(_impl_.google_web_trigger_experiment_id_) { uint64_t { 0u } },
        decltype(_impl_.google_app_experiment_id_) { uint64_t { 0u } }, decltype(_impl_.google_web_visibility_) { 0 } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forcing_flag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.forcing_flag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Study_Experiment::~Study_Experiment()
{
    // @@protoc_insertion_point(destructor:variations.Study.Experiment)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Study_Experiment::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.param_.~RepeatedPtrField();
    _impl_.override_ui_string_.~RepeatedPtrField();
    _impl_.name_.Destroy();
    _impl_.forcing_flag_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.feature_association_;
}

void Study_Experiment::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Study_Experiment::Clear()
{
    // @@protoc_insertion_point(message_clear_start:variations.Study.Experiment)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.param_.Clear();
    _impl_.override_ui_string_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.forcing_flag_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.feature_association_ != nullptr);
            _impl_.feature_association_->Clear();
        }
    }
    if (cached_has_bits & 0x000000f8u) {
        ::memset(&_impl_.google_web_experiment_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.google_app_experiment_id_) - reinterpret_cast<char*>(&_impl_.google_web_experiment_id_))
                + sizeof(_impl_.google_app_experiment_id_));
    }
    _impl_.google_web_visibility_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Study_Experiment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required uint32 probability_weight = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_probability_weight(&has_bits);
                _impl_.probability_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint64 google_web_experiment_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_google_web_experiment_id(&has_bits);
                _impl_.google_web_experiment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string forcing_flag = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_forcing_flag();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .variations.Study.Experiment.Param param = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_param(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .variations.Study.Experiment.Type type = 7 [default = NORMAL];
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::variations::Study_Experiment_Type_IsValid(val))) {
                    _internal_set_type(static_cast<::variations::Study_Experiment_Type>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional uint64 google_web_trigger_experiment_id = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_google_web_trigger_experiment_id(&has_bits);
                _impl_.google_web_trigger_experiment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .variations.Study.Experiment.OverrideUIString override_ui_string = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_override_ui_string(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .variations.Study.Experiment.FeatureAssociation feature_association = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                ptr = ctx->ParseMessage(_internal_mutable_feature_association(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint64 google_app_experiment_id = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
                _Internal::set_has_google_app_experiment_id(&has_bits);
                _impl_.google_app_experiment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .variations.Study.GoogleWebVisibility google_web_visibility = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::variations::Study_GoogleWebVisibility_IsValid(val))) {
                    _internal_set_google_web_visibility(static_cast<::variations::Study_GoogleWebVisibility>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Study_Experiment::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Experiment)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // required uint32 probability_weight = 2;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_probability_weight(), target);
    }

    // optional uint64 google_web_experiment_id = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_google_web_experiment_id(), target);
    }

    // optional string forcing_flag = 5;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_forcing_flag(), target);
    }

    // repeated .variations.Study.Experiment.Param param = 6;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_param_size()); i < n; i++) {
        const auto& repfield = this->_internal_param(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .variations.Study.Experiment.Type type = 7 [default = NORMAL];
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(7, this->_internal_type(), target);
    }

    // optional uint64 google_web_trigger_experiment_id = 8;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_google_web_trigger_experiment_id(), target);
    }

    // repeated .variations.Study.Experiment.OverrideUIString override_ui_string = 9;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_override_ui_string_size()); i < n; i++) {
        const auto& repfield = this->_internal_override_ui_string(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .variations.Study.Experiment.FeatureAssociation feature_association = 12;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            12, _Internal::feature_association(this), _Internal::feature_association(this).GetCachedSize(), target, stream);
    }

    // optional uint64 google_app_experiment_id = 15;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(15, this->_internal_google_app_experiment_id(), target);
    }

    // optional .variations.Study.GoogleWebVisibility google_web_visibility = 16;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(16, this->_internal_google_web_visibility(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Experiment)
    return target;
}

size_t Study_Experiment::RequiredFieldsByteSizeFallback() const
{
    // @@protoc_insertion_point(required_fields_byte_size_fallback_start:variations.Study.Experiment)
    size_t total_size = 0;

    if (_internal_has_name()) {
        // required string name = 1;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
    }

    if (_internal_has_probability_weight()) {
        // required uint32 probability_weight = 2;
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_probability_weight());
    }

    return total_size;
}
size_t Study_Experiment::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:variations.Study.Experiment)
    size_t total_size = 0;

    if (((_impl_._has_bits_[0] & 0x00000011) ^ 0x00000011) == 0) { // All required fields are present.
        // required string name = 1;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());

        // required uint32 probability_weight = 2;
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_probability_weight());

    } else {
        total_size += RequiredFieldsByteSizeFallback();
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .variations.Study.Experiment.Param param = 6;
    total_size += 1UL * this->_internal_param_size();
    for (const auto& msg : this->_impl_.param_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .variations.Study.Experiment.OverrideUIString override_ui_string = 9;
    total_size += 1UL * this->_internal_override_ui_string_size();
    for (const auto& msg : this->_impl_.override_ui_string_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000eu) {
        // optional string forcing_flag = 5;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_forcing_flag());
        }

        // optional .variations.Study.Experiment.FeatureAssociation feature_association = 12;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.feature_association_);
        }

        // optional uint64 google_web_experiment_id = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_google_web_experiment_id());
        }
    }
    if (cached_has_bits & 0x000000e0u) {
        // optional .variations.Study.Experiment.Type type = 7 [default = NORMAL];
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }

        // optional uint64 google_web_trigger_experiment_id = 8;
        if (cached_has_bits & 0x00000040u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_google_web_trigger_experiment_id());
        }

        // optional uint64 google_app_experiment_id = 15;
        if (cached_has_bits & 0x00000080u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_google_app_experiment_id());
        }
    }
    // optional .variations.Study.GoogleWebVisibility google_web_visibility = 16;
    if (cached_has_bits & 0x00000100u) {
        total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_google_web_visibility());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Study_Experiment::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Study_Experiment*>(&from));
}

void Study_Experiment::MergeFrom(const Study_Experiment& from)
{
    Study_Experiment* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Experiment)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.param_.MergeFrom(from._impl_.param_);
    _this->_impl_.override_ui_string_.MergeFrom(from._impl_.override_ui_string_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_forcing_flag(from._internal_forcing_flag());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_feature_association()->::variations::Study_Experiment_FeatureAssociation::MergeFrom(from._internal_feature_association());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.google_web_experiment_id_ = from._impl_.google_web_experiment_id_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.probability_weight_ = from._impl_.probability_weight_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.google_web_trigger_experiment_id_ = from._impl_.google_web_trigger_experiment_id_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.google_app_experiment_id_ = from._impl_.google_app_experiment_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00000100u) {
        _this->_internal_set_google_web_visibility(from._internal_google_web_visibility());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Experiment::CopyFrom(const Study_Experiment& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Experiment)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Study_Experiment::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    return true;
}

void Study_Experiment::InternalSwap(Study_Experiment* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.param_.InternalSwap(&other->_impl_.param_);
    _impl_.override_ui_string_.InternalSwap(&other->_impl_.override_ui_string_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.forcing_flag_, lhs_arena, &other->_impl_.forcing_flag_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Study_Experiment, _impl_.google_web_visibility_)
        + sizeof(Study_Experiment::_impl_.google_web_visibility_) - PROTOBUF_FIELD_OFFSET(Study_Experiment, _impl_.feature_association_)>(
        reinterpret_cast<char*>(&_impl_.feature_association_), reinterpret_cast<char*>(&other->_impl_.feature_association_));
}

std::string Study_Experiment::GetTypeName() const
{
    return "variations.Study.Experiment";
}

// ===================================================================

class Study_Filter::_Internal {
public:
    using HasBits = decltype(std::declval<Study_Filter>()._impl_._has_bits_);
    static void set_has_start_date(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_end_date(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_min_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_max_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_min_os_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_max_os_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_is_low_end_device(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_is_enterprise(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_policy_restriction(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
};

Study_Filter::Study_Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:variations.Study.Filter)
}
Study_Filter::Study_Filter(const Study_Filter& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Study_Filter* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.channel_) { from._impl_.channel_ }, decltype(_impl_.platform_) { from._impl_.platform_ },
        decltype(_impl_.locale_) { from._impl_.locale_ }, decltype(_impl_.form_factor_) { from._impl_.form_factor_ },
        decltype(_impl_.hardware_class_) { from._impl_.hardware_class_ }, decltype(_impl_.exclude_hardware_class_) { from._impl_.exclude_hardware_class_ },
        decltype(_impl_.country_) { from._impl_.country_ }, decltype(_impl_.exclude_country_) { from._impl_.exclude_country_ },
        decltype(_impl_.exclude_locale_) { from._impl_.exclude_locale_ }, decltype(_impl_.exclude_form_factor_) { from._impl_.exclude_form_factor_ },
        decltype(_impl_.cpu_architecture_) { from._impl_.cpu_architecture_ },
        decltype(_impl_.exclude_cpu_architecture_) { from._impl_.exclude_cpu_architecture_ }, decltype(_impl_.google_group_) { from._impl_.google_group_ },
        /*decltype(_impl_._google_group_cached_byte_size_)*/ { 0 }, decltype(_impl_.exclude_google_group_) { from._impl_.exclude_google_group_ },
        /*decltype(_impl_._exclude_google_group_cached_byte_size_)*/ { 0 }, decltype(_impl_.min_version_) {}, decltype(_impl_.max_version_) {},
        decltype(_impl_.min_os_version_) {}, decltype(_impl_.max_os_version_) {}, decltype(_impl_.start_date_) {}, decltype(_impl_.end_date_) {},
        decltype(_impl_.is_low_end_device_) {}, decltype(_impl_.is_enterprise_) {}, decltype(_impl_.policy_restriction_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.min_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.min_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_min_version()) {
        _this->_impl_.min_version_.Set(from._internal_min_version(), _this->GetArenaForAllocation());
    }
    _impl_.max_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.max_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_max_version()) {
        _this->_impl_.max_version_.Set(from._internal_max_version(), _this->GetArenaForAllocation());
    }
    _impl_.min_os_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.min_os_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_min_os_version()) {
        _this->_impl_.min_os_version_.Set(from._internal_min_os_version(), _this->GetArenaForAllocation());
    }
    _impl_.max_os_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.max_os_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_max_os_version()) {
        _this->_impl_.max_os_version_.Set(from._internal_max_os_version(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.start_date_, &from._impl_.start_date_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.policy_restriction_) - reinterpret_cast<char*>(&_impl_.start_date_))
            + sizeof(_impl_.policy_restriction_));
    // @@protoc_insertion_point(copy_constructor:variations.Study.Filter)
}

inline void Study_Filter::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.channel_) { arena },
        decltype(_impl_.platform_) { arena }, decltype(_impl_.locale_) { arena }, decltype(_impl_.form_factor_) { arena },
        decltype(_impl_.hardware_class_) { arena }, decltype(_impl_.exclude_hardware_class_) { arena }, decltype(_impl_.country_) { arena },
        decltype(_impl_.exclude_country_) { arena }, decltype(_impl_.exclude_locale_) { arena }, decltype(_impl_.exclude_form_factor_) { arena },
        decltype(_impl_.cpu_architecture_) { arena }, decltype(_impl_.exclude_cpu_architecture_) { arena }, decltype(_impl_.google_group_) { arena },
        /*decltype(_impl_._google_group_cached_byte_size_)*/ { 0 }, decltype(_impl_.exclude_google_group_) { arena },
        /*decltype(_impl_._exclude_google_group_cached_byte_size_)*/ { 0 }, decltype(_impl_.min_version_) {}, decltype(_impl_.max_version_) {},
        decltype(_impl_.min_os_version_) {}, decltype(_impl_.max_os_version_) {}, decltype(_impl_.start_date_) { int64_t { 0 } },
        decltype(_impl_.end_date_) { int64_t { 0 } }, decltype(_impl_.is_low_end_device_) { false }, decltype(_impl_.is_enterprise_) { false },
        decltype(_impl_.policy_restriction_) { 0 } };
    _impl_.min_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.min_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.max_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.max_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.min_os_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.min_os_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.max_os_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.max_os_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Study_Filter::~Study_Filter()
{
    // @@protoc_insertion_point(destructor:variations.Study.Filter)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Study_Filter::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.channel_.~RepeatedField();
    _impl_.platform_.~RepeatedField();
    _impl_.locale_.~RepeatedPtrField();
    _impl_.form_factor_.~RepeatedField();
    _impl_.hardware_class_.~RepeatedPtrField();
    _impl_.exclude_hardware_class_.~RepeatedPtrField();
    _impl_.country_.~RepeatedPtrField();
    _impl_.exclude_country_.~RepeatedPtrField();
    _impl_.exclude_locale_.~RepeatedPtrField();
    _impl_.exclude_form_factor_.~RepeatedField();
    _impl_.cpu_architecture_.~RepeatedField();
    _impl_.exclude_cpu_architecture_.~RepeatedField();
    _impl_.google_group_.~RepeatedField();
    _impl_.exclude_google_group_.~RepeatedField();
    _impl_.min_version_.Destroy();
    _impl_.max_version_.Destroy();
    _impl_.min_os_version_.Destroy();
    _impl_.max_os_version_.Destroy();
}

void Study_Filter::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Study_Filter::Clear()
{
    // @@protoc_insertion_point(message_clear_start:variations.Study.Filter)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.channel_.Clear();
    _impl_.platform_.Clear();
    _impl_.locale_.Clear();
    _impl_.form_factor_.Clear();
    _impl_.hardware_class_.Clear();
    _impl_.exclude_hardware_class_.Clear();
    _impl_.country_.Clear();
    _impl_.exclude_country_.Clear();
    _impl_.exclude_locale_.Clear();
    _impl_.exclude_form_factor_.Clear();
    _impl_.cpu_architecture_.Clear();
    _impl_.exclude_cpu_architecture_.Clear();
    _impl_.google_group_.Clear();
    _impl_.exclude_google_group_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.min_version_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.max_version_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.min_os_version_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.max_os_version_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x000000f0u) {
        ::memset(&_impl_.start_date_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_enterprise_) - reinterpret_cast<char*>(&_impl_.start_date_))
                + sizeof(_impl_.is_enterprise_));
    }
    _impl_.policy_restriction_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Study_Filter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 start_date = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_start_date(&has_bits);
                _impl_.start_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string min_version = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_min_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string max_version = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_max_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .variations.Study.Channel channel = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::variations::Study_Channel_IsValid(val))) {
                        _internal_add_channel(static_cast<::variations::Study_Channel>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
            } else if (static_cast<uint8_t>(tag) == 34) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(
                    _internal_mutable_channel(), ptr, ctx, ::variations::Study_Channel_IsValid, &_internal_metadata_, 4);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .variations.Study.Platform platform = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::variations::Study_Platform_IsValid(val))) {
                        _internal_add_platform(static_cast<::variations::Study_Platform>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
            } else if (static_cast<uint8_t>(tag) == 42) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(
                    _internal_mutable_platform(), ptr, ctx, ::variations::Study_Platform_IsValid, &_internal_metadata_, 5);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string locale = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_locale();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .variations.Study.FormFactor form_factor = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::variations::Study_FormFactor_IsValid(val))) {
                        _internal_add_form_factor(static_cast<::variations::Study_FormFactor>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
            } else if (static_cast<uint8_t>(tag) == 58) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(
                    _internal_mutable_form_factor(), ptr, ctx, ::variations::Study_FormFactor_IsValid, &_internal_metadata_, 7);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string hardware_class = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_hardware_class();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string exclude_hardware_class = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_exclude_hardware_class();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string country = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_country();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string exclude_country = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_exclude_country();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string exclude_locale = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_exclude_locale();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional int64 end_date = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                _Internal::set_has_end_date(&has_bits);
                _impl_.end_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .variations.Study.FormFactor exclude_form_factor = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::variations::Study_FormFactor_IsValid(val))) {
                        _internal_add_exclude_form_factor(static_cast<::variations::Study_FormFactor>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<112>(ptr));
            } else if (static_cast<uint8_t>(tag) == 114) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(
                    _internal_mutable_exclude_form_factor(), ptr, ctx, ::variations::Study_FormFactor_IsValid, &_internal_metadata_, 14);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_low_end_device = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
                _Internal::set_has_is_low_end_device(&has_bits);
                _impl_.is_low_end_device_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string min_os_version = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                auto str = _internal_mutable_min_os_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string max_os_version = 17;
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
                auto str = _internal_mutable_max_os_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_enterprise = 18;
        case 18:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
                _Internal::set_has_is_enterprise(&has_bits);
                _impl_.is_enterprise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .variations.Study.PolicyRestriction policy_restriction = 19 [default = NONE];
        case 19:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::variations::Study_PolicyRestriction_IsValid(val))) {
                    _internal_set_policy_restriction(static_cast<::variations::Study_PolicyRestriction>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated .variations.Study.CpuArchitecture cpu_architecture = 20;
        case 20:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::variations::Study_CpuArchitecture_IsValid(val))) {
                        _internal_add_cpu_architecture(static_cast<::variations::Study_CpuArchitecture>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<160>(ptr));
            } else if (static_cast<uint8_t>(tag) == 162) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(
                    _internal_mutable_cpu_architecture(), ptr, ctx, ::variations::Study_CpuArchitecture_IsValid, &_internal_metadata_, 20);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .variations.Study.CpuArchitecture exclude_cpu_architecture = 21;
        case 21:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::variations::Study_CpuArchitecture_IsValid(val))) {
                        _internal_add_exclude_cpu_architecture(static_cast<::variations::Study_CpuArchitecture>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(21, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<168>(ptr));
            } else if (static_cast<uint8_t>(tag) == 170) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(
                    _internal_mutable_exclude_cpu_architecture(), ptr, ctx, ::variations::Study_CpuArchitecture_IsValid, &_internal_metadata_, 21);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated int64 google_group = 22 [packed = true];
        case 22:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_google_group(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 176) {
                _internal_add_google_group(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated int64 exclude_google_group = 23 [packed = true];
        case 23:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_exclude_google_group(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 184) {
                _internal_add_exclude_google_group(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Study_Filter::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Filter)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 start_date = 1;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_start_date(), target);
    }

    // optional string min_version = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_min_version(), target);
    }

    // optional string max_version = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_max_version(), target);
    }

    // repeated .variations.Study.Channel channel = 4;
    for (int i = 0, n = this->_internal_channel_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_channel(i), target);
    }

    // repeated .variations.Study.Platform platform = 5;
    for (int i = 0, n = this->_internal_platform_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_platform(i), target);
    }

    // repeated string locale = 6;
    for (int i = 0, n = this->_internal_locale_size(); i < n; i++) {
        const auto& s = this->_internal_locale(i);
        target = stream->WriteString(6, s, target);
    }

    // repeated .variations.Study.FormFactor form_factor = 7;
    for (int i = 0, n = this->_internal_form_factor_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(7, this->_internal_form_factor(i), target);
    }

    // repeated string hardware_class = 8;
    for (int i = 0, n = this->_internal_hardware_class_size(); i < n; i++) {
        const auto& s = this->_internal_hardware_class(i);
        target = stream->WriteString(8, s, target);
    }

    // repeated string exclude_hardware_class = 9;
    for (int i = 0, n = this->_internal_exclude_hardware_class_size(); i < n; i++) {
        const auto& s = this->_internal_exclude_hardware_class(i);
        target = stream->WriteString(9, s, target);
    }

    // repeated string country = 10;
    for (int i = 0, n = this->_internal_country_size(); i < n; i++) {
        const auto& s = this->_internal_country(i);
        target = stream->WriteString(10, s, target);
    }

    // repeated string exclude_country = 11;
    for (int i = 0, n = this->_internal_exclude_country_size(); i < n; i++) {
        const auto& s = this->_internal_exclude_country(i);
        target = stream->WriteString(11, s, target);
    }

    // repeated string exclude_locale = 12;
    for (int i = 0, n = this->_internal_exclude_locale_size(); i < n; i++) {
        const auto& s = this->_internal_exclude_locale(i);
        target = stream->WriteString(12, s, target);
    }

    // optional int64 end_date = 13;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(13, this->_internal_end_date(), target);
    }

    // repeated .variations.Study.FormFactor exclude_form_factor = 14;
    for (int i = 0, n = this->_internal_exclude_form_factor_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(14, this->_internal_exclude_form_factor(i), target);
    }

    // optional bool is_low_end_device = 15;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_is_low_end_device(), target);
    }

    // optional string min_os_version = 16;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(16, this->_internal_min_os_version(), target);
    }

    // optional string max_os_version = 17;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(17, this->_internal_max_os_version(), target);
    }

    // optional bool is_enterprise = 18;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_is_enterprise(), target);
    }

    // optional .variations.Study.PolicyRestriction policy_restriction = 19 [default = NONE];
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(19, this->_internal_policy_restriction(), target);
    }

    // repeated .variations.Study.CpuArchitecture cpu_architecture = 20;
    for (int i = 0, n = this->_internal_cpu_architecture_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(20, this->_internal_cpu_architecture(i), target);
    }

    // repeated .variations.Study.CpuArchitecture exclude_cpu_architecture = 21;
    for (int i = 0, n = this->_internal_exclude_cpu_architecture_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(21, this->_internal_exclude_cpu_architecture(i), target);
    }

    // repeated int64 google_group = 22 [packed = true];
    {
        int byte_size = _impl_._google_group_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteInt64Packed(22, _internal_google_group(), byte_size, target);
        }
    }

    // repeated int64 exclude_google_group = 23 [packed = true];
    {
        int byte_size = _impl_._exclude_google_group_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteInt64Packed(23, _internal_exclude_google_group(), byte_size, target);
        }
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Filter)
    return target;
}

size_t Study_Filter::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:variations.Study.Filter)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .variations.Study.Channel channel = 4;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_channel_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_channel(static_cast<int>(i)));
        }
        total_size += (1UL * count) + data_size;
    }

    // repeated .variations.Study.Platform platform = 5;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_platform_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_platform(static_cast<int>(i)));
        }
        total_size += (1UL * count) + data_size;
    }

    // repeated string locale = 6;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.locale_.size());
    for (int i = 0, n = _impl_.locale_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.locale_.Get(i));
    }

    // repeated .variations.Study.FormFactor form_factor = 7;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_form_factor_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_form_factor(static_cast<int>(i)));
        }
        total_size += (1UL * count) + data_size;
    }

    // repeated string hardware_class = 8;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.hardware_class_.size());
    for (int i = 0, n = _impl_.hardware_class_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.hardware_class_.Get(i));
    }

    // repeated string exclude_hardware_class = 9;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.exclude_hardware_class_.size());
    for (int i = 0, n = _impl_.exclude_hardware_class_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.exclude_hardware_class_.Get(i));
    }

    // repeated string country = 10;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.country_.size());
    for (int i = 0, n = _impl_.country_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.country_.Get(i));
    }

    // repeated string exclude_country = 11;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.exclude_country_.size());
    for (int i = 0, n = _impl_.exclude_country_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.exclude_country_.Get(i));
    }

    // repeated string exclude_locale = 12;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.exclude_locale_.size());
    for (int i = 0, n = _impl_.exclude_locale_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.exclude_locale_.Get(i));
    }

    // repeated .variations.Study.FormFactor exclude_form_factor = 14;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_exclude_form_factor_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_exclude_form_factor(static_cast<int>(i)));
        }
        total_size += (1UL * count) + data_size;
    }

    // repeated .variations.Study.CpuArchitecture cpu_architecture = 20;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_cpu_architecture_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_cpu_architecture(static_cast<int>(i)));
        }
        total_size += (2UL * count) + data_size;
    }

    // repeated .variations.Study.CpuArchitecture exclude_cpu_architecture = 21;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_exclude_cpu_architecture_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_exclude_cpu_architecture(static_cast<int>(i)));
        }
        total_size += (2UL * count) + data_size;
    }

    // repeated int64 google_group = 22 [packed = true];
    {
        size_t data_size = ::_pbi::WireFormatLite::Int64Size(this->_impl_.google_group_);
        if (data_size > 0) {
            total_size += 2 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._google_group_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    // repeated int64 exclude_google_group = 23 [packed = true];
    {
        size_t data_size = ::_pbi::WireFormatLite::Int64Size(this->_impl_.exclude_google_group_);
        if (data_size > 0) {
            total_size += 2 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._exclude_google_group_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string min_version = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_min_version());
        }

        // optional string max_version = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_max_version());
        }

        // optional string min_os_version = 16;
        if (cached_has_bits & 0x00000004u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_min_os_version());
        }

        // optional string max_os_version = 17;
        if (cached_has_bits & 0x00000008u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_max_os_version());
        }

        // optional int64 start_date = 1;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_start_date());
        }

        // optional int64 end_date = 13;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_end_date());
        }

        // optional bool is_low_end_device = 15;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + 1;
        }

        // optional bool is_enterprise = 18;
        if (cached_has_bits & 0x00000080u) {
            total_size += 2 + 1;
        }
    }
    // optional .variations.Study.PolicyRestriction policy_restriction = 19 [default = NONE];
    if (cached_has_bits & 0x00000100u) {
        total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_policy_restriction());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Study_Filter::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Study_Filter*>(&from));
}

void Study_Filter::MergeFrom(const Study_Filter& from)
{
    Study_Filter* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Filter)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.channel_.MergeFrom(from._impl_.channel_);
    _this->_impl_.platform_.MergeFrom(from._impl_.platform_);
    _this->_impl_.locale_.MergeFrom(from._impl_.locale_);
    _this->_impl_.form_factor_.MergeFrom(from._impl_.form_factor_);
    _this->_impl_.hardware_class_.MergeFrom(from._impl_.hardware_class_);
    _this->_impl_.exclude_hardware_class_.MergeFrom(from._impl_.exclude_hardware_class_);
    _this->_impl_.country_.MergeFrom(from._impl_.country_);
    _this->_impl_.exclude_country_.MergeFrom(from._impl_.exclude_country_);
    _this->_impl_.exclude_locale_.MergeFrom(from._impl_.exclude_locale_);
    _this->_impl_.exclude_form_factor_.MergeFrom(from._impl_.exclude_form_factor_);
    _this->_impl_.cpu_architecture_.MergeFrom(from._impl_.cpu_architecture_);
    _this->_impl_.exclude_cpu_architecture_.MergeFrom(from._impl_.exclude_cpu_architecture_);
    _this->_impl_.google_group_.MergeFrom(from._impl_.google_group_);
    _this->_impl_.exclude_google_group_.MergeFrom(from._impl_.exclude_google_group_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_min_version(from._internal_min_version());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_max_version(from._internal_max_version());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_min_os_version(from._internal_min_os_version());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_max_os_version(from._internal_max_os_version());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.start_date_ = from._impl_.start_date_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.end_date_ = from._impl_.end_date_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.is_low_end_device_ = from._impl_.is_low_end_device_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.is_enterprise_ = from._impl_.is_enterprise_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00000100u) {
        _this->_internal_set_policy_restriction(from._internal_policy_restriction());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Filter::CopyFrom(const Study_Filter& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Filter)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Study_Filter::IsInitialized() const
{
    return true;
}

void Study_Filter::InternalSwap(Study_Filter* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.channel_.InternalSwap(&other->_impl_.channel_);
    _impl_.platform_.InternalSwap(&other->_impl_.platform_);
    _impl_.locale_.InternalSwap(&other->_impl_.locale_);
    _impl_.form_factor_.InternalSwap(&other->_impl_.form_factor_);
    _impl_.hardware_class_.InternalSwap(&other->_impl_.hardware_class_);
    _impl_.exclude_hardware_class_.InternalSwap(&other->_impl_.exclude_hardware_class_);
    _impl_.country_.InternalSwap(&other->_impl_.country_);
    _impl_.exclude_country_.InternalSwap(&other->_impl_.exclude_country_);
    _impl_.exclude_locale_.InternalSwap(&other->_impl_.exclude_locale_);
    _impl_.exclude_form_factor_.InternalSwap(&other->_impl_.exclude_form_factor_);
    _impl_.cpu_architecture_.InternalSwap(&other->_impl_.cpu_architecture_);
    _impl_.exclude_cpu_architecture_.InternalSwap(&other->_impl_.exclude_cpu_architecture_);
    _impl_.google_group_.InternalSwap(&other->_impl_.google_group_);
    _impl_.exclude_google_group_.InternalSwap(&other->_impl_.exclude_google_group_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.min_version_, lhs_arena, &other->_impl_.min_version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.max_version_, lhs_arena, &other->_impl_.max_version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.min_os_version_, lhs_arena, &other->_impl_.min_os_version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.max_os_version_, lhs_arena, &other->_impl_.max_os_version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Study_Filter, _impl_.policy_restriction_)
        + sizeof(Study_Filter::_impl_.policy_restriction_) - PROTOBUF_FIELD_OFFSET(Study_Filter, _impl_.start_date_)>(
        reinterpret_cast<char*>(&_impl_.start_date_), reinterpret_cast<char*>(&other->_impl_.start_date_));
}

std::string Study_Filter::GetTypeName() const
{
    return "variations.Study.Filter";
}

// ===================================================================

class Study::_Internal {
public:
    using HasBits = decltype(std::declval<Study>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_expiry_date(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_consistency(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::variations::LayerMemberReference& layer(const Study* msg);
    static void set_has_layer(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_default_experiment_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::variations::Study_Filter& filter(const Study* msg);
    static void set_has_filter(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_randomization_seed(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_activation_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
    }
};

const ::variations::LayerMemberReference& Study::_Internal::layer(const Study* msg)
{
    return *msg->_impl_.layer_;
}
const ::variations::Study_Filter& Study::_Internal::filter(const Study* msg)
{
    return *msg->_impl_.filter_;
}
void Study::clear_layer()
{
    if (_impl_.layer_ != nullptr)
        _impl_.layer_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
Study::Study(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:variations.Study)
}
Study::Study(const Study& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Study* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.experiment_) { from._impl_.experiment_ }, decltype(_impl_.name_) {}, decltype(_impl_.default_experiment_name_) {},
        decltype(_impl_.filter_) { nullptr }, decltype(_impl_.layer_) { nullptr }, decltype(_impl_.expiry_date_) {}, decltype(_impl_.consistency_) {},
        decltype(_impl_.randomization_seed_) {}, decltype(_impl_.activation_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.default_experiment_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_experiment_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_default_experiment_name()) {
        _this->_impl_.default_experiment_name_.Set(from._internal_default_experiment_name(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_filter()) {
        _this->_impl_.filter_ = new ::variations::Study_Filter(*from._impl_.filter_);
    }
    if (from._internal_has_layer()) {
        _this->_impl_.layer_ = new ::variations::LayerMemberReference(*from._impl_.layer_);
    }
    ::memcpy(&_impl_.expiry_date_, &from._impl_.expiry_date_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.activation_type_) - reinterpret_cast<char*>(&_impl_.expiry_date_))
            + sizeof(_impl_.activation_type_));
    // @@protoc_insertion_point(copy_constructor:variations.Study)
}

inline void Study::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.experiment_) { arena },
        decltype(_impl_.name_) {}, decltype(_impl_.default_experiment_name_) {}, decltype(_impl_.filter_) { nullptr }, decltype(_impl_.layer_) { nullptr },
        decltype(_impl_.expiry_date_) { int64_t { 0 } }, decltype(_impl_.consistency_) { 0 }, decltype(_impl_.randomization_seed_) { 0u },
        decltype(_impl_.activation_type_) { 0 } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_experiment_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_experiment_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Study::~Study()
{
    // @@protoc_insertion_point(destructor:variations.Study)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Study::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.experiment_.~RepeatedPtrField();
    _impl_.name_.Destroy();
    _impl_.default_experiment_name_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.filter_;
    if (this != internal_default_instance())
        delete _impl_.layer_;
}

void Study::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Study::Clear()
{
    // @@protoc_insertion_point(message_clear_start:variations.Study)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.experiment_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.default_experiment_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.filter_ != nullptr);
            _impl_.filter_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.layer_ != nullptr);
            _impl_.layer_->Clear();
        }
    }
    if (cached_has_bits & 0x000000f0u) {
        ::memset(&_impl_.expiry_date_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.activation_type_) - reinterpret_cast<char*>(&_impl_.expiry_date_))
                + sizeof(_impl_.activation_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Study::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 expiry_date = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_expiry_date(&has_bits);
                _impl_.expiry_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .variations.Study.Consistency consistency = 7 [default = SESSION];
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::variations::Study_Consistency_IsValid(val))) {
                    _internal_set_consistency(static_cast<::variations::Study_Consistency>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string default_experiment_name = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_default_experiment_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .variations.Study.Experiment experiment = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_experiment(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .variations.Study.Filter filter = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr = ctx->ParseMessage(_internal_mutable_filter(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 randomization_seed = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
                _Internal::set_has_randomization_seed(&has_bits);
                _impl_.randomization_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .variations.Study.ActivationType activation_type = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::variations::Study_ActivationType_IsValid(val))) {
                    _internal_set_activation_type(static_cast<::variations::Study_ActivationType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .variations.LayerMemberReference layer = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                ptr = ctx->ParseMessage(_internal_mutable_layer(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Study::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:variations.Study)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional int64 expiry_date = 3;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_expiry_date(), target);
    }

    // optional .variations.Study.Consistency consistency = 7 [default = SESSION];
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(7, this->_internal_consistency(), target);
    }

    // optional string default_experiment_name = 8;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_default_experiment_name(), target);
    }

    // repeated .variations.Study.Experiment experiment = 9;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_experiment_size()); i < n; i++) {
        const auto& repfield = this->_internal_experiment(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .variations.Study.Filter filter = 10;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            10, _Internal::filter(this), _Internal::filter(this).GetCachedSize(), target, stream);
    }

    // optional uint32 randomization_seed = 11;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_randomization_seed(), target);
    }

    // optional .variations.Study.ActivationType activation_type = 12;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(12, this->_internal_activation_type(), target);
    }

    // optional .variations.LayerMemberReference layer = 16;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            16, _Internal::layer(this), _Internal::layer(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:variations.Study)
    return target;
}

size_t Study::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:variations.Study)
    size_t total_size = 0;

    // required string name = 1;
    if (_internal_has_name()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .variations.Study.Experiment experiment = 9;
    total_size += 1UL * this->_internal_experiment_size();
    for (const auto& msg : this->_impl_.experiment_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000feu) {
        // optional string default_experiment_name = 8;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_default_experiment_name());
        }

        // optional .variations.Study.Filter filter = 10;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.filter_);
        }

        // optional .variations.LayerMemberReference layer = 16;
        if (cached_has_bits & 0x00000008u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.layer_);
        }

        // optional int64 expiry_date = 3;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_expiry_date());
        }

        // optional .variations.Study.Consistency consistency = 7 [default = SESSION];
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_consistency());
        }

        // optional uint32 randomization_seed = 11;
        if (cached_has_bits & 0x00000040u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_randomization_seed());
        }

        // optional .variations.Study.ActivationType activation_type = 12;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_activation_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Study::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Study*>(&from));
}

void Study::MergeFrom(const Study& from)
{
    Study* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:variations.Study)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.experiment_.MergeFrom(from._impl_.experiment_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_default_experiment_name(from._internal_default_experiment_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_filter()->::variations::Study_Filter::MergeFrom(from._internal_filter());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_layer()->::variations::LayerMemberReference::MergeFrom(from._internal_layer());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.expiry_date_ = from._impl_.expiry_date_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.consistency_ = from._impl_.consistency_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.randomization_seed_ = from._impl_.randomization_seed_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.activation_type_ = from._impl_.activation_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study::CopyFrom(const Study& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:variations.Study)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Study::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.experiment_))
        return false;
    return true;
}

void Study::InternalSwap(Study* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.experiment_.InternalSwap(&other->_impl_.experiment_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.default_experiment_name_, lhs_arena, &other->_impl_.default_experiment_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Study, _impl_.activation_type_) + sizeof(Study::_impl_.activation_type_)
        - PROTOBUF_FIELD_OFFSET(Study, _impl_.filter_)>(reinterpret_cast<char*>(&_impl_.filter_), reinterpret_cast<char*>(&other->_impl_.filter_));
}

std::string Study::GetTypeName() const
{
    return "variations.Study";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace variations
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::variations::Study_Experiment_Param* Arena::CreateMaybeMessage<::variations::Study_Experiment_Param>(Arena* arena)
{
    return Arena::CreateMessageInternal<::variations::Study_Experiment_Param>(arena);
}
template <>
PROTOBUF_NOINLINE ::variations::Study_Experiment_FeatureAssociation* Arena::CreateMaybeMessage<::variations::Study_Experiment_FeatureAssociation>(Arena* arena)
{
    return Arena::CreateMessageInternal<::variations::Study_Experiment_FeatureAssociation>(arena);
}
template <>
PROTOBUF_NOINLINE ::variations::Study_Experiment_OverrideUIString* Arena::CreateMaybeMessage<::variations::Study_Experiment_OverrideUIString>(Arena* arena)
{
    return Arena::CreateMessageInternal<::variations::Study_Experiment_OverrideUIString>(arena);
}
template <> PROTOBUF_NOINLINE ::variations::Study_Experiment* Arena::CreateMaybeMessage<::variations::Study_Experiment>(Arena* arena)
{
    return Arena::CreateMessageInternal<::variations::Study_Experiment>(arena);
}
template <> PROTOBUF_NOINLINE ::variations::Study_Filter* Arena::CreateMaybeMessage<::variations::Study_Filter>(Arena* arena)
{
    return Arena::CreateMessageInternal<::variations::Study_Filter>(arena);
}
template <> PROTOBUF_NOINLINE ::variations::Study* Arena::CreateMaybeMessage<::variations::Study>(Arena* arena)
{
    return Arena::CreateMessageInternal<::variations::Study>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
