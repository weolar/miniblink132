// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/manta/proto/manta.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fmanta_2fproto_2fmanta_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fmanta_2fproto_2fmanta_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/manta/proto/common.pb.h"
#include "components/manta/proto/sparky.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fmanta_2fproto_2fmanta_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fmanta_2fproto_2fmanta_2eproto {
    static const uint32_t offsets[];
};
namespace manta {
namespace proto {
class ChromeClientInfo;
struct ChromeClientInfoDefaultTypeInternal;
extern ChromeClientInfoDefaultTypeInternal _ChromeClientInfo_default_instance_;
class ClientInfo;
struct ClientInfoDefaultTypeInternal;
extern ClientInfoDefaultTypeInternal _ClientInfo_default_instance_;
class FilteredData;
struct FilteredDataDefaultTypeInternal;
extern FilteredDataDefaultTypeInternal _FilteredData_default_instance_;
class ImageDimensions;
struct ImageDimensionsDefaultTypeInternal;
extern ImageDimensionsDefaultTypeInternal _ImageDimensions_default_instance_;
class InputData;
struct InputDataDefaultTypeInternal;
extern InputDataDefaultTypeInternal _InputData_default_instance_;
class OutputData;
struct OutputDataDefaultTypeInternal;
extern OutputDataDefaultTypeInternal _OutputData_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestConfig;
struct RequestConfigDefaultTypeInternal;
extern RequestConfigDefaultTypeInternal _RequestConfig_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
} // namespace proto
} // namespace manta
PROTOBUF_NAMESPACE_OPEN
template <>::manta::proto::ChromeClientInfo* Arena::CreateMaybeMessage<::manta::proto::ChromeClientInfo>(Arena*);
template <>::manta::proto::ClientInfo* Arena::CreateMaybeMessage<::manta::proto::ClientInfo>(Arena*);
template <>::manta::proto::FilteredData* Arena::CreateMaybeMessage<::manta::proto::FilteredData>(Arena*);
template <>::manta::proto::ImageDimensions* Arena::CreateMaybeMessage<::manta::proto::ImageDimensions>(Arena*);
template <>::manta::proto::InputData* Arena::CreateMaybeMessage<::manta::proto::InputData>(Arena*);
template <>::manta::proto::OutputData* Arena::CreateMaybeMessage<::manta::proto::OutputData>(Arena*);
template <>::manta::proto::Request* Arena::CreateMaybeMessage<::manta::proto::Request>(Arena*);
template <>::manta::proto::RequestConfig* Arena::CreateMaybeMessage<::manta::proto::RequestConfig>(Arena*);
template <>::manta::proto::Response* Arena::CreateMaybeMessage<::manta::proto::Response>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace manta {
namespace proto {

enum ClientInfo_ClientType : int { ClientInfo_ClientType_CHROME = 2 };
bool ClientInfo_ClientType_IsValid(int value);
constexpr ClientInfo_ClientType ClientInfo_ClientType_ClientType_MIN = ClientInfo_ClientType_CHROME;
constexpr ClientInfo_ClientType ClientInfo_ClientType_ClientType_MAX = ClientInfo_ClientType_CHROME;
constexpr int ClientInfo_ClientType_ClientType_ARRAYSIZE = ClientInfo_ClientType_ClientType_MAX + 1;

const std::string& ClientInfo_ClientType_Name(ClientInfo_ClientType value);
template <typename T> inline const std::string& ClientInfo_ClientType_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, ClientInfo_ClientType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ClientInfo_ClientType_Name.");
    return ClientInfo_ClientType_Name(static_cast<ClientInfo_ClientType>(enum_t_value));
}
bool ClientInfo_ClientType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientInfo_ClientType* value);
enum ChromeClientInfo_Channel : int {
    ChromeClientInfo_Channel_UNKNOWN = 0,
    ChromeClientInfo_Channel_CANARY = 1,
    ChromeClientInfo_Channel_DEV = 2,
    ChromeClientInfo_Channel_BETA = 3,
    ChromeClientInfo_Channel_STABLE = 4
};
bool ChromeClientInfo_Channel_IsValid(int value);
constexpr ChromeClientInfo_Channel ChromeClientInfo_Channel_Channel_MIN = ChromeClientInfo_Channel_UNKNOWN;
constexpr ChromeClientInfo_Channel ChromeClientInfo_Channel_Channel_MAX = ChromeClientInfo_Channel_STABLE;
constexpr int ChromeClientInfo_Channel_Channel_ARRAYSIZE = ChromeClientInfo_Channel_Channel_MAX + 1;

const std::string& ChromeClientInfo_Channel_Name(ChromeClientInfo_Channel value);
template <typename T> inline const std::string& ChromeClientInfo_Channel_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, ChromeClientInfo_Channel>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ChromeClientInfo_Channel_Name.");
    return ChromeClientInfo_Channel_Name(static_cast<ChromeClientInfo_Channel>(enum_t_value));
}
bool ChromeClientInfo_Channel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChromeClientInfo_Channel* value);
enum RequestConfig_Tone : int {
    RequestConfig_Tone_UNSPECIFIED = 0,
    RequestConfig_Tone_SHORTEN = 1,
    RequestConfig_Tone_ELABORATE = 2,
    RequestConfig_Tone_REPHRASE = 3,
    RequestConfig_Tone_FORMALIZE = 4,
    RequestConfig_Tone_EMOJIFY = 5,
    RequestConfig_Tone_FREEFORM_REWRITE = 6,
    RequestConfig_Tone_FREEFORM_WRITE = 7,
    RequestConfig_Tone_PROOFREAD = 8
};
bool RequestConfig_Tone_IsValid(int value);
constexpr RequestConfig_Tone RequestConfig_Tone_Tone_MIN = RequestConfig_Tone_UNSPECIFIED;
constexpr RequestConfig_Tone RequestConfig_Tone_Tone_MAX = RequestConfig_Tone_PROOFREAD;
constexpr int RequestConfig_Tone_Tone_ARRAYSIZE = RequestConfig_Tone_Tone_MAX + 1;

const std::string& RequestConfig_Tone_Name(RequestConfig_Tone value);
template <typename T> inline const std::string& RequestConfig_Tone_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, RequestConfig_Tone>::value || ::std::is_integral<T>::value, "Incorrect type passed to function RequestConfig_Tone_Name.");
    return RequestConfig_Tone_Name(static_cast<RequestConfig_Tone>(enum_t_value));
}
bool RequestConfig_Tone_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestConfig_Tone* value);
enum FeatureName : int {
    CHROMEOS_VC_BACKGROUNDS = 300,
    CHROMEOS_WALLPAPER = 301,
    TEXT_TEST = 302,
    CHROMEOS_READER_SUMMARY = 303,
    CHROMEOS_READER_TOC = 312,
    CHROMEOS_READER_Q_AND_A = 313,
    CHROMEOS_SPARKY = 314,
    CHROMEOS_LOBSTER = 315,
    CHROMEOS_SCANNER = 316,
    CHROMEOS_READER_ELUCIDATION = 317,
    CHROMEOS_WALRUS = 318,
    ACCESSIBILITY_IMAGE_DESCRIPTION = 700
};
bool FeatureName_IsValid(int value);
constexpr FeatureName FeatureName_MIN = CHROMEOS_VC_BACKGROUNDS;
constexpr FeatureName FeatureName_MAX = ACCESSIBILITY_IMAGE_DESCRIPTION;
constexpr int FeatureName_ARRAYSIZE = FeatureName_MAX + 1;

const std::string& FeatureName_Name(FeatureName value);
template <typename T> inline const std::string& FeatureName_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, FeatureName>::value || ::std::is_integral<T>::value, "Incorrect type passed to function FeatureName_Name.");
    return FeatureName_Name(static_cast<FeatureName>(enum_t_value));
}
bool FeatureName_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FeatureName* value);
enum ImageResolution : int { RESOLUTION_64 = 1, RESOLUTION_256 = 2, RESOLUTION_1024 = 3, RESOLUTION_LARGE = 12 };
bool ImageResolution_IsValid(int value);
constexpr ImageResolution ImageResolution_MIN = RESOLUTION_64;
constexpr ImageResolution ImageResolution_MAX = RESOLUTION_LARGE;
constexpr int ImageResolution_ARRAYSIZE = ImageResolution_MAX + 1;

const std::string& ImageResolution_Name(ImageResolution value);
template <typename T> inline const std::string& ImageResolution_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ImageResolution>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ImageResolution_Name.");
    return ImageResolution_Name(static_cast<ImageResolution>(enum_t_value));
}
bool ImageResolution_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImageResolution* value);
enum AspectRatio : int { ASPECT_RATIO_UNSPECIFIED = 0, ASPECT_RATIO_16_9 = 1, ASPECT_RATIO_16_10 = 2, ASPECT_RATIO_4_3 = 3 };
bool AspectRatio_IsValid(int value);
constexpr AspectRatio AspectRatio_MIN = ASPECT_RATIO_UNSPECIFIED;
constexpr AspectRatio AspectRatio_MAX = ASPECT_RATIO_4_3;
constexpr int AspectRatio_ARRAYSIZE = AspectRatio_MAX + 1;

const std::string& AspectRatio_Name(AspectRatio value);
template <typename T> inline const std::string& AspectRatio_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AspectRatio>::value || ::std::is_integral<T>::value, "Incorrect type passed to function AspectRatio_Name.");
    return AspectRatio_Name(static_cast<AspectRatio>(enum_t_value));
}
bool AspectRatio_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AspectRatio* value);
enum FilteredReason : int { UNSPECIFIED = 0, IMAGE_SAFETY = 1, TEXT_SAFETY = 2, TEXT_LOW_QUALITY = 3, TEXT_BLOCKLIST = 4 };
bool FilteredReason_IsValid(int value);
constexpr FilteredReason FilteredReason_MIN = UNSPECIFIED;
constexpr FilteredReason FilteredReason_MAX = TEXT_BLOCKLIST;
constexpr int FilteredReason_ARRAYSIZE = FilteredReason_MAX + 1;

const std::string& FilteredReason_Name(FilteredReason value);
template <typename T> inline const std::string& FilteredReason_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, FilteredReason>::value || ::std::is_integral<T>::value, "Incorrect type passed to function FilteredReason_Name.");
    return FilteredReason_Name(static_cast<FilteredReason>(enum_t_value));
}
bool FilteredReason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FilteredReason* value);
// ===================================================================

class ClientInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.ClientInfo) */ {
public:
    inline ClientInfo()
        : ClientInfo(nullptr)
    {
    }
    ~ClientInfo() override;
    explicit PROTOBUF_CONSTEXPR ClientInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ClientInfo(const ClientInfo& from);
    ClientInfo(ClientInfo&& from) noexcept
        : ClientInfo()
    {
        *this = ::std::move(from);
    }

    inline ClientInfo& operator=(const ClientInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ClientInfo& operator=(ClientInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ClientInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ClientInfo* internal_default_instance()
    {
        return reinterpret_cast<const ClientInfo*>(&_ClientInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(ClientInfo& a, ClientInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ClientInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ClientInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ClientInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ClientInfo& from);
    void MergeFrom(const ClientInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ClientInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.ClientInfo";
    }

protected:
    explicit ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ClientInfo_ClientType ClientType;
    static constexpr ClientType CHROME = ClientInfo_ClientType_CHROME;
    static inline bool ClientType_IsValid(int value)
    {
        return ClientInfo_ClientType_IsValid(value);
    }
    static constexpr ClientType ClientType_MIN = ClientInfo_ClientType_ClientType_MIN;
    static constexpr ClientType ClientType_MAX = ClientInfo_ClientType_ClientType_MAX;
    static constexpr int ClientType_ARRAYSIZE = ClientInfo_ClientType_ClientType_ARRAYSIZE;
    template <typename T> static inline const std::string& ClientType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ClientType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ClientType_Name.");
        return ClientInfo_ClientType_Name(enum_t_value);
    }
    static inline bool ClientType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientType* value)
    {
        return ClientInfo_ClientType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kChromeClientInfoFieldNumber = 4,
        kClientTypeFieldNumber = 1,
    };
    // optional .manta.proto.ChromeClientInfo chrome_client_info = 4;
    bool has_chrome_client_info() const;

private:
    bool _internal_has_chrome_client_info() const;

public:
    void clear_chrome_client_info();
    const ::manta::proto::ChromeClientInfo& chrome_client_info() const;
    PROTOBUF_NODISCARD ::manta::proto::ChromeClientInfo* release_chrome_client_info();
    ::manta::proto::ChromeClientInfo* mutable_chrome_client_info();
    void set_allocated_chrome_client_info(::manta::proto::ChromeClientInfo* chrome_client_info);

private:
    const ::manta::proto::ChromeClientInfo& _internal_chrome_client_info() const;
    ::manta::proto::ChromeClientInfo* _internal_mutable_chrome_client_info();

public:
    void unsafe_arena_set_allocated_chrome_client_info(::manta::proto::ChromeClientInfo* chrome_client_info);
    ::manta::proto::ChromeClientInfo* unsafe_arena_release_chrome_client_info();

    // optional .manta.proto.ClientInfo.ClientType client_type = 1;
    bool has_client_type() const;

private:
    bool _internal_has_client_type() const;

public:
    void clear_client_type();
    ::manta::proto::ClientInfo_ClientType client_type() const;
    void set_client_type(::manta::proto::ClientInfo_ClientType value);

private:
    ::manta::proto::ClientInfo_ClientType _internal_client_type() const;
    void _internal_set_client_type(::manta::proto::ClientInfo_ClientType value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.ClientInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::manta::proto::ChromeClientInfo* chrome_client_info_;
        int client_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fmanta_2eproto;
};
// -------------------------------------------------------------------

class ChromeClientInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.ChromeClientInfo) */ {
public:
    inline ChromeClientInfo()
        : ChromeClientInfo(nullptr)
    {
    }
    ~ChromeClientInfo() override;
    explicit PROTOBUF_CONSTEXPR ChromeClientInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ChromeClientInfo(const ChromeClientInfo& from);
    ChromeClientInfo(ChromeClientInfo&& from) noexcept
        : ChromeClientInfo()
    {
        *this = ::std::move(from);
    }

    inline ChromeClientInfo& operator=(const ChromeClientInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ChromeClientInfo& operator=(ChromeClientInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ChromeClientInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ChromeClientInfo* internal_default_instance()
    {
        return reinterpret_cast<const ChromeClientInfo*>(&_ChromeClientInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(ChromeClientInfo& a, ChromeClientInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ChromeClientInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ChromeClientInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ChromeClientInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ChromeClientInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ChromeClientInfo& from);
    void MergeFrom(const ChromeClientInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ChromeClientInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.ChromeClientInfo";
    }

protected:
    explicit ChromeClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ChromeClientInfo_Channel Channel;
    static constexpr Channel UNKNOWN = ChromeClientInfo_Channel_UNKNOWN;
    static constexpr Channel CANARY = ChromeClientInfo_Channel_CANARY;
    static constexpr Channel DEV = ChromeClientInfo_Channel_DEV;
    static constexpr Channel BETA = ChromeClientInfo_Channel_BETA;
    static constexpr Channel STABLE = ChromeClientInfo_Channel_STABLE;
    static inline bool Channel_IsValid(int value)
    {
        return ChromeClientInfo_Channel_IsValid(value);
    }
    static constexpr Channel Channel_MIN = ChromeClientInfo_Channel_Channel_MIN;
    static constexpr Channel Channel_MAX = ChromeClientInfo_Channel_Channel_MAX;
    static constexpr int Channel_ARRAYSIZE = ChromeClientInfo_Channel_Channel_ARRAYSIZE;
    template <typename T> static inline const std::string& Channel_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Channel>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Channel_Name.");
        return ChromeClientInfo_Channel_Name(enum_t_value);
    }
    static inline bool Channel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Channel* value)
    {
        return ChromeClientInfo_Channel_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kChromeVersionFieldNumber = 1,
        kLocaleFieldNumber = 4,
        kChromeChannelFieldNumber = 5,
    };
    // optional string chrome_version = 1;
    bool has_chrome_version() const;

private:
    bool _internal_has_chrome_version() const;

public:
    void clear_chrome_version();
    const std::string& chrome_version() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_chrome_version(ArgT0&& arg0, ArgT... args);
    std::string* mutable_chrome_version();
    PROTOBUF_NODISCARD std::string* release_chrome_version();
    void set_allocated_chrome_version(std::string* chrome_version);

private:
    const std::string& _internal_chrome_version() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_chrome_version(const std::string& value);
    std::string* _internal_mutable_chrome_version();

public:
    // optional string locale = 4;
    bool has_locale() const;

private:
    bool _internal_has_locale() const;

public:
    void clear_locale();
    const std::string& locale() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_locale(ArgT0&& arg0, ArgT... args);
    std::string* mutable_locale();
    PROTOBUF_NODISCARD std::string* release_locale();
    void set_allocated_locale(std::string* locale);

private:
    const std::string& _internal_locale() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(const std::string& value);
    std::string* _internal_mutable_locale();

public:
    // optional .manta.proto.ChromeClientInfo.Channel chrome_channel = 5;
    bool has_chrome_channel() const;

private:
    bool _internal_has_chrome_channel() const;

public:
    void clear_chrome_channel();
    ::manta::proto::ChromeClientInfo_Channel chrome_channel() const;
    void set_chrome_channel(::manta::proto::ChromeClientInfo_Channel value);

private:
    ::manta::proto::ChromeClientInfo_Channel _internal_chrome_channel() const;
    void _internal_set_chrome_channel(::manta::proto::ChromeClientInfo_Channel value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.ChromeClientInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chrome_version_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
        int chrome_channel_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fmanta_2eproto;
};
// -------------------------------------------------------------------

class ImageDimensions final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.ImageDimensions) */ {
public:
    inline ImageDimensions()
        : ImageDimensions(nullptr)
    {
    }
    ~ImageDimensions() override;
    explicit PROTOBUF_CONSTEXPR ImageDimensions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ImageDimensions(const ImageDimensions& from);
    ImageDimensions(ImageDimensions&& from) noexcept
        : ImageDimensions()
    {
        *this = ::std::move(from);
    }

    inline ImageDimensions& operator=(const ImageDimensions& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ImageDimensions& operator=(ImageDimensions&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ImageDimensions& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ImageDimensions* internal_default_instance()
    {
        return reinterpret_cast<const ImageDimensions*>(&_ImageDimensions_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(ImageDimensions& a, ImageDimensions& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ImageDimensions* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ImageDimensions* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ImageDimensions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ImageDimensions>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ImageDimensions& from);
    void MergeFrom(const ImageDimensions& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ImageDimensions* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.ImageDimensions";
    }

protected:
    explicit ImageDimensions(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kWidthFieldNumber = 1,
        kHeightFieldNumber = 2,
    };
    // optional uint32 width = 1;
    bool has_width() const;

private:
    bool _internal_has_width() const;

public:
    void clear_width();
    uint32_t width() const;
    void set_width(uint32_t value);

private:
    uint32_t _internal_width() const;
    void _internal_set_width(uint32_t value);

public:
    // optional uint32 height = 2;
    bool has_height() const;

private:
    bool _internal_has_height() const;

public:
    void clear_height();
    uint32_t height() const;
    void set_height(uint32_t value);

private:
    uint32_t _internal_height() const;
    void _internal_set_height(uint32_t value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.ImageDimensions)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t width_;
        uint32_t height_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fmanta_2eproto;
};
// -------------------------------------------------------------------

class RequestConfig final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.RequestConfig) */ {
public:
    inline RequestConfig()
        : RequestConfig(nullptr)
    {
    }
    ~RequestConfig() override;
    explicit PROTOBUF_CONSTEXPR RequestConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    RequestConfig(const RequestConfig& from);
    RequestConfig(RequestConfig&& from) noexcept
        : RequestConfig()
    {
        *this = ::std::move(from);
    }

    inline RequestConfig& operator=(const RequestConfig& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline RequestConfig& operator=(RequestConfig&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const RequestConfig& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const RequestConfig* internal_default_instance()
    {
        return reinterpret_cast<const RequestConfig*>(&_RequestConfig_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(RequestConfig& a, RequestConfig& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(RequestConfig* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(RequestConfig* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    RequestConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<RequestConfig>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const RequestConfig& from);
    void MergeFrom(const RequestConfig& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RequestConfig* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.RequestConfig";
    }

protected:
    explicit RequestConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef RequestConfig_Tone Tone;
    static constexpr Tone UNSPECIFIED = RequestConfig_Tone_UNSPECIFIED;
    static constexpr Tone SHORTEN = RequestConfig_Tone_SHORTEN;
    static constexpr Tone ELABORATE = RequestConfig_Tone_ELABORATE;
    static constexpr Tone REPHRASE = RequestConfig_Tone_REPHRASE;
    static constexpr Tone FORMALIZE = RequestConfig_Tone_FORMALIZE;
    static constexpr Tone EMOJIFY = RequestConfig_Tone_EMOJIFY;
    static constexpr Tone FREEFORM_REWRITE = RequestConfig_Tone_FREEFORM_REWRITE;
    static constexpr Tone FREEFORM_WRITE = RequestConfig_Tone_FREEFORM_WRITE;
    static constexpr Tone PROOFREAD = RequestConfig_Tone_PROOFREAD;
    static inline bool Tone_IsValid(int value)
    {
        return RequestConfig_Tone_IsValid(value);
    }
    static constexpr Tone Tone_MIN = RequestConfig_Tone_Tone_MIN;
    static constexpr Tone Tone_MAX = RequestConfig_Tone_Tone_MAX;
    static constexpr int Tone_ARRAYSIZE = RequestConfig_Tone_Tone_ARRAYSIZE;
    template <typename T> static inline const std::string& Tone_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Tone>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Tone_Name.");
        return RequestConfig_Tone_Name(enum_t_value);
    }
    static inline bool Tone_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Tone* value)
    {
        return RequestConfig_Tone_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kImageDimensionsFieldNumber = 7,
        kSpecificOptionsFieldNumber = 9,
        kGenerationSeedFieldNumber = 1,
        kNumOutputsFieldNumber = 3,
        kToneFieldNumber = 5,
        kAspectRatioFieldNumber = 8,
        kImageResolutionFieldNumber = 2,
    };
    // optional .manta.proto.ImageDimensions image_dimensions = 7;
    bool has_image_dimensions() const;

private:
    bool _internal_has_image_dimensions() const;

public:
    void clear_image_dimensions();
    const ::manta::proto::ImageDimensions& image_dimensions() const;
    PROTOBUF_NODISCARD ::manta::proto::ImageDimensions* release_image_dimensions();
    ::manta::proto::ImageDimensions* mutable_image_dimensions();
    void set_allocated_image_dimensions(::manta::proto::ImageDimensions* image_dimensions);

private:
    const ::manta::proto::ImageDimensions& _internal_image_dimensions() const;
    ::manta::proto::ImageDimensions* _internal_mutable_image_dimensions();

public:
    void unsafe_arena_set_allocated_image_dimensions(::manta::proto::ImageDimensions* image_dimensions);
    ::manta::proto::ImageDimensions* unsafe_arena_release_image_dimensions();

    // optional .manta.proto.Proto3Any specific_options = 9;
    bool has_specific_options() const;

private:
    bool _internal_has_specific_options() const;

public:
    void clear_specific_options();
    const ::manta::proto::Proto3Any& specific_options() const;
    PROTOBUF_NODISCARD ::manta::proto::Proto3Any* release_specific_options();
    ::manta::proto::Proto3Any* mutable_specific_options();
    void set_allocated_specific_options(::manta::proto::Proto3Any* specific_options);

private:
    const ::manta::proto::Proto3Any& _internal_specific_options() const;
    ::manta::proto::Proto3Any* _internal_mutable_specific_options();

public:
    void unsafe_arena_set_allocated_specific_options(::manta::proto::Proto3Any* specific_options);
    ::manta::proto::Proto3Any* unsafe_arena_release_specific_options();

    // optional uint32 generation_seed = 1;
    bool has_generation_seed() const;

private:
    bool _internal_has_generation_seed() const;

public:
    void clear_generation_seed();
    uint32_t generation_seed() const;
    void set_generation_seed(uint32_t value);

private:
    uint32_t _internal_generation_seed() const;
    void _internal_set_generation_seed(uint32_t value);

public:
    // optional uint32 num_outputs = 3;
    bool has_num_outputs() const;

private:
    bool _internal_has_num_outputs() const;

public:
    void clear_num_outputs();
    uint32_t num_outputs() const;
    void set_num_outputs(uint32_t value);

private:
    uint32_t _internal_num_outputs() const;
    void _internal_set_num_outputs(uint32_t value);

public:
    // optional .manta.proto.RequestConfig.Tone tone = 5;
    bool has_tone() const;

private:
    bool _internal_has_tone() const;

public:
    void clear_tone();
    ::manta::proto::RequestConfig_Tone tone() const;
    void set_tone(::manta::proto::RequestConfig_Tone value);

private:
    ::manta::proto::RequestConfig_Tone _internal_tone() const;
    void _internal_set_tone(::manta::proto::RequestConfig_Tone value);

public:
    // optional .manta.proto.AspectRatio aspect_ratio = 8;
    bool has_aspect_ratio() const;

private:
    bool _internal_has_aspect_ratio() const;

public:
    void clear_aspect_ratio();
    ::manta::proto::AspectRatio aspect_ratio() const;
    void set_aspect_ratio(::manta::proto::AspectRatio value);

private:
    ::manta::proto::AspectRatio _internal_aspect_ratio() const;
    void _internal_set_aspect_ratio(::manta::proto::AspectRatio value);

public:
    // optional .manta.proto.ImageResolution image_resolution = 2;
    bool has_image_resolution() const;

private:
    bool _internal_has_image_resolution() const;

public:
    void clear_image_resolution();
    ::manta::proto::ImageResolution image_resolution() const;
    void set_image_resolution(::manta::proto::ImageResolution value);

private:
    ::manta::proto::ImageResolution _internal_image_resolution() const;
    void _internal_set_image_resolution(::manta::proto::ImageResolution value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.RequestConfig)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::manta::proto::ImageDimensions* image_dimensions_;
        ::manta::proto::Proto3Any* specific_options_;
        uint32_t generation_seed_;
        uint32_t num_outputs_;
        int tone_;
        int aspect_ratio_;
        int image_resolution_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fmanta_2eproto;
};
// -------------------------------------------------------------------

class InputData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.InputData) */ {
public:
    inline InputData()
        : InputData(nullptr)
    {
    }
    ~InputData() override;
    explicit PROTOBUF_CONSTEXPR InputData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    InputData(const InputData& from);
    InputData(InputData&& from) noexcept
        : InputData()
    {
        *this = ::std::move(from);
    }

    inline InputData& operator=(const InputData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline InputData& operator=(InputData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const InputData& default_instance()
    {
        return *internal_default_instance();
    }
    enum InputDataCase {
        kText = 1,
        kImage = 2,
        kCustom = 3,
        kSparkyContextData = 5,
        INPUT_DATA_NOT_SET = 0,
    };

    static inline const InputData* internal_default_instance()
    {
        return reinterpret_cast<const InputData*>(&_InputData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(InputData& a, InputData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(InputData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(InputData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    InputData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<InputData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const InputData& from);
    void MergeFrom(const InputData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(InputData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.InputData";
    }

protected:
    explicit InputData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTagFieldNumber = 4,
        kTextFieldNumber = 1,
        kImageFieldNumber = 2,
        kCustomFieldNumber = 3,
        kSparkyContextDataFieldNumber = 5,
    };
    // optional string tag = 4;
    bool has_tag() const;

private:
    bool _internal_has_tag() const;

public:
    void clear_tag();
    const std::string& tag() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_tag(ArgT0&& arg0, ArgT... args);
    std::string* mutable_tag();
    PROTOBUF_NODISCARD std::string* release_tag();
    void set_allocated_tag(std::string* tag);

private:
    const std::string& _internal_tag() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
    std::string* _internal_mutable_tag();

public:
    // string text = 1;
    bool has_text() const;

private:
    bool _internal_has_text() const;

public:
    void clear_text();
    const std::string& text() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_text(ArgT0&& arg0, ArgT... args);
    std::string* mutable_text();
    PROTOBUF_NODISCARD std::string* release_text();
    void set_allocated_text(std::string* text);

private:
    const std::string& _internal_text() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
    std::string* _internal_mutable_text();

public:
    // .manta.proto.Image image = 2;
    bool has_image() const;

private:
    bool _internal_has_image() const;

public:
    void clear_image();
    const ::manta::proto::Image& image() const;
    PROTOBUF_NODISCARD ::manta::proto::Image* release_image();
    ::manta::proto::Image* mutable_image();
    void set_allocated_image(::manta::proto::Image* image);

private:
    const ::manta::proto::Image& _internal_image() const;
    ::manta::proto::Image* _internal_mutable_image();

public:
    void unsafe_arena_set_allocated_image(::manta::proto::Image* image);
    ::manta::proto::Image* unsafe_arena_release_image();

    // .manta.proto.Proto3Any custom = 3;
    bool has_custom() const;

private:
    bool _internal_has_custom() const;

public:
    void clear_custom();
    const ::manta::proto::Proto3Any& custom() const;
    PROTOBUF_NODISCARD ::manta::proto::Proto3Any* release_custom();
    ::manta::proto::Proto3Any* mutable_custom();
    void set_allocated_custom(::manta::proto::Proto3Any* custom);

private:
    const ::manta::proto::Proto3Any& _internal_custom() const;
    ::manta::proto::Proto3Any* _internal_mutable_custom();

public:
    void unsafe_arena_set_allocated_custom(::manta::proto::Proto3Any* custom);
    ::manta::proto::Proto3Any* unsafe_arena_release_custom();

    // .manta.proto.SparkyContextData sparky_context_data = 5;
    bool has_sparky_context_data() const;

private:
    bool _internal_has_sparky_context_data() const;

public:
    void clear_sparky_context_data();
    const ::manta::proto::SparkyContextData& sparky_context_data() const;
    PROTOBUF_NODISCARD ::manta::proto::SparkyContextData* release_sparky_context_data();
    ::manta::proto::SparkyContextData* mutable_sparky_context_data();
    void set_allocated_sparky_context_data(::manta::proto::SparkyContextData* sparky_context_data);

private:
    const ::manta::proto::SparkyContextData& _internal_sparky_context_data() const;
    ::manta::proto::SparkyContextData* _internal_mutable_sparky_context_data();

public:
    void unsafe_arena_set_allocated_sparky_context_data(::manta::proto::SparkyContextData* sparky_context_data);
    ::manta::proto::SparkyContextData* unsafe_arena_release_sparky_context_data();

    void clear_input_data();
    InputDataCase input_data_case() const;
    // @@protoc_insertion_point(class_scope:manta.proto.InputData)
private:
    class _Internal;
    void set_has_text();
    void set_has_image();
    void set_has_custom();
    void set_has_sparky_context_data();

    inline bool has_input_data() const;
    inline void clear_has_input_data();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
        union InputDataUnion {
            constexpr InputDataUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
            ::manta::proto::Image* image_;
            ::manta::proto::Proto3Any* custom_;
            ::manta::proto::SparkyContextData* sparky_context_data_;
        } input_data_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fmanta_2eproto;
};
// -------------------------------------------------------------------

class Request final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.Request) */ {
public:
    inline Request()
        : Request(nullptr)
    {
    }
    ~Request() override;
    explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Request(const Request& from);
    Request(Request&& from) noexcept
        : Request()
    {
        *this = ::std::move(from);
    }

    inline Request& operator=(const Request& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Request& operator=(Request&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Request& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Request* internal_default_instance()
    {
        return reinterpret_cast<const Request*>(&_Request_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(Request& a, Request& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Request* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Request* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Request>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Request& from);
    void MergeFrom(const Request& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Request* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.Request";
    }

protected:
    explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kInputDataFieldNumber = 4,
        kClientInfoFieldNumber = 2,
        kRequestConfigFieldNumber = 3,
        kFeatureNameFieldNumber = 1,
    };
    // repeated .manta.proto.InputData input_data = 4;
    int input_data_size() const;

private:
    int _internal_input_data_size() const;

public:
    void clear_input_data();
    ::manta::proto::InputData* mutable_input_data(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::InputData>* mutable_input_data();

private:
    const ::manta::proto::InputData& _internal_input_data(int index) const;
    ::manta::proto::InputData* _internal_add_input_data();

public:
    const ::manta::proto::InputData& input_data(int index) const;
    ::manta::proto::InputData* add_input_data();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::InputData>& input_data() const;

    // optional .manta.proto.ClientInfo client_info = 2;
    bool has_client_info() const;

private:
    bool _internal_has_client_info() const;

public:
    void clear_client_info();
    const ::manta::proto::ClientInfo& client_info() const;
    PROTOBUF_NODISCARD ::manta::proto::ClientInfo* release_client_info();
    ::manta::proto::ClientInfo* mutable_client_info();
    void set_allocated_client_info(::manta::proto::ClientInfo* client_info);

private:
    const ::manta::proto::ClientInfo& _internal_client_info() const;
    ::manta::proto::ClientInfo* _internal_mutable_client_info();

public:
    void unsafe_arena_set_allocated_client_info(::manta::proto::ClientInfo* client_info);
    ::manta::proto::ClientInfo* unsafe_arena_release_client_info();

    // optional .manta.proto.RequestConfig request_config = 3;
    bool has_request_config() const;

private:
    bool _internal_has_request_config() const;

public:
    void clear_request_config();
    const ::manta::proto::RequestConfig& request_config() const;
    PROTOBUF_NODISCARD ::manta::proto::RequestConfig* release_request_config();
    ::manta::proto::RequestConfig* mutable_request_config();
    void set_allocated_request_config(::manta::proto::RequestConfig* request_config);

private:
    const ::manta::proto::RequestConfig& _internal_request_config() const;
    ::manta::proto::RequestConfig* _internal_mutable_request_config();

public:
    void unsafe_arena_set_allocated_request_config(::manta::proto::RequestConfig* request_config);
    ::manta::proto::RequestConfig* unsafe_arena_release_request_config();

    // optional .manta.proto.FeatureName feature_name = 1;
    bool has_feature_name() const;

private:
    bool _internal_has_feature_name() const;

public:
    void clear_feature_name();
    ::manta::proto::FeatureName feature_name() const;
    void set_feature_name(::manta::proto::FeatureName value);

private:
    ::manta::proto::FeatureName _internal_feature_name() const;
    void _internal_set_feature_name(::manta::proto::FeatureName value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.Request)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::InputData> input_data_;
        ::manta::proto::ClientInfo* client_info_;
        ::manta::proto::RequestConfig* request_config_;
        int feature_name_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fmanta_2eproto;
};
// -------------------------------------------------------------------

class OutputData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.OutputData) */ {
public:
    inline OutputData()
        : OutputData(nullptr)
    {
    }
    ~OutputData() override;
    explicit PROTOBUF_CONSTEXPR OutputData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    OutputData(const OutputData& from);
    OutputData(OutputData&& from) noexcept
        : OutputData()
    {
        *this = ::std::move(from);
    }

    inline OutputData& operator=(const OutputData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline OutputData& operator=(OutputData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const OutputData& default_instance()
    {
        return *internal_default_instance();
    }
    enum OutputDataCase {
        kText = 1,
        kImage = 2,
        kCustom = 3,
        kSparkyResponse = 7,
        OUTPUT_DATA_NOT_SET = 0,
    };

    static inline const OutputData* internal_default_instance()
    {
        return reinterpret_cast<const OutputData*>(&_OutputData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(OutputData& a, OutputData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(OutputData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(OutputData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    OutputData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<OutputData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const OutputData& from);
    void MergeFrom(const OutputData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(OutputData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.OutputData";
    }

protected:
    explicit OutputData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kScoreFieldNumber = 5,
        kGenerationSeedFieldNumber = 6,
        kTextFieldNumber = 1,
        kImageFieldNumber = 2,
        kCustomFieldNumber = 3,
        kSparkyResponseFieldNumber = 7,
    };
    // optional float score = 5;
    bool has_score() const;

private:
    bool _internal_has_score() const;

public:
    void clear_score();
    float score() const;
    void set_score(float value);

private:
    float _internal_score() const;
    void _internal_set_score(float value);

public:
    // optional uint32 generation_seed = 6;
    bool has_generation_seed() const;

private:
    bool _internal_has_generation_seed() const;

public:
    void clear_generation_seed();
    uint32_t generation_seed() const;
    void set_generation_seed(uint32_t value);

private:
    uint32_t _internal_generation_seed() const;
    void _internal_set_generation_seed(uint32_t value);

public:
    // string text = 1;
    bool has_text() const;

private:
    bool _internal_has_text() const;

public:
    void clear_text();
    const std::string& text() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_text(ArgT0&& arg0, ArgT... args);
    std::string* mutable_text();
    PROTOBUF_NODISCARD std::string* release_text();
    void set_allocated_text(std::string* text);

private:
    const std::string& _internal_text() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
    std::string* _internal_mutable_text();

public:
    // .manta.proto.Image image = 2;
    bool has_image() const;

private:
    bool _internal_has_image() const;

public:
    void clear_image();
    const ::manta::proto::Image& image() const;
    PROTOBUF_NODISCARD ::manta::proto::Image* release_image();
    ::manta::proto::Image* mutable_image();
    void set_allocated_image(::manta::proto::Image* image);

private:
    const ::manta::proto::Image& _internal_image() const;
    ::manta::proto::Image* _internal_mutable_image();

public:
    void unsafe_arena_set_allocated_image(::manta::proto::Image* image);
    ::manta::proto::Image* unsafe_arena_release_image();

    // .manta.proto.Proto3Any custom = 3;
    bool has_custom() const;

private:
    bool _internal_has_custom() const;

public:
    void clear_custom();
    const ::manta::proto::Proto3Any& custom() const;
    PROTOBUF_NODISCARD ::manta::proto::Proto3Any* release_custom();
    ::manta::proto::Proto3Any* mutable_custom();
    void set_allocated_custom(::manta::proto::Proto3Any* custom);

private:
    const ::manta::proto::Proto3Any& _internal_custom() const;
    ::manta::proto::Proto3Any* _internal_mutable_custom();

public:
    void unsafe_arena_set_allocated_custom(::manta::proto::Proto3Any* custom);
    ::manta::proto::Proto3Any* unsafe_arena_release_custom();

    // .manta.proto.SparkyResponse sparky_response = 7;
    bool has_sparky_response() const;

private:
    bool _internal_has_sparky_response() const;

public:
    void clear_sparky_response();
    const ::manta::proto::SparkyResponse& sparky_response() const;
    PROTOBUF_NODISCARD ::manta::proto::SparkyResponse* release_sparky_response();
    ::manta::proto::SparkyResponse* mutable_sparky_response();
    void set_allocated_sparky_response(::manta::proto::SparkyResponse* sparky_response);

private:
    const ::manta::proto::SparkyResponse& _internal_sparky_response() const;
    ::manta::proto::SparkyResponse* _internal_mutable_sparky_response();

public:
    void unsafe_arena_set_allocated_sparky_response(::manta::proto::SparkyResponse* sparky_response);
    ::manta::proto::SparkyResponse* unsafe_arena_release_sparky_response();

    void clear_output_data();
    OutputDataCase output_data_case() const;
    // @@protoc_insertion_point(class_scope:manta.proto.OutputData)
private:
    class _Internal;
    void set_has_text();
    void set_has_image();
    void set_has_custom();
    void set_has_sparky_response();

    inline bool has_output_data() const;
    inline void clear_has_output_data();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        float score_;
        uint32_t generation_seed_;
        union OutputDataUnion {
            constexpr OutputDataUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
            ::manta::proto::Image* image_;
            ::manta::proto::Proto3Any* custom_;
            ::manta::proto::SparkyResponse* sparky_response_;
        } output_data_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fmanta_2eproto;
};
// -------------------------------------------------------------------

class FilteredData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.FilteredData) */ {
public:
    inline FilteredData()
        : FilteredData(nullptr)
    {
    }
    ~FilteredData() override;
    explicit PROTOBUF_CONSTEXPR FilteredData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FilteredData(const FilteredData& from);
    FilteredData(FilteredData&& from) noexcept
        : FilteredData()
    {
        *this = ::std::move(from);
    }

    inline FilteredData& operator=(const FilteredData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FilteredData& operator=(FilteredData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const FilteredData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FilteredData* internal_default_instance()
    {
        return reinterpret_cast<const FilteredData*>(&_FilteredData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(FilteredData& a, FilteredData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FilteredData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FilteredData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FilteredData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FilteredData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FilteredData& from);
    void MergeFrom(const FilteredData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FilteredData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.FilteredData";
    }

protected:
    explicit FilteredData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kIsOutputDataFieldNumber = 2,
        kReasonFieldNumber = 3,
    };
    // optional bool is_output_data = 2;
    bool has_is_output_data() const;

private:
    bool _internal_has_is_output_data() const;

public:
    void clear_is_output_data();
    bool is_output_data() const;
    void set_is_output_data(bool value);

private:
    bool _internal_is_output_data() const;
    void _internal_set_is_output_data(bool value);

public:
    // optional .manta.proto.FilteredReason reason = 3;
    bool has_reason() const;

private:
    bool _internal_has_reason() const;

public:
    void clear_reason();
    ::manta::proto::FilteredReason reason() const;
    void set_reason(::manta::proto::FilteredReason value);

private:
    ::manta::proto::FilteredReason _internal_reason() const;
    void _internal_set_reason(::manta::proto::FilteredReason value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.FilteredData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        bool is_output_data_;
        int reason_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fmanta_2eproto;
};
// -------------------------------------------------------------------

class Response final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.Response) */ {
public:
    inline Response()
        : Response(nullptr)
    {
    }
    ~Response() override;
    explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Response(const Response& from);
    Response(Response&& from) noexcept
        : Response()
    {
        *this = ::std::move(from);
    }

    inline Response& operator=(const Response& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Response& operator=(Response&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Response& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Response* internal_default_instance()
    {
        return reinterpret_cast<const Response*>(&_Response_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(Response& a, Response& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Response* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Response* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Response>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Response& from);
    void MergeFrom(const Response& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Response* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.Response";
    }

protected:
    explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kOutputDataFieldNumber = 1,
        kFilteredDataFieldNumber = 2,
    };
    // repeated .manta.proto.OutputData output_data = 1;
    int output_data_size() const;

private:
    int _internal_output_data_size() const;

public:
    void clear_output_data();
    ::manta::proto::OutputData* mutable_output_data(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::OutputData>* mutable_output_data();

private:
    const ::manta::proto::OutputData& _internal_output_data(int index) const;
    ::manta::proto::OutputData* _internal_add_output_data();

public:
    const ::manta::proto::OutputData& output_data(int index) const;
    ::manta::proto::OutputData* add_output_data();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::OutputData>& output_data() const;

    // repeated .manta.proto.FilteredData filtered_data = 2;
    int filtered_data_size() const;

private:
    int _internal_filtered_data_size() const;

public:
    void clear_filtered_data();
    ::manta::proto::FilteredData* mutable_filtered_data(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::FilteredData>* mutable_filtered_data();

private:
    const ::manta::proto::FilteredData& _internal_filtered_data(int index) const;
    ::manta::proto::FilteredData* _internal_add_filtered_data();

public:
    const ::manta::proto::FilteredData& filtered_data(int index) const;
    ::manta::proto::FilteredData* add_filtered_data();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::FilteredData>& filtered_data() const;

    // @@protoc_insertion_point(class_scope:manta.proto.Response)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::OutputData> output_data_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::FilteredData> filtered_data_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fmanta_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// ClientInfo

// optional .manta.proto.ClientInfo.ClientType client_type = 1;
inline bool ClientInfo::_internal_has_client_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ClientInfo::has_client_type() const
{
    return _internal_has_client_type();
}
inline void ClientInfo::clear_client_type()
{
    _impl_.client_type_ = 2;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::manta::proto::ClientInfo_ClientType ClientInfo::_internal_client_type() const
{
    return static_cast<::manta::proto::ClientInfo_ClientType>(_impl_.client_type_);
}
inline ::manta::proto::ClientInfo_ClientType ClientInfo::client_type() const
{
    // @@protoc_insertion_point(field_get:manta.proto.ClientInfo.client_type)
    return _internal_client_type();
}
inline void ClientInfo::_internal_set_client_type(::manta::proto::ClientInfo_ClientType value)
{
    assert(::manta::proto::ClientInfo_ClientType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.client_type_ = value;
}
inline void ClientInfo::set_client_type(::manta::proto::ClientInfo_ClientType value)
{
    _internal_set_client_type(value);
    // @@protoc_insertion_point(field_set:manta.proto.ClientInfo.client_type)
}

// optional .manta.proto.ChromeClientInfo chrome_client_info = 4;
inline bool ClientInfo::_internal_has_chrome_client_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.chrome_client_info_ != nullptr);
    return value;
}
inline bool ClientInfo::has_chrome_client_info() const
{
    return _internal_has_chrome_client_info();
}
inline void ClientInfo::clear_chrome_client_info()
{
    if (_impl_.chrome_client_info_ != nullptr)
        _impl_.chrome_client_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::manta::proto::ChromeClientInfo& ClientInfo::_internal_chrome_client_info() const
{
    const ::manta::proto::ChromeClientInfo* p = _impl_.chrome_client_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::ChromeClientInfo&>(::manta::proto::_ChromeClientInfo_default_instance_);
}
inline const ::manta::proto::ChromeClientInfo& ClientInfo::chrome_client_info() const
{
    // @@protoc_insertion_point(field_get:manta.proto.ClientInfo.chrome_client_info)
    return _internal_chrome_client_info();
}
inline void ClientInfo::unsafe_arena_set_allocated_chrome_client_info(::manta::proto::ChromeClientInfo* chrome_client_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chrome_client_info_);
    }
    _impl_.chrome_client_info_ = chrome_client_info;
    if (chrome_client_info) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.ClientInfo.chrome_client_info)
}
inline ::manta::proto::ChromeClientInfo* ClientInfo::release_chrome_client_info()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::ChromeClientInfo* temp = _impl_.chrome_client_info_;
    _impl_.chrome_client_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::ChromeClientInfo* ClientInfo::unsafe_arena_release_chrome_client_info()
{
    // @@protoc_insertion_point(field_release:manta.proto.ClientInfo.chrome_client_info)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::ChromeClientInfo* temp = _impl_.chrome_client_info_;
    _impl_.chrome_client_info_ = nullptr;
    return temp;
}
inline ::manta::proto::ChromeClientInfo* ClientInfo::_internal_mutable_chrome_client_info()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.chrome_client_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::ChromeClientInfo>(GetArenaForAllocation());
        _impl_.chrome_client_info_ = p;
    }
    return _impl_.chrome_client_info_;
}
inline ::manta::proto::ChromeClientInfo* ClientInfo::mutable_chrome_client_info()
{
    ::manta::proto::ChromeClientInfo* _msg = _internal_mutable_chrome_client_info();
    // @@protoc_insertion_point(field_mutable:manta.proto.ClientInfo.chrome_client_info)
    return _msg;
}
inline void ClientInfo::set_allocated_chrome_client_info(::manta::proto::ChromeClientInfo* chrome_client_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.chrome_client_info_;
    }
    if (chrome_client_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chrome_client_info);
        if (message_arena != submessage_arena) {
            chrome_client_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, chrome_client_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.chrome_client_info_ = chrome_client_info;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.ClientInfo.chrome_client_info)
}

// -------------------------------------------------------------------

// ChromeClientInfo

// optional string chrome_version = 1;
inline bool ChromeClientInfo::_internal_has_chrome_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ChromeClientInfo::has_chrome_version() const
{
    return _internal_has_chrome_version();
}
inline void ChromeClientInfo::clear_chrome_version()
{
    _impl_.chrome_version_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChromeClientInfo::chrome_version() const
{
    // @@protoc_insertion_point(field_get:manta.proto.ChromeClientInfo.chrome_version)
    return _internal_chrome_version();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ChromeClientInfo::set_chrome_version(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.chrome_version_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.ChromeClientInfo.chrome_version)
}
inline std::string* ChromeClientInfo::mutable_chrome_version()
{
    std::string* _s = _internal_mutable_chrome_version();
    // @@protoc_insertion_point(field_mutable:manta.proto.ChromeClientInfo.chrome_version)
    return _s;
}
inline const std::string& ChromeClientInfo::_internal_chrome_version() const
{
    return _impl_.chrome_version_.Get();
}
inline void ChromeClientInfo::_internal_set_chrome_version(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.chrome_version_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeClientInfo::_internal_mutable_chrome_version()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.chrome_version_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeClientInfo::release_chrome_version()
{
    // @@protoc_insertion_point(field_release:manta.proto.ChromeClientInfo.chrome_version)
    if (!_internal_has_chrome_version()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.chrome_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.chrome_version_.IsDefault()) {
        _impl_.chrome_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ChromeClientInfo::set_allocated_chrome_version(std::string* chrome_version)
{
    if (chrome_version != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.chrome_version_.SetAllocated(chrome_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.chrome_version_.IsDefault()) {
        _impl_.chrome_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.ChromeClientInfo.chrome_version)
}

// optional string locale = 4;
inline bool ChromeClientInfo::_internal_has_locale() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ChromeClientInfo::has_locale() const
{
    return _internal_has_locale();
}
inline void ChromeClientInfo::clear_locale()
{
    _impl_.locale_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChromeClientInfo::locale() const
{
    // @@protoc_insertion_point(field_get:manta.proto.ChromeClientInfo.locale)
    return _internal_locale();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ChromeClientInfo::set_locale(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.locale_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.ChromeClientInfo.locale)
}
inline std::string* ChromeClientInfo::mutable_locale()
{
    std::string* _s = _internal_mutable_locale();
    // @@protoc_insertion_point(field_mutable:manta.proto.ChromeClientInfo.locale)
    return _s;
}
inline const std::string& ChromeClientInfo::_internal_locale() const
{
    return _impl_.locale_.Get();
}
inline void ChromeClientInfo::_internal_set_locale(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.locale_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeClientInfo::_internal_mutable_locale()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.locale_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeClientInfo::release_locale()
{
    // @@protoc_insertion_point(field_release:manta.proto.ChromeClientInfo.locale)
    if (!_internal_has_locale()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.locale_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.locale_.IsDefault()) {
        _impl_.locale_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ChromeClientInfo::set_allocated_locale(std::string* locale)
{
    if (locale != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.locale_.SetAllocated(locale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.locale_.IsDefault()) {
        _impl_.locale_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.ChromeClientInfo.locale)
}

// optional .manta.proto.ChromeClientInfo.Channel chrome_channel = 5;
inline bool ChromeClientInfo::_internal_has_chrome_channel() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ChromeClientInfo::has_chrome_channel() const
{
    return _internal_has_chrome_channel();
}
inline void ChromeClientInfo::clear_chrome_channel()
{
    _impl_.chrome_channel_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::manta::proto::ChromeClientInfo_Channel ChromeClientInfo::_internal_chrome_channel() const
{
    return static_cast<::manta::proto::ChromeClientInfo_Channel>(_impl_.chrome_channel_);
}
inline ::manta::proto::ChromeClientInfo_Channel ChromeClientInfo::chrome_channel() const
{
    // @@protoc_insertion_point(field_get:manta.proto.ChromeClientInfo.chrome_channel)
    return _internal_chrome_channel();
}
inline void ChromeClientInfo::_internal_set_chrome_channel(::manta::proto::ChromeClientInfo_Channel value)
{
    assert(::manta::proto::ChromeClientInfo_Channel_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.chrome_channel_ = value;
}
inline void ChromeClientInfo::set_chrome_channel(::manta::proto::ChromeClientInfo_Channel value)
{
    _internal_set_chrome_channel(value);
    // @@protoc_insertion_point(field_set:manta.proto.ChromeClientInfo.chrome_channel)
}

// -------------------------------------------------------------------

// ImageDimensions

// optional uint32 width = 1;
inline bool ImageDimensions::_internal_has_width() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ImageDimensions::has_width() const
{
    return _internal_has_width();
}
inline void ImageDimensions::clear_width()
{
    _impl_.width_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t ImageDimensions::_internal_width() const
{
    return _impl_.width_;
}
inline uint32_t ImageDimensions::width() const
{
    // @@protoc_insertion_point(field_get:manta.proto.ImageDimensions.width)
    return _internal_width();
}
inline void ImageDimensions::_internal_set_width(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.width_ = value;
}
inline void ImageDimensions::set_width(uint32_t value)
{
    _internal_set_width(value);
    // @@protoc_insertion_point(field_set:manta.proto.ImageDimensions.width)
}

// optional uint32 height = 2;
inline bool ImageDimensions::_internal_has_height() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ImageDimensions::has_height() const
{
    return _internal_has_height();
}
inline void ImageDimensions::clear_height()
{
    _impl_.height_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ImageDimensions::_internal_height() const
{
    return _impl_.height_;
}
inline uint32_t ImageDimensions::height() const
{
    // @@protoc_insertion_point(field_get:manta.proto.ImageDimensions.height)
    return _internal_height();
}
inline void ImageDimensions::_internal_set_height(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.height_ = value;
}
inline void ImageDimensions::set_height(uint32_t value)
{
    _internal_set_height(value);
    // @@protoc_insertion_point(field_set:manta.proto.ImageDimensions.height)
}

// -------------------------------------------------------------------

// RequestConfig

// optional uint32 generation_seed = 1;
inline bool RequestConfig::_internal_has_generation_seed() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool RequestConfig::has_generation_seed() const
{
    return _internal_has_generation_seed();
}
inline void RequestConfig::clear_generation_seed()
{
    _impl_.generation_seed_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RequestConfig::_internal_generation_seed() const
{
    return _impl_.generation_seed_;
}
inline uint32_t RequestConfig::generation_seed() const
{
    // @@protoc_insertion_point(field_get:manta.proto.RequestConfig.generation_seed)
    return _internal_generation_seed();
}
inline void RequestConfig::_internal_set_generation_seed(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.generation_seed_ = value;
}
inline void RequestConfig::set_generation_seed(uint32_t value)
{
    _internal_set_generation_seed(value);
    // @@protoc_insertion_point(field_set:manta.proto.RequestConfig.generation_seed)
}

// optional .manta.proto.ImageResolution image_resolution = 2;
inline bool RequestConfig::_internal_has_image_resolution() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool RequestConfig::has_image_resolution() const
{
    return _internal_has_image_resolution();
}
inline void RequestConfig::clear_image_resolution()
{
    _impl_.image_resolution_ = 1;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::manta::proto::ImageResolution RequestConfig::_internal_image_resolution() const
{
    return static_cast<::manta::proto::ImageResolution>(_impl_.image_resolution_);
}
inline ::manta::proto::ImageResolution RequestConfig::image_resolution() const
{
    // @@protoc_insertion_point(field_get:manta.proto.RequestConfig.image_resolution)
    return _internal_image_resolution();
}
inline void RequestConfig::_internal_set_image_resolution(::manta::proto::ImageResolution value)
{
    assert(::manta::proto::ImageResolution_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.image_resolution_ = value;
}
inline void RequestConfig::set_image_resolution(::manta::proto::ImageResolution value)
{
    _internal_set_image_resolution(value);
    // @@protoc_insertion_point(field_set:manta.proto.RequestConfig.image_resolution)
}

// optional uint32 num_outputs = 3;
inline bool RequestConfig::_internal_has_num_outputs() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool RequestConfig::has_num_outputs() const
{
    return _internal_has_num_outputs();
}
inline void RequestConfig::clear_num_outputs()
{
    _impl_.num_outputs_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t RequestConfig::_internal_num_outputs() const
{
    return _impl_.num_outputs_;
}
inline uint32_t RequestConfig::num_outputs() const
{
    // @@protoc_insertion_point(field_get:manta.proto.RequestConfig.num_outputs)
    return _internal_num_outputs();
}
inline void RequestConfig::_internal_set_num_outputs(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.num_outputs_ = value;
}
inline void RequestConfig::set_num_outputs(uint32_t value)
{
    _internal_set_num_outputs(value);
    // @@protoc_insertion_point(field_set:manta.proto.RequestConfig.num_outputs)
}

// optional .manta.proto.RequestConfig.Tone tone = 5;
inline bool RequestConfig::_internal_has_tone() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool RequestConfig::has_tone() const
{
    return _internal_has_tone();
}
inline void RequestConfig::clear_tone()
{
    _impl_.tone_ = 0;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::manta::proto::RequestConfig_Tone RequestConfig::_internal_tone() const
{
    return static_cast<::manta::proto::RequestConfig_Tone>(_impl_.tone_);
}
inline ::manta::proto::RequestConfig_Tone RequestConfig::tone() const
{
    // @@protoc_insertion_point(field_get:manta.proto.RequestConfig.tone)
    return _internal_tone();
}
inline void RequestConfig::_internal_set_tone(::manta::proto::RequestConfig_Tone value)
{
    assert(::manta::proto::RequestConfig_Tone_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.tone_ = value;
}
inline void RequestConfig::set_tone(::manta::proto::RequestConfig_Tone value)
{
    _internal_set_tone(value);
    // @@protoc_insertion_point(field_set:manta.proto.RequestConfig.tone)
}

// optional .manta.proto.ImageDimensions image_dimensions = 7;
inline bool RequestConfig::_internal_has_image_dimensions() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.image_dimensions_ != nullptr);
    return value;
}
inline bool RequestConfig::has_image_dimensions() const
{
    return _internal_has_image_dimensions();
}
inline void RequestConfig::clear_image_dimensions()
{
    if (_impl_.image_dimensions_ != nullptr)
        _impl_.image_dimensions_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::manta::proto::ImageDimensions& RequestConfig::_internal_image_dimensions() const
{
    const ::manta::proto::ImageDimensions* p = _impl_.image_dimensions_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::ImageDimensions&>(::manta::proto::_ImageDimensions_default_instance_);
}
inline const ::manta::proto::ImageDimensions& RequestConfig::image_dimensions() const
{
    // @@protoc_insertion_point(field_get:manta.proto.RequestConfig.image_dimensions)
    return _internal_image_dimensions();
}
inline void RequestConfig::unsafe_arena_set_allocated_image_dimensions(::manta::proto::ImageDimensions* image_dimensions)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.image_dimensions_);
    }
    _impl_.image_dimensions_ = image_dimensions;
    if (image_dimensions) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.RequestConfig.image_dimensions)
}
inline ::manta::proto::ImageDimensions* RequestConfig::release_image_dimensions()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::ImageDimensions* temp = _impl_.image_dimensions_;
    _impl_.image_dimensions_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::ImageDimensions* RequestConfig::unsafe_arena_release_image_dimensions()
{
    // @@protoc_insertion_point(field_release:manta.proto.RequestConfig.image_dimensions)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::ImageDimensions* temp = _impl_.image_dimensions_;
    _impl_.image_dimensions_ = nullptr;
    return temp;
}
inline ::manta::proto::ImageDimensions* RequestConfig::_internal_mutable_image_dimensions()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.image_dimensions_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::ImageDimensions>(GetArenaForAllocation());
        _impl_.image_dimensions_ = p;
    }
    return _impl_.image_dimensions_;
}
inline ::manta::proto::ImageDimensions* RequestConfig::mutable_image_dimensions()
{
    ::manta::proto::ImageDimensions* _msg = _internal_mutable_image_dimensions();
    // @@protoc_insertion_point(field_mutable:manta.proto.RequestConfig.image_dimensions)
    return _msg;
}
inline void RequestConfig::set_allocated_image_dimensions(::manta::proto::ImageDimensions* image_dimensions)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.image_dimensions_;
    }
    if (image_dimensions) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image_dimensions);
        if (message_arena != submessage_arena) {
            image_dimensions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, image_dimensions, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.image_dimensions_ = image_dimensions;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.RequestConfig.image_dimensions)
}

// optional .manta.proto.AspectRatio aspect_ratio = 8;
inline bool RequestConfig::_internal_has_aspect_ratio() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool RequestConfig::has_aspect_ratio() const
{
    return _internal_has_aspect_ratio();
}
inline void RequestConfig::clear_aspect_ratio()
{
    _impl_.aspect_ratio_ = 0;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::manta::proto::AspectRatio RequestConfig::_internal_aspect_ratio() const
{
    return static_cast<::manta::proto::AspectRatio>(_impl_.aspect_ratio_);
}
inline ::manta::proto::AspectRatio RequestConfig::aspect_ratio() const
{
    // @@protoc_insertion_point(field_get:manta.proto.RequestConfig.aspect_ratio)
    return _internal_aspect_ratio();
}
inline void RequestConfig::_internal_set_aspect_ratio(::manta::proto::AspectRatio value)
{
    assert(::manta::proto::AspectRatio_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.aspect_ratio_ = value;
}
inline void RequestConfig::set_aspect_ratio(::manta::proto::AspectRatio value)
{
    _internal_set_aspect_ratio(value);
    // @@protoc_insertion_point(field_set:manta.proto.RequestConfig.aspect_ratio)
}

// optional .manta.proto.Proto3Any specific_options = 9;
inline bool RequestConfig::_internal_has_specific_options() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.specific_options_ != nullptr);
    return value;
}
inline bool RequestConfig::has_specific_options() const
{
    return _internal_has_specific_options();
}
inline const ::manta::proto::Proto3Any& RequestConfig::_internal_specific_options() const
{
    const ::manta::proto::Proto3Any* p = _impl_.specific_options_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::Proto3Any&>(::manta::proto::_Proto3Any_default_instance_);
}
inline const ::manta::proto::Proto3Any& RequestConfig::specific_options() const
{
    // @@protoc_insertion_point(field_get:manta.proto.RequestConfig.specific_options)
    return _internal_specific_options();
}
inline void RequestConfig::unsafe_arena_set_allocated_specific_options(::manta::proto::Proto3Any* specific_options)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.specific_options_);
    }
    _impl_.specific_options_ = specific_options;
    if (specific_options) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.RequestConfig.specific_options)
}
inline ::manta::proto::Proto3Any* RequestConfig::release_specific_options()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::manta::proto::Proto3Any* temp = _impl_.specific_options_;
    _impl_.specific_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::Proto3Any* RequestConfig::unsafe_arena_release_specific_options()
{
    // @@protoc_insertion_point(field_release:manta.proto.RequestConfig.specific_options)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::manta::proto::Proto3Any* temp = _impl_.specific_options_;
    _impl_.specific_options_ = nullptr;
    return temp;
}
inline ::manta::proto::Proto3Any* RequestConfig::_internal_mutable_specific_options()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.specific_options_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::Proto3Any>(GetArenaForAllocation());
        _impl_.specific_options_ = p;
    }
    return _impl_.specific_options_;
}
inline ::manta::proto::Proto3Any* RequestConfig::mutable_specific_options()
{
    ::manta::proto::Proto3Any* _msg = _internal_mutable_specific_options();
    // @@protoc_insertion_point(field_mutable:manta.proto.RequestConfig.specific_options)
    return _msg;
}
inline void RequestConfig::set_allocated_specific_options(::manta::proto::Proto3Any* specific_options)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.specific_options_);
    }
    if (specific_options) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(specific_options));
        if (message_arena != submessage_arena) {
            specific_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, specific_options, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.specific_options_ = specific_options;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.RequestConfig.specific_options)
}

// -------------------------------------------------------------------

// InputData

// string text = 1;
inline bool InputData::_internal_has_text() const
{
    return input_data_case() == kText;
}
inline bool InputData::has_text() const
{
    return _internal_has_text();
}
inline void InputData::set_has_text()
{
    _impl_._oneof_case_[0] = kText;
}
inline void InputData::clear_text()
{
    if (_internal_has_text()) {
        _impl_.input_data_.text_.Destroy();
        clear_has_input_data();
    }
}
inline const std::string& InputData::text() const
{
    // @@protoc_insertion_point(field_get:manta.proto.InputData.text)
    return _internal_text();
}
template <typename ArgT0, typename... ArgT> inline void InputData::set_text(ArgT0&& arg0, ArgT... args)
{
    if (!_internal_has_text()) {
        clear_input_data();
        set_has_text();
        _impl_.input_data_.text_.InitDefault();
    }
    _impl_.input_data_.text_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.InputData.text)
}
inline std::string* InputData::mutable_text()
{
    std::string* _s = _internal_mutable_text();
    // @@protoc_insertion_point(field_mutable:manta.proto.InputData.text)
    return _s;
}
inline const std::string& InputData::_internal_text() const
{
    if (_internal_has_text()) {
        return _impl_.input_data_.text_.Get();
    }
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void InputData::_internal_set_text(const std::string& value)
{
    if (!_internal_has_text()) {
        clear_input_data();
        set_has_text();
        _impl_.input_data_.text_.InitDefault();
    }
    _impl_.input_data_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* InputData::_internal_mutable_text()
{
    if (!_internal_has_text()) {
        clear_input_data();
        set_has_text();
        _impl_.input_data_.text_.InitDefault();
    }
    return _impl_.input_data_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* InputData::release_text()
{
    // @@protoc_insertion_point(field_release:manta.proto.InputData.text)
    if (_internal_has_text()) {
        clear_has_input_data();
        return _impl_.input_data_.text_.Release();
    } else {
        return nullptr;
    }
}
inline void InputData::set_allocated_text(std::string* text)
{
    if (has_input_data()) {
        clear_input_data();
    }
    if (text != nullptr) {
        set_has_text();
        _impl_.input_data_.text_.InitAllocated(text, GetArenaForAllocation());
    }
    // @@protoc_insertion_point(field_set_allocated:manta.proto.InputData.text)
}

// .manta.proto.Image image = 2;
inline bool InputData::_internal_has_image() const
{
    return input_data_case() == kImage;
}
inline bool InputData::has_image() const
{
    return _internal_has_image();
}
inline void InputData::set_has_image()
{
    _impl_._oneof_case_[0] = kImage;
}
inline ::manta::proto::Image* InputData::release_image()
{
    // @@protoc_insertion_point(field_release:manta.proto.InputData.image)
    if (_internal_has_image()) {
        clear_has_input_data();
        ::manta::proto::Image* temp = _impl_.input_data_.image_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.input_data_.image_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::manta::proto::Image& InputData::_internal_image() const
{
    return _internal_has_image() ? *_impl_.input_data_.image_ : reinterpret_cast<::manta::proto::Image&>(::manta::proto::_Image_default_instance_);
}
inline const ::manta::proto::Image& InputData::image() const
{
    // @@protoc_insertion_point(field_get:manta.proto.InputData.image)
    return _internal_image();
}
inline ::manta::proto::Image* InputData::unsafe_arena_release_image()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:manta.proto.InputData.image)
    if (_internal_has_image()) {
        clear_has_input_data();
        ::manta::proto::Image* temp = _impl_.input_data_.image_;
        _impl_.input_data_.image_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void InputData::unsafe_arena_set_allocated_image(::manta::proto::Image* image)
{
    clear_input_data();
    if (image) {
        set_has_image();
        _impl_.input_data_.image_ = image;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.InputData.image)
}
inline ::manta::proto::Image* InputData::_internal_mutable_image()
{
    if (!_internal_has_image()) {
        clear_input_data();
        set_has_image();
        _impl_.input_data_.image_ = CreateMaybeMessage<::manta::proto::Image>(GetArenaForAllocation());
    }
    return _impl_.input_data_.image_;
}
inline ::manta::proto::Image* InputData::mutable_image()
{
    ::manta::proto::Image* _msg = _internal_mutable_image();
    // @@protoc_insertion_point(field_mutable:manta.proto.InputData.image)
    return _msg;
}

// .manta.proto.Proto3Any custom = 3;
inline bool InputData::_internal_has_custom() const
{
    return input_data_case() == kCustom;
}
inline bool InputData::has_custom() const
{
    return _internal_has_custom();
}
inline void InputData::set_has_custom()
{
    _impl_._oneof_case_[0] = kCustom;
}
inline ::manta::proto::Proto3Any* InputData::release_custom()
{
    // @@protoc_insertion_point(field_release:manta.proto.InputData.custom)
    if (_internal_has_custom()) {
        clear_has_input_data();
        ::manta::proto::Proto3Any* temp = _impl_.input_data_.custom_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.input_data_.custom_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::manta::proto::Proto3Any& InputData::_internal_custom() const
{
    return _internal_has_custom() ? *_impl_.input_data_.custom_ : reinterpret_cast<::manta::proto::Proto3Any&>(::manta::proto::_Proto3Any_default_instance_);
}
inline const ::manta::proto::Proto3Any& InputData::custom() const
{
    // @@protoc_insertion_point(field_get:manta.proto.InputData.custom)
    return _internal_custom();
}
inline ::manta::proto::Proto3Any* InputData::unsafe_arena_release_custom()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:manta.proto.InputData.custom)
    if (_internal_has_custom()) {
        clear_has_input_data();
        ::manta::proto::Proto3Any* temp = _impl_.input_data_.custom_;
        _impl_.input_data_.custom_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void InputData::unsafe_arena_set_allocated_custom(::manta::proto::Proto3Any* custom)
{
    clear_input_data();
    if (custom) {
        set_has_custom();
        _impl_.input_data_.custom_ = custom;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.InputData.custom)
}
inline ::manta::proto::Proto3Any* InputData::_internal_mutable_custom()
{
    if (!_internal_has_custom()) {
        clear_input_data();
        set_has_custom();
        _impl_.input_data_.custom_ = CreateMaybeMessage<::manta::proto::Proto3Any>(GetArenaForAllocation());
    }
    return _impl_.input_data_.custom_;
}
inline ::manta::proto::Proto3Any* InputData::mutable_custom()
{
    ::manta::proto::Proto3Any* _msg = _internal_mutable_custom();
    // @@protoc_insertion_point(field_mutable:manta.proto.InputData.custom)
    return _msg;
}

// .manta.proto.SparkyContextData sparky_context_data = 5;
inline bool InputData::_internal_has_sparky_context_data() const
{
    return input_data_case() == kSparkyContextData;
}
inline bool InputData::has_sparky_context_data() const
{
    return _internal_has_sparky_context_data();
}
inline void InputData::set_has_sparky_context_data()
{
    _impl_._oneof_case_[0] = kSparkyContextData;
}
inline ::manta::proto::SparkyContextData* InputData::release_sparky_context_data()
{
    // @@protoc_insertion_point(field_release:manta.proto.InputData.sparky_context_data)
    if (_internal_has_sparky_context_data()) {
        clear_has_input_data();
        ::manta::proto::SparkyContextData* temp = _impl_.input_data_.sparky_context_data_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.input_data_.sparky_context_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::manta::proto::SparkyContextData& InputData::_internal_sparky_context_data() const
{
    return _internal_has_sparky_context_data() ? *_impl_.input_data_.sparky_context_data_
                                               : reinterpret_cast<::manta::proto::SparkyContextData&>(::manta::proto::_SparkyContextData_default_instance_);
}
inline const ::manta::proto::SparkyContextData& InputData::sparky_context_data() const
{
    // @@protoc_insertion_point(field_get:manta.proto.InputData.sparky_context_data)
    return _internal_sparky_context_data();
}
inline ::manta::proto::SparkyContextData* InputData::unsafe_arena_release_sparky_context_data()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:manta.proto.InputData.sparky_context_data)
    if (_internal_has_sparky_context_data()) {
        clear_has_input_data();
        ::manta::proto::SparkyContextData* temp = _impl_.input_data_.sparky_context_data_;
        _impl_.input_data_.sparky_context_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void InputData::unsafe_arena_set_allocated_sparky_context_data(::manta::proto::SparkyContextData* sparky_context_data)
{
    clear_input_data();
    if (sparky_context_data) {
        set_has_sparky_context_data();
        _impl_.input_data_.sparky_context_data_ = sparky_context_data;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.InputData.sparky_context_data)
}
inline ::manta::proto::SparkyContextData* InputData::_internal_mutable_sparky_context_data()
{
    if (!_internal_has_sparky_context_data()) {
        clear_input_data();
        set_has_sparky_context_data();
        _impl_.input_data_.sparky_context_data_ = CreateMaybeMessage<::manta::proto::SparkyContextData>(GetArenaForAllocation());
    }
    return _impl_.input_data_.sparky_context_data_;
}
inline ::manta::proto::SparkyContextData* InputData::mutable_sparky_context_data()
{
    ::manta::proto::SparkyContextData* _msg = _internal_mutable_sparky_context_data();
    // @@protoc_insertion_point(field_mutable:manta.proto.InputData.sparky_context_data)
    return _msg;
}

// optional string tag = 4;
inline bool InputData::_internal_has_tag() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool InputData::has_tag() const
{
    return _internal_has_tag();
}
inline void InputData::clear_tag()
{
    _impl_.tag_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InputData::tag() const
{
    // @@protoc_insertion_point(field_get:manta.proto.InputData.tag)
    return _internal_tag();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void InputData::set_tag(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.tag_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.InputData.tag)
}
inline std::string* InputData::mutable_tag()
{
    std::string* _s = _internal_mutable_tag();
    // @@protoc_insertion_point(field_mutable:manta.proto.InputData.tag)
    return _s;
}
inline const std::string& InputData::_internal_tag() const
{
    return _impl_.tag_.Get();
}
inline void InputData::_internal_set_tag(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.tag_.Set(value, GetArenaForAllocation());
}
inline std::string* InputData::_internal_mutable_tag()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.tag_.Mutable(GetArenaForAllocation());
}
inline std::string* InputData::release_tag()
{
    // @@protoc_insertion_point(field_release:manta.proto.InputData.tag)
    if (!_internal_has_tag()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.tag_.IsDefault()) {
        _impl_.tag_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void InputData::set_allocated_tag(std::string* tag)
{
    if (tag != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.tag_.SetAllocated(tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.tag_.IsDefault()) {
        _impl_.tag_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.InputData.tag)
}

inline bool InputData::has_input_data() const
{
    return input_data_case() != INPUT_DATA_NOT_SET;
}
inline void InputData::clear_has_input_data()
{
    _impl_._oneof_case_[0] = INPUT_DATA_NOT_SET;
}
inline InputData::InputDataCase InputData::input_data_case() const
{
    return InputData::InputDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Request

// optional .manta.proto.FeatureName feature_name = 1;
inline bool Request::_internal_has_feature_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool Request::has_feature_name() const
{
    return _internal_has_feature_name();
}
inline void Request::clear_feature_name()
{
    _impl_.feature_name_ = 300;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::manta::proto::FeatureName Request::_internal_feature_name() const
{
    return static_cast<::manta::proto::FeatureName>(_impl_.feature_name_);
}
inline ::manta::proto::FeatureName Request::feature_name() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Request.feature_name)
    return _internal_feature_name();
}
inline void Request::_internal_set_feature_name(::manta::proto::FeatureName value)
{
    assert(::manta::proto::FeatureName_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.feature_name_ = value;
}
inline void Request::set_feature_name(::manta::proto::FeatureName value)
{
    _internal_set_feature_name(value);
    // @@protoc_insertion_point(field_set:manta.proto.Request.feature_name)
}

// optional .manta.proto.ClientInfo client_info = 2;
inline bool Request::_internal_has_client_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.client_info_ != nullptr);
    return value;
}
inline bool Request::has_client_info() const
{
    return _internal_has_client_info();
}
inline void Request::clear_client_info()
{
    if (_impl_.client_info_ != nullptr)
        _impl_.client_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::manta::proto::ClientInfo& Request::_internal_client_info() const
{
    const ::manta::proto::ClientInfo* p = _impl_.client_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::ClientInfo&>(::manta::proto::_ClientInfo_default_instance_);
}
inline const ::manta::proto::ClientInfo& Request::client_info() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Request.client_info)
    return _internal_client_info();
}
inline void Request::unsafe_arena_set_allocated_client_info(::manta::proto::ClientInfo* client_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_info_);
    }
    _impl_.client_info_ = client_info;
    if (client_info) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.Request.client_info)
}
inline ::manta::proto::ClientInfo* Request::release_client_info()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::ClientInfo* temp = _impl_.client_info_;
    _impl_.client_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::ClientInfo* Request::unsafe_arena_release_client_info()
{
    // @@protoc_insertion_point(field_release:manta.proto.Request.client_info)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::ClientInfo* temp = _impl_.client_info_;
    _impl_.client_info_ = nullptr;
    return temp;
}
inline ::manta::proto::ClientInfo* Request::_internal_mutable_client_info()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.client_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::ClientInfo>(GetArenaForAllocation());
        _impl_.client_info_ = p;
    }
    return _impl_.client_info_;
}
inline ::manta::proto::ClientInfo* Request::mutable_client_info()
{
    ::manta::proto::ClientInfo* _msg = _internal_mutable_client_info();
    // @@protoc_insertion_point(field_mutable:manta.proto.Request.client_info)
    return _msg;
}
inline void Request::set_allocated_client_info(::manta::proto::ClientInfo* client_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.client_info_;
    }
    if (client_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_info);
        if (message_arena != submessage_arena) {
            client_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, client_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.client_info_ = client_info;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Request.client_info)
}

// optional .manta.proto.RequestConfig request_config = 3;
inline bool Request::_internal_has_request_config() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.request_config_ != nullptr);
    return value;
}
inline bool Request::has_request_config() const
{
    return _internal_has_request_config();
}
inline void Request::clear_request_config()
{
    if (_impl_.request_config_ != nullptr)
        _impl_.request_config_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::manta::proto::RequestConfig& Request::_internal_request_config() const
{
    const ::manta::proto::RequestConfig* p = _impl_.request_config_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::RequestConfig&>(::manta::proto::_RequestConfig_default_instance_);
}
inline const ::manta::proto::RequestConfig& Request::request_config() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Request.request_config)
    return _internal_request_config();
}
inline void Request::unsafe_arena_set_allocated_request_config(::manta::proto::RequestConfig* request_config)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_config_);
    }
    _impl_.request_config_ = request_config;
    if (request_config) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.Request.request_config)
}
inline ::manta::proto::RequestConfig* Request::release_request_config()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::manta::proto::RequestConfig* temp = _impl_.request_config_;
    _impl_.request_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::RequestConfig* Request::unsafe_arena_release_request_config()
{
    // @@protoc_insertion_point(field_release:manta.proto.Request.request_config)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::manta::proto::RequestConfig* temp = _impl_.request_config_;
    _impl_.request_config_ = nullptr;
    return temp;
}
inline ::manta::proto::RequestConfig* Request::_internal_mutable_request_config()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.request_config_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::RequestConfig>(GetArenaForAllocation());
        _impl_.request_config_ = p;
    }
    return _impl_.request_config_;
}
inline ::manta::proto::RequestConfig* Request::mutable_request_config()
{
    ::manta::proto::RequestConfig* _msg = _internal_mutable_request_config();
    // @@protoc_insertion_point(field_mutable:manta.proto.Request.request_config)
    return _msg;
}
inline void Request::set_allocated_request_config(::manta::proto::RequestConfig* request_config)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.request_config_;
    }
    if (request_config) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request_config);
        if (message_arena != submessage_arena) {
            request_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, request_config, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.request_config_ = request_config;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Request.request_config)
}

// repeated .manta.proto.InputData input_data = 4;
inline int Request::_internal_input_data_size() const
{
    return _impl_.input_data_.size();
}
inline int Request::input_data_size() const
{
    return _internal_input_data_size();
}
inline void Request::clear_input_data()
{
    _impl_.input_data_.Clear();
}
inline ::manta::proto::InputData* Request::mutable_input_data(int index)
{
    // @@protoc_insertion_point(field_mutable:manta.proto.Request.input_data)
    return _impl_.input_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::InputData>* Request::mutable_input_data()
{
    // @@protoc_insertion_point(field_mutable_list:manta.proto.Request.input_data)
    return &_impl_.input_data_;
}
inline const ::manta::proto::InputData& Request::_internal_input_data(int index) const
{
    return _impl_.input_data_.Get(index);
}
inline const ::manta::proto::InputData& Request::input_data(int index) const
{
    // @@protoc_insertion_point(field_get:manta.proto.Request.input_data)
    return _internal_input_data(index);
}
inline ::manta::proto::InputData* Request::_internal_add_input_data()
{
    return _impl_.input_data_.Add();
}
inline ::manta::proto::InputData* Request::add_input_data()
{
    ::manta::proto::InputData* _add = _internal_add_input_data();
    // @@protoc_insertion_point(field_add:manta.proto.Request.input_data)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::InputData>& Request::input_data() const
{
    // @@protoc_insertion_point(field_list:manta.proto.Request.input_data)
    return _impl_.input_data_;
}

// -------------------------------------------------------------------

// OutputData

// string text = 1;
inline bool OutputData::_internal_has_text() const
{
    return output_data_case() == kText;
}
inline bool OutputData::has_text() const
{
    return _internal_has_text();
}
inline void OutputData::set_has_text()
{
    _impl_._oneof_case_[0] = kText;
}
inline void OutputData::clear_text()
{
    if (_internal_has_text()) {
        _impl_.output_data_.text_.Destroy();
        clear_has_output_data();
    }
}
inline const std::string& OutputData::text() const
{
    // @@protoc_insertion_point(field_get:manta.proto.OutputData.text)
    return _internal_text();
}
template <typename ArgT0, typename... ArgT> inline void OutputData::set_text(ArgT0&& arg0, ArgT... args)
{
    if (!_internal_has_text()) {
        clear_output_data();
        set_has_text();
        _impl_.output_data_.text_.InitDefault();
    }
    _impl_.output_data_.text_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.OutputData.text)
}
inline std::string* OutputData::mutable_text()
{
    std::string* _s = _internal_mutable_text();
    // @@protoc_insertion_point(field_mutable:manta.proto.OutputData.text)
    return _s;
}
inline const std::string& OutputData::_internal_text() const
{
    if (_internal_has_text()) {
        return _impl_.output_data_.text_.Get();
    }
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void OutputData::_internal_set_text(const std::string& value)
{
    if (!_internal_has_text()) {
        clear_output_data();
        set_has_text();
        _impl_.output_data_.text_.InitDefault();
    }
    _impl_.output_data_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* OutputData::_internal_mutable_text()
{
    if (!_internal_has_text()) {
        clear_output_data();
        set_has_text();
        _impl_.output_data_.text_.InitDefault();
    }
    return _impl_.output_data_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* OutputData::release_text()
{
    // @@protoc_insertion_point(field_release:manta.proto.OutputData.text)
    if (_internal_has_text()) {
        clear_has_output_data();
        return _impl_.output_data_.text_.Release();
    } else {
        return nullptr;
    }
}
inline void OutputData::set_allocated_text(std::string* text)
{
    if (has_output_data()) {
        clear_output_data();
    }
    if (text != nullptr) {
        set_has_text();
        _impl_.output_data_.text_.InitAllocated(text, GetArenaForAllocation());
    }
    // @@protoc_insertion_point(field_set_allocated:manta.proto.OutputData.text)
}

// .manta.proto.Image image = 2;
inline bool OutputData::_internal_has_image() const
{
    return output_data_case() == kImage;
}
inline bool OutputData::has_image() const
{
    return _internal_has_image();
}
inline void OutputData::set_has_image()
{
    _impl_._oneof_case_[0] = kImage;
}
inline ::manta::proto::Image* OutputData::release_image()
{
    // @@protoc_insertion_point(field_release:manta.proto.OutputData.image)
    if (_internal_has_image()) {
        clear_has_output_data();
        ::manta::proto::Image* temp = _impl_.output_data_.image_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.output_data_.image_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::manta::proto::Image& OutputData::_internal_image() const
{
    return _internal_has_image() ? *_impl_.output_data_.image_ : reinterpret_cast<::manta::proto::Image&>(::manta::proto::_Image_default_instance_);
}
inline const ::manta::proto::Image& OutputData::image() const
{
    // @@protoc_insertion_point(field_get:manta.proto.OutputData.image)
    return _internal_image();
}
inline ::manta::proto::Image* OutputData::unsafe_arena_release_image()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:manta.proto.OutputData.image)
    if (_internal_has_image()) {
        clear_has_output_data();
        ::manta::proto::Image* temp = _impl_.output_data_.image_;
        _impl_.output_data_.image_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void OutputData::unsafe_arena_set_allocated_image(::manta::proto::Image* image)
{
    clear_output_data();
    if (image) {
        set_has_image();
        _impl_.output_data_.image_ = image;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.OutputData.image)
}
inline ::manta::proto::Image* OutputData::_internal_mutable_image()
{
    if (!_internal_has_image()) {
        clear_output_data();
        set_has_image();
        _impl_.output_data_.image_ = CreateMaybeMessage<::manta::proto::Image>(GetArenaForAllocation());
    }
    return _impl_.output_data_.image_;
}
inline ::manta::proto::Image* OutputData::mutable_image()
{
    ::manta::proto::Image* _msg = _internal_mutable_image();
    // @@protoc_insertion_point(field_mutable:manta.proto.OutputData.image)
    return _msg;
}

// .manta.proto.Proto3Any custom = 3;
inline bool OutputData::_internal_has_custom() const
{
    return output_data_case() == kCustom;
}
inline bool OutputData::has_custom() const
{
    return _internal_has_custom();
}
inline void OutputData::set_has_custom()
{
    _impl_._oneof_case_[0] = kCustom;
}
inline ::manta::proto::Proto3Any* OutputData::release_custom()
{
    // @@protoc_insertion_point(field_release:manta.proto.OutputData.custom)
    if (_internal_has_custom()) {
        clear_has_output_data();
        ::manta::proto::Proto3Any* temp = _impl_.output_data_.custom_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.output_data_.custom_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::manta::proto::Proto3Any& OutputData::_internal_custom() const
{
    return _internal_has_custom() ? *_impl_.output_data_.custom_ : reinterpret_cast<::manta::proto::Proto3Any&>(::manta::proto::_Proto3Any_default_instance_);
}
inline const ::manta::proto::Proto3Any& OutputData::custom() const
{
    // @@protoc_insertion_point(field_get:manta.proto.OutputData.custom)
    return _internal_custom();
}
inline ::manta::proto::Proto3Any* OutputData::unsafe_arena_release_custom()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:manta.proto.OutputData.custom)
    if (_internal_has_custom()) {
        clear_has_output_data();
        ::manta::proto::Proto3Any* temp = _impl_.output_data_.custom_;
        _impl_.output_data_.custom_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void OutputData::unsafe_arena_set_allocated_custom(::manta::proto::Proto3Any* custom)
{
    clear_output_data();
    if (custom) {
        set_has_custom();
        _impl_.output_data_.custom_ = custom;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.OutputData.custom)
}
inline ::manta::proto::Proto3Any* OutputData::_internal_mutable_custom()
{
    if (!_internal_has_custom()) {
        clear_output_data();
        set_has_custom();
        _impl_.output_data_.custom_ = CreateMaybeMessage<::manta::proto::Proto3Any>(GetArenaForAllocation());
    }
    return _impl_.output_data_.custom_;
}
inline ::manta::proto::Proto3Any* OutputData::mutable_custom()
{
    ::manta::proto::Proto3Any* _msg = _internal_mutable_custom();
    // @@protoc_insertion_point(field_mutable:manta.proto.OutputData.custom)
    return _msg;
}

// .manta.proto.SparkyResponse sparky_response = 7;
inline bool OutputData::_internal_has_sparky_response() const
{
    return output_data_case() == kSparkyResponse;
}
inline bool OutputData::has_sparky_response() const
{
    return _internal_has_sparky_response();
}
inline void OutputData::set_has_sparky_response()
{
    _impl_._oneof_case_[0] = kSparkyResponse;
}
inline ::manta::proto::SparkyResponse* OutputData::release_sparky_response()
{
    // @@protoc_insertion_point(field_release:manta.proto.OutputData.sparky_response)
    if (_internal_has_sparky_response()) {
        clear_has_output_data();
        ::manta::proto::SparkyResponse* temp = _impl_.output_data_.sparky_response_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.output_data_.sparky_response_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::manta::proto::SparkyResponse& OutputData::_internal_sparky_response() const
{
    return _internal_has_sparky_response() ? *_impl_.output_data_.sparky_response_
                                           : reinterpret_cast<::manta::proto::SparkyResponse&>(::manta::proto::_SparkyResponse_default_instance_);
}
inline const ::manta::proto::SparkyResponse& OutputData::sparky_response() const
{
    // @@protoc_insertion_point(field_get:manta.proto.OutputData.sparky_response)
    return _internal_sparky_response();
}
inline ::manta::proto::SparkyResponse* OutputData::unsafe_arena_release_sparky_response()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:manta.proto.OutputData.sparky_response)
    if (_internal_has_sparky_response()) {
        clear_has_output_data();
        ::manta::proto::SparkyResponse* temp = _impl_.output_data_.sparky_response_;
        _impl_.output_data_.sparky_response_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void OutputData::unsafe_arena_set_allocated_sparky_response(::manta::proto::SparkyResponse* sparky_response)
{
    clear_output_data();
    if (sparky_response) {
        set_has_sparky_response();
        _impl_.output_data_.sparky_response_ = sparky_response;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.OutputData.sparky_response)
}
inline ::manta::proto::SparkyResponse* OutputData::_internal_mutable_sparky_response()
{
    if (!_internal_has_sparky_response()) {
        clear_output_data();
        set_has_sparky_response();
        _impl_.output_data_.sparky_response_ = CreateMaybeMessage<::manta::proto::SparkyResponse>(GetArenaForAllocation());
    }
    return _impl_.output_data_.sparky_response_;
}
inline ::manta::proto::SparkyResponse* OutputData::mutable_sparky_response()
{
    ::manta::proto::SparkyResponse* _msg = _internal_mutable_sparky_response();
    // @@protoc_insertion_point(field_mutable:manta.proto.OutputData.sparky_response)
    return _msg;
}

// optional float score = 5;
inline bool OutputData::_internal_has_score() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool OutputData::has_score() const
{
    return _internal_has_score();
}
inline void OutputData::clear_score()
{
    _impl_.score_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float OutputData::_internal_score() const
{
    return _impl_.score_;
}
inline float OutputData::score() const
{
    // @@protoc_insertion_point(field_get:manta.proto.OutputData.score)
    return _internal_score();
}
inline void OutputData::_internal_set_score(float value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.score_ = value;
}
inline void OutputData::set_score(float value)
{
    _internal_set_score(value);
    // @@protoc_insertion_point(field_set:manta.proto.OutputData.score)
}

// optional uint32 generation_seed = 6;
inline bool OutputData::_internal_has_generation_seed() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool OutputData::has_generation_seed() const
{
    return _internal_has_generation_seed();
}
inline void OutputData::clear_generation_seed()
{
    _impl_.generation_seed_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t OutputData::_internal_generation_seed() const
{
    return _impl_.generation_seed_;
}
inline uint32_t OutputData::generation_seed() const
{
    // @@protoc_insertion_point(field_get:manta.proto.OutputData.generation_seed)
    return _internal_generation_seed();
}
inline void OutputData::_internal_set_generation_seed(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.generation_seed_ = value;
}
inline void OutputData::set_generation_seed(uint32_t value)
{
    _internal_set_generation_seed(value);
    // @@protoc_insertion_point(field_set:manta.proto.OutputData.generation_seed)
}

inline bool OutputData::has_output_data() const
{
    return output_data_case() != OUTPUT_DATA_NOT_SET;
}
inline void OutputData::clear_has_output_data()
{
    _impl_._oneof_case_[0] = OUTPUT_DATA_NOT_SET;
}
inline OutputData::OutputDataCase OutputData::output_data_case() const
{
    return OutputData::OutputDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FilteredData

// optional bool is_output_data = 2;
inline bool FilteredData::_internal_has_is_output_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool FilteredData::has_is_output_data() const
{
    return _internal_has_is_output_data();
}
inline void FilteredData::clear_is_output_data()
{
    _impl_.is_output_data_ = false;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool FilteredData::_internal_is_output_data() const
{
    return _impl_.is_output_data_;
}
inline bool FilteredData::is_output_data() const
{
    // @@protoc_insertion_point(field_get:manta.proto.FilteredData.is_output_data)
    return _internal_is_output_data();
}
inline void FilteredData::_internal_set_is_output_data(bool value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.is_output_data_ = value;
}
inline void FilteredData::set_is_output_data(bool value)
{
    _internal_set_is_output_data(value);
    // @@protoc_insertion_point(field_set:manta.proto.FilteredData.is_output_data)
}

// optional .manta.proto.FilteredReason reason = 3;
inline bool FilteredData::_internal_has_reason() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool FilteredData::has_reason() const
{
    return _internal_has_reason();
}
inline void FilteredData::clear_reason()
{
    _impl_.reason_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::manta::proto::FilteredReason FilteredData::_internal_reason() const
{
    return static_cast<::manta::proto::FilteredReason>(_impl_.reason_);
}
inline ::manta::proto::FilteredReason FilteredData::reason() const
{
    // @@protoc_insertion_point(field_get:manta.proto.FilteredData.reason)
    return _internal_reason();
}
inline void FilteredData::_internal_set_reason(::manta::proto::FilteredReason value)
{
    assert(::manta::proto::FilteredReason_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.reason_ = value;
}
inline void FilteredData::set_reason(::manta::proto::FilteredReason value)
{
    _internal_set_reason(value);
    // @@protoc_insertion_point(field_set:manta.proto.FilteredData.reason)
}

// -------------------------------------------------------------------

// Response

// repeated .manta.proto.OutputData output_data = 1;
inline int Response::_internal_output_data_size() const
{
    return _impl_.output_data_.size();
}
inline int Response::output_data_size() const
{
    return _internal_output_data_size();
}
inline void Response::clear_output_data()
{
    _impl_.output_data_.Clear();
}
inline ::manta::proto::OutputData* Response::mutable_output_data(int index)
{
    // @@protoc_insertion_point(field_mutable:manta.proto.Response.output_data)
    return _impl_.output_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::OutputData>* Response::mutable_output_data()
{
    // @@protoc_insertion_point(field_mutable_list:manta.proto.Response.output_data)
    return &_impl_.output_data_;
}
inline const ::manta::proto::OutputData& Response::_internal_output_data(int index) const
{
    return _impl_.output_data_.Get(index);
}
inline const ::manta::proto::OutputData& Response::output_data(int index) const
{
    // @@protoc_insertion_point(field_get:manta.proto.Response.output_data)
    return _internal_output_data(index);
}
inline ::manta::proto::OutputData* Response::_internal_add_output_data()
{
    return _impl_.output_data_.Add();
}
inline ::manta::proto::OutputData* Response::add_output_data()
{
    ::manta::proto::OutputData* _add = _internal_add_output_data();
    // @@protoc_insertion_point(field_add:manta.proto.Response.output_data)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::OutputData>& Response::output_data() const
{
    // @@protoc_insertion_point(field_list:manta.proto.Response.output_data)
    return _impl_.output_data_;
}

// repeated .manta.proto.FilteredData filtered_data = 2;
inline int Response::_internal_filtered_data_size() const
{
    return _impl_.filtered_data_.size();
}
inline int Response::filtered_data_size() const
{
    return _internal_filtered_data_size();
}
inline void Response::clear_filtered_data()
{
    _impl_.filtered_data_.Clear();
}
inline ::manta::proto::FilteredData* Response::mutable_filtered_data(int index)
{
    // @@protoc_insertion_point(field_mutable:manta.proto.Response.filtered_data)
    return _impl_.filtered_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::FilteredData>* Response::mutable_filtered_data()
{
    // @@protoc_insertion_point(field_mutable_list:manta.proto.Response.filtered_data)
    return &_impl_.filtered_data_;
}
inline const ::manta::proto::FilteredData& Response::_internal_filtered_data(int index) const
{
    return _impl_.filtered_data_.Get(index);
}
inline const ::manta::proto::FilteredData& Response::filtered_data(int index) const
{
    // @@protoc_insertion_point(field_get:manta.proto.Response.filtered_data)
    return _internal_filtered_data(index);
}
inline ::manta::proto::FilteredData* Response::_internal_add_filtered_data()
{
    return _impl_.filtered_data_.Add();
}
inline ::manta::proto::FilteredData* Response::add_filtered_data()
{
    ::manta::proto::FilteredData* _add = _internal_add_filtered_data();
    // @@protoc_insertion_point(field_add:manta.proto.Response.filtered_data)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::FilteredData>& Response::filtered_data() const
{
    // @@protoc_insertion_point(field_list:manta.proto.Response.filtered_data)
    return _impl_.filtered_data_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace proto
} // namespace manta

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::manta::proto::ClientInfo_ClientType> : ::std::true_type { };
template <> struct is_proto_enum<::manta::proto::ChromeClientInfo_Channel> : ::std::true_type { };
template <> struct is_proto_enum<::manta::proto::RequestConfig_Tone> : ::std::true_type { };
template <> struct is_proto_enum<::manta::proto::FeatureName> : ::std::true_type { };
template <> struct is_proto_enum<::manta::proto::ImageResolution> : ::std::true_type { };
template <> struct is_proto_enum<::manta::proto::AspectRatio> : ::std::true_type { };
template <> struct is_proto_enum<::manta::proto::FilteredReason> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fmanta_2fproto_2fmanta_2eproto
