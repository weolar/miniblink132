// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/manta/proto/sparky.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fmanta_2fproto_2fsparky_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fmanta_2fproto_2fsparky_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/manta/proto/common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fmanta_2fproto_2fsparky_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fmanta_2fproto_2fsparky_2eproto {
    static const uint32_t offsets[];
};
namespace manta {
namespace proto {
class Action;
struct ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class App;
struct AppDefaultTypeInternal;
extern AppDefaultTypeInternal _App_default_instance_;
class AppsData;
struct AppsDataDefaultTypeInternal;
extern AppsDataDefaultTypeInternal _AppsData_default_instance_;
class BatteryData;
struct BatteryDataDefaultTypeInternal;
extern BatteryDataDefaultTypeInternal _BatteryData_default_instance_;
class CPUData;
struct CPUDataDefaultTypeInternal;
extern CPUDataDefaultTypeInternal _CPUData_default_instance_;
class Click;
struct ClickDefaultTypeInternal;
extern ClickDefaultTypeInternal _Click_default_instance_;
class ContextRequest;
struct ContextRequestDefaultTypeInternal;
extern ContextRequestDefaultTypeInternal _ContextRequest_default_instance_;
class DiagnosticsData;
struct DiagnosticsDataDefaultTypeInternal;
extern DiagnosticsDataDefaultTypeInternal _DiagnosticsData_default_instance_;
class DiagnosticsRequest;
struct DiagnosticsRequestDefaultTypeInternal;
extern DiagnosticsRequestDefaultTypeInternal _DiagnosticsRequest_default_instance_;
class File;
struct FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class FileRequest;
struct FileRequestDefaultTypeInternal;
extern FileRequestDefaultTypeInternal _FileRequest_default_instance_;
class FilesData;
struct FilesDataDefaultTypeInternal;
extern FilesDataDefaultTypeInternal _FilesData_default_instance_;
class KeyPress;
struct KeyPressDefaultTypeInternal;
extern KeyPressDefaultTypeInternal _KeyPress_default_instance_;
class LaunchFile;
struct LaunchFileDefaultTypeInternal;
extern LaunchFileDefaultTypeInternal _LaunchFile_default_instance_;
class MemoryData;
struct MemoryDataDefaultTypeInternal;
extern MemoryDataDefaultTypeInternal _MemoryData_default_instance_;
class Scroll;
struct ScrollDefaultTypeInternal;
extern ScrollDefaultTypeInternal _Scroll_default_instance_;
class ServerConfig;
struct ServerConfigDefaultTypeInternal;
extern ServerConfigDefaultTypeInternal _ServerConfig_default_instance_;
class Setting;
struct SettingDefaultTypeInternal;
extern SettingDefaultTypeInternal _Setting_default_instance_;
class SettingsData;
struct SettingsDataDefaultTypeInternal;
extern SettingsDataDefaultTypeInternal _SettingsData_default_instance_;
class SettingsDataRequest;
struct SettingsDataRequestDefaultTypeInternal;
extern SettingsDataRequestDefaultTypeInternal _SettingsDataRequest_default_instance_;
class SettingsValue;
struct SettingsValueDefaultTypeInternal;
extern SettingsValueDefaultTypeInternal _SettingsValue_default_instance_;
class SparkyContextData;
struct SparkyContextDataDefaultTypeInternal;
extern SparkyContextDataDefaultTypeInternal _SparkyContextData_default_instance_;
class SparkyResponse;
struct SparkyResponseDefaultTypeInternal;
extern SparkyResponseDefaultTypeInternal _SparkyResponse_default_instance_;
class StorageData;
struct StorageDataDefaultTypeInternal;
extern StorageDataDefaultTypeInternal _StorageData_default_instance_;
class TextEntry;
struct TextEntryDefaultTypeInternal;
extern TextEntryDefaultTypeInternal _TextEntry_default_instance_;
class Turn;
struct TurnDefaultTypeInternal;
extern TurnDefaultTypeInternal _Turn_default_instance_;
class Update;
struct UpdateDefaultTypeInternal;
extern UpdateDefaultTypeInternal _Update_default_instance_;
class WebContent;
struct WebContentDefaultTypeInternal;
extern WebContentDefaultTypeInternal _WebContent_default_instance_;
class WriteFile;
struct WriteFileDefaultTypeInternal;
extern WriteFileDefaultTypeInternal _WriteFile_default_instance_;
} // namespace proto
} // namespace manta
PROTOBUF_NAMESPACE_OPEN
template <>::manta::proto::Action* Arena::CreateMaybeMessage<::manta::proto::Action>(Arena*);
template <>::manta::proto::App* Arena::CreateMaybeMessage<::manta::proto::App>(Arena*);
template <>::manta::proto::AppsData* Arena::CreateMaybeMessage<::manta::proto::AppsData>(Arena*);
template <>::manta::proto::BatteryData* Arena::CreateMaybeMessage<::manta::proto::BatteryData>(Arena*);
template <>::manta::proto::CPUData* Arena::CreateMaybeMessage<::manta::proto::CPUData>(Arena*);
template <>::manta::proto::Click* Arena::CreateMaybeMessage<::manta::proto::Click>(Arena*);
template <>::manta::proto::ContextRequest* Arena::CreateMaybeMessage<::manta::proto::ContextRequest>(Arena*);
template <>::manta::proto::DiagnosticsData* Arena::CreateMaybeMessage<::manta::proto::DiagnosticsData>(Arena*);
template <>::manta::proto::DiagnosticsRequest* Arena::CreateMaybeMessage<::manta::proto::DiagnosticsRequest>(Arena*);
template <>::manta::proto::File* Arena::CreateMaybeMessage<::manta::proto::File>(Arena*);
template <>::manta::proto::FileRequest* Arena::CreateMaybeMessage<::manta::proto::FileRequest>(Arena*);
template <>::manta::proto::FilesData* Arena::CreateMaybeMessage<::manta::proto::FilesData>(Arena*);
template <>::manta::proto::KeyPress* Arena::CreateMaybeMessage<::manta::proto::KeyPress>(Arena*);
template <>::manta::proto::LaunchFile* Arena::CreateMaybeMessage<::manta::proto::LaunchFile>(Arena*);
template <>::manta::proto::MemoryData* Arena::CreateMaybeMessage<::manta::proto::MemoryData>(Arena*);
template <>::manta::proto::Scroll* Arena::CreateMaybeMessage<::manta::proto::Scroll>(Arena*);
template <>::manta::proto::ServerConfig* Arena::CreateMaybeMessage<::manta::proto::ServerConfig>(Arena*);
template <>::manta::proto::Setting* Arena::CreateMaybeMessage<::manta::proto::Setting>(Arena*);
template <>::manta::proto::SettingsData* Arena::CreateMaybeMessage<::manta::proto::SettingsData>(Arena*);
template <>::manta::proto::SettingsDataRequest* Arena::CreateMaybeMessage<::manta::proto::SettingsDataRequest>(Arena*);
template <>::manta::proto::SettingsValue* Arena::CreateMaybeMessage<::manta::proto::SettingsValue>(Arena*);
template <>::manta::proto::SparkyContextData* Arena::CreateMaybeMessage<::manta::proto::SparkyContextData>(Arena*);
template <>::manta::proto::SparkyResponse* Arena::CreateMaybeMessage<::manta::proto::SparkyResponse>(Arena*);
template <>::manta::proto::StorageData* Arena::CreateMaybeMessage<::manta::proto::StorageData>(Arena*);
template <>::manta::proto::TextEntry* Arena::CreateMaybeMessage<::manta::proto::TextEntry>(Arena*);
template <>::manta::proto::Turn* Arena::CreateMaybeMessage<::manta::proto::Turn>(Arena*);
template <>::manta::proto::Update* Arena::CreateMaybeMessage<::manta::proto::Update>(Arena*);
template <>::manta::proto::WebContent* Arena::CreateMaybeMessage<::manta::proto::WebContent>(Arena*);
template <>::manta::proto::WriteFile* Arena::CreateMaybeMessage<::manta::proto::WriteFile>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace manta {
namespace proto {

enum Click_Button : int {
    Click_Button_UNSPECIFIED = 0,
    Click_Button_LEFT = 1,
    Click_Button_RIGHT = 2,
    Click_Button_MIDDLE = 3,
    Click_Button_Click_Button_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    Click_Button_Click_Button_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Click_Button_IsValid(int value);
constexpr Click_Button Click_Button_Button_MIN = Click_Button_UNSPECIFIED;
constexpr Click_Button Click_Button_Button_MAX = Click_Button_MIDDLE;
constexpr int Click_Button_Button_ARRAYSIZE = Click_Button_Button_MAX + 1;

const std::string& Click_Button_Name(Click_Button value);
template <typename T> inline const std::string& Click_Button_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Click_Button>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Click_Button_Name.");
    return Click_Button_Name(static_cast<Click_Button>(enum_t_value));
}
bool Click_Button_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Click_Button* value);
enum Scroll_Direction : int {
    Scroll_Direction_UNSPECIFIED = 0,
    Scroll_Direction_UP = 1,
    Scroll_Direction_DOWN = 2,
    Scroll_Direction_LEFT = 3,
    Scroll_Direction_RIGHT = 4,
    Scroll_Direction_Scroll_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    Scroll_Direction_Scroll_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Scroll_Direction_IsValid(int value);
constexpr Scroll_Direction Scroll_Direction_Direction_MIN = Scroll_Direction_UNSPECIFIED;
constexpr Scroll_Direction Scroll_Direction_Direction_MAX = Scroll_Direction_RIGHT;
constexpr int Scroll_Direction_Direction_ARRAYSIZE = Scroll_Direction_Direction_MAX + 1;

const std::string& Scroll_Direction_Name(Scroll_Direction value);
template <typename T> inline const std::string& Scroll_Direction_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Scroll_Direction>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Scroll_Direction_Name.");
    return Scroll_Direction_Name(static_cast<Scroll_Direction>(enum_t_value));
}
bool Scroll_Direction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Scroll_Direction* value);
enum Task : int {
    TASK_UNSPECIFIED = 0,
    TASK_SETTINGS = 1,
    TASK_DIAGNOSTICS = 2,
    TASK_GENERIC = 5,
    TASK_PLANNER = 6,
    Task_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    Task_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Task_IsValid(int value);
constexpr Task Task_MIN = TASK_UNSPECIFIED;
constexpr Task Task_MAX = TASK_PLANNER;
constexpr int Task_ARRAYSIZE = Task_MAX + 1;

const std::string& Task_Name(Task value);
template <typename T> inline const std::string& Task_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Task>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Task_Name.");
    return Task_Name(static_cast<Task>(enum_t_value));
}
bool Task_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Task* value);
enum Diagnostics : int {
    DIAGNOSTICS_UNSPECIFIED = 0,
    DIAGNOSTICS_MEMORY = 1,
    DIAGNOSTICS_CPU = 2,
    DIAGNOSTICS_BATTERY = 3,
    DIAGNOSTICS_STORAGE = 4,
    Diagnostics_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    Diagnostics_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Diagnostics_IsValid(int value);
constexpr Diagnostics Diagnostics_MIN = DIAGNOSTICS_UNSPECIFIED;
constexpr Diagnostics Diagnostics_MAX = DIAGNOSTICS_STORAGE;
constexpr int Diagnostics_ARRAYSIZE = Diagnostics_MAX + 1;

const std::string& Diagnostics_Name(Diagnostics value);
template <typename T> inline const std::string& Diagnostics_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Diagnostics>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Diagnostics_Name.");
    return Diagnostics_Name(static_cast<Diagnostics>(enum_t_value));
}
bool Diagnostics_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Diagnostics* value);
enum SettingType : int {
    SETTING_TYPE_UNSPECIFIED = 0,
    SETTING_TYPE_BOOL = 1,
    SETTING_TYPE_STRING = 2,
    SETTING_TYPE_DOUBLE = 3,
    SETTING_TYPE_INTEGER = 4,
    SettingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    SettingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SettingType_IsValid(int value);
constexpr SettingType SettingType_MIN = SETTING_TYPE_UNSPECIFIED;
constexpr SettingType SettingType_MAX = SETTING_TYPE_INTEGER;
constexpr int SettingType_ARRAYSIZE = SettingType_MAX + 1;

const std::string& SettingType_Name(SettingType value);
template <typename T> inline const std::string& SettingType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, SettingType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function SettingType_Name.");
    return SettingType_Name(static_cast<SettingType>(enum_t_value));
}
bool SettingType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SettingType* value);
enum Role : int {
    ROLE_UNSPECIFIED = 0,
    ROLE_USER = 1,
    ROLE_ASSISTANT = 2,
    Role_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    Role_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Role_IsValid(int value);
constexpr Role Role_MIN = ROLE_UNSPECIFIED;
constexpr Role Role_MAX = ROLE_ASSISTANT;
constexpr int Role_ARRAYSIZE = Role_MAX + 1;

const std::string& Role_Name(Role value);
template <typename T> inline const std::string& Role_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Role>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Role_Name.");
    return Role_Name(static_cast<Role>(enum_t_value));
}
bool Role_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Role* value);
// ===================================================================

class BatteryData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.BatteryData) */ {
public:
    inline BatteryData()
        : BatteryData(nullptr)
    {
    }
    ~BatteryData() override;
    explicit PROTOBUF_CONSTEXPR BatteryData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    BatteryData(const BatteryData& from);
    BatteryData(BatteryData&& from) noexcept
        : BatteryData()
    {
        *this = ::std::move(from);
    }

    inline BatteryData& operator=(const BatteryData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline BatteryData& operator=(BatteryData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const BatteryData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const BatteryData* internal_default_instance()
    {
        return reinterpret_cast<const BatteryData*>(&_BatteryData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(BatteryData& a, BatteryData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(BatteryData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(BatteryData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    BatteryData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<BatteryData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const BatteryData& from);
    void MergeFrom(const BatteryData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(BatteryData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.BatteryData";
    }

protected:
    explicit BatteryData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kBatteryTimeFieldNumber = 3,
        kBatteryHealthFieldNumber = 1,
        kCycleCountFieldNumber = 2,
        kBatteryChargePercentageFieldNumber = 4,
    };
    // optional string battery_time = 3;
    bool has_battery_time() const;

private:
    bool _internal_has_battery_time() const;

public:
    void clear_battery_time();
    const std::string& battery_time() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_battery_time(ArgT0&& arg0, ArgT... args);
    std::string* mutable_battery_time();
    PROTOBUF_NODISCARD std::string* release_battery_time();
    void set_allocated_battery_time(std::string* battery_time);

private:
    const std::string& _internal_battery_time() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_battery_time(const std::string& value);
    std::string* _internal_mutable_battery_time();

public:
    // optional int32 battery_health = 1;
    bool has_battery_health() const;

private:
    bool _internal_has_battery_health() const;

public:
    void clear_battery_health();
    int32_t battery_health() const;
    void set_battery_health(int32_t value);

private:
    int32_t _internal_battery_health() const;
    void _internal_set_battery_health(int32_t value);

public:
    // optional int32 cycle_count = 2;
    bool has_cycle_count() const;

private:
    bool _internal_has_cycle_count() const;

public:
    void clear_cycle_count();
    int32_t cycle_count() const;
    void set_cycle_count(int32_t value);

private:
    int32_t _internal_cycle_count() const;
    void _internal_set_cycle_count(int32_t value);

public:
    // optional int32 battery_charge_percentage = 4;
    bool has_battery_charge_percentage() const;

private:
    bool _internal_has_battery_charge_percentage() const;

public:
    void clear_battery_charge_percentage();
    int32_t battery_charge_percentage() const;
    void set_battery_charge_percentage(int32_t value);

private:
    int32_t _internal_battery_charge_percentage() const;
    void _internal_set_battery_charge_percentage(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.BatteryData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr battery_time_;
        int32_t battery_health_;
        int32_t cycle_count_;
        int32_t battery_charge_percentage_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class StorageData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.StorageData) */ {
public:
    inline StorageData()
        : StorageData(nullptr)
    {
    }
    ~StorageData() override;
    explicit PROTOBUF_CONSTEXPR StorageData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    StorageData(const StorageData& from);
    StorageData(StorageData&& from) noexcept
        : StorageData()
    {
        *this = ::std::move(from);
    }

    inline StorageData& operator=(const StorageData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline StorageData& operator=(StorageData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const StorageData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const StorageData* internal_default_instance()
    {
        return reinterpret_cast<const StorageData*>(&_StorageData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(StorageData& a, StorageData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(StorageData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(StorageData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    StorageData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<StorageData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const StorageData& from);
    void MergeFrom(const StorageData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(StorageData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.StorageData";
    }

protected:
    explicit StorageData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFreeStorageFieldNumber = 1,
        kTotalStorageFieldNumber = 2,
    };
    // optional string free_storage = 1;
    bool has_free_storage() const;

private:
    bool _internal_has_free_storage() const;

public:
    void clear_free_storage();
    const std::string& free_storage() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_free_storage(ArgT0&& arg0, ArgT... args);
    std::string* mutable_free_storage();
    PROTOBUF_NODISCARD std::string* release_free_storage();
    void set_allocated_free_storage(std::string* free_storage);

private:
    const std::string& _internal_free_storage() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_free_storage(const std::string& value);
    std::string* _internal_mutable_free_storage();

public:
    // optional string total_storage = 2;
    bool has_total_storage() const;

private:
    bool _internal_has_total_storage() const;

public:
    void clear_total_storage();
    const std::string& total_storage() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_total_storage(ArgT0&& arg0, ArgT... args);
    std::string* mutable_total_storage();
    PROTOBUF_NODISCARD std::string* release_total_storage();
    void set_allocated_total_storage(std::string* total_storage);

private:
    const std::string& _internal_total_storage() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_total_storage(const std::string& value);
    std::string* _internal_mutable_total_storage();

public:
    // @@protoc_insertion_point(class_scope:manta.proto.StorageData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr free_storage_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr total_storage_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class CPUData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.CPUData) */ {
public:
    inline CPUData()
        : CPUData(nullptr)
    {
    }
    ~CPUData() override;
    explicit PROTOBUF_CONSTEXPR CPUData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CPUData(const CPUData& from);
    CPUData(CPUData&& from) noexcept
        : CPUData()
    {
        *this = ::std::move(from);
    }

    inline CPUData& operator=(const CPUData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CPUData& operator=(CPUData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const CPUData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CPUData* internal_default_instance()
    {
        return reinterpret_cast<const CPUData*>(&_CPUData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(CPUData& a, CPUData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CPUData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CPUData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CPUData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CPUData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CPUData& from);
    void MergeFrom(const CPUData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CPUData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.CPUData";
    }

protected:
    explicit CPUData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCpuUsageSnapshotFieldNumber = 1,
        kTemperatureFieldNumber = 2,
        kClockSpeedGhzFieldNumber = 3,
    };
    // optional int32 cpu_usage_snapshot = 1;
    bool has_cpu_usage_snapshot() const;

private:
    bool _internal_has_cpu_usage_snapshot() const;

public:
    void clear_cpu_usage_snapshot();
    int32_t cpu_usage_snapshot() const;
    void set_cpu_usage_snapshot(int32_t value);

private:
    int32_t _internal_cpu_usage_snapshot() const;
    void _internal_set_cpu_usage_snapshot(int32_t value);

public:
    // optional int32 temperature = 2;
    bool has_temperature() const;

private:
    bool _internal_has_temperature() const;

public:
    void clear_temperature();
    int32_t temperature() const;
    void set_temperature(int32_t value);

private:
    int32_t _internal_temperature() const;
    void _internal_set_temperature(int32_t value);

public:
    // optional double clock_speed_ghz = 3;
    bool has_clock_speed_ghz() const;

private:
    bool _internal_has_clock_speed_ghz() const;

public:
    void clear_clock_speed_ghz();
    double clock_speed_ghz() const;
    void set_clock_speed_ghz(double value);

private:
    double _internal_clock_speed_ghz() const;
    void _internal_set_clock_speed_ghz(double value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.CPUData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int32_t cpu_usage_snapshot_;
        int32_t temperature_;
        double clock_speed_ghz_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class MemoryData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.MemoryData) */ {
public:
    inline MemoryData()
        : MemoryData(nullptr)
    {
    }
    ~MemoryData() override;
    explicit PROTOBUF_CONSTEXPR MemoryData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    MemoryData(const MemoryData& from);
    MemoryData(MemoryData&& from) noexcept
        : MemoryData()
    {
        *this = ::std::move(from);
    }

    inline MemoryData& operator=(const MemoryData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline MemoryData& operator=(MemoryData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const MemoryData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const MemoryData* internal_default_instance()
    {
        return reinterpret_cast<const MemoryData*>(&_MemoryData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(MemoryData& a, MemoryData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(MemoryData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(MemoryData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    MemoryData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<MemoryData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const MemoryData& from);
    void MergeFrom(const MemoryData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(MemoryData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.MemoryData";
    }

protected:
    explicit MemoryData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFreeRamGbFieldNumber = 1,
        kTotalRamGbFieldNumber = 2,
    };
    // optional double free_ram_gb = 1;
    bool has_free_ram_gb() const;

private:
    bool _internal_has_free_ram_gb() const;

public:
    void clear_free_ram_gb();
    double free_ram_gb() const;
    void set_free_ram_gb(double value);

private:
    double _internal_free_ram_gb() const;
    void _internal_set_free_ram_gb(double value);

public:
    // optional double total_ram_gb = 2;
    bool has_total_ram_gb() const;

private:
    bool _internal_has_total_ram_gb() const;

public:
    void clear_total_ram_gb();
    double total_ram_gb() const;
    void set_total_ram_gb(double value);

private:
    double _internal_total_ram_gb() const;
    void _internal_set_total_ram_gb(double value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.MemoryData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        double free_ram_gb_;
        double total_ram_gb_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class DiagnosticsData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.DiagnosticsData) */ {
public:
    inline DiagnosticsData()
        : DiagnosticsData(nullptr)
    {
    }
    ~DiagnosticsData() override;
    explicit PROTOBUF_CONSTEXPR DiagnosticsData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    DiagnosticsData(const DiagnosticsData& from);
    DiagnosticsData(DiagnosticsData&& from) noexcept
        : DiagnosticsData()
    {
        *this = ::std::move(from);
    }

    inline DiagnosticsData& operator=(const DiagnosticsData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DiagnosticsData& operator=(DiagnosticsData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const DiagnosticsData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DiagnosticsData* internal_default_instance()
    {
        return reinterpret_cast<const DiagnosticsData*>(&_DiagnosticsData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(DiagnosticsData& a, DiagnosticsData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(DiagnosticsData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DiagnosticsData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DiagnosticsData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<DiagnosticsData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const DiagnosticsData& from);
    void MergeFrom(const DiagnosticsData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DiagnosticsData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.DiagnosticsData";
    }

protected:
    explicit DiagnosticsData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kBatteryFieldNumber = 1,
        kStorageFieldNumber = 2,
        kCpuFieldNumber = 3,
        kMemoryFieldNumber = 4,
    };
    // optional .manta.proto.BatteryData battery = 1;
    bool has_battery() const;

private:
    bool _internal_has_battery() const;

public:
    void clear_battery();
    const ::manta::proto::BatteryData& battery() const;
    PROTOBUF_NODISCARD ::manta::proto::BatteryData* release_battery();
    ::manta::proto::BatteryData* mutable_battery();
    void set_allocated_battery(::manta::proto::BatteryData* battery);

private:
    const ::manta::proto::BatteryData& _internal_battery() const;
    ::manta::proto::BatteryData* _internal_mutable_battery();

public:
    void unsafe_arena_set_allocated_battery(::manta::proto::BatteryData* battery);
    ::manta::proto::BatteryData* unsafe_arena_release_battery();

    // optional .manta.proto.StorageData storage = 2;
    bool has_storage() const;

private:
    bool _internal_has_storage() const;

public:
    void clear_storage();
    const ::manta::proto::StorageData& storage() const;
    PROTOBUF_NODISCARD ::manta::proto::StorageData* release_storage();
    ::manta::proto::StorageData* mutable_storage();
    void set_allocated_storage(::manta::proto::StorageData* storage);

private:
    const ::manta::proto::StorageData& _internal_storage() const;
    ::manta::proto::StorageData* _internal_mutable_storage();

public:
    void unsafe_arena_set_allocated_storage(::manta::proto::StorageData* storage);
    ::manta::proto::StorageData* unsafe_arena_release_storage();

    // optional .manta.proto.CPUData cpu = 3;
    bool has_cpu() const;

private:
    bool _internal_has_cpu() const;

public:
    void clear_cpu();
    const ::manta::proto::CPUData& cpu() const;
    PROTOBUF_NODISCARD ::manta::proto::CPUData* release_cpu();
    ::manta::proto::CPUData* mutable_cpu();
    void set_allocated_cpu(::manta::proto::CPUData* cpu);

private:
    const ::manta::proto::CPUData& _internal_cpu() const;
    ::manta::proto::CPUData* _internal_mutable_cpu();

public:
    void unsafe_arena_set_allocated_cpu(::manta::proto::CPUData* cpu);
    ::manta::proto::CPUData* unsafe_arena_release_cpu();

    // optional .manta.proto.MemoryData memory = 4;
    bool has_memory() const;

private:
    bool _internal_has_memory() const;

public:
    void clear_memory();
    const ::manta::proto::MemoryData& memory() const;
    PROTOBUF_NODISCARD ::manta::proto::MemoryData* release_memory();
    ::manta::proto::MemoryData* mutable_memory();
    void set_allocated_memory(::manta::proto::MemoryData* memory);

private:
    const ::manta::proto::MemoryData& _internal_memory() const;
    ::manta::proto::MemoryData* _internal_mutable_memory();

public:
    void unsafe_arena_set_allocated_memory(::manta::proto::MemoryData* memory);
    ::manta::proto::MemoryData* unsafe_arena_release_memory();

    // @@protoc_insertion_point(class_scope:manta.proto.DiagnosticsData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::manta::proto::BatteryData* battery_;
        ::manta::proto::StorageData* storage_;
        ::manta::proto::CPUData* cpu_;
        ::manta::proto::MemoryData* memory_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class ServerConfig final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.ServerConfig) */ {
public:
    inline ServerConfig()
        : ServerConfig(nullptr)
    {
    }
    ~ServerConfig() override;
    explicit PROTOBUF_CONSTEXPR ServerConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ServerConfig(const ServerConfig& from);
    ServerConfig(ServerConfig&& from) noexcept
        : ServerConfig()
    {
        *this = ::std::move(from);
    }

    inline ServerConfig& operator=(const ServerConfig& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ServerConfig& operator=(ServerConfig&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ServerConfig& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ServerConfig* internal_default_instance()
    {
        return reinterpret_cast<const ServerConfig*>(&_ServerConfig_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(ServerConfig& a, ServerConfig& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ServerConfig* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ServerConfig* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ServerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ServerConfig>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ServerConfig& from);
    void MergeFrom(const ServerConfig& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ServerConfig* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.ServerConfig";
    }

protected:
    explicit ServerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kServerUrlFieldNumber = 1,
    };
    // optional string server_url = 1;
    bool has_server_url() const;

private:
    bool _internal_has_server_url() const;

public:
    void clear_server_url();
    const std::string& server_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_server_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_server_url();
    PROTOBUF_NODISCARD std::string* release_server_url();
    void set_allocated_server_url(std::string* server_url);

private:
    const std::string& _internal_server_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_url(const std::string& value);
    std::string* _internal_mutable_server_url();

public:
    // @@protoc_insertion_point(class_scope:manta.proto.ServerConfig)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_url_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class SettingsValue final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.SettingsValue) */ {
public:
    inline SettingsValue()
        : SettingsValue(nullptr)
    {
    }
    ~SettingsValue() override;
    explicit PROTOBUF_CONSTEXPR SettingsValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SettingsValue(const SettingsValue& from);
    SettingsValue(SettingsValue&& from) noexcept
        : SettingsValue()
    {
        *this = ::std::move(from);
    }

    inline SettingsValue& operator=(const SettingsValue& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SettingsValue& operator=(SettingsValue&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SettingsValue& default_instance()
    {
        return *internal_default_instance();
    }
    enum SettingsValueCase {
        kBoolVal = 1,
        kTextVal = 2,
        kDoubleVal = 3,
        kIntVal = 4,
        SETTINGS_VALUE_NOT_SET = 0,
    };

    static inline const SettingsValue* internal_default_instance()
    {
        return reinterpret_cast<const SettingsValue*>(&_SettingsValue_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(SettingsValue& a, SettingsValue& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SettingsValue* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SettingsValue* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SettingsValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SettingsValue>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SettingsValue& from);
    void MergeFrom(const SettingsValue& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SettingsValue* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.SettingsValue";
    }

protected:
    explicit SettingsValue(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kBoolValFieldNumber = 1,
        kTextValFieldNumber = 2,
        kDoubleValFieldNumber = 3,
        kIntValFieldNumber = 4,
    };
    // bool bool_val = 1;
    bool has_bool_val() const;

private:
    bool _internal_has_bool_val() const;

public:
    void clear_bool_val();
    bool bool_val() const;
    void set_bool_val(bool value);

private:
    bool _internal_bool_val() const;
    void _internal_set_bool_val(bool value);

public:
    // string text_val = 2;
    bool has_text_val() const;

private:
    bool _internal_has_text_val() const;

public:
    void clear_text_val();
    const std::string& text_val() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_text_val(ArgT0&& arg0, ArgT... args);
    std::string* mutable_text_val();
    PROTOBUF_NODISCARD std::string* release_text_val();
    void set_allocated_text_val(std::string* text_val);

private:
    const std::string& _internal_text_val() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_val(const std::string& value);
    std::string* _internal_mutable_text_val();

public:
    // double double_val = 3;
    bool has_double_val() const;

private:
    bool _internal_has_double_val() const;

public:
    void clear_double_val();
    double double_val() const;
    void set_double_val(double value);

private:
    double _internal_double_val() const;
    void _internal_set_double_val(double value);

public:
    // int32 int_val = 4;
    bool has_int_val() const;

private:
    bool _internal_has_int_val() const;

public:
    void clear_int_val();
    int32_t int_val() const;
    void set_int_val(int32_t value);

private:
    int32_t _internal_int_val() const;
    void _internal_set_int_val(int32_t value);

public:
    void clear_settings_value();
    SettingsValueCase settings_value_case() const;
    // @@protoc_insertion_point(class_scope:manta.proto.SettingsValue)
private:
    class _Internal;
    void set_has_bool_val();
    void set_has_text_val();
    void set_has_double_val();
    void set_has_int_val();

    inline bool has_settings_value() const;
    inline void clear_has_settings_value();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        union SettingsValueUnion {
            constexpr SettingsValueUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            bool bool_val_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_val_;
            double double_val_;
            int32_t int_val_;
        } settings_value_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class Setting final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.Setting) */ {
public:
    inline Setting()
        : Setting(nullptr)
    {
    }
    ~Setting() override;
    explicit PROTOBUF_CONSTEXPR Setting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Setting(const Setting& from);
    Setting(Setting&& from) noexcept
        : Setting()
    {
        *this = ::std::move(from);
    }

    inline Setting& operator=(const Setting& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Setting& operator=(Setting&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Setting& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Setting* internal_default_instance()
    {
        return reinterpret_cast<const Setting*>(&_Setting_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(Setting& a, Setting& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Setting* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Setting* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Setting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Setting>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Setting& from);
    void MergeFrom(const Setting& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Setting* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.Setting";
    }

protected:
    explicit Setting(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSettingsIdFieldNumber = 1,
        kValueFieldNumber = 2,
        kTypeFieldNumber = 3,
    };
    // string settings_id = 1;
    void clear_settings_id();
    const std::string& settings_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_settings_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_settings_id();
    PROTOBUF_NODISCARD std::string* release_settings_id();
    void set_allocated_settings_id(std::string* settings_id);

private:
    const std::string& _internal_settings_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_settings_id(const std::string& value);
    std::string* _internal_mutable_settings_id();

public:
    // .manta.proto.SettingsValue value = 2;
    bool has_value() const;

private:
    bool _internal_has_value() const;

public:
    void clear_value();
    const ::manta::proto::SettingsValue& value() const;
    PROTOBUF_NODISCARD ::manta::proto::SettingsValue* release_value();
    ::manta::proto::SettingsValue* mutable_value();
    void set_allocated_value(::manta::proto::SettingsValue* value);

private:
    const ::manta::proto::SettingsValue& _internal_value() const;
    ::manta::proto::SettingsValue* _internal_mutable_value();

public:
    void unsafe_arena_set_allocated_value(::manta::proto::SettingsValue* value);
    ::manta::proto::SettingsValue* unsafe_arena_release_value();

    // .manta.proto.SettingType type = 3;
    void clear_type();
    ::manta::proto::SettingType type() const;
    void set_type(::manta::proto::SettingType value);

private:
    ::manta::proto::SettingType _internal_type() const;
    void _internal_set_type(::manta::proto::SettingType value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.Setting)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr settings_id_;
        ::manta::proto::SettingsValue* value_;
        int type_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class SettingsData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.SettingsData) */ {
public:
    inline SettingsData()
        : SettingsData(nullptr)
    {
    }
    ~SettingsData() override;
    explicit PROTOBUF_CONSTEXPR SettingsData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SettingsData(const SettingsData& from);
    SettingsData(SettingsData&& from) noexcept
        : SettingsData()
    {
        *this = ::std::move(from);
    }

    inline SettingsData& operator=(const SettingsData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SettingsData& operator=(SettingsData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SettingsData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SettingsData* internal_default_instance()
    {
        return reinterpret_cast<const SettingsData*>(&_SettingsData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(SettingsData& a, SettingsData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SettingsData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SettingsData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SettingsData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SettingsData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SettingsData& from);
    void MergeFrom(const SettingsData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SettingsData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.SettingsData";
    }

protected:
    explicit SettingsData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSettingFieldNumber = 1,
    };
    // repeated .manta.proto.Setting setting = 1;
    int setting_size() const;

private:
    int _internal_setting_size() const;

public:
    void clear_setting();
    ::manta::proto::Setting* mutable_setting(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Setting>* mutable_setting();

private:
    const ::manta::proto::Setting& _internal_setting(int index) const;
    ::manta::proto::Setting* _internal_add_setting();

public:
    const ::manta::proto::Setting& setting(int index) const;
    ::manta::proto::Setting* add_setting();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Setting>& setting() const;

    // @@protoc_insertion_point(class_scope:manta.proto.SettingsData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Setting> setting_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class App final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.App) */ {
public:
    inline App()
        : App(nullptr)
    {
    }
    ~App() override;
    explicit PROTOBUF_CONSTEXPR App(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    App(const App& from);
    App(App&& from) noexcept
        : App()
    {
        *this = ::std::move(from);
    }

    inline App& operator=(const App& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline App& operator=(App&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const App& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const App* internal_default_instance()
    {
        return reinterpret_cast<const App*>(&_App_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(App& a, App& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(App* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(App* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    App* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<App>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const App& from);
    void MergeFrom(const App& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(App* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.App";
    }

protected:
    explicit App(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSearchableTermFieldNumber = 3,
        kIdFieldNumber = 1,
        kNameFieldNumber = 2,
    };
    // repeated string searchable_term = 3;
    int searchable_term_size() const;

private:
    int _internal_searchable_term_size() const;

public:
    void clear_searchable_term();
    const std::string& searchable_term(int index) const;
    std::string* mutable_searchable_term(int index);
    void set_searchable_term(int index, const std::string& value);
    void set_searchable_term(int index, std::string&& value);
    void set_searchable_term(int index, const char* value);
    void set_searchable_term(int index, const char* value, size_t size);
    std::string* add_searchable_term();
    void add_searchable_term(const std::string& value);
    void add_searchable_term(std::string&& value);
    void add_searchable_term(const char* value);
    void add_searchable_term(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& searchable_term() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_searchable_term();

private:
    const std::string& _internal_searchable_term(int index) const;
    std::string* _internal_add_searchable_term();

public:
    // string id = 1;
    void clear_id();
    const std::string& id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_id();
    PROTOBUF_NODISCARD std::string* release_id();
    void set_allocated_id(std::string* id);

private:
    const std::string& _internal_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
    std::string* _internal_mutable_id();

public:
    // string name = 2;
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // @@protoc_insertion_point(class_scope:manta.proto.App)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> searchable_term_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class AppsData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.AppsData) */ {
public:
    inline AppsData()
        : AppsData(nullptr)
    {
    }
    ~AppsData() override;
    explicit PROTOBUF_CONSTEXPR AppsData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AppsData(const AppsData& from);
    AppsData(AppsData&& from) noexcept
        : AppsData()
    {
        *this = ::std::move(from);
    }

    inline AppsData& operator=(const AppsData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AppsData& operator=(AppsData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const AppsData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AppsData* internal_default_instance()
    {
        return reinterpret_cast<const AppsData*>(&_AppsData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 10;

    friend void swap(AppsData& a, AppsData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AppsData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AppsData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AppsData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AppsData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AppsData& from);
    void MergeFrom(const AppsData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AppsData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.AppsData";
    }

protected:
    explicit AppsData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kAppFieldNumber = 1,
    };
    // repeated .manta.proto.App app = 1;
    int app_size() const;

private:
    int _internal_app_size() const;

public:
    void clear_app();
    ::manta::proto::App* mutable_app(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::App>* mutable_app();

private:
    const ::manta::proto::App& _internal_app(int index) const;
    ::manta::proto::App* _internal_add_app();

public:
    const ::manta::proto::App& app(int index) const;
    ::manta::proto::App* add_app();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::App>& app() const;

    // @@protoc_insertion_point(class_scope:manta.proto.AppsData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::App> app_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class TextEntry final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.TextEntry) */ {
public:
    inline TextEntry()
        : TextEntry(nullptr)
    {
    }
    ~TextEntry() override;
    explicit PROTOBUF_CONSTEXPR TextEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TextEntry(const TextEntry& from);
    TextEntry(TextEntry&& from) noexcept
        : TextEntry()
    {
        *this = ::std::move(from);
    }

    inline TextEntry& operator=(const TextEntry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TextEntry& operator=(TextEntry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const TextEntry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const TextEntry* internal_default_instance()
    {
        return reinterpret_cast<const TextEntry*>(&_TextEntry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 11;

    friend void swap(TextEntry& a, TextEntry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TextEntry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TextEntry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TextEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TextEntry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TextEntry& from);
    void MergeFrom(const TextEntry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TextEntry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.TextEntry";
    }

protected:
    explicit TextEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTextFieldNumber = 1,
    };
    // optional string text = 1;
    bool has_text() const;

private:
    bool _internal_has_text() const;

public:
    void clear_text();
    const std::string& text() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_text(ArgT0&& arg0, ArgT... args);
    std::string* mutable_text();
    PROTOBUF_NODISCARD std::string* release_text();
    void set_allocated_text(std::string* text);

private:
    const std::string& _internal_text() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
    std::string* _internal_mutable_text();

public:
    // @@protoc_insertion_point(class_scope:manta.proto.TextEntry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class KeyPress final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.KeyPress) */ {
public:
    inline KeyPress()
        : KeyPress(nullptr)
    {
    }
    ~KeyPress() override;
    explicit PROTOBUF_CONSTEXPR KeyPress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    KeyPress(const KeyPress& from);
    KeyPress(KeyPress&& from) noexcept
        : KeyPress()
    {
        *this = ::std::move(from);
    }

    inline KeyPress& operator=(const KeyPress& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline KeyPress& operator=(KeyPress&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const KeyPress& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const KeyPress* internal_default_instance()
    {
        return reinterpret_cast<const KeyPress*>(&_KeyPress_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 12;

    friend void swap(KeyPress& a, KeyPress& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(KeyPress* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(KeyPress* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    KeyPress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<KeyPress>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const KeyPress& from);
    void MergeFrom(const KeyPress& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(KeyPress* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.KeyPress";
    }

protected:
    explicit KeyPress(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kKeyFieldNumber = 1,
        kControlFieldNumber = 2,
        kAltFieldNumber = 3,
        kShiftFieldNumber = 4,
    };
    // optional string key = 1;
    bool has_key() const;

private:
    bool _internal_has_key() const;

public:
    void clear_key();
    const std::string& key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_key();
    PROTOBUF_NODISCARD std::string* release_key();
    void set_allocated_key(std::string* key);

private:
    const std::string& _internal_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
    std::string* _internal_mutable_key();

public:
    // optional bool control = 2;
    bool has_control() const;

private:
    bool _internal_has_control() const;

public:
    void clear_control();
    bool control() const;
    void set_control(bool value);

private:
    bool _internal_control() const;
    void _internal_set_control(bool value);

public:
    // optional bool alt = 3;
    bool has_alt() const;

private:
    bool _internal_has_alt() const;

public:
    void clear_alt();
    bool alt() const;
    void set_alt(bool value);

private:
    bool _internal_alt() const;
    void _internal_set_alt(bool value);

public:
    // optional bool shift = 4;
    bool has_shift() const;

private:
    bool _internal_has_shift() const;

public:
    void clear_shift();
    bool shift() const;
    void set_shift(bool value);

private:
    bool _internal_shift() const;
    void _internal_set_shift(bool value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.KeyPress)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
        bool control_;
        bool alt_;
        bool shift_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class Click final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.Click) */ {
public:
    inline Click()
        : Click(nullptr)
    {
    }
    ~Click() override;
    explicit PROTOBUF_CONSTEXPR Click(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Click(const Click& from);
    Click(Click&& from) noexcept
        : Click()
    {
        *this = ::std::move(from);
    }

    inline Click& operator=(const Click& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Click& operator=(Click&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Click& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Click* internal_default_instance()
    {
        return reinterpret_cast<const Click*>(&_Click_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 13;

    friend void swap(Click& a, Click& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Click* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Click* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Click* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Click>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Click& from);
    void MergeFrom(const Click& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Click* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.Click";
    }

protected:
    explicit Click(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef Click_Button Button;
    static constexpr Button UNSPECIFIED = Click_Button_UNSPECIFIED;
    static constexpr Button LEFT = Click_Button_LEFT;
    static constexpr Button RIGHT = Click_Button_RIGHT;
    static constexpr Button MIDDLE = Click_Button_MIDDLE;
    static inline bool Button_IsValid(int value)
    {
        return Click_Button_IsValid(value);
    }
    static constexpr Button Button_MIN = Click_Button_Button_MIN;
    static constexpr Button Button_MAX = Click_Button_Button_MAX;
    static constexpr int Button_ARRAYSIZE = Click_Button_Button_ARRAYSIZE;
    template <typename T> static inline const std::string& Button_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Button>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Button_Name.");
        return Click_Button_Name(enum_t_value);
    }
    static inline bool Button_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Button* value)
    {
        return Click_Button_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kXPosFieldNumber = 1,
        kYPosFieldNumber = 2,
        kButtonFieldNumber = 3,
    };
    // optional int32 x_pos = 1;
    bool has_x_pos() const;

private:
    bool _internal_has_x_pos() const;

public:
    void clear_x_pos();
    int32_t x_pos() const;
    void set_x_pos(int32_t value);

private:
    int32_t _internal_x_pos() const;
    void _internal_set_x_pos(int32_t value);

public:
    // optional int32 y_pos = 2;
    bool has_y_pos() const;

private:
    bool _internal_has_y_pos() const;

public:
    void clear_y_pos();
    int32_t y_pos() const;
    void set_y_pos(int32_t value);

private:
    int32_t _internal_y_pos() const;
    void _internal_set_y_pos(int32_t value);

public:
    // optional .manta.proto.Click.Button button = 3;
    bool has_button() const;

private:
    bool _internal_has_button() const;

public:
    void clear_button();
    ::manta::proto::Click_Button button() const;
    void set_button(::manta::proto::Click_Button value);

private:
    ::manta::proto::Click_Button _internal_button() const;
    void _internal_set_button(::manta::proto::Click_Button value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.Click)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int32_t x_pos_;
        int32_t y_pos_;
        int button_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class Scroll final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.Scroll) */ {
public:
    inline Scroll()
        : Scroll(nullptr)
    {
    }
    ~Scroll() override;
    explicit PROTOBUF_CONSTEXPR Scroll(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Scroll(const Scroll& from);
    Scroll(Scroll&& from) noexcept
        : Scroll()
    {
        *this = ::std::move(from);
    }

    inline Scroll& operator=(const Scroll& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Scroll& operator=(Scroll&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Scroll& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Scroll* internal_default_instance()
    {
        return reinterpret_cast<const Scroll*>(&_Scroll_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 14;

    friend void swap(Scroll& a, Scroll& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Scroll* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Scroll* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Scroll* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Scroll>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Scroll& from);
    void MergeFrom(const Scroll& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Scroll* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.Scroll";
    }

protected:
    explicit Scroll(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef Scroll_Direction Direction;
    static constexpr Direction UNSPECIFIED = Scroll_Direction_UNSPECIFIED;
    static constexpr Direction UP = Scroll_Direction_UP;
    static constexpr Direction DOWN = Scroll_Direction_DOWN;
    static constexpr Direction LEFT = Scroll_Direction_LEFT;
    static constexpr Direction RIGHT = Scroll_Direction_RIGHT;
    static inline bool Direction_IsValid(int value)
    {
        return Scroll_Direction_IsValid(value);
    }
    static constexpr Direction Direction_MIN = Scroll_Direction_Direction_MIN;
    static constexpr Direction Direction_MAX = Scroll_Direction_Direction_MAX;
    static constexpr int Direction_ARRAYSIZE = Scroll_Direction_Direction_ARRAYSIZE;
    template <typename T> static inline const std::string& Direction_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Direction>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Direction_Name.");
        return Scroll_Direction_Name(enum_t_value);
    }
    static inline bool Direction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Direction* value)
    {
        return Scroll_Direction_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kDirectionFieldNumber = 1,
        kDistanceFieldNumber = 2,
    };
    // optional .manta.proto.Scroll.Direction direction = 1;
    bool has_direction() const;

private:
    bool _internal_has_direction() const;

public:
    void clear_direction();
    ::manta::proto::Scroll_Direction direction() const;
    void set_direction(::manta::proto::Scroll_Direction value);

private:
    ::manta::proto::Scroll_Direction _internal_direction() const;
    void _internal_set_direction(::manta::proto::Scroll_Direction value);

public:
    // optional int32 distance = 2;
    bool has_distance() const;

private:
    bool _internal_has_distance() const;

public:
    void clear_distance();
    int32_t distance() const;
    void set_distance(int32_t value);

private:
    int32_t _internal_distance() const;
    void _internal_set_distance(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.Scroll)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int direction_;
        int32_t distance_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class LaunchFile final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.LaunchFile) */ {
public:
    inline LaunchFile()
        : LaunchFile(nullptr)
    {
    }
    ~LaunchFile() override;
    explicit PROTOBUF_CONSTEXPR LaunchFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    LaunchFile(const LaunchFile& from);
    LaunchFile(LaunchFile&& from) noexcept
        : LaunchFile()
    {
        *this = ::std::move(from);
    }

    inline LaunchFile& operator=(const LaunchFile& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline LaunchFile& operator=(LaunchFile&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const LaunchFile& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const LaunchFile* internal_default_instance()
    {
        return reinterpret_cast<const LaunchFile*>(&_LaunchFile_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 15;

    friend void swap(LaunchFile& a, LaunchFile& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(LaunchFile* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(LaunchFile* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    LaunchFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<LaunchFile>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const LaunchFile& from);
    void MergeFrom(const LaunchFile& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(LaunchFile* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.LaunchFile";
    }

protected:
    explicit LaunchFile(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kLaunchFilePathFieldNumber = 1,
    };
    // optional string launch_file_path = 1;
    bool has_launch_file_path() const;

private:
    bool _internal_has_launch_file_path() const;

public:
    void clear_launch_file_path();
    const std::string& launch_file_path() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_launch_file_path(ArgT0&& arg0, ArgT... args);
    std::string* mutable_launch_file_path();
    PROTOBUF_NODISCARD std::string* release_launch_file_path();
    void set_allocated_launch_file_path(std::string* launch_file_path);

private:
    const std::string& _internal_launch_file_path() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_launch_file_path(const std::string& value);
    std::string* _internal_mutable_launch_file_path();

public:
    // @@protoc_insertion_point(class_scope:manta.proto.LaunchFile)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr launch_file_path_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class WriteFile final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.WriteFile) */ {
public:
    inline WriteFile()
        : WriteFile(nullptr)
    {
    }
    ~WriteFile() override;
    explicit PROTOBUF_CONSTEXPR WriteFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    WriteFile(const WriteFile& from);
    WriteFile(WriteFile&& from) noexcept
        : WriteFile()
    {
        *this = ::std::move(from);
    }

    inline WriteFile& operator=(const WriteFile& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline WriteFile& operator=(WriteFile&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const WriteFile& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const WriteFile* internal_default_instance()
    {
        return reinterpret_cast<const WriteFile*>(&_WriteFile_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 16;

    friend void swap(WriteFile& a, WriteFile& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(WriteFile* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(WriteFile* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    WriteFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<WriteFile>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const WriteFile& from);
    void MergeFrom(const WriteFile& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(WriteFile* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.WriteFile";
    }

protected:
    explicit WriteFile(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kNameFieldNumber = 1,
        kFileBytesFieldNumber = 2,
    };
    // optional string name = 1;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // optional string file_bytes = 2;
    bool has_file_bytes() const;

private:
    bool _internal_has_file_bytes() const;

public:
    void clear_file_bytes();
    const std::string& file_bytes() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_file_bytes(ArgT0&& arg0, ArgT... args);
    std::string* mutable_file_bytes();
    PROTOBUF_NODISCARD std::string* release_file_bytes();
    void set_allocated_file_bytes(std::string* file_bytes);

private:
    const std::string& _internal_file_bytes() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_bytes(const std::string& value);
    std::string* _internal_mutable_file_bytes();

public:
    // @@protoc_insertion_point(class_scope:manta.proto.WriteFile)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_bytes_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class Action final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.Action) */ {
public:
    inline Action()
        : Action(nullptr)
    {
    }
    ~Action() override;
    explicit PROTOBUF_CONSTEXPR Action(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Action(const Action& from);
    Action(Action&& from) noexcept
        : Action()
    {
        *this = ::std::move(from);
    }

    inline Action& operator=(const Action& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Action& operator=(Action&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Action& default_instance()
    {
        return *internal_default_instance();
    }
    enum ActionCase {
        kUpdateSetting = 1,
        kLaunchAppId = 2,
        kClick = 3,
        kTextEntry = 4,
        kAllDone = 5,
        kLaunchFile = 6,
        kKeyPress = 7,
        kScroll = 8,
        kWriteFile = 9,
        ACTION_NOT_SET = 0,
    };

    static inline const Action* internal_default_instance()
    {
        return reinterpret_cast<const Action*>(&_Action_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 17;

    friend void swap(Action& a, Action& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Action* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Action* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Action>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Action& from);
    void MergeFrom(const Action& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Action* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.Action";
    }

protected:
    explicit Action(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUpdateSettingFieldNumber = 1,
        kLaunchAppIdFieldNumber = 2,
        kClickFieldNumber = 3,
        kTextEntryFieldNumber = 4,
        kAllDoneFieldNumber = 5,
        kLaunchFileFieldNumber = 6,
        kKeyPressFieldNumber = 7,
        kScrollFieldNumber = 8,
        kWriteFileFieldNumber = 9,
    };
    // .manta.proto.Setting update_setting = 1;
    bool has_update_setting() const;

private:
    bool _internal_has_update_setting() const;

public:
    void clear_update_setting();
    const ::manta::proto::Setting& update_setting() const;
    PROTOBUF_NODISCARD ::manta::proto::Setting* release_update_setting();
    ::manta::proto::Setting* mutable_update_setting();
    void set_allocated_update_setting(::manta::proto::Setting* update_setting);

private:
    const ::manta::proto::Setting& _internal_update_setting() const;
    ::manta::proto::Setting* _internal_mutable_update_setting();

public:
    void unsafe_arena_set_allocated_update_setting(::manta::proto::Setting* update_setting);
    ::manta::proto::Setting* unsafe_arena_release_update_setting();

    // string launch_app_id = 2;
    bool has_launch_app_id() const;

private:
    bool _internal_has_launch_app_id() const;

public:
    void clear_launch_app_id();
    const std::string& launch_app_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_launch_app_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_launch_app_id();
    PROTOBUF_NODISCARD std::string* release_launch_app_id();
    void set_allocated_launch_app_id(std::string* launch_app_id);

private:
    const std::string& _internal_launch_app_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_launch_app_id(const std::string& value);
    std::string* _internal_mutable_launch_app_id();

public:
    // .manta.proto.Click click = 3;
    bool has_click() const;

private:
    bool _internal_has_click() const;

public:
    void clear_click();
    const ::manta::proto::Click& click() const;
    PROTOBUF_NODISCARD ::manta::proto::Click* release_click();
    ::manta::proto::Click* mutable_click();
    void set_allocated_click(::manta::proto::Click* click);

private:
    const ::manta::proto::Click& _internal_click() const;
    ::manta::proto::Click* _internal_mutable_click();

public:
    void unsafe_arena_set_allocated_click(::manta::proto::Click* click);
    ::manta::proto::Click* unsafe_arena_release_click();

    // .manta.proto.TextEntry text_entry = 4;
    bool has_text_entry() const;

private:
    bool _internal_has_text_entry() const;

public:
    void clear_text_entry();
    const ::manta::proto::TextEntry& text_entry() const;
    PROTOBUF_NODISCARD ::manta::proto::TextEntry* release_text_entry();
    ::manta::proto::TextEntry* mutable_text_entry();
    void set_allocated_text_entry(::manta::proto::TextEntry* text_entry);

private:
    const ::manta::proto::TextEntry& _internal_text_entry() const;
    ::manta::proto::TextEntry* _internal_mutable_text_entry();

public:
    void unsafe_arena_set_allocated_text_entry(::manta::proto::TextEntry* text_entry);
    ::manta::proto::TextEntry* unsafe_arena_release_text_entry();

    // bool all_done = 5;
    bool has_all_done() const;

private:
    bool _internal_has_all_done() const;

public:
    void clear_all_done();
    bool all_done() const;
    void set_all_done(bool value);

private:
    bool _internal_all_done() const;
    void _internal_set_all_done(bool value);

public:
    // .manta.proto.LaunchFile launch_file = 6;
    bool has_launch_file() const;

private:
    bool _internal_has_launch_file() const;

public:
    void clear_launch_file();
    const ::manta::proto::LaunchFile& launch_file() const;
    PROTOBUF_NODISCARD ::manta::proto::LaunchFile* release_launch_file();
    ::manta::proto::LaunchFile* mutable_launch_file();
    void set_allocated_launch_file(::manta::proto::LaunchFile* launch_file);

private:
    const ::manta::proto::LaunchFile& _internal_launch_file() const;
    ::manta::proto::LaunchFile* _internal_mutable_launch_file();

public:
    void unsafe_arena_set_allocated_launch_file(::manta::proto::LaunchFile* launch_file);
    ::manta::proto::LaunchFile* unsafe_arena_release_launch_file();

    // .manta.proto.KeyPress key_press = 7;
    bool has_key_press() const;

private:
    bool _internal_has_key_press() const;

public:
    void clear_key_press();
    const ::manta::proto::KeyPress& key_press() const;
    PROTOBUF_NODISCARD ::manta::proto::KeyPress* release_key_press();
    ::manta::proto::KeyPress* mutable_key_press();
    void set_allocated_key_press(::manta::proto::KeyPress* key_press);

private:
    const ::manta::proto::KeyPress& _internal_key_press() const;
    ::manta::proto::KeyPress* _internal_mutable_key_press();

public:
    void unsafe_arena_set_allocated_key_press(::manta::proto::KeyPress* key_press);
    ::manta::proto::KeyPress* unsafe_arena_release_key_press();

    // .manta.proto.Scroll scroll = 8;
    bool has_scroll() const;

private:
    bool _internal_has_scroll() const;

public:
    void clear_scroll();
    const ::manta::proto::Scroll& scroll() const;
    PROTOBUF_NODISCARD ::manta::proto::Scroll* release_scroll();
    ::manta::proto::Scroll* mutable_scroll();
    void set_allocated_scroll(::manta::proto::Scroll* scroll);

private:
    const ::manta::proto::Scroll& _internal_scroll() const;
    ::manta::proto::Scroll* _internal_mutable_scroll();

public:
    void unsafe_arena_set_allocated_scroll(::manta::proto::Scroll* scroll);
    ::manta::proto::Scroll* unsafe_arena_release_scroll();

    // .manta.proto.WriteFile write_file = 9;
    bool has_write_file() const;

private:
    bool _internal_has_write_file() const;

public:
    void clear_write_file();
    const ::manta::proto::WriteFile& write_file() const;
    PROTOBUF_NODISCARD ::manta::proto::WriteFile* release_write_file();
    ::manta::proto::WriteFile* mutable_write_file();
    void set_allocated_write_file(::manta::proto::WriteFile* write_file);

private:
    const ::manta::proto::WriteFile& _internal_write_file() const;
    ::manta::proto::WriteFile* _internal_mutable_write_file();

public:
    void unsafe_arena_set_allocated_write_file(::manta::proto::WriteFile* write_file);
    ::manta::proto::WriteFile* unsafe_arena_release_write_file();

    void clear_action();
    ActionCase action_case() const;
    // @@protoc_insertion_point(class_scope:manta.proto.Action)
private:
    class _Internal;
    void set_has_update_setting();
    void set_has_launch_app_id();
    void set_has_click();
    void set_has_text_entry();
    void set_has_all_done();
    void set_has_launch_file();
    void set_has_key_press();
    void set_has_scroll();
    void set_has_write_file();

    inline bool has_action() const;
    inline void clear_has_action();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        union ActionUnion {
            constexpr ActionUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::manta::proto::Setting* update_setting_;
            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr launch_app_id_;
            ::manta::proto::Click* click_;
            ::manta::proto::TextEntry* text_entry_;
            bool all_done_;
            ::manta::proto::LaunchFile* launch_file_;
            ::manta::proto::KeyPress* key_press_;
            ::manta::proto::Scroll* scroll_;
            ::manta::proto::WriteFile* write_file_;
        } action_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class DiagnosticsRequest final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.DiagnosticsRequest) */ {
public:
    inline DiagnosticsRequest()
        : DiagnosticsRequest(nullptr)
    {
    }
    ~DiagnosticsRequest() override;
    explicit PROTOBUF_CONSTEXPR DiagnosticsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    DiagnosticsRequest(const DiagnosticsRequest& from);
    DiagnosticsRequest(DiagnosticsRequest&& from) noexcept
        : DiagnosticsRequest()
    {
        *this = ::std::move(from);
    }

    inline DiagnosticsRequest& operator=(const DiagnosticsRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DiagnosticsRequest& operator=(DiagnosticsRequest&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const DiagnosticsRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DiagnosticsRequest* internal_default_instance()
    {
        return reinterpret_cast<const DiagnosticsRequest*>(&_DiagnosticsRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 18;

    friend void swap(DiagnosticsRequest& a, DiagnosticsRequest& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(DiagnosticsRequest* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DiagnosticsRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DiagnosticsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<DiagnosticsRequest>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const DiagnosticsRequest& from);
    void MergeFrom(const DiagnosticsRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DiagnosticsRequest* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.DiagnosticsRequest";
    }

protected:
    explicit DiagnosticsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDiagnosticsFieldNumber = 1,
    };
    // repeated .manta.proto.Diagnostics diagnostics = 1;
    int diagnostics_size() const;

private:
    int _internal_diagnostics_size() const;

public:
    void clear_diagnostics();

private:
    ::manta::proto::Diagnostics _internal_diagnostics(int index) const;
    void _internal_add_diagnostics(::manta::proto::Diagnostics value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_diagnostics();

public:
    ::manta::proto::Diagnostics diagnostics(int index) const;
    void set_diagnostics(int index, ::manta::proto::Diagnostics value);
    void add_diagnostics(::manta::proto::Diagnostics value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& diagnostics() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_diagnostics();

    // @@protoc_insertion_point(class_scope:manta.proto.DiagnosticsRequest)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> diagnostics_;
        mutable std::atomic<int> _diagnostics_cached_byte_size_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class SettingsDataRequest final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.SettingsDataRequest) */ {
public:
    inline SettingsDataRequest()
        : SettingsDataRequest(nullptr)
    {
    }
    ~SettingsDataRequest() override;
    explicit PROTOBUF_CONSTEXPR SettingsDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SettingsDataRequest(const SettingsDataRequest& from);
    SettingsDataRequest(SettingsDataRequest&& from) noexcept
        : SettingsDataRequest()
    {
        *this = ::std::move(from);
    }

    inline SettingsDataRequest& operator=(const SettingsDataRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SettingsDataRequest& operator=(SettingsDataRequest&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SettingsDataRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SettingsDataRequest* internal_default_instance()
    {
        return reinterpret_cast<const SettingsDataRequest*>(&_SettingsDataRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 19;

    friend void swap(SettingsDataRequest& a, SettingsDataRequest& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SettingsDataRequest* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SettingsDataRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SettingsDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SettingsDataRequest>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SettingsDataRequest& from);
    void MergeFrom(const SettingsDataRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SettingsDataRequest* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.SettingsDataRequest";
    }

protected:
    explicit SettingsDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:manta.proto.SettingsDataRequest)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class FileRequest final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.FileRequest) */ {
public:
    inline FileRequest()
        : FileRequest(nullptr)
    {
    }
    ~FileRequest() override;
    explicit PROTOBUF_CONSTEXPR FileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FileRequest(const FileRequest& from);
    FileRequest(FileRequest&& from) noexcept
        : FileRequest()
    {
        *this = ::std::move(from);
    }

    inline FileRequest& operator=(const FileRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FileRequest& operator=(FileRequest&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const FileRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FileRequest* internal_default_instance()
    {
        return reinterpret_cast<const FileRequest*>(&_FileRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 20;

    friend void swap(FileRequest& a, FileRequest& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FileRequest* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FileRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FileRequest>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FileRequest& from);
    void MergeFrom(const FileRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FileRequest* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.FileRequest";
    }

protected:
    explicit FileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kPathsFieldNumber = 1,
    };
    // repeated string paths = 1;
    int paths_size() const;

private:
    int _internal_paths_size() const;

public:
    void clear_paths();
    const std::string& paths(int index) const;
    std::string* mutable_paths(int index);
    void set_paths(int index, const std::string& value);
    void set_paths(int index, std::string&& value);
    void set_paths(int index, const char* value);
    void set_paths(int index, const char* value, size_t size);
    std::string* add_paths();
    void add_paths(const std::string& value);
    void add_paths(std::string&& value);
    void add_paths(const char* value);
    void add_paths(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& paths() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_paths();

private:
    const std::string& _internal_paths(int index) const;
    std::string* _internal_add_paths();

public:
    // @@protoc_insertion_point(class_scope:manta.proto.FileRequest)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> paths_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class File final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.File) */ {
public:
    inline File()
        : File(nullptr)
    {
    }
    ~File() override;
    explicit PROTOBUF_CONSTEXPR File(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    File(const File& from);
    File(File&& from) noexcept
        : File()
    {
        *this = ::std::move(from);
    }

    inline File& operator=(const File& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline File& operator=(File&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const File& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const File* internal_default_instance()
    {
        return reinterpret_cast<const File*>(&_File_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 21;

    friend void swap(File& a, File& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(File* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(File* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    File* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<File>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const File& from);
    void MergeFrom(const File& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(File* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.File";
    }

protected:
    explicit File(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kPathFieldNumber = 1,
        kNameFieldNumber = 2,
        kDateModifiedFieldNumber = 4,
        kSerializedBytesFieldNumber = 5,
        kSummaryFieldNumber = 6,
        kSizeInBytesFieldNumber = 3,
    };
    // optional string path = 1;
    bool has_path() const;

private:
    bool _internal_has_path() const;

public:
    void clear_path();
    const std::string& path() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_path(ArgT0&& arg0, ArgT... args);
    std::string* mutable_path();
    PROTOBUF_NODISCARD std::string* release_path();
    void set_allocated_path(std::string* path);

private:
    const std::string& _internal_path() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
    std::string* _internal_mutable_path();

public:
    // optional string name = 2;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // optional string date_modified = 4;
    bool has_date_modified() const;

private:
    bool _internal_has_date_modified() const;

public:
    void clear_date_modified();
    const std::string& date_modified() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_date_modified(ArgT0&& arg0, ArgT... args);
    std::string* mutable_date_modified();
    PROTOBUF_NODISCARD std::string* release_date_modified();
    void set_allocated_date_modified(std::string* date_modified);

private:
    const std::string& _internal_date_modified() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_date_modified(const std::string& value);
    std::string* _internal_mutable_date_modified();

public:
    // optional bytes serialized_bytes = 5;
    bool has_serialized_bytes() const;

private:
    bool _internal_has_serialized_bytes() const;

public:
    void clear_serialized_bytes();
    const std::string& serialized_bytes() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_serialized_bytes(ArgT0&& arg0, ArgT... args);
    std::string* mutable_serialized_bytes();
    PROTOBUF_NODISCARD std::string* release_serialized_bytes();
    void set_allocated_serialized_bytes(std::string* serialized_bytes);

private:
    const std::string& _internal_serialized_bytes() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_bytes(const std::string& value);
    std::string* _internal_mutable_serialized_bytes();

public:
    // optional string summary = 6;
    bool has_summary() const;

private:
    bool _internal_has_summary() const;

public:
    void clear_summary();
    const std::string& summary() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_summary(ArgT0&& arg0, ArgT... args);
    std::string* mutable_summary();
    PROTOBUF_NODISCARD std::string* release_summary();
    void set_allocated_summary(std::string* summary);

private:
    const std::string& _internal_summary() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary(const std::string& value);
    std::string* _internal_mutable_summary();

public:
    // optional int64 size_in_bytes = 3;
    bool has_size_in_bytes() const;

private:
    bool _internal_has_size_in_bytes() const;

public:
    void clear_size_in_bytes();
    int64_t size_in_bytes() const;
    void set_size_in_bytes(int64_t value);

private:
    int64_t _internal_size_in_bytes() const;
    void _internal_set_size_in_bytes(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.File)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_modified_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_bytes_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr summary_;
        int64_t size_in_bytes_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class FilesData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.FilesData) */ {
public:
    inline FilesData()
        : FilesData(nullptr)
    {
    }
    ~FilesData() override;
    explicit PROTOBUF_CONSTEXPR FilesData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FilesData(const FilesData& from);
    FilesData(FilesData&& from) noexcept
        : FilesData()
    {
        *this = ::std::move(from);
    }

    inline FilesData& operator=(const FilesData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FilesData& operator=(FilesData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const FilesData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FilesData* internal_default_instance()
    {
        return reinterpret_cast<const FilesData*>(&_FilesData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 22;

    friend void swap(FilesData& a, FilesData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FilesData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FilesData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FilesData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FilesData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FilesData& from);
    void MergeFrom(const FilesData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FilesData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.FilesData";
    }

protected:
    explicit FilesData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFilesFieldNumber = 1,
    };
    // repeated .manta.proto.File files = 1;
    int files_size() const;

private:
    int _internal_files_size() const;

public:
    void clear_files();
    ::manta::proto::File* mutable_files(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::File>* mutable_files();

private:
    const ::manta::proto::File& _internal_files(int index) const;
    ::manta::proto::File* _internal_add_files();

public:
    const ::manta::proto::File& files(int index) const;
    ::manta::proto::File* add_files();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::File>& files() const;

    // @@protoc_insertion_point(class_scope:manta.proto.FilesData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::File> files_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class Update final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.Update) */ {
public:
    inline Update()
        : Update(nullptr)
    {
    }
    ~Update() override;
    explicit PROTOBUF_CONSTEXPR Update(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Update(const Update& from);
    Update(Update&& from) noexcept
        : Update()
    {
        *this = ::std::move(from);
    }

    inline Update& operator=(const Update& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Update& operator=(Update&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Update& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Update* internal_default_instance()
    {
        return reinterpret_cast<const Update*>(&_Update_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 23;

    friend void swap(Update& a, Update& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Update* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Update* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Update* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Update>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Update& from);
    void MergeFrom(const Update& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Update* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.Update";
    }

protected:
    explicit Update(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFilesWithSummaryFieldNumber = 1,
    };
    // optional .manta.proto.FilesData files_with_summary = 1;
    bool has_files_with_summary() const;

private:
    bool _internal_has_files_with_summary() const;

public:
    void clear_files_with_summary();
    const ::manta::proto::FilesData& files_with_summary() const;
    PROTOBUF_NODISCARD ::manta::proto::FilesData* release_files_with_summary();
    ::manta::proto::FilesData* mutable_files_with_summary();
    void set_allocated_files_with_summary(::manta::proto::FilesData* files_with_summary);

private:
    const ::manta::proto::FilesData& _internal_files_with_summary() const;
    ::manta::proto::FilesData* _internal_mutable_files_with_summary();

public:
    void unsafe_arena_set_allocated_files_with_summary(::manta::proto::FilesData* files_with_summary);
    ::manta::proto::FilesData* unsafe_arena_release_files_with_summary();

    // @@protoc_insertion_point(class_scope:manta.proto.Update)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::manta::proto::FilesData* files_with_summary_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class ContextRequest final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.ContextRequest) */ {
public:
    inline ContextRequest()
        : ContextRequest(nullptr)
    {
    }
    ~ContextRequest() override;
    explicit PROTOBUF_CONSTEXPR ContextRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ContextRequest(const ContextRequest& from);
    ContextRequest(ContextRequest&& from) noexcept
        : ContextRequest()
    {
        *this = ::std::move(from);
    }

    inline ContextRequest& operator=(const ContextRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ContextRequest& operator=(ContextRequest&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ContextRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ContextRequest* internal_default_instance()
    {
        return reinterpret_cast<const ContextRequest*>(&_ContextRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 24;

    friend void swap(ContextRequest& a, ContextRequest& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ContextRequest* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ContextRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ContextRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ContextRequest>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ContextRequest& from);
    void MergeFrom(const ContextRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ContextRequest* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.ContextRequest";
    }

protected:
    explicit ContextRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDiagnosticsFieldNumber = 1,
        kFilesFieldNumber = 2,
        kSettingsFieldNumber = 3,
    };
    // optional .manta.proto.DiagnosticsRequest diagnostics = 1;
    bool has_diagnostics() const;

private:
    bool _internal_has_diagnostics() const;

public:
    void clear_diagnostics();
    const ::manta::proto::DiagnosticsRequest& diagnostics() const;
    PROTOBUF_NODISCARD ::manta::proto::DiagnosticsRequest* release_diagnostics();
    ::manta::proto::DiagnosticsRequest* mutable_diagnostics();
    void set_allocated_diagnostics(::manta::proto::DiagnosticsRequest* diagnostics);

private:
    const ::manta::proto::DiagnosticsRequest& _internal_diagnostics() const;
    ::manta::proto::DiagnosticsRequest* _internal_mutable_diagnostics();

public:
    void unsafe_arena_set_allocated_diagnostics(::manta::proto::DiagnosticsRequest* diagnostics);
    ::manta::proto::DiagnosticsRequest* unsafe_arena_release_diagnostics();

    // optional .manta.proto.FileRequest files = 2;
    bool has_files() const;

private:
    bool _internal_has_files() const;

public:
    void clear_files();
    const ::manta::proto::FileRequest& files() const;
    PROTOBUF_NODISCARD ::manta::proto::FileRequest* release_files();
    ::manta::proto::FileRequest* mutable_files();
    void set_allocated_files(::manta::proto::FileRequest* files);

private:
    const ::manta::proto::FileRequest& _internal_files() const;
    ::manta::proto::FileRequest* _internal_mutable_files();

public:
    void unsafe_arena_set_allocated_files(::manta::proto::FileRequest* files);
    ::manta::proto::FileRequest* unsafe_arena_release_files();

    // optional .manta.proto.SettingsDataRequest settings = 3;
    bool has_settings() const;

private:
    bool _internal_has_settings() const;

public:
    void clear_settings();
    const ::manta::proto::SettingsDataRequest& settings() const;
    PROTOBUF_NODISCARD ::manta::proto::SettingsDataRequest* release_settings();
    ::manta::proto::SettingsDataRequest* mutable_settings();
    void set_allocated_settings(::manta::proto::SettingsDataRequest* settings);

private:
    const ::manta::proto::SettingsDataRequest& _internal_settings() const;
    ::manta::proto::SettingsDataRequest* _internal_mutable_settings();

public:
    void unsafe_arena_set_allocated_settings(::manta::proto::SettingsDataRequest* settings);
    ::manta::proto::SettingsDataRequest* unsafe_arena_release_settings();

    // @@protoc_insertion_point(class_scope:manta.proto.ContextRequest)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::manta::proto::DiagnosticsRequest* diagnostics_;
        ::manta::proto::FileRequest* files_;
        ::manta::proto::SettingsDataRequest* settings_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class Turn final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.Turn) */ {
public:
    inline Turn()
        : Turn(nullptr)
    {
    }
    ~Turn() override;
    explicit PROTOBUF_CONSTEXPR Turn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Turn(const Turn& from);
    Turn(Turn&& from) noexcept
        : Turn()
    {
        *this = ::std::move(from);
    }

    inline Turn& operator=(const Turn& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Turn& operator=(Turn&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Turn& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Turn* internal_default_instance()
    {
        return reinterpret_cast<const Turn*>(&_Turn_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 25;

    friend void swap(Turn& a, Turn& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Turn* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Turn* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Turn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Turn>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Turn& from);
    void MergeFrom(const Turn& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Turn* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.Turn";
    }

protected:
    explicit Turn(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kActionFieldNumber = 3,
        kMessageFieldNumber = 1,
        kScreenshotFieldNumber = 4,
        kRoleFieldNumber = 2,
    };
    // repeated .manta.proto.Action action = 3;
    int action_size() const;

private:
    int _internal_action_size() const;

public:
    void clear_action();
    ::manta::proto::Action* mutable_action(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Action>* mutable_action();

private:
    const ::manta::proto::Action& _internal_action(int index) const;
    ::manta::proto::Action* _internal_add_action();

public:
    const ::manta::proto::Action& action(int index) const;
    ::manta::proto::Action* add_action();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Action>& action() const;

    // optional string message = 1;
    bool has_message() const;

private:
    bool _internal_has_message() const;

public:
    void clear_message();
    const std::string& message() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_message(ArgT0&& arg0, ArgT... args);
    std::string* mutable_message();
    PROTOBUF_NODISCARD std::string* release_message();
    void set_allocated_message(std::string* message);

private:
    const std::string& _internal_message() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
    std::string* _internal_mutable_message();

public:
    // optional .manta.proto.Image screenshot = 4;
    bool has_screenshot() const;

private:
    bool _internal_has_screenshot() const;

public:
    void clear_screenshot();
    const ::manta::proto::Image& screenshot() const;
    PROTOBUF_NODISCARD ::manta::proto::Image* release_screenshot();
    ::manta::proto::Image* mutable_screenshot();
    void set_allocated_screenshot(::manta::proto::Image* screenshot);

private:
    const ::manta::proto::Image& _internal_screenshot() const;
    ::manta::proto::Image* _internal_mutable_screenshot();

public:
    void unsafe_arena_set_allocated_screenshot(::manta::proto::Image* screenshot);
    ::manta::proto::Image* unsafe_arena_release_screenshot();

    // optional .manta.proto.Role role = 2;
    bool has_role() const;

private:
    bool _internal_has_role() const;

public:
    void clear_role();
    ::manta::proto::Role role() const;
    void set_role(::manta::proto::Role value);

private:
    ::manta::proto::Role _internal_role() const;
    void _internal_set_role(::manta::proto::Role value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.Turn)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Action> action_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
        ::manta::proto::Image* screenshot_;
        int role_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class SparkyResponse final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.SparkyResponse) */ {
public:
    inline SparkyResponse()
        : SparkyResponse(nullptr)
    {
    }
    ~SparkyResponse() override;
    explicit PROTOBUF_CONSTEXPR SparkyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SparkyResponse(const SparkyResponse& from);
    SparkyResponse(SparkyResponse&& from) noexcept
        : SparkyResponse()
    {
        *this = ::std::move(from);
    }

    inline SparkyResponse& operator=(const SparkyResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SparkyResponse& operator=(SparkyResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SparkyResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SparkyResponse* internal_default_instance()
    {
        return reinterpret_cast<const SparkyResponse*>(&_SparkyResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 26;

    friend void swap(SparkyResponse& a, SparkyResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SparkyResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SparkyResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SparkyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SparkyResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SparkyResponse& from);
    void MergeFrom(const SparkyResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SparkyResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.SparkyResponse";
    }

protected:
    explicit SparkyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kContextRequestFieldNumber = 1,
        kLatestReplyFieldNumber = 2,
        kUpdateFieldNumber = 3,
    };
    // optional .manta.proto.ContextRequest context_request = 1;
    bool has_context_request() const;

private:
    bool _internal_has_context_request() const;

public:
    void clear_context_request();
    const ::manta::proto::ContextRequest& context_request() const;
    PROTOBUF_NODISCARD ::manta::proto::ContextRequest* release_context_request();
    ::manta::proto::ContextRequest* mutable_context_request();
    void set_allocated_context_request(::manta::proto::ContextRequest* context_request);

private:
    const ::manta::proto::ContextRequest& _internal_context_request() const;
    ::manta::proto::ContextRequest* _internal_mutable_context_request();

public:
    void unsafe_arena_set_allocated_context_request(::manta::proto::ContextRequest* context_request);
    ::manta::proto::ContextRequest* unsafe_arena_release_context_request();

    // optional .manta.proto.Turn latest_reply = 2;
    bool has_latest_reply() const;

private:
    bool _internal_has_latest_reply() const;

public:
    void clear_latest_reply();
    const ::manta::proto::Turn& latest_reply() const;
    PROTOBUF_NODISCARD ::manta::proto::Turn* release_latest_reply();
    ::manta::proto::Turn* mutable_latest_reply();
    void set_allocated_latest_reply(::manta::proto::Turn* latest_reply);

private:
    const ::manta::proto::Turn& _internal_latest_reply() const;
    ::manta::proto::Turn* _internal_mutable_latest_reply();

public:
    void unsafe_arena_set_allocated_latest_reply(::manta::proto::Turn* latest_reply);
    ::manta::proto::Turn* unsafe_arena_release_latest_reply();

    // optional .manta.proto.Update update = 3;
    bool has_update() const;

private:
    bool _internal_has_update() const;

public:
    void clear_update();
    const ::manta::proto::Update& update() const;
    PROTOBUF_NODISCARD ::manta::proto::Update* release_update();
    ::manta::proto::Update* mutable_update();
    void set_allocated_update(::manta::proto::Update* update);

private:
    const ::manta::proto::Update& _internal_update() const;
    ::manta::proto::Update* _internal_mutable_update();

public:
    void unsafe_arena_set_allocated_update(::manta::proto::Update* update);
    ::manta::proto::Update* unsafe_arena_release_update();

    // @@protoc_insertion_point(class_scope:manta.proto.SparkyResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::manta::proto::ContextRequest* context_request_;
        ::manta::proto::Turn* latest_reply_;
        ::manta::proto::Update* update_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class WebContent final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.WebContent) */ {
public:
    inline WebContent()
        : WebContent(nullptr)
    {
    }
    ~WebContent() override;
    explicit PROTOBUF_CONSTEXPR WebContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    WebContent(const WebContent& from);
    WebContent(WebContent&& from) noexcept
        : WebContent()
    {
        *this = ::std::move(from);
    }

    inline WebContent& operator=(const WebContent& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline WebContent& operator=(WebContent&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const WebContent& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const WebContent* internal_default_instance()
    {
        return reinterpret_cast<const WebContent*>(&_WebContent_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 27;

    friend void swap(WebContent& a, WebContent& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(WebContent* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(WebContent* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    WebContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<WebContent>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const WebContent& from);
    void MergeFrom(const WebContent& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(WebContent* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.WebContent";
    }

protected:
    explicit WebContent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kPageContentsFieldNumber = 1,
        kPageUrlFieldNumber = 2,
    };
    // optional string page_contents = 1;
    bool has_page_contents() const;

private:
    bool _internal_has_page_contents() const;

public:
    void clear_page_contents();
    const std::string& page_contents() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_page_contents(ArgT0&& arg0, ArgT... args);
    std::string* mutable_page_contents();
    PROTOBUF_NODISCARD std::string* release_page_contents();
    void set_allocated_page_contents(std::string* page_contents);

private:
    const std::string& _internal_page_contents() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_contents(const std::string& value);
    std::string* _internal_mutable_page_contents();

public:
    // optional string page_url = 2;
    bool has_page_url() const;

private:
    bool _internal_has_page_url() const;

public:
    void clear_page_url();
    const std::string& page_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_page_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_page_url();
    PROTOBUF_NODISCARD std::string* release_page_url();
    void set_allocated_page_url(std::string* page_url);

private:
    const std::string& _internal_page_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_url(const std::string& value);
    std::string* _internal_mutable_page_url();

public:
    // @@protoc_insertion_point(class_scope:manta.proto.WebContent)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_contents_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_url_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// -------------------------------------------------------------------

class SparkyContextData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:manta.proto.SparkyContextData) */ {
public:
    inline SparkyContextData()
        : SparkyContextData(nullptr)
    {
    }
    ~SparkyContextData() override;
    explicit PROTOBUF_CONSTEXPR SparkyContextData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SparkyContextData(const SparkyContextData& from);
    SparkyContextData(SparkyContextData&& from) noexcept
        : SparkyContextData()
    {
        *this = ::std::move(from);
    }

    inline SparkyContextData& operator=(const SparkyContextData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SparkyContextData& operator=(SparkyContextData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SparkyContextData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SparkyContextData* internal_default_instance()
    {
        return reinterpret_cast<const SparkyContextData*>(&_SparkyContextData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 28;

    friend void swap(SparkyContextData& a, SparkyContextData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SparkyContextData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SparkyContextData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SparkyContextData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SparkyContextData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SparkyContextData& from);
    void MergeFrom(const SparkyContextData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SparkyContextData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "manta.proto.SparkyContextData";
    }

protected:
    explicit SparkyContextData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kConversationFieldNumber = 4,
        kDiagnosticsDataFieldNumber = 2,
        kSettingsDataFieldNumber = 3,
        kScreenshotFieldNumber = 5,
        kAppsDataFieldNumber = 6,
        kWebContentsFieldNumber = 7,
        kFilesDataFieldNumber = 8,
        kServerConfigFieldNumber = 9,
        kTaskFieldNumber = 1,
    };
    // repeated .manta.proto.Turn conversation = 4;
    int conversation_size() const;

private:
    int _internal_conversation_size() const;

public:
    void clear_conversation();
    ::manta::proto::Turn* mutable_conversation(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Turn>* mutable_conversation();

private:
    const ::manta::proto::Turn& _internal_conversation(int index) const;
    ::manta::proto::Turn* _internal_add_conversation();

public:
    const ::manta::proto::Turn& conversation(int index) const;
    ::manta::proto::Turn* add_conversation();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Turn>& conversation() const;

    // optional .manta.proto.DiagnosticsData diagnostics_data = 2;
    bool has_diagnostics_data() const;

private:
    bool _internal_has_diagnostics_data() const;

public:
    void clear_diagnostics_data();
    const ::manta::proto::DiagnosticsData& diagnostics_data() const;
    PROTOBUF_NODISCARD ::manta::proto::DiagnosticsData* release_diagnostics_data();
    ::manta::proto::DiagnosticsData* mutable_diagnostics_data();
    void set_allocated_diagnostics_data(::manta::proto::DiagnosticsData* diagnostics_data);

private:
    const ::manta::proto::DiagnosticsData& _internal_diagnostics_data() const;
    ::manta::proto::DiagnosticsData* _internal_mutable_diagnostics_data();

public:
    void unsafe_arena_set_allocated_diagnostics_data(::manta::proto::DiagnosticsData* diagnostics_data);
    ::manta::proto::DiagnosticsData* unsafe_arena_release_diagnostics_data();

    // optional .manta.proto.SettingsData settings_data = 3;
    bool has_settings_data() const;

private:
    bool _internal_has_settings_data() const;

public:
    void clear_settings_data();
    const ::manta::proto::SettingsData& settings_data() const;
    PROTOBUF_NODISCARD ::manta::proto::SettingsData* release_settings_data();
    ::manta::proto::SettingsData* mutable_settings_data();
    void set_allocated_settings_data(::manta::proto::SettingsData* settings_data);

private:
    const ::manta::proto::SettingsData& _internal_settings_data() const;
    ::manta::proto::SettingsData* _internal_mutable_settings_data();

public:
    void unsafe_arena_set_allocated_settings_data(::manta::proto::SettingsData* settings_data);
    ::manta::proto::SettingsData* unsafe_arena_release_settings_data();

    // optional .manta.proto.Image screenshot = 5;
    bool has_screenshot() const;

private:
    bool _internal_has_screenshot() const;

public:
    void clear_screenshot();
    const ::manta::proto::Image& screenshot() const;
    PROTOBUF_NODISCARD ::manta::proto::Image* release_screenshot();
    ::manta::proto::Image* mutable_screenshot();
    void set_allocated_screenshot(::manta::proto::Image* screenshot);

private:
    const ::manta::proto::Image& _internal_screenshot() const;
    ::manta::proto::Image* _internal_mutable_screenshot();

public:
    void unsafe_arena_set_allocated_screenshot(::manta::proto::Image* screenshot);
    ::manta::proto::Image* unsafe_arena_release_screenshot();

    // optional .manta.proto.AppsData apps_data = 6;
    bool has_apps_data() const;

private:
    bool _internal_has_apps_data() const;

public:
    void clear_apps_data();
    const ::manta::proto::AppsData& apps_data() const;
    PROTOBUF_NODISCARD ::manta::proto::AppsData* release_apps_data();
    ::manta::proto::AppsData* mutable_apps_data();
    void set_allocated_apps_data(::manta::proto::AppsData* apps_data);

private:
    const ::manta::proto::AppsData& _internal_apps_data() const;
    ::manta::proto::AppsData* _internal_mutable_apps_data();

public:
    void unsafe_arena_set_allocated_apps_data(::manta::proto::AppsData* apps_data);
    ::manta::proto::AppsData* unsafe_arena_release_apps_data();

    // optional .manta.proto.WebContent web_contents = 7;
    bool has_web_contents() const;

private:
    bool _internal_has_web_contents() const;

public:
    void clear_web_contents();
    const ::manta::proto::WebContent& web_contents() const;
    PROTOBUF_NODISCARD ::manta::proto::WebContent* release_web_contents();
    ::manta::proto::WebContent* mutable_web_contents();
    void set_allocated_web_contents(::manta::proto::WebContent* web_contents);

private:
    const ::manta::proto::WebContent& _internal_web_contents() const;
    ::manta::proto::WebContent* _internal_mutable_web_contents();

public:
    void unsafe_arena_set_allocated_web_contents(::manta::proto::WebContent* web_contents);
    ::manta::proto::WebContent* unsafe_arena_release_web_contents();

    // optional .manta.proto.FilesData files_data = 8;
    bool has_files_data() const;

private:
    bool _internal_has_files_data() const;

public:
    void clear_files_data();
    const ::manta::proto::FilesData& files_data() const;
    PROTOBUF_NODISCARD ::manta::proto::FilesData* release_files_data();
    ::manta::proto::FilesData* mutable_files_data();
    void set_allocated_files_data(::manta::proto::FilesData* files_data);

private:
    const ::manta::proto::FilesData& _internal_files_data() const;
    ::manta::proto::FilesData* _internal_mutable_files_data();

public:
    void unsafe_arena_set_allocated_files_data(::manta::proto::FilesData* files_data);
    ::manta::proto::FilesData* unsafe_arena_release_files_data();

    // optional .manta.proto.ServerConfig server_config = 9;
    bool has_server_config() const;

private:
    bool _internal_has_server_config() const;

public:
    void clear_server_config();
    const ::manta::proto::ServerConfig& server_config() const;
    PROTOBUF_NODISCARD ::manta::proto::ServerConfig* release_server_config();
    ::manta::proto::ServerConfig* mutable_server_config();
    void set_allocated_server_config(::manta::proto::ServerConfig* server_config);

private:
    const ::manta::proto::ServerConfig& _internal_server_config() const;
    ::manta::proto::ServerConfig* _internal_mutable_server_config();

public:
    void unsafe_arena_set_allocated_server_config(::manta::proto::ServerConfig* server_config);
    ::manta::proto::ServerConfig* unsafe_arena_release_server_config();

    // optional .manta.proto.Task task = 1;
    bool has_task() const;

private:
    bool _internal_has_task() const;

public:
    void clear_task();
    ::manta::proto::Task task() const;
    void set_task(::manta::proto::Task value);

private:
    ::manta::proto::Task _internal_task() const;
    void _internal_set_task(::manta::proto::Task value);

public:
    // @@protoc_insertion_point(class_scope:manta.proto.SparkyContextData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Turn> conversation_;
        ::manta::proto::DiagnosticsData* diagnostics_data_;
        ::manta::proto::SettingsData* settings_data_;
        ::manta::proto::Image* screenshot_;
        ::manta::proto::AppsData* apps_data_;
        ::manta::proto::WebContent* web_contents_;
        ::manta::proto::FilesData* files_data_;
        ::manta::proto::ServerConfig* server_config_;
        int task_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fmanta_2fproto_2fsparky_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// BatteryData

// optional int32 battery_health = 1;
inline bool BatteryData::_internal_has_battery_health() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool BatteryData::has_battery_health() const
{
    return _internal_has_battery_health();
}
inline void BatteryData::clear_battery_health()
{
    _impl_.battery_health_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t BatteryData::_internal_battery_health() const
{
    return _impl_.battery_health_;
}
inline int32_t BatteryData::battery_health() const
{
    // @@protoc_insertion_point(field_get:manta.proto.BatteryData.battery_health)
    return _internal_battery_health();
}
inline void BatteryData::_internal_set_battery_health(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.battery_health_ = value;
}
inline void BatteryData::set_battery_health(int32_t value)
{
    _internal_set_battery_health(value);
    // @@protoc_insertion_point(field_set:manta.proto.BatteryData.battery_health)
}

// optional int32 cycle_count = 2;
inline bool BatteryData::_internal_has_cycle_count() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool BatteryData::has_cycle_count() const
{
    return _internal_has_cycle_count();
}
inline void BatteryData::clear_cycle_count()
{
    _impl_.cycle_count_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t BatteryData::_internal_cycle_count() const
{
    return _impl_.cycle_count_;
}
inline int32_t BatteryData::cycle_count() const
{
    // @@protoc_insertion_point(field_get:manta.proto.BatteryData.cycle_count)
    return _internal_cycle_count();
}
inline void BatteryData::_internal_set_cycle_count(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.cycle_count_ = value;
}
inline void BatteryData::set_cycle_count(int32_t value)
{
    _internal_set_cycle_count(value);
    // @@protoc_insertion_point(field_set:manta.proto.BatteryData.cycle_count)
}

// optional string battery_time = 3;
inline bool BatteryData::_internal_has_battery_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool BatteryData::has_battery_time() const
{
    return _internal_has_battery_time();
}
inline void BatteryData::clear_battery_time()
{
    _impl_.battery_time_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BatteryData::battery_time() const
{
    // @@protoc_insertion_point(field_get:manta.proto.BatteryData.battery_time)
    return _internal_battery_time();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void BatteryData::set_battery_time(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.battery_time_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.BatteryData.battery_time)
}
inline std::string* BatteryData::mutable_battery_time()
{
    std::string* _s = _internal_mutable_battery_time();
    // @@protoc_insertion_point(field_mutable:manta.proto.BatteryData.battery_time)
    return _s;
}
inline const std::string& BatteryData::_internal_battery_time() const
{
    return _impl_.battery_time_.Get();
}
inline void BatteryData::_internal_set_battery_time(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.battery_time_.Set(value, GetArenaForAllocation());
}
inline std::string* BatteryData::_internal_mutable_battery_time()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.battery_time_.Mutable(GetArenaForAllocation());
}
inline std::string* BatteryData::release_battery_time()
{
    // @@protoc_insertion_point(field_release:manta.proto.BatteryData.battery_time)
    if (!_internal_has_battery_time()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.battery_time_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.battery_time_.IsDefault()) {
        _impl_.battery_time_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void BatteryData::set_allocated_battery_time(std::string* battery_time)
{
    if (battery_time != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.battery_time_.SetAllocated(battery_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.battery_time_.IsDefault()) {
        _impl_.battery_time_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.BatteryData.battery_time)
}

// optional int32 battery_charge_percentage = 4;
inline bool BatteryData::_internal_has_battery_charge_percentage() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool BatteryData::has_battery_charge_percentage() const
{
    return _internal_has_battery_charge_percentage();
}
inline void BatteryData::clear_battery_charge_percentage()
{
    _impl_.battery_charge_percentage_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t BatteryData::_internal_battery_charge_percentage() const
{
    return _impl_.battery_charge_percentage_;
}
inline int32_t BatteryData::battery_charge_percentage() const
{
    // @@protoc_insertion_point(field_get:manta.proto.BatteryData.battery_charge_percentage)
    return _internal_battery_charge_percentage();
}
inline void BatteryData::_internal_set_battery_charge_percentage(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.battery_charge_percentage_ = value;
}
inline void BatteryData::set_battery_charge_percentage(int32_t value)
{
    _internal_set_battery_charge_percentage(value);
    // @@protoc_insertion_point(field_set:manta.proto.BatteryData.battery_charge_percentage)
}

// -------------------------------------------------------------------

// StorageData

// optional string free_storage = 1;
inline bool StorageData::_internal_has_free_storage() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool StorageData::has_free_storage() const
{
    return _internal_has_free_storage();
}
inline void StorageData::clear_free_storage()
{
    _impl_.free_storage_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StorageData::free_storage() const
{
    // @@protoc_insertion_point(field_get:manta.proto.StorageData.free_storage)
    return _internal_free_storage();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void StorageData::set_free_storage(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.free_storage_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.StorageData.free_storage)
}
inline std::string* StorageData::mutable_free_storage()
{
    std::string* _s = _internal_mutable_free_storage();
    // @@protoc_insertion_point(field_mutable:manta.proto.StorageData.free_storage)
    return _s;
}
inline const std::string& StorageData::_internal_free_storage() const
{
    return _impl_.free_storage_.Get();
}
inline void StorageData::_internal_set_free_storage(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.free_storage_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageData::_internal_mutable_free_storage()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.free_storage_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageData::release_free_storage()
{
    // @@protoc_insertion_point(field_release:manta.proto.StorageData.free_storage)
    if (!_internal_has_free_storage()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.free_storage_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.free_storage_.IsDefault()) {
        _impl_.free_storage_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void StorageData::set_allocated_free_storage(std::string* free_storage)
{
    if (free_storage != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.free_storage_.SetAllocated(free_storage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.free_storage_.IsDefault()) {
        _impl_.free_storage_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.StorageData.free_storage)
}

// optional string total_storage = 2;
inline bool StorageData::_internal_has_total_storage() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool StorageData::has_total_storage() const
{
    return _internal_has_total_storage();
}
inline void StorageData::clear_total_storage()
{
    _impl_.total_storage_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StorageData::total_storage() const
{
    // @@protoc_insertion_point(field_get:manta.proto.StorageData.total_storage)
    return _internal_total_storage();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void StorageData::set_total_storage(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.total_storage_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.StorageData.total_storage)
}
inline std::string* StorageData::mutable_total_storage()
{
    std::string* _s = _internal_mutable_total_storage();
    // @@protoc_insertion_point(field_mutable:manta.proto.StorageData.total_storage)
    return _s;
}
inline const std::string& StorageData::_internal_total_storage() const
{
    return _impl_.total_storage_.Get();
}
inline void StorageData::_internal_set_total_storage(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.total_storage_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageData::_internal_mutable_total_storage()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.total_storage_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageData::release_total_storage()
{
    // @@protoc_insertion_point(field_release:manta.proto.StorageData.total_storage)
    if (!_internal_has_total_storage()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.total_storage_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.total_storage_.IsDefault()) {
        _impl_.total_storage_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void StorageData::set_allocated_total_storage(std::string* total_storage)
{
    if (total_storage != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.total_storage_.SetAllocated(total_storage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.total_storage_.IsDefault()) {
        _impl_.total_storage_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.StorageData.total_storage)
}

// -------------------------------------------------------------------

// CPUData

// optional int32 cpu_usage_snapshot = 1;
inline bool CPUData::_internal_has_cpu_usage_snapshot() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool CPUData::has_cpu_usage_snapshot() const
{
    return _internal_has_cpu_usage_snapshot();
}
inline void CPUData::clear_cpu_usage_snapshot()
{
    _impl_.cpu_usage_snapshot_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t CPUData::_internal_cpu_usage_snapshot() const
{
    return _impl_.cpu_usage_snapshot_;
}
inline int32_t CPUData::cpu_usage_snapshot() const
{
    // @@protoc_insertion_point(field_get:manta.proto.CPUData.cpu_usage_snapshot)
    return _internal_cpu_usage_snapshot();
}
inline void CPUData::_internal_set_cpu_usage_snapshot(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.cpu_usage_snapshot_ = value;
}
inline void CPUData::set_cpu_usage_snapshot(int32_t value)
{
    _internal_set_cpu_usage_snapshot(value);
    // @@protoc_insertion_point(field_set:manta.proto.CPUData.cpu_usage_snapshot)
}

// optional int32 temperature = 2;
inline bool CPUData::_internal_has_temperature() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool CPUData::has_temperature() const
{
    return _internal_has_temperature();
}
inline void CPUData::clear_temperature()
{
    _impl_.temperature_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CPUData::_internal_temperature() const
{
    return _impl_.temperature_;
}
inline int32_t CPUData::temperature() const
{
    // @@protoc_insertion_point(field_get:manta.proto.CPUData.temperature)
    return _internal_temperature();
}
inline void CPUData::_internal_set_temperature(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.temperature_ = value;
}
inline void CPUData::set_temperature(int32_t value)
{
    _internal_set_temperature(value);
    // @@protoc_insertion_point(field_set:manta.proto.CPUData.temperature)
}

// optional double clock_speed_ghz = 3;
inline bool CPUData::_internal_has_clock_speed_ghz() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool CPUData::has_clock_speed_ghz() const
{
    return _internal_has_clock_speed_ghz();
}
inline void CPUData::clear_clock_speed_ghz()
{
    _impl_.clock_speed_ghz_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double CPUData::_internal_clock_speed_ghz() const
{
    return _impl_.clock_speed_ghz_;
}
inline double CPUData::clock_speed_ghz() const
{
    // @@protoc_insertion_point(field_get:manta.proto.CPUData.clock_speed_ghz)
    return _internal_clock_speed_ghz();
}
inline void CPUData::_internal_set_clock_speed_ghz(double value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.clock_speed_ghz_ = value;
}
inline void CPUData::set_clock_speed_ghz(double value)
{
    _internal_set_clock_speed_ghz(value);
    // @@protoc_insertion_point(field_set:manta.proto.CPUData.clock_speed_ghz)
}

// -------------------------------------------------------------------

// MemoryData

// optional double free_ram_gb = 1;
inline bool MemoryData::_internal_has_free_ram_gb() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool MemoryData::has_free_ram_gb() const
{
    return _internal_has_free_ram_gb();
}
inline void MemoryData::clear_free_ram_gb()
{
    _impl_.free_ram_gb_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double MemoryData::_internal_free_ram_gb() const
{
    return _impl_.free_ram_gb_;
}
inline double MemoryData::free_ram_gb() const
{
    // @@protoc_insertion_point(field_get:manta.proto.MemoryData.free_ram_gb)
    return _internal_free_ram_gb();
}
inline void MemoryData::_internal_set_free_ram_gb(double value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.free_ram_gb_ = value;
}
inline void MemoryData::set_free_ram_gb(double value)
{
    _internal_set_free_ram_gb(value);
    // @@protoc_insertion_point(field_set:manta.proto.MemoryData.free_ram_gb)
}

// optional double total_ram_gb = 2;
inline bool MemoryData::_internal_has_total_ram_gb() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool MemoryData::has_total_ram_gb() const
{
    return _internal_has_total_ram_gb();
}
inline void MemoryData::clear_total_ram_gb()
{
    _impl_.total_ram_gb_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double MemoryData::_internal_total_ram_gb() const
{
    return _impl_.total_ram_gb_;
}
inline double MemoryData::total_ram_gb() const
{
    // @@protoc_insertion_point(field_get:manta.proto.MemoryData.total_ram_gb)
    return _internal_total_ram_gb();
}
inline void MemoryData::_internal_set_total_ram_gb(double value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.total_ram_gb_ = value;
}
inline void MemoryData::set_total_ram_gb(double value)
{
    _internal_set_total_ram_gb(value);
    // @@protoc_insertion_point(field_set:manta.proto.MemoryData.total_ram_gb)
}

// -------------------------------------------------------------------

// DiagnosticsData

// optional .manta.proto.BatteryData battery = 1;
inline bool DiagnosticsData::_internal_has_battery() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.battery_ != nullptr);
    return value;
}
inline bool DiagnosticsData::has_battery() const
{
    return _internal_has_battery();
}
inline void DiagnosticsData::clear_battery()
{
    if (_impl_.battery_ != nullptr)
        _impl_.battery_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::manta::proto::BatteryData& DiagnosticsData::_internal_battery() const
{
    const ::manta::proto::BatteryData* p = _impl_.battery_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::BatteryData&>(::manta::proto::_BatteryData_default_instance_);
}
inline const ::manta::proto::BatteryData& DiagnosticsData::battery() const
{
    // @@protoc_insertion_point(field_get:manta.proto.DiagnosticsData.battery)
    return _internal_battery();
}
inline void DiagnosticsData::unsafe_arena_set_allocated_battery(::manta::proto::BatteryData* battery)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.battery_);
    }
    _impl_.battery_ = battery;
    if (battery) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.DiagnosticsData.battery)
}
inline ::manta::proto::BatteryData* DiagnosticsData::release_battery()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::BatteryData* temp = _impl_.battery_;
    _impl_.battery_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::BatteryData* DiagnosticsData::unsafe_arena_release_battery()
{
    // @@protoc_insertion_point(field_release:manta.proto.DiagnosticsData.battery)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::BatteryData* temp = _impl_.battery_;
    _impl_.battery_ = nullptr;
    return temp;
}
inline ::manta::proto::BatteryData* DiagnosticsData::_internal_mutable_battery()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.battery_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::BatteryData>(GetArenaForAllocation());
        _impl_.battery_ = p;
    }
    return _impl_.battery_;
}
inline ::manta::proto::BatteryData* DiagnosticsData::mutable_battery()
{
    ::manta::proto::BatteryData* _msg = _internal_mutable_battery();
    // @@protoc_insertion_point(field_mutable:manta.proto.DiagnosticsData.battery)
    return _msg;
}
inline void DiagnosticsData::set_allocated_battery(::manta::proto::BatteryData* battery)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.battery_;
    }
    if (battery) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(battery);
        if (message_arena != submessage_arena) {
            battery = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, battery, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.battery_ = battery;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.DiagnosticsData.battery)
}

// optional .manta.proto.StorageData storage = 2;
inline bool DiagnosticsData::_internal_has_storage() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.storage_ != nullptr);
    return value;
}
inline bool DiagnosticsData::has_storage() const
{
    return _internal_has_storage();
}
inline void DiagnosticsData::clear_storage()
{
    if (_impl_.storage_ != nullptr)
        _impl_.storage_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::manta::proto::StorageData& DiagnosticsData::_internal_storage() const
{
    const ::manta::proto::StorageData* p = _impl_.storage_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::StorageData&>(::manta::proto::_StorageData_default_instance_);
}
inline const ::manta::proto::StorageData& DiagnosticsData::storage() const
{
    // @@protoc_insertion_point(field_get:manta.proto.DiagnosticsData.storage)
    return _internal_storage();
}
inline void DiagnosticsData::unsafe_arena_set_allocated_storage(::manta::proto::StorageData* storage)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.storage_);
    }
    _impl_.storage_ = storage;
    if (storage) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.DiagnosticsData.storage)
}
inline ::manta::proto::StorageData* DiagnosticsData::release_storage()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::manta::proto::StorageData* temp = _impl_.storage_;
    _impl_.storage_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::StorageData* DiagnosticsData::unsafe_arena_release_storage()
{
    // @@protoc_insertion_point(field_release:manta.proto.DiagnosticsData.storage)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::manta::proto::StorageData* temp = _impl_.storage_;
    _impl_.storage_ = nullptr;
    return temp;
}
inline ::manta::proto::StorageData* DiagnosticsData::_internal_mutable_storage()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.storage_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::StorageData>(GetArenaForAllocation());
        _impl_.storage_ = p;
    }
    return _impl_.storage_;
}
inline ::manta::proto::StorageData* DiagnosticsData::mutable_storage()
{
    ::manta::proto::StorageData* _msg = _internal_mutable_storage();
    // @@protoc_insertion_point(field_mutable:manta.proto.DiagnosticsData.storage)
    return _msg;
}
inline void DiagnosticsData::set_allocated_storage(::manta::proto::StorageData* storage)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.storage_;
    }
    if (storage) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(storage);
        if (message_arena != submessage_arena) {
            storage = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, storage, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.storage_ = storage;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.DiagnosticsData.storage)
}

// optional .manta.proto.CPUData cpu = 3;
inline bool DiagnosticsData::_internal_has_cpu() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.cpu_ != nullptr);
    return value;
}
inline bool DiagnosticsData::has_cpu() const
{
    return _internal_has_cpu();
}
inline void DiagnosticsData::clear_cpu()
{
    if (_impl_.cpu_ != nullptr)
        _impl_.cpu_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::manta::proto::CPUData& DiagnosticsData::_internal_cpu() const
{
    const ::manta::proto::CPUData* p = _impl_.cpu_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::CPUData&>(::manta::proto::_CPUData_default_instance_);
}
inline const ::manta::proto::CPUData& DiagnosticsData::cpu() const
{
    // @@protoc_insertion_point(field_get:manta.proto.DiagnosticsData.cpu)
    return _internal_cpu();
}
inline void DiagnosticsData::unsafe_arena_set_allocated_cpu(::manta::proto::CPUData* cpu)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cpu_);
    }
    _impl_.cpu_ = cpu;
    if (cpu) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.DiagnosticsData.cpu)
}
inline ::manta::proto::CPUData* DiagnosticsData::release_cpu()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::manta::proto::CPUData* temp = _impl_.cpu_;
    _impl_.cpu_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::CPUData* DiagnosticsData::unsafe_arena_release_cpu()
{
    // @@protoc_insertion_point(field_release:manta.proto.DiagnosticsData.cpu)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::manta::proto::CPUData* temp = _impl_.cpu_;
    _impl_.cpu_ = nullptr;
    return temp;
}
inline ::manta::proto::CPUData* DiagnosticsData::_internal_mutable_cpu()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.cpu_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::CPUData>(GetArenaForAllocation());
        _impl_.cpu_ = p;
    }
    return _impl_.cpu_;
}
inline ::manta::proto::CPUData* DiagnosticsData::mutable_cpu()
{
    ::manta::proto::CPUData* _msg = _internal_mutable_cpu();
    // @@protoc_insertion_point(field_mutable:manta.proto.DiagnosticsData.cpu)
    return _msg;
}
inline void DiagnosticsData::set_allocated_cpu(::manta::proto::CPUData* cpu)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.cpu_;
    }
    if (cpu) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cpu);
        if (message_arena != submessage_arena) {
            cpu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, cpu, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.cpu_ = cpu;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.DiagnosticsData.cpu)
}

// optional .manta.proto.MemoryData memory = 4;
inline bool DiagnosticsData::_internal_has_memory() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.memory_ != nullptr);
    return value;
}
inline bool DiagnosticsData::has_memory() const
{
    return _internal_has_memory();
}
inline void DiagnosticsData::clear_memory()
{
    if (_impl_.memory_ != nullptr)
        _impl_.memory_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::manta::proto::MemoryData& DiagnosticsData::_internal_memory() const
{
    const ::manta::proto::MemoryData* p = _impl_.memory_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::MemoryData&>(::manta::proto::_MemoryData_default_instance_);
}
inline const ::manta::proto::MemoryData& DiagnosticsData::memory() const
{
    // @@protoc_insertion_point(field_get:manta.proto.DiagnosticsData.memory)
    return _internal_memory();
}
inline void DiagnosticsData::unsafe_arena_set_allocated_memory(::manta::proto::MemoryData* memory)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.memory_);
    }
    _impl_.memory_ = memory;
    if (memory) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.DiagnosticsData.memory)
}
inline ::manta::proto::MemoryData* DiagnosticsData::release_memory()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::manta::proto::MemoryData* temp = _impl_.memory_;
    _impl_.memory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::MemoryData* DiagnosticsData::unsafe_arena_release_memory()
{
    // @@protoc_insertion_point(field_release:manta.proto.DiagnosticsData.memory)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::manta::proto::MemoryData* temp = _impl_.memory_;
    _impl_.memory_ = nullptr;
    return temp;
}
inline ::manta::proto::MemoryData* DiagnosticsData::_internal_mutable_memory()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.memory_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::MemoryData>(GetArenaForAllocation());
        _impl_.memory_ = p;
    }
    return _impl_.memory_;
}
inline ::manta::proto::MemoryData* DiagnosticsData::mutable_memory()
{
    ::manta::proto::MemoryData* _msg = _internal_mutable_memory();
    // @@protoc_insertion_point(field_mutable:manta.proto.DiagnosticsData.memory)
    return _msg;
}
inline void DiagnosticsData::set_allocated_memory(::manta::proto::MemoryData* memory)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.memory_;
    }
    if (memory) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(memory);
        if (message_arena != submessage_arena) {
            memory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, memory, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.memory_ = memory;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.DiagnosticsData.memory)
}

// -------------------------------------------------------------------

// ServerConfig

// optional string server_url = 1;
inline bool ServerConfig::_internal_has_server_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ServerConfig::has_server_url() const
{
    return _internal_has_server_url();
}
inline void ServerConfig::clear_server_url()
{
    _impl_.server_url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServerConfig::server_url() const
{
    // @@protoc_insertion_point(field_get:manta.proto.ServerConfig.server_url)
    return _internal_server_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ServerConfig::set_server_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.server_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.ServerConfig.server_url)
}
inline std::string* ServerConfig::mutable_server_url()
{
    std::string* _s = _internal_mutable_server_url();
    // @@protoc_insertion_point(field_mutable:manta.proto.ServerConfig.server_url)
    return _s;
}
inline const std::string& ServerConfig::_internal_server_url() const
{
    return _impl_.server_url_.Get();
}
inline void ServerConfig::_internal_set_server_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.server_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerConfig::_internal_mutable_server_url()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.server_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ServerConfig::release_server_url()
{
    // @@protoc_insertion_point(field_release:manta.proto.ServerConfig.server_url)
    if (!_internal_has_server_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.server_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.server_url_.IsDefault()) {
        _impl_.server_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ServerConfig::set_allocated_server_url(std::string* server_url)
{
    if (server_url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.server_url_.SetAllocated(server_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.server_url_.IsDefault()) {
        _impl_.server_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.ServerConfig.server_url)
}

// -------------------------------------------------------------------

// SettingsValue

// bool bool_val = 1;
inline bool SettingsValue::_internal_has_bool_val() const
{
    return settings_value_case() == kBoolVal;
}
inline bool SettingsValue::has_bool_val() const
{
    return _internal_has_bool_val();
}
inline void SettingsValue::set_has_bool_val()
{
    _impl_._oneof_case_[0] = kBoolVal;
}
inline void SettingsValue::clear_bool_val()
{
    if (_internal_has_bool_val()) {
        _impl_.settings_value_.bool_val_ = false;
        clear_has_settings_value();
    }
}
inline bool SettingsValue::_internal_bool_val() const
{
    if (_internal_has_bool_val()) {
        return _impl_.settings_value_.bool_val_;
    }
    return false;
}
inline void SettingsValue::_internal_set_bool_val(bool value)
{
    if (!_internal_has_bool_val()) {
        clear_settings_value();
        set_has_bool_val();
    }
    _impl_.settings_value_.bool_val_ = value;
}
inline bool SettingsValue::bool_val() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SettingsValue.bool_val)
    return _internal_bool_val();
}
inline void SettingsValue::set_bool_val(bool value)
{
    _internal_set_bool_val(value);
    // @@protoc_insertion_point(field_set:manta.proto.SettingsValue.bool_val)
}

// string text_val = 2;
inline bool SettingsValue::_internal_has_text_val() const
{
    return settings_value_case() == kTextVal;
}
inline bool SettingsValue::has_text_val() const
{
    return _internal_has_text_val();
}
inline void SettingsValue::set_has_text_val()
{
    _impl_._oneof_case_[0] = kTextVal;
}
inline void SettingsValue::clear_text_val()
{
    if (_internal_has_text_val()) {
        _impl_.settings_value_.text_val_.Destroy();
        clear_has_settings_value();
    }
}
inline const std::string& SettingsValue::text_val() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SettingsValue.text_val)
    return _internal_text_val();
}
template <typename ArgT0, typename... ArgT> inline void SettingsValue::set_text_val(ArgT0&& arg0, ArgT... args)
{
    if (!_internal_has_text_val()) {
        clear_settings_value();
        set_has_text_val();
        _impl_.settings_value_.text_val_.InitDefault();
    }
    _impl_.settings_value_.text_val_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.SettingsValue.text_val)
}
inline std::string* SettingsValue::mutable_text_val()
{
    std::string* _s = _internal_mutable_text_val();
    // @@protoc_insertion_point(field_mutable:manta.proto.SettingsValue.text_val)
    return _s;
}
inline const std::string& SettingsValue::_internal_text_val() const
{
    if (_internal_has_text_val()) {
        return _impl_.settings_value_.text_val_.Get();
    }
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SettingsValue::_internal_set_text_val(const std::string& value)
{
    if (!_internal_has_text_val()) {
        clear_settings_value();
        set_has_text_val();
        _impl_.settings_value_.text_val_.InitDefault();
    }
    _impl_.settings_value_.text_val_.Set(value, GetArenaForAllocation());
}
inline std::string* SettingsValue::_internal_mutable_text_val()
{
    if (!_internal_has_text_val()) {
        clear_settings_value();
        set_has_text_val();
        _impl_.settings_value_.text_val_.InitDefault();
    }
    return _impl_.settings_value_.text_val_.Mutable(GetArenaForAllocation());
}
inline std::string* SettingsValue::release_text_val()
{
    // @@protoc_insertion_point(field_release:manta.proto.SettingsValue.text_val)
    if (_internal_has_text_val()) {
        clear_has_settings_value();
        return _impl_.settings_value_.text_val_.Release();
    } else {
        return nullptr;
    }
}
inline void SettingsValue::set_allocated_text_val(std::string* text_val)
{
    if (has_settings_value()) {
        clear_settings_value();
    }
    if (text_val != nullptr) {
        set_has_text_val();
        _impl_.settings_value_.text_val_.InitAllocated(text_val, GetArenaForAllocation());
    }
    // @@protoc_insertion_point(field_set_allocated:manta.proto.SettingsValue.text_val)
}

// double double_val = 3;
inline bool SettingsValue::_internal_has_double_val() const
{
    return settings_value_case() == kDoubleVal;
}
inline bool SettingsValue::has_double_val() const
{
    return _internal_has_double_val();
}
inline void SettingsValue::set_has_double_val()
{
    _impl_._oneof_case_[0] = kDoubleVal;
}
inline void SettingsValue::clear_double_val()
{
    if (_internal_has_double_val()) {
        _impl_.settings_value_.double_val_ = 0;
        clear_has_settings_value();
    }
}
inline double SettingsValue::_internal_double_val() const
{
    if (_internal_has_double_val()) {
        return _impl_.settings_value_.double_val_;
    }
    return 0;
}
inline void SettingsValue::_internal_set_double_val(double value)
{
    if (!_internal_has_double_val()) {
        clear_settings_value();
        set_has_double_val();
    }
    _impl_.settings_value_.double_val_ = value;
}
inline double SettingsValue::double_val() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SettingsValue.double_val)
    return _internal_double_val();
}
inline void SettingsValue::set_double_val(double value)
{
    _internal_set_double_val(value);
    // @@protoc_insertion_point(field_set:manta.proto.SettingsValue.double_val)
}

// int32 int_val = 4;
inline bool SettingsValue::_internal_has_int_val() const
{
    return settings_value_case() == kIntVal;
}
inline bool SettingsValue::has_int_val() const
{
    return _internal_has_int_val();
}
inline void SettingsValue::set_has_int_val()
{
    _impl_._oneof_case_[0] = kIntVal;
}
inline void SettingsValue::clear_int_val()
{
    if (_internal_has_int_val()) {
        _impl_.settings_value_.int_val_ = 0;
        clear_has_settings_value();
    }
}
inline int32_t SettingsValue::_internal_int_val() const
{
    if (_internal_has_int_val()) {
        return _impl_.settings_value_.int_val_;
    }
    return 0;
}
inline void SettingsValue::_internal_set_int_val(int32_t value)
{
    if (!_internal_has_int_val()) {
        clear_settings_value();
        set_has_int_val();
    }
    _impl_.settings_value_.int_val_ = value;
}
inline int32_t SettingsValue::int_val() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SettingsValue.int_val)
    return _internal_int_val();
}
inline void SettingsValue::set_int_val(int32_t value)
{
    _internal_set_int_val(value);
    // @@protoc_insertion_point(field_set:manta.proto.SettingsValue.int_val)
}

inline bool SettingsValue::has_settings_value() const
{
    return settings_value_case() != SETTINGS_VALUE_NOT_SET;
}
inline void SettingsValue::clear_has_settings_value()
{
    _impl_._oneof_case_[0] = SETTINGS_VALUE_NOT_SET;
}
inline SettingsValue::SettingsValueCase SettingsValue::settings_value_case() const
{
    return SettingsValue::SettingsValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Setting

// string settings_id = 1;
inline void Setting::clear_settings_id()
{
    _impl_.settings_id_.ClearToEmpty();
}
inline const std::string& Setting::settings_id() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Setting.settings_id)
    return _internal_settings_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Setting::set_settings_id(ArgT0&& arg0, ArgT... args)
{

    _impl_.settings_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.Setting.settings_id)
}
inline std::string* Setting::mutable_settings_id()
{
    std::string* _s = _internal_mutable_settings_id();
    // @@protoc_insertion_point(field_mutable:manta.proto.Setting.settings_id)
    return _s;
}
inline const std::string& Setting::_internal_settings_id() const
{
    return _impl_.settings_id_.Get();
}
inline void Setting::_internal_set_settings_id(const std::string& value)
{

    _impl_.settings_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Setting::_internal_mutable_settings_id()
{

    return _impl_.settings_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Setting::release_settings_id()
{
    // @@protoc_insertion_point(field_release:manta.proto.Setting.settings_id)
    return _impl_.settings_id_.Release();
}
inline void Setting::set_allocated_settings_id(std::string* settings_id)
{
    if (settings_id != nullptr) {

    } else {
    }
    _impl_.settings_id_.SetAllocated(settings_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.settings_id_.IsDefault()) {
        _impl_.settings_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Setting.settings_id)
}

// .manta.proto.SettingsValue value = 2;
inline bool Setting::_internal_has_value() const
{
    return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool Setting::has_value() const
{
    return _internal_has_value();
}
inline void Setting::clear_value()
{
    if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
        delete _impl_.value_;
    }
    _impl_.value_ = nullptr;
}
inline const ::manta::proto::SettingsValue& Setting::_internal_value() const
{
    const ::manta::proto::SettingsValue* p = _impl_.value_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::SettingsValue&>(::manta::proto::_SettingsValue_default_instance_);
}
inline const ::manta::proto::SettingsValue& Setting::value() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Setting.value)
    return _internal_value();
}
inline void Setting::unsafe_arena_set_allocated_value(::manta::proto::SettingsValue* value)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
    }
    _impl_.value_ = value;
    if (value) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.Setting.value)
}
inline ::manta::proto::SettingsValue* Setting::release_value()
{

    ::manta::proto::SettingsValue* temp = _impl_.value_;
    _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::SettingsValue* Setting::unsafe_arena_release_value()
{
    // @@protoc_insertion_point(field_release:manta.proto.Setting.value)

    ::manta::proto::SettingsValue* temp = _impl_.value_;
    _impl_.value_ = nullptr;
    return temp;
}
inline ::manta::proto::SettingsValue* Setting::_internal_mutable_value()
{

    if (_impl_.value_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::SettingsValue>(GetArenaForAllocation());
        _impl_.value_ = p;
    }
    return _impl_.value_;
}
inline ::manta::proto::SettingsValue* Setting::mutable_value()
{
    ::manta::proto::SettingsValue* _msg = _internal_mutable_value();
    // @@protoc_insertion_point(field_mutable:manta.proto.Setting.value)
    return _msg;
}
inline void Setting::set_allocated_value(::manta::proto::SettingsValue* value)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.value_;
    }
    if (value) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
        if (message_arena != submessage_arena) {
            value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, value, submessage_arena);
        }

    } else {
    }
    _impl_.value_ = value;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Setting.value)
}

// .manta.proto.SettingType type = 3;
inline void Setting::clear_type()
{
    _impl_.type_ = 0;
}
inline ::manta::proto::SettingType Setting::_internal_type() const
{
    return static_cast<::manta::proto::SettingType>(_impl_.type_);
}
inline ::manta::proto::SettingType Setting::type() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Setting.type)
    return _internal_type();
}
inline void Setting::_internal_set_type(::manta::proto::SettingType value)
{

    _impl_.type_ = value;
}
inline void Setting::set_type(::manta::proto::SettingType value)
{
    _internal_set_type(value);
    // @@protoc_insertion_point(field_set:manta.proto.Setting.type)
}

// -------------------------------------------------------------------

// SettingsData

// repeated .manta.proto.Setting setting = 1;
inline int SettingsData::_internal_setting_size() const
{
    return _impl_.setting_.size();
}
inline int SettingsData::setting_size() const
{
    return _internal_setting_size();
}
inline void SettingsData::clear_setting()
{
    _impl_.setting_.Clear();
}
inline ::manta::proto::Setting* SettingsData::mutable_setting(int index)
{
    // @@protoc_insertion_point(field_mutable:manta.proto.SettingsData.setting)
    return _impl_.setting_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Setting>* SettingsData::mutable_setting()
{
    // @@protoc_insertion_point(field_mutable_list:manta.proto.SettingsData.setting)
    return &_impl_.setting_;
}
inline const ::manta::proto::Setting& SettingsData::_internal_setting(int index) const
{
    return _impl_.setting_.Get(index);
}
inline const ::manta::proto::Setting& SettingsData::setting(int index) const
{
    // @@protoc_insertion_point(field_get:manta.proto.SettingsData.setting)
    return _internal_setting(index);
}
inline ::manta::proto::Setting* SettingsData::_internal_add_setting()
{
    return _impl_.setting_.Add();
}
inline ::manta::proto::Setting* SettingsData::add_setting()
{
    ::manta::proto::Setting* _add = _internal_add_setting();
    // @@protoc_insertion_point(field_add:manta.proto.SettingsData.setting)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Setting>& SettingsData::setting() const
{
    // @@protoc_insertion_point(field_list:manta.proto.SettingsData.setting)
    return _impl_.setting_;
}

// -------------------------------------------------------------------

// App

// string id = 1;
inline void App::clear_id()
{
    _impl_.id_.ClearToEmpty();
}
inline const std::string& App::id() const
{
    // @@protoc_insertion_point(field_get:manta.proto.App.id)
    return _internal_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void App::set_id(ArgT0&& arg0, ArgT... args)
{

    _impl_.id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.App.id)
}
inline std::string* App::mutable_id()
{
    std::string* _s = _internal_mutable_id();
    // @@protoc_insertion_point(field_mutable:manta.proto.App.id)
    return _s;
}
inline const std::string& App::_internal_id() const
{
    return _impl_.id_.Get();
}
inline void App::_internal_set_id(const std::string& value)
{

    _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_id()
{

    return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_id()
{
    // @@protoc_insertion_point(field_release:manta.proto.App.id)
    return _impl_.id_.Release();
}
inline void App::set_allocated_id(std::string* id)
{
    if (id != nullptr) {

    } else {
    }
    _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.id_.IsDefault()) {
        _impl_.id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.App.id)
}

// string name = 2;
inline void App::clear_name()
{
    _impl_.name_.ClearToEmpty();
}
inline const std::string& App::name() const
{
    // @@protoc_insertion_point(field_get:manta.proto.App.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void App::set_name(ArgT0&& arg0, ArgT... args)
{

    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.App.name)
}
inline std::string* App::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:manta.proto.App.name)
    return _s;
}
inline const std::string& App::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void App::_internal_set_name(const std::string& value)
{

    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_name()
{

    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* App::release_name()
{
    // @@protoc_insertion_point(field_release:manta.proto.App.name)
    return _impl_.name_.Release();
}
inline void App::set_allocated_name(std::string* name)
{
    if (name != nullptr) {

    } else {
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.App.name)
}

// repeated string searchable_term = 3;
inline int App::_internal_searchable_term_size() const
{
    return _impl_.searchable_term_.size();
}
inline int App::searchable_term_size() const
{
    return _internal_searchable_term_size();
}
inline void App::clear_searchable_term()
{
    _impl_.searchable_term_.Clear();
}
inline std::string* App::add_searchable_term()
{
    std::string* _s = _internal_add_searchable_term();
    // @@protoc_insertion_point(field_add_mutable:manta.proto.App.searchable_term)
    return _s;
}
inline const std::string& App::_internal_searchable_term(int index) const
{
    return _impl_.searchable_term_.Get(index);
}
inline const std::string& App::searchable_term(int index) const
{
    // @@protoc_insertion_point(field_get:manta.proto.App.searchable_term)
    return _internal_searchable_term(index);
}
inline std::string* App::mutable_searchable_term(int index)
{
    // @@protoc_insertion_point(field_mutable:manta.proto.App.searchable_term)
    return _impl_.searchable_term_.Mutable(index);
}
inline void App::set_searchable_term(int index, const std::string& value)
{
    _impl_.searchable_term_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:manta.proto.App.searchable_term)
}
inline void App::set_searchable_term(int index, std::string&& value)
{
    _impl_.searchable_term_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:manta.proto.App.searchable_term)
}
inline void App::set_searchable_term(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.searchable_term_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:manta.proto.App.searchable_term)
}
inline void App::set_searchable_term(int index, const char* value, size_t size)
{
    _impl_.searchable_term_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:manta.proto.App.searchable_term)
}
inline std::string* App::_internal_add_searchable_term()
{
    return _impl_.searchable_term_.Add();
}
inline void App::add_searchable_term(const std::string& value)
{
    _impl_.searchable_term_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:manta.proto.App.searchable_term)
}
inline void App::add_searchable_term(std::string&& value)
{
    _impl_.searchable_term_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:manta.proto.App.searchable_term)
}
inline void App::add_searchable_term(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.searchable_term_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:manta.proto.App.searchable_term)
}
inline void App::add_searchable_term(const char* value, size_t size)
{
    _impl_.searchable_term_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:manta.proto.App.searchable_term)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& App::searchable_term() const
{
    // @@protoc_insertion_point(field_list:manta.proto.App.searchable_term)
    return _impl_.searchable_term_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* App::mutable_searchable_term()
{
    // @@protoc_insertion_point(field_mutable_list:manta.proto.App.searchable_term)
    return &_impl_.searchable_term_;
}

// -------------------------------------------------------------------

// AppsData

// repeated .manta.proto.App app = 1;
inline int AppsData::_internal_app_size() const
{
    return _impl_.app_.size();
}
inline int AppsData::app_size() const
{
    return _internal_app_size();
}
inline void AppsData::clear_app()
{
    _impl_.app_.Clear();
}
inline ::manta::proto::App* AppsData::mutable_app(int index)
{
    // @@protoc_insertion_point(field_mutable:manta.proto.AppsData.app)
    return _impl_.app_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::App>* AppsData::mutable_app()
{
    // @@protoc_insertion_point(field_mutable_list:manta.proto.AppsData.app)
    return &_impl_.app_;
}
inline const ::manta::proto::App& AppsData::_internal_app(int index) const
{
    return _impl_.app_.Get(index);
}
inline const ::manta::proto::App& AppsData::app(int index) const
{
    // @@protoc_insertion_point(field_get:manta.proto.AppsData.app)
    return _internal_app(index);
}
inline ::manta::proto::App* AppsData::_internal_add_app()
{
    return _impl_.app_.Add();
}
inline ::manta::proto::App* AppsData::add_app()
{
    ::manta::proto::App* _add = _internal_add_app();
    // @@protoc_insertion_point(field_add:manta.proto.AppsData.app)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::App>& AppsData::app() const
{
    // @@protoc_insertion_point(field_list:manta.proto.AppsData.app)
    return _impl_.app_;
}

// -------------------------------------------------------------------

// TextEntry

// optional string text = 1;
inline bool TextEntry::_internal_has_text() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool TextEntry::has_text() const
{
    return _internal_has_text();
}
inline void TextEntry::clear_text()
{
    _impl_.text_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TextEntry::text() const
{
    // @@protoc_insertion_point(field_get:manta.proto.TextEntry.text)
    return _internal_text();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void TextEntry::set_text(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.text_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.TextEntry.text)
}
inline std::string* TextEntry::mutable_text()
{
    std::string* _s = _internal_mutable_text();
    // @@protoc_insertion_point(field_mutable:manta.proto.TextEntry.text)
    return _s;
}
inline const std::string& TextEntry::_internal_text() const
{
    return _impl_.text_.Get();
}
inline void TextEntry::_internal_set_text(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* TextEntry::_internal_mutable_text()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* TextEntry::release_text()
{
    // @@protoc_insertion_point(field_release:manta.proto.TextEntry.text)
    if (!_internal_has_text()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.text_.IsDefault()) {
        _impl_.text_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void TextEntry::set_allocated_text(std::string* text)
{
    if (text != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.text_.IsDefault()) {
        _impl_.text_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.TextEntry.text)
}

// -------------------------------------------------------------------

// KeyPress

// optional string key = 1;
inline bool KeyPress::_internal_has_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool KeyPress::has_key() const
{
    return _internal_has_key();
}
inline void KeyPress::clear_key()
{
    _impl_.key_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& KeyPress::key() const
{
    // @@protoc_insertion_point(field_get:manta.proto.KeyPress.key)
    return _internal_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void KeyPress::set_key(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.key_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.KeyPress.key)
}
inline std::string* KeyPress::mutable_key()
{
    std::string* _s = _internal_mutable_key();
    // @@protoc_insertion_point(field_mutable:manta.proto.KeyPress.key)
    return _s;
}
inline const std::string& KeyPress::_internal_key() const
{
    return _impl_.key_.Get();
}
inline void KeyPress::_internal_set_key(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* KeyPress::_internal_mutable_key()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* KeyPress::release_key()
{
    // @@protoc_insertion_point(field_release:manta.proto.KeyPress.key)
    if (!_internal_has_key()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.key_.IsDefault()) {
        _impl_.key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void KeyPress::set_allocated_key(std::string* key)
{
    if (key != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.key_.IsDefault()) {
        _impl_.key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.KeyPress.key)
}

// optional bool control = 2;
inline bool KeyPress::_internal_has_control() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool KeyPress::has_control() const
{
    return _internal_has_control();
}
inline void KeyPress::clear_control()
{
    _impl_.control_ = false;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool KeyPress::_internal_control() const
{
    return _impl_.control_;
}
inline bool KeyPress::control() const
{
    // @@protoc_insertion_point(field_get:manta.proto.KeyPress.control)
    return _internal_control();
}
inline void KeyPress::_internal_set_control(bool value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.control_ = value;
}
inline void KeyPress::set_control(bool value)
{
    _internal_set_control(value);
    // @@protoc_insertion_point(field_set:manta.proto.KeyPress.control)
}

// optional bool alt = 3;
inline bool KeyPress::_internal_has_alt() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool KeyPress::has_alt() const
{
    return _internal_has_alt();
}
inline void KeyPress::clear_alt()
{
    _impl_.alt_ = false;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool KeyPress::_internal_alt() const
{
    return _impl_.alt_;
}
inline bool KeyPress::alt() const
{
    // @@protoc_insertion_point(field_get:manta.proto.KeyPress.alt)
    return _internal_alt();
}
inline void KeyPress::_internal_set_alt(bool value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.alt_ = value;
}
inline void KeyPress::set_alt(bool value)
{
    _internal_set_alt(value);
    // @@protoc_insertion_point(field_set:manta.proto.KeyPress.alt)
}

// optional bool shift = 4;
inline bool KeyPress::_internal_has_shift() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool KeyPress::has_shift() const
{
    return _internal_has_shift();
}
inline void KeyPress::clear_shift()
{
    _impl_.shift_ = false;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool KeyPress::_internal_shift() const
{
    return _impl_.shift_;
}
inline bool KeyPress::shift() const
{
    // @@protoc_insertion_point(field_get:manta.proto.KeyPress.shift)
    return _internal_shift();
}
inline void KeyPress::_internal_set_shift(bool value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.shift_ = value;
}
inline void KeyPress::set_shift(bool value)
{
    _internal_set_shift(value);
    // @@protoc_insertion_point(field_set:manta.proto.KeyPress.shift)
}

// -------------------------------------------------------------------

// Click

// optional int32 x_pos = 1;
inline bool Click::_internal_has_x_pos() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Click::has_x_pos() const
{
    return _internal_has_x_pos();
}
inline void Click::clear_x_pos()
{
    _impl_.x_pos_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t Click::_internal_x_pos() const
{
    return _impl_.x_pos_;
}
inline int32_t Click::x_pos() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Click.x_pos)
    return _internal_x_pos();
}
inline void Click::_internal_set_x_pos(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.x_pos_ = value;
}
inline void Click::set_x_pos(int32_t value)
{
    _internal_set_x_pos(value);
    // @@protoc_insertion_point(field_set:manta.proto.Click.x_pos)
}

// optional int32 y_pos = 2;
inline bool Click::_internal_has_y_pos() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Click::has_y_pos() const
{
    return _internal_has_y_pos();
}
inline void Click::clear_y_pos()
{
    _impl_.y_pos_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Click::_internal_y_pos() const
{
    return _impl_.y_pos_;
}
inline int32_t Click::y_pos() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Click.y_pos)
    return _internal_y_pos();
}
inline void Click::_internal_set_y_pos(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.y_pos_ = value;
}
inline void Click::set_y_pos(int32_t value)
{
    _internal_set_y_pos(value);
    // @@protoc_insertion_point(field_set:manta.proto.Click.y_pos)
}

// optional .manta.proto.Click.Button button = 3;
inline bool Click::_internal_has_button() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool Click::has_button() const
{
    return _internal_has_button();
}
inline void Click::clear_button()
{
    _impl_.button_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::manta::proto::Click_Button Click::_internal_button() const
{
    return static_cast<::manta::proto::Click_Button>(_impl_.button_);
}
inline ::manta::proto::Click_Button Click::button() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Click.button)
    return _internal_button();
}
inline void Click::_internal_set_button(::manta::proto::Click_Button value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.button_ = value;
}
inline void Click::set_button(::manta::proto::Click_Button value)
{
    _internal_set_button(value);
    // @@protoc_insertion_point(field_set:manta.proto.Click.button)
}

// -------------------------------------------------------------------

// Scroll

// optional .manta.proto.Scroll.Direction direction = 1;
inline bool Scroll::_internal_has_direction() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Scroll::has_direction() const
{
    return _internal_has_direction();
}
inline void Scroll::clear_direction()
{
    _impl_.direction_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::manta::proto::Scroll_Direction Scroll::_internal_direction() const
{
    return static_cast<::manta::proto::Scroll_Direction>(_impl_.direction_);
}
inline ::manta::proto::Scroll_Direction Scroll::direction() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Scroll.direction)
    return _internal_direction();
}
inline void Scroll::_internal_set_direction(::manta::proto::Scroll_Direction value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.direction_ = value;
}
inline void Scroll::set_direction(::manta::proto::Scroll_Direction value)
{
    _internal_set_direction(value);
    // @@protoc_insertion_point(field_set:manta.proto.Scroll.direction)
}

// optional int32 distance = 2;
inline bool Scroll::_internal_has_distance() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Scroll::has_distance() const
{
    return _internal_has_distance();
}
inline void Scroll::clear_distance()
{
    _impl_.distance_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Scroll::_internal_distance() const
{
    return _impl_.distance_;
}
inline int32_t Scroll::distance() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Scroll.distance)
    return _internal_distance();
}
inline void Scroll::_internal_set_distance(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.distance_ = value;
}
inline void Scroll::set_distance(int32_t value)
{
    _internal_set_distance(value);
    // @@protoc_insertion_point(field_set:manta.proto.Scroll.distance)
}

// -------------------------------------------------------------------

// LaunchFile

// optional string launch_file_path = 1;
inline bool LaunchFile::_internal_has_launch_file_path() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool LaunchFile::has_launch_file_path() const
{
    return _internal_has_launch_file_path();
}
inline void LaunchFile::clear_launch_file_path()
{
    _impl_.launch_file_path_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LaunchFile::launch_file_path() const
{
    // @@protoc_insertion_point(field_get:manta.proto.LaunchFile.launch_file_path)
    return _internal_launch_file_path();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void LaunchFile::set_launch_file_path(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.launch_file_path_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.LaunchFile.launch_file_path)
}
inline std::string* LaunchFile::mutable_launch_file_path()
{
    std::string* _s = _internal_mutable_launch_file_path();
    // @@protoc_insertion_point(field_mutable:manta.proto.LaunchFile.launch_file_path)
    return _s;
}
inline const std::string& LaunchFile::_internal_launch_file_path() const
{
    return _impl_.launch_file_path_.Get();
}
inline void LaunchFile::_internal_set_launch_file_path(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.launch_file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* LaunchFile::_internal_mutable_launch_file_path()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.launch_file_path_.Mutable(GetArenaForAllocation());
}
inline std::string* LaunchFile::release_launch_file_path()
{
    // @@protoc_insertion_point(field_release:manta.proto.LaunchFile.launch_file_path)
    if (!_internal_has_launch_file_path()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.launch_file_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.launch_file_path_.IsDefault()) {
        _impl_.launch_file_path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void LaunchFile::set_allocated_launch_file_path(std::string* launch_file_path)
{
    if (launch_file_path != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.launch_file_path_.SetAllocated(launch_file_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.launch_file_path_.IsDefault()) {
        _impl_.launch_file_path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.LaunchFile.launch_file_path)
}

// -------------------------------------------------------------------

// WriteFile

// optional string name = 1;
inline bool WriteFile::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool WriteFile::has_name() const
{
    return _internal_has_name();
}
inline void WriteFile::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WriteFile::name() const
{
    // @@protoc_insertion_point(field_get:manta.proto.WriteFile.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WriteFile::set_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.WriteFile.name)
}
inline std::string* WriteFile::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:manta.proto.WriteFile.name)
    return _s;
}
inline const std::string& WriteFile::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void WriteFile::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteFile::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteFile::release_name()
{
    // @@protoc_insertion_point(field_release:manta.proto.WriteFile.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void WriteFile::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.WriteFile.name)
}

// optional string file_bytes = 2;
inline bool WriteFile::_internal_has_file_bytes() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool WriteFile::has_file_bytes() const
{
    return _internal_has_file_bytes();
}
inline void WriteFile::clear_file_bytes()
{
    _impl_.file_bytes_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WriteFile::file_bytes() const
{
    // @@protoc_insertion_point(field_get:manta.proto.WriteFile.file_bytes)
    return _internal_file_bytes();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WriteFile::set_file_bytes(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.file_bytes_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.WriteFile.file_bytes)
}
inline std::string* WriteFile::mutable_file_bytes()
{
    std::string* _s = _internal_mutable_file_bytes();
    // @@protoc_insertion_point(field_mutable:manta.proto.WriteFile.file_bytes)
    return _s;
}
inline const std::string& WriteFile::_internal_file_bytes() const
{
    return _impl_.file_bytes_.Get();
}
inline void WriteFile::_internal_set_file_bytes(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.file_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteFile::_internal_mutable_file_bytes()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.file_bytes_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteFile::release_file_bytes()
{
    // @@protoc_insertion_point(field_release:manta.proto.WriteFile.file_bytes)
    if (!_internal_has_file_bytes()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.file_bytes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.file_bytes_.IsDefault()) {
        _impl_.file_bytes_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void WriteFile::set_allocated_file_bytes(std::string* file_bytes)
{
    if (file_bytes != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.file_bytes_.SetAllocated(file_bytes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.file_bytes_.IsDefault()) {
        _impl_.file_bytes_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.WriteFile.file_bytes)
}

// -------------------------------------------------------------------

// Action

// .manta.proto.Setting update_setting = 1;
inline bool Action::_internal_has_update_setting() const
{
    return action_case() == kUpdateSetting;
}
inline bool Action::has_update_setting() const
{
    return _internal_has_update_setting();
}
inline void Action::set_has_update_setting()
{
    _impl_._oneof_case_[0] = kUpdateSetting;
}
inline void Action::clear_update_setting()
{
    if (_internal_has_update_setting()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.update_setting_;
        }
        clear_has_action();
    }
}
inline ::manta::proto::Setting* Action::release_update_setting()
{
    // @@protoc_insertion_point(field_release:manta.proto.Action.update_setting)
    if (_internal_has_update_setting()) {
        clear_has_action();
        ::manta::proto::Setting* temp = _impl_.action_.update_setting_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.action_.update_setting_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::manta::proto::Setting& Action::_internal_update_setting() const
{
    return _internal_has_update_setting() ? *_impl_.action_.update_setting_
                                          : reinterpret_cast<::manta::proto::Setting&>(::manta::proto::_Setting_default_instance_);
}
inline const ::manta::proto::Setting& Action::update_setting() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Action.update_setting)
    return _internal_update_setting();
}
inline ::manta::proto::Setting* Action::unsafe_arena_release_update_setting()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:manta.proto.Action.update_setting)
    if (_internal_has_update_setting()) {
        clear_has_action();
        ::manta::proto::Setting* temp = _impl_.action_.update_setting_;
        _impl_.action_.update_setting_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Action::unsafe_arena_set_allocated_update_setting(::manta::proto::Setting* update_setting)
{
    clear_action();
    if (update_setting) {
        set_has_update_setting();
        _impl_.action_.update_setting_ = update_setting;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.Action.update_setting)
}
inline ::manta::proto::Setting* Action::_internal_mutable_update_setting()
{
    if (!_internal_has_update_setting()) {
        clear_action();
        set_has_update_setting();
        _impl_.action_.update_setting_ = CreateMaybeMessage<::manta::proto::Setting>(GetArenaForAllocation());
    }
    return _impl_.action_.update_setting_;
}
inline ::manta::proto::Setting* Action::mutable_update_setting()
{
    ::manta::proto::Setting* _msg = _internal_mutable_update_setting();
    // @@protoc_insertion_point(field_mutable:manta.proto.Action.update_setting)
    return _msg;
}

// string launch_app_id = 2;
inline bool Action::_internal_has_launch_app_id() const
{
    return action_case() == kLaunchAppId;
}
inline bool Action::has_launch_app_id() const
{
    return _internal_has_launch_app_id();
}
inline void Action::set_has_launch_app_id()
{
    _impl_._oneof_case_[0] = kLaunchAppId;
}
inline void Action::clear_launch_app_id()
{
    if (_internal_has_launch_app_id()) {
        _impl_.action_.launch_app_id_.Destroy();
        clear_has_action();
    }
}
inline const std::string& Action::launch_app_id() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Action.launch_app_id)
    return _internal_launch_app_id();
}
template <typename ArgT0, typename... ArgT> inline void Action::set_launch_app_id(ArgT0&& arg0, ArgT... args)
{
    if (!_internal_has_launch_app_id()) {
        clear_action();
        set_has_launch_app_id();
        _impl_.action_.launch_app_id_.InitDefault();
    }
    _impl_.action_.launch_app_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.Action.launch_app_id)
}
inline std::string* Action::mutable_launch_app_id()
{
    std::string* _s = _internal_mutable_launch_app_id();
    // @@protoc_insertion_point(field_mutable:manta.proto.Action.launch_app_id)
    return _s;
}
inline const std::string& Action::_internal_launch_app_id() const
{
    if (_internal_has_launch_app_id()) {
        return _impl_.action_.launch_app_id_.Get();
    }
    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Action::_internal_set_launch_app_id(const std::string& value)
{
    if (!_internal_has_launch_app_id()) {
        clear_action();
        set_has_launch_app_id();
        _impl_.action_.launch_app_id_.InitDefault();
    }
    _impl_.action_.launch_app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Action::_internal_mutable_launch_app_id()
{
    if (!_internal_has_launch_app_id()) {
        clear_action();
        set_has_launch_app_id();
        _impl_.action_.launch_app_id_.InitDefault();
    }
    return _impl_.action_.launch_app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Action::release_launch_app_id()
{
    // @@protoc_insertion_point(field_release:manta.proto.Action.launch_app_id)
    if (_internal_has_launch_app_id()) {
        clear_has_action();
        return _impl_.action_.launch_app_id_.Release();
    } else {
        return nullptr;
    }
}
inline void Action::set_allocated_launch_app_id(std::string* launch_app_id)
{
    if (has_action()) {
        clear_action();
    }
    if (launch_app_id != nullptr) {
        set_has_launch_app_id();
        _impl_.action_.launch_app_id_.InitAllocated(launch_app_id, GetArenaForAllocation());
    }
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Action.launch_app_id)
}

// .manta.proto.Click click = 3;
inline bool Action::_internal_has_click() const
{
    return action_case() == kClick;
}
inline bool Action::has_click() const
{
    return _internal_has_click();
}
inline void Action::set_has_click()
{
    _impl_._oneof_case_[0] = kClick;
}
inline void Action::clear_click()
{
    if (_internal_has_click()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.click_;
        }
        clear_has_action();
    }
}
inline ::manta::proto::Click* Action::release_click()
{
    // @@protoc_insertion_point(field_release:manta.proto.Action.click)
    if (_internal_has_click()) {
        clear_has_action();
        ::manta::proto::Click* temp = _impl_.action_.click_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.action_.click_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::manta::proto::Click& Action::_internal_click() const
{
    return _internal_has_click() ? *_impl_.action_.click_ : reinterpret_cast<::manta::proto::Click&>(::manta::proto::_Click_default_instance_);
}
inline const ::manta::proto::Click& Action::click() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Action.click)
    return _internal_click();
}
inline ::manta::proto::Click* Action::unsafe_arena_release_click()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:manta.proto.Action.click)
    if (_internal_has_click()) {
        clear_has_action();
        ::manta::proto::Click* temp = _impl_.action_.click_;
        _impl_.action_.click_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Action::unsafe_arena_set_allocated_click(::manta::proto::Click* click)
{
    clear_action();
    if (click) {
        set_has_click();
        _impl_.action_.click_ = click;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.Action.click)
}
inline ::manta::proto::Click* Action::_internal_mutable_click()
{
    if (!_internal_has_click()) {
        clear_action();
        set_has_click();
        _impl_.action_.click_ = CreateMaybeMessage<::manta::proto::Click>(GetArenaForAllocation());
    }
    return _impl_.action_.click_;
}
inline ::manta::proto::Click* Action::mutable_click()
{
    ::manta::proto::Click* _msg = _internal_mutable_click();
    // @@protoc_insertion_point(field_mutable:manta.proto.Action.click)
    return _msg;
}

// .manta.proto.TextEntry text_entry = 4;
inline bool Action::_internal_has_text_entry() const
{
    return action_case() == kTextEntry;
}
inline bool Action::has_text_entry() const
{
    return _internal_has_text_entry();
}
inline void Action::set_has_text_entry()
{
    _impl_._oneof_case_[0] = kTextEntry;
}
inline void Action::clear_text_entry()
{
    if (_internal_has_text_entry()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.text_entry_;
        }
        clear_has_action();
    }
}
inline ::manta::proto::TextEntry* Action::release_text_entry()
{
    // @@protoc_insertion_point(field_release:manta.proto.Action.text_entry)
    if (_internal_has_text_entry()) {
        clear_has_action();
        ::manta::proto::TextEntry* temp = _impl_.action_.text_entry_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.action_.text_entry_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::manta::proto::TextEntry& Action::_internal_text_entry() const
{
    return _internal_has_text_entry() ? *_impl_.action_.text_entry_
                                      : reinterpret_cast<::manta::proto::TextEntry&>(::manta::proto::_TextEntry_default_instance_);
}
inline const ::manta::proto::TextEntry& Action::text_entry() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Action.text_entry)
    return _internal_text_entry();
}
inline ::manta::proto::TextEntry* Action::unsafe_arena_release_text_entry()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:manta.proto.Action.text_entry)
    if (_internal_has_text_entry()) {
        clear_has_action();
        ::manta::proto::TextEntry* temp = _impl_.action_.text_entry_;
        _impl_.action_.text_entry_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Action::unsafe_arena_set_allocated_text_entry(::manta::proto::TextEntry* text_entry)
{
    clear_action();
    if (text_entry) {
        set_has_text_entry();
        _impl_.action_.text_entry_ = text_entry;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.Action.text_entry)
}
inline ::manta::proto::TextEntry* Action::_internal_mutable_text_entry()
{
    if (!_internal_has_text_entry()) {
        clear_action();
        set_has_text_entry();
        _impl_.action_.text_entry_ = CreateMaybeMessage<::manta::proto::TextEntry>(GetArenaForAllocation());
    }
    return _impl_.action_.text_entry_;
}
inline ::manta::proto::TextEntry* Action::mutable_text_entry()
{
    ::manta::proto::TextEntry* _msg = _internal_mutable_text_entry();
    // @@protoc_insertion_point(field_mutable:manta.proto.Action.text_entry)
    return _msg;
}

// bool all_done = 5;
inline bool Action::_internal_has_all_done() const
{
    return action_case() == kAllDone;
}
inline bool Action::has_all_done() const
{
    return _internal_has_all_done();
}
inline void Action::set_has_all_done()
{
    _impl_._oneof_case_[0] = kAllDone;
}
inline void Action::clear_all_done()
{
    if (_internal_has_all_done()) {
        _impl_.action_.all_done_ = false;
        clear_has_action();
    }
}
inline bool Action::_internal_all_done() const
{
    if (_internal_has_all_done()) {
        return _impl_.action_.all_done_;
    }
    return false;
}
inline void Action::_internal_set_all_done(bool value)
{
    if (!_internal_has_all_done()) {
        clear_action();
        set_has_all_done();
    }
    _impl_.action_.all_done_ = value;
}
inline bool Action::all_done() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Action.all_done)
    return _internal_all_done();
}
inline void Action::set_all_done(bool value)
{
    _internal_set_all_done(value);
    // @@protoc_insertion_point(field_set:manta.proto.Action.all_done)
}

// .manta.proto.LaunchFile launch_file = 6;
inline bool Action::_internal_has_launch_file() const
{
    return action_case() == kLaunchFile;
}
inline bool Action::has_launch_file() const
{
    return _internal_has_launch_file();
}
inline void Action::set_has_launch_file()
{
    _impl_._oneof_case_[0] = kLaunchFile;
}
inline void Action::clear_launch_file()
{
    if (_internal_has_launch_file()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.launch_file_;
        }
        clear_has_action();
    }
}
inline ::manta::proto::LaunchFile* Action::release_launch_file()
{
    // @@protoc_insertion_point(field_release:manta.proto.Action.launch_file)
    if (_internal_has_launch_file()) {
        clear_has_action();
        ::manta::proto::LaunchFile* temp = _impl_.action_.launch_file_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.action_.launch_file_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::manta::proto::LaunchFile& Action::_internal_launch_file() const
{
    return _internal_has_launch_file() ? *_impl_.action_.launch_file_
                                       : reinterpret_cast<::manta::proto::LaunchFile&>(::manta::proto::_LaunchFile_default_instance_);
}
inline const ::manta::proto::LaunchFile& Action::launch_file() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Action.launch_file)
    return _internal_launch_file();
}
inline ::manta::proto::LaunchFile* Action::unsafe_arena_release_launch_file()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:manta.proto.Action.launch_file)
    if (_internal_has_launch_file()) {
        clear_has_action();
        ::manta::proto::LaunchFile* temp = _impl_.action_.launch_file_;
        _impl_.action_.launch_file_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Action::unsafe_arena_set_allocated_launch_file(::manta::proto::LaunchFile* launch_file)
{
    clear_action();
    if (launch_file) {
        set_has_launch_file();
        _impl_.action_.launch_file_ = launch_file;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.Action.launch_file)
}
inline ::manta::proto::LaunchFile* Action::_internal_mutable_launch_file()
{
    if (!_internal_has_launch_file()) {
        clear_action();
        set_has_launch_file();
        _impl_.action_.launch_file_ = CreateMaybeMessage<::manta::proto::LaunchFile>(GetArenaForAllocation());
    }
    return _impl_.action_.launch_file_;
}
inline ::manta::proto::LaunchFile* Action::mutable_launch_file()
{
    ::manta::proto::LaunchFile* _msg = _internal_mutable_launch_file();
    // @@protoc_insertion_point(field_mutable:manta.proto.Action.launch_file)
    return _msg;
}

// .manta.proto.KeyPress key_press = 7;
inline bool Action::_internal_has_key_press() const
{
    return action_case() == kKeyPress;
}
inline bool Action::has_key_press() const
{
    return _internal_has_key_press();
}
inline void Action::set_has_key_press()
{
    _impl_._oneof_case_[0] = kKeyPress;
}
inline void Action::clear_key_press()
{
    if (_internal_has_key_press()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.key_press_;
        }
        clear_has_action();
    }
}
inline ::manta::proto::KeyPress* Action::release_key_press()
{
    // @@protoc_insertion_point(field_release:manta.proto.Action.key_press)
    if (_internal_has_key_press()) {
        clear_has_action();
        ::manta::proto::KeyPress* temp = _impl_.action_.key_press_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.action_.key_press_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::manta::proto::KeyPress& Action::_internal_key_press() const
{
    return _internal_has_key_press() ? *_impl_.action_.key_press_ : reinterpret_cast<::manta::proto::KeyPress&>(::manta::proto::_KeyPress_default_instance_);
}
inline const ::manta::proto::KeyPress& Action::key_press() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Action.key_press)
    return _internal_key_press();
}
inline ::manta::proto::KeyPress* Action::unsafe_arena_release_key_press()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:manta.proto.Action.key_press)
    if (_internal_has_key_press()) {
        clear_has_action();
        ::manta::proto::KeyPress* temp = _impl_.action_.key_press_;
        _impl_.action_.key_press_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Action::unsafe_arena_set_allocated_key_press(::manta::proto::KeyPress* key_press)
{
    clear_action();
    if (key_press) {
        set_has_key_press();
        _impl_.action_.key_press_ = key_press;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.Action.key_press)
}
inline ::manta::proto::KeyPress* Action::_internal_mutable_key_press()
{
    if (!_internal_has_key_press()) {
        clear_action();
        set_has_key_press();
        _impl_.action_.key_press_ = CreateMaybeMessage<::manta::proto::KeyPress>(GetArenaForAllocation());
    }
    return _impl_.action_.key_press_;
}
inline ::manta::proto::KeyPress* Action::mutable_key_press()
{
    ::manta::proto::KeyPress* _msg = _internal_mutable_key_press();
    // @@protoc_insertion_point(field_mutable:manta.proto.Action.key_press)
    return _msg;
}

// .manta.proto.Scroll scroll = 8;
inline bool Action::_internal_has_scroll() const
{
    return action_case() == kScroll;
}
inline bool Action::has_scroll() const
{
    return _internal_has_scroll();
}
inline void Action::set_has_scroll()
{
    _impl_._oneof_case_[0] = kScroll;
}
inline void Action::clear_scroll()
{
    if (_internal_has_scroll()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.scroll_;
        }
        clear_has_action();
    }
}
inline ::manta::proto::Scroll* Action::release_scroll()
{
    // @@protoc_insertion_point(field_release:manta.proto.Action.scroll)
    if (_internal_has_scroll()) {
        clear_has_action();
        ::manta::proto::Scroll* temp = _impl_.action_.scroll_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.action_.scroll_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::manta::proto::Scroll& Action::_internal_scroll() const
{
    return _internal_has_scroll() ? *_impl_.action_.scroll_ : reinterpret_cast<::manta::proto::Scroll&>(::manta::proto::_Scroll_default_instance_);
}
inline const ::manta::proto::Scroll& Action::scroll() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Action.scroll)
    return _internal_scroll();
}
inline ::manta::proto::Scroll* Action::unsafe_arena_release_scroll()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:manta.proto.Action.scroll)
    if (_internal_has_scroll()) {
        clear_has_action();
        ::manta::proto::Scroll* temp = _impl_.action_.scroll_;
        _impl_.action_.scroll_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Action::unsafe_arena_set_allocated_scroll(::manta::proto::Scroll* scroll)
{
    clear_action();
    if (scroll) {
        set_has_scroll();
        _impl_.action_.scroll_ = scroll;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.Action.scroll)
}
inline ::manta::proto::Scroll* Action::_internal_mutable_scroll()
{
    if (!_internal_has_scroll()) {
        clear_action();
        set_has_scroll();
        _impl_.action_.scroll_ = CreateMaybeMessage<::manta::proto::Scroll>(GetArenaForAllocation());
    }
    return _impl_.action_.scroll_;
}
inline ::manta::proto::Scroll* Action::mutable_scroll()
{
    ::manta::proto::Scroll* _msg = _internal_mutable_scroll();
    // @@protoc_insertion_point(field_mutable:manta.proto.Action.scroll)
    return _msg;
}

// .manta.proto.WriteFile write_file = 9;
inline bool Action::_internal_has_write_file() const
{
    return action_case() == kWriteFile;
}
inline bool Action::has_write_file() const
{
    return _internal_has_write_file();
}
inline void Action::set_has_write_file()
{
    _impl_._oneof_case_[0] = kWriteFile;
}
inline void Action::clear_write_file()
{
    if (_internal_has_write_file()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.write_file_;
        }
        clear_has_action();
    }
}
inline ::manta::proto::WriteFile* Action::release_write_file()
{
    // @@protoc_insertion_point(field_release:manta.proto.Action.write_file)
    if (_internal_has_write_file()) {
        clear_has_action();
        ::manta::proto::WriteFile* temp = _impl_.action_.write_file_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.action_.write_file_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::manta::proto::WriteFile& Action::_internal_write_file() const
{
    return _internal_has_write_file() ? *_impl_.action_.write_file_
                                      : reinterpret_cast<::manta::proto::WriteFile&>(::manta::proto::_WriteFile_default_instance_);
}
inline const ::manta::proto::WriteFile& Action::write_file() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Action.write_file)
    return _internal_write_file();
}
inline ::manta::proto::WriteFile* Action::unsafe_arena_release_write_file()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:manta.proto.Action.write_file)
    if (_internal_has_write_file()) {
        clear_has_action();
        ::manta::proto::WriteFile* temp = _impl_.action_.write_file_;
        _impl_.action_.write_file_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Action::unsafe_arena_set_allocated_write_file(::manta::proto::WriteFile* write_file)
{
    clear_action();
    if (write_file) {
        set_has_write_file();
        _impl_.action_.write_file_ = write_file;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.Action.write_file)
}
inline ::manta::proto::WriteFile* Action::_internal_mutable_write_file()
{
    if (!_internal_has_write_file()) {
        clear_action();
        set_has_write_file();
        _impl_.action_.write_file_ = CreateMaybeMessage<::manta::proto::WriteFile>(GetArenaForAllocation());
    }
    return _impl_.action_.write_file_;
}
inline ::manta::proto::WriteFile* Action::mutable_write_file()
{
    ::manta::proto::WriteFile* _msg = _internal_mutable_write_file();
    // @@protoc_insertion_point(field_mutable:manta.proto.Action.write_file)
    return _msg;
}

inline bool Action::has_action() const
{
    return action_case() != ACTION_NOT_SET;
}
inline void Action::clear_has_action()
{
    _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline Action::ActionCase Action::action_case() const
{
    return Action::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DiagnosticsRequest

// repeated .manta.proto.Diagnostics diagnostics = 1;
inline int DiagnosticsRequest::_internal_diagnostics_size() const
{
    return _impl_.diagnostics_.size();
}
inline int DiagnosticsRequest::diagnostics_size() const
{
    return _internal_diagnostics_size();
}
inline void DiagnosticsRequest::clear_diagnostics()
{
    _impl_.diagnostics_.Clear();
}
inline ::manta::proto::Diagnostics DiagnosticsRequest::_internal_diagnostics(int index) const
{
    return static_cast<::manta::proto::Diagnostics>(_impl_.diagnostics_.Get(index));
}
inline ::manta::proto::Diagnostics DiagnosticsRequest::diagnostics(int index) const
{
    // @@protoc_insertion_point(field_get:manta.proto.DiagnosticsRequest.diagnostics)
    return _internal_diagnostics(index);
}
inline void DiagnosticsRequest::set_diagnostics(int index, ::manta::proto::Diagnostics value)
{
    _impl_.diagnostics_.Set(index, value);
    // @@protoc_insertion_point(field_set:manta.proto.DiagnosticsRequest.diagnostics)
}
inline void DiagnosticsRequest::_internal_add_diagnostics(::manta::proto::Diagnostics value)
{
    _impl_.diagnostics_.Add(value);
}
inline void DiagnosticsRequest::add_diagnostics(::manta::proto::Diagnostics value)
{
    _internal_add_diagnostics(value);
    // @@protoc_insertion_point(field_add:manta.proto.DiagnosticsRequest.diagnostics)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& DiagnosticsRequest::diagnostics() const
{
    // @@protoc_insertion_point(field_list:manta.proto.DiagnosticsRequest.diagnostics)
    return _impl_.diagnostics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* DiagnosticsRequest::_internal_mutable_diagnostics()
{
    return &_impl_.diagnostics_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* DiagnosticsRequest::mutable_diagnostics()
{
    // @@protoc_insertion_point(field_mutable_list:manta.proto.DiagnosticsRequest.diagnostics)
    return _internal_mutable_diagnostics();
}

// -------------------------------------------------------------------

// SettingsDataRequest

// -------------------------------------------------------------------

// FileRequest

// repeated string paths = 1;
inline int FileRequest::_internal_paths_size() const
{
    return _impl_.paths_.size();
}
inline int FileRequest::paths_size() const
{
    return _internal_paths_size();
}
inline void FileRequest::clear_paths()
{
    _impl_.paths_.Clear();
}
inline std::string* FileRequest::add_paths()
{
    std::string* _s = _internal_add_paths();
    // @@protoc_insertion_point(field_add_mutable:manta.proto.FileRequest.paths)
    return _s;
}
inline const std::string& FileRequest::_internal_paths(int index) const
{
    return _impl_.paths_.Get(index);
}
inline const std::string& FileRequest::paths(int index) const
{
    // @@protoc_insertion_point(field_get:manta.proto.FileRequest.paths)
    return _internal_paths(index);
}
inline std::string* FileRequest::mutable_paths(int index)
{
    // @@protoc_insertion_point(field_mutable:manta.proto.FileRequest.paths)
    return _impl_.paths_.Mutable(index);
}
inline void FileRequest::set_paths(int index, const std::string& value)
{
    _impl_.paths_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:manta.proto.FileRequest.paths)
}
inline void FileRequest::set_paths(int index, std::string&& value)
{
    _impl_.paths_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:manta.proto.FileRequest.paths)
}
inline void FileRequest::set_paths(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.paths_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:manta.proto.FileRequest.paths)
}
inline void FileRequest::set_paths(int index, const char* value, size_t size)
{
    _impl_.paths_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:manta.proto.FileRequest.paths)
}
inline std::string* FileRequest::_internal_add_paths()
{
    return _impl_.paths_.Add();
}
inline void FileRequest::add_paths(const std::string& value)
{
    _impl_.paths_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:manta.proto.FileRequest.paths)
}
inline void FileRequest::add_paths(std::string&& value)
{
    _impl_.paths_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:manta.proto.FileRequest.paths)
}
inline void FileRequest::add_paths(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.paths_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:manta.proto.FileRequest.paths)
}
inline void FileRequest::add_paths(const char* value, size_t size)
{
    _impl_.paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:manta.proto.FileRequest.paths)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& FileRequest::paths() const
{
    // @@protoc_insertion_point(field_list:manta.proto.FileRequest.paths)
    return _impl_.paths_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* FileRequest::mutable_paths()
{
    // @@protoc_insertion_point(field_mutable_list:manta.proto.FileRequest.paths)
    return &_impl_.paths_;
}

// -------------------------------------------------------------------

// File

// optional string path = 1;
inline bool File::_internal_has_path() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool File::has_path() const
{
    return _internal_has_path();
}
inline void File::clear_path()
{
    _impl_.path_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& File::path() const
{
    // @@protoc_insertion_point(field_get:manta.proto.File.path)
    return _internal_path();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void File::set_path(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.path_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.File.path)
}
inline std::string* File::mutable_path()
{
    std::string* _s = _internal_mutable_path();
    // @@protoc_insertion_point(field_mutable:manta.proto.File.path)
    return _s;
}
inline const std::string& File::_internal_path() const
{
    return _impl_.path_.Get();
}
inline void File::_internal_set_path(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_path()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_path()
{
    // @@protoc_insertion_point(field_release:manta.proto.File.path)
    if (!_internal_has_path()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.path_.IsDefault()) {
        _impl_.path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void File::set_allocated_path(std::string* path)
{
    if (path != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.path_.IsDefault()) {
        _impl_.path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.File.path)
}

// optional string name = 2;
inline bool File::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool File::has_name() const
{
    return _internal_has_name();
}
inline void File::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& File::name() const
{
    // @@protoc_insertion_point(field_get:manta.proto.File.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void File::set_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.File.name)
}
inline std::string* File::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:manta.proto.File.name)
    return _s;
}
inline const std::string& File::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void File::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_name()
{
    // @@protoc_insertion_point(field_release:manta.proto.File.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void File::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.File.name)
}

// optional int64 size_in_bytes = 3;
inline bool File::_internal_has_size_in_bytes() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool File::has_size_in_bytes() const
{
    return _internal_has_size_in_bytes();
}
inline void File::clear_size_in_bytes()
{
    _impl_.size_in_bytes_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t File::_internal_size_in_bytes() const
{
    return _impl_.size_in_bytes_;
}
inline int64_t File::size_in_bytes() const
{
    // @@protoc_insertion_point(field_get:manta.proto.File.size_in_bytes)
    return _internal_size_in_bytes();
}
inline void File::_internal_set_size_in_bytes(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.size_in_bytes_ = value;
}
inline void File::set_size_in_bytes(int64_t value)
{
    _internal_set_size_in_bytes(value);
    // @@protoc_insertion_point(field_set:manta.proto.File.size_in_bytes)
}

// optional string date_modified = 4;
inline bool File::_internal_has_date_modified() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool File::has_date_modified() const
{
    return _internal_has_date_modified();
}
inline void File::clear_date_modified()
{
    _impl_.date_modified_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& File::date_modified() const
{
    // @@protoc_insertion_point(field_get:manta.proto.File.date_modified)
    return _internal_date_modified();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void File::set_date_modified(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.date_modified_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.File.date_modified)
}
inline std::string* File::mutable_date_modified()
{
    std::string* _s = _internal_mutable_date_modified();
    // @@protoc_insertion_point(field_mutable:manta.proto.File.date_modified)
    return _s;
}
inline const std::string& File::_internal_date_modified() const
{
    return _impl_.date_modified_.Get();
}
inline void File::_internal_set_date_modified(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.date_modified_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_date_modified()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.date_modified_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_date_modified()
{
    // @@protoc_insertion_point(field_release:manta.proto.File.date_modified)
    if (!_internal_has_date_modified()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.date_modified_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.date_modified_.IsDefault()) {
        _impl_.date_modified_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void File::set_allocated_date_modified(std::string* date_modified)
{
    if (date_modified != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.date_modified_.SetAllocated(date_modified, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.date_modified_.IsDefault()) {
        _impl_.date_modified_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.File.date_modified)
}

// optional bytes serialized_bytes = 5;
inline bool File::_internal_has_serialized_bytes() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool File::has_serialized_bytes() const
{
    return _internal_has_serialized_bytes();
}
inline void File::clear_serialized_bytes()
{
    _impl_.serialized_bytes_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& File::serialized_bytes() const
{
    // @@protoc_insertion_point(field_get:manta.proto.File.serialized_bytes)
    return _internal_serialized_bytes();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void File::set_serialized_bytes(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.serialized_bytes_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.File.serialized_bytes)
}
inline std::string* File::mutable_serialized_bytes()
{
    std::string* _s = _internal_mutable_serialized_bytes();
    // @@protoc_insertion_point(field_mutable:manta.proto.File.serialized_bytes)
    return _s;
}
inline const std::string& File::_internal_serialized_bytes() const
{
    return _impl_.serialized_bytes_.Get();
}
inline void File::_internal_set_serialized_bytes(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.serialized_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_serialized_bytes()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.serialized_bytes_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_serialized_bytes()
{
    // @@protoc_insertion_point(field_release:manta.proto.File.serialized_bytes)
    if (!_internal_has_serialized_bytes()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.serialized_bytes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.serialized_bytes_.IsDefault()) {
        _impl_.serialized_bytes_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void File::set_allocated_serialized_bytes(std::string* serialized_bytes)
{
    if (serialized_bytes != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.serialized_bytes_.SetAllocated(serialized_bytes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.serialized_bytes_.IsDefault()) {
        _impl_.serialized_bytes_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.File.serialized_bytes)
}

// optional string summary = 6;
inline bool File::_internal_has_summary() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool File::has_summary() const
{
    return _internal_has_summary();
}
inline void File::clear_summary()
{
    _impl_.summary_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& File::summary() const
{
    // @@protoc_insertion_point(field_get:manta.proto.File.summary)
    return _internal_summary();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void File::set_summary(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.summary_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.File.summary)
}
inline std::string* File::mutable_summary()
{
    std::string* _s = _internal_mutable_summary();
    // @@protoc_insertion_point(field_mutable:manta.proto.File.summary)
    return _s;
}
inline const std::string& File::_internal_summary() const
{
    return _impl_.summary_.Get();
}
inline void File::_internal_set_summary(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.summary_.Set(value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_summary()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    return _impl_.summary_.Mutable(GetArenaForAllocation());
}
inline std::string* File::release_summary()
{
    // @@protoc_insertion_point(field_release:manta.proto.File.summary)
    if (!_internal_has_summary()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000010u;
    auto* p = _impl_.summary_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.summary_.IsDefault()) {
        _impl_.summary_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void File::set_allocated_summary(std::string* summary)
{
    if (summary != nullptr) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.summary_.SetAllocated(summary, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.summary_.IsDefault()) {
        _impl_.summary_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.File.summary)
}

// -------------------------------------------------------------------

// FilesData

// repeated .manta.proto.File files = 1;
inline int FilesData::_internal_files_size() const
{
    return _impl_.files_.size();
}
inline int FilesData::files_size() const
{
    return _internal_files_size();
}
inline void FilesData::clear_files()
{
    _impl_.files_.Clear();
}
inline ::manta::proto::File* FilesData::mutable_files(int index)
{
    // @@protoc_insertion_point(field_mutable:manta.proto.FilesData.files)
    return _impl_.files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::File>* FilesData::mutable_files()
{
    // @@protoc_insertion_point(field_mutable_list:manta.proto.FilesData.files)
    return &_impl_.files_;
}
inline const ::manta::proto::File& FilesData::_internal_files(int index) const
{
    return _impl_.files_.Get(index);
}
inline const ::manta::proto::File& FilesData::files(int index) const
{
    // @@protoc_insertion_point(field_get:manta.proto.FilesData.files)
    return _internal_files(index);
}
inline ::manta::proto::File* FilesData::_internal_add_files()
{
    return _impl_.files_.Add();
}
inline ::manta::proto::File* FilesData::add_files()
{
    ::manta::proto::File* _add = _internal_add_files();
    // @@protoc_insertion_point(field_add:manta.proto.FilesData.files)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::File>& FilesData::files() const
{
    // @@protoc_insertion_point(field_list:manta.proto.FilesData.files)
    return _impl_.files_;
}

// -------------------------------------------------------------------

// Update

// optional .manta.proto.FilesData files_with_summary = 1;
inline bool Update::_internal_has_files_with_summary() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.files_with_summary_ != nullptr);
    return value;
}
inline bool Update::has_files_with_summary() const
{
    return _internal_has_files_with_summary();
}
inline void Update::clear_files_with_summary()
{
    if (_impl_.files_with_summary_ != nullptr)
        _impl_.files_with_summary_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::manta::proto::FilesData& Update::_internal_files_with_summary() const
{
    const ::manta::proto::FilesData* p = _impl_.files_with_summary_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::FilesData&>(::manta::proto::_FilesData_default_instance_);
}
inline const ::manta::proto::FilesData& Update::files_with_summary() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Update.files_with_summary)
    return _internal_files_with_summary();
}
inline void Update::unsafe_arena_set_allocated_files_with_summary(::manta::proto::FilesData* files_with_summary)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.files_with_summary_);
    }
    _impl_.files_with_summary_ = files_with_summary;
    if (files_with_summary) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.Update.files_with_summary)
}
inline ::manta::proto::FilesData* Update::release_files_with_summary()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::FilesData* temp = _impl_.files_with_summary_;
    _impl_.files_with_summary_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::FilesData* Update::unsafe_arena_release_files_with_summary()
{
    // @@protoc_insertion_point(field_release:manta.proto.Update.files_with_summary)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::FilesData* temp = _impl_.files_with_summary_;
    _impl_.files_with_summary_ = nullptr;
    return temp;
}
inline ::manta::proto::FilesData* Update::_internal_mutable_files_with_summary()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.files_with_summary_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::FilesData>(GetArenaForAllocation());
        _impl_.files_with_summary_ = p;
    }
    return _impl_.files_with_summary_;
}
inline ::manta::proto::FilesData* Update::mutable_files_with_summary()
{
    ::manta::proto::FilesData* _msg = _internal_mutable_files_with_summary();
    // @@protoc_insertion_point(field_mutable:manta.proto.Update.files_with_summary)
    return _msg;
}
inline void Update::set_allocated_files_with_summary(::manta::proto::FilesData* files_with_summary)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.files_with_summary_;
    }
    if (files_with_summary) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(files_with_summary);
        if (message_arena != submessage_arena) {
            files_with_summary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, files_with_summary, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.files_with_summary_ = files_with_summary;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Update.files_with_summary)
}

// -------------------------------------------------------------------

// ContextRequest

// optional .manta.proto.DiagnosticsRequest diagnostics = 1;
inline bool ContextRequest::_internal_has_diagnostics() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.diagnostics_ != nullptr);
    return value;
}
inline bool ContextRequest::has_diagnostics() const
{
    return _internal_has_diagnostics();
}
inline void ContextRequest::clear_diagnostics()
{
    if (_impl_.diagnostics_ != nullptr)
        _impl_.diagnostics_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::manta::proto::DiagnosticsRequest& ContextRequest::_internal_diagnostics() const
{
    const ::manta::proto::DiagnosticsRequest* p = _impl_.diagnostics_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::DiagnosticsRequest&>(::manta::proto::_DiagnosticsRequest_default_instance_);
}
inline const ::manta::proto::DiagnosticsRequest& ContextRequest::diagnostics() const
{
    // @@protoc_insertion_point(field_get:manta.proto.ContextRequest.diagnostics)
    return _internal_diagnostics();
}
inline void ContextRequest::unsafe_arena_set_allocated_diagnostics(::manta::proto::DiagnosticsRequest* diagnostics)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.diagnostics_);
    }
    _impl_.diagnostics_ = diagnostics;
    if (diagnostics) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.ContextRequest.diagnostics)
}
inline ::manta::proto::DiagnosticsRequest* ContextRequest::release_diagnostics()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::DiagnosticsRequest* temp = _impl_.diagnostics_;
    _impl_.diagnostics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::DiagnosticsRequest* ContextRequest::unsafe_arena_release_diagnostics()
{
    // @@protoc_insertion_point(field_release:manta.proto.ContextRequest.diagnostics)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::DiagnosticsRequest* temp = _impl_.diagnostics_;
    _impl_.diagnostics_ = nullptr;
    return temp;
}
inline ::manta::proto::DiagnosticsRequest* ContextRequest::_internal_mutable_diagnostics()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.diagnostics_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::DiagnosticsRequest>(GetArenaForAllocation());
        _impl_.diagnostics_ = p;
    }
    return _impl_.diagnostics_;
}
inline ::manta::proto::DiagnosticsRequest* ContextRequest::mutable_diagnostics()
{
    ::manta::proto::DiagnosticsRequest* _msg = _internal_mutable_diagnostics();
    // @@protoc_insertion_point(field_mutable:manta.proto.ContextRequest.diagnostics)
    return _msg;
}
inline void ContextRequest::set_allocated_diagnostics(::manta::proto::DiagnosticsRequest* diagnostics)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.diagnostics_;
    }
    if (diagnostics) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(diagnostics);
        if (message_arena != submessage_arena) {
            diagnostics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, diagnostics, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.diagnostics_ = diagnostics;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.ContextRequest.diagnostics)
}

// optional .manta.proto.FileRequest files = 2;
inline bool ContextRequest::_internal_has_files() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.files_ != nullptr);
    return value;
}
inline bool ContextRequest::has_files() const
{
    return _internal_has_files();
}
inline void ContextRequest::clear_files()
{
    if (_impl_.files_ != nullptr)
        _impl_.files_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::manta::proto::FileRequest& ContextRequest::_internal_files() const
{
    const ::manta::proto::FileRequest* p = _impl_.files_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::FileRequest&>(::manta::proto::_FileRequest_default_instance_);
}
inline const ::manta::proto::FileRequest& ContextRequest::files() const
{
    // @@protoc_insertion_point(field_get:manta.proto.ContextRequest.files)
    return _internal_files();
}
inline void ContextRequest::unsafe_arena_set_allocated_files(::manta::proto::FileRequest* files)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.files_);
    }
    _impl_.files_ = files;
    if (files) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.ContextRequest.files)
}
inline ::manta::proto::FileRequest* ContextRequest::release_files()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::manta::proto::FileRequest* temp = _impl_.files_;
    _impl_.files_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::FileRequest* ContextRequest::unsafe_arena_release_files()
{
    // @@protoc_insertion_point(field_release:manta.proto.ContextRequest.files)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::manta::proto::FileRequest* temp = _impl_.files_;
    _impl_.files_ = nullptr;
    return temp;
}
inline ::manta::proto::FileRequest* ContextRequest::_internal_mutable_files()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.files_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::FileRequest>(GetArenaForAllocation());
        _impl_.files_ = p;
    }
    return _impl_.files_;
}
inline ::manta::proto::FileRequest* ContextRequest::mutable_files()
{
    ::manta::proto::FileRequest* _msg = _internal_mutable_files();
    // @@protoc_insertion_point(field_mutable:manta.proto.ContextRequest.files)
    return _msg;
}
inline void ContextRequest::set_allocated_files(::manta::proto::FileRequest* files)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.files_;
    }
    if (files) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(files);
        if (message_arena != submessage_arena) {
            files = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, files, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.files_ = files;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.ContextRequest.files)
}

// optional .manta.proto.SettingsDataRequest settings = 3;
inline bool ContextRequest::_internal_has_settings() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.settings_ != nullptr);
    return value;
}
inline bool ContextRequest::has_settings() const
{
    return _internal_has_settings();
}
inline void ContextRequest::clear_settings()
{
    if (_impl_.settings_ != nullptr)
        _impl_.settings_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::manta::proto::SettingsDataRequest& ContextRequest::_internal_settings() const
{
    const ::manta::proto::SettingsDataRequest* p = _impl_.settings_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::SettingsDataRequest&>(::manta::proto::_SettingsDataRequest_default_instance_);
}
inline const ::manta::proto::SettingsDataRequest& ContextRequest::settings() const
{
    // @@protoc_insertion_point(field_get:manta.proto.ContextRequest.settings)
    return _internal_settings();
}
inline void ContextRequest::unsafe_arena_set_allocated_settings(::manta::proto::SettingsDataRequest* settings)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settings_);
    }
    _impl_.settings_ = settings;
    if (settings) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.ContextRequest.settings)
}
inline ::manta::proto::SettingsDataRequest* ContextRequest::release_settings()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::manta::proto::SettingsDataRequest* temp = _impl_.settings_;
    _impl_.settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::SettingsDataRequest* ContextRequest::unsafe_arena_release_settings()
{
    // @@protoc_insertion_point(field_release:manta.proto.ContextRequest.settings)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::manta::proto::SettingsDataRequest* temp = _impl_.settings_;
    _impl_.settings_ = nullptr;
    return temp;
}
inline ::manta::proto::SettingsDataRequest* ContextRequest::_internal_mutable_settings()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.settings_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::SettingsDataRequest>(GetArenaForAllocation());
        _impl_.settings_ = p;
    }
    return _impl_.settings_;
}
inline ::manta::proto::SettingsDataRequest* ContextRequest::mutable_settings()
{
    ::manta::proto::SettingsDataRequest* _msg = _internal_mutable_settings();
    // @@protoc_insertion_point(field_mutable:manta.proto.ContextRequest.settings)
    return _msg;
}
inline void ContextRequest::set_allocated_settings(::manta::proto::SettingsDataRequest* settings)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.settings_;
    }
    if (settings) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settings);
        if (message_arena != submessage_arena) {
            settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, settings, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.settings_ = settings;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.ContextRequest.settings)
}

// -------------------------------------------------------------------

// Turn

// optional string message = 1;
inline bool Turn::_internal_has_message() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Turn::has_message() const
{
    return _internal_has_message();
}
inline void Turn::clear_message()
{
    _impl_.message_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Turn::message() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Turn.message)
    return _internal_message();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Turn::set_message(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.message_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.Turn.message)
}
inline std::string* Turn::mutable_message()
{
    std::string* _s = _internal_mutable_message();
    // @@protoc_insertion_point(field_mutable:manta.proto.Turn.message)
    return _s;
}
inline const std::string& Turn::_internal_message() const
{
    return _impl_.message_.Get();
}
inline void Turn::_internal_set_message(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Turn::_internal_mutable_message()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Turn::release_message()
{
    // @@protoc_insertion_point(field_release:manta.proto.Turn.message)
    if (!_internal_has_message()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.message_.IsDefault()) {
        _impl_.message_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Turn::set_allocated_message(std::string* message)
{
    if (message != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.message_.IsDefault()) {
        _impl_.message_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Turn.message)
}

// optional .manta.proto.Role role = 2;
inline bool Turn::_internal_has_role() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool Turn::has_role() const
{
    return _internal_has_role();
}
inline void Turn::clear_role()
{
    _impl_.role_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::manta::proto::Role Turn::_internal_role() const
{
    return static_cast<::manta::proto::Role>(_impl_.role_);
}
inline ::manta::proto::Role Turn::role() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Turn.role)
    return _internal_role();
}
inline void Turn::_internal_set_role(::manta::proto::Role value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.role_ = value;
}
inline void Turn::set_role(::manta::proto::Role value)
{
    _internal_set_role(value);
    // @@protoc_insertion_point(field_set:manta.proto.Turn.role)
}

// repeated .manta.proto.Action action = 3;
inline int Turn::_internal_action_size() const
{
    return _impl_.action_.size();
}
inline int Turn::action_size() const
{
    return _internal_action_size();
}
inline void Turn::clear_action()
{
    _impl_.action_.Clear();
}
inline ::manta::proto::Action* Turn::mutable_action(int index)
{
    // @@protoc_insertion_point(field_mutable:manta.proto.Turn.action)
    return _impl_.action_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Action>* Turn::mutable_action()
{
    // @@protoc_insertion_point(field_mutable_list:manta.proto.Turn.action)
    return &_impl_.action_;
}
inline const ::manta::proto::Action& Turn::_internal_action(int index) const
{
    return _impl_.action_.Get(index);
}
inline const ::manta::proto::Action& Turn::action(int index) const
{
    // @@protoc_insertion_point(field_get:manta.proto.Turn.action)
    return _internal_action(index);
}
inline ::manta::proto::Action* Turn::_internal_add_action()
{
    return _impl_.action_.Add();
}
inline ::manta::proto::Action* Turn::add_action()
{
    ::manta::proto::Action* _add = _internal_add_action();
    // @@protoc_insertion_point(field_add:manta.proto.Turn.action)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Action>& Turn::action() const
{
    // @@protoc_insertion_point(field_list:manta.proto.Turn.action)
    return _impl_.action_;
}

// optional .manta.proto.Image screenshot = 4;
inline bool Turn::_internal_has_screenshot() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.screenshot_ != nullptr);
    return value;
}
inline bool Turn::has_screenshot() const
{
    return _internal_has_screenshot();
}
inline const ::manta::proto::Image& Turn::_internal_screenshot() const
{
    const ::manta::proto::Image* p = _impl_.screenshot_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::Image&>(::manta::proto::_Image_default_instance_);
}
inline const ::manta::proto::Image& Turn::screenshot() const
{
    // @@protoc_insertion_point(field_get:manta.proto.Turn.screenshot)
    return _internal_screenshot();
}
inline void Turn::unsafe_arena_set_allocated_screenshot(::manta::proto::Image* screenshot)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.screenshot_);
    }
    _impl_.screenshot_ = screenshot;
    if (screenshot) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.Turn.screenshot)
}
inline ::manta::proto::Image* Turn::release_screenshot()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::manta::proto::Image* temp = _impl_.screenshot_;
    _impl_.screenshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::Image* Turn::unsafe_arena_release_screenshot()
{
    // @@protoc_insertion_point(field_release:manta.proto.Turn.screenshot)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::manta::proto::Image* temp = _impl_.screenshot_;
    _impl_.screenshot_ = nullptr;
    return temp;
}
inline ::manta::proto::Image* Turn::_internal_mutable_screenshot()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.screenshot_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::Image>(GetArenaForAllocation());
        _impl_.screenshot_ = p;
    }
    return _impl_.screenshot_;
}
inline ::manta::proto::Image* Turn::mutable_screenshot()
{
    ::manta::proto::Image* _msg = _internal_mutable_screenshot();
    // @@protoc_insertion_point(field_mutable:manta.proto.Turn.screenshot)
    return _msg;
}
inline void Turn::set_allocated_screenshot(::manta::proto::Image* screenshot)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.screenshot_);
    }
    if (screenshot) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(screenshot));
        if (message_arena != submessage_arena) {
            screenshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, screenshot, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.screenshot_ = screenshot;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Turn.screenshot)
}

// -------------------------------------------------------------------

// SparkyResponse

// optional .manta.proto.ContextRequest context_request = 1;
inline bool SparkyResponse::_internal_has_context_request() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.context_request_ != nullptr);
    return value;
}
inline bool SparkyResponse::has_context_request() const
{
    return _internal_has_context_request();
}
inline void SparkyResponse::clear_context_request()
{
    if (_impl_.context_request_ != nullptr)
        _impl_.context_request_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::manta::proto::ContextRequest& SparkyResponse::_internal_context_request() const
{
    const ::manta::proto::ContextRequest* p = _impl_.context_request_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::ContextRequest&>(::manta::proto::_ContextRequest_default_instance_);
}
inline const ::manta::proto::ContextRequest& SparkyResponse::context_request() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SparkyResponse.context_request)
    return _internal_context_request();
}
inline void SparkyResponse::unsafe_arena_set_allocated_context_request(::manta::proto::ContextRequest* context_request)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_request_);
    }
    _impl_.context_request_ = context_request;
    if (context_request) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.SparkyResponse.context_request)
}
inline ::manta::proto::ContextRequest* SparkyResponse::release_context_request()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::ContextRequest* temp = _impl_.context_request_;
    _impl_.context_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::ContextRequest* SparkyResponse::unsafe_arena_release_context_request()
{
    // @@protoc_insertion_point(field_release:manta.proto.SparkyResponse.context_request)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::ContextRequest* temp = _impl_.context_request_;
    _impl_.context_request_ = nullptr;
    return temp;
}
inline ::manta::proto::ContextRequest* SparkyResponse::_internal_mutable_context_request()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.context_request_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::ContextRequest>(GetArenaForAllocation());
        _impl_.context_request_ = p;
    }
    return _impl_.context_request_;
}
inline ::manta::proto::ContextRequest* SparkyResponse::mutable_context_request()
{
    ::manta::proto::ContextRequest* _msg = _internal_mutable_context_request();
    // @@protoc_insertion_point(field_mutable:manta.proto.SparkyResponse.context_request)
    return _msg;
}
inline void SparkyResponse::set_allocated_context_request(::manta::proto::ContextRequest* context_request)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.context_request_;
    }
    if (context_request) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context_request);
        if (message_arena != submessage_arena) {
            context_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, context_request, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.context_request_ = context_request;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.SparkyResponse.context_request)
}

// optional .manta.proto.Turn latest_reply = 2;
inline bool SparkyResponse::_internal_has_latest_reply() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.latest_reply_ != nullptr);
    return value;
}
inline bool SparkyResponse::has_latest_reply() const
{
    return _internal_has_latest_reply();
}
inline void SparkyResponse::clear_latest_reply()
{
    if (_impl_.latest_reply_ != nullptr)
        _impl_.latest_reply_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::manta::proto::Turn& SparkyResponse::_internal_latest_reply() const
{
    const ::manta::proto::Turn* p = _impl_.latest_reply_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::Turn&>(::manta::proto::_Turn_default_instance_);
}
inline const ::manta::proto::Turn& SparkyResponse::latest_reply() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SparkyResponse.latest_reply)
    return _internal_latest_reply();
}
inline void SparkyResponse::unsafe_arena_set_allocated_latest_reply(::manta::proto::Turn* latest_reply)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.latest_reply_);
    }
    _impl_.latest_reply_ = latest_reply;
    if (latest_reply) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.SparkyResponse.latest_reply)
}
inline ::manta::proto::Turn* SparkyResponse::release_latest_reply()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::manta::proto::Turn* temp = _impl_.latest_reply_;
    _impl_.latest_reply_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::Turn* SparkyResponse::unsafe_arena_release_latest_reply()
{
    // @@protoc_insertion_point(field_release:manta.proto.SparkyResponse.latest_reply)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::manta::proto::Turn* temp = _impl_.latest_reply_;
    _impl_.latest_reply_ = nullptr;
    return temp;
}
inline ::manta::proto::Turn* SparkyResponse::_internal_mutable_latest_reply()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.latest_reply_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::Turn>(GetArenaForAllocation());
        _impl_.latest_reply_ = p;
    }
    return _impl_.latest_reply_;
}
inline ::manta::proto::Turn* SparkyResponse::mutable_latest_reply()
{
    ::manta::proto::Turn* _msg = _internal_mutable_latest_reply();
    // @@protoc_insertion_point(field_mutable:manta.proto.SparkyResponse.latest_reply)
    return _msg;
}
inline void SparkyResponse::set_allocated_latest_reply(::manta::proto::Turn* latest_reply)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.latest_reply_;
    }
    if (latest_reply) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(latest_reply);
        if (message_arena != submessage_arena) {
            latest_reply = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, latest_reply, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.latest_reply_ = latest_reply;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.SparkyResponse.latest_reply)
}

// optional .manta.proto.Update update = 3;
inline bool SparkyResponse::_internal_has_update() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.update_ != nullptr);
    return value;
}
inline bool SparkyResponse::has_update() const
{
    return _internal_has_update();
}
inline void SparkyResponse::clear_update()
{
    if (_impl_.update_ != nullptr)
        _impl_.update_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::manta::proto::Update& SparkyResponse::_internal_update() const
{
    const ::manta::proto::Update* p = _impl_.update_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::Update&>(::manta::proto::_Update_default_instance_);
}
inline const ::manta::proto::Update& SparkyResponse::update() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SparkyResponse.update)
    return _internal_update();
}
inline void SparkyResponse::unsafe_arena_set_allocated_update(::manta::proto::Update* update)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.update_);
    }
    _impl_.update_ = update;
    if (update) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.SparkyResponse.update)
}
inline ::manta::proto::Update* SparkyResponse::release_update()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::manta::proto::Update* temp = _impl_.update_;
    _impl_.update_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::Update* SparkyResponse::unsafe_arena_release_update()
{
    // @@protoc_insertion_point(field_release:manta.proto.SparkyResponse.update)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::manta::proto::Update* temp = _impl_.update_;
    _impl_.update_ = nullptr;
    return temp;
}
inline ::manta::proto::Update* SparkyResponse::_internal_mutable_update()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.update_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::Update>(GetArenaForAllocation());
        _impl_.update_ = p;
    }
    return _impl_.update_;
}
inline ::manta::proto::Update* SparkyResponse::mutable_update()
{
    ::manta::proto::Update* _msg = _internal_mutable_update();
    // @@protoc_insertion_point(field_mutable:manta.proto.SparkyResponse.update)
    return _msg;
}
inline void SparkyResponse::set_allocated_update(::manta::proto::Update* update)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.update_;
    }
    if (update) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(update);
        if (message_arena != submessage_arena) {
            update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, update, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.update_ = update;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.SparkyResponse.update)
}

// -------------------------------------------------------------------

// WebContent

// optional string page_contents = 1;
inline bool WebContent::_internal_has_page_contents() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool WebContent::has_page_contents() const
{
    return _internal_has_page_contents();
}
inline void WebContent::clear_page_contents()
{
    _impl_.page_contents_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WebContent::page_contents() const
{
    // @@protoc_insertion_point(field_get:manta.proto.WebContent.page_contents)
    return _internal_page_contents();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WebContent::set_page_contents(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.page_contents_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.WebContent.page_contents)
}
inline std::string* WebContent::mutable_page_contents()
{
    std::string* _s = _internal_mutable_page_contents();
    // @@protoc_insertion_point(field_mutable:manta.proto.WebContent.page_contents)
    return _s;
}
inline const std::string& WebContent::_internal_page_contents() const
{
    return _impl_.page_contents_.Get();
}
inline void WebContent::_internal_set_page_contents(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.page_contents_.Set(value, GetArenaForAllocation());
}
inline std::string* WebContent::_internal_mutable_page_contents()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.page_contents_.Mutable(GetArenaForAllocation());
}
inline std::string* WebContent::release_page_contents()
{
    // @@protoc_insertion_point(field_release:manta.proto.WebContent.page_contents)
    if (!_internal_has_page_contents()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.page_contents_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.page_contents_.IsDefault()) {
        _impl_.page_contents_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void WebContent::set_allocated_page_contents(std::string* page_contents)
{
    if (page_contents != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.page_contents_.SetAllocated(page_contents, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.page_contents_.IsDefault()) {
        _impl_.page_contents_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.WebContent.page_contents)
}

// optional string page_url = 2;
inline bool WebContent::_internal_has_page_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool WebContent::has_page_url() const
{
    return _internal_has_page_url();
}
inline void WebContent::clear_page_url()
{
    _impl_.page_url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WebContent::page_url() const
{
    // @@protoc_insertion_point(field_get:manta.proto.WebContent.page_url)
    return _internal_page_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WebContent::set_page_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.page_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:manta.proto.WebContent.page_url)
}
inline std::string* WebContent::mutable_page_url()
{
    std::string* _s = _internal_mutable_page_url();
    // @@protoc_insertion_point(field_mutable:manta.proto.WebContent.page_url)
    return _s;
}
inline const std::string& WebContent::_internal_page_url() const
{
    return _impl_.page_url_.Get();
}
inline void WebContent::_internal_set_page_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.page_url_.Set(value, GetArenaForAllocation());
}
inline std::string* WebContent::_internal_mutable_page_url()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.page_url_.Mutable(GetArenaForAllocation());
}
inline std::string* WebContent::release_page_url()
{
    // @@protoc_insertion_point(field_release:manta.proto.WebContent.page_url)
    if (!_internal_has_page_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.page_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.page_url_.IsDefault()) {
        _impl_.page_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void WebContent::set_allocated_page_url(std::string* page_url)
{
    if (page_url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.page_url_.SetAllocated(page_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.page_url_.IsDefault()) {
        _impl_.page_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:manta.proto.WebContent.page_url)
}

// -------------------------------------------------------------------

// SparkyContextData

// optional .manta.proto.Task task = 1;
inline bool SparkyContextData::_internal_has_task() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool SparkyContextData::has_task() const
{
    return _internal_has_task();
}
inline void SparkyContextData::clear_task()
{
    _impl_.task_ = 0;
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::manta::proto::Task SparkyContextData::_internal_task() const
{
    return static_cast<::manta::proto::Task>(_impl_.task_);
}
inline ::manta::proto::Task SparkyContextData::task() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SparkyContextData.task)
    return _internal_task();
}
inline void SparkyContextData::_internal_set_task(::manta::proto::Task value)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.task_ = value;
}
inline void SparkyContextData::set_task(::manta::proto::Task value)
{
    _internal_set_task(value);
    // @@protoc_insertion_point(field_set:manta.proto.SparkyContextData.task)
}

// optional .manta.proto.DiagnosticsData diagnostics_data = 2;
inline bool SparkyContextData::_internal_has_diagnostics_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.diagnostics_data_ != nullptr);
    return value;
}
inline bool SparkyContextData::has_diagnostics_data() const
{
    return _internal_has_diagnostics_data();
}
inline void SparkyContextData::clear_diagnostics_data()
{
    if (_impl_.diagnostics_data_ != nullptr)
        _impl_.diagnostics_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::manta::proto::DiagnosticsData& SparkyContextData::_internal_diagnostics_data() const
{
    const ::manta::proto::DiagnosticsData* p = _impl_.diagnostics_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::DiagnosticsData&>(::manta::proto::_DiagnosticsData_default_instance_);
}
inline const ::manta::proto::DiagnosticsData& SparkyContextData::diagnostics_data() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SparkyContextData.diagnostics_data)
    return _internal_diagnostics_data();
}
inline void SparkyContextData::unsafe_arena_set_allocated_diagnostics_data(::manta::proto::DiagnosticsData* diagnostics_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.diagnostics_data_);
    }
    _impl_.diagnostics_data_ = diagnostics_data;
    if (diagnostics_data) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.SparkyContextData.diagnostics_data)
}
inline ::manta::proto::DiagnosticsData* SparkyContextData::release_diagnostics_data()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::DiagnosticsData* temp = _impl_.diagnostics_data_;
    _impl_.diagnostics_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::DiagnosticsData* SparkyContextData::unsafe_arena_release_diagnostics_data()
{
    // @@protoc_insertion_point(field_release:manta.proto.SparkyContextData.diagnostics_data)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::manta::proto::DiagnosticsData* temp = _impl_.diagnostics_data_;
    _impl_.diagnostics_data_ = nullptr;
    return temp;
}
inline ::manta::proto::DiagnosticsData* SparkyContextData::_internal_mutable_diagnostics_data()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.diagnostics_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::DiagnosticsData>(GetArenaForAllocation());
        _impl_.diagnostics_data_ = p;
    }
    return _impl_.diagnostics_data_;
}
inline ::manta::proto::DiagnosticsData* SparkyContextData::mutable_diagnostics_data()
{
    ::manta::proto::DiagnosticsData* _msg = _internal_mutable_diagnostics_data();
    // @@protoc_insertion_point(field_mutable:manta.proto.SparkyContextData.diagnostics_data)
    return _msg;
}
inline void SparkyContextData::set_allocated_diagnostics_data(::manta::proto::DiagnosticsData* diagnostics_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.diagnostics_data_;
    }
    if (diagnostics_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(diagnostics_data);
        if (message_arena != submessage_arena) {
            diagnostics_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, diagnostics_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.diagnostics_data_ = diagnostics_data;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.SparkyContextData.diagnostics_data)
}

// optional .manta.proto.SettingsData settings_data = 3;
inline bool SparkyContextData::_internal_has_settings_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.settings_data_ != nullptr);
    return value;
}
inline bool SparkyContextData::has_settings_data() const
{
    return _internal_has_settings_data();
}
inline void SparkyContextData::clear_settings_data()
{
    if (_impl_.settings_data_ != nullptr)
        _impl_.settings_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::manta::proto::SettingsData& SparkyContextData::_internal_settings_data() const
{
    const ::manta::proto::SettingsData* p = _impl_.settings_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::SettingsData&>(::manta::proto::_SettingsData_default_instance_);
}
inline const ::manta::proto::SettingsData& SparkyContextData::settings_data() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SparkyContextData.settings_data)
    return _internal_settings_data();
}
inline void SparkyContextData::unsafe_arena_set_allocated_settings_data(::manta::proto::SettingsData* settings_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.settings_data_);
    }
    _impl_.settings_data_ = settings_data;
    if (settings_data) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.SparkyContextData.settings_data)
}
inline ::manta::proto::SettingsData* SparkyContextData::release_settings_data()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::manta::proto::SettingsData* temp = _impl_.settings_data_;
    _impl_.settings_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::SettingsData* SparkyContextData::unsafe_arena_release_settings_data()
{
    // @@protoc_insertion_point(field_release:manta.proto.SparkyContextData.settings_data)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::manta::proto::SettingsData* temp = _impl_.settings_data_;
    _impl_.settings_data_ = nullptr;
    return temp;
}
inline ::manta::proto::SettingsData* SparkyContextData::_internal_mutable_settings_data()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.settings_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::SettingsData>(GetArenaForAllocation());
        _impl_.settings_data_ = p;
    }
    return _impl_.settings_data_;
}
inline ::manta::proto::SettingsData* SparkyContextData::mutable_settings_data()
{
    ::manta::proto::SettingsData* _msg = _internal_mutable_settings_data();
    // @@protoc_insertion_point(field_mutable:manta.proto.SparkyContextData.settings_data)
    return _msg;
}
inline void SparkyContextData::set_allocated_settings_data(::manta::proto::SettingsData* settings_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.settings_data_;
    }
    if (settings_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settings_data);
        if (message_arena != submessage_arena) {
            settings_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, settings_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.settings_data_ = settings_data;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.SparkyContextData.settings_data)
}

// repeated .manta.proto.Turn conversation = 4;
inline int SparkyContextData::_internal_conversation_size() const
{
    return _impl_.conversation_.size();
}
inline int SparkyContextData::conversation_size() const
{
    return _internal_conversation_size();
}
inline void SparkyContextData::clear_conversation()
{
    _impl_.conversation_.Clear();
}
inline ::manta::proto::Turn* SparkyContextData::mutable_conversation(int index)
{
    // @@protoc_insertion_point(field_mutable:manta.proto.SparkyContextData.conversation)
    return _impl_.conversation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Turn>* SparkyContextData::mutable_conversation()
{
    // @@protoc_insertion_point(field_mutable_list:manta.proto.SparkyContextData.conversation)
    return &_impl_.conversation_;
}
inline const ::manta::proto::Turn& SparkyContextData::_internal_conversation(int index) const
{
    return _impl_.conversation_.Get(index);
}
inline const ::manta::proto::Turn& SparkyContextData::conversation(int index) const
{
    // @@protoc_insertion_point(field_get:manta.proto.SparkyContextData.conversation)
    return _internal_conversation(index);
}
inline ::manta::proto::Turn* SparkyContextData::_internal_add_conversation()
{
    return _impl_.conversation_.Add();
}
inline ::manta::proto::Turn* SparkyContextData::add_conversation()
{
    ::manta::proto::Turn* _add = _internal_add_conversation();
    // @@protoc_insertion_point(field_add:manta.proto.SparkyContextData.conversation)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::manta::proto::Turn>& SparkyContextData::conversation() const
{
    // @@protoc_insertion_point(field_list:manta.proto.SparkyContextData.conversation)
    return _impl_.conversation_;
}

// optional .manta.proto.Image screenshot = 5;
inline bool SparkyContextData::_internal_has_screenshot() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.screenshot_ != nullptr);
    return value;
}
inline bool SparkyContextData::has_screenshot() const
{
    return _internal_has_screenshot();
}
inline const ::manta::proto::Image& SparkyContextData::_internal_screenshot() const
{
    const ::manta::proto::Image* p = _impl_.screenshot_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::Image&>(::manta::proto::_Image_default_instance_);
}
inline const ::manta::proto::Image& SparkyContextData::screenshot() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SparkyContextData.screenshot)
    return _internal_screenshot();
}
inline void SparkyContextData::unsafe_arena_set_allocated_screenshot(::manta::proto::Image* screenshot)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.screenshot_);
    }
    _impl_.screenshot_ = screenshot;
    if (screenshot) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.SparkyContextData.screenshot)
}
inline ::manta::proto::Image* SparkyContextData::release_screenshot()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::manta::proto::Image* temp = _impl_.screenshot_;
    _impl_.screenshot_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::Image* SparkyContextData::unsafe_arena_release_screenshot()
{
    // @@protoc_insertion_point(field_release:manta.proto.SparkyContextData.screenshot)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::manta::proto::Image* temp = _impl_.screenshot_;
    _impl_.screenshot_ = nullptr;
    return temp;
}
inline ::manta::proto::Image* SparkyContextData::_internal_mutable_screenshot()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.screenshot_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::Image>(GetArenaForAllocation());
        _impl_.screenshot_ = p;
    }
    return _impl_.screenshot_;
}
inline ::manta::proto::Image* SparkyContextData::mutable_screenshot()
{
    ::manta::proto::Image* _msg = _internal_mutable_screenshot();
    // @@protoc_insertion_point(field_mutable:manta.proto.SparkyContextData.screenshot)
    return _msg;
}
inline void SparkyContextData::set_allocated_screenshot(::manta::proto::Image* screenshot)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.screenshot_);
    }
    if (screenshot) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(screenshot));
        if (message_arena != submessage_arena) {
            screenshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, screenshot, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.screenshot_ = screenshot;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.SparkyContextData.screenshot)
}

// optional .manta.proto.AppsData apps_data = 6;
inline bool SparkyContextData::_internal_has_apps_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.apps_data_ != nullptr);
    return value;
}
inline bool SparkyContextData::has_apps_data() const
{
    return _internal_has_apps_data();
}
inline void SparkyContextData::clear_apps_data()
{
    if (_impl_.apps_data_ != nullptr)
        _impl_.apps_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::manta::proto::AppsData& SparkyContextData::_internal_apps_data() const
{
    const ::manta::proto::AppsData* p = _impl_.apps_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::AppsData&>(::manta::proto::_AppsData_default_instance_);
}
inline const ::manta::proto::AppsData& SparkyContextData::apps_data() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SparkyContextData.apps_data)
    return _internal_apps_data();
}
inline void SparkyContextData::unsafe_arena_set_allocated_apps_data(::manta::proto::AppsData* apps_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.apps_data_);
    }
    _impl_.apps_data_ = apps_data;
    if (apps_data) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.SparkyContextData.apps_data)
}
inline ::manta::proto::AppsData* SparkyContextData::release_apps_data()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::manta::proto::AppsData* temp = _impl_.apps_data_;
    _impl_.apps_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::AppsData* SparkyContextData::unsafe_arena_release_apps_data()
{
    // @@protoc_insertion_point(field_release:manta.proto.SparkyContextData.apps_data)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::manta::proto::AppsData* temp = _impl_.apps_data_;
    _impl_.apps_data_ = nullptr;
    return temp;
}
inline ::manta::proto::AppsData* SparkyContextData::_internal_mutable_apps_data()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.apps_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::AppsData>(GetArenaForAllocation());
        _impl_.apps_data_ = p;
    }
    return _impl_.apps_data_;
}
inline ::manta::proto::AppsData* SparkyContextData::mutable_apps_data()
{
    ::manta::proto::AppsData* _msg = _internal_mutable_apps_data();
    // @@protoc_insertion_point(field_mutable:manta.proto.SparkyContextData.apps_data)
    return _msg;
}
inline void SparkyContextData::set_allocated_apps_data(::manta::proto::AppsData* apps_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.apps_data_;
    }
    if (apps_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(apps_data);
        if (message_arena != submessage_arena) {
            apps_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, apps_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.apps_data_ = apps_data;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.SparkyContextData.apps_data)
}

// optional .manta.proto.WebContent web_contents = 7;
inline bool SparkyContextData::_internal_has_web_contents() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.web_contents_ != nullptr);
    return value;
}
inline bool SparkyContextData::has_web_contents() const
{
    return _internal_has_web_contents();
}
inline void SparkyContextData::clear_web_contents()
{
    if (_impl_.web_contents_ != nullptr)
        _impl_.web_contents_->Clear();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::manta::proto::WebContent& SparkyContextData::_internal_web_contents() const
{
    const ::manta::proto::WebContent* p = _impl_.web_contents_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::WebContent&>(::manta::proto::_WebContent_default_instance_);
}
inline const ::manta::proto::WebContent& SparkyContextData::web_contents() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SparkyContextData.web_contents)
    return _internal_web_contents();
}
inline void SparkyContextData::unsafe_arena_set_allocated_web_contents(::manta::proto::WebContent* web_contents)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.web_contents_);
    }
    _impl_.web_contents_ = web_contents;
    if (web_contents) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.SparkyContextData.web_contents)
}
inline ::manta::proto::WebContent* SparkyContextData::release_web_contents()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::manta::proto::WebContent* temp = _impl_.web_contents_;
    _impl_.web_contents_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::WebContent* SparkyContextData::unsafe_arena_release_web_contents()
{
    // @@protoc_insertion_point(field_release:manta.proto.SparkyContextData.web_contents)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::manta::proto::WebContent* temp = _impl_.web_contents_;
    _impl_.web_contents_ = nullptr;
    return temp;
}
inline ::manta::proto::WebContent* SparkyContextData::_internal_mutable_web_contents()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.web_contents_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::WebContent>(GetArenaForAllocation());
        _impl_.web_contents_ = p;
    }
    return _impl_.web_contents_;
}
inline ::manta::proto::WebContent* SparkyContextData::mutable_web_contents()
{
    ::manta::proto::WebContent* _msg = _internal_mutable_web_contents();
    // @@protoc_insertion_point(field_mutable:manta.proto.SparkyContextData.web_contents)
    return _msg;
}
inline void SparkyContextData::set_allocated_web_contents(::manta::proto::WebContent* web_contents)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.web_contents_;
    }
    if (web_contents) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(web_contents);
        if (message_arena != submessage_arena) {
            web_contents = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, web_contents, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.web_contents_ = web_contents;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.SparkyContextData.web_contents)
}

// optional .manta.proto.FilesData files_data = 8;
inline bool SparkyContextData::_internal_has_files_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.files_data_ != nullptr);
    return value;
}
inline bool SparkyContextData::has_files_data() const
{
    return _internal_has_files_data();
}
inline void SparkyContextData::clear_files_data()
{
    if (_impl_.files_data_ != nullptr)
        _impl_.files_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::manta::proto::FilesData& SparkyContextData::_internal_files_data() const
{
    const ::manta::proto::FilesData* p = _impl_.files_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::FilesData&>(::manta::proto::_FilesData_default_instance_);
}
inline const ::manta::proto::FilesData& SparkyContextData::files_data() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SparkyContextData.files_data)
    return _internal_files_data();
}
inline void SparkyContextData::unsafe_arena_set_allocated_files_data(::manta::proto::FilesData* files_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.files_data_);
    }
    _impl_.files_data_ = files_data;
    if (files_data) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.SparkyContextData.files_data)
}
inline ::manta::proto::FilesData* SparkyContextData::release_files_data()
{
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::manta::proto::FilesData* temp = _impl_.files_data_;
    _impl_.files_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::FilesData* SparkyContextData::unsafe_arena_release_files_data()
{
    // @@protoc_insertion_point(field_release:manta.proto.SparkyContextData.files_data)
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::manta::proto::FilesData* temp = _impl_.files_data_;
    _impl_.files_data_ = nullptr;
    return temp;
}
inline ::manta::proto::FilesData* SparkyContextData::_internal_mutable_files_data()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    if (_impl_.files_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::FilesData>(GetArenaForAllocation());
        _impl_.files_data_ = p;
    }
    return _impl_.files_data_;
}
inline ::manta::proto::FilesData* SparkyContextData::mutable_files_data()
{
    ::manta::proto::FilesData* _msg = _internal_mutable_files_data();
    // @@protoc_insertion_point(field_mutable:manta.proto.SparkyContextData.files_data)
    return _msg;
}
inline void SparkyContextData::set_allocated_files_data(::manta::proto::FilesData* files_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.files_data_;
    }
    if (files_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(files_data);
        if (message_arena != submessage_arena) {
            files_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, files_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.files_data_ = files_data;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.SparkyContextData.files_data)
}

// optional .manta.proto.ServerConfig server_config = 9;
inline bool SparkyContextData::_internal_has_server_config() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.server_config_ != nullptr);
    return value;
}
inline bool SparkyContextData::has_server_config() const
{
    return _internal_has_server_config();
}
inline void SparkyContextData::clear_server_config()
{
    if (_impl_.server_config_ != nullptr)
        _impl_.server_config_->Clear();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::manta::proto::ServerConfig& SparkyContextData::_internal_server_config() const
{
    const ::manta::proto::ServerConfig* p = _impl_.server_config_;
    return p != nullptr ? *p : reinterpret_cast<const ::manta::proto::ServerConfig&>(::manta::proto::_ServerConfig_default_instance_);
}
inline const ::manta::proto::ServerConfig& SparkyContextData::server_config() const
{
    // @@protoc_insertion_point(field_get:manta.proto.SparkyContextData.server_config)
    return _internal_server_config();
}
inline void SparkyContextData::unsafe_arena_set_allocated_server_config(::manta::proto::ServerConfig* server_config)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_config_);
    }
    _impl_.server_config_ = server_config;
    if (server_config) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:manta.proto.SparkyContextData.server_config)
}
inline ::manta::proto::ServerConfig* SparkyContextData::release_server_config()
{
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::manta::proto::ServerConfig* temp = _impl_.server_config_;
    _impl_.server_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::manta::proto::ServerConfig* SparkyContextData::unsafe_arena_release_server_config()
{
    // @@protoc_insertion_point(field_release:manta.proto.SparkyContextData.server_config)
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::manta::proto::ServerConfig* temp = _impl_.server_config_;
    _impl_.server_config_ = nullptr;
    return temp;
}
inline ::manta::proto::ServerConfig* SparkyContextData::_internal_mutable_server_config()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    if (_impl_.server_config_ == nullptr) {
        auto* p = CreateMaybeMessage<::manta::proto::ServerConfig>(GetArenaForAllocation());
        _impl_.server_config_ = p;
    }
    return _impl_.server_config_;
}
inline ::manta::proto::ServerConfig* SparkyContextData::mutable_server_config()
{
    ::manta::proto::ServerConfig* _msg = _internal_mutable_server_config();
    // @@protoc_insertion_point(field_mutable:manta.proto.SparkyContextData.server_config)
    return _msg;
}
inline void SparkyContextData::set_allocated_server_config(::manta::proto::ServerConfig* server_config)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.server_config_;
    }
    if (server_config) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(server_config);
        if (message_arena != submessage_arena) {
            server_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, server_config, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.server_config_ = server_config;
    // @@protoc_insertion_point(field_set_allocated:manta.proto.SparkyContextData.server_config)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace proto
} // namespace manta

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::manta::proto::Click_Button> : ::std::true_type { };
template <> struct is_proto_enum<::manta::proto::Scroll_Direction> : ::std::true_type { };
template <> struct is_proto_enum<::manta::proto::Task> : ::std::true_type { };
template <> struct is_proto_enum<::manta::proto::Diagnostics> : ::std::true_type { };
template <> struct is_proto_enum<::manta::proto::SettingType> : ::std::true_type { };
template <> struct is_proto_enum<::manta::proto::Role> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fmanta_2fproto_2fsparky_2eproto
