// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/manta/proto/sparky.proto

#include "components/manta/proto/sparky.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace manta {
namespace proto {
PROTOBUF_CONSTEXPR BatteryData::BatteryData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.battery_time_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.battery_health_)*/ 0,
        /*decltype(_impl_.cycle_count_)*/ 0, /*decltype(_impl_.battery_charge_percentage_)*/ 0 }
{
}
struct BatteryDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR BatteryDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~BatteryDataDefaultTypeInternal()
    {
    }
    union {
        BatteryData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BatteryDataDefaultTypeInternal _BatteryData_default_instance_;
PROTOBUF_CONSTEXPR StorageData::StorageData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.free_storage_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.total_storage_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct StorageDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR StorageDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~StorageDataDefaultTypeInternal()
    {
    }
    union {
        StorageData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StorageDataDefaultTypeInternal _StorageData_default_instance_;
PROTOBUF_CONSTEXPR CPUData::CPUData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.cpu_usage_snapshot_)*/ 0,
        /*decltype(_impl_.temperature_)*/ 0, /*decltype(_impl_.clock_speed_ghz_)*/ 0 }
{
}
struct CPUDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CPUDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CPUDataDefaultTypeInternal()
    {
    }
    union {
        CPUData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CPUDataDefaultTypeInternal _CPUData_default_instance_;
PROTOBUF_CONSTEXPR MemoryData::MemoryData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.free_ram_gb_)*/ 0,
        /*decltype(_impl_.total_ram_gb_)*/ 0 }
{
}
struct MemoryDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR MemoryDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~MemoryDataDefaultTypeInternal()
    {
    }
    union {
        MemoryData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemoryDataDefaultTypeInternal _MemoryData_default_instance_;
PROTOBUF_CONSTEXPR DiagnosticsData::DiagnosticsData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.battery_)*/ nullptr,
        /*decltype(_impl_.storage_)*/ nullptr, /*decltype(_impl_.cpu_)*/ nullptr, /*decltype(_impl_.memory_)*/ nullptr }
{
}
struct DiagnosticsDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DiagnosticsDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DiagnosticsDataDefaultTypeInternal()
    {
    }
    union {
        DiagnosticsData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DiagnosticsDataDefaultTypeInternal _DiagnosticsData_default_instance_;
PROTOBUF_CONSTEXPR ServerConfig::ServerConfig(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.server_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ServerConfigDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ServerConfigDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ServerConfigDefaultTypeInternal()
    {
    }
    union {
        ServerConfig _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ServerConfigDefaultTypeInternal _ServerConfig_default_instance_;
PROTOBUF_CONSTEXPR SettingsValue::SettingsValue(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.settings_value_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct SettingsValueDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SettingsValueDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SettingsValueDefaultTypeInternal()
    {
    }
    union {
        SettingsValue _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SettingsValueDefaultTypeInternal _SettingsValue_default_instance_;
PROTOBUF_CONSTEXPR Setting::Setting(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.settings_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.value_)*/ nullptr,
        /*decltype(_impl_.type_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SettingDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SettingDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SettingDefaultTypeInternal()
    {
    }
    union {
        Setting _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SettingDefaultTypeInternal _Setting_default_instance_;
PROTOBUF_CONSTEXPR SettingsData::SettingsData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.setting_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SettingsDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SettingsDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SettingsDataDefaultTypeInternal()
    {
    }
    union {
        SettingsData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SettingsDataDefaultTypeInternal _SettingsData_default_instance_;
PROTOBUF_CONSTEXPR App::App(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.searchable_term_)*/ {}, /*decltype(_impl_.id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct AppDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AppDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AppDefaultTypeInternal()
    {
    }
    union {
        App _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppDefaultTypeInternal _App_default_instance_;
PROTOBUF_CONSTEXPR AppsData::AppsData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.app_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct AppsDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AppsDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AppsDataDefaultTypeInternal()
    {
    }
    union {
        AppsData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppsDataDefaultTypeInternal _AppsData_default_instance_;
PROTOBUF_CONSTEXPR TextEntry::TextEntry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.text_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct TextEntryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TextEntryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TextEntryDefaultTypeInternal()
    {
    }
    union {
        TextEntry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TextEntryDefaultTypeInternal _TextEntry_default_instance_;
PROTOBUF_CONSTEXPR KeyPress::KeyPress(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.control_)*/ false,
        /*decltype(_impl_.alt_)*/ false, /*decltype(_impl_.shift_)*/ false }
{
}
struct KeyPressDefaultTypeInternal {
    PROTOBUF_CONSTEXPR KeyPressDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~KeyPressDefaultTypeInternal()
    {
    }
    union {
        KeyPress _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyPressDefaultTypeInternal _KeyPress_default_instance_;
PROTOBUF_CONSTEXPR Click::Click(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.x_pos_)*/ 0, /*decltype(_impl_.y_pos_)*/ 0,
        /*decltype(_impl_.button_)*/ 0 }
{
}
struct ClickDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClickDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClickDefaultTypeInternal()
    {
    }
    union {
        Click _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClickDefaultTypeInternal _Click_default_instance_;
PROTOBUF_CONSTEXPR Scroll::Scroll(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.direction_)*/ 0, /*decltype(_impl_.distance_)*/ 0 }
{
}
struct ScrollDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ScrollDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ScrollDefaultTypeInternal()
    {
    }
    union {
        Scroll _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScrollDefaultTypeInternal _Scroll_default_instance_;
PROTOBUF_CONSTEXPR LaunchFile::LaunchFile(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.launch_file_path_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct LaunchFileDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LaunchFileDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LaunchFileDefaultTypeInternal()
    {
    }
    union {
        LaunchFile _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LaunchFileDefaultTypeInternal _LaunchFile_default_instance_;
PROTOBUF_CONSTEXPR WriteFile::WriteFile(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.file_bytes_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct WriteFileDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WriteFileDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WriteFileDefaultTypeInternal()
    {
    }
    union {
        WriteFile _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WriteFileDefaultTypeInternal _WriteFile_default_instance_;
PROTOBUF_CONSTEXPR Action::Action(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.action_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct ActionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ActionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ActionDefaultTypeInternal()
    {
    }
    union {
        Action _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActionDefaultTypeInternal _Action_default_instance_;
PROTOBUF_CONSTEXPR DiagnosticsRequest::DiagnosticsRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.diagnostics_)*/ {}, /*decltype(_impl_._diagnostics_cached_byte_size_)*/ { 0 }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct DiagnosticsRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DiagnosticsRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DiagnosticsRequestDefaultTypeInternal()
    {
    }
    union {
        DiagnosticsRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DiagnosticsRequestDefaultTypeInternal _DiagnosticsRequest_default_instance_;
PROTOBUF_CONSTEXPR SettingsDataRequest::SettingsDataRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SettingsDataRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SettingsDataRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SettingsDataRequestDefaultTypeInternal()
    {
    }
    union {
        SettingsDataRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SettingsDataRequestDefaultTypeInternal
    _SettingsDataRequest_default_instance_;
PROTOBUF_CONSTEXPR FileRequest::FileRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.paths_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct FileRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FileRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FileRequestDefaultTypeInternal()
    {
    }
    union {
        FileRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileRequestDefaultTypeInternal _FileRequest_default_instance_;
PROTOBUF_CONSTEXPR File::File(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.path_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.date_modified_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.serialized_bytes_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.summary_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.size_in_bytes_)*/ int64_t { 0 } }
{
}
struct FileDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FileDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FileDefaultTypeInternal()
    {
    }
    union {
        File _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileDefaultTypeInternal _File_default_instance_;
PROTOBUF_CONSTEXPR FilesData::FilesData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.files_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct FilesDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FilesDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FilesDataDefaultTypeInternal()
    {
    }
    union {
        FilesData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FilesDataDefaultTypeInternal _FilesData_default_instance_;
PROTOBUF_CONSTEXPR Update::Update(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.files_with_summary_)*/ nullptr }
{
}
struct UpdateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UpdateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UpdateDefaultTypeInternal()
    {
    }
    union {
        Update _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateDefaultTypeInternal _Update_default_instance_;
PROTOBUF_CONSTEXPR ContextRequest::ContextRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.diagnostics_)*/ nullptr,
        /*decltype(_impl_.files_)*/ nullptr, /*decltype(_impl_.settings_)*/ nullptr }
{
}
struct ContextRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ContextRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ContextRequestDefaultTypeInternal()
    {
    }
    union {
        ContextRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContextRequestDefaultTypeInternal _ContextRequest_default_instance_;
PROTOBUF_CONSTEXPR Turn::Turn(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.action_)*/ {},
        /*decltype(_impl_.message_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.screenshot_)*/ nullptr,
        /*decltype(_impl_.role_)*/ 0 }
{
}
struct TurnDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TurnDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TurnDefaultTypeInternal()
    {
    }
    union {
        Turn _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TurnDefaultTypeInternal _Turn_default_instance_;
PROTOBUF_CONSTEXPR SparkyResponse::SparkyResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.context_request_)*/ nullptr,
        /*decltype(_impl_.latest_reply_)*/ nullptr, /*decltype(_impl_.update_)*/ nullptr }
{
}
struct SparkyResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SparkyResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SparkyResponseDefaultTypeInternal()
    {
    }
    union {
        SparkyResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SparkyResponseDefaultTypeInternal _SparkyResponse_default_instance_;
PROTOBUF_CONSTEXPR WebContent::WebContent(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.page_contents_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.page_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct WebContentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WebContentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WebContentDefaultTypeInternal()
    {
    }
    union {
        WebContent _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WebContentDefaultTypeInternal _WebContent_default_instance_;
PROTOBUF_CONSTEXPR SparkyContextData::SparkyContextData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.conversation_)*/ {},
        /*decltype(_impl_.diagnostics_data_)*/ nullptr, /*decltype(_impl_.settings_data_)*/ nullptr, /*decltype(_impl_.screenshot_)*/ nullptr,
        /*decltype(_impl_.apps_data_)*/ nullptr, /*decltype(_impl_.web_contents_)*/ nullptr, /*decltype(_impl_.files_data_)*/ nullptr,
        /*decltype(_impl_.server_config_)*/ nullptr, /*decltype(_impl_.task_)*/ 0 }
{
}
struct SparkyContextDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SparkyContextDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SparkyContextDataDefaultTypeInternal()
    {
    }
    union {
        SparkyContextData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SparkyContextDataDefaultTypeInternal _SparkyContextData_default_instance_;
} // namespace proto
} // namespace manta
namespace manta {
namespace proto {
bool Click_Button_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Click_Button_strings[4] = {};

static const char Click_Button_names[] = "LEFT"
                                         "MIDDLE"
                                         "RIGHT"
                                         "UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Click_Button_entries[] = {
    { { Click_Button_names + 0, 4 }, 1 },
    { { Click_Button_names + 4, 6 }, 3 },
    { { Click_Button_names + 10, 5 }, 2 },
    { { Click_Button_names + 15, 11 }, 0 },
};

static const int Click_Button_entries_by_number[] = {
    3, // 0 -> UNSPECIFIED
    0, // 1 -> LEFT
    2, // 2 -> RIGHT
    1, // 3 -> MIDDLE
};

const std::string& Click_Button_Name(Click_Button value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(Click_Button_entries, Click_Button_entries_by_number, 4, Click_Button_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Click_Button_entries, Click_Button_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Click_Button_strings[idx].get();
}
bool Click_Button_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Click_Button* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Click_Button_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<Click_Button>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Click_Button Click::UNSPECIFIED;
constexpr Click_Button Click::LEFT;
constexpr Click_Button Click::RIGHT;
constexpr Click_Button Click::MIDDLE;
constexpr Click_Button Click::Button_MIN;
constexpr Click_Button Click::Button_MAX;
constexpr int Click::Button_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Scroll_Direction_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Scroll_Direction_strings[5] = {};

static const char Scroll_Direction_names[] = "DOWN"
                                             "LEFT"
                                             "RIGHT"
                                             "UNSPECIFIED"
                                             "UP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Scroll_Direction_entries[] = {
    { { Scroll_Direction_names + 0, 4 }, 2 },
    { { Scroll_Direction_names + 4, 4 }, 3 },
    { { Scroll_Direction_names + 8, 5 }, 4 },
    { { Scroll_Direction_names + 13, 11 }, 0 },
    { { Scroll_Direction_names + 24, 2 }, 1 },
};

static const int Scroll_Direction_entries_by_number[] = {
    3, // 0 -> UNSPECIFIED
    4, // 1 -> UP
    0, // 2 -> DOWN
    1, // 3 -> LEFT
    2, // 4 -> RIGHT
};

const std::string& Scroll_Direction_Name(Scroll_Direction value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(Scroll_Direction_entries, Scroll_Direction_entries_by_number, 5, Scroll_Direction_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Scroll_Direction_entries, Scroll_Direction_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Scroll_Direction_strings[idx].get();
}
bool Scroll_Direction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Scroll_Direction* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Scroll_Direction_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<Scroll_Direction>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Scroll_Direction Scroll::UNSPECIFIED;
constexpr Scroll_Direction Scroll::UP;
constexpr Scroll_Direction Scroll::DOWN;
constexpr Scroll_Direction Scroll::LEFT;
constexpr Scroll_Direction Scroll::RIGHT;
constexpr Scroll_Direction Scroll::Direction_MIN;
constexpr Scroll_Direction Scroll::Direction_MAX;
constexpr int Scroll::Direction_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Task_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 5:
    case 6:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Task_strings[5] = {};

static const char Task_names[] = "TASK_DIAGNOSTICS"
                                 "TASK_GENERIC"
                                 "TASK_PLANNER"
                                 "TASK_SETTINGS"
                                 "TASK_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Task_entries[] = {
    { { Task_names + 0, 16 }, 2 },
    { { Task_names + 16, 12 }, 5 },
    { { Task_names + 28, 12 }, 6 },
    { { Task_names + 40, 13 }, 1 },
    { { Task_names + 53, 16 }, 0 },
};

static const int Task_entries_by_number[] = {
    4, // 0 -> TASK_UNSPECIFIED
    3, // 1 -> TASK_SETTINGS
    0, // 2 -> TASK_DIAGNOSTICS
    1, // 5 -> TASK_GENERIC
    2, // 6 -> TASK_PLANNER
};

const std::string& Task_Name(Task value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(Task_entries, Task_entries_by_number, 5, Task_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Task_entries, Task_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Task_strings[idx].get();
}
bool Task_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Task* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Task_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<Task>(int_value);
    }
    return success;
}
bool Diagnostics_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Diagnostics_strings[5] = {};

static const char Diagnostics_names[] = "DIAGNOSTICS_BATTERY"
                                        "DIAGNOSTICS_CPU"
                                        "DIAGNOSTICS_MEMORY"
                                        "DIAGNOSTICS_STORAGE"
                                        "DIAGNOSTICS_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Diagnostics_entries[] = {
    { { Diagnostics_names + 0, 19 }, 3 },
    { { Diagnostics_names + 19, 15 }, 2 },
    { { Diagnostics_names + 34, 18 }, 1 },
    { { Diagnostics_names + 52, 19 }, 4 },
    { { Diagnostics_names + 71, 23 }, 0 },
};

static const int Diagnostics_entries_by_number[] = {
    4, // 0 -> DIAGNOSTICS_UNSPECIFIED
    2, // 1 -> DIAGNOSTICS_MEMORY
    1, // 2 -> DIAGNOSTICS_CPU
    0, // 3 -> DIAGNOSTICS_BATTERY
    3, // 4 -> DIAGNOSTICS_STORAGE
};

const std::string& Diagnostics_Name(Diagnostics value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(Diagnostics_entries, Diagnostics_entries_by_number, 5, Diagnostics_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Diagnostics_entries, Diagnostics_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Diagnostics_strings[idx].get();
}
bool Diagnostics_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Diagnostics* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Diagnostics_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<Diagnostics>(int_value);
    }
    return success;
}
bool SettingType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SettingType_strings[5] = {};

static const char SettingType_names[] = "SETTING_TYPE_BOOL"
                                        "SETTING_TYPE_DOUBLE"
                                        "SETTING_TYPE_INTEGER"
                                        "SETTING_TYPE_STRING"
                                        "SETTING_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SettingType_entries[] = {
    { { SettingType_names + 0, 17 }, 1 },
    { { SettingType_names + 17, 19 }, 3 },
    { { SettingType_names + 36, 20 }, 4 },
    { { SettingType_names + 56, 19 }, 2 },
    { { SettingType_names + 75, 24 }, 0 },
};

static const int SettingType_entries_by_number[] = {
    4, // 0 -> SETTING_TYPE_UNSPECIFIED
    0, // 1 -> SETTING_TYPE_BOOL
    3, // 2 -> SETTING_TYPE_STRING
    1, // 3 -> SETTING_TYPE_DOUBLE
    2, // 4 -> SETTING_TYPE_INTEGER
};

const std::string& SettingType_Name(SettingType value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(SettingType_entries, SettingType_entries_by_number, 5, SettingType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(SettingType_entries, SettingType_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : SettingType_strings[idx].get();
}
bool SettingType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SettingType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(SettingType_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<SettingType>(int_value);
    }
    return success;
}
bool Role_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Role_strings[3] = {};

static const char Role_names[] = "ROLE_ASSISTANT"
                                 "ROLE_UNSPECIFIED"
                                 "ROLE_USER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Role_entries[] = {
    { { Role_names + 0, 14 }, 2 },
    { { Role_names + 14, 16 }, 0 },
    { { Role_names + 30, 9 }, 1 },
};

static const int Role_entries_by_number[] = {
    1, // 0 -> ROLE_UNSPECIFIED
    2, // 1 -> ROLE_USER
    0, // 2 -> ROLE_ASSISTANT
};

const std::string& Role_Name(Role value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(Role_entries, Role_entries_by_number, 3, Role_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(Role_entries, Role_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : Role_strings[idx].get();
}
bool Role_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Role* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(Role_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<Role>(int_value);
    }
    return success;
}

// ===================================================================

class BatteryData::_Internal {
public:
    using HasBits = decltype(std::declval<BatteryData>()._impl_._has_bits_);
    static void set_has_battery_health(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_cycle_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_battery_time(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_battery_charge_percentage(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

BatteryData::BatteryData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.BatteryData)
}
BatteryData::BatteryData(const BatteryData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    BatteryData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.battery_time_) {},
        decltype(_impl_.battery_health_) {}, decltype(_impl_.cycle_count_) {}, decltype(_impl_.battery_charge_percentage_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.battery_time_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.battery_time_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_battery_time()) {
        _this->_impl_.battery_time_.Set(from._internal_battery_time(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.battery_health_, &from._impl_.battery_health_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.battery_charge_percentage_) - reinterpret_cast<char*>(&_impl_.battery_health_))
            + sizeof(_impl_.battery_charge_percentage_));
    // @@protoc_insertion_point(copy_constructor:manta.proto.BatteryData)
}

inline void BatteryData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.battery_time_) {},
        decltype(_impl_.battery_health_) { 0 }, decltype(_impl_.cycle_count_) { 0 }, decltype(_impl_.battery_charge_percentage_) { 0 } };
    _impl_.battery_time_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.battery_time_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BatteryData::~BatteryData()
{
    // @@protoc_insertion_point(destructor:manta.proto.BatteryData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void BatteryData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.battery_time_.Destroy();
}

void BatteryData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void BatteryData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.BatteryData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.battery_time_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x0000000eu) {
        ::memset(&_impl_.battery_health_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.battery_charge_percentage_) - reinterpret_cast<char*>(&_impl_.battery_health_))
                + sizeof(_impl_.battery_charge_percentage_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* BatteryData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 battery_health = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_battery_health(&has_bits);
                _impl_.battery_health_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 cycle_count = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_cycle_count(&has_bits);
                _impl_.cycle_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string battery_time = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_battery_time();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // optional int32 battery_charge_percentage = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_battery_charge_percentage(&has_bits);
                _impl_.battery_charge_percentage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* BatteryData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.BatteryData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional int32 battery_health = 1;
    if (_internal_has_battery_health()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_battery_health(), target);
    }

    // optional int32 cycle_count = 2;
    if (_internal_has_cycle_count()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_cycle_count(), target);
    }

    // optional string battery_time = 3;
    if (_internal_has_battery_time()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_battery_time().data(),
            static_cast<int>(this->_internal_battery_time().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "manta.proto.BatteryData.battery_time");
        target = stream->WriteStringMaybeAliased(3, this->_internal_battery_time(), target);
    }

    // optional int32 battery_charge_percentage = 4;
    if (_internal_has_battery_charge_percentage()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_battery_charge_percentage(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.BatteryData)
    return target;
}

size_t BatteryData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.BatteryData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string battery_time = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_battery_time());
        }

        // optional int32 battery_health = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_battery_health());
        }

        // optional int32 cycle_count = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cycle_count());
        }

        // optional int32 battery_charge_percentage = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_battery_charge_percentage());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void BatteryData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const BatteryData*>(&from));
}

void BatteryData::MergeFrom(const BatteryData& from)
{
    BatteryData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.BatteryData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_battery_time(from._internal_battery_time());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.battery_health_ = from._impl_.battery_health_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.cycle_count_ = from._impl_.cycle_count_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.battery_charge_percentage_ = from._impl_.battery_charge_percentage_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BatteryData::CopyFrom(const BatteryData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.BatteryData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool BatteryData::IsInitialized() const
{
    return true;
}

void BatteryData::InternalSwap(BatteryData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.battery_time_, lhs_arena, &other->_impl_.battery_time_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(BatteryData, _impl_.battery_charge_percentage_)
        + sizeof(BatteryData::_impl_.battery_charge_percentage_) - PROTOBUF_FIELD_OFFSET(BatteryData, _impl_.battery_health_)>(
        reinterpret_cast<char*>(&_impl_.battery_health_), reinterpret_cast<char*>(&other->_impl_.battery_health_));
}

std::string BatteryData::GetTypeName() const
{
    return "manta.proto.BatteryData";
}

// ===================================================================

class StorageData::_Internal {
public:
    using HasBits = decltype(std::declval<StorageData>()._impl_._has_bits_);
    static void set_has_free_storage(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_total_storage(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

StorageData::StorageData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.StorageData)
}
StorageData::StorageData(const StorageData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    StorageData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.free_storage_) {},
        decltype(_impl_.total_storage_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.free_storage_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.free_storage_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_free_storage()) {
        _this->_impl_.free_storage_.Set(from._internal_free_storage(), _this->GetArenaForAllocation());
    }
    _impl_.total_storage_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.total_storage_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_total_storage()) {
        _this->_impl_.total_storage_.Set(from._internal_total_storage(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:manta.proto.StorageData)
}

inline void StorageData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.free_storage_) {}, decltype(_impl_.total_storage_) {} };
    _impl_.free_storage_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.free_storage_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.total_storage_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.total_storage_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StorageData::~StorageData()
{
    // @@protoc_insertion_point(destructor:manta.proto.StorageData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void StorageData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.free_storage_.Destroy();
    _impl_.total_storage_.Destroy();
}

void StorageData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void StorageData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.StorageData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.free_storage_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.total_storage_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* StorageData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string free_storage = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_free_storage();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // optional string total_storage = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_total_storage();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* StorageData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.StorageData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional string free_storage = 1;
    if (_internal_has_free_storage()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_free_storage().data(),
            static_cast<int>(this->_internal_free_storage().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "manta.proto.StorageData.free_storage");
        target = stream->WriteStringMaybeAliased(1, this->_internal_free_storage(), target);
    }

    // optional string total_storage = 2;
    if (_internal_has_total_storage()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_total_storage().data(),
            static_cast<int>(this->_internal_total_storage().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "manta.proto.StorageData.total_storage");
        target = stream->WriteStringMaybeAliased(2, this->_internal_total_storage(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.StorageData)
    return target;
}

size_t StorageData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.StorageData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string free_storage = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_free_storage());
        }

        // optional string total_storage = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_total_storage());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void StorageData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const StorageData*>(&from));
}

void StorageData::MergeFrom(const StorageData& from)
{
    StorageData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.StorageData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_free_storage(from._internal_free_storage());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_total_storage(from._internal_total_storage());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StorageData::CopyFrom(const StorageData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.StorageData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool StorageData::IsInitialized() const
{
    return true;
}

void StorageData::InternalSwap(StorageData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.free_storage_, lhs_arena, &other->_impl_.free_storage_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.total_storage_, lhs_arena, &other->_impl_.total_storage_, rhs_arena);
}

std::string StorageData::GetTypeName() const
{
    return "manta.proto.StorageData";
}

// ===================================================================

class CPUData::_Internal {
public:
    using HasBits = decltype(std::declval<CPUData>()._impl_._has_bits_);
    static void set_has_cpu_usage_snapshot(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_temperature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_clock_speed_ghz(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

CPUData::CPUData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.CPUData)
}
CPUData::CPUData(const CPUData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CPUData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.cpu_usage_snapshot_) {}, decltype(_impl_.temperature_) {}, decltype(_impl_.clock_speed_ghz_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.cpu_usage_snapshot_, &from._impl_.cpu_usage_snapshot_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.clock_speed_ghz_) - reinterpret_cast<char*>(&_impl_.cpu_usage_snapshot_))
            + sizeof(_impl_.clock_speed_ghz_));
    // @@protoc_insertion_point(copy_constructor:manta.proto.CPUData)
}

inline void CPUData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cpu_usage_snapshot_) { 0 },
        decltype(_impl_.temperature_) { 0 }, decltype(_impl_.clock_speed_ghz_) { 0 } };
}

CPUData::~CPUData()
{
    // @@protoc_insertion_point(destructor:manta.proto.CPUData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CPUData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CPUData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CPUData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.CPUData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        ::memset(&_impl_.cpu_usage_snapshot_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.clock_speed_ghz_) - reinterpret_cast<char*>(&_impl_.cpu_usage_snapshot_))
                + sizeof(_impl_.clock_speed_ghz_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CPUData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 cpu_usage_snapshot = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_cpu_usage_snapshot(&has_bits);
                _impl_.cpu_usage_snapshot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 temperature = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_temperature(&has_bits);
                _impl_.temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional double clock_speed_ghz = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
                _Internal::set_has_clock_speed_ghz(&has_bits);
                _impl_.clock_speed_ghz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
                ptr += sizeof(double);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CPUData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.CPUData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional int32 cpu_usage_snapshot = 1;
    if (_internal_has_cpu_usage_snapshot()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_cpu_usage_snapshot(), target);
    }

    // optional int32 temperature = 2;
    if (_internal_has_temperature()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_temperature(), target);
    }

    // optional double clock_speed_ghz = 3;
    if (_internal_has_clock_speed_ghz()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_clock_speed_ghz(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.CPUData)
    return target;
}

size_t CPUData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.CPUData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional int32 cpu_usage_snapshot = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cpu_usage_snapshot());
        }

        // optional int32 temperature = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_temperature());
        }

        // optional double clock_speed_ghz = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 8;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CPUData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CPUData*>(&from));
}

void CPUData::MergeFrom(const CPUData& from)
{
    CPUData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.CPUData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.cpu_usage_snapshot_ = from._impl_.cpu_usage_snapshot_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.temperature_ = from._impl_.temperature_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.clock_speed_ghz_ = from._impl_.clock_speed_ghz_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CPUData::CopyFrom(const CPUData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.CPUData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CPUData::IsInitialized() const
{
    return true;
}

void CPUData::InternalSwap(CPUData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(CPUData, _impl_.clock_speed_ghz_) + sizeof(CPUData::_impl_.clock_speed_ghz_)
        - PROTOBUF_FIELD_OFFSET(CPUData, _impl_.cpu_usage_snapshot_)>(
        reinterpret_cast<char*>(&_impl_.cpu_usage_snapshot_), reinterpret_cast<char*>(&other->_impl_.cpu_usage_snapshot_));
}

std::string CPUData::GetTypeName() const
{
    return "manta.proto.CPUData";
}

// ===================================================================

class MemoryData::_Internal {
public:
    using HasBits = decltype(std::declval<MemoryData>()._impl_._has_bits_);
    static void set_has_free_ram_gb(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_total_ram_gb(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

MemoryData::MemoryData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.MemoryData)
}
MemoryData::MemoryData(const MemoryData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    MemoryData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.free_ram_gb_) {},
        decltype(_impl_.total_ram_gb_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.free_ram_gb_, &from._impl_.free_ram_gb_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_ram_gb_) - reinterpret_cast<char*>(&_impl_.free_ram_gb_)) + sizeof(_impl_.total_ram_gb_));
    // @@protoc_insertion_point(copy_constructor:manta.proto.MemoryData)
}

inline void MemoryData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.free_ram_gb_) { 0 },
        decltype(_impl_.total_ram_gb_) { 0 } };
}

MemoryData::~MemoryData()
{
    // @@protoc_insertion_point(destructor:manta.proto.MemoryData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void MemoryData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MemoryData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void MemoryData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.MemoryData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.free_ram_gb_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_ram_gb_) - reinterpret_cast<char*>(&_impl_.free_ram_gb_)) + sizeof(_impl_.total_ram_gb_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* MemoryData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional double free_ram_gb = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
                _Internal::set_has_free_ram_gb(&has_bits);
                _impl_.free_ram_gb_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
                ptr += sizeof(double);
            } else
                goto handle_unusual;
            continue;
        // optional double total_ram_gb = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
                _Internal::set_has_total_ram_gb(&has_bits);
                _impl_.total_ram_gb_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
                ptr += sizeof(double);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* MemoryData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.MemoryData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional double free_ram_gb = 1;
    if (_internal_has_free_ram_gb()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_free_ram_gb(), target);
    }

    // optional double total_ram_gb = 2;
    if (_internal_has_total_ram_gb()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_total_ram_gb(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.MemoryData)
    return target;
}

size_t MemoryData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.MemoryData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional double free_ram_gb = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 8;
        }

        // optional double total_ram_gb = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 8;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void MemoryData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const MemoryData*>(&from));
}

void MemoryData::MergeFrom(const MemoryData& from)
{
    MemoryData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.MemoryData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.free_ram_gb_ = from._impl_.free_ram_gb_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.total_ram_gb_ = from._impl_.total_ram_gb_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MemoryData::CopyFrom(const MemoryData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.MemoryData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool MemoryData::IsInitialized() const
{
    return true;
}

void MemoryData::InternalSwap(MemoryData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(MemoryData, _impl_.total_ram_gb_) + sizeof(MemoryData::_impl_.total_ram_gb_)
        - PROTOBUF_FIELD_OFFSET(MemoryData, _impl_.free_ram_gb_)>(
        reinterpret_cast<char*>(&_impl_.free_ram_gb_), reinterpret_cast<char*>(&other->_impl_.free_ram_gb_));
}

std::string MemoryData::GetTypeName() const
{
    return "manta.proto.MemoryData";
}

// ===================================================================

class DiagnosticsData::_Internal {
public:
    using HasBits = decltype(std::declval<DiagnosticsData>()._impl_._has_bits_);
    static const ::manta::proto::BatteryData& battery(const DiagnosticsData* msg);
    static void set_has_battery(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::manta::proto::StorageData& storage(const DiagnosticsData* msg);
    static void set_has_storage(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::manta::proto::CPUData& cpu(const DiagnosticsData* msg);
    static void set_has_cpu(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::manta::proto::MemoryData& memory(const DiagnosticsData* msg);
    static void set_has_memory(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::manta::proto::BatteryData& DiagnosticsData::_Internal::battery(const DiagnosticsData* msg)
{
    return *msg->_impl_.battery_;
}
const ::manta::proto::StorageData& DiagnosticsData::_Internal::storage(const DiagnosticsData* msg)
{
    return *msg->_impl_.storage_;
}
const ::manta::proto::CPUData& DiagnosticsData::_Internal::cpu(const DiagnosticsData* msg)
{
    return *msg->_impl_.cpu_;
}
const ::manta::proto::MemoryData& DiagnosticsData::_Internal::memory(const DiagnosticsData* msg)
{
    return *msg->_impl_.memory_;
}
DiagnosticsData::DiagnosticsData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.DiagnosticsData)
}
DiagnosticsData::DiagnosticsData(const DiagnosticsData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DiagnosticsData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.battery_) { nullptr },
        decltype(_impl_.storage_) { nullptr }, decltype(_impl_.cpu_) { nullptr }, decltype(_impl_.memory_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_battery()) {
        _this->_impl_.battery_ = new ::manta::proto::BatteryData(*from._impl_.battery_);
    }
    if (from._internal_has_storage()) {
        _this->_impl_.storage_ = new ::manta::proto::StorageData(*from._impl_.storage_);
    }
    if (from._internal_has_cpu()) {
        _this->_impl_.cpu_ = new ::manta::proto::CPUData(*from._impl_.cpu_);
    }
    if (from._internal_has_memory()) {
        _this->_impl_.memory_ = new ::manta::proto::MemoryData(*from._impl_.memory_);
    }
    // @@protoc_insertion_point(copy_constructor:manta.proto.DiagnosticsData)
}

inline void DiagnosticsData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.battery_) { nullptr },
        decltype(_impl_.storage_) { nullptr }, decltype(_impl_.cpu_) { nullptr }, decltype(_impl_.memory_) { nullptr } };
}

DiagnosticsData::~DiagnosticsData()
{
    // @@protoc_insertion_point(destructor:manta.proto.DiagnosticsData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DiagnosticsData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.battery_;
    if (this != internal_default_instance())
        delete _impl_.storage_;
    if (this != internal_default_instance())
        delete _impl_.cpu_;
    if (this != internal_default_instance())
        delete _impl_.memory_;
}

void DiagnosticsData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DiagnosticsData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.DiagnosticsData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.battery_ != nullptr);
            _impl_.battery_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.storage_ != nullptr);
            _impl_.storage_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.cpu_ != nullptr);
            _impl_.cpu_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.memory_ != nullptr);
            _impl_.memory_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DiagnosticsData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .manta.proto.BatteryData battery = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_battery(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.StorageData storage = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_storage(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.CPUData cpu = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_cpu(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.MemoryData memory = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_memory(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DiagnosticsData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.DiagnosticsData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional .manta.proto.BatteryData battery = 1;
    if (_internal_has_battery()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::battery(this), _Internal::battery(this).GetCachedSize(), target, stream);
    }

    // optional .manta.proto.StorageData storage = 2;
    if (_internal_has_storage()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::storage(this), _Internal::storage(this).GetCachedSize(), target, stream);
    }

    // optional .manta.proto.CPUData cpu = 3;
    if (_internal_has_cpu()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::cpu(this), _Internal::cpu(this).GetCachedSize(), target, stream);
    }

    // optional .manta.proto.MemoryData memory = 4;
    if (_internal_has_memory()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::memory(this), _Internal::memory(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.DiagnosticsData)
    return target;
}

size_t DiagnosticsData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.DiagnosticsData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .manta.proto.BatteryData battery = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.battery_);
        }

        // optional .manta.proto.StorageData storage = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.storage_);
        }

        // optional .manta.proto.CPUData cpu = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.cpu_);
        }

        // optional .manta.proto.MemoryData memory = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.memory_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DiagnosticsData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DiagnosticsData*>(&from));
}

void DiagnosticsData::MergeFrom(const DiagnosticsData& from)
{
    DiagnosticsData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.DiagnosticsData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_battery()->::manta::proto::BatteryData::MergeFrom(from._internal_battery());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_storage()->::manta::proto::StorageData::MergeFrom(from._internal_storage());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_cpu()->::manta::proto::CPUData::MergeFrom(from._internal_cpu());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_memory()->::manta::proto::MemoryData::MergeFrom(from._internal_memory());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DiagnosticsData::CopyFrom(const DiagnosticsData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.DiagnosticsData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DiagnosticsData::IsInitialized() const
{
    return true;
}

void DiagnosticsData::InternalSwap(DiagnosticsData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(DiagnosticsData, _impl_.memory_) + sizeof(DiagnosticsData::_impl_.memory_)
        - PROTOBUF_FIELD_OFFSET(DiagnosticsData, _impl_.battery_)>(reinterpret_cast<char*>(&_impl_.battery_), reinterpret_cast<char*>(&other->_impl_.battery_));
}

std::string DiagnosticsData::GetTypeName() const
{
    return "manta.proto.DiagnosticsData";
}

// ===================================================================

class ServerConfig::_Internal {
public:
    using HasBits = decltype(std::declval<ServerConfig>()._impl_._has_bits_);
    static void set_has_server_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ServerConfig::ServerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.ServerConfig)
}
ServerConfig::ServerConfig(const ServerConfig& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ServerConfig* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.server_url_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.server_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_server_url()) {
        _this->_impl_.server_url_.Set(from._internal_server_url(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:manta.proto.ServerConfig)
}

inline void ServerConfig::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.server_url_) {} };
    _impl_.server_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ServerConfig::~ServerConfig()
{
    // @@protoc_insertion_point(destructor:manta.proto.ServerConfig)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ServerConfig::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.server_url_.Destroy();
}

void ServerConfig::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ServerConfig::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.ServerConfig)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.server_url_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ServerConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string server_url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_server_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ServerConfig::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.ServerConfig)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional string server_url = 1;
    if (_internal_has_server_url()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_server_url().data(),
            static_cast<int>(this->_internal_server_url().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "manta.proto.ServerConfig.server_url");
        target = stream->WriteStringMaybeAliased(1, this->_internal_server_url(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.ServerConfig)
    return target;
}

size_t ServerConfig::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.ServerConfig)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string server_url = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_server_url());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ServerConfig::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ServerConfig*>(&from));
}

void ServerConfig::MergeFrom(const ServerConfig& from)
{
    ServerConfig* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.ServerConfig)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_server_url()) {
        _this->_internal_set_server_url(from._internal_server_url());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ServerConfig::CopyFrom(const ServerConfig& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.ServerConfig)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ServerConfig::IsInitialized() const
{
    return true;
}

void ServerConfig::InternalSwap(ServerConfig* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.server_url_, lhs_arena, &other->_impl_.server_url_, rhs_arena);
}

std::string ServerConfig::GetTypeName() const
{
    return "manta.proto.ServerConfig";
}

// ===================================================================

class SettingsValue::_Internal {
public:
};

SettingsValue::SettingsValue(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.SettingsValue)
}
SettingsValue::SettingsValue(const SettingsValue& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SettingsValue* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.settings_value_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_settings_value();
    switch (from.settings_value_case()) {
    case kBoolVal: {
        _this->_internal_set_bool_val(from._internal_bool_val());
        break;
    }
    case kTextVal: {
        _this->_internal_set_text_val(from._internal_text_val());
        break;
    }
    case kDoubleVal: {
        _this->_internal_set_double_val(from._internal_double_val());
        break;
    }
    case kIntVal: {
        _this->_internal_set_int_val(from._internal_int_val());
        break;
    }
    case SETTINGS_VALUE_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:manta.proto.SettingsValue)
}

inline void SettingsValue::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.settings_value_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_settings_value();
}

SettingsValue::~SettingsValue()
{
    // @@protoc_insertion_point(destructor:manta.proto.SettingsValue)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SettingsValue::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_settings_value()) {
        clear_settings_value();
    }
}

void SettingsValue::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SettingsValue::clear_settings_value()
{
    // @@protoc_insertion_point(one_of_clear_start:manta.proto.SettingsValue)
    switch (settings_value_case()) {
    case kBoolVal: {
        // No need to clear
        break;
    }
    case kTextVal: {
        _impl_.settings_value_.text_val_.Destroy();
        break;
    }
    case kDoubleVal: {
        // No need to clear
        break;
    }
    case kIntVal: {
        // No need to clear
        break;
    }
    case SETTINGS_VALUE_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = SETTINGS_VALUE_NOT_SET;
}

void SettingsValue::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.SettingsValue)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_settings_value();
    _internal_metadata_.Clear<std::string>();
}

const char* SettingsValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // bool bool_val = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _internal_set_bool_val(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string text_val = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_text_val();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // double double_val = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
                _internal_set_double_val(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
                ptr += sizeof(double);
            } else
                goto handle_unusual;
            continue;
        // int32 int_val = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _internal_set_int_val(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SettingsValue::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.SettingsValue)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // bool bool_val = 1;
    if (_internal_has_bool_val()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_bool_val(), target);
    }

    // string text_val = 2;
    if (_internal_has_text_val()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_text_val().data(),
            static_cast<int>(this->_internal_text_val().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "manta.proto.SettingsValue.text_val");
        target = stream->WriteStringMaybeAliased(2, this->_internal_text_val(), target);
    }

    // double double_val = 3;
    if (_internal_has_double_val()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_double_val(), target);
    }

    // int32 int_val = 4;
    if (_internal_has_int_val()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_int_val(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.SettingsValue)
    return target;
}

size_t SettingsValue::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.SettingsValue)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (settings_value_case()) {
    // bool bool_val = 1;
    case kBoolVal: {
        total_size += 1 + 1;
        break;
    }
    // string text_val = 2;
    case kTextVal: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_text_val());
        break;
    }
    // double double_val = 3;
    case kDoubleVal: {
        total_size += 1 + 8;
        break;
    }
    // int32 int_val = 4;
    case kIntVal: {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_int_val());
        break;
    }
    case SETTINGS_VALUE_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SettingsValue::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SettingsValue*>(&from));
}

void SettingsValue::MergeFrom(const SettingsValue& from)
{
    SettingsValue* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.SettingsValue)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.settings_value_case()) {
    case kBoolVal: {
        _this->_internal_set_bool_val(from._internal_bool_val());
        break;
    }
    case kTextVal: {
        _this->_internal_set_text_val(from._internal_text_val());
        break;
    }
    case kDoubleVal: {
        _this->_internal_set_double_val(from._internal_double_val());
        break;
    }
    case kIntVal: {
        _this->_internal_set_int_val(from._internal_int_val());
        break;
    }
    case SETTINGS_VALUE_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SettingsValue::CopyFrom(const SettingsValue& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.SettingsValue)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SettingsValue::IsInitialized() const
{
    return true;
}

void SettingsValue::InternalSwap(SettingsValue* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.settings_value_, other->_impl_.settings_value_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string SettingsValue::GetTypeName() const
{
    return "manta.proto.SettingsValue";
}

// ===================================================================

class Setting::_Internal {
public:
    static const ::manta::proto::SettingsValue& value(const Setting* msg);
};

const ::manta::proto::SettingsValue& Setting::_Internal::value(const Setting* msg)
{
    return *msg->_impl_.value_;
}
Setting::Setting(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.Setting)
}
Setting::Setting(const Setting& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Setting* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_.settings_id_) {}, decltype(_impl_.value_) { nullptr }, decltype(_impl_.type_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.settings_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.settings_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_settings_id().empty()) {
        _this->_impl_.settings_id_.Set(from._internal_settings_id(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_value()) {
        _this->_impl_.value_ = new ::manta::proto::SettingsValue(*from._impl_.value_);
    }
    _this->_impl_.type_ = from._impl_.type_;
    // @@protoc_insertion_point(copy_constructor:manta.proto.Setting)
}

inline void Setting::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_.settings_id_) {}, decltype(_impl_.value_) { nullptr }, decltype(_impl_.type_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.settings_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.settings_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Setting::~Setting()
{
    // @@protoc_insertion_point(destructor:manta.proto.Setting)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Setting::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.settings_id_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.value_;
}

void Setting::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Setting::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.Setting)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.settings_id_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
        delete _impl_.value_;
    }
    _impl_.value_ = nullptr;
    _impl_.type_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* Setting::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string settings_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_settings_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // .manta.proto.SettingsValue value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .manta.proto.SettingType type = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_type(static_cast<::manta::proto::SettingType>(val));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Setting::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.Setting)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string settings_id = 1;
    if (!this->_internal_settings_id().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_settings_id().data(),
            static_cast<int>(this->_internal_settings_id().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "manta.proto.Setting.settings_id");
        target = stream->WriteStringMaybeAliased(1, this->_internal_settings_id(), target);
    }

    // .manta.proto.SettingsValue value = 2;
    if (this->_internal_has_value()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::value(this), _Internal::value(this).GetCachedSize(), target, stream);
    }

    // .manta.proto.SettingType type = 3;
    if (this->_internal_type() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.Setting)
    return target;
}

size_t Setting::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.Setting)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string settings_id = 1;
    if (!this->_internal_settings_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_settings_id());
    }

    // .manta.proto.SettingsValue value = 2;
    if (this->_internal_has_value()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.value_);
    }

    // .manta.proto.SettingType type = 3;
    if (this->_internal_type() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Setting::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Setting*>(&from));
}

void Setting::MergeFrom(const Setting& from)
{
    Setting* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.Setting)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_settings_id().empty()) {
        _this->_internal_set_settings_id(from._internal_settings_id());
    }
    if (from._internal_has_value()) {
        _this->_internal_mutable_value()->::manta::proto::SettingsValue::MergeFrom(from._internal_value());
    }
    if (from._internal_type() != 0) {
        _this->_internal_set_type(from._internal_type());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Setting::CopyFrom(const Setting& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.Setting)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Setting::IsInitialized() const
{
    return true;
}

void Setting::InternalSwap(Setting* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.settings_id_, lhs_arena, &other->_impl_.settings_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Setting, _impl_.type_) + sizeof(Setting::_impl_.type_)
        - PROTOBUF_FIELD_OFFSET(Setting, _impl_.value_)>(reinterpret_cast<char*>(&_impl_.value_), reinterpret_cast<char*>(&other->_impl_.value_));
}

std::string Setting::GetTypeName() const
{
    return "manta.proto.Setting";
}

// ===================================================================

class SettingsData::_Internal {
public:
};

SettingsData::SettingsData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.SettingsData)
}
SettingsData::SettingsData(const SettingsData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SettingsData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.setting_) { from._impl_.setting_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:manta.proto.SettingsData)
}

inline void SettingsData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.setting_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

SettingsData::~SettingsData()
{
    // @@protoc_insertion_point(destructor:manta.proto.SettingsData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SettingsData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.setting_.~RepeatedPtrField();
}

void SettingsData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SettingsData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.SettingsData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.setting_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SettingsData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .manta.proto.Setting setting = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_setting(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SettingsData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.SettingsData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .manta.proto.Setting setting = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_setting_size()); i < n; i++) {
        const auto& repfield = this->_internal_setting(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.SettingsData)
    return target;
}

size_t SettingsData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.SettingsData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .manta.proto.Setting setting = 1;
    total_size += 1UL * this->_internal_setting_size();
    for (const auto& msg : this->_impl_.setting_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SettingsData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SettingsData*>(&from));
}

void SettingsData::MergeFrom(const SettingsData& from)
{
    SettingsData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.SettingsData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.setting_.MergeFrom(from._impl_.setting_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SettingsData::CopyFrom(const SettingsData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.SettingsData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SettingsData::IsInitialized() const
{
    return true;
}

void SettingsData::InternalSwap(SettingsData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.setting_.InternalSwap(&other->_impl_.setting_);
}

std::string SettingsData::GetTypeName() const
{
    return "manta.proto.SettingsData";
}

// ===================================================================

class App::_Internal {
public:
};

App::App(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.App)
}
App::App(const App& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    App* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.searchable_term_) { from._impl_.searchable_term_ }, decltype(_impl_.id_) {}, decltype(_impl_.name_) {},
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_id().empty()) {
        _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
    }
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_name().empty()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:manta.proto.App)
}

inline void App::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_.searchable_term_) { arena }, decltype(_impl_.id_) {}, decltype(_impl_.name_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

App::~App()
{
    // @@protoc_insertion_point(destructor:manta.proto.App)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void App::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.searchable_term_.~RepeatedPtrField();
    _impl_.id_.Destroy();
    _impl_.name_.Destroy();
}

void App::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void App::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.App)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.searchable_term_.Clear();
    _impl_.id_.ClearToEmpty();
    _impl_.name_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* App::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string searchable_term = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_searchable_term();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    CHK_(::_pbi::VerifyUTF8(str, nullptr));
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* App::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.App)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string id = 1;
    if (!this->_internal_id().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "manta.proto.App.id");
        target = stream->WriteStringMaybeAliased(1, this->_internal_id(), target);
    }

    // string name = 2;
    if (!this->_internal_name().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "manta.proto.App.name");
        target = stream->WriteStringMaybeAliased(2, this->_internal_name(), target);
    }

    // repeated string searchable_term = 3;
    for (int i = 0, n = this->_internal_searchable_term_size(); i < n; i++) {
        const auto& s = this->_internal_searchable_term(i);
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
            s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "manta.proto.App.searchable_term");
        target = stream->WriteString(3, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.App)
    return target;
}

size_t App::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.App)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string searchable_term = 3;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.searchable_term_.size());
    for (int i = 0, n = _impl_.searchable_term_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.searchable_term_.Get(i));
    }

    // string id = 1;
    if (!this->_internal_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_id());
    }

    // string name = 2;
    if (!this->_internal_name().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void App::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const App*>(&from));
}

void App::MergeFrom(const App& from)
{
    App* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.App)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.searchable_term_.MergeFrom(from._impl_.searchable_term_);
    if (!from._internal_id().empty()) {
        _this->_internal_set_id(from._internal_id());
    }
    if (!from._internal_name().empty()) {
        _this->_internal_set_name(from._internal_name());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void App::CopyFrom(const App& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.App)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool App::IsInitialized() const
{
    return true;
}

void App::InternalSwap(App* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.searchable_term_.InternalSwap(&other->_impl_.searchable_term_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena, &other->_impl_.id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
}

std::string App::GetTypeName() const
{
    return "manta.proto.App";
}

// ===================================================================

class AppsData::_Internal {
public:
};

AppsData::AppsData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.AppsData)
}
AppsData::AppsData(const AppsData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AppsData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.app_) { from._impl_.app_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:manta.proto.AppsData)
}

inline void AppsData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.app_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

AppsData::~AppsData()
{
    // @@protoc_insertion_point(destructor:manta.proto.AppsData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AppsData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.app_.~RepeatedPtrField();
}

void AppsData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AppsData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.AppsData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.app_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AppsData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .manta.proto.App app = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_app(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AppsData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.AppsData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .manta.proto.App app = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_app_size()); i < n; i++) {
        const auto& repfield = this->_internal_app(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.AppsData)
    return target;
}

size_t AppsData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.AppsData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .manta.proto.App app = 1;
    total_size += 1UL * this->_internal_app_size();
    for (const auto& msg : this->_impl_.app_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AppsData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AppsData*>(&from));
}

void AppsData::MergeFrom(const AppsData& from)
{
    AppsData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.AppsData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.app_.MergeFrom(from._impl_.app_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppsData::CopyFrom(const AppsData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.AppsData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AppsData::IsInitialized() const
{
    return true;
}

void AppsData::InternalSwap(AppsData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.app_.InternalSwap(&other->_impl_.app_);
}

std::string AppsData::GetTypeName() const
{
    return "manta.proto.AppsData";
}

// ===================================================================

class TextEntry::_Internal {
public:
    using HasBits = decltype(std::declval<TextEntry>()._impl_._has_bits_);
    static void set_has_text(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

TextEntry::TextEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.TextEntry)
}
TextEntry::TextEntry(const TextEntry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TextEntry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.text_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_text()) {
        _this->_impl_.text_.Set(from._internal_text(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:manta.proto.TextEntry)
}

inline void TextEntry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.text_) {} };
    _impl_.text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TextEntry::~TextEntry()
{
    // @@protoc_insertion_point(destructor:manta.proto.TextEntry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TextEntry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.text_.Destroy();
}

void TextEntry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TextEntry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.TextEntry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.text_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* TextEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string text = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_text();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TextEntry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.TextEntry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional string text = 1;
    if (_internal_has_text()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "manta.proto.TextEntry.text");
        target = stream->WriteStringMaybeAliased(1, this->_internal_text(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.TextEntry)
    return target;
}

size_t TextEntry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.TextEntry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string text = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_text());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TextEntry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TextEntry*>(&from));
}

void TextEntry::MergeFrom(const TextEntry& from)
{
    TextEntry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.TextEntry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_text()) {
        _this->_internal_set_text(from._internal_text());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TextEntry::CopyFrom(const TextEntry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.TextEntry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TextEntry::IsInitialized() const
{
    return true;
}

void TextEntry::InternalSwap(TextEntry* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.text_, lhs_arena, &other->_impl_.text_, rhs_arena);
}

std::string TextEntry::GetTypeName() const
{
    return "manta.proto.TextEntry";
}

// ===================================================================

class KeyPress::_Internal {
public:
    using HasBits = decltype(std::declval<KeyPress>()._impl_._has_bits_);
    static void set_has_key(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_control(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_alt(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_shift(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

KeyPress::KeyPress(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.KeyPress)
}
KeyPress::KeyPress(const KeyPress& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    KeyPress* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.key_) {},
        decltype(_impl_.control_) {}, decltype(_impl_.alt_) {}, decltype(_impl_.shift_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_key()) {
        _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.control_, &from._impl_.control_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.shift_) - reinterpret_cast<char*>(&_impl_.control_)) + sizeof(_impl_.shift_));
    // @@protoc_insertion_point(copy_constructor:manta.proto.KeyPress)
}

inline void KeyPress::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.key_) {}, decltype(_impl_.control_) { false },
        decltype(_impl_.alt_) { false }, decltype(_impl_.shift_) { false } };
    _impl_.key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KeyPress::~KeyPress()
{
    // @@protoc_insertion_point(destructor:manta.proto.KeyPress)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void KeyPress::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.key_.Destroy();
}

void KeyPress::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void KeyPress::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.KeyPress)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.key_.ClearNonDefaultToEmpty();
    }
    ::memset(
        &_impl_.control_, 0, static_cast<size_t>(reinterpret_cast<char*>(&_impl_.shift_) - reinterpret_cast<char*>(&_impl_.control_)) + sizeof(_impl_.shift_));
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* KeyPress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string key = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool control = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_control(&has_bits);
                _impl_.control_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool alt = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_alt(&has_bits);
                _impl_.alt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool shift = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_shift(&has_bits);
                _impl_.shift_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* KeyPress::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.KeyPress)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional string key = 1;
    if (_internal_has_key()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "manta.proto.KeyPress.key");
        target = stream->WriteStringMaybeAliased(1, this->_internal_key(), target);
    }

    // optional bool control = 2;
    if (_internal_has_control()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_control(), target);
    }

    // optional bool alt = 3;
    if (_internal_has_alt()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_alt(), target);
    }

    // optional bool shift = 4;
    if (_internal_has_shift()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_shift(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.KeyPress)
    return target;
}

size_t KeyPress::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.KeyPress)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string key = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_key());
        }

        // optional bool control = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }

        // optional bool alt = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }

        // optional bool shift = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void KeyPress::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const KeyPress*>(&from));
}

void KeyPress::MergeFrom(const KeyPress& from)
{
    KeyPress* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.KeyPress)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_key(from._internal_key());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.control_ = from._impl_.control_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.alt_ = from._impl_.alt_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.shift_ = from._impl_.shift_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeyPress::CopyFrom(const KeyPress& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.KeyPress)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool KeyPress::IsInitialized() const
{
    return true;
}

void KeyPress::InternalSwap(KeyPress* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena, &other->_impl_.key_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(KeyPress, _impl_.shift_) + sizeof(KeyPress::_impl_.shift_)
        - PROTOBUF_FIELD_OFFSET(KeyPress, _impl_.control_)>(reinterpret_cast<char*>(&_impl_.control_), reinterpret_cast<char*>(&other->_impl_.control_));
}

std::string KeyPress::GetTypeName() const
{
    return "manta.proto.KeyPress";
}

// ===================================================================

class Click::_Internal {
public:
    using HasBits = decltype(std::declval<Click>()._impl_._has_bits_);
    static void set_has_x_pos(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_y_pos(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_button(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

Click::Click(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.Click)
}
Click::Click(const Click& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Click* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.x_pos_) {},
        decltype(_impl_.y_pos_) {}, decltype(_impl_.button_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.x_pos_, &from._impl_.x_pos_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.button_) - reinterpret_cast<char*>(&_impl_.x_pos_)) + sizeof(_impl_.button_));
    // @@protoc_insertion_point(copy_constructor:manta.proto.Click)
}

inline void Click::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.x_pos_) { 0 }, decltype(_impl_.y_pos_) { 0 },
        decltype(_impl_.button_) { 0 } };
}

Click::~Click()
{
    // @@protoc_insertion_point(destructor:manta.proto.Click)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Click::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Click::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Click::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.Click)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        ::memset(&_impl_.x_pos_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.button_) - reinterpret_cast<char*>(&_impl_.x_pos_)) + sizeof(_impl_.button_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Click::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 x_pos = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_x_pos(&has_bits);
                _impl_.x_pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 y_pos = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_y_pos(&has_bits);
                _impl_.y_pos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.Click.Button button = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_button(static_cast<::manta::proto::Click_Button>(val));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Click::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.Click)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional int32 x_pos = 1;
    if (_internal_has_x_pos()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x_pos(), target);
    }

    // optional int32 y_pos = 2;
    if (_internal_has_y_pos()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y_pos(), target);
    }

    // optional .manta.proto.Click.Button button = 3;
    if (_internal_has_button()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_button(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.Click)
    return target;
}

size_t Click::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.Click)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional int32 x_pos = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x_pos());
        }

        // optional int32 y_pos = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y_pos());
        }

        // optional .manta.proto.Click.Button button = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_button());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Click::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Click*>(&from));
}

void Click::MergeFrom(const Click& from)
{
    Click* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.Click)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.x_pos_ = from._impl_.x_pos_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.y_pos_ = from._impl_.y_pos_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.button_ = from._impl_.button_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Click::CopyFrom(const Click& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.Click)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Click::IsInitialized() const
{
    return true;
}

void Click::InternalSwap(Click* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Click, _impl_.button_) + sizeof(Click::_impl_.button_)
        - PROTOBUF_FIELD_OFFSET(Click, _impl_.x_pos_)>(reinterpret_cast<char*>(&_impl_.x_pos_), reinterpret_cast<char*>(&other->_impl_.x_pos_));
}

std::string Click::GetTypeName() const
{
    return "manta.proto.Click";
}

// ===================================================================

class Scroll::_Internal {
public:
    using HasBits = decltype(std::declval<Scroll>()._impl_._has_bits_);
    static void set_has_direction(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_distance(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

Scroll::Scroll(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.Scroll)
}
Scroll::Scroll(const Scroll& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Scroll* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.direction_) {},
        decltype(_impl_.distance_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.direction_, &from._impl_.direction_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.distance_) - reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.distance_));
    // @@protoc_insertion_point(copy_constructor:manta.proto.Scroll)
}

inline void Scroll::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.direction_) { 0 }, decltype(_impl_.distance_) { 0 } };
}

Scroll::~Scroll()
{
    // @@protoc_insertion_point(destructor:manta.proto.Scroll)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Scroll::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Scroll::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Scroll::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.Scroll)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.direction_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.distance_) - reinterpret_cast<char*>(&_impl_.direction_)) + sizeof(_impl_.distance_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Scroll::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .manta.proto.Scroll.Direction direction = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_direction(static_cast<::manta::proto::Scroll_Direction>(val));
            } else
                goto handle_unusual;
            continue;
        // optional int32 distance = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_distance(&has_bits);
                _impl_.distance_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Scroll::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.Scroll)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional .manta.proto.Scroll.Direction direction = 1;
    if (_internal_has_direction()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_direction(), target);
    }

    // optional int32 distance = 2;
    if (_internal_has_distance()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_distance(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.Scroll)
    return target;
}

size_t Scroll::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.Scroll)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .manta.proto.Scroll.Direction direction = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
        }

        // optional int32 distance = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_distance());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Scroll::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Scroll*>(&from));
}

void Scroll::MergeFrom(const Scroll& from)
{
    Scroll* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.Scroll)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.direction_ = from._impl_.direction_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.distance_ = from._impl_.distance_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Scroll::CopyFrom(const Scroll& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.Scroll)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Scroll::IsInitialized() const
{
    return true;
}

void Scroll::InternalSwap(Scroll* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Scroll, _impl_.distance_) + sizeof(Scroll::_impl_.distance_)
        - PROTOBUF_FIELD_OFFSET(Scroll, _impl_.direction_)>(reinterpret_cast<char*>(&_impl_.direction_), reinterpret_cast<char*>(&other->_impl_.direction_));
}

std::string Scroll::GetTypeName() const
{
    return "manta.proto.Scroll";
}

// ===================================================================

class LaunchFile::_Internal {
public:
    using HasBits = decltype(std::declval<LaunchFile>()._impl_._has_bits_);
    static void set_has_launch_file_path(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

LaunchFile::LaunchFile(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.LaunchFile)
}
LaunchFile::LaunchFile(const LaunchFile& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LaunchFile* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.launch_file_path_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.launch_file_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.launch_file_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_launch_file_path()) {
        _this->_impl_.launch_file_path_.Set(from._internal_launch_file_path(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:manta.proto.LaunchFile)
}

inline void LaunchFile::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.launch_file_path_) {} };
    _impl_.launch_file_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.launch_file_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LaunchFile::~LaunchFile()
{
    // @@protoc_insertion_point(destructor:manta.proto.LaunchFile)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LaunchFile::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.launch_file_path_.Destroy();
}

void LaunchFile::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LaunchFile::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.LaunchFile)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.launch_file_path_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LaunchFile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string launch_file_path = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_launch_file_path();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LaunchFile::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.LaunchFile)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional string launch_file_path = 1;
    if (_internal_has_launch_file_path()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_launch_file_path().data(),
            static_cast<int>(this->_internal_launch_file_path().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "manta.proto.LaunchFile.launch_file_path");
        target = stream->WriteStringMaybeAliased(1, this->_internal_launch_file_path(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.LaunchFile)
    return target;
}

size_t LaunchFile::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.LaunchFile)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string launch_file_path = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_launch_file_path());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LaunchFile::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LaunchFile*>(&from));
}

void LaunchFile::MergeFrom(const LaunchFile& from)
{
    LaunchFile* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.LaunchFile)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_launch_file_path()) {
        _this->_internal_set_launch_file_path(from._internal_launch_file_path());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LaunchFile::CopyFrom(const LaunchFile& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.LaunchFile)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LaunchFile::IsInitialized() const
{
    return true;
}

void LaunchFile::InternalSwap(LaunchFile* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.launch_file_path_, lhs_arena, &other->_impl_.launch_file_path_, rhs_arena);
}

std::string LaunchFile::GetTypeName() const
{
    return "manta.proto.LaunchFile";
}

// ===================================================================

class WriteFile::_Internal {
public:
    using HasBits = decltype(std::declval<WriteFile>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_file_bytes(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

WriteFile::WriteFile(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.WriteFile)
}
WriteFile::WriteFile(const WriteFile& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WriteFile* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {},
        decltype(_impl_.file_bytes_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.file_bytes_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_bytes_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_file_bytes()) {
        _this->_impl_.file_bytes_.Set(from._internal_file_bytes(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:manta.proto.WriteFile)
}

inline void WriteFile::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {}, decltype(_impl_.file_bytes_) {} };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_bytes_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_bytes_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WriteFile::~WriteFile()
{
    // @@protoc_insertion_point(destructor:manta.proto.WriteFile)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WriteFile::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_.Destroy();
    _impl_.file_bytes_.Destroy();
}

void WriteFile::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WriteFile::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.WriteFile)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.file_bytes_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WriteFile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // optional string file_bytes = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_file_bytes();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WriteFile::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.WriteFile)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional string name = 1;
    if (_internal_has_name()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "manta.proto.WriteFile.name");
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional string file_bytes = 2;
    if (_internal_has_file_bytes()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_file_bytes().data(),
            static_cast<int>(this->_internal_file_bytes().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "manta.proto.WriteFile.file_bytes");
        target = stream->WriteStringMaybeAliased(2, this->_internal_file_bytes(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.WriteFile)
    return target;
}

size_t WriteFile::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.WriteFile)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string file_bytes = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_file_bytes());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WriteFile::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WriteFile*>(&from));
}

void WriteFile::MergeFrom(const WriteFile& from)
{
    WriteFile* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.WriteFile)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_file_bytes(from._internal_file_bytes());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WriteFile::CopyFrom(const WriteFile& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.WriteFile)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WriteFile::IsInitialized() const
{
    return true;
}

void WriteFile::InternalSwap(WriteFile* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.file_bytes_, lhs_arena, &other->_impl_.file_bytes_, rhs_arena);
}

std::string WriteFile::GetTypeName() const
{
    return "manta.proto.WriteFile";
}

// ===================================================================

class Action::_Internal {
public:
    static const ::manta::proto::Setting& update_setting(const Action* msg);
    static const ::manta::proto::Click& click(const Action* msg);
    static const ::manta::proto::TextEntry& text_entry(const Action* msg);
    static const ::manta::proto::LaunchFile& launch_file(const Action* msg);
    static const ::manta::proto::KeyPress& key_press(const Action* msg);
    static const ::manta::proto::Scroll& scroll(const Action* msg);
    static const ::manta::proto::WriteFile& write_file(const Action* msg);
};

const ::manta::proto::Setting& Action::_Internal::update_setting(const Action* msg)
{
    return *msg->_impl_.action_.update_setting_;
}
const ::manta::proto::Click& Action::_Internal::click(const Action* msg)
{
    return *msg->_impl_.action_.click_;
}
const ::manta::proto::TextEntry& Action::_Internal::text_entry(const Action* msg)
{
    return *msg->_impl_.action_.text_entry_;
}
const ::manta::proto::LaunchFile& Action::_Internal::launch_file(const Action* msg)
{
    return *msg->_impl_.action_.launch_file_;
}
const ::manta::proto::KeyPress& Action::_Internal::key_press(const Action* msg)
{
    return *msg->_impl_.action_.key_press_;
}
const ::manta::proto::Scroll& Action::_Internal::scroll(const Action* msg)
{
    return *msg->_impl_.action_.scroll_;
}
const ::manta::proto::WriteFile& Action::_Internal::write_file(const Action* msg)
{
    return *msg->_impl_.action_.write_file_;
}
void Action::set_allocated_update_setting(::manta::proto::Setting* update_setting)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_action();
    if (update_setting) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(update_setting);
        if (message_arena != submessage_arena) {
            update_setting = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, update_setting, submessage_arena);
        }
        set_has_update_setting();
        _impl_.action_.update_setting_ = update_setting;
    }
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Action.update_setting)
}
void Action::set_allocated_click(::manta::proto::Click* click)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_action();
    if (click) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(click);
        if (message_arena != submessage_arena) {
            click = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, click, submessage_arena);
        }
        set_has_click();
        _impl_.action_.click_ = click;
    }
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Action.click)
}
void Action::set_allocated_text_entry(::manta::proto::TextEntry* text_entry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_action();
    if (text_entry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_entry);
        if (message_arena != submessage_arena) {
            text_entry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, text_entry, submessage_arena);
        }
        set_has_text_entry();
        _impl_.action_.text_entry_ = text_entry;
    }
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Action.text_entry)
}
void Action::set_allocated_launch_file(::manta::proto::LaunchFile* launch_file)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_action();
    if (launch_file) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(launch_file);
        if (message_arena != submessage_arena) {
            launch_file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, launch_file, submessage_arena);
        }
        set_has_launch_file();
        _impl_.action_.launch_file_ = launch_file;
    }
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Action.launch_file)
}
void Action::set_allocated_key_press(::manta::proto::KeyPress* key_press)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_action();
    if (key_press) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(key_press);
        if (message_arena != submessage_arena) {
            key_press = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, key_press, submessage_arena);
        }
        set_has_key_press();
        _impl_.action_.key_press_ = key_press;
    }
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Action.key_press)
}
void Action::set_allocated_scroll(::manta::proto::Scroll* scroll)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_action();
    if (scroll) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scroll);
        if (message_arena != submessage_arena) {
            scroll = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, scroll, submessage_arena);
        }
        set_has_scroll();
        _impl_.action_.scroll_ = scroll;
    }
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Action.scroll)
}
void Action::set_allocated_write_file(::manta::proto::WriteFile* write_file)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_action();
    if (write_file) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(write_file);
        if (message_arena != submessage_arena) {
            write_file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, write_file, submessage_arena);
        }
        set_has_write_file();
        _impl_.action_.write_file_ = write_file;
    }
    // @@protoc_insertion_point(field_set_allocated:manta.proto.Action.write_file)
}
Action::Action(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.Action)
}
Action::Action(const Action& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Action* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.action_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_action();
    switch (from.action_case()) {
    case kUpdateSetting: {
        _this->_internal_mutable_update_setting()->::manta::proto::Setting::MergeFrom(from._internal_update_setting());
        break;
    }
    case kLaunchAppId: {
        _this->_internal_set_launch_app_id(from._internal_launch_app_id());
        break;
    }
    case kClick: {
        _this->_internal_mutable_click()->::manta::proto::Click::MergeFrom(from._internal_click());
        break;
    }
    case kTextEntry: {
        _this->_internal_mutable_text_entry()->::manta::proto::TextEntry::MergeFrom(from._internal_text_entry());
        break;
    }
    case kAllDone: {
        _this->_internal_set_all_done(from._internal_all_done());
        break;
    }
    case kLaunchFile: {
        _this->_internal_mutable_launch_file()->::manta::proto::LaunchFile::MergeFrom(from._internal_launch_file());
        break;
    }
    case kKeyPress: {
        _this->_internal_mutable_key_press()->::manta::proto::KeyPress::MergeFrom(from._internal_key_press());
        break;
    }
    case kScroll: {
        _this->_internal_mutable_scroll()->::manta::proto::Scroll::MergeFrom(from._internal_scroll());
        break;
    }
    case kWriteFile: {
        _this->_internal_mutable_write_file()->::manta::proto::WriteFile::MergeFrom(from._internal_write_file());
        break;
    }
    case ACTION_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:manta.proto.Action)
}

inline void Action::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.action_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_action();
}

Action::~Action()
{
    // @@protoc_insertion_point(destructor:manta.proto.Action)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Action::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_action()) {
        clear_action();
    }
}

void Action::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Action::clear_action()
{
    // @@protoc_insertion_point(one_of_clear_start:manta.proto.Action)
    switch (action_case()) {
    case kUpdateSetting: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.update_setting_;
        }
        break;
    }
    case kLaunchAppId: {
        _impl_.action_.launch_app_id_.Destroy();
        break;
    }
    case kClick: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.click_;
        }
        break;
    }
    case kTextEntry: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.text_entry_;
        }
        break;
    }
    case kAllDone: {
        // No need to clear
        break;
    }
    case kLaunchFile: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.launch_file_;
        }
        break;
    }
    case kKeyPress: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.key_press_;
        }
        break;
    }
    case kScroll: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.scroll_;
        }
        break;
    }
    case kWriteFile: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.write_file_;
        }
        break;
    }
    case ACTION_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = ACTION_NOT_SET;
}

void Action::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.Action)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_action();
    _internal_metadata_.Clear<std::string>();
}

const char* Action::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .manta.proto.Setting update_setting = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_update_setting(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string launch_app_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_launch_app_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // .manta.proto.Click click = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_click(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .manta.proto.TextEntry text_entry = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_text_entry(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bool all_done = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _internal_set_all_done(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .manta.proto.LaunchFile launch_file = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_launch_file(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .manta.proto.KeyPress key_press = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_key_press(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .manta.proto.Scroll scroll = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_scroll(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .manta.proto.WriteFile write_file = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr = ctx->ParseMessage(_internal_mutable_write_file(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Action::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.Action)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .manta.proto.Setting update_setting = 1;
    if (_internal_has_update_setting()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::update_setting(this), _Internal::update_setting(this).GetCachedSize(), target, stream);
    }

    // string launch_app_id = 2;
    if (_internal_has_launch_app_id()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_launch_app_id().data(),
            static_cast<int>(this->_internal_launch_app_id().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "manta.proto.Action.launch_app_id");
        target = stream->WriteStringMaybeAliased(2, this->_internal_launch_app_id(), target);
    }

    // .manta.proto.Click click = 3;
    if (_internal_has_click()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::click(this), _Internal::click(this).GetCachedSize(), target, stream);
    }

    // .manta.proto.TextEntry text_entry = 4;
    if (_internal_has_text_entry()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::text_entry(this), _Internal::text_entry(this).GetCachedSize(), target, stream);
    }

    // bool all_done = 5;
    if (_internal_has_all_done()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_all_done(), target);
    }

    // .manta.proto.LaunchFile launch_file = 6;
    if (_internal_has_launch_file()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::launch_file(this), _Internal::launch_file(this).GetCachedSize(), target, stream);
    }

    // .manta.proto.KeyPress key_press = 7;
    if (_internal_has_key_press()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::key_press(this), _Internal::key_press(this).GetCachedSize(), target, stream);
    }

    // .manta.proto.Scroll scroll = 8;
    if (_internal_has_scroll()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            8, _Internal::scroll(this), _Internal::scroll(this).GetCachedSize(), target, stream);
    }

    // .manta.proto.WriteFile write_file = 9;
    if (_internal_has_write_file()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            9, _Internal::write_file(this), _Internal::write_file(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.Action)
    return target;
}

size_t Action::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.Action)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (action_case()) {
    // .manta.proto.Setting update_setting = 1;
    case kUpdateSetting: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.action_.update_setting_);
        break;
    }
    // string launch_app_id = 2;
    case kLaunchAppId: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_launch_app_id());
        break;
    }
    // .manta.proto.Click click = 3;
    case kClick: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.action_.click_);
        break;
    }
    // .manta.proto.TextEntry text_entry = 4;
    case kTextEntry: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.action_.text_entry_);
        break;
    }
    // bool all_done = 5;
    case kAllDone: {
        total_size += 1 + 1;
        break;
    }
    // .manta.proto.LaunchFile launch_file = 6;
    case kLaunchFile: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.action_.launch_file_);
        break;
    }
    // .manta.proto.KeyPress key_press = 7;
    case kKeyPress: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.action_.key_press_);
        break;
    }
    // .manta.proto.Scroll scroll = 8;
    case kScroll: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.action_.scroll_);
        break;
    }
    // .manta.proto.WriteFile write_file = 9;
    case kWriteFile: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.action_.write_file_);
        break;
    }
    case ACTION_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Action::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Action*>(&from));
}

void Action::MergeFrom(const Action& from)
{
    Action* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.Action)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.action_case()) {
    case kUpdateSetting: {
        _this->_internal_mutable_update_setting()->::manta::proto::Setting::MergeFrom(from._internal_update_setting());
        break;
    }
    case kLaunchAppId: {
        _this->_internal_set_launch_app_id(from._internal_launch_app_id());
        break;
    }
    case kClick: {
        _this->_internal_mutable_click()->::manta::proto::Click::MergeFrom(from._internal_click());
        break;
    }
    case kTextEntry: {
        _this->_internal_mutable_text_entry()->::manta::proto::TextEntry::MergeFrom(from._internal_text_entry());
        break;
    }
    case kAllDone: {
        _this->_internal_set_all_done(from._internal_all_done());
        break;
    }
    case kLaunchFile: {
        _this->_internal_mutable_launch_file()->::manta::proto::LaunchFile::MergeFrom(from._internal_launch_file());
        break;
    }
    case kKeyPress: {
        _this->_internal_mutable_key_press()->::manta::proto::KeyPress::MergeFrom(from._internal_key_press());
        break;
    }
    case kScroll: {
        _this->_internal_mutable_scroll()->::manta::proto::Scroll::MergeFrom(from._internal_scroll());
        break;
    }
    case kWriteFile: {
        _this->_internal_mutable_write_file()->::manta::proto::WriteFile::MergeFrom(from._internal_write_file());
        break;
    }
    case ACTION_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Action::CopyFrom(const Action& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.Action)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Action::IsInitialized() const
{
    return true;
}

void Action::InternalSwap(Action* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.action_, other->_impl_.action_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string Action::GetTypeName() const
{
    return "manta.proto.Action";
}

// ===================================================================

class DiagnosticsRequest::_Internal {
public:
};

DiagnosticsRequest::DiagnosticsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.DiagnosticsRequest)
}
DiagnosticsRequest::DiagnosticsRequest(const DiagnosticsRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DiagnosticsRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.diagnostics_) { from._impl_.diagnostics_ }, /*decltype(_impl_._diagnostics_cached_byte_size_)*/ { 0 },
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:manta.proto.DiagnosticsRequest)
}

inline void DiagnosticsRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_.diagnostics_) { arena }, /*decltype(_impl_._diagnostics_cached_byte_size_)*/ { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
}

DiagnosticsRequest::~DiagnosticsRequest()
{
    // @@protoc_insertion_point(destructor:manta.proto.DiagnosticsRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DiagnosticsRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.diagnostics_.~RepeatedField();
}

void DiagnosticsRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DiagnosticsRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.DiagnosticsRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.diagnostics_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DiagnosticsRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .manta.proto.Diagnostics diagnostics = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_diagnostics(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 8) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_add_diagnostics(static_cast<::manta::proto::Diagnostics>(val));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DiagnosticsRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.DiagnosticsRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .manta.proto.Diagnostics diagnostics = 1;
    {
        int byte_size = _impl_._diagnostics_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteEnumPacked(1, _impl_.diagnostics_, byte_size, target);
        }
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.DiagnosticsRequest)
    return target;
}

size_t DiagnosticsRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.DiagnosticsRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .manta.proto.Diagnostics diagnostics = 1;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_diagnostics_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_diagnostics(static_cast<int>(i)));
        }
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._diagnostics_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DiagnosticsRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DiagnosticsRequest*>(&from));
}

void DiagnosticsRequest::MergeFrom(const DiagnosticsRequest& from)
{
    DiagnosticsRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.DiagnosticsRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.diagnostics_.MergeFrom(from._impl_.diagnostics_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DiagnosticsRequest::CopyFrom(const DiagnosticsRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.DiagnosticsRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DiagnosticsRequest::IsInitialized() const
{
    return true;
}

void DiagnosticsRequest::InternalSwap(DiagnosticsRequest* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.diagnostics_.InternalSwap(&other->_impl_.diagnostics_);
}

std::string DiagnosticsRequest::GetTypeName() const
{
    return "manta.proto.DiagnosticsRequest";
}

// ===================================================================

class SettingsDataRequest::_Internal {
public:
};

SettingsDataRequest::SettingsDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.SettingsDataRequest)
}
SettingsDataRequest::SettingsDataRequest(const SettingsDataRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SettingsDataRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:manta.proto.SettingsDataRequest)
}

inline void SettingsDataRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

SettingsDataRequest::~SettingsDataRequest()
{
    // @@protoc_insertion_point(destructor:manta.proto.SettingsDataRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SettingsDataRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SettingsDataRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SettingsDataRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.SettingsDataRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* SettingsDataRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SettingsDataRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.SettingsDataRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.SettingsDataRequest)
    return target;
}

size_t SettingsDataRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.SettingsDataRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SettingsDataRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SettingsDataRequest*>(&from));
}

void SettingsDataRequest::MergeFrom(const SettingsDataRequest& from)
{
    SettingsDataRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.SettingsDataRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SettingsDataRequest::CopyFrom(const SettingsDataRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.SettingsDataRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SettingsDataRequest::IsInitialized() const
{
    return true;
}

void SettingsDataRequest::InternalSwap(SettingsDataRequest* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string SettingsDataRequest::GetTypeName() const
{
    return "manta.proto.SettingsDataRequest";
}

// ===================================================================

class FileRequest::_Internal {
public:
};

FileRequest::FileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.FileRequest)
}
FileRequest::FileRequest(const FileRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    FileRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.paths_) { from._impl_.paths_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:manta.proto.FileRequest)
}

inline void FileRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.paths_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

FileRequest::~FileRequest()
{
    // @@protoc_insertion_point(destructor:manta.proto.FileRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void FileRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.paths_.~RepeatedPtrField();
}

void FileRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void FileRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.FileRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.paths_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* FileRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated string paths = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_paths();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    CHK_(::_pbi::VerifyUTF8(str, nullptr));
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* FileRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.FileRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated string paths = 1;
    for (int i = 0, n = this->_internal_paths_size(); i < n; i++) {
        const auto& s = this->_internal_paths(i);
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
            s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "manta.proto.FileRequest.paths");
        target = stream->WriteString(1, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.FileRequest)
    return target;
}

size_t FileRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.FileRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string paths = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.paths_.size());
    for (int i = 0, n = _impl_.paths_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.paths_.Get(i));
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void FileRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const FileRequest*>(&from));
}

void FileRequest::MergeFrom(const FileRequest& from)
{
    FileRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.FileRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.paths_.MergeFrom(from._impl_.paths_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FileRequest::CopyFrom(const FileRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.FileRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FileRequest::IsInitialized() const
{
    return true;
}

void FileRequest::InternalSwap(FileRequest* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.paths_.InternalSwap(&other->_impl_.paths_);
}

std::string FileRequest::GetTypeName() const
{
    return "manta.proto.FileRequest";
}

// ===================================================================

class File::_Internal {
public:
    using HasBits = decltype(std::declval<File>()._impl_._has_bits_);
    static void set_has_path(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_size_in_bytes(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_date_modified(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_serialized_bytes(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_summary(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

File::File(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.File)
}
File::File(const File& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    File* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.path_) {},
        decltype(_impl_.name_) {}, decltype(_impl_.date_modified_) {}, decltype(_impl_.serialized_bytes_) {}, decltype(_impl_.summary_) {},
        decltype(_impl_.size_in_bytes_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_path()) {
        _this->_impl_.path_.Set(from._internal_path(), _this->GetArenaForAllocation());
    }
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.date_modified_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.date_modified_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_date_modified()) {
        _this->_impl_.date_modified_.Set(from._internal_date_modified(), _this->GetArenaForAllocation());
    }
    _impl_.serialized_bytes_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_bytes_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_serialized_bytes()) {
        _this->_impl_.serialized_bytes_.Set(from._internal_serialized_bytes(), _this->GetArenaForAllocation());
    }
    _impl_.summary_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.summary_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_summary()) {
        _this->_impl_.summary_.Set(from._internal_summary(), _this->GetArenaForAllocation());
    }
    _this->_impl_.size_in_bytes_ = from._impl_.size_in_bytes_;
    // @@protoc_insertion_point(copy_constructor:manta.proto.File)
}

inline void File::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.path_) {}, decltype(_impl_.name_) {},
        decltype(_impl_.date_modified_) {}, decltype(_impl_.serialized_bytes_) {}, decltype(_impl_.summary_) {},
        decltype(_impl_.size_in_bytes_) { int64_t { 0 } } };
    _impl_.path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.date_modified_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.date_modified_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_bytes_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_bytes_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.summary_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.summary_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

File::~File()
{
    // @@protoc_insertion_point(destructor:manta.proto.File)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void File::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.path_.Destroy();
    _impl_.name_.Destroy();
    _impl_.date_modified_.Destroy();
    _impl_.serialized_bytes_.Destroy();
    _impl_.summary_.Destroy();
}

void File::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void File::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.File)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.path_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.date_modified_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.serialized_bytes_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.summary_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.size_in_bytes_ = int64_t { 0 };
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* File::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string path = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_path();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // optional string name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // optional int64 size_in_bytes = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_size_in_bytes(&has_bits);
                _impl_.size_in_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string date_modified = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_date_modified();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // optional bytes serialized_bytes = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_serialized_bytes();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string summary = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_summary();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* File::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.File)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional string path = 1;
    if (_internal_has_path()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "manta.proto.File.path");
        target = stream->WriteStringMaybeAliased(1, this->_internal_path(), target);
    }

    // optional string name = 2;
    if (_internal_has_name()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "manta.proto.File.name");
        target = stream->WriteStringMaybeAliased(2, this->_internal_name(), target);
    }

    // optional int64 size_in_bytes = 3;
    if (_internal_has_size_in_bytes()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_size_in_bytes(), target);
    }

    // optional string date_modified = 4;
    if (_internal_has_date_modified()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_date_modified().data(),
            static_cast<int>(this->_internal_date_modified().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "manta.proto.File.date_modified");
        target = stream->WriteStringMaybeAliased(4, this->_internal_date_modified(), target);
    }

    // optional bytes serialized_bytes = 5;
    if (_internal_has_serialized_bytes()) {
        target = stream->WriteBytesMaybeAliased(5, this->_internal_serialized_bytes(), target);
    }

    // optional string summary = 6;
    if (_internal_has_summary()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_summary().data(),
            static_cast<int>(this->_internal_summary().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "manta.proto.File.summary");
        target = stream->WriteStringMaybeAliased(6, this->_internal_summary(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.File)
    return target;
}

size_t File::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.File)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional string path = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_path());
        }

        // optional string name = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string date_modified = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_date_modified());
        }

        // optional bytes serialized_bytes = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_serialized_bytes());
        }

        // optional string summary = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_summary());
        }

        // optional int64 size_in_bytes = 3;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_size_in_bytes());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void File::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const File*>(&from));
}

void File::MergeFrom(const File& from)
{
    File* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.File)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_path(from._internal_path());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_date_modified(from._internal_date_modified());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_serialized_bytes(from._internal_serialized_bytes());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_summary(from._internal_summary());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.size_in_bytes_ = from._impl_.size_in_bytes_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void File::CopyFrom(const File& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.File)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool File::IsInitialized() const
{
    return true;
}

void File::InternalSwap(File* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.path_, lhs_arena, &other->_impl_.path_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.date_modified_, lhs_arena, &other->_impl_.date_modified_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.serialized_bytes_, lhs_arena, &other->_impl_.serialized_bytes_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.summary_, lhs_arena, &other->_impl_.summary_, rhs_arena);
    swap(_impl_.size_in_bytes_, other->_impl_.size_in_bytes_);
}

std::string File::GetTypeName() const
{
    return "manta.proto.File";
}

// ===================================================================

class FilesData::_Internal {
public:
};

FilesData::FilesData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.FilesData)
}
FilesData::FilesData(const FilesData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    FilesData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.files_) { from._impl_.files_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:manta.proto.FilesData)
}

inline void FilesData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.files_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

FilesData::~FilesData()
{
    // @@protoc_insertion_point(destructor:manta.proto.FilesData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void FilesData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.files_.~RepeatedPtrField();
}

void FilesData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void FilesData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.FilesData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.files_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* FilesData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .manta.proto.File files = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_files(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* FilesData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.FilesData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .manta.proto.File files = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_files_size()); i < n; i++) {
        const auto& repfield = this->_internal_files(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.FilesData)
    return target;
}

size_t FilesData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.FilesData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .manta.proto.File files = 1;
    total_size += 1UL * this->_internal_files_size();
    for (const auto& msg : this->_impl_.files_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void FilesData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const FilesData*>(&from));
}

void FilesData::MergeFrom(const FilesData& from)
{
    FilesData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.FilesData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.files_.MergeFrom(from._impl_.files_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FilesData::CopyFrom(const FilesData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.FilesData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FilesData::IsInitialized() const
{
    return true;
}

void FilesData::InternalSwap(FilesData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.files_.InternalSwap(&other->_impl_.files_);
}

std::string FilesData::GetTypeName() const
{
    return "manta.proto.FilesData";
}

// ===================================================================

class Update::_Internal {
public:
    using HasBits = decltype(std::declval<Update>()._impl_._has_bits_);
    static const ::manta::proto::FilesData& files_with_summary(const Update* msg);
    static void set_has_files_with_summary(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::manta::proto::FilesData& Update::_Internal::files_with_summary(const Update* msg)
{
    return *msg->_impl_.files_with_summary_;
}
Update::Update(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.Update)
}
Update::Update(const Update& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Update* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.files_with_summary_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_files_with_summary()) {
        _this->_impl_.files_with_summary_ = new ::manta::proto::FilesData(*from._impl_.files_with_summary_);
    }
    // @@protoc_insertion_point(copy_constructor:manta.proto.Update)
}

inline void Update::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.files_with_summary_) { nullptr } };
}

Update::~Update()
{
    // @@protoc_insertion_point(destructor:manta.proto.Update)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Update::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.files_with_summary_;
}

void Update::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Update::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.Update)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.files_with_summary_ != nullptr);
        _impl_.files_with_summary_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Update::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .manta.proto.FilesData files_with_summary = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_files_with_summary(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Update::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.Update)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional .manta.proto.FilesData files_with_summary = 1;
    if (_internal_has_files_with_summary()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::files_with_summary(this), _Internal::files_with_summary(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.Update)
    return target;
}

size_t Update::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.Update)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .manta.proto.FilesData files_with_summary = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.files_with_summary_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Update::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Update*>(&from));
}

void Update::MergeFrom(const Update& from)
{
    Update* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.Update)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_files_with_summary()) {
        _this->_internal_mutable_files_with_summary()->::manta::proto::FilesData::MergeFrom(from._internal_files_with_summary());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Update::CopyFrom(const Update& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.Update)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Update::IsInitialized() const
{
    return true;
}

void Update::InternalSwap(Update* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.files_with_summary_, other->_impl_.files_with_summary_);
}

std::string Update::GetTypeName() const
{
    return "manta.proto.Update";
}

// ===================================================================

class ContextRequest::_Internal {
public:
    using HasBits = decltype(std::declval<ContextRequest>()._impl_._has_bits_);
    static const ::manta::proto::DiagnosticsRequest& diagnostics(const ContextRequest* msg);
    static void set_has_diagnostics(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::manta::proto::FileRequest& files(const ContextRequest* msg);
    static void set_has_files(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::manta::proto::SettingsDataRequest& settings(const ContextRequest* msg);
    static void set_has_settings(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::manta::proto::DiagnosticsRequest& ContextRequest::_Internal::diagnostics(const ContextRequest* msg)
{
    return *msg->_impl_.diagnostics_;
}
const ::manta::proto::FileRequest& ContextRequest::_Internal::files(const ContextRequest* msg)
{
    return *msg->_impl_.files_;
}
const ::manta::proto::SettingsDataRequest& ContextRequest::_Internal::settings(const ContextRequest* msg)
{
    return *msg->_impl_.settings_;
}
ContextRequest::ContextRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.ContextRequest)
}
ContextRequest::ContextRequest(const ContextRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ContextRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.diagnostics_) { nullptr }, decltype(_impl_.files_) { nullptr }, decltype(_impl_.settings_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_diagnostics()) {
        _this->_impl_.diagnostics_ = new ::manta::proto::DiagnosticsRequest(*from._impl_.diagnostics_);
    }
    if (from._internal_has_files()) {
        _this->_impl_.files_ = new ::manta::proto::FileRequest(*from._impl_.files_);
    }
    if (from._internal_has_settings()) {
        _this->_impl_.settings_ = new ::manta::proto::SettingsDataRequest(*from._impl_.settings_);
    }
    // @@protoc_insertion_point(copy_constructor:manta.proto.ContextRequest)
}

inline void ContextRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.diagnostics_) { nullptr },
        decltype(_impl_.files_) { nullptr }, decltype(_impl_.settings_) { nullptr } };
}

ContextRequest::~ContextRequest()
{
    // @@protoc_insertion_point(destructor:manta.proto.ContextRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ContextRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.diagnostics_;
    if (this != internal_default_instance())
        delete _impl_.files_;
    if (this != internal_default_instance())
        delete _impl_.settings_;
}

void ContextRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ContextRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.ContextRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.diagnostics_ != nullptr);
            _impl_.diagnostics_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.files_ != nullptr);
            _impl_.files_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.settings_ != nullptr);
            _impl_.settings_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ContextRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .manta.proto.DiagnosticsRequest diagnostics = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_diagnostics(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.FileRequest files = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_files(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.SettingsDataRequest settings = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_settings(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ContextRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.ContextRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional .manta.proto.DiagnosticsRequest diagnostics = 1;
    if (_internal_has_diagnostics()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::diagnostics(this), _Internal::diagnostics(this).GetCachedSize(), target, stream);
    }

    // optional .manta.proto.FileRequest files = 2;
    if (_internal_has_files()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::files(this), _Internal::files(this).GetCachedSize(), target, stream);
    }

    // optional .manta.proto.SettingsDataRequest settings = 3;
    if (_internal_has_settings()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::settings(this), _Internal::settings(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.ContextRequest)
    return target;
}

size_t ContextRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.ContextRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional .manta.proto.DiagnosticsRequest diagnostics = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.diagnostics_);
        }

        // optional .manta.proto.FileRequest files = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.files_);
        }

        // optional .manta.proto.SettingsDataRequest settings = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.settings_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ContextRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ContextRequest*>(&from));
}

void ContextRequest::MergeFrom(const ContextRequest& from)
{
    ContextRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.ContextRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_diagnostics()->::manta::proto::DiagnosticsRequest::MergeFrom(from._internal_diagnostics());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_files()->::manta::proto::FileRequest::MergeFrom(from._internal_files());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_settings()->::manta::proto::SettingsDataRequest::MergeFrom(from._internal_settings());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContextRequest::CopyFrom(const ContextRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.ContextRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ContextRequest::IsInitialized() const
{
    return true;
}

void ContextRequest::InternalSwap(ContextRequest* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ContextRequest, _impl_.settings_) + sizeof(ContextRequest::_impl_.settings_)
        - PROTOBUF_FIELD_OFFSET(ContextRequest, _impl_.diagnostics_)>(
        reinterpret_cast<char*>(&_impl_.diagnostics_), reinterpret_cast<char*>(&other->_impl_.diagnostics_));
}

std::string ContextRequest::GetTypeName() const
{
    return "manta.proto.ContextRequest";
}

// ===================================================================

class Turn::_Internal {
public:
    using HasBits = decltype(std::declval<Turn>()._impl_._has_bits_);
    static void set_has_message(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_role(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::manta::proto::Image& screenshot(const Turn* msg);
    static void set_has_screenshot(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::manta::proto::Image& Turn::_Internal::screenshot(const Turn* msg)
{
    return *msg->_impl_.screenshot_;
}
void Turn::clear_screenshot()
{
    if (_impl_.screenshot_ != nullptr)
        _impl_.screenshot_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
Turn::Turn(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.Turn)
}
Turn::Turn(const Turn& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Turn* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.action_) { from._impl_.action_ }, decltype(_impl_.message_) {}, decltype(_impl_.screenshot_) { nullptr }, decltype(_impl_.role_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_message()) {
        _this->_impl_.message_.Set(from._internal_message(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_screenshot()) {
        _this->_impl_.screenshot_ = new ::manta::proto::Image(*from._impl_.screenshot_);
    }
    _this->_impl_.role_ = from._impl_.role_;
    // @@protoc_insertion_point(copy_constructor:manta.proto.Turn)
}

inline void Turn::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.action_) { arena },
        decltype(_impl_.message_) {}, decltype(_impl_.screenshot_) { nullptr }, decltype(_impl_.role_) { 0 } };
    _impl_.message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Turn::~Turn()
{
    // @@protoc_insertion_point(destructor:manta.proto.Turn)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Turn::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.action_.~RepeatedPtrField();
    _impl_.message_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.screenshot_;
}

void Turn::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Turn::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.Turn)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.action_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.message_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.screenshot_ != nullptr);
            _impl_.screenshot_->Clear();
        }
    }
    _impl_.role_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Turn::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string message = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_message();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.Role role = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_role(static_cast<::manta::proto::Role>(val));
            } else
                goto handle_unusual;
            continue;
        // repeated .manta.proto.Action action = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_action(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.Image screenshot = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_screenshot(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Turn::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.Turn)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional string message = 1;
    if (_internal_has_message()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_message().data(),
            static_cast<int>(this->_internal_message().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "manta.proto.Turn.message");
        target = stream->WriteStringMaybeAliased(1, this->_internal_message(), target);
    }

    // optional .manta.proto.Role role = 2;
    if (_internal_has_role()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_role(), target);
    }

    // repeated .manta.proto.Action action = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_action_size()); i < n; i++) {
        const auto& repfield = this->_internal_action(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .manta.proto.Image screenshot = 4;
    if (_internal_has_screenshot()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::screenshot(this), _Internal::screenshot(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.Turn)
    return target;
}

size_t Turn::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.Turn)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .manta.proto.Action action = 3;
    total_size += 1UL * this->_internal_action_size();
    for (const auto& msg : this->_impl_.action_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string message = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_message());
        }

        // optional .manta.proto.Image screenshot = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.screenshot_);
        }

        // optional .manta.proto.Role role = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_role());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Turn::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Turn*>(&from));
}

void Turn::MergeFrom(const Turn& from)
{
    Turn* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.Turn)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.action_.MergeFrom(from._impl_.action_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_message(from._internal_message());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_screenshot()->::manta::proto::Image::MergeFrom(from._internal_screenshot());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.role_ = from._impl_.role_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Turn::CopyFrom(const Turn& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.Turn)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Turn::IsInitialized() const
{
    return true;
}

void Turn::InternalSwap(Turn* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.action_.InternalSwap(&other->_impl_.action_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.message_, lhs_arena, &other->_impl_.message_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Turn, _impl_.role_) + sizeof(Turn::_impl_.role_)
        - PROTOBUF_FIELD_OFFSET(Turn, _impl_.screenshot_)>(reinterpret_cast<char*>(&_impl_.screenshot_), reinterpret_cast<char*>(&other->_impl_.screenshot_));
}

std::string Turn::GetTypeName() const
{
    return "manta.proto.Turn";
}

// ===================================================================

class SparkyResponse::_Internal {
public:
    using HasBits = decltype(std::declval<SparkyResponse>()._impl_._has_bits_);
    static const ::manta::proto::ContextRequest& context_request(const SparkyResponse* msg);
    static void set_has_context_request(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::manta::proto::Turn& latest_reply(const SparkyResponse* msg);
    static void set_has_latest_reply(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::manta::proto::Update& update(const SparkyResponse* msg);
    static void set_has_update(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::manta::proto::ContextRequest& SparkyResponse::_Internal::context_request(const SparkyResponse* msg)
{
    return *msg->_impl_.context_request_;
}
const ::manta::proto::Turn& SparkyResponse::_Internal::latest_reply(const SparkyResponse* msg)
{
    return *msg->_impl_.latest_reply_;
}
const ::manta::proto::Update& SparkyResponse::_Internal::update(const SparkyResponse* msg)
{
    return *msg->_impl_.update_;
}
SparkyResponse::SparkyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.SparkyResponse)
}
SparkyResponse::SparkyResponse(const SparkyResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SparkyResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.context_request_) { nullptr }, decltype(_impl_.latest_reply_) { nullptr }, decltype(_impl_.update_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_context_request()) {
        _this->_impl_.context_request_ = new ::manta::proto::ContextRequest(*from._impl_.context_request_);
    }
    if (from._internal_has_latest_reply()) {
        _this->_impl_.latest_reply_ = new ::manta::proto::Turn(*from._impl_.latest_reply_);
    }
    if (from._internal_has_update()) {
        _this->_impl_.update_ = new ::manta::proto::Update(*from._impl_.update_);
    }
    // @@protoc_insertion_point(copy_constructor:manta.proto.SparkyResponse)
}

inline void SparkyResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.context_request_) { nullptr },
        decltype(_impl_.latest_reply_) { nullptr }, decltype(_impl_.update_) { nullptr } };
}

SparkyResponse::~SparkyResponse()
{
    // @@protoc_insertion_point(destructor:manta.proto.SparkyResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SparkyResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.context_request_;
    if (this != internal_default_instance())
        delete _impl_.latest_reply_;
    if (this != internal_default_instance())
        delete _impl_.update_;
}

void SparkyResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SparkyResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.SparkyResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.context_request_ != nullptr);
            _impl_.context_request_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.latest_reply_ != nullptr);
            _impl_.latest_reply_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.update_ != nullptr);
            _impl_.update_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SparkyResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .manta.proto.ContextRequest context_request = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_context_request(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.Turn latest_reply = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_latest_reply(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.Update update = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_update(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SparkyResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.SparkyResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional .manta.proto.ContextRequest context_request = 1;
    if (_internal_has_context_request()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::context_request(this), _Internal::context_request(this).GetCachedSize(), target, stream);
    }

    // optional .manta.proto.Turn latest_reply = 2;
    if (_internal_has_latest_reply()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::latest_reply(this), _Internal::latest_reply(this).GetCachedSize(), target, stream);
    }

    // optional .manta.proto.Update update = 3;
    if (_internal_has_update()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::update(this), _Internal::update(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.SparkyResponse)
    return target;
}

size_t SparkyResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.SparkyResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional .manta.proto.ContextRequest context_request = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.context_request_);
        }

        // optional .manta.proto.Turn latest_reply = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.latest_reply_);
        }

        // optional .manta.proto.Update update = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.update_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SparkyResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SparkyResponse*>(&from));
}

void SparkyResponse::MergeFrom(const SparkyResponse& from)
{
    SparkyResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.SparkyResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_context_request()->::manta::proto::ContextRequest::MergeFrom(from._internal_context_request());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_latest_reply()->::manta::proto::Turn::MergeFrom(from._internal_latest_reply());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_update()->::manta::proto::Update::MergeFrom(from._internal_update());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SparkyResponse::CopyFrom(const SparkyResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.SparkyResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SparkyResponse::IsInitialized() const
{
    return true;
}

void SparkyResponse::InternalSwap(SparkyResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(SparkyResponse, _impl_.update_) + sizeof(SparkyResponse::_impl_.update_)
        - PROTOBUF_FIELD_OFFSET(SparkyResponse, _impl_.context_request_)>(
        reinterpret_cast<char*>(&_impl_.context_request_), reinterpret_cast<char*>(&other->_impl_.context_request_));
}

std::string SparkyResponse::GetTypeName() const
{
    return "manta.proto.SparkyResponse";
}

// ===================================================================

class WebContent::_Internal {
public:
    using HasBits = decltype(std::declval<WebContent>()._impl_._has_bits_);
    static void set_has_page_contents(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_page_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

WebContent::WebContent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.WebContent)
}
WebContent::WebContent(const WebContent& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WebContent* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.page_contents_) {},
        decltype(_impl_.page_url_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.page_contents_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_contents_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_page_contents()) {
        _this->_impl_.page_contents_.Set(from._internal_page_contents(), _this->GetArenaForAllocation());
    }
    _impl_.page_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_page_url()) {
        _this->_impl_.page_url_.Set(from._internal_page_url(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:manta.proto.WebContent)
}

inline void WebContent::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.page_contents_) {}, decltype(_impl_.page_url_) {} };
    _impl_.page_contents_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_contents_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WebContent::~WebContent()
{
    // @@protoc_insertion_point(destructor:manta.proto.WebContent)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WebContent::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.page_contents_.Destroy();
    _impl_.page_url_.Destroy();
}

void WebContent::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WebContent::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.WebContent)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.page_contents_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.page_url_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WebContent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string page_contents = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_page_contents();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // optional string page_url = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_page_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WebContent::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.WebContent)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional string page_contents = 1;
    if (_internal_has_page_contents()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_page_contents().data(),
            static_cast<int>(this->_internal_page_contents().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "manta.proto.WebContent.page_contents");
        target = stream->WriteStringMaybeAliased(1, this->_internal_page_contents(), target);
    }

    // optional string page_url = 2;
    if (_internal_has_page_url()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_page_url().data(),
            static_cast<int>(this->_internal_page_url().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "manta.proto.WebContent.page_url");
        target = stream->WriteStringMaybeAliased(2, this->_internal_page_url(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.WebContent)
    return target;
}

size_t WebContent::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.WebContent)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string page_contents = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_page_contents());
        }

        // optional string page_url = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_page_url());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WebContent::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WebContent*>(&from));
}

void WebContent::MergeFrom(const WebContent& from)
{
    WebContent* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.WebContent)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_page_contents(from._internal_page_contents());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_page_url(from._internal_page_url());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WebContent::CopyFrom(const WebContent& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.WebContent)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WebContent::IsInitialized() const
{
    return true;
}

void WebContent::InternalSwap(WebContent* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.page_contents_, lhs_arena, &other->_impl_.page_contents_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.page_url_, lhs_arena, &other->_impl_.page_url_, rhs_arena);
}

std::string WebContent::GetTypeName() const
{
    return "manta.proto.WebContent";
}

// ===================================================================

class SparkyContextData::_Internal {
public:
    using HasBits = decltype(std::declval<SparkyContextData>()._impl_._has_bits_);
    static void set_has_task(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static const ::manta::proto::DiagnosticsData& diagnostics_data(const SparkyContextData* msg);
    static void set_has_diagnostics_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::manta::proto::SettingsData& settings_data(const SparkyContextData* msg);
    static void set_has_settings_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::manta::proto::Image& screenshot(const SparkyContextData* msg);
    static void set_has_screenshot(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::manta::proto::AppsData& apps_data(const SparkyContextData* msg);
    static void set_has_apps_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::manta::proto::WebContent& web_contents(const SparkyContextData* msg);
    static void set_has_web_contents(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::manta::proto::FilesData& files_data(const SparkyContextData* msg);
    static void set_has_files_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::manta::proto::ServerConfig& server_config(const SparkyContextData* msg);
    static void set_has_server_config(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
};

const ::manta::proto::DiagnosticsData& SparkyContextData::_Internal::diagnostics_data(const SparkyContextData* msg)
{
    return *msg->_impl_.diagnostics_data_;
}
const ::manta::proto::SettingsData& SparkyContextData::_Internal::settings_data(const SparkyContextData* msg)
{
    return *msg->_impl_.settings_data_;
}
const ::manta::proto::Image& SparkyContextData::_Internal::screenshot(const SparkyContextData* msg)
{
    return *msg->_impl_.screenshot_;
}
const ::manta::proto::AppsData& SparkyContextData::_Internal::apps_data(const SparkyContextData* msg)
{
    return *msg->_impl_.apps_data_;
}
const ::manta::proto::WebContent& SparkyContextData::_Internal::web_contents(const SparkyContextData* msg)
{
    return *msg->_impl_.web_contents_;
}
const ::manta::proto::FilesData& SparkyContextData::_Internal::files_data(const SparkyContextData* msg)
{
    return *msg->_impl_.files_data_;
}
const ::manta::proto::ServerConfig& SparkyContextData::_Internal::server_config(const SparkyContextData* msg)
{
    return *msg->_impl_.server_config_;
}
void SparkyContextData::clear_screenshot()
{
    if (_impl_.screenshot_ != nullptr)
        _impl_.screenshot_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
SparkyContextData::SparkyContextData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:manta.proto.SparkyContextData)
}
SparkyContextData::SparkyContextData(const SparkyContextData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SparkyContextData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.conversation_) { from._impl_.conversation_ }, decltype(_impl_.diagnostics_data_) { nullptr },
        decltype(_impl_.settings_data_) { nullptr }, decltype(_impl_.screenshot_) { nullptr }, decltype(_impl_.apps_data_) { nullptr },
        decltype(_impl_.web_contents_) { nullptr }, decltype(_impl_.files_data_) { nullptr }, decltype(_impl_.server_config_) { nullptr },
        decltype(_impl_.task_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_diagnostics_data()) {
        _this->_impl_.diagnostics_data_ = new ::manta::proto::DiagnosticsData(*from._impl_.diagnostics_data_);
    }
    if (from._internal_has_settings_data()) {
        _this->_impl_.settings_data_ = new ::manta::proto::SettingsData(*from._impl_.settings_data_);
    }
    if (from._internal_has_screenshot()) {
        _this->_impl_.screenshot_ = new ::manta::proto::Image(*from._impl_.screenshot_);
    }
    if (from._internal_has_apps_data()) {
        _this->_impl_.apps_data_ = new ::manta::proto::AppsData(*from._impl_.apps_data_);
    }
    if (from._internal_has_web_contents()) {
        _this->_impl_.web_contents_ = new ::manta::proto::WebContent(*from._impl_.web_contents_);
    }
    if (from._internal_has_files_data()) {
        _this->_impl_.files_data_ = new ::manta::proto::FilesData(*from._impl_.files_data_);
    }
    if (from._internal_has_server_config()) {
        _this->_impl_.server_config_ = new ::manta::proto::ServerConfig(*from._impl_.server_config_);
    }
    _this->_impl_.task_ = from._impl_.task_;
    // @@protoc_insertion_point(copy_constructor:manta.proto.SparkyContextData)
}

inline void SparkyContextData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.conversation_) { arena },
        decltype(_impl_.diagnostics_data_) { nullptr }, decltype(_impl_.settings_data_) { nullptr }, decltype(_impl_.screenshot_) { nullptr },
        decltype(_impl_.apps_data_) { nullptr }, decltype(_impl_.web_contents_) { nullptr }, decltype(_impl_.files_data_) { nullptr },
        decltype(_impl_.server_config_) { nullptr }, decltype(_impl_.task_) { 0 } };
}

SparkyContextData::~SparkyContextData()
{
    // @@protoc_insertion_point(destructor:manta.proto.SparkyContextData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SparkyContextData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.conversation_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.diagnostics_data_;
    if (this != internal_default_instance())
        delete _impl_.settings_data_;
    if (this != internal_default_instance())
        delete _impl_.screenshot_;
    if (this != internal_default_instance())
        delete _impl_.apps_data_;
    if (this != internal_default_instance())
        delete _impl_.web_contents_;
    if (this != internal_default_instance())
        delete _impl_.files_data_;
    if (this != internal_default_instance())
        delete _impl_.server_config_;
}

void SparkyContextData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SparkyContextData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:manta.proto.SparkyContextData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.conversation_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.diagnostics_data_ != nullptr);
            _impl_.diagnostics_data_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.settings_data_ != nullptr);
            _impl_.settings_data_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.screenshot_ != nullptr);
            _impl_.screenshot_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.apps_data_ != nullptr);
            _impl_.apps_data_->Clear();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.web_contents_ != nullptr);
            _impl_.web_contents_->Clear();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.files_data_ != nullptr);
            _impl_.files_data_->Clear();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.server_config_ != nullptr);
            _impl_.server_config_->Clear();
        }
    }
    _impl_.task_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SparkyContextData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .manta.proto.Task task = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_task(static_cast<::manta::proto::Task>(val));
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.DiagnosticsData diagnostics_data = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_diagnostics_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.SettingsData settings_data = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_settings_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .manta.proto.Turn conversation = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_conversation(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.Image screenshot = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_screenshot(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.AppsData apps_data = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_apps_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.WebContent web_contents = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_web_contents(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.FilesData files_data = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_files_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .manta.proto.ServerConfig server_config = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr = ctx->ParseMessage(_internal_mutable_server_config(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SparkyContextData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:manta.proto.SparkyContextData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // optional .manta.proto.Task task = 1;
    if (_internal_has_task()) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_task(), target);
    }

    // optional .manta.proto.DiagnosticsData diagnostics_data = 2;
    if (_internal_has_diagnostics_data()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::diagnostics_data(this), _Internal::diagnostics_data(this).GetCachedSize(), target, stream);
    }

    // optional .manta.proto.SettingsData settings_data = 3;
    if (_internal_has_settings_data()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::settings_data(this), _Internal::settings_data(this).GetCachedSize(), target, stream);
    }

    // repeated .manta.proto.Turn conversation = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_conversation_size()); i < n; i++) {
        const auto& repfield = this->_internal_conversation(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .manta.proto.Image screenshot = 5;
    if (_internal_has_screenshot()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::screenshot(this), _Internal::screenshot(this).GetCachedSize(), target, stream);
    }

    // optional .manta.proto.AppsData apps_data = 6;
    if (_internal_has_apps_data()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::apps_data(this), _Internal::apps_data(this).GetCachedSize(), target, stream);
    }

    // optional .manta.proto.WebContent web_contents = 7;
    if (_internal_has_web_contents()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::web_contents(this), _Internal::web_contents(this).GetCachedSize(), target, stream);
    }

    // optional .manta.proto.FilesData files_data = 8;
    if (_internal_has_files_data()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            8, _Internal::files_data(this), _Internal::files_data(this).GetCachedSize(), target, stream);
    }

    // optional .manta.proto.ServerConfig server_config = 9;
    if (_internal_has_server_config()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            9, _Internal::server_config(this), _Internal::server_config(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:manta.proto.SparkyContextData)
    return target;
}

size_t SparkyContextData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:manta.proto.SparkyContextData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .manta.proto.Turn conversation = 4;
    total_size += 1UL * this->_internal_conversation_size();
    for (const auto& msg : this->_impl_.conversation_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional .manta.proto.DiagnosticsData diagnostics_data = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.diagnostics_data_);
        }

        // optional .manta.proto.SettingsData settings_data = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.settings_data_);
        }

        // optional .manta.proto.Image screenshot = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.screenshot_);
        }

        // optional .manta.proto.AppsData apps_data = 6;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.apps_data_);
        }

        // optional .manta.proto.WebContent web_contents = 7;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.web_contents_);
        }

        // optional .manta.proto.FilesData files_data = 8;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.files_data_);
        }

        // optional .manta.proto.ServerConfig server_config = 9;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.server_config_);
        }

        // optional .manta.proto.Task task = 1;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_task());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SparkyContextData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SparkyContextData*>(&from));
}

void SparkyContextData::MergeFrom(const SparkyContextData& from)
{
    SparkyContextData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:manta.proto.SparkyContextData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.conversation_.MergeFrom(from._impl_.conversation_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_diagnostics_data()->::manta::proto::DiagnosticsData::MergeFrom(from._internal_diagnostics_data());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_settings_data()->::manta::proto::SettingsData::MergeFrom(from._internal_settings_data());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_screenshot()->::manta::proto::Image::MergeFrom(from._internal_screenshot());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_apps_data()->::manta::proto::AppsData::MergeFrom(from._internal_apps_data());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_web_contents()->::manta::proto::WebContent::MergeFrom(from._internal_web_contents());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_files_data()->::manta::proto::FilesData::MergeFrom(from._internal_files_data());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_server_config()->::manta::proto::ServerConfig::MergeFrom(from._internal_server_config());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.task_ = from._impl_.task_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SparkyContextData::CopyFrom(const SparkyContextData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:manta.proto.SparkyContextData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SparkyContextData::IsInitialized() const
{
    return true;
}

void SparkyContextData::InternalSwap(SparkyContextData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.conversation_.InternalSwap(&other->_impl_.conversation_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(SparkyContextData, _impl_.task_) + sizeof(SparkyContextData::_impl_.task_)
        - PROTOBUF_FIELD_OFFSET(SparkyContextData, _impl_.diagnostics_data_)>(
        reinterpret_cast<char*>(&_impl_.diagnostics_data_), reinterpret_cast<char*>(&other->_impl_.diagnostics_data_));
}

std::string SparkyContextData::GetTypeName() const
{
    return "manta.proto.SparkyContextData";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace proto
} // namespace manta
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::manta::proto::BatteryData* Arena::CreateMaybeMessage<::manta::proto::BatteryData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::BatteryData>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::StorageData* Arena::CreateMaybeMessage<::manta::proto::StorageData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::StorageData>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::CPUData* Arena::CreateMaybeMessage<::manta::proto::CPUData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::CPUData>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::MemoryData* Arena::CreateMaybeMessage<::manta::proto::MemoryData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::MemoryData>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::DiagnosticsData* Arena::CreateMaybeMessage<::manta::proto::DiagnosticsData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::DiagnosticsData>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::ServerConfig* Arena::CreateMaybeMessage<::manta::proto::ServerConfig>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::ServerConfig>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::SettingsValue* Arena::CreateMaybeMessage<::manta::proto::SettingsValue>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::SettingsValue>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::Setting* Arena::CreateMaybeMessage<::manta::proto::Setting>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::Setting>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::SettingsData* Arena::CreateMaybeMessage<::manta::proto::SettingsData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::SettingsData>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::App* Arena::CreateMaybeMessage<::manta::proto::App>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::App>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::AppsData* Arena::CreateMaybeMessage<::manta::proto::AppsData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::AppsData>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::TextEntry* Arena::CreateMaybeMessage<::manta::proto::TextEntry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::TextEntry>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::KeyPress* Arena::CreateMaybeMessage<::manta::proto::KeyPress>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::KeyPress>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::Click* Arena::CreateMaybeMessage<::manta::proto::Click>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::Click>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::Scroll* Arena::CreateMaybeMessage<::manta::proto::Scroll>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::Scroll>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::LaunchFile* Arena::CreateMaybeMessage<::manta::proto::LaunchFile>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::LaunchFile>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::WriteFile* Arena::CreateMaybeMessage<::manta::proto::WriteFile>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::WriteFile>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::Action* Arena::CreateMaybeMessage<::manta::proto::Action>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::Action>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::DiagnosticsRequest* Arena::CreateMaybeMessage<::manta::proto::DiagnosticsRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::DiagnosticsRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::SettingsDataRequest* Arena::CreateMaybeMessage<::manta::proto::SettingsDataRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::SettingsDataRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::FileRequest* Arena::CreateMaybeMessage<::manta::proto::FileRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::FileRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::File* Arena::CreateMaybeMessage<::manta::proto::File>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::File>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::FilesData* Arena::CreateMaybeMessage<::manta::proto::FilesData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::FilesData>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::Update* Arena::CreateMaybeMessage<::manta::proto::Update>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::Update>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::ContextRequest* Arena::CreateMaybeMessage<::manta::proto::ContextRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::ContextRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::Turn* Arena::CreateMaybeMessage<::manta::proto::Turn>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::Turn>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::SparkyResponse* Arena::CreateMaybeMessage<::manta::proto::SparkyResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::SparkyResponse>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::WebContent* Arena::CreateMaybeMessage<::manta::proto::WebContent>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::WebContent>(arena);
}
template <> PROTOBUF_NOINLINE ::manta::proto::SparkyContextData* Arena::CreateMaybeMessage<::manta::proto::SparkyContextData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::manta::proto::SparkyContextData>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
