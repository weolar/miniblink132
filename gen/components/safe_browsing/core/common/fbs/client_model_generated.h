// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CLIENTMODEL_SAFE_BROWSING_FLAT_MATCHRULE__H_
#define FLATBUFFERS_GENERATED_CLIENTMODEL_SAFE_BROWSING_FLAT_MATCHRULE__H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(
    FLATBUFFERS_VERSION_MAJOR == 24 && FLATBUFFERS_VERSION_MINOR == 3 && FLATBUFFERS_VERSION_REVISION == 25, "Non-compatible flatbuffers version included");

#include "components/safe_browsing/core/common/fbs/csd_generated.h"

namespace safe_browsing {
namespace flat {

struct Hash;
struct HashBuilder;

struct ClientSideModel;
struct ClientSideModelBuilder;

namespace ClientSideModel_ {

struct Rule;
struct RuleBuilder;

struct IPSubnet;
struct IPSubnetBuilder;

} // namespace ClientSideModel_

struct TfLiteModelMetadata;
struct TfLiteModelMetadataBuilder;

namespace TfLiteModelMetadata_ {

struct Threshold;
struct ThresholdBuilder;

} // namespace TfLiteModelMetadata_

struct VisionModel;
struct VisionModelBuilder;

struct VisualTarget;
struct VisualTargetBuilder;

struct MatchConfig;
struct MatchConfigBuilder;

struct MatchRule;
struct MatchRuleBuilder;

namespace MatchRule_ {

struct ColorRange;
struct ColorRangeBuilder;

struct FloatColorRange;
struct FloatColorRangeBuilder;

} // namespace MatchRule_

struct Hash FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef HashBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_DATA = 4 };
    const ::flatbuffers::Vector<uint8_t>* data() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t>*>(VT_DATA);
    }
    ::flatbuffers::Vector<uint8_t>* mutable_data()
    {
        return GetPointer<::flatbuffers::Vector<uint8_t>*>(VT_DATA);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_DATA) && verifier.VerifyVector(data()) && verifier.EndTable();
    }
};

struct HashBuilder {
    typedef Hash Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data)
    {
        fbb_.AddOffset(Hash::VT_DATA, data);
    }
    explicit HashBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Hash> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<Hash>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<Hash> CreateHash(::flatbuffers::FlatBufferBuilder& _fbb, ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0)
{
    HashBuilder builder_(_fbb);
    builder_.add_data(data);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<Hash> CreateHashDirect(::flatbuffers::FlatBufferBuilder& _fbb, const std::vector<uint8_t>* data = nullptr)
{
    auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
    return safe_browsing::flat::CreateHash(_fbb, data__);
}

struct ClientSideModel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef ClientSideModelBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_HASHES = 4,
        VT_RULE = 6,
        VT_PAGE_TERM = 8,
        VT_PAGE_WORD = 10,
        VT_MAX_WORDS_PER_TERM = 12,
        VT_VERSION = 14,
        VT_BAD_SUBNET = 16,
        VT_MURMUR_HASH_SEED = 18,
        VT_MAX_SHINGLES_PER_PAGE = 20,
        VT_SHINGLE_SIZE = 22,
        VT_THRESHOLD_PROBABILITY = 24,
        VT_VISION_MODEL = 26,
        VT_TFLITE_METADATA = 36,
        VT_IMG_EMBEDDING_METADATA = 38,
        VT_DOM_MODEL_VERSION = 40
    };
    const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::Hash>>* hashes() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::Hash>>*>(VT_HASHES);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::Hash>>* mutable_hashes()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::Hash>>*>(VT_HASHES);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>>* rule() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>>*>(VT_RULE);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>>* mutable_rule()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>>*>(VT_RULE);
    }
    const ::flatbuffers::Vector<int32_t>* page_term() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t>*>(VT_PAGE_TERM);
    }
    ::flatbuffers::Vector<int32_t>* mutable_page_term()
    {
        return GetPointer<::flatbuffers::Vector<int32_t>*>(VT_PAGE_TERM);
    }
    const ::flatbuffers::Vector<uint32_t>* page_word() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint32_t>*>(VT_PAGE_WORD);
    }
    ::flatbuffers::Vector<uint32_t>* mutable_page_word()
    {
        return GetPointer<::flatbuffers::Vector<uint32_t>*>(VT_PAGE_WORD);
    }
    int32_t max_words_per_term() const
    {
        return GetField<int32_t>(VT_MAX_WORDS_PER_TERM, 0);
    }
    bool mutate_max_words_per_term(int32_t _max_words_per_term = 0)
    {
        return SetField<int32_t>(VT_MAX_WORDS_PER_TERM, _max_words_per_term, 0);
    }
    int32_t version() const
    {
        return GetField<int32_t>(VT_VERSION, 0);
    }
    bool mutate_version(int32_t _version = 0)
    {
        return SetField<int32_t>(VT_VERSION, _version, 0);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>>* bad_subnet() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>>*>(VT_BAD_SUBNET);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>>* mutable_bad_subnet()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>>*>(VT_BAD_SUBNET);
    }
    uint32_t murmur_hash_seed() const
    {
        return GetField<uint32_t>(VT_MURMUR_HASH_SEED, 0);
    }
    bool mutate_murmur_hash_seed(uint32_t _murmur_hash_seed = 0)
    {
        return SetField<uint32_t>(VT_MURMUR_HASH_SEED, _murmur_hash_seed, 0);
    }
    int32_t max_shingles_per_page() const
    {
        return GetField<int32_t>(VT_MAX_SHINGLES_PER_PAGE, 200);
    }
    bool mutate_max_shingles_per_page(int32_t _max_shingles_per_page = 200)
    {
        return SetField<int32_t>(VT_MAX_SHINGLES_PER_PAGE, _max_shingles_per_page, 200);
    }
    int32_t shingle_size() const
    {
        return GetField<int32_t>(VT_SHINGLE_SIZE, 4);
    }
    bool mutate_shingle_size(int32_t _shingle_size = 4)
    {
        return SetField<int32_t>(VT_SHINGLE_SIZE, _shingle_size, 4);
    }
    float threshold_probability() const
    {
        return GetField<float>(VT_THRESHOLD_PROBABILITY, 0.5f);
    }
    bool mutate_threshold_probability(float _threshold_probability = 0.5f)
    {
        return SetField<float>(VT_THRESHOLD_PROBABILITY, _threshold_probability, 0.5f);
    }
    const safe_browsing::flat::VisionModel* vision_model() const
    {
        return GetPointer<const safe_browsing::flat::VisionModel*>(VT_VISION_MODEL);
    }
    safe_browsing::flat::VisionModel* mutable_vision_model()
    {
        return GetPointer<safe_browsing::flat::VisionModel*>(VT_VISION_MODEL);
    }
    const safe_browsing::flat::TfLiteModelMetadata* tflite_metadata() const
    {
        return GetPointer<const safe_browsing::flat::TfLiteModelMetadata*>(VT_TFLITE_METADATA);
    }
    safe_browsing::flat::TfLiteModelMetadata* mutable_tflite_metadata()
    {
        return GetPointer<safe_browsing::flat::TfLiteModelMetadata*>(VT_TFLITE_METADATA);
    }
    const safe_browsing::flat::TfLiteModelMetadata* img_embedding_metadata() const
    {
        return GetPointer<const safe_browsing::flat::TfLiteModelMetadata*>(VT_IMG_EMBEDDING_METADATA);
    }
    safe_browsing::flat::TfLiteModelMetadata* mutable_img_embedding_metadata()
    {
        return GetPointer<safe_browsing::flat::TfLiteModelMetadata*>(VT_IMG_EMBEDDING_METADATA);
    }
    int32_t dom_model_version() const
    {
        return GetField<int32_t>(VT_DOM_MODEL_VERSION, 0);
    }
    bool mutate_dom_model_version(int32_t _dom_model_version = 0)
    {
        return SetField<int32_t>(VT_DOM_MODEL_VERSION, _dom_model_version, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_HASHES) && verifier.VerifyVector(hashes()) && verifier.VerifyVectorOfTables(hashes())
            && VerifyOffset(verifier, VT_RULE) && verifier.VerifyVector(rule()) && verifier.VerifyVectorOfTables(rule()) && VerifyOffset(verifier, VT_PAGE_TERM)
            && verifier.VerifyVector(page_term()) && VerifyOffset(verifier, VT_PAGE_WORD) && verifier.VerifyVector(page_word())
            && VerifyField<int32_t>(verifier, VT_MAX_WORDS_PER_TERM, 4) && VerifyField<int32_t>(verifier, VT_VERSION, 4)
            && VerifyOffset(verifier, VT_BAD_SUBNET) && verifier.VerifyVector(bad_subnet()) && verifier.VerifyVectorOfTables(bad_subnet())
            && VerifyField<uint32_t>(verifier, VT_MURMUR_HASH_SEED, 4) && VerifyField<int32_t>(verifier, VT_MAX_SHINGLES_PER_PAGE, 4)
            && VerifyField<int32_t>(verifier, VT_SHINGLE_SIZE, 4) && VerifyField<float>(verifier, VT_THRESHOLD_PROBABILITY, 4)
            && VerifyOffset(verifier, VT_VISION_MODEL) && verifier.VerifyTable(vision_model()) && VerifyOffset(verifier, VT_TFLITE_METADATA)
            && verifier.VerifyTable(tflite_metadata()) && VerifyOffset(verifier, VT_IMG_EMBEDDING_METADATA) && verifier.VerifyTable(img_embedding_metadata())
            && VerifyField<int32_t>(verifier, VT_DOM_MODEL_VERSION, 4) && verifier.EndTable();
    }
};

struct ClientSideModelBuilder {
    typedef ClientSideModel Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_hashes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::Hash>>> hashes)
    {
        fbb_.AddOffset(ClientSideModel::VT_HASHES, hashes);
    }
    void add_rule(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>>> rule)
    {
        fbb_.AddOffset(ClientSideModel::VT_RULE, rule);
    }
    void add_page_term(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> page_term)
    {
        fbb_.AddOffset(ClientSideModel::VT_PAGE_TERM, page_term);
    }
    void add_page_word(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> page_word)
    {
        fbb_.AddOffset(ClientSideModel::VT_PAGE_WORD, page_word);
    }
    void add_max_words_per_term(int32_t max_words_per_term)
    {
        fbb_.AddElement<int32_t>(ClientSideModel::VT_MAX_WORDS_PER_TERM, max_words_per_term, 0);
    }
    void add_version(int32_t version)
    {
        fbb_.AddElement<int32_t>(ClientSideModel::VT_VERSION, version, 0);
    }
    void add_bad_subnet(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>>> bad_subnet)
    {
        fbb_.AddOffset(ClientSideModel::VT_BAD_SUBNET, bad_subnet);
    }
    void add_murmur_hash_seed(uint32_t murmur_hash_seed)
    {
        fbb_.AddElement<uint32_t>(ClientSideModel::VT_MURMUR_HASH_SEED, murmur_hash_seed, 0);
    }
    void add_max_shingles_per_page(int32_t max_shingles_per_page)
    {
        fbb_.AddElement<int32_t>(ClientSideModel::VT_MAX_SHINGLES_PER_PAGE, max_shingles_per_page, 200);
    }
    void add_shingle_size(int32_t shingle_size)
    {
        fbb_.AddElement<int32_t>(ClientSideModel::VT_SHINGLE_SIZE, shingle_size, 4);
    }
    void add_threshold_probability(float threshold_probability)
    {
        fbb_.AddElement<float>(ClientSideModel::VT_THRESHOLD_PROBABILITY, threshold_probability, 0.5f);
    }
    void add_vision_model(::flatbuffers::Offset<safe_browsing::flat::VisionModel> vision_model)
    {
        fbb_.AddOffset(ClientSideModel::VT_VISION_MODEL, vision_model);
    }
    void add_tflite_metadata(::flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata> tflite_metadata)
    {
        fbb_.AddOffset(ClientSideModel::VT_TFLITE_METADATA, tflite_metadata);
    }
    void add_img_embedding_metadata(::flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata> img_embedding_metadata)
    {
        fbb_.AddOffset(ClientSideModel::VT_IMG_EMBEDDING_METADATA, img_embedding_metadata);
    }
    void add_dom_model_version(int32_t dom_model_version)
    {
        fbb_.AddElement<int32_t>(ClientSideModel::VT_DOM_MODEL_VERSION, dom_model_version, 0);
    }
    explicit ClientSideModelBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<ClientSideModel> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ClientSideModel>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<ClientSideModel> CreateClientSideModel(::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::Hash>>> hashes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>>> rule = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> page_term = 0, ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> page_word = 0,
    int32_t max_words_per_term = 0, int32_t version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>>> bad_subnet = 0,
    uint32_t murmur_hash_seed = 0, int32_t max_shingles_per_page = 200, int32_t shingle_size = 4, float threshold_probability = 0.5f,
    ::flatbuffers::Offset<safe_browsing::flat::VisionModel> vision_model = 0,
    ::flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata> tflite_metadata = 0,
    ::flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata> img_embedding_metadata = 0, int32_t dom_model_version = 0)
{
    ClientSideModelBuilder builder_(_fbb);
    builder_.add_dom_model_version(dom_model_version);
    builder_.add_img_embedding_metadata(img_embedding_metadata);
    builder_.add_tflite_metadata(tflite_metadata);
    builder_.add_vision_model(vision_model);
    builder_.add_threshold_probability(threshold_probability);
    builder_.add_shingle_size(shingle_size);
    builder_.add_max_shingles_per_page(max_shingles_per_page);
    builder_.add_murmur_hash_seed(murmur_hash_seed);
    builder_.add_bad_subnet(bad_subnet);
    builder_.add_version(version);
    builder_.add_max_words_per_term(max_words_per_term);
    builder_.add_page_word(page_word);
    builder_.add_page_term(page_term);
    builder_.add_rule(rule);
    builder_.add_hashes(hashes);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<ClientSideModel> CreateClientSideModelDirect(::flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<::flatbuffers::Offset<safe_browsing::flat::Hash>>* hashes = nullptr,
    const std::vector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>>* rule = nullptr, const std::vector<int32_t>* page_term = nullptr,
    const std::vector<uint32_t>* page_word = nullptr, int32_t max_words_per_term = 0, int32_t version = 0,
    const std::vector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>>* bad_subnet = nullptr, uint32_t murmur_hash_seed = 0,
    int32_t max_shingles_per_page = 200, int32_t shingle_size = 4, float threshold_probability = 0.5f,
    ::flatbuffers::Offset<safe_browsing::flat::VisionModel> vision_model = 0,
    ::flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata> tflite_metadata = 0,
    ::flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata> img_embedding_metadata = 0, int32_t dom_model_version = 0)
{
    auto hashes__ = hashes ? _fbb.CreateVector<::flatbuffers::Offset<safe_browsing::flat::Hash>>(*hashes) : 0;
    auto rule__ = rule ? _fbb.CreateVector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::Rule>>(*rule) : 0;
    auto page_term__ = page_term ? _fbb.CreateVector<int32_t>(*page_term) : 0;
    auto page_word__ = page_word ? _fbb.CreateVector<uint32_t>(*page_word) : 0;
    auto bad_subnet__ = bad_subnet ? _fbb.CreateVector<::flatbuffers::Offset<safe_browsing::flat::ClientSideModel_::IPSubnet>>(*bad_subnet) : 0;
    return safe_browsing::flat::CreateClientSideModel(_fbb, hashes__, rule__, page_term__, page_word__, max_words_per_term, version, bad_subnet__,
        murmur_hash_seed, max_shingles_per_page, shingle_size, threshold_probability, vision_model, tflite_metadata, img_embedding_metadata, dom_model_version);
}

namespace ClientSideModel_ {

struct Rule FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef RuleBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_FEATURE = 4, VT_WEIGHT = 6 };
    const ::flatbuffers::Vector<int32_t>* feature() const
    {
        return GetPointer<const ::flatbuffers::Vector<int32_t>*>(VT_FEATURE);
    }
    ::flatbuffers::Vector<int32_t>* mutable_feature()
    {
        return GetPointer<::flatbuffers::Vector<int32_t>*>(VT_FEATURE);
    }
    float weight() const
    {
        return GetField<float>(VT_WEIGHT, 0.0f);
    }
    bool mutate_weight(float _weight = 0.0f)
    {
        return SetField<float>(VT_WEIGHT, _weight, 0.0f);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_FEATURE) && verifier.VerifyVector(feature())
            && VerifyField<float>(verifier, VT_WEIGHT, 4) && verifier.EndTable();
    }
};

struct RuleBuilder {
    typedef Rule Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_feature(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> feature)
    {
        fbb_.AddOffset(Rule::VT_FEATURE, feature);
    }
    void add_weight(float weight)
    {
        fbb_.AddElement<float>(Rule::VT_WEIGHT, weight, 0.0f);
    }
    explicit RuleBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Rule> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<Rule>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<Rule> CreateRule(
    ::flatbuffers::FlatBufferBuilder& _fbb, ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> feature = 0, float weight = 0.0f)
{
    RuleBuilder builder_(_fbb);
    builder_.add_weight(weight);
    builder_.add_feature(feature);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<Rule> CreateRuleDirect(::flatbuffers::FlatBufferBuilder& _fbb, const std::vector<int32_t>* feature = nullptr, float weight = 0.0f)
{
    auto feature__ = feature ? _fbb.CreateVector<int32_t>(*feature) : 0;
    return safe_browsing::flat::ClientSideModel_::CreateRule(_fbb, feature__, weight);
}

struct IPSubnet FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef IPSubnetBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_PREFIX = 4, VT_SIZE = 6 };
    const ::flatbuffers::Vector<uint8_t>* prefix() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t>*>(VT_PREFIX);
    }
    ::flatbuffers::Vector<uint8_t>* mutable_prefix()
    {
        return GetPointer<::flatbuffers::Vector<uint8_t>*>(VT_PREFIX);
    }
    int32_t size() const
    {
        return GetField<int32_t>(VT_SIZE, 128);
    }
    bool mutate_size(int32_t _size = 128)
    {
        return SetField<int32_t>(VT_SIZE, _size, 128);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffsetRequired(verifier, VT_PREFIX) && verifier.VerifyVector(prefix())
            && VerifyField<int32_t>(verifier, VT_SIZE, 4) && verifier.EndTable();
    }
};

struct IPSubnetBuilder {
    typedef IPSubnet Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_prefix(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> prefix)
    {
        fbb_.AddOffset(IPSubnet::VT_PREFIX, prefix);
    }
    void add_size(int32_t size)
    {
        fbb_.AddElement<int32_t>(IPSubnet::VT_SIZE, size, 128);
    }
    explicit IPSubnetBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<IPSubnet> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<IPSubnet>(end);
        fbb_.Required(o, IPSubnet::VT_PREFIX);
        return o;
    }
};

inline ::flatbuffers::Offset<IPSubnet> CreateIPSubnet(
    ::flatbuffers::FlatBufferBuilder& _fbb, ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> prefix = 0, int32_t size = 128)
{
    IPSubnetBuilder builder_(_fbb);
    builder_.add_size(size);
    builder_.add_prefix(prefix);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<IPSubnet> CreateIPSubnetDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb, const std::vector<uint8_t>* prefix = nullptr, int32_t size = 128)
{
    auto prefix__ = prefix ? _fbb.CreateVector<uint8_t>(*prefix) : 0;
    return safe_browsing::flat::ClientSideModel_::CreateIPSubnet(_fbb, prefix__, size);
}

} // namespace ClientSideModel_

struct TfLiteModelMetadata FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef TfLiteModelMetadataBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_VERSION = 4, VT_THRESHOLDS = 6, VT_INPUT_WIDTH = 8, VT_INPUT_HEIGHT = 10 };
    int32_t version() const
    {
        return GetField<int32_t>(VT_VERSION, 0);
    }
    bool mutate_version(int32_t _version = 0)
    {
        return SetField<int32_t>(VT_VERSION, _version, 0);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>>* thresholds() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>>*>(VT_THRESHOLDS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>>* mutable_thresholds()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>>*>(VT_THRESHOLDS);
    }
    int32_t input_width() const
    {
        return GetField<int32_t>(VT_INPUT_WIDTH, 0);
    }
    bool mutate_input_width(int32_t _input_width = 0)
    {
        return SetField<int32_t>(VT_INPUT_WIDTH, _input_width, 0);
    }
    int32_t input_height() const
    {
        return GetField<int32_t>(VT_INPUT_HEIGHT, 0);
    }
    bool mutate_input_height(int32_t _input_height = 0)
    {
        return SetField<int32_t>(VT_INPUT_HEIGHT, _input_height, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_VERSION, 4) && VerifyOffset(verifier, VT_THRESHOLDS)
            && verifier.VerifyVector(thresholds()) && verifier.VerifyVectorOfTables(thresholds()) && VerifyField<int32_t>(verifier, VT_INPUT_WIDTH, 4)
            && VerifyField<int32_t>(verifier, VT_INPUT_HEIGHT, 4) && verifier.EndTable();
    }
};

struct TfLiteModelMetadataBuilder {
    typedef TfLiteModelMetadata Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_version(int32_t version)
    {
        fbb_.AddElement<int32_t>(TfLiteModelMetadata::VT_VERSION, version, 0);
    }
    void add_thresholds(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>>> thresholds)
    {
        fbb_.AddOffset(TfLiteModelMetadata::VT_THRESHOLDS, thresholds);
    }
    void add_input_width(int32_t input_width)
    {
        fbb_.AddElement<int32_t>(TfLiteModelMetadata::VT_INPUT_WIDTH, input_width, 0);
    }
    void add_input_height(int32_t input_height)
    {
        fbb_.AddElement<int32_t>(TfLiteModelMetadata::VT_INPUT_HEIGHT, input_height, 0);
    }
    explicit TfLiteModelMetadataBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<TfLiteModelMetadata> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<TfLiteModelMetadata>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<TfLiteModelMetadata> CreateTfLiteModelMetadata(::flatbuffers::FlatBufferBuilder& _fbb, int32_t version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>>> thresholds = 0,
    int32_t input_width = 0, int32_t input_height = 0)
{
    TfLiteModelMetadataBuilder builder_(_fbb);
    builder_.add_input_height(input_height);
    builder_.add_input_width(input_width);
    builder_.add_thresholds(thresholds);
    builder_.add_version(version);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<TfLiteModelMetadata> CreateTfLiteModelMetadataDirect(::flatbuffers::FlatBufferBuilder& _fbb, int32_t version = 0,
    const std::vector<::flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>>* thresholds = nullptr, int32_t input_width = 0,
    int32_t input_height = 0)
{
    auto thresholds__ = thresholds ? _fbb.CreateVector<::flatbuffers::Offset<safe_browsing::flat::TfLiteModelMetadata_::Threshold>>(*thresholds) : 0;
    return safe_browsing::flat::CreateTfLiteModelMetadata(_fbb, version, thresholds__, input_width, input_height);
}

namespace TfLiteModelMetadata_ {

struct Threshold FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef ThresholdBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_LABEL = 4, VT_THRESHOLD = 6, VT_ESB_THRESHOLD = 8 };
    const ::flatbuffers::String* label() const
    {
        return GetPointer<const ::flatbuffers::String*>(VT_LABEL);
    }
    ::flatbuffers::String* mutable_label()
    {
        return GetPointer<::flatbuffers::String*>(VT_LABEL);
    }
    float threshold() const
    {
        return GetField<float>(VT_THRESHOLD, 0.0f);
    }
    bool mutate_threshold(float _threshold = 0.0f)
    {
        return SetField<float>(VT_THRESHOLD, _threshold, 0.0f);
    }
    float esb_threshold() const
    {
        return GetField<float>(VT_ESB_THRESHOLD, 0.0f);
    }
    bool mutate_esb_threshold(float _esb_threshold = 0.0f)
    {
        return SetField<float>(VT_ESB_THRESHOLD, _esb_threshold, 0.0f);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_LABEL) && verifier.VerifyString(label()) && VerifyField<float>(verifier, VT_THRESHOLD, 4)
            && VerifyField<float>(verifier, VT_ESB_THRESHOLD, 4) && verifier.EndTable();
    }
};

struct ThresholdBuilder {
    typedef Threshold Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_label(::flatbuffers::Offset<::flatbuffers::String> label)
    {
        fbb_.AddOffset(Threshold::VT_LABEL, label);
    }
    void add_threshold(float threshold)
    {
        fbb_.AddElement<float>(Threshold::VT_THRESHOLD, threshold, 0.0f);
    }
    void add_esb_threshold(float esb_threshold)
    {
        fbb_.AddElement<float>(Threshold::VT_ESB_THRESHOLD, esb_threshold, 0.0f);
    }
    explicit ThresholdBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<Threshold> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<Threshold>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<Threshold> CreateThreshold(
    ::flatbuffers::FlatBufferBuilder& _fbb, ::flatbuffers::Offset<::flatbuffers::String> label = 0, float threshold = 0.0f, float esb_threshold = 0.0f)
{
    ThresholdBuilder builder_(_fbb);
    builder_.add_esb_threshold(esb_threshold);
    builder_.add_threshold(threshold);
    builder_.add_label(label);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<Threshold> CreateThresholdDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb, const char* label = nullptr, float threshold = 0.0f, float esb_threshold = 0.0f)
{
    auto label__ = label ? _fbb.CreateString(label) : 0;
    return safe_browsing::flat::TfLiteModelMetadata_::CreateThreshold(_fbb, label__, threshold, esb_threshold);
}

} // namespace TfLiteModelMetadata_

struct VisionModel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef VisionModelBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_TARGETS = 4 };
    const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::VisualTarget>>* targets() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::VisualTarget>>*>(VT_TARGETS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::VisualTarget>>* mutable_targets()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::VisualTarget>>*>(VT_TARGETS);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_TARGETS) && verifier.VerifyVector(targets()) && verifier.VerifyVectorOfTables(targets())
            && verifier.EndTable();
    }
};

struct VisionModelBuilder {
    typedef VisionModel Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_targets(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::VisualTarget>>> targets)
    {
        fbb_.AddOffset(VisionModel::VT_TARGETS, targets);
    }
    explicit VisionModelBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<VisionModel> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<VisionModel>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<VisionModel> CreateVisionModel(
    ::flatbuffers::FlatBufferBuilder& _fbb, ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::VisualTarget>>> targets = 0)
{
    VisionModelBuilder builder_(_fbb);
    builder_.add_targets(targets);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<VisionModel> CreateVisionModelDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb, const std::vector<::flatbuffers::Offset<safe_browsing::flat::VisualTarget>>* targets = nullptr)
{
    auto targets__ = targets ? _fbb.CreateVector<::flatbuffers::Offset<safe_browsing::flat::VisualTarget>>(*targets) : 0;
    return safe_browsing::flat::CreateVisionModel(_fbb, targets__);
}

struct VisualTarget FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef VisualTargetBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_DIGEST = 4,
        VT_TIMESTAMP_USEC = 6,
        VT_HASH = 8,
        VT_DIMENSION_SIZE = 10,
        VT_BINS = 12,
        VT_MATCH_CONFIG = 14
    };
    const ::flatbuffers::Vector<uint8_t>* digest() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t>*>(VT_DIGEST);
    }
    ::flatbuffers::Vector<uint8_t>* mutable_digest()
    {
        return GetPointer<::flatbuffers::Vector<uint8_t>*>(VT_DIGEST);
    }
    int64_t timestamp_usec() const
    {
        return GetField<int64_t>(VT_TIMESTAMP_USEC, 0);
    }
    bool mutate_timestamp_usec(int64_t _timestamp_usec = 0)
    {
        return SetField<int64_t>(VT_TIMESTAMP_USEC, _timestamp_usec, 0);
    }
    const ::flatbuffers::Vector<uint8_t>* hash() const
    {
        return GetPointer<const ::flatbuffers::Vector<uint8_t>*>(VT_HASH);
    }
    ::flatbuffers::Vector<uint8_t>* mutable_hash()
    {
        return GetPointer<::flatbuffers::Vector<uint8_t>*>(VT_HASH);
    }
    int32_t dimension_size() const
    {
        return GetField<int32_t>(VT_DIMENSION_SIZE, 0);
    }
    bool mutate_dimension_size(int32_t _dimension_size = 0)
    {
        return SetField<int32_t>(VT_DIMENSION_SIZE, _dimension_size, 0);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>>* bins() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>>*>(VT_BINS);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>>* mutable_bins()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>>*>(VT_BINS);
    }
    const safe_browsing::flat::MatchConfig* match_config() const
    {
        return GetPointer<const safe_browsing::flat::MatchConfig*>(VT_MATCH_CONFIG);
    }
    safe_browsing::flat::MatchConfig* mutable_match_config()
    {
        return GetPointer<safe_browsing::flat::MatchConfig*>(VT_MATCH_CONFIG);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_DIGEST) && verifier.VerifyVector(digest())
            && VerifyField<int64_t>(verifier, VT_TIMESTAMP_USEC, 8) && VerifyOffset(verifier, VT_HASH) && verifier.VerifyVector(hash())
            && VerifyField<int32_t>(verifier, VT_DIMENSION_SIZE, 4) && VerifyOffset(verifier, VT_BINS) && verifier.VerifyVector(bins())
            && verifier.VerifyVectorOfTables(bins()) && VerifyOffset(verifier, VT_MATCH_CONFIG) && verifier.VerifyTable(match_config()) && verifier.EndTable();
    }
};

struct VisualTargetBuilder {
    typedef VisualTarget Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_digest(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> digest)
    {
        fbb_.AddOffset(VisualTarget::VT_DIGEST, digest);
    }
    void add_timestamp_usec(int64_t timestamp_usec)
    {
        fbb_.AddElement<int64_t>(VisualTarget::VT_TIMESTAMP_USEC, timestamp_usec, 0);
    }
    void add_hash(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> hash)
    {
        fbb_.AddOffset(VisualTarget::VT_HASH, hash);
    }
    void add_dimension_size(int32_t dimension_size)
    {
        fbb_.AddElement<int32_t>(VisualTarget::VT_DIMENSION_SIZE, dimension_size, 0);
    }
    void add_bins(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>>> bins)
    {
        fbb_.AddOffset(VisualTarget::VT_BINS, bins);
    }
    void add_match_config(::flatbuffers::Offset<safe_browsing::flat::MatchConfig> match_config)
    {
        fbb_.AddOffset(VisualTarget::VT_MATCH_CONFIG, match_config);
    }
    explicit VisualTargetBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<VisualTarget> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<VisualTarget>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<VisualTarget> CreateVisualTarget(::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> digest = 0, int64_t timestamp_usec = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> hash = 0, int32_t dimension_size = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>>> bins = 0,
    ::flatbuffers::Offset<safe_browsing::flat::MatchConfig> match_config = 0)
{
    VisualTargetBuilder builder_(_fbb);
    builder_.add_timestamp_usec(timestamp_usec);
    builder_.add_match_config(match_config);
    builder_.add_bins(bins);
    builder_.add_dimension_size(dimension_size);
    builder_.add_hash(hash);
    builder_.add_digest(digest);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<VisualTarget> CreateVisualTargetDirect(::flatbuffers::FlatBufferBuilder& _fbb, const std::vector<uint8_t>* digest = nullptr,
    int64_t timestamp_usec = 0, const std::vector<uint8_t>* hash = nullptr, int32_t dimension_size = 0,
    const std::vector<::flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>>* bins = nullptr,
    ::flatbuffers::Offset<safe_browsing::flat::MatchConfig> match_config = 0)
{
    auto digest__ = digest ? _fbb.CreateVector<uint8_t>(*digest) : 0;
    auto hash__ = hash ? _fbb.CreateVector<uint8_t>(*hash) : 0;
    auto bins__ = bins ? _fbb.CreateVector<::flatbuffers::Offset<safe_browsing::flat::VisualFeatures_::ColorHistogramBin>>(*bins) : 0;
    return safe_browsing::flat::CreateVisualTarget(_fbb, digest__, timestamp_usec, hash__, dimension_size, bins__, match_config);
}

struct MatchConfig FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef MatchConfigBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_MATCH_RULE = 4 };
    const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule>>* match_rule() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule>>*>(VT_MATCH_RULE);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule>>* mutable_match_rule()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule>>*>(VT_MATCH_RULE);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_MATCH_RULE) && verifier.VerifyVector(match_rule())
            && verifier.VerifyVectorOfTables(match_rule()) && verifier.EndTable();
    }
};

struct MatchConfigBuilder {
    typedef MatchConfig Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_match_rule(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule>>> match_rule)
    {
        fbb_.AddOffset(MatchConfig::VT_MATCH_RULE, match_rule);
    }
    explicit MatchConfigBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<MatchConfig> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<MatchConfig>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<MatchConfig> CreateMatchConfig(
    ::flatbuffers::FlatBufferBuilder& _fbb, ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule>>> match_rule = 0)
{
    MatchConfigBuilder builder_(_fbb);
    builder_.add_match_rule(match_rule);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<MatchConfig> CreateMatchConfigDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb, const std::vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule>>* match_rule = nullptr)
{
    auto match_rule__ = match_rule ? _fbb.CreateVector<::flatbuffers::Offset<safe_browsing::flat::MatchRule>>(*match_rule) : 0;
    return safe_browsing::flat::CreateMatchConfig(_fbb, match_rule__);
}

struct MatchRule FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef MatchRuleBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_HASH_DISTANCE = 4,
        VT_COLOR_DISTANCE = 6,
        VT_COLOR_RANGE = 8,
        VT_FLOAT_COLOR_RANGE = 10
    };
    double hash_distance() const
    {
        return GetField<double>(VT_HASH_DISTANCE, 0.0);
    }
    bool mutate_hash_distance(double _hash_distance = 0.0)
    {
        return SetField<double>(VT_HASH_DISTANCE, _hash_distance, 0.0);
    }
    double color_distance() const
    {
        return GetField<double>(VT_COLOR_DISTANCE, 0.0);
    }
    bool mutate_color_distance(double _color_distance = 0.0)
    {
        return SetField<double>(VT_COLOR_DISTANCE, _color_distance, 0.0);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>>* color_range() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>>*>(VT_COLOR_RANGE);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>>* mutable_color_range()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>>*>(VT_COLOR_RANGE);
    }
    const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>>* float_color_range() const
    {
        return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>>*>(VT_FLOAT_COLOR_RANGE);
    }
    ::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>>* mutable_float_color_range()
    {
        return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>>*>(VT_FLOAT_COLOR_RANGE);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<double>(verifier, VT_HASH_DISTANCE, 8) && VerifyField<double>(verifier, VT_COLOR_DISTANCE, 8)
            && VerifyOffset(verifier, VT_COLOR_RANGE) && verifier.VerifyVector(color_range()) && verifier.VerifyVectorOfTables(color_range())
            && VerifyOffset(verifier, VT_FLOAT_COLOR_RANGE) && verifier.VerifyVector(float_color_range()) && verifier.VerifyVectorOfTables(float_color_range())
            && verifier.EndTable();
    }
};

struct MatchRuleBuilder {
    typedef MatchRule Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_hash_distance(double hash_distance)
    {
        fbb_.AddElement<double>(MatchRule::VT_HASH_DISTANCE, hash_distance, 0.0);
    }
    void add_color_distance(double color_distance)
    {
        fbb_.AddElement<double>(MatchRule::VT_COLOR_DISTANCE, color_distance, 0.0);
    }
    void add_color_range(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>>> color_range)
    {
        fbb_.AddOffset(MatchRule::VT_COLOR_RANGE, color_range);
    }
    void add_float_color_range(
        ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>>> float_color_range)
    {
        fbb_.AddOffset(MatchRule::VT_FLOAT_COLOR_RANGE, float_color_range);
    }
    explicit MatchRuleBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<MatchRule> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<MatchRule>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<MatchRule> CreateMatchRule(::flatbuffers::FlatBufferBuilder& _fbb, double hash_distance = 0.0, double color_distance = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>>> color_range = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>>> float_color_range = 0)
{
    MatchRuleBuilder builder_(_fbb);
    builder_.add_color_distance(color_distance);
    builder_.add_hash_distance(hash_distance);
    builder_.add_float_color_range(float_color_range);
    builder_.add_color_range(color_range);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<MatchRule> CreateMatchRuleDirect(::flatbuffers::FlatBufferBuilder& _fbb, double hash_distance = 0.0, double color_distance = 0.0,
    const std::vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>>* color_range = nullptr,
    const std::vector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>>* float_color_range = nullptr)
{
    auto color_range__ = color_range ? _fbb.CreateVector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::ColorRange>>(*color_range) : 0;
    auto float_color_range__
        = float_color_range ? _fbb.CreateVector<::flatbuffers::Offset<safe_browsing::flat::MatchRule_::FloatColorRange>>(*float_color_range) : 0;
    return safe_browsing::flat::CreateMatchRule(_fbb, hash_distance, color_distance, color_range__, float_color_range__);
}

namespace MatchRule_ {

struct ColorRange FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef ColorRangeBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_LOW = 4, VT_HIGH = 6 };
    int32_t low() const
    {
        return GetField<int32_t>(VT_LOW, 0);
    }
    bool mutate_low(int32_t _low = 0)
    {
        return SetField<int32_t>(VT_LOW, _low, 0);
    }
    int32_t high() const
    {
        return GetField<int32_t>(VT_HIGH, 0);
    }
    bool mutate_high(int32_t _high = 0)
    {
        return SetField<int32_t>(VT_HIGH, _high, 0);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<int32_t>(verifier, VT_LOW, 4) && VerifyField<int32_t>(verifier, VT_HIGH, 4) && verifier.EndTable();
    }
};

struct ColorRangeBuilder {
    typedef ColorRange Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_low(int32_t low)
    {
        fbb_.AddElement<int32_t>(ColorRange::VT_LOW, low, 0);
    }
    void add_high(int32_t high)
    {
        fbb_.AddElement<int32_t>(ColorRange::VT_HIGH, high, 0);
    }
    explicit ColorRangeBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<ColorRange> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<ColorRange>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<ColorRange> CreateColorRange(::flatbuffers::FlatBufferBuilder& _fbb, int32_t low = 0, int32_t high = 0)
{
    ColorRangeBuilder builder_(_fbb);
    builder_.add_high(high);
    builder_.add_low(low);
    return builder_.Finish();
}

struct FloatColorRange FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef FloatColorRangeBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_LOW = 4, VT_HIGH = 6 };
    float low() const
    {
        return GetField<float>(VT_LOW, 0.0f);
    }
    bool mutate_low(float _low = 0.0f)
    {
        return SetField<float>(VT_LOW, _low, 0.0f);
    }
    float high() const
    {
        return GetField<float>(VT_HIGH, 0.0f);
    }
    bool mutate_high(float _high = 0.0f)
    {
        return SetField<float>(VT_HIGH, _high, 0.0f);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const
    {
        return VerifyTableStart(verifier) && VerifyField<float>(verifier, VT_LOW, 4) && VerifyField<float>(verifier, VT_HIGH, 4) && verifier.EndTable();
    }
};

struct FloatColorRangeBuilder {
    typedef FloatColorRange Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_low(float low)
    {
        fbb_.AddElement<float>(FloatColorRange::VT_LOW, low, 0.0f);
    }
    void add_high(float high)
    {
        fbb_.AddElement<float>(FloatColorRange::VT_HIGH, high, 0.0f);
    }
    explicit FloatColorRangeBuilder(::flatbuffers::FlatBufferBuilder& _fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<FloatColorRange> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<FloatColorRange>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<FloatColorRange> CreateFloatColorRange(::flatbuffers::FlatBufferBuilder& _fbb, float low = 0.0f, float high = 0.0f)
{
    FloatColorRangeBuilder builder_(_fbb);
    builder_.add_high(high);
    builder_.add_low(low);
    return builder_.Finish();
}

} // namespace MatchRule_

namespace ClientSideModel_ {

} // namespace ClientSideModel_

namespace TfLiteModelMetadata_ {

} // namespace TfLiteModelMetadata_

namespace MatchRule_ {

} // namespace MatchRule_

inline const safe_browsing::flat::ClientSideModel* GetClientSideModel(const void* buf)
{
    return ::flatbuffers::GetRoot<safe_browsing::flat::ClientSideModel>(buf);
}

inline const safe_browsing::flat::ClientSideModel* GetSizePrefixedClientSideModel(const void* buf)
{
    return ::flatbuffers::GetSizePrefixedRoot<safe_browsing::flat::ClientSideModel>(buf);
}

inline ClientSideModel* GetMutableClientSideModel(void* buf)
{
    return ::flatbuffers::GetMutableRoot<ClientSideModel>(buf);
}

inline safe_browsing::flat::ClientSideModel* GetMutableSizePrefixedClientSideModel(void* buf)
{
    return ::flatbuffers::GetMutableSizePrefixedRoot<safe_browsing::flat::ClientSideModel>(buf);
}

inline bool VerifyClientSideModelBuffer(::flatbuffers::Verifier& verifier)
{
    return verifier.VerifyBuffer<safe_browsing::flat::ClientSideModel>(nullptr);
}

inline bool VerifySizePrefixedClientSideModelBuffer(::flatbuffers::Verifier& verifier)
{
    return verifier.VerifySizePrefixedBuffer<safe_browsing::flat::ClientSideModel>(nullptr);
}

inline void FinishClientSideModelBuffer(::flatbuffers::FlatBufferBuilder& fbb, ::flatbuffers::Offset<safe_browsing::flat::ClientSideModel> root)
{
    fbb.Finish(root);
}

inline void FinishSizePrefixedClientSideModelBuffer(::flatbuffers::FlatBufferBuilder& fbb, ::flatbuffers::Offset<safe_browsing::flat::ClientSideModel> root)
{
    fbb.FinishSizePrefixed(root);
}

} // namespace flat
} // namespace safe_browsing

#endif // FLATBUFFERS_GENERATED_CLIENTMODEL_SAFE_BROWSING_FLAT_MATCHRULE__H_
