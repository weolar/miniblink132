// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safebrowsingv5.proto

#include "safebrowsingv5.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace safe_browsing {
namespace V5 {
PROTOBUF_CONSTEXPR SearchHashesRequest::SearchHashesRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.hash_prefixes_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SearchHashesRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SearchHashesRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SearchHashesRequestDefaultTypeInternal()
    {
    }
    union {
        SearchHashesRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SearchHashesRequestDefaultTypeInternal
    _SearchHashesRequest_default_instance_;
PROTOBUF_CONSTEXPR SearchHashesResponse::SearchHashesResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.full_hashes_)*/ {}, /*decltype(_impl_.cache_duration_)*/ nullptr, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SearchHashesResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SearchHashesResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SearchHashesResponseDefaultTypeInternal()
    {
    }
    union {
        SearchHashesResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SearchHashesResponseDefaultTypeInternal
    _SearchHashesResponse_default_instance_;
PROTOBUF_CONSTEXPR FullHash_FullHashDetail::FullHash_FullHashDetail(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.attributes_)*/ {}, /*decltype(_impl_._attributes_cached_byte_size_)*/ { 0 }, /*decltype(_impl_.threat_type_)*/ 0,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct FullHash_FullHashDetailDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FullHash_FullHashDetailDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FullHash_FullHashDetailDefaultTypeInternal()
    {
    }
    union {
        FullHash_FullHashDetail _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FullHash_FullHashDetailDefaultTypeInternal
    _FullHash_FullHashDetail_default_instance_;
PROTOBUF_CONSTEXPR FullHash::FullHash(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.full_hash_details_)*/ {},
        /*decltype(_impl_.full_hash_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct FullHashDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FullHashDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FullHashDefaultTypeInternal()
    {
    }
    union {
        FullHash _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FullHashDefaultTypeInternal _FullHash_default_instance_;
PROTOBUF_CONSTEXPR Duration::Duration(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.seconds_)*/ int64_t { 0 }, /*decltype(_impl_.nanos_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct DurationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DurationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DurationDefaultTypeInternal()
    {
    }
    union {
        Duration _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DurationDefaultTypeInternal _Duration_default_instance_;
} // namespace V5
} // namespace safe_browsing
namespace safe_browsing {
namespace V5 {
bool ThreatType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
    case 15:
    case 20:
    case 21:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThreatType_strings[9] = {};

static const char ThreatType_names[] = "ABUSIVE_EXPERIENCE_VIOLATION"
                                       "API_ABUSE"
                                       "BETTER_ADS_VIOLATION"
                                       "MALWARE"
                                       "POTENTIALLY_HARMFUL_APPLICATION"
                                       "SOCIAL_ENGINEERING"
                                       "THREAT_TYPE_UNSPECIFIED"
                                       "TRICK_TO_BILL"
                                       "UNWANTED_SOFTWARE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThreatType_entries[] = {
    { { ThreatType_names + 0, 28 }, 20 },
    { { ThreatType_names + 28, 9 }, 6 },
    { { ThreatType_names + 37, 20 }, 21 },
    { { ThreatType_names + 57, 7 }, 1 },
    { { ThreatType_names + 64, 31 }, 4 },
    { { ThreatType_names + 95, 18 }, 2 },
    { { ThreatType_names + 113, 23 }, 0 },
    { { ThreatType_names + 136, 13 }, 15 },
    { { ThreatType_names + 149, 17 }, 3 },
};

static const int ThreatType_entries_by_number[] = {
    6, // 0 -> THREAT_TYPE_UNSPECIFIED
    3, // 1 -> MALWARE
    5, // 2 -> SOCIAL_ENGINEERING
    8, // 3 -> UNWANTED_SOFTWARE
    4, // 4 -> POTENTIALLY_HARMFUL_APPLICATION
    1, // 6 -> API_ABUSE
    7, // 15 -> TRICK_TO_BILL
    0, // 20 -> ABUSIVE_EXPERIENCE_VIOLATION
    2, // 21 -> BETTER_ADS_VIOLATION
};

const std::string& ThreatType_Name(ThreatType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ThreatType_entries, ThreatType_entries_by_number, 9, ThreatType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ThreatType_entries, ThreatType_entries_by_number, 9, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ThreatType_strings[idx].get();
}
bool ThreatType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ThreatType_entries, 9, name, &int_value);
    if (success) {
        *value = static_cast<ThreatType>(int_value);
    }
    return success;
}
bool ThreatAttribute_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThreatAttribute_strings[3] = {};

static const char ThreatAttribute_names[] = "CANARY"
                                            "FRAME_ONLY"
                                            "THREAT_ATTRIBUTE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThreatAttribute_entries[] = {
    { { ThreatAttribute_names + 0, 6 }, 1 },
    { { ThreatAttribute_names + 6, 10 }, 2 },
    { { ThreatAttribute_names + 16, 28 }, 0 },
};

static const int ThreatAttribute_entries_by_number[] = {
    2, // 0 -> THREAT_ATTRIBUTE_UNSPECIFIED
    0, // 1 -> CANARY
    1, // 2 -> FRAME_ONLY
};

const std::string& ThreatAttribute_Name(ThreatAttribute value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ThreatAttribute_entries, ThreatAttribute_entries_by_number, 3, ThreatAttribute_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ThreatAttribute_entries, ThreatAttribute_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ThreatAttribute_strings[idx].get();
}
bool ThreatAttribute_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatAttribute* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ThreatAttribute_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ThreatAttribute>(int_value);
    }
    return success;
}

// ===================================================================

class SearchHashesRequest::_Internal {
public:
};

SearchHashesRequest::SearchHashesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.V5.SearchHashesRequest)
}
SearchHashesRequest::SearchHashesRequest(const SearchHashesRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SearchHashesRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.hash_prefixes_) { from._impl_.hash_prefixes_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.V5.SearchHashesRequest)
}

inline void SearchHashesRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.hash_prefixes_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

SearchHashesRequest::~SearchHashesRequest()
{
    // @@protoc_insertion_point(destructor:safe_browsing.V5.SearchHashesRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SearchHashesRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.hash_prefixes_.~RepeatedPtrField();
}

void SearchHashesRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SearchHashesRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.V5.SearchHashesRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.hash_prefixes_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SearchHashesRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated bytes hash_prefixes = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_hash_prefixes();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SearchHashesRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.V5.SearchHashesRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated bytes hash_prefixes = 1;
    for (int i = 0, n = this->_internal_hash_prefixes_size(); i < n; i++) {
        const auto& s = this->_internal_hash_prefixes(i);
        target = stream->WriteBytes(1, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.V5.SearchHashesRequest)
    return target;
}

size_t SearchHashesRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.V5.SearchHashesRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated bytes hash_prefixes = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.hash_prefixes_.size());
    for (int i = 0, n = _impl_.hash_prefixes_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(_impl_.hash_prefixes_.Get(i));
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SearchHashesRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SearchHashesRequest*>(&from));
}

void SearchHashesRequest::MergeFrom(const SearchHashesRequest& from)
{
    SearchHashesRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.V5.SearchHashesRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.hash_prefixes_.MergeFrom(from._impl_.hash_prefixes_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SearchHashesRequest::CopyFrom(const SearchHashesRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.V5.SearchHashesRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SearchHashesRequest::IsInitialized() const
{
    return true;
}

void SearchHashesRequest::InternalSwap(SearchHashesRequest* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.hash_prefixes_.InternalSwap(&other->_impl_.hash_prefixes_);
}

std::string SearchHashesRequest::GetTypeName() const
{
    return "safe_browsing.V5.SearchHashesRequest";
}

// ===================================================================

class SearchHashesResponse::_Internal {
public:
    static const ::safe_browsing::V5::Duration& cache_duration(const SearchHashesResponse* msg);
};

const ::safe_browsing::V5::Duration& SearchHashesResponse::_Internal::cache_duration(const SearchHashesResponse* msg)
{
    return *msg->_impl_.cache_duration_;
}
SearchHashesResponse::SearchHashesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.V5.SearchHashesResponse)
}
SearchHashesResponse::SearchHashesResponse(const SearchHashesResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SearchHashesResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.full_hashes_) { from._impl_.full_hashes_ }, decltype(_impl_.cache_duration_) { nullptr },
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_cache_duration()) {
        _this->_impl_.cache_duration_ = new ::safe_browsing::V5::Duration(*from._impl_.cache_duration_);
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.V5.SearchHashesResponse)
}

inline void SearchHashesResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.full_hashes_) { arena }, decltype(_impl_.cache_duration_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };
}

SearchHashesResponse::~SearchHashesResponse()
{
    // @@protoc_insertion_point(destructor:safe_browsing.V5.SearchHashesResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SearchHashesResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.full_hashes_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.cache_duration_;
}

void SearchHashesResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SearchHashesResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.V5.SearchHashesResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.full_hashes_.Clear();
    if (GetArenaForAllocation() == nullptr && _impl_.cache_duration_ != nullptr) {
        delete _impl_.cache_duration_;
    }
    _impl_.cache_duration_ = nullptr;
    _internal_metadata_.Clear<std::string>();
}

const char* SearchHashesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.V5.FullHash full_hashes = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_full_hashes(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // .safe_browsing.V5.Duration cache_duration = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_cache_duration(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SearchHashesResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.V5.SearchHashesResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.V5.FullHash full_hashes = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_full_hashes_size()); i < n; i++) {
        const auto& repfield = this->_internal_full_hashes(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    // .safe_browsing.V5.Duration cache_duration = 2;
    if (this->_internal_has_cache_duration()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::cache_duration(this), _Internal::cache_duration(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.V5.SearchHashesResponse)
    return target;
}

size_t SearchHashesResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.V5.SearchHashesResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.V5.FullHash full_hashes = 1;
    total_size += 1UL * this->_internal_full_hashes_size();
    for (const auto& msg : this->_impl_.full_hashes_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // .safe_browsing.V5.Duration cache_duration = 2;
    if (this->_internal_has_cache_duration()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.cache_duration_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SearchHashesResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SearchHashesResponse*>(&from));
}

void SearchHashesResponse::MergeFrom(const SearchHashesResponse& from)
{
    SearchHashesResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.V5.SearchHashesResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.full_hashes_.MergeFrom(from._impl_.full_hashes_);
    if (from._internal_has_cache_duration()) {
        _this->_internal_mutable_cache_duration()->::safe_browsing::V5::Duration::MergeFrom(from._internal_cache_duration());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SearchHashesResponse::CopyFrom(const SearchHashesResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.V5.SearchHashesResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SearchHashesResponse::IsInitialized() const
{
    return true;
}

void SearchHashesResponse::InternalSwap(SearchHashesResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.full_hashes_.InternalSwap(&other->_impl_.full_hashes_);
    swap(_impl_.cache_duration_, other->_impl_.cache_duration_);
}

std::string SearchHashesResponse::GetTypeName() const
{
    return "safe_browsing.V5.SearchHashesResponse";
}

// ===================================================================

class FullHash_FullHashDetail::_Internal {
public:
};

FullHash_FullHashDetail::FullHash_FullHashDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.V5.FullHash.FullHashDetail)
}
FullHash_FullHashDetail::FullHash_FullHashDetail(const FullHash_FullHashDetail& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    FullHash_FullHashDetail* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.attributes_) { from._impl_.attributes_ }, /*decltype(_impl_._attributes_cached_byte_size_)*/ { 0 },
        decltype(_impl_.threat_type_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.threat_type_ = from._impl_.threat_type_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.V5.FullHash.FullHashDetail)
}

inline void FullHash_FullHashDetail::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.attributes_) { arena }, /*decltype(_impl_._attributes_cached_byte_size_)*/ { 0 }, decltype(_impl_.threat_type_) { 0 },
        /*decltype(_impl_._cached_size_)*/ {} };
}

FullHash_FullHashDetail::~FullHash_FullHashDetail()
{
    // @@protoc_insertion_point(destructor:safe_browsing.V5.FullHash.FullHashDetail)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void FullHash_FullHashDetail::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.attributes_.~RepeatedField();
}

void FullHash_FullHashDetail::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void FullHash_FullHashDetail::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.V5.FullHash.FullHashDetail)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.attributes_.Clear();
    _impl_.threat_type_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* FullHash_FullHashDetail::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .safe_browsing.V5.ThreatType threat_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_threat_type(static_cast<::safe_browsing::V5::ThreatType>(val));
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.V5.ThreatAttribute attributes = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_attributes(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 16) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_add_attributes(static_cast<::safe_browsing::V5::ThreatAttribute>(val));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* FullHash_FullHashDetail::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.V5.FullHash.FullHashDetail)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .safe_browsing.V5.ThreatType threat_type = 1;
    if (this->_internal_threat_type() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_threat_type(), target);
    }

    // repeated .safe_browsing.V5.ThreatAttribute attributes = 2;
    {
        int byte_size = _impl_._attributes_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteEnumPacked(2, _impl_.attributes_, byte_size, target);
        }
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.V5.FullHash.FullHashDetail)
    return target;
}

size_t FullHash_FullHashDetail::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.V5.FullHash.FullHashDetail)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.V5.ThreatAttribute attributes = 2;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_attributes_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_attributes(static_cast<int>(i)));
        }
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._attributes_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    // .safe_browsing.V5.ThreatType threat_type = 1;
    if (this->_internal_threat_type() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_type());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void FullHash_FullHashDetail::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const FullHash_FullHashDetail*>(&from));
}

void FullHash_FullHashDetail::MergeFrom(const FullHash_FullHashDetail& from)
{
    FullHash_FullHashDetail* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.V5.FullHash.FullHashDetail)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.attributes_.MergeFrom(from._impl_.attributes_);
    if (from._internal_threat_type() != 0) {
        _this->_internal_set_threat_type(from._internal_threat_type());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FullHash_FullHashDetail::CopyFrom(const FullHash_FullHashDetail& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.V5.FullHash.FullHashDetail)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FullHash_FullHashDetail::IsInitialized() const
{
    return true;
}

void FullHash_FullHashDetail::InternalSwap(FullHash_FullHashDetail* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.attributes_.InternalSwap(&other->_impl_.attributes_);
    swap(_impl_.threat_type_, other->_impl_.threat_type_);
}

std::string FullHash_FullHashDetail::GetTypeName() const
{
    return "safe_browsing.V5.FullHash.FullHashDetail";
}

// ===================================================================

class FullHash::_Internal {
public:
};

FullHash::FullHash(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.V5.FullHash)
}
FullHash::FullHash(const FullHash& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    FullHash* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_.full_hash_details_) { from._impl_.full_hash_details_ }, decltype(_impl_.full_hash_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.full_hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.full_hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_full_hash().empty()) {
        _this->_impl_.full_hash_.Set(from._internal_full_hash(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.V5.FullHash)
}

inline void FullHash::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.full_hash_details_) { arena }, decltype(_impl_.full_hash_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.full_hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.full_hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FullHash::~FullHash()
{
    // @@protoc_insertion_point(destructor:safe_browsing.V5.FullHash)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void FullHash::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.full_hash_details_.~RepeatedPtrField();
    _impl_.full_hash_.Destroy();
}

void FullHash::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void FullHash::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.V5.FullHash)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.full_hash_details_.Clear();
    _impl_.full_hash_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* FullHash::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // bytes full_hash = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_full_hash();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.V5.FullHash.FullHashDetail full_hash_details = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_full_hash_details(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* FullHash::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.V5.FullHash)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // bytes full_hash = 1;
    if (!this->_internal_full_hash().empty()) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_full_hash(), target);
    }

    // repeated .safe_browsing.V5.FullHash.FullHashDetail full_hash_details = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_full_hash_details_size()); i < n; i++) {
        const auto& repfield = this->_internal_full_hash_details(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.V5.FullHash)
    return target;
}

size_t FullHash::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.V5.FullHash)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.V5.FullHash.FullHashDetail full_hash_details = 2;
    total_size += 1UL * this->_internal_full_hash_details_size();
    for (const auto& msg : this->_impl_.full_hash_details_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // bytes full_hash = 1;
    if (!this->_internal_full_hash().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_full_hash());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void FullHash::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const FullHash*>(&from));
}

void FullHash::MergeFrom(const FullHash& from)
{
    FullHash* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.V5.FullHash)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.full_hash_details_.MergeFrom(from._impl_.full_hash_details_);
    if (!from._internal_full_hash().empty()) {
        _this->_internal_set_full_hash(from._internal_full_hash());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FullHash::CopyFrom(const FullHash& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.V5.FullHash)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FullHash::IsInitialized() const
{
    return true;
}

void FullHash::InternalSwap(FullHash* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.full_hash_details_.InternalSwap(&other->_impl_.full_hash_details_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.full_hash_, lhs_arena, &other->_impl_.full_hash_, rhs_arena);
}

std::string FullHash::GetTypeName() const
{
    return "safe_browsing.V5.FullHash";
}

// ===================================================================

class Duration::_Internal {
public:
};

Duration::Duration(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.V5.Duration)
}
Duration::Duration(const Duration& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Duration* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.seconds_) {}, decltype(_impl_.nanos_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.seconds_, &from._impl_.seconds_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nanos_) - reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.V5.Duration)
}

inline void Duration::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.seconds_) { int64_t { 0 } }, decltype(_impl_.nanos_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
}

Duration::~Duration()
{
    // @@protoc_insertion_point(destructor:safe_browsing.V5.Duration)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Duration::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Duration::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Duration::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.V5.Duration)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    ::memset(
        &_impl_.seconds_, 0, static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nanos_) - reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
    _internal_metadata_.Clear<std::string>();
}

const char* Duration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // int64 seconds = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // int32 nanos = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.nanos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Duration::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.V5.Duration)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // int64 seconds = 1;
    if (this->_internal_seconds() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seconds(), target);
    }

    // int32 nanos = 2;
    if (this->_internal_nanos() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nanos(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.V5.Duration)
    return target;
}

size_t Duration::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.V5.Duration)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // int64 seconds = 1;
    if (this->_internal_seconds() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seconds());
    }

    // int32 nanos = 2;
    if (this->_internal_nanos() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nanos());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Duration::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Duration*>(&from));
}

void Duration::MergeFrom(const Duration& from)
{
    Duration* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.V5.Duration)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_seconds() != 0) {
        _this->_internal_set_seconds(from._internal_seconds());
    }
    if (from._internal_nanos() != 0) {
        _this->_internal_set_nanos(from._internal_nanos());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Duration::CopyFrom(const Duration& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.V5.Duration)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Duration::IsInitialized() const
{
    return true;
}

void Duration::InternalSwap(Duration* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Duration, _impl_.nanos_) + sizeof(Duration::_impl_.nanos_)
        - PROTOBUF_FIELD_OFFSET(Duration, _impl_.seconds_)>(reinterpret_cast<char*>(&_impl_.seconds_), reinterpret_cast<char*>(&other->_impl_.seconds_));
}

std::string Duration::GetTypeName() const
{
    return "safe_browsing.V5.Duration";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace V5
} // namespace safe_browsing
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::safe_browsing::V5::SearchHashesRequest* Arena::CreateMaybeMessage<::safe_browsing::V5::SearchHashesRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::V5::SearchHashesRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::V5::SearchHashesResponse* Arena::CreateMaybeMessage<::safe_browsing::V5::SearchHashesResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::V5::SearchHashesResponse>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::V5::FullHash_FullHashDetail* Arena::CreateMaybeMessage<::safe_browsing::V5::FullHash_FullHashDetail>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::V5::FullHash_FullHashDetail>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::V5::FullHash* Arena::CreateMaybeMessage<::safe_browsing::V5::FullHash>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::V5::FullHash>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::V5::Duration* Arena::CreateMaybeMessage<::safe_browsing::V5::Duration>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::V5::Duration>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
