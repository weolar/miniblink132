// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/safe_browsing/core/common/proto/csd.proto

#include "components/safe_browsing/core/common/proto/csd.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace safe_browsing {
PROTOBUF_CONSTEXPR ChromeUserPopulation_PageLoadToken::ChromeUserPopulation_PageLoadToken(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.token_value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.token_time_msec_)*/ int64_t { 0 }, /*decltype(_impl_.token_source_)*/ 0 }
{
}
struct ChromeUserPopulation_PageLoadTokenDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ChromeUserPopulation_PageLoadTokenDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ChromeUserPopulation_PageLoadTokenDefaultTypeInternal()
    {
    }
    union {
        ChromeUserPopulation_PageLoadToken _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeUserPopulation_PageLoadTokenDefaultTypeInternal
    _ChromeUserPopulation_PageLoadToken_default_instance_;
PROTOBUF_CONSTEXPR ChromeUserPopulation::ChromeUserPopulation(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.finch_active_groups_)*/ {},
        /*decltype(_impl_.page_load_tokens_)*/ {}, /*decltype(_impl_.user_agent_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.user_population_)*/ 0, /*decltype(_impl_.profile_management_status_)*/ 0, /*decltype(_impl_.is_history_sync_enabled_)*/ false,
        /*decltype(_impl_.is_under_advanced_protection_)*/ false, /*decltype(_impl_.is_incognito_)*/ false, /*decltype(_impl_.is_mbb_enabled_)*/ false,
        /*decltype(_impl_.number_of_profiles_)*/ 0, /*decltype(_impl_.number_of_loaded_profiles_)*/ 0, /*decltype(_impl_.is_aesb_enabled_)*/ false,
        /*decltype(_impl_.is_signed_in_)*/ false, /*decltype(_impl_.aesb_last_update_time_windows_epoch_micros_)*/ int64_t { 0 } }
{
}
struct ChromeUserPopulationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ChromeUserPopulationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ChromeUserPopulationDefaultTypeInternal()
    {
    }
    union {
        ChromeUserPopulation _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeUserPopulationDefaultTypeInternal
    _ChromeUserPopulation_default_instance_;
PROTOBUF_CONSTEXPR ImageFeatureEmbedding::ImageFeatureEmbedding(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.embedding_value_)*/ {},
        /*decltype(_impl_.embedding_model_version_)*/ 0 }
{
}
struct ImageFeatureEmbeddingDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ImageFeatureEmbeddingDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ImageFeatureEmbeddingDefaultTypeInternal()
    {
    }
    union {
        ImageFeatureEmbedding _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageFeatureEmbeddingDefaultTypeInternal
    _ImageFeatureEmbedding_default_instance_;
PROTOBUF_CONSTEXPR LlamaTriggerRuleInfo::LlamaTriggerRuleInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.llama_trigger_rule_id_)*/ 0,
        /*decltype(_impl_.intelligent_scan_)*/ false }
{
}
struct LlamaTriggerRuleInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LlamaTriggerRuleInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LlamaTriggerRuleInfoDefaultTypeInternal()
    {
    }
    union {
        LlamaTriggerRuleInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LlamaTriggerRuleInfoDefaultTypeInternal
    _LlamaTriggerRuleInfo_default_instance_;
PROTOBUF_CONSTEXPR LlamaForcedTriggerInfo::LlamaForcedTriggerInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.llama_trigger_rule_infos_)*/ {},
        /*decltype(_impl_.intelligent_scan_)*/ false }
{
}
struct LlamaForcedTriggerInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LlamaForcedTriggerInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LlamaForcedTriggerInfoDefaultTypeInternal()
    {
    }
    union {
        LlamaForcedTriggerInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LlamaForcedTriggerInfoDefaultTypeInternal
    _LlamaForcedTriggerInfo_default_instance_;
PROTOBUF_CONSTEXPR ClientPhishingRequest_Feature::ClientPhishingRequest_Feature(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.value_)*/ 0 }
{
}
struct ClientPhishingRequest_FeatureDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientPhishingRequest_FeatureDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientPhishingRequest_FeatureDefaultTypeInternal()
    {
    }
    union {
        ClientPhishingRequest_Feature _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientPhishingRequest_FeatureDefaultTypeInternal
    _ClientPhishingRequest_Feature_default_instance_;
PROTOBUF_CONSTEXPR ClientPhishingRequest_CategoryScore::ClientPhishingRequest_CategoryScore(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.label_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.value_)*/ 0 }
{
}
struct ClientPhishingRequest_CategoryScoreDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientPhishingRequest_CategoryScoreDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientPhishingRequest_CategoryScoreDefaultTypeInternal()
    {
    }
    union {
        ClientPhishingRequest_CategoryScore _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientPhishingRequest_CategoryScoreDefaultTypeInternal
    _ClientPhishingRequest_CategoryScore_default_instance_;
PROTOBUF_CONSTEXPR ClientPhishingRequest::ClientPhishingRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.feature_map_)*/ {},
        /*decltype(_impl_.non_model_feature_map_)*/ {}, /*decltype(_impl_.shingle_hashes_)*/ {}, /*decltype(_impl_._shingle_hashes_cached_byte_size_)*/ { 0 },
        /*decltype(_impl_.referrer_chain_)*/ {}, /*decltype(_impl_.tflite_model_scores_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.obsolete_referrer_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.obsolete_hash_prefix_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.deprecated_model_filename_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.population_)*/ nullptr, /*decltype(_impl_.visual_features_)*/ nullptr, /*decltype(_impl_.image_feature_embedding_)*/ nullptr,
        /*decltype(_impl_.llama_forced_trigger_info_)*/ nullptr, /*decltype(_impl_.client_score_)*/ 0, /*decltype(_impl_.model_version_)*/ 0,
        /*decltype(_impl_.is_phishing_)*/ false, /*decltype(_impl_.is_dom_match_)*/ false, /*decltype(_impl_.is_tflite_match_)*/ false,
        /*decltype(_impl_.tflite_model_version_)*/ 0, /*decltype(_impl_.dom_model_version_)*/ 0, /*decltype(_impl_.client_side_detection_type_)*/ 0,
        /*decltype(_impl_.report_type_)*/ 0 }
{
}
struct ClientPhishingRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientPhishingRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientPhishingRequestDefaultTypeInternal()
    {
    }
    union {
        ClientPhishingRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientPhishingRequestDefaultTypeInternal
    _ClientPhishingRequest_default_instance_;
PROTOBUF_CONSTEXPR ClientPhishingResponse::ClientPhishingResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.obsolete_allowlist_expression_)*/ {},
        /*decltype(_impl_.phishy_)*/ false }
{
}
struct ClientPhishingResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientPhishingResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientPhishingResponseDefaultTypeInternal()
    {
    }
    union {
        ClientPhishingResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientPhishingResponseDefaultTypeInternal
    _ClientPhishingResponse_default_instance_;
PROTOBUF_CONSTEXPR LoginReputationClientRequest_Frame_Form::LoginReputationClientRequest_Frame_Form(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.action_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.has_password_field_)*/ false }
{
}
struct LoginReputationClientRequest_Frame_FormDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LoginReputationClientRequest_Frame_FormDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LoginReputationClientRequest_Frame_FormDefaultTypeInternal()
    {
    }
    union {
        LoginReputationClientRequest_Frame_Form _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginReputationClientRequest_Frame_FormDefaultTypeInternal
    _LoginReputationClientRequest_Frame_Form_default_instance_;
PROTOBUF_CONSTEXPR LoginReputationClientRequest_Frame::LoginReputationClientRequest_Frame(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.referrer_chain_)*/ {},
        /*decltype(_impl_.forms_)*/ {}, /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.referrer_chain_options_)*/ nullptr, /*decltype(_impl_.frame_index_)*/ 0, /*decltype(_impl_.parent_frame_index_)*/ 0,
        /*decltype(_impl_.has_password_field_)*/ false }
{
}
struct LoginReputationClientRequest_FrameDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LoginReputationClientRequest_FrameDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LoginReputationClientRequest_FrameDefaultTypeInternal()
    {
    }
    union {
        LoginReputationClientRequest_Frame _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginReputationClientRequest_FrameDefaultTypeInternal
    _LoginReputationClientRequest_Frame_default_instance_;
PROTOBUF_CONSTEXPR
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType(
        ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.is_account_syncing_)*/ false,
        /*decltype(_impl_.account_type_)*/ 0 }
{
}
struct LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountTypeDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountTypeDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountTypeDefaultTypeInternal()
    {
    }
    union {
        LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountTypeDefaultTypeInternal
        _LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_default_instance_;
PROTOBUF_CONSTEXPR LoginReputationClientRequest_PasswordReuseEvent::LoginReputationClientRequest_PasswordReuseEvent(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.domains_matching_password_)*/ {},
        /*decltype(_impl_.reused_password_account_type_)*/ nullptr, /*decltype(_impl_.frame_id_)*/ 0, /*decltype(_impl_.sync_account_type_)*/ 0,
        /*decltype(_impl_.reused_password_type_)*/ 0 }
{
}
struct LoginReputationClientRequest_PasswordReuseEventDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LoginReputationClientRequest_PasswordReuseEventDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LoginReputationClientRequest_PasswordReuseEventDefaultTypeInternal()
    {
    }
    union {
        LoginReputationClientRequest_PasswordReuseEvent _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginReputationClientRequest_PasswordReuseEventDefaultTypeInternal
    _LoginReputationClientRequest_PasswordReuseEvent_default_instance_;
PROTOBUF_CONSTEXPR LoginReputationClientRequest_UrlDisplayExperiment::LoginReputationClientRequest_UrlDisplayExperiment(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.delayed_warnings_enabled_)*/ false,
        /*decltype(_impl_.delayed_warnings_mouse_clicks_enabled_)*/ false, /*decltype(_impl_.reveal_on_hover_)*/ false,
        /*decltype(_impl_.hide_on_interaction_)*/ false, /*decltype(_impl_.elide_to_registrable_domain_)*/ false,
        /*decltype(_impl_.simplified_url_display_enabled_)*/ false }
{
}
struct LoginReputationClientRequest_UrlDisplayExperimentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LoginReputationClientRequest_UrlDisplayExperimentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LoginReputationClientRequest_UrlDisplayExperimentDefaultTypeInternal()
    {
    }
    union {
        LoginReputationClientRequest_UrlDisplayExperiment _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginReputationClientRequest_UrlDisplayExperimentDefaultTypeInternal
    _LoginReputationClientRequest_UrlDisplayExperiment_default_instance_;
PROTOBUF_CONSTEXPR LoginReputationClientRequest_ReferringAppInfo::LoginReputationClientRequest_ReferringAppInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.referring_app_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.referring_app_source_)*/ 0 }
{
}
struct LoginReputationClientRequest_ReferringAppInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LoginReputationClientRequest_ReferringAppInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LoginReputationClientRequest_ReferringAppInfoDefaultTypeInternal()
    {
    }
    union {
        LoginReputationClientRequest_ReferringAppInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginReputationClientRequest_ReferringAppInfoDefaultTypeInternal
    _LoginReputationClientRequest_ReferringAppInfo_default_instance_;
PROTOBUF_CONSTEXPR LoginReputationClientRequest_DebuggingMetadata::LoginReputationClientRequest_DebuggingMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.csd_model_version_)*/ 0,
        /*decltype(_impl_.preclassification_check_result_)*/ 0, /*decltype(_impl_.phishing_detector_result_)*/ 0,
        /*decltype(_impl_.local_model_detects_phishing_)*/ false, /*decltype(_impl_.forced_request_)*/ false, /*decltype(_impl_.network_result_)*/ 0 }
{
}
struct LoginReputationClientRequest_DebuggingMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LoginReputationClientRequest_DebuggingMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LoginReputationClientRequest_DebuggingMetadataDefaultTypeInternal()
    {
    }
    union {
        LoginReputationClientRequest_DebuggingMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginReputationClientRequest_DebuggingMetadataDefaultTypeInternal
    _LoginReputationClientRequest_DebuggingMetadata_default_instance_;
PROTOBUF_CONSTEXPR LoginReputationClientRequest::LoginReputationClientRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.frames_)*/ {},
        /*decltype(_impl_.page_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.content_type_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.password_reuse_event_)*/ nullptr, /*decltype(_impl_.population_)*/ nullptr, /*decltype(_impl_.visual_features_)*/ nullptr,
        /*decltype(_impl_.dom_features_)*/ nullptr, /*decltype(_impl_.url_display_experiment_)*/ nullptr, /*decltype(_impl_.referring_app_info_)*/ nullptr,
        /*decltype(_impl_.csd_debugging_metadata_)*/ nullptr, /*decltype(_impl_.trigger_type_)*/ 0, /*decltype(_impl_.stored_verdict_cnt_)*/ 0,
        /*decltype(_impl_.clicked_through_interstitial_)*/ false, /*decltype(_impl_.content_area_height_)*/ 0, /*decltype(_impl_.content_area_width_)*/ 0,
        /*decltype(_impl_.report_type_)*/ 0 }
{
}
struct LoginReputationClientRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LoginReputationClientRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LoginReputationClientRequestDefaultTypeInternal()
    {
    }
    union {
        LoginReputationClientRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginReputationClientRequestDefaultTypeInternal
    _LoginReputationClientRequest_default_instance_;
PROTOBUF_CONSTEXPR LoginReputationClientResponse::LoginReputationClientResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.cache_expression_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.verdict_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.cache_duration_sec_)*/ int64_t { 0 }, /*decltype(_impl_.verdict_type_)*/ 0,
        /*decltype(_impl_.deprecated_cache_expression_exact_match_)*/ false }
{
}
struct LoginReputationClientResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LoginReputationClientResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LoginReputationClientResponseDefaultTypeInternal()
    {
    }
    union {
        LoginReputationClientResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoginReputationClientResponseDefaultTypeInternal
    _LoginReputationClientResponse_default_instance_;
PROTOBUF_CONSTEXPR VisualFeatures_BlurredImage::VisualFeatures_BlurredImage(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.data_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.width_)*/ 0,
        /*decltype(_impl_.height_)*/ 0 }
{
}
struct VisualFeatures_BlurredImageDefaultTypeInternal {
    PROTOBUF_CONSTEXPR VisualFeatures_BlurredImageDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~VisualFeatures_BlurredImageDefaultTypeInternal()
    {
    }
    union {
        VisualFeatures_BlurredImage _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VisualFeatures_BlurredImageDefaultTypeInternal
    _VisualFeatures_BlurredImage_default_instance_;
PROTOBUF_CONSTEXPR VisualFeatures::VisualFeatures(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.image_)*/ nullptr }
{
}
struct VisualFeaturesDefaultTypeInternal {
    PROTOBUF_CONSTEXPR VisualFeaturesDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~VisualFeaturesDefaultTypeInternal()
    {
    }
    union {
        VisualFeatures _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VisualFeaturesDefaultTypeInternal _VisualFeatures_default_instance_;
PROTOBUF_CONSTEXPR DomFeatures_Feature::DomFeatures_Feature(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.value_)*/ 0 }
{
}
struct DomFeatures_FeatureDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DomFeatures_FeatureDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DomFeatures_FeatureDefaultTypeInternal()
    {
    }
    union {
        DomFeatures_Feature _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DomFeatures_FeatureDefaultTypeInternal
    _DomFeatures_Feature_default_instance_;
PROTOBUF_CONSTEXPR DomFeatures::DomFeatures(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.feature_map_)*/ {},
        /*decltype(_impl_.shingle_hashes_)*/ {}, /*decltype(_impl_._shingle_hashes_cached_byte_size_)*/ { 0 }, /*decltype(_impl_.model_version_)*/ 0 }
{
}
struct DomFeaturesDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DomFeaturesDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DomFeaturesDefaultTypeInternal()
    {
    }
    union {
        DomFeatures _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DomFeaturesDefaultTypeInternal _DomFeatures_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_Digests::ClientDownloadRequest_Digests(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.sha256_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sha1_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.md5_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientDownloadRequest_DigestsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_DigestsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_DigestsDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_Digests _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_DigestsDefaultTypeInternal
    _ClientDownloadRequest_Digests_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_Resource::ClientDownloadRequest_Resource(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.remote_ip_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.referrer_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.type_)*/ 0 }
{
}
struct ClientDownloadRequest_ResourceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_ResourceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_ResourceDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_Resource _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_ResourceDefaultTypeInternal
    _ClientDownloadRequest_Resource_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_CertificateChain_Element::ClientDownloadRequest_CertificateChain_Element(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.certificate_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientDownloadRequest_CertificateChain_ElementDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_CertificateChain_ElementDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_CertificateChain_ElementDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_CertificateChain_Element _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_CertificateChain_ElementDefaultTypeInternal
    _ClientDownloadRequest_CertificateChain_Element_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_CertificateChain::ClientDownloadRequest_CertificateChain(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.element_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ClientDownloadRequest_CertificateChainDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_CertificateChainDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_CertificateChainDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_CertificateChain _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_CertificateChainDefaultTypeInternal
    _ClientDownloadRequest_CertificateChain_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_ExtendedAttr::ClientDownloadRequest_ExtendedAttr(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientDownloadRequest_ExtendedAttrDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_ExtendedAttrDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_ExtendedAttrDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_ExtendedAttr _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_ExtendedAttrDefaultTypeInternal
    _ClientDownloadRequest_ExtendedAttr_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_SignatureInfo::ClientDownloadRequest_SignatureInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.certificate_chain_)*/ {},
        /*decltype(_impl_.signed_data_)*/ {}, /*decltype(_impl_.xattr_)*/ {}, /*decltype(_impl_.trusted_)*/ false }
{
}
struct ClientDownloadRequest_SignatureInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_SignatureInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_SignatureInfoDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_SignatureInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_SignatureInfoDefaultTypeInternal
    _ClientDownloadRequest_SignatureInfo_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_PEImageHeaders_DebugData::ClientDownloadRequest_PEImageHeaders_DebugData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.directory_entry_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.raw_data_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientDownloadRequest_PEImageHeaders_DebugDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_PEImageHeaders_DebugDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_PEImageHeaders_DebugDataDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_PEImageHeaders_DebugData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_PEImageHeaders_DebugDataDefaultTypeInternal
    _ClientDownloadRequest_PEImageHeaders_DebugData_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_PEImageHeaders::ClientDownloadRequest_PEImageHeaders(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.section_header_)*/ {},
        /*decltype(_impl_.debug_data_)*/ {}, /*decltype(_impl_.dos_header_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.file_header_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.optional_headers32_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.optional_headers64_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.export_section_data_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientDownloadRequest_PEImageHeadersDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_PEImageHeadersDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_PEImageHeadersDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_PEImageHeaders _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_PEImageHeadersDefaultTypeInternal
    _ClientDownloadRequest_PEImageHeaders_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_MachOHeaders_LoadCommand::ClientDownloadRequest_MachOHeaders_LoadCommand(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.command_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.command_id_)*/ 0u }
{
}
struct ClientDownloadRequest_MachOHeaders_LoadCommandDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_MachOHeaders_LoadCommandDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_MachOHeaders_LoadCommandDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_MachOHeaders_LoadCommand _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_MachOHeaders_LoadCommandDefaultTypeInternal
    _ClientDownloadRequest_MachOHeaders_LoadCommand_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_MachOHeaders::ClientDownloadRequest_MachOHeaders(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.load_commands_)*/ {},
        /*decltype(_impl_.mach_header_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientDownloadRequest_MachOHeadersDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_MachOHeadersDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_MachOHeadersDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_MachOHeaders _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_MachOHeadersDefaultTypeInternal
    _ClientDownloadRequest_MachOHeaders_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_ImageHeaders::ClientDownloadRequest_ImageHeaders(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.mach_o_headers_)*/ {},
        /*decltype(_impl_.pe_headers_)*/ nullptr }
{
}
struct ClientDownloadRequest_ImageHeadersDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_ImageHeadersDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_ImageHeadersDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_ImageHeaders _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_ImageHeadersDefaultTypeInternal
    _ClientDownloadRequest_ImageHeaders_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_ArchivedBinary::ClientDownloadRequest_ArchivedBinary(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.file_path_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.digests_)*/ nullptr,
        /*decltype(_impl_.signature_)*/ nullptr, /*decltype(_impl_.image_headers_)*/ nullptr, /*decltype(_impl_.length_)*/ int64_t { 0 },
        /*decltype(_impl_.download_type_)*/ 0, /*decltype(_impl_.is_encrypted_)*/ false, /*decltype(_impl_.is_executable_)*/ false,
        /*decltype(_impl_.is_archive_)*/ false }
{
}
struct ClientDownloadRequest_ArchivedBinaryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_ArchivedBinaryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_ArchivedBinaryDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_ArchivedBinary _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_ArchivedBinaryDefaultTypeInternal
    _ClientDownloadRequest_ArchivedBinary_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_DetachedCodeSignature::ClientDownloadRequest_DetachedCodeSignature(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.file_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.contents_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientDownloadRequest_DetachedCodeSignatureDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_DetachedCodeSignatureDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_DetachedCodeSignatureDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_DetachedCodeSignature _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_DetachedCodeSignatureDefaultTypeInternal
    _ClientDownloadRequest_DetachedCodeSignature_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_ArchiveSummary::ClientDownloadRequest_ArchiveSummary(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.parser_status_)*/ 0,
        /*decltype(_impl_.file_count_)*/ 0, /*decltype(_impl_.directory_count_)*/ 0, /*decltype(_impl_.is_encrypted_)*/ false }
{
}
struct ClientDownloadRequest_ArchiveSummaryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_ArchiveSummaryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_ArchiveSummaryDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_ArchiveSummary _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_ArchiveSummaryDefaultTypeInternal
    _ClientDownloadRequest_ArchiveSummary_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest_TailoredInfo::ClientDownloadRequest_TailoredInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.version_)*/ 0 }
{
}
struct ClientDownloadRequest_TailoredInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequest_TailoredInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequest_TailoredInfoDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest_TailoredInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequest_TailoredInfoDefaultTypeInternal
    _ClientDownloadRequest_TailoredInfo_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadRequest::ClientDownloadRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.resources_)*/ {},
        /*decltype(_impl_.archived_binary_)*/ {}, /*decltype(_impl_.alternate_extensions_)*/ {}, /*decltype(_impl_.referrer_chain_)*/ {},
        /*decltype(_impl_.detached_code_signature_)*/ {}, /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.file_basename_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.locale_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.udif_code_signature_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.access_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.previous_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.digests_)*/ nullptr,
        /*decltype(_impl_.signature_)*/ nullptr, /*decltype(_impl_.image_headers_)*/ nullptr, /*decltype(_impl_.population_)*/ nullptr,
        /*decltype(_impl_.referrer_chain_options_)*/ nullptr, /*decltype(_impl_.archive_summary_)*/ nullptr, /*decltype(_impl_.tailored_info_)*/ nullptr,
        /*decltype(_impl_.length_)*/ int64_t { 0 }, /*decltype(_impl_.download_type_)*/ 0, /*decltype(_impl_.user_initiated_)*/ false,
        /*decltype(_impl_.deprecated_archive_valid_)*/ false, /*decltype(_impl_.skipped_url_allowlist_)*/ false,
        /*decltype(_impl_.skipped_certificate_allowlist_)*/ false, /*decltype(_impl_.deprecated_download_attribution_finch_enabled_)*/ false,
        /*decltype(_impl_.request_ap_verdicts_)*/ false, /*decltype(_impl_.deprecated_archive_file_count_)*/ 0,
        /*decltype(_impl_.deprecated_archive_directory_count_)*/ 0 }
{
}
struct ClientDownloadRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadRequestDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadRequestDefaultTypeInternal
    _ClientDownloadRequest_default_instance_;
PROTOBUF_CONSTEXPR ReferrerChainOptions::ReferrerChainOptions(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.recent_navigations_to_collect_)*/ 0 }
{
}
struct ReferrerChainOptionsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ReferrerChainOptionsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ReferrerChainOptionsDefaultTypeInternal()
    {
    }
    union {
        ReferrerChainOptions _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReferrerChainOptionsDefaultTypeInternal
    _ReferrerChainOptions_default_instance_;
PROTOBUF_CONSTEXPR ReferrerChainEntry_ServerRedirect::ReferrerChainEntry_ServerRedirect(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ReferrerChainEntry_ServerRedirectDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ReferrerChainEntry_ServerRedirectDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ReferrerChainEntry_ServerRedirectDefaultTypeInternal()
    {
    }
    union {
        ReferrerChainEntry_ServerRedirect _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReferrerChainEntry_ServerRedirectDefaultTypeInternal
    _ReferrerChainEntry_ServerRedirect_default_instance_;
PROTOBUF_CONSTEXPR ReferrerChainEntry::ReferrerChainEntry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.ip_addresses_)*/ {},
        /*decltype(_impl_.server_redirect_chain_)*/ {}, /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.referrer_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.referrer_main_frame_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.main_frame_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.navigation_time_msec_)*/ 0, /*decltype(_impl_.navigation_initiation_)*/ 0, /*decltype(_impl_.is_retargeting_)*/ false,
        /*decltype(_impl_.maybe_launched_by_external_application_)*/ false, /*decltype(_impl_.is_subframe_url_removed_)*/ false,
        /*decltype(_impl_.is_subframe_referrer_url_removed_)*/ false, /*decltype(_impl_.is_url_removed_by_policy_)*/ false, /*decltype(_impl_.type_)*/ 4 }
{
}
struct ReferrerChainEntryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ReferrerChainEntryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ReferrerChainEntryDefaultTypeInternal()
    {
    }
    union {
        ReferrerChainEntry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReferrerChainEntryDefaultTypeInternal _ReferrerChainEntry_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadResponse_MoreInfo::ClientDownloadResponse_MoreInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.description_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientDownloadResponse_MoreInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadResponse_MoreInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadResponse_MoreInfoDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadResponse_MoreInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadResponse_MoreInfoDefaultTypeInternal
    _ClientDownloadResponse_MoreInfo_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadResponse_TailoredVerdict::ClientDownloadResponse_TailoredVerdict(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.adjustments_)*/ {},
        /*decltype(_impl_._adjustments_cached_byte_size_)*/ { 0 }, /*decltype(_impl_.tailored_verdict_type_)*/ 0 }
{
}
struct ClientDownloadResponse_TailoredVerdictDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadResponse_TailoredVerdictDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadResponse_TailoredVerdictDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadResponse_TailoredVerdict _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadResponse_TailoredVerdictDefaultTypeInternal
    _ClientDownloadResponse_TailoredVerdict_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadResponse::ClientDownloadResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.more_info_)*/ nullptr,
        /*decltype(_impl_.tailored_verdict_)*/ nullptr, /*decltype(_impl_.verdict_)*/ 0, /*decltype(_impl_.upload_)*/ false,
        /*decltype(_impl_.request_deep_scan_)*/ false, /*decltype(_impl_.is_suspicious_encrypted_archive_)*/ false }
{
}
struct ClientDownloadResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadResponseDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadResponseDefaultTypeInternal
    _ClientDownloadResponse_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadReport_UserInformation::ClientDownloadReport_UserInformation(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.email_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientDownloadReport_UserInformationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadReport_UserInformationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadReport_UserInformationDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadReport_UserInformation _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadReport_UserInformationDefaultTypeInternal
    _ClientDownloadReport_UserInformation_default_instance_;
PROTOBUF_CONSTEXPR ClientDownloadReport::ClientDownloadReport(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.comment_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.download_request_)*/ nullptr,
        /*decltype(_impl_.user_information_)*/ nullptr, /*decltype(_impl_.download_response_)*/ nullptr, /*decltype(_impl_.reason_)*/ 0 }
{
}
struct ClientDownloadReportDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientDownloadReportDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientDownloadReportDefaultTypeInternal()
    {
    }
    union {
        ClientDownloadReport _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientDownloadReportDefaultTypeInternal
    _ClientDownloadReport_default_instance_;
PROTOBUF_CONSTEXPR ClientUploadResponse::ClientUploadResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.permalink_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.status_)*/ 0 }
{
}
struct ClientUploadResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientUploadResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientUploadResponseDefaultTypeInternal()
    {
    }
    union {
        ClientUploadResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientUploadResponseDefaultTypeInternal
    _ClientUploadResponse_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_TrackedPreferenceIncident::ClientIncidentReport_IncidentData_TrackedPreferenceIncident(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.split_key_)*/ {},
        /*decltype(_impl_.path_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.atomic_value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.value_state_)*/ 0 }
{
}
struct ClientIncidentReport_IncidentData_TrackedPreferenceIncidentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_TrackedPreferenceIncidentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_IncidentData_TrackedPreferenceIncidentDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_IncidentData_TrackedPreferenceIncident _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ClientIncidentReport_IncidentData_TrackedPreferenceIncidentDefaultTypeInternal
        _ClientIncidentReport_IncidentData_TrackedPreferenceIncident_default_instance_;
PROTOBUF_CONSTEXPR
    ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile(
        ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.relative_path_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.signature_)*/ nullptr,
        /*decltype(_impl_.image_headers_)*/ nullptr }
{
}
struct ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFileDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFileDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFileDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFileDefaultTypeInternal
        _ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_BinaryIntegrityIncident::ClientIncidentReport_IncidentData_BinaryIntegrityIncident(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.contained_file_)*/ {},
        /*decltype(_impl_.file_basename_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.signature_)*/ nullptr,
        /*decltype(_impl_.image_headers_)*/ nullptr, /*decltype(_impl_.sec_error_)*/ 0 }
{
}
struct ClientIncidentReport_IncidentData_BinaryIntegrityIncidentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_BinaryIntegrityIncidentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_IncidentData_BinaryIntegrityIncidentDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_IncidentData_BinaryIntegrityIncident _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_IncidentData_BinaryIntegrityIncidentDefaultTypeInternal
    _ClientIncidentReport_IncidentData_BinaryIntegrityIncident_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_ResourceRequestIncident::ClientIncidentReport_IncidentData_ResourceRequestIncident(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.digest_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.origin_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.type_)*/ 0 }
{
}
struct ClientIncidentReport_IncidentData_ResourceRequestIncidentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData_ResourceRequestIncidentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_IncidentData_ResourceRequestIncidentDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_IncidentData_ResourceRequestIncident _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_IncidentData_ResourceRequestIncidentDefaultTypeInternal
    _ClientIncidentReport_IncidentData_ResourceRequestIncident_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentData::ClientIncidentReport_IncidentData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.tracked_preference_)*/ nullptr,
        /*decltype(_impl_.binary_integrity_)*/ nullptr, /*decltype(_impl_.resource_request_)*/ nullptr, /*decltype(_impl_.incident_time_msec_)*/ int64_t { 0 } }
{
}
struct ClientIncidentReport_IncidentDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_IncidentDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_IncidentDataDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_IncidentData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_IncidentDataDefaultTypeInternal
    _ClientIncidentReport_IncidentData_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_DownloadDetails::ClientIncidentReport_DownloadDetails(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.download_)*/ nullptr,
        /*decltype(_impl_.download_time_msec_)*/ int64_t { 0 }, /*decltype(_impl_.open_time_msec_)*/ int64_t { 0 } }
{
}
struct ClientIncidentReport_DownloadDetailsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_DownloadDetailsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_DownloadDetailsDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_DownloadDetails _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_DownloadDetailsDefaultTypeInternal
    _ClientIncidentReport_DownloadDetails_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_OS_RegistryValue::ClientIncidentReport_EnvironmentData_OS_RegistryValue(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.data_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.type_)*/ 0u }
{
}
struct ClientIncidentReport_EnvironmentData_OS_RegistryValueDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_OS_RegistryValueDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_EnvironmentData_OS_RegistryValueDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_EnvironmentData_OS_RegistryValue _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_OS_RegistryValueDefaultTypeInternal
    _ClientIncidentReport_EnvironmentData_OS_RegistryValue_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_OS_RegistryKey::ClientIncidentReport_EnvironmentData_OS_RegistryKey(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.value_)*/ {}, /*decltype(_impl_.key_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientIncidentReport_EnvironmentData_OS_RegistryKeyDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_OS_RegistryKeyDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_EnvironmentData_OS_RegistryKeyDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_EnvironmentData_OS_RegistryKey _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_OS_RegistryKeyDefaultTypeInternal
    _ClientIncidentReport_EnvironmentData_OS_RegistryKey_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_OS::ClientIncidentReport_EnvironmentData_OS(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.registry_key_)*/ {},
        /*decltype(_impl_.os_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.os_version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.is_enrolled_to_domain_)*/ false }
{
}
struct ClientIncidentReport_EnvironmentData_OSDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_OSDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_EnvironmentData_OSDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_EnvironmentData_OS _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_OSDefaultTypeInternal
    _ClientIncidentReport_EnvironmentData_OS_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Machine::ClientIncidentReport_EnvironmentData_Machine(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.cpu_architecture_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.cpu_vendor_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.cpuid_)*/ 0u }
{
}
struct ClientIncidentReport_EnvironmentData_MachineDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_MachineDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_EnvironmentData_MachineDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_EnvironmentData_Machine _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_MachineDefaultTypeInternal
    _ClientIncidentReport_EnvironmentData_Machine_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_Patch::ClientIncidentReport_EnvironmentData_Process_Patch(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.function_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.target_dll_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientIncidentReport_EnvironmentData_Process_PatchDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_PatchDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_EnvironmentData_Process_PatchDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_EnvironmentData_Process_Patch _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_Process_PatchDefaultTypeInternal
    _ClientIncidentReport_EnvironmentData_Process_Patch_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_NetworkProvider::ClientIncidentReport_EnvironmentData_Process_NetworkProvider(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ClientIncidentReport_EnvironmentData_Process_NetworkProviderDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_NetworkProviderDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_EnvironmentData_Process_NetworkProviderDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_EnvironmentData_Process_NetworkProvider _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ClientIncidentReport_EnvironmentData_Process_NetworkProviderDefaultTypeInternal
        _ClientIncidentReport_EnvironmentData_Process_NetworkProvider_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_Dll::ClientIncidentReport_EnvironmentData_Process_Dll(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.feature_)*/ {},
        /*decltype(_impl_.path_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.image_headers_)*/ nullptr,
        /*decltype(_impl_.base_address_)*/ uint64_t { 0u }, /*decltype(_impl_.length_)*/ 0u }
{
}
struct ClientIncidentReport_EnvironmentData_Process_DllDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_DllDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_EnvironmentData_Process_DllDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_EnvironmentData_Process_Dll _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_Process_DllDefaultTypeInternal
    _ClientIncidentReport_EnvironmentData_Process_Dll_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.modified_bytes_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.export_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.file_offset_)*/ 0u,
        /*decltype(_impl_.byte_count_)*/ 0 }
{
}
struct ClientIncidentReport_EnvironmentData_Process_ModuleState_ModificationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_ModuleState_ModificationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_EnvironmentData_Process_ModuleState_ModificationDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ClientIncidentReport_EnvironmentData_Process_ModuleState_ModificationDefaultTypeInternal
        _ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_ModuleState::ClientIncidentReport_EnvironmentData_Process_ModuleState(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.obsolete_modified_export_)*/ {},
        /*decltype(_impl_.modification_)*/ {}, /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.modified_state_)*/ 0 }
{
}
struct ClientIncidentReport_EnvironmentData_Process_ModuleStateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process_ModuleStateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_EnvironmentData_Process_ModuleStateDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_EnvironmentData_Process_ModuleState _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_Process_ModuleStateDefaultTypeInternal
    _ClientIncidentReport_EnvironmentData_Process_ModuleState_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_Process::ClientIncidentReport_EnvironmentData_Process(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.obsolete_dlls_)*/ {},
        /*decltype(_impl_.patches_)*/ {}, /*decltype(_impl_.network_providers_)*/ {}, /*decltype(_impl_.dll_)*/ {}, /*decltype(_impl_.blocklisted_dll_)*/ {},
        /*decltype(_impl_.module_state_)*/ {}, /*decltype(_impl_.version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.uptime_msec_)*/ int64_t { 0 }, /*decltype(_impl_.chrome_update_channel_)*/ 0, /*decltype(_impl_.metrics_consent_)*/ false,
        /*decltype(_impl_.obsolete_extended_consent_)*/ false, /*decltype(_impl_.obsolete_field_trial_participant_)*/ false }
{
}
struct ClientIncidentReport_EnvironmentData_ProcessDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData_ProcessDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_EnvironmentData_ProcessDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_EnvironmentData_Process _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentData_ProcessDefaultTypeInternal
    _ClientIncidentReport_EnvironmentData_Process_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentData::ClientIncidentReport_EnvironmentData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.os_)*/ nullptr,
        /*decltype(_impl_.machine_)*/ nullptr, /*decltype(_impl_.process_)*/ nullptr }
{
}
struct ClientIncidentReport_EnvironmentDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_EnvironmentDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_EnvironmentDataDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_EnvironmentData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_EnvironmentDataDefaultTypeInternal
    _ClientIncidentReport_EnvironmentData_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_ExtensionData_ExtensionInfo::ClientIncidentReport_ExtensionData_ExtensionInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.description_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.update_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.manifest_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.state_)*/ 0,
        /*decltype(_impl_.type_)*/ 0, /*decltype(_impl_.has_signature_validation_)*/ false, /*decltype(_impl_.signature_is_valid_)*/ false,
        /*decltype(_impl_.installed_by_custodian_)*/ false, /*decltype(_impl_.installed_by_default_)*/ false, /*decltype(_impl_.installed_by_oem_)*/ false,
        /*decltype(_impl_.from_bookmark_)*/ false, /*decltype(_impl_.from_webstore_)*/ false, /*decltype(_impl_.converted_from_user_script_)*/ false,
        /*decltype(_impl_.install_time_msec_)*/ int64_t { 0 }, /*decltype(_impl_.may_be_untrusted_)*/ false, /*decltype(_impl_.manifest_location_type_)*/ 0 }
{
}
struct ClientIncidentReport_ExtensionData_ExtensionInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_ExtensionData_ExtensionInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_ExtensionData_ExtensionInfoDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_ExtensionData_ExtensionInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_ExtensionData_ExtensionInfoDefaultTypeInternal
    _ClientIncidentReport_ExtensionData_ExtensionInfo_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_ExtensionData::ClientIncidentReport_ExtensionData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.last_installed_extension_)*/ nullptr }
{
}
struct ClientIncidentReport_ExtensionDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_ExtensionDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_ExtensionDataDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_ExtensionData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_ExtensionDataDefaultTypeInternal
    _ClientIncidentReport_ExtensionData_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport_NonBinaryDownloadDetails::ClientIncidentReport_NonBinaryDownloadDetails(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.file_type_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.url_spec_sha256_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.host_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.length_)*/ int64_t { 0 } }
{
}
struct ClientIncidentReport_NonBinaryDownloadDetailsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReport_NonBinaryDownloadDetailsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReport_NonBinaryDownloadDetailsDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport_NonBinaryDownloadDetails _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReport_NonBinaryDownloadDetailsDefaultTypeInternal
    _ClientIncidentReport_NonBinaryDownloadDetails_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentReport::ClientIncidentReport(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.incident_)*/ {},
        /*decltype(_impl_.download_)*/ nullptr, /*decltype(_impl_.environment_)*/ nullptr, /*decltype(_impl_.population_)*/ nullptr,
        /*decltype(_impl_.extension_data_)*/ nullptr, /*decltype(_impl_.non_binary_download_)*/ nullptr }
{
}
struct ClientIncidentReportDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentReportDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentReportDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentReport _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentReportDefaultTypeInternal
    _ClientIncidentReport_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentResponse_EnvironmentRequest::ClientIncidentResponse_EnvironmentRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.dll_index_)*/ 0 }
{
}
struct ClientIncidentResponse_EnvironmentRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentResponse_EnvironmentRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentResponse_EnvironmentRequestDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentResponse_EnvironmentRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentResponse_EnvironmentRequestDefaultTypeInternal
    _ClientIncidentResponse_EnvironmentRequest_default_instance_;
PROTOBUF_CONSTEXPR ClientIncidentResponse::ClientIncidentResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.environment_requests_)*/ {},
        /*decltype(_impl_.token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.download_requested_)*/ false }
{
}
struct ClientIncidentResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientIncidentResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientIncidentResponseDefaultTypeInternal()
    {
    }
    union {
        ClientIncidentResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientIncidentResponseDefaultTypeInternal
    _ClientIncidentResponse_default_instance_;
PROTOBUF_CONSTEXPR DownloadMetadata::DownloadMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.download_)*/ nullptr,
        /*decltype(_impl_.download_id_)*/ 0u }
{
}
struct DownloadMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DownloadMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DownloadMetadataDefaultTypeInternal()
    {
    }
    union {
        DownloadMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownloadMetadataDefaultTypeInternal _DownloadMetadata_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPHeader::ClientSafeBrowsingReportRequest_HTTPHeader(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientSafeBrowsingReportRequest_HTTPHeaderDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPHeaderDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_HTTPHeaderDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_HTTPHeader _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_HTTPHeaderDefaultTypeInternal
    _ClientSafeBrowsingReportRequest_HTTPHeader_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.verb_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.uri_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientSafeBrowsingReportRequest_HTTPRequest_FirstLineDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPRequest_FirstLineDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_HTTPRequest_FirstLineDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_HTTPRequest_FirstLineDefaultTypeInternal
    _ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPRequest::ClientSafeBrowsingReportRequest_HTTPRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.headers_)*/ {},
        /*decltype(_impl_.body_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.bodydigest_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.firstline_)*/ nullptr,
        /*decltype(_impl_.bodylength_)*/ 0 }
{
}
struct ClientSafeBrowsingReportRequest_HTTPRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_HTTPRequestDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_HTTPRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_HTTPRequestDefaultTypeInternal
    _ClientSafeBrowsingReportRequest_HTTPRequest_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.message_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.code_)*/ 0 }
{
}
struct ClientSafeBrowsingReportRequest_HTTPResponse_FirstLineDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPResponse_FirstLineDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_HTTPResponse_FirstLineDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_HTTPResponse_FirstLineDefaultTypeInternal
    _ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPResponse::ClientSafeBrowsingReportRequest_HTTPResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.headers_)*/ {},
        /*decltype(_impl_.body_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.bodydigest_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.remote_ip_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.firstline_)*/ nullptr,
        /*decltype(_impl_.bodylength_)*/ 0 }
{
}
struct ClientSafeBrowsingReportRequest_HTTPResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HTTPResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_HTTPResponseDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_HTTPResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_HTTPResponseDefaultTypeInternal
    _ClientSafeBrowsingReportRequest_HTTPResponse_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_Resource::ClientSafeBrowsingReportRequest_Resource(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.child_ids_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.tag_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.request_)*/ nullptr,
        /*decltype(_impl_.response_)*/ nullptr, /*decltype(_impl_.id_)*/ 0, /*decltype(_impl_.parent_id_)*/ 0 }
{
}
struct ClientSafeBrowsingReportRequest_ResourceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_ResourceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_ResourceDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_Resource _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_ResourceDefaultTypeInternal
    _ClientSafeBrowsingReportRequest_Resource_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.client_version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.google_play_services_version_)*/ int64_t { 0 }, /*decltype(_impl_.url_api_type_)*/ 0, /*decltype(_impl_.is_instant_apps_)*/ false,
        /*decltype(_impl_.is_async_check_)*/ false, /*decltype(_impl_.app_verification_enabled_)*/ false }
{
}
struct ClientSafeBrowsingReportRequest_SafeBrowsingClientPropertiesDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_SafeBrowsingClientPropertiesDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_SafeBrowsingClientPropertiesDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ClientSafeBrowsingReportRequest_SafeBrowsingClientPropertiesDefaultTypeInternal
        _ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.sha256_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ClientSafeBrowsingReportRequest_DownloadItemInfo_DigestsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_DownloadItemInfo_DigestsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_DownloadItemInfo_DigestsDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_DownloadItemInfo_DigestsDefaultTypeInternal
    _ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_DownloadItemInfo::ClientSafeBrowsingReportRequest_DownloadItemInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.file_basename_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.digests_)*/ nullptr,
        /*decltype(_impl_.length_)*/ int64_t { 0 } }
{
}
struct ClientSafeBrowsingReportRequest_DownloadItemInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_DownloadItemInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_DownloadItemInfoDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_DownloadItemInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_DownloadItemInfoDefaultTypeInternal
    _ClientSafeBrowsingReportRequest_DownloadItemInfo_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_DownloadWarningAction::ClientSafeBrowsingReportRequest_DownloadWarningAction(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.surface_)*/ 0, /*decltype(_impl_.action_)*/ 0,
        /*decltype(_impl_.interval_msec_)*/ int64_t { 0 }, /*decltype(_impl_.is_terminal_action_)*/ false }
{
}
struct ClientSafeBrowsingReportRequest_DownloadWarningActionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_DownloadWarningActionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_DownloadWarningActionDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_DownloadWarningAction _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_DownloadWarningActionDefaultTypeInternal
    _ClientSafeBrowsingReportRequest_DownloadWarningAction_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.threat_type_)*/ 0,
        /*decltype(_impl_.matched_global_cache_)*/ false, /*decltype(_impl_.locally_cached_results_threat_type_)*/ 0 }
{
}
struct ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetailsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetailsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetailsDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetailsDefaultTypeInternal
        _ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.url_realtime_details_)*/ nullptr,
        /*decltype(_impl_.hash_realtime_details_)*/ nullptr, /*decltype(_impl_.hash_database_threat_type_)*/ 0 }
{
}
struct ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetailsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetailsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetailsDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetailsDefaultTypeInternal
        _ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_InterstitialInteraction::ClientSafeBrowsingReportRequest_InterstitialInteraction(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.security_interstitial_interaction_)*/ 0,
        /*decltype(_impl_.occurrence_count_)*/ 0, /*decltype(_impl_.first_interaction_timestamp_msec_)*/ int64_t { 0 },
        /*decltype(_impl_.last_interaction_timestamp_msec_)*/ int64_t { 0 } }
{
}
struct ClientSafeBrowsingReportRequest_InterstitialInteractionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_InterstitialInteractionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_InterstitialInteractionDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_InterstitialInteraction _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_InterstitialInteractionDefaultTypeInternal
    _ClientSafeBrowsingReportRequest_InterstitialInteraction_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_PhishySiteInteraction::ClientSafeBrowsingReportRequest_PhishySiteInteraction(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.phishy_site_interaction_type_)*/ 0,
        /*decltype(_impl_.occurrence_count_)*/ 0, /*decltype(_impl_.first_interaction_timestamp_msec_)*/ int64_t { 0 },
        /*decltype(_impl_.last_interaction_timestamp_msec_)*/ int64_t { 0 } }
{
}
struct ClientSafeBrowsingReportRequest_PhishySiteInteractionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_PhishySiteInteractionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_PhishySiteInteractionDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_PhishySiteInteraction _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_PhishySiteInteractionDefaultTypeInternal
    _ClientSafeBrowsingReportRequest_PhishySiteInteraction_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_WarningShownInfo::ClientSafeBrowsingReportRequest_WarningShownInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.post_data_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.warning_type_)*/ 0 }
{
}
struct ClientSafeBrowsingReportRequest_WarningShownInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_WarningShownInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_WarningShownInfoDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_WarningShownInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_WarningShownInfoDefaultTypeInternal
    _ClientSafeBrowsingReportRequest_WarningShownInfo_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_PermissionPromptInfo::ClientSafeBrowsingReportRequest_PermissionPromptInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.origin_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.display_duration_sec_)*/ int64_t { 0 } }
{
}
struct ClientSafeBrowsingReportRequest_PermissionPromptInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_PermissionPromptInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_PermissionPromptInfoDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_PermissionPromptInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequest_PermissionPromptInfoDefaultTypeInternal
    _ClientSafeBrowsingReportRequest_PermissionPromptInfo_default_instance_;
PROTOBUF_CONSTEXPR
    ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo(
        ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.hash_realtime_threat_type_)*/ 0,
        /*decltype(_impl_.url_realtime_threat_type_)*/ 0 }
{
}
struct ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfoDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfoDefaultTypeInternal
        _ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_default_instance_;
PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequest::ClientSafeBrowsingReportRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.resources_)*/ {},
        /*decltype(_impl_.client_asn_)*/ {}, /*decltype(_impl_.dom_)*/ {}, /*decltype(_impl_.referrer_chain_)*/ {},
        /*decltype(_impl_.download_warning_actions_)*/ {}, /*decltype(_impl_.interstitial_interactions_)*/ {},
        /*decltype(_impl_.phishy_site_interactions_)*/ {}, /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.page_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.referrer_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.client_country_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.safety_net_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.locale_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.client_properties_)*/ nullptr,
        /*decltype(_impl_.download_item_info_)*/ nullptr, /*decltype(_impl_.population_)*/ nullptr,
        /*decltype(_impl_.hash_real_time_experiment_details_)*/ nullptr, /*decltype(_impl_.warning_shown_info_)*/ nullptr,
        /*decltype(_impl_.permission_prompt_info_)*/ nullptr, /*decltype(_impl_.url_real_time_and_hash_real_time_discrepancy_info_)*/ nullptr,
        /*decltype(_impl_.type_)*/ 0, /*decltype(_impl_.complete_)*/ false, /*decltype(_impl_.did_proceed_)*/ false, /*decltype(_impl_.repeat_visit_)*/ false,
        /*decltype(_impl_.show_download_in_folder_)*/ false, /*decltype(_impl_.download_verdict_)*/ 0, /*decltype(_impl_.url_request_destination_)*/ 0,
        /*decltype(_impl_.warning_shown_timestamp_msec_)*/ int64_t { 0 } }
{
}
struct ClientSafeBrowsingReportRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientSafeBrowsingReportRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientSafeBrowsingReportRequestDefaultTypeInternal()
    {
    }
    union {
        ClientSafeBrowsingReportRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientSafeBrowsingReportRequestDefaultTypeInternal
    _ClientSafeBrowsingReportRequest_default_instance_;
PROTOBUF_CONSTEXPR HTMLElement_Attribute::HTMLElement_Attribute(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct HTMLElement_AttributeDefaultTypeInternal {
    PROTOBUF_CONSTEXPR HTMLElement_AttributeDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~HTMLElement_AttributeDefaultTypeInternal()
    {
    }
    union {
        HTMLElement_Attribute _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HTMLElement_AttributeDefaultTypeInternal
    _HTMLElement_Attribute_default_instance_;
PROTOBUF_CONSTEXPR HTMLElement::HTMLElement(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.child_ids_)*/ {},
        /*decltype(_impl_.attribute_)*/ {}, /*decltype(_impl_.tag_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.inner_html_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.id_)*/ 0,
        /*decltype(_impl_.resource_id_)*/ 0 }
{
}
struct HTMLElementDefaultTypeInternal {
    PROTOBUF_CONSTEXPR HTMLElementDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~HTMLElementDefaultTypeInternal()
    {
    }
    union {
        HTMLElement _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HTMLElementDefaultTypeInternal _HTMLElement_default_instance_;
PROTOBUF_CONSTEXPR ExtensionWebStoreInstallRequest::ExtensionWebStoreInstallRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.referrer_chain_)*/ {},
        /*decltype(_impl_.referrer_chain_options_)*/ nullptr }
{
}
struct ExtensionWebStoreInstallRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionWebStoreInstallRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionWebStoreInstallRequestDefaultTypeInternal()
    {
    }
    union {
        ExtensionWebStoreInstallRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionWebStoreInstallRequestDefaultTypeInternal
    _ExtensionWebStoreInstallRequest_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.hash_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ExtensionTelemetryReportRequest_ExtensionInfo_FileInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_ExtensionInfo_FileInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_ExtensionInfo_FileInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionTelemetryReportRequest_ExtensionInfo_FileInfoDefaultTypeInternal
    _ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_ExtensionInfo::ExtensionTelemetryReportRequest_ExtensionInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.file_infos_)*/ {},
        /*decltype(_impl_.id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.manifest_json_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.install_timestamp_msec_)*/ int64_t { 0 }, /*decltype(_impl_.is_default_installed_)*/ false,
        /*decltype(_impl_.is_oem_installed_)*/ false, /*decltype(_impl_.is_from_store_)*/ false, /*decltype(_impl_.updates_from_store_)*/ false,
        /*decltype(_impl_.is_converted_from_user_script_)*/ false, /*decltype(_impl_.type_)*/ 0, /*decltype(_impl_.install_location_)*/ 0,
        /*decltype(_impl_.blocklist_state_)*/ 0, /*decltype(_impl_.disable_reasons_)*/ 0u, /*decltype(_impl_.telemetry_blocklist_state_)*/ 0,
        /*decltype(_impl_.installation_policy_)*/ 0 }
{
}
struct ExtensionTelemetryReportRequest_ExtensionInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_ExtensionInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_ExtensionInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_ExtensionInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionTelemetryReportRequest_ExtensionInfoDefaultTypeInternal
    _ExtensionTelemetryReportRequest_ExtensionInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.function_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.script_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.line_)*/ 0u,
        /*decltype(_impl_.column_)*/ 0u }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrameDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrameDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrameDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrameDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::ExtensionTelemetryReportRequest_SignalInfo_JSCallStack(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.frames_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_JSCallStackDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_JSCallStackDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_JSCallStackDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_JSCallStack _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionTelemetryReportRequest_SignalInfo_JSCallStackDefaultTypeInternal
    _ExtensionTelemetryReportRequest_SignalInfo_JSCallStack_default_instance_;
PROTOBUF_CONSTEXPR
    ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo(
        ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.hash_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.execution_count_)*/ 0u }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfoDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.scripts_)*/ {},
        /*decltype(_impl_.max_exceeded_script_count_)*/ 0u }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfoDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.contact_count_)*/ 0u,
        /*decltype(_impl_.connection_protocol_)*/ 0, /*decltype(_impl_.contacted_by_)*/ 0 }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfoDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.remote_host_)*/ {},
        /*decltype(_impl_.collected_from_new_interception_)*/ false }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfoDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_default_instance_;
PROTOBUF_CONSTEXPR
    ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo(
        ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.js_callstacks_)*/ {},
        /*decltype(_impl_.domain_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.path_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.store_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.secure_)*/ false,
        /*decltype(_impl_.is_session_)*/ false, /*decltype(_impl_.count_)*/ 0u }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfoDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.get_all_args_info_)*/ {},
        /*decltype(_impl_.max_exceeded_args_count_)*/ 0u }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfoDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.js_callstacks_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.store_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.count_)*/ 0u }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfoDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.get_args_info_)*/ {},
        /*decltype(_impl_.max_exceeded_args_count_)*/ 0u }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfoDefaultTypeInternal
    _ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.remote_host_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.count_)*/ 0u }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfoDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.is_account_syncing_)*/ false,
        /*decltype(_impl_.account_type_)*/ 0 }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountTypeDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountTypeDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountTypeDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountTypeDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.domains_matching_password_)*/ {},
        /*decltype(_impl_.reused_password_account_type_)*/ nullptr, /*decltype(_impl_.is_chrome_signin_password_)*/ false, /*decltype(_impl_.count_)*/ 0u }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfoDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.remote_host_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.count_)*/ 0u }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostDataDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostDataDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.remote_hosts_)*/ {}, /*decltype(_impl_.reused_password_infos_)*/ {}, /*decltype(_impl_.remote_hosts_data_)*/ {},
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfoDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.rules_)*/ {},
        /*decltype(_impl_.max_exceeded_rules_count_)*/ 0u }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfoDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.js_callstacks_)*/ {},
        /*decltype(_impl_.new_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.current_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.method_)*/ 0,
        /*decltype(_impl_.count_)*/ 0u }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetailsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetailsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetailsDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetailsDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.call_details_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfoDefaultTypeInternal
    _ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.request_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.redirect_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.type_)*/ 0,
        /*decltype(_impl_.count_)*/ 0u }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetailsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetailsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetailsDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetailsDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails_default_instance_;
PROTOBUF_CONSTEXPR
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo(
        ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.action_details_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfoDefaultTypeInternal
        _ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfo::ExtensionTelemetryReportRequest_SignalInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.tabs_execute_script_info_)*/ nullptr,
        /*decltype(_impl_.remote_host_contacted_info_)*/ nullptr, /*decltype(_impl_.cookies_get_all_info_)*/ nullptr,
        /*decltype(_impl_.cookies_get_info_)*/ nullptr, /*decltype(_impl_.potential_password_theft_info_)*/ nullptr,
        /*decltype(_impl_.declarative_net_request_info_)*/ nullptr, /*decltype(_impl_.tabs_api_info_)*/ nullptr,
        /*decltype(_impl_.declarative_net_request_action_info_)*/ nullptr }
{
}
struct ExtensionTelemetryReportRequest_SignalInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_SignalInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_SignalInfoDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_SignalInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionTelemetryReportRequest_SignalInfoDefaultTypeInternal
    _ExtensionTelemetryReportRequest_SignalInfo_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_Report::ExtensionTelemetryReportRequest_Report(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.signals_)*/ {},
        /*decltype(_impl_.extension_)*/ nullptr }
{
}
struct ExtensionTelemetryReportRequest_ReportDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest_ReportDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequest_ReportDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest_Report _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionTelemetryReportRequest_ReportDefaultTypeInternal
    _ExtensionTelemetryReportRequest_Report_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequest::ExtensionTelemetryReportRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.reports_)*/ {},
        /*decltype(_impl_.creation_timestamp_msec_)*/ int64_t { 0 }, /*decltype(_impl_.configuration_version_)*/ 0u,
        /*decltype(_impl_.developer_mode_enabled_)*/ false, /*decltype(_impl_.management_authority_trustworthiness_)*/ 0,
        /*decltype(_impl_.management_authority_)*/ 0 }
{
}
struct ExtensionTelemetryReportRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportRequestDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionTelemetryReportRequestDefaultTypeInternal
    _ExtensionTelemetryReportRequest_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportResponse_ExtensionParameters::ExtensionTelemetryReportResponse_ExtensionParameters(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.extension_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.signal_enable_mask_)*/ uint64_t { 0u } }
{
}
struct ExtensionTelemetryReportResponse_ExtensionParametersDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportResponse_ExtensionParametersDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportResponse_ExtensionParametersDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportResponse_ExtensionParameters _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionTelemetryReportResponse_ExtensionParametersDefaultTypeInternal
    _ExtensionTelemetryReportResponse_ExtensionParameters_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportResponse_Configuration::ExtensionTelemetryReportResponse_Configuration(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.extension_parameters_)*/ {},
        /*decltype(_impl_.configuration_version_)*/ 0u, /*decltype(_impl_.reporting_interval_seconds_)*/ 0u, /*decltype(_impl_.writes_per_interval_)*/ 0u }
{
}
struct ExtensionTelemetryReportResponse_ConfigurationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportResponse_ConfigurationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportResponse_ConfigurationDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportResponse_Configuration _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionTelemetryReportResponse_ConfigurationDefaultTypeInternal
    _ExtensionTelemetryReportResponse_Configuration_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::ExtensionTelemetryReportResponse_OffstoreExtensionVerdict(
    ::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.extension_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.verdict_type_)*/ 0 }
{
}
struct ExtensionTelemetryReportResponse_OffstoreExtensionVerdictDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportResponse_OffstoreExtensionVerdictDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportResponse_OffstoreExtensionVerdictDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportResponse_OffstoreExtensionVerdict _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionTelemetryReportResponse_OffstoreExtensionVerdictDefaultTypeInternal
    _ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_default_instance_;
PROTOBUF_CONSTEXPR ExtensionTelemetryReportResponse::ExtensionTelemetryReportResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.offstore_extension_verdicts_)*/ {},
        /*decltype(_impl_.configuration_)*/ nullptr }
{
}
struct ExtensionTelemetryReportResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ExtensionTelemetryReportResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ExtensionTelemetryReportResponseDefaultTypeInternal()
    {
    }
    union {
        ExtensionTelemetryReportResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ExtensionTelemetryReportResponseDefaultTypeInternal
    _ExtensionTelemetryReportResponse_default_instance_;
} // namespace safe_browsing
namespace safe_browsing {
bool ChromeUserPopulation_PageLoadToken_TokenSource_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ChromeUserPopulation_PageLoadToken_TokenSource_strings[2] = {};

static const char ChromeUserPopulation_PageLoadToken_TokenSource_names[] = "CLIENT_GENERATION"
                                                                           "SOURCE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ChromeUserPopulation_PageLoadToken_TokenSource_entries[] = {
    { { ChromeUserPopulation_PageLoadToken_TokenSource_names + 0, 17 }, 1 },
    { { ChromeUserPopulation_PageLoadToken_TokenSource_names + 17, 18 }, 0 },
};

static const int ChromeUserPopulation_PageLoadToken_TokenSource_entries_by_number[] = {
    1, // 0 -> SOURCE_UNSPECIFIED
    0, // 1 -> CLIENT_GENERATION
};

const std::string& ChromeUserPopulation_PageLoadToken_TokenSource_Name(ChromeUserPopulation_PageLoadToken_TokenSource value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ChromeUserPopulation_PageLoadToken_TokenSource_entries,
        ChromeUserPopulation_PageLoadToken_TokenSource_entries_by_number, 2, ChromeUserPopulation_PageLoadToken_TokenSource_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ChromeUserPopulation_PageLoadToken_TokenSource_entries, ChromeUserPopulation_PageLoadToken_TokenSource_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ChromeUserPopulation_PageLoadToken_TokenSource_strings[idx].get();
}
bool ChromeUserPopulation_PageLoadToken_TokenSource_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChromeUserPopulation_PageLoadToken_TokenSource* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ChromeUserPopulation_PageLoadToken_TokenSource_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<ChromeUserPopulation_PageLoadToken_TokenSource>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ChromeUserPopulation_PageLoadToken_TokenSource ChromeUserPopulation_PageLoadToken::SOURCE_UNSPECIFIED;
constexpr ChromeUserPopulation_PageLoadToken_TokenSource ChromeUserPopulation_PageLoadToken::CLIENT_GENERATION;
constexpr ChromeUserPopulation_PageLoadToken_TokenSource ChromeUserPopulation_PageLoadToken::TokenSource_MIN;
constexpr ChromeUserPopulation_PageLoadToken_TokenSource ChromeUserPopulation_PageLoadToken::TokenSource_MAX;
constexpr int ChromeUserPopulation_PageLoadToken::TokenSource_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ChromeUserPopulation_UserPopulation_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ChromeUserPopulation_UserPopulation_strings[4] = {};

static const char ChromeUserPopulation_UserPopulation_names[] = "ENHANCED_PROTECTION"
                                                                "EXTENDED_REPORTING"
                                                                "SAFE_BROWSING"
                                                                "UNKNOWN_USER_POPULATION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ChromeUserPopulation_UserPopulation_entries[] = {
    { { ChromeUserPopulation_UserPopulation_names + 0, 19 }, 3 },
    { { ChromeUserPopulation_UserPopulation_names + 19, 18 }, 2 },
    { { ChromeUserPopulation_UserPopulation_names + 37, 13 }, 1 },
    { { ChromeUserPopulation_UserPopulation_names + 50, 23 }, 0 },
};

static const int ChromeUserPopulation_UserPopulation_entries_by_number[] = {
    3, // 0 -> UNKNOWN_USER_POPULATION
    2, // 1 -> SAFE_BROWSING
    1, // 2 -> EXTENDED_REPORTING
    0, // 3 -> ENHANCED_PROTECTION
};

const std::string& ChromeUserPopulation_UserPopulation_Name(ChromeUserPopulation_UserPopulation value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ChromeUserPopulation_UserPopulation_entries, ChromeUserPopulation_UserPopulation_entries_by_number, 4, ChromeUserPopulation_UserPopulation_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ChromeUserPopulation_UserPopulation_entries, ChromeUserPopulation_UserPopulation_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ChromeUserPopulation_UserPopulation_strings[idx].get();
}
bool ChromeUserPopulation_UserPopulation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChromeUserPopulation_UserPopulation* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ChromeUserPopulation_UserPopulation_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<ChromeUserPopulation_UserPopulation>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ChromeUserPopulation_UserPopulation ChromeUserPopulation::UNKNOWN_USER_POPULATION;
constexpr ChromeUserPopulation_UserPopulation ChromeUserPopulation::SAFE_BROWSING;
constexpr ChromeUserPopulation_UserPopulation ChromeUserPopulation::EXTENDED_REPORTING;
constexpr ChromeUserPopulation_UserPopulation ChromeUserPopulation::ENHANCED_PROTECTION;
constexpr ChromeUserPopulation_UserPopulation ChromeUserPopulation::UserPopulation_MIN;
constexpr ChromeUserPopulation_UserPopulation ChromeUserPopulation::UserPopulation_MAX;
constexpr int ChromeUserPopulation::UserPopulation_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ChromeUserPopulation_ProfileManagementStatus_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ChromeUserPopulation_ProfileManagementStatus_strings[4] = {};

static const char ChromeUserPopulation_ProfileManagementStatus_names[] = "ENTERPRISE_MANAGED"
                                                                         "NOT_MANAGED"
                                                                         "UNAVAILABLE"
                                                                         "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ChromeUserPopulation_ProfileManagementStatus_entries[] = {
    { { ChromeUserPopulation_ProfileManagementStatus_names + 0, 18 }, 3 },
    { { ChromeUserPopulation_ProfileManagementStatus_names + 18, 11 }, 2 },
    { { ChromeUserPopulation_ProfileManagementStatus_names + 29, 11 }, 1 },
    { { ChromeUserPopulation_ProfileManagementStatus_names + 40, 7 }, 0 },
};

static const int ChromeUserPopulation_ProfileManagementStatus_entries_by_number[] = {
    3, // 0 -> UNKNOWN
    2, // 1 -> UNAVAILABLE
    1, // 2 -> NOT_MANAGED
    0, // 3 -> ENTERPRISE_MANAGED
};

const std::string& ChromeUserPopulation_ProfileManagementStatus_Name(ChromeUserPopulation_ProfileManagementStatus value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ChromeUserPopulation_ProfileManagementStatus_entries,
        ChromeUserPopulation_ProfileManagementStatus_entries_by_number, 4, ChromeUserPopulation_ProfileManagementStatus_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ChromeUserPopulation_ProfileManagementStatus_entries, ChromeUserPopulation_ProfileManagementStatus_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ChromeUserPopulation_ProfileManagementStatus_strings[idx].get();
}
bool ChromeUserPopulation_ProfileManagementStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChromeUserPopulation_ProfileManagementStatus* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ChromeUserPopulation_ProfileManagementStatus_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<ChromeUserPopulation_ProfileManagementStatus>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ChromeUserPopulation_ProfileManagementStatus ChromeUserPopulation::UNKNOWN;
constexpr ChromeUserPopulation_ProfileManagementStatus ChromeUserPopulation::UNAVAILABLE;
constexpr ChromeUserPopulation_ProfileManagementStatus ChromeUserPopulation::NOT_MANAGED;
constexpr ChromeUserPopulation_ProfileManagementStatus ChromeUserPopulation::ENTERPRISE_MANAGED;
constexpr ChromeUserPopulation_ProfileManagementStatus ChromeUserPopulation::ProfileManagementStatus_MIN;
constexpr ChromeUserPopulation_ProfileManagementStatus ChromeUserPopulation::ProfileManagementStatus_MAX;
constexpr int ChromeUserPopulation::ProfileManagementStatus_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientPhishingRequest_ReportType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientPhishingRequest_ReportType_strings[3] = {};

static const char ClientPhishingRequest_ReportType_names[] = "FULL_REPORT"
                                                             "REPORT_TYPE_UNSPECIFIED"
                                                             "SAMPLE_REPORT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientPhishingRequest_ReportType_entries[] = {
    { { ClientPhishingRequest_ReportType_names + 0, 11 }, 1 },
    { { ClientPhishingRequest_ReportType_names + 11, 23 }, 0 },
    { { ClientPhishingRequest_ReportType_names + 34, 13 }, 2 },
};

static const int ClientPhishingRequest_ReportType_entries_by_number[] = {
    1, // 0 -> REPORT_TYPE_UNSPECIFIED
    0, // 1 -> FULL_REPORT
    2, // 2 -> SAMPLE_REPORT
};

const std::string& ClientPhishingRequest_ReportType_Name(ClientPhishingRequest_ReportType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ClientPhishingRequest_ReportType_entries, ClientPhishingRequest_ReportType_entries_by_number, 3, ClientPhishingRequest_ReportType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ClientPhishingRequest_ReportType_entries, ClientPhishingRequest_ReportType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientPhishingRequest_ReportType_strings[idx].get();
}
bool ClientPhishingRequest_ReportType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientPhishingRequest_ReportType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientPhishingRequest_ReportType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ClientPhishingRequest_ReportType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientPhishingRequest_ReportType ClientPhishingRequest::REPORT_TYPE_UNSPECIFIED;
constexpr ClientPhishingRequest_ReportType ClientPhishingRequest::FULL_REPORT;
constexpr ClientPhishingRequest_ReportType ClientPhishingRequest::SAMPLE_REPORT;
constexpr ClientPhishingRequest_ReportType ClientPhishingRequest::ReportType_MIN;
constexpr ClientPhishingRequest_ReportType ClientPhishingRequest::ReportType_MAX;
constexpr int ClientPhishingRequest::ReportType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_strings[5] = {};

static const char LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_names[] = "GMAIL"
                                                                                                                  "GSUITE"
                                                                                                                  "NON_GAIA_ENTERPRISE"
                                                                                                                  "SAVED_PASSWORD"
                                                                                                                  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_entries[] = {
    { { LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_names + 0, 5 }, 2 },
    { { LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_names + 5, 6 }, 1 },
    { { LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_names + 11, 19 }, 3 },
    { { LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_names + 30, 14 }, 4 },
    { { LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_names + 44, 7 }, 0 },
};

static const int LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_entries_by_number[] = {
    4, // 0 -> UNKNOWN
    1, // 1 -> GSUITE
    0, // 2 -> GMAIL
    2, // 3 -> NON_GAIA_ENTERPRISE
    3, // 4 -> SAVED_PASSWORD
};

const std::string& LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_Name(
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_entries,
        LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_entries_by_number, 5,
        LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_entries,
        LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_strings[idx].get();
}
bool LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::UNKNOWN;
constexpr LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::GSUITE;
constexpr LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::GMAIL;
constexpr LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::NON_GAIA_ENTERPRISE;
constexpr LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::SAVED_PASSWORD;
constexpr LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::AccountType_MIN;
constexpr LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::AccountType_MAX;
constexpr int LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::AccountType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_strings[3] = {};

static const char LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_names[] = "GMAIL"
                                                                                            "GSUITE"
                                                                                            "NOT_SIGNED_IN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_entries[] = {
    { { LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_names + 0, 5 }, 1 },
    { { LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_names + 5, 6 }, 2 },
    { { LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_names + 11, 13 }, 0 },
};

static const int LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_entries_by_number[] = {
    2, // 0 -> NOT_SIGNED_IN
    0, // 1 -> GMAIL
    1, // 2 -> GSUITE
};

const std::string& LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_Name(LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_entries,
        LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_entries_by_number, 3,
        LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_entries,
        LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_strings[idx].get();
}
bool LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType LoginReputationClientRequest_PasswordReuseEvent::NOT_SIGNED_IN;
constexpr LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType LoginReputationClientRequest_PasswordReuseEvent::GMAIL;
constexpr LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType LoginReputationClientRequest_PasswordReuseEvent::GSUITE;
constexpr LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType LoginReputationClientRequest_PasswordReuseEvent::SyncAccountType_MIN;
constexpr LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType LoginReputationClientRequest_PasswordReuseEvent::SyncAccountType_MAX;
constexpr int LoginReputationClientRequest_PasswordReuseEvent::SyncAccountType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_strings[5] = {};

static const char LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_names[] = "ENTERPRISE_PASSWORD"
                                                                                               "OTHER_GAIA_PASSWORD"
                                                                                               "REUSED_PASSWORD_TYPE_UNKNOWN"
                                                                                               "SAVED_PASSWORD"
                                                                                               "SIGN_IN_PASSWORD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_entries[] = {
    { { LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_names + 0, 19 }, 4 },
    { { LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_names + 19, 19 }, 3 },
    { { LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_names + 38, 28 }, 0 },
    { { LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_names + 66, 14 }, 1 },
    { { LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_names + 80, 16 }, 2 },
};

static const int LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_entries_by_number[] = {
    2, // 0 -> REUSED_PASSWORD_TYPE_UNKNOWN
    3, // 1 -> SAVED_PASSWORD
    4, // 2 -> SIGN_IN_PASSWORD
    1, // 3 -> OTHER_GAIA_PASSWORD
    0, // 4 -> ENTERPRISE_PASSWORD
};

const std::string& LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_Name(
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_entries,
            LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_entries_by_number, 5,
            LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_entries,
        LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_strings[idx].get();
}
bool LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType LoginReputationClientRequest_PasswordReuseEvent::REUSED_PASSWORD_TYPE_UNKNOWN;
constexpr LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType LoginReputationClientRequest_PasswordReuseEvent::SAVED_PASSWORD;
constexpr LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType LoginReputationClientRequest_PasswordReuseEvent::SIGN_IN_PASSWORD;
constexpr LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType LoginReputationClientRequest_PasswordReuseEvent::OTHER_GAIA_PASSWORD;
constexpr LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType LoginReputationClientRequest_PasswordReuseEvent::ENTERPRISE_PASSWORD;
constexpr LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType LoginReputationClientRequest_PasswordReuseEvent::ReusedPasswordType_MIN;
constexpr LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType LoginReputationClientRequest_PasswordReuseEvent::ReusedPasswordType_MAX;
constexpr int LoginReputationClientRequest_PasswordReuseEvent::ReusedPasswordType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_strings[4] = {};

static const char LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_names[] = "ACTIVITY_REFERRER"
                                                                                             "KNOWN_APP_ID"
                                                                                             "REFERRING_APP_SOURCE_UNSPECIFIED"
                                                                                             "UNKNOWN_APP_ID";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_entries[] = {
    { { LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_names + 0, 17 }, 3 },
    { { LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_names + 17, 12 }, 1 },
    { { LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_names + 29, 32 }, 0 },
    { { LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_names + 61, 14 }, 2 },
};

static const int LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_entries_by_number[] = {
    2, // 0 -> REFERRING_APP_SOURCE_UNSPECIFIED
    1, // 1 -> KNOWN_APP_ID
    3, // 2 -> UNKNOWN_APP_ID
    0, // 3 -> ACTIVITY_REFERRER
};

const std::string& LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_Name(LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_entries,
        LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_entries_by_number, 4,
        LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_entries,
        LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_strings[idx].get();
}
bool LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource LoginReputationClientRequest_ReferringAppInfo::REFERRING_APP_SOURCE_UNSPECIFIED;
constexpr LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource LoginReputationClientRequest_ReferringAppInfo::KNOWN_APP_ID;
constexpr LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource LoginReputationClientRequest_ReferringAppInfo::UNKNOWN_APP_ID;
constexpr LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource LoginReputationClientRequest_ReferringAppInfo::ACTIVITY_REFERRER;
constexpr LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource LoginReputationClientRequest_ReferringAppInfo::ReferringAppSource_MIN;
constexpr LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource LoginReputationClientRequest_ReferringAppInfo::ReferringAppSource_MAX;
constexpr int LoginReputationClientRequest_ReferringAppInfo::ReferringAppSource_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LoginReputationClientRequest_TriggerType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginReputationClientRequest_TriggerType_strings[3] = {};

static const char LoginReputationClientRequest_TriggerType_names[] = "PASSWORD_REUSE_EVENT"
                                                                     "TRIGGER_TYPE_UNSPECIFIED"
                                                                     "UNFAMILIAR_LOGIN_PAGE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginReputationClientRequest_TriggerType_entries[] = {
    { { LoginReputationClientRequest_TriggerType_names + 0, 20 }, 2 },
    { { LoginReputationClientRequest_TriggerType_names + 20, 24 }, 0 },
    { { LoginReputationClientRequest_TriggerType_names + 44, 21 }, 1 },
};

static const int LoginReputationClientRequest_TriggerType_entries_by_number[] = {
    1, // 0 -> TRIGGER_TYPE_UNSPECIFIED
    2, // 1 -> UNFAMILIAR_LOGIN_PAGE
    0, // 2 -> PASSWORD_REUSE_EVENT
};

const std::string& LoginReputationClientRequest_TriggerType_Name(LoginReputationClientRequest_TriggerType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(LoginReputationClientRequest_TriggerType_entries,
        LoginReputationClientRequest_TriggerType_entries_by_number, 3, LoginReputationClientRequest_TriggerType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        LoginReputationClientRequest_TriggerType_entries, LoginReputationClientRequest_TriggerType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : LoginReputationClientRequest_TriggerType_strings[idx].get();
}
bool LoginReputationClientRequest_TriggerType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginReputationClientRequest_TriggerType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(LoginReputationClientRequest_TriggerType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<LoginReputationClientRequest_TriggerType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LoginReputationClientRequest_TriggerType LoginReputationClientRequest::TRIGGER_TYPE_UNSPECIFIED;
constexpr LoginReputationClientRequest_TriggerType LoginReputationClientRequest::UNFAMILIAR_LOGIN_PAGE;
constexpr LoginReputationClientRequest_TriggerType LoginReputationClientRequest::PASSWORD_REUSE_EVENT;
constexpr LoginReputationClientRequest_TriggerType LoginReputationClientRequest::TriggerType_MIN;
constexpr LoginReputationClientRequest_TriggerType LoginReputationClientRequest::TriggerType_MAX;
constexpr int LoginReputationClientRequest::TriggerType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LoginReputationClientRequest_ReportType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginReputationClientRequest_ReportType_strings[3] = {};

static const char LoginReputationClientRequest_ReportType_names[] = "FULL_REPORT"
                                                                    "SAMPLE_REPORT"
                                                                    "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginReputationClientRequest_ReportType_entries[] = {
    { { LoginReputationClientRequest_ReportType_names + 0, 11 }, 1 },
    { { LoginReputationClientRequest_ReportType_names + 11, 13 }, 2 },
    { { LoginReputationClientRequest_ReportType_names + 24, 7 }, 0 },
};

static const int LoginReputationClientRequest_ReportType_entries_by_number[] = {
    2, // 0 -> UNKNOWN
    0, // 1 -> FULL_REPORT
    1, // 2 -> SAMPLE_REPORT
};

const std::string& LoginReputationClientRequest_ReportType_Name(LoginReputationClientRequest_ReportType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(LoginReputationClientRequest_ReportType_entries,
        LoginReputationClientRequest_ReportType_entries_by_number, 3, LoginReputationClientRequest_ReportType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        LoginReputationClientRequest_ReportType_entries, LoginReputationClientRequest_ReportType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : LoginReputationClientRequest_ReportType_strings[idx].get();
}
bool LoginReputationClientRequest_ReportType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginReputationClientRequest_ReportType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(LoginReputationClientRequest_ReportType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<LoginReputationClientRequest_ReportType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LoginReputationClientRequest_ReportType LoginReputationClientRequest::UNKNOWN;
constexpr LoginReputationClientRequest_ReportType LoginReputationClientRequest::FULL_REPORT;
constexpr LoginReputationClientRequest_ReportType LoginReputationClientRequest::SAMPLE_REPORT;
constexpr LoginReputationClientRequest_ReportType LoginReputationClientRequest::ReportType_MIN;
constexpr LoginReputationClientRequest_ReportType LoginReputationClientRequest::ReportType_MAX;
constexpr int LoginReputationClientRequest::ReportType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool LoginReputationClientResponse_VerdictType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> LoginReputationClientResponse_VerdictType_strings[4] = {};

static const char LoginReputationClientResponse_VerdictType_names[] = "LOW_REPUTATION"
                                                                      "PHISHING"
                                                                      "SAFE"
                                                                      "VERDICT_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry LoginReputationClientResponse_VerdictType_entries[] = {
    { { LoginReputationClientResponse_VerdictType_names + 0, 14 }, 2 },
    { { LoginReputationClientResponse_VerdictType_names + 14, 8 }, 3 },
    { { LoginReputationClientResponse_VerdictType_names + 22, 4 }, 1 },
    { { LoginReputationClientResponse_VerdictType_names + 26, 24 }, 0 },
};

static const int LoginReputationClientResponse_VerdictType_entries_by_number[] = {
    3, // 0 -> VERDICT_TYPE_UNSPECIFIED
    2, // 1 -> SAFE
    0, // 2 -> LOW_REPUTATION
    1, // 3 -> PHISHING
};

const std::string& LoginReputationClientResponse_VerdictType_Name(LoginReputationClientResponse_VerdictType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(LoginReputationClientResponse_VerdictType_entries,
        LoginReputationClientResponse_VerdictType_entries_by_number, 4, LoginReputationClientResponse_VerdictType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        LoginReputationClientResponse_VerdictType_entries, LoginReputationClientResponse_VerdictType_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : LoginReputationClientResponse_VerdictType_strings[idx].get();
}
bool LoginReputationClientResponse_VerdictType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginReputationClientResponse_VerdictType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(LoginReputationClientResponse_VerdictType_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<LoginReputationClientResponse_VerdictType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr LoginReputationClientResponse_VerdictType LoginReputationClientResponse::VERDICT_TYPE_UNSPECIFIED;
constexpr LoginReputationClientResponse_VerdictType LoginReputationClientResponse::SAFE;
constexpr LoginReputationClientResponse_VerdictType LoginReputationClientResponse::LOW_REPUTATION;
constexpr LoginReputationClientResponse_VerdictType LoginReputationClientResponse::PHISHING;
constexpr LoginReputationClientResponse_VerdictType LoginReputationClientResponse::VerdictType_MIN;
constexpr LoginReputationClientResponse_VerdictType LoginReputationClientResponse::VerdictType_MAX;
constexpr int LoginReputationClientResponse::VerdictType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientDownloadRequest_ArchiveSummary_Status_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientDownloadRequest_ArchiveSummary_Status_strings[5] = {};

static const char ClientDownloadRequest_ArchiveSummary_Status_names[] = "DISK_ERROR"
                                                                        "PARSER_TIMED_OUT"
                                                                        "TOO_LARGE"
                                                                        "UNKNOWN"
                                                                        "VALID";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientDownloadRequest_ArchiveSummary_Status_entries[] = {
    { { ClientDownloadRequest_ArchiveSummary_Status_names + 0, 10 }, 4 },
    { { ClientDownloadRequest_ArchiveSummary_Status_names + 10, 16 }, 2 },
    { { ClientDownloadRequest_ArchiveSummary_Status_names + 26, 9 }, 3 },
    { { ClientDownloadRequest_ArchiveSummary_Status_names + 35, 7 }, 0 },
    { { ClientDownloadRequest_ArchiveSummary_Status_names + 42, 5 }, 1 },
};

static const int ClientDownloadRequest_ArchiveSummary_Status_entries_by_number[] = {
    3, // 0 -> UNKNOWN
    4, // 1 -> VALID
    1, // 2 -> PARSER_TIMED_OUT
    2, // 3 -> TOO_LARGE
    0, // 4 -> DISK_ERROR
};

const std::string& ClientDownloadRequest_ArchiveSummary_Status_Name(ClientDownloadRequest_ArchiveSummary_Status value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientDownloadRequest_ArchiveSummary_Status_entries,
        ClientDownloadRequest_ArchiveSummary_Status_entries_by_number, 5, ClientDownloadRequest_ArchiveSummary_Status_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ClientDownloadRequest_ArchiveSummary_Status_entries, ClientDownloadRequest_ArchiveSummary_Status_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientDownloadRequest_ArchiveSummary_Status_strings[idx].get();
}
bool ClientDownloadRequest_ArchiveSummary_Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientDownloadRequest_ArchiveSummary_Status* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientDownloadRequest_ArchiveSummary_Status_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<ClientDownloadRequest_ArchiveSummary_Status>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientDownloadRequest_ArchiveSummary_Status ClientDownloadRequest_ArchiveSummary::UNKNOWN;
constexpr ClientDownloadRequest_ArchiveSummary_Status ClientDownloadRequest_ArchiveSummary::VALID;
constexpr ClientDownloadRequest_ArchiveSummary_Status ClientDownloadRequest_ArchiveSummary::PARSER_TIMED_OUT;
constexpr ClientDownloadRequest_ArchiveSummary_Status ClientDownloadRequest_ArchiveSummary::TOO_LARGE;
constexpr ClientDownloadRequest_ArchiveSummary_Status ClientDownloadRequest_ArchiveSummary::DISK_ERROR;
constexpr ClientDownloadRequest_ArchiveSummary_Status ClientDownloadRequest_ArchiveSummary::Status_MIN;
constexpr ClientDownloadRequest_ArchiveSummary_Status ClientDownloadRequest_ArchiveSummary::Status_MAX;
constexpr int ClientDownloadRequest_ArchiveSummary::Status_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientDownloadRequest_ResourceType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientDownloadRequest_ResourceType_strings[6] = {};

static const char ClientDownloadRequest_ResourceType_names[] = "DOWNLOAD_REDIRECT"
                                                               "DOWNLOAD_URL"
                                                               "PPAPI_DOCUMENT"
                                                               "PPAPI_PLUGIN"
                                                               "TAB_REDIRECT"
                                                               "TAB_URL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientDownloadRequest_ResourceType_entries[] = {
    { { ClientDownloadRequest_ResourceType_names + 0, 17 }, 1 },
    { { ClientDownloadRequest_ResourceType_names + 17, 12 }, 0 },
    { { ClientDownloadRequest_ResourceType_names + 29, 14 }, 4 },
    { { ClientDownloadRequest_ResourceType_names + 43, 12 }, 5 },
    { { ClientDownloadRequest_ResourceType_names + 55, 12 }, 3 },
    { { ClientDownloadRequest_ResourceType_names + 67, 7 }, 2 },
};

static const int ClientDownloadRequest_ResourceType_entries_by_number[] = {
    1, // 0 -> DOWNLOAD_URL
    0, // 1 -> DOWNLOAD_REDIRECT
    5, // 2 -> TAB_URL
    4, // 3 -> TAB_REDIRECT
    2, // 4 -> PPAPI_DOCUMENT
    3, // 5 -> PPAPI_PLUGIN
};

const std::string& ClientDownloadRequest_ResourceType_Name(ClientDownloadRequest_ResourceType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ClientDownloadRequest_ResourceType_entries, ClientDownloadRequest_ResourceType_entries_by_number, 6, ClientDownloadRequest_ResourceType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ClientDownloadRequest_ResourceType_entries, ClientDownloadRequest_ResourceType_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientDownloadRequest_ResourceType_strings[idx].get();
}
bool ClientDownloadRequest_ResourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientDownloadRequest_ResourceType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientDownloadRequest_ResourceType_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<ClientDownloadRequest_ResourceType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::DOWNLOAD_URL;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::DOWNLOAD_REDIRECT;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::TAB_URL;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::TAB_REDIRECT;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::PPAPI_DOCUMENT;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::PPAPI_PLUGIN;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::ResourceType_MIN;
constexpr ClientDownloadRequest_ResourceType ClientDownloadRequest::ResourceType_MAX;
constexpr int ClientDownloadRequest::ResourceType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientDownloadRequest_DownloadType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientDownloadRequest_DownloadType_strings[18] = {};

static const char ClientDownloadRequest_DownloadType_names[] = "ANDROID_APK"
                                                               "ARCHIVE"
                                                               "CHROME_EXTENSION"
                                                               "DOCUMENT"
                                                               "INVALID_RAR"
                                                               "INVALID_SEVEN_ZIP"
                                                               "INVALID_ZIP"
                                                               "MAC_ARCHIVE_FAILED_PARSING"
                                                               "MAC_EXECUTABLE"
                                                               "PPAPI_SAVE_REQUEST"
                                                               "RAR_COMPRESSED_ARCHIVE"
                                                               "RAR_COMPRESSED_EXECUTABLE"
                                                               "SAMPLED_UNSUPPORTED_FILE"
                                                               "SEVEN_ZIP_COMPRESSED_ARCHIVE"
                                                               "SEVEN_ZIP_COMPRESSED_EXECUTABLE"
                                                               "WIN_EXECUTABLE"
                                                               "ZIPPED_ARCHIVE"
                                                               "ZIPPED_EXECUTABLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientDownloadRequest_DownloadType_entries[] = {
    { { ClientDownloadRequest_DownloadType_names + 0, 11 }, 2 },
    { { ClientDownloadRequest_DownloadType_names + 11, 7 }, 6 },
    { { ClientDownloadRequest_DownloadType_names + 18, 16 }, 1 },
    { { ClientDownloadRequest_DownloadType_names + 34, 8 }, 14 },
    { { ClientDownloadRequest_DownloadType_names + 42, 11 }, 13 },
    { { ClientDownloadRequest_DownloadType_names + 53, 17 }, 17 },
    { { ClientDownloadRequest_DownloadType_names + 70, 11 }, 7 },
    { { ClientDownloadRequest_DownloadType_names + 81, 26 }, 8 },
    { { ClientDownloadRequest_DownloadType_names + 107, 14 }, 4 },
    { { ClientDownloadRequest_DownloadType_names + 121, 18 }, 9 },
    { { ClientDownloadRequest_DownloadType_names + 139, 22 }, 12 },
    { { ClientDownloadRequest_DownloadType_names + 161, 25 }, 11 },
    { { ClientDownloadRequest_DownloadType_names + 186, 24 }, 10 },
    { { ClientDownloadRequest_DownloadType_names + 210, 28 }, 16 },
    { { ClientDownloadRequest_DownloadType_names + 238, 31 }, 15 },
    { { ClientDownloadRequest_DownloadType_names + 269, 14 }, 0 },
    { { ClientDownloadRequest_DownloadType_names + 283, 14 }, 5 },
    { { ClientDownloadRequest_DownloadType_names + 297, 17 }, 3 },
};

static const int ClientDownloadRequest_DownloadType_entries_by_number[] = {
    15, // 0 -> WIN_EXECUTABLE
    2, // 1 -> CHROME_EXTENSION
    0, // 2 -> ANDROID_APK
    17, // 3 -> ZIPPED_EXECUTABLE
    8, // 4 -> MAC_EXECUTABLE
    16, // 5 -> ZIPPED_ARCHIVE
    1, // 6 -> ARCHIVE
    6, // 7 -> INVALID_ZIP
    7, // 8 -> MAC_ARCHIVE_FAILED_PARSING
    9, // 9 -> PPAPI_SAVE_REQUEST
    12, // 10 -> SAMPLED_UNSUPPORTED_FILE
    11, // 11 -> RAR_COMPRESSED_EXECUTABLE
    10, // 12 -> RAR_COMPRESSED_ARCHIVE
    4, // 13 -> INVALID_RAR
    3, // 14 -> DOCUMENT
    14, // 15 -> SEVEN_ZIP_COMPRESSED_EXECUTABLE
    13, // 16 -> SEVEN_ZIP_COMPRESSED_ARCHIVE
    5, // 17 -> INVALID_SEVEN_ZIP
};

const std::string& ClientDownloadRequest_DownloadType_Name(ClientDownloadRequest_DownloadType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ClientDownloadRequest_DownloadType_entries, ClientDownloadRequest_DownloadType_entries_by_number, 18, ClientDownloadRequest_DownloadType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ClientDownloadRequest_DownloadType_entries, ClientDownloadRequest_DownloadType_entries_by_number, 18, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientDownloadRequest_DownloadType_strings[idx].get();
}
bool ClientDownloadRequest_DownloadType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientDownloadRequest_DownloadType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientDownloadRequest_DownloadType_entries, 18, name, &int_value);
    if (success) {
        *value = static_cast<ClientDownloadRequest_DownloadType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::WIN_EXECUTABLE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::CHROME_EXTENSION;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::ANDROID_APK;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::ZIPPED_EXECUTABLE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::MAC_EXECUTABLE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::ZIPPED_ARCHIVE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::ARCHIVE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::INVALID_ZIP;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::MAC_ARCHIVE_FAILED_PARSING;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::PPAPI_SAVE_REQUEST;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::SAMPLED_UNSUPPORTED_FILE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::RAR_COMPRESSED_EXECUTABLE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::RAR_COMPRESSED_ARCHIVE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::INVALID_RAR;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::DOCUMENT;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::SEVEN_ZIP_COMPRESSED_EXECUTABLE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::SEVEN_ZIP_COMPRESSED_ARCHIVE;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::INVALID_SEVEN_ZIP;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::DownloadType_MIN;
constexpr ClientDownloadRequest_DownloadType ClientDownloadRequest::DownloadType_MAX;
constexpr int ClientDownloadRequest::DownloadType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ReferrerChainEntry_URLType_IsValid(int value)
{
    switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReferrerChainEntry_URLType_strings[7] = {};

static const char ReferrerChainEntry_URLType_names[] = "CLIENT_REDIRECT"
                                                       "DEPRECATED_SERVER_REDIRECT"
                                                       "EVENT_URL"
                                                       "LANDING_PAGE"
                                                       "LANDING_REFERRER"
                                                       "RECENT_NAVIGATION"
                                                       "REFERRER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReferrerChainEntry_URLType_entries[] = {
    { { ReferrerChainEntry_URLType_names + 0, 15 }, 4 },
    { { ReferrerChainEntry_URLType_names + 15, 26 }, 5 },
    { { ReferrerChainEntry_URLType_names + 41, 9 }, 1 },
    { { ReferrerChainEntry_URLType_names + 50, 12 }, 2 },
    { { ReferrerChainEntry_URLType_names + 62, 16 }, 3 },
    { { ReferrerChainEntry_URLType_names + 78, 17 }, 6 },
    { { ReferrerChainEntry_URLType_names + 95, 8 }, 7 },
};

static const int ReferrerChainEntry_URLType_entries_by_number[] = {
    2, // 1 -> EVENT_URL
    3, // 2 -> LANDING_PAGE
    4, // 3 -> LANDING_REFERRER
    0, // 4 -> CLIENT_REDIRECT
    1, // 5 -> DEPRECATED_SERVER_REDIRECT
    5, // 6 -> RECENT_NAVIGATION
    6, // 7 -> REFERRER
};

const std::string& ReferrerChainEntry_URLType_Name(ReferrerChainEntry_URLType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ReferrerChainEntry_URLType_entries, ReferrerChainEntry_URLType_entries_by_number, 7, ReferrerChainEntry_URLType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ReferrerChainEntry_URLType_entries, ReferrerChainEntry_URLType_entries_by_number, 7, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ReferrerChainEntry_URLType_strings[idx].get();
}
bool ReferrerChainEntry_URLType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReferrerChainEntry_URLType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ReferrerChainEntry_URLType_entries, 7, name, &int_value);
    if (success) {
        *value = static_cast<ReferrerChainEntry_URLType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::EVENT_URL;
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::LANDING_PAGE;
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::LANDING_REFERRER;
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::CLIENT_REDIRECT;
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::DEPRECATED_SERVER_REDIRECT;
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::RECENT_NAVIGATION;
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::REFERRER;
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::URLType_MIN;
constexpr ReferrerChainEntry_URLType ReferrerChainEntry::URLType_MAX;
constexpr int ReferrerChainEntry::URLType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ReferrerChainEntry_NavigationInitiation_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ReferrerChainEntry_NavigationInitiation_strings[6] = {};

static const char ReferrerChainEntry_NavigationInitiation_names[] = "BROWSER_INITIATED"
                                                                    "COPY_PASTE_USER_INITIATED"
                                                                    "NOTIFICATION_INITIATED"
                                                                    "RENDERER_INITIATED_WITHOUT_USER_GESTURE"
                                                                    "RENDERER_INITIATED_WITH_USER_GESTURE"
                                                                    "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ReferrerChainEntry_NavigationInitiation_entries[] = {
    { { ReferrerChainEntry_NavigationInitiation_names + 0, 17 }, 1 },
    { { ReferrerChainEntry_NavigationInitiation_names + 17, 25 }, 4 },
    { { ReferrerChainEntry_NavigationInitiation_names + 42, 22 }, 5 },
    { { ReferrerChainEntry_NavigationInitiation_names + 64, 39 }, 2 },
    { { ReferrerChainEntry_NavigationInitiation_names + 103, 36 }, 3 },
    { { ReferrerChainEntry_NavigationInitiation_names + 139, 9 }, 0 },
};

static const int ReferrerChainEntry_NavigationInitiation_entries_by_number[] = {
    5, // 0 -> UNDEFINED
    0, // 1 -> BROWSER_INITIATED
    3, // 2 -> RENDERER_INITIATED_WITHOUT_USER_GESTURE
    4, // 3 -> RENDERER_INITIATED_WITH_USER_GESTURE
    1, // 4 -> COPY_PASTE_USER_INITIATED
    2, // 5 -> NOTIFICATION_INITIATED
};

const std::string& ReferrerChainEntry_NavigationInitiation_Name(ReferrerChainEntry_NavigationInitiation value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ReferrerChainEntry_NavigationInitiation_entries,
        ReferrerChainEntry_NavigationInitiation_entries_by_number, 6, ReferrerChainEntry_NavigationInitiation_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ReferrerChainEntry_NavigationInitiation_entries, ReferrerChainEntry_NavigationInitiation_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ReferrerChainEntry_NavigationInitiation_strings[idx].get();
}
bool ReferrerChainEntry_NavigationInitiation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReferrerChainEntry_NavigationInitiation* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ReferrerChainEntry_NavigationInitiation_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<ReferrerChainEntry_NavigationInitiation>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ReferrerChainEntry_NavigationInitiation ReferrerChainEntry::UNDEFINED;
constexpr ReferrerChainEntry_NavigationInitiation ReferrerChainEntry::BROWSER_INITIATED;
constexpr ReferrerChainEntry_NavigationInitiation ReferrerChainEntry::RENDERER_INITIATED_WITHOUT_USER_GESTURE;
constexpr ReferrerChainEntry_NavigationInitiation ReferrerChainEntry::RENDERER_INITIATED_WITH_USER_GESTURE;
constexpr ReferrerChainEntry_NavigationInitiation ReferrerChainEntry::COPY_PASTE_USER_INITIATED;
constexpr ReferrerChainEntry_NavigationInitiation ReferrerChainEntry::NOTIFICATION_INITIATED;
constexpr ReferrerChainEntry_NavigationInitiation ReferrerChainEntry::NavigationInitiation_MIN;
constexpr ReferrerChainEntry_NavigationInitiation ReferrerChainEntry::NavigationInitiation_MAX;
constexpr int ReferrerChainEntry::NavigationInitiation_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_strings[3] = {};

static const char ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_names[] = "COOKIE_THEFT"
                                                                                       "SUSPICIOUS_ARCHIVE"
                                                                                       "VERDICT_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_entries[] = {
    { { ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_names + 0, 12 }, 1 },
    { { ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_names + 12, 18 }, 2 },
    { { ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_names + 30, 24 }, 0 },
};

static const int ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_entries_by_number[] = {
    2, // 0 -> VERDICT_TYPE_UNSPECIFIED
    0, // 1 -> COOKIE_THEFT
    1, // 2 -> SUSPICIOUS_ARCHIVE
};

const std::string& ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_Name(ClientDownloadResponse_TailoredVerdict_TailoredVerdictType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_entries,
        ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_entries_by_number, 3, ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_entries,
        ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_strings[idx].get();
}
bool ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientDownloadResponse_TailoredVerdict_TailoredVerdictType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ClientDownloadResponse_TailoredVerdict_TailoredVerdictType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientDownloadResponse_TailoredVerdict_TailoredVerdictType ClientDownloadResponse_TailoredVerdict::VERDICT_TYPE_UNSPECIFIED;
constexpr ClientDownloadResponse_TailoredVerdict_TailoredVerdictType ClientDownloadResponse_TailoredVerdict::COOKIE_THEFT;
constexpr ClientDownloadResponse_TailoredVerdict_TailoredVerdictType ClientDownloadResponse_TailoredVerdict::SUSPICIOUS_ARCHIVE;
constexpr ClientDownloadResponse_TailoredVerdict_TailoredVerdictType ClientDownloadResponse_TailoredVerdict::TailoredVerdictType_MIN;
constexpr ClientDownloadResponse_TailoredVerdict_TailoredVerdictType ClientDownloadResponse_TailoredVerdict::TailoredVerdictType_MAX;
constexpr int ClientDownloadResponse_TailoredVerdict::TailoredVerdictType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_strings[2]
    = {};

static const char ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_names[] = "ACCOUNT_INFO_STRING"
                                                                                                 "ADJUSTMENT_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_entries[] = {
    { { ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_names + 0, 19 }, 1 },
    { { ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_names + 19, 22 }, 0 },
};

static const int ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_entries_by_number[] = {
    1, // 0 -> ADJUSTMENT_UNSPECIFIED
    0, // 1 -> ACCOUNT_INFO_STRING
};

const std::string& ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_Name(
    ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_entries,
            ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_entries_by_number, 2,
            ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_entries,
        ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_strings[idx].get();
}
bool ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment ClientDownloadResponse_TailoredVerdict::ADJUSTMENT_UNSPECIFIED;
constexpr ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment ClientDownloadResponse_TailoredVerdict::ACCOUNT_INFO_STRING;
constexpr ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment ClientDownloadResponse_TailoredVerdict::ExperimentalWarningAdjustment_MIN;
constexpr ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment ClientDownloadResponse_TailoredVerdict::ExperimentalWarningAdjustment_MAX;
constexpr int ClientDownloadResponse_TailoredVerdict::ExperimentalWarningAdjustment_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientDownloadResponse_Verdict_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 8:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientDownloadResponse_Verdict_strings[7] = {};

static const char ClientDownloadResponse_Verdict_names[] = "DANGEROUS"
                                                           "DANGEROUS_ACCOUNT_COMPROMISE"
                                                           "DANGEROUS_HOST"
                                                           "POTENTIALLY_UNWANTED"
                                                           "SAFE"
                                                           "UNCOMMON"
                                                           "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientDownloadResponse_Verdict_entries[] = {
    { { ClientDownloadResponse_Verdict_names + 0, 9 }, 1 },
    { { ClientDownloadResponse_Verdict_names + 9, 28 }, 8 },
    { { ClientDownloadResponse_Verdict_names + 37, 14 }, 4 },
    { { ClientDownloadResponse_Verdict_names + 51, 20 }, 3 },
    { { ClientDownloadResponse_Verdict_names + 71, 4 }, 0 },
    { { ClientDownloadResponse_Verdict_names + 75, 8 }, 2 },
    { { ClientDownloadResponse_Verdict_names + 83, 7 }, 5 },
};

static const int ClientDownloadResponse_Verdict_entries_by_number[] = {
    4, // 0 -> SAFE
    0, // 1 -> DANGEROUS
    5, // 2 -> UNCOMMON
    3, // 3 -> POTENTIALLY_UNWANTED
    2, // 4 -> DANGEROUS_HOST
    6, // 5 -> UNKNOWN
    1, // 8 -> DANGEROUS_ACCOUNT_COMPROMISE
};

const std::string& ClientDownloadResponse_Verdict_Name(ClientDownloadResponse_Verdict value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ClientDownloadResponse_Verdict_entries, ClientDownloadResponse_Verdict_entries_by_number, 7, ClientDownloadResponse_Verdict_strings);
    (void)dummy;
    int idx
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientDownloadResponse_Verdict_entries, ClientDownloadResponse_Verdict_entries_by_number, 7, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientDownloadResponse_Verdict_strings[idx].get();
}
bool ClientDownloadResponse_Verdict_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientDownloadResponse_Verdict* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientDownloadResponse_Verdict_entries, 7, name, &int_value);
    if (success) {
        *value = static_cast<ClientDownloadResponse_Verdict>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::SAFE;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::DANGEROUS;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::UNCOMMON;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::POTENTIALLY_UNWANTED;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::DANGEROUS_HOST;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::UNKNOWN;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::DANGEROUS_ACCOUNT_COMPROMISE;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::Verdict_MIN;
constexpr ClientDownloadResponse_Verdict ClientDownloadResponse::Verdict_MAX;
constexpr int ClientDownloadResponse::Verdict_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientDownloadReport_Reason_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientDownloadReport_Reason_strings[3] = {};

static const char ClientDownloadReport_Reason_names[] = "APPEAL"
                                                        "FALSE_POSITIVE"
                                                        "SHARE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientDownloadReport_Reason_entries[] = {
    { { ClientDownloadReport_Reason_names + 0, 6 }, 2 },
    { { ClientDownloadReport_Reason_names + 6, 14 }, 1 },
    { { ClientDownloadReport_Reason_names + 20, 5 }, 0 },
};

static const int ClientDownloadReport_Reason_entries_by_number[] = {
    2, // 0 -> SHARE
    1, // 1 -> FALSE_POSITIVE
    0, // 2 -> APPEAL
};

const std::string& ClientDownloadReport_Reason_Name(ClientDownloadReport_Reason value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ClientDownloadReport_Reason_entries, ClientDownloadReport_Reason_entries_by_number, 3, ClientDownloadReport_Reason_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientDownloadReport_Reason_entries, ClientDownloadReport_Reason_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientDownloadReport_Reason_strings[idx].get();
}
bool ClientDownloadReport_Reason_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientDownloadReport_Reason* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientDownloadReport_Reason_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ClientDownloadReport_Reason>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientDownloadReport_Reason ClientDownloadReport::SHARE;
constexpr ClientDownloadReport_Reason ClientDownloadReport::FALSE_POSITIVE;
constexpr ClientDownloadReport_Reason ClientDownloadReport::APPEAL;
constexpr ClientDownloadReport_Reason ClientDownloadReport::Reason_MIN;
constexpr ClientDownloadReport_Reason ClientDownloadReport::Reason_MAX;
constexpr int ClientDownloadReport::Reason_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientUploadResponse_UploadStatus_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientUploadResponse_UploadStatus_strings[2] = {};

static const char ClientUploadResponse_UploadStatus_names[] = "SUCCESS"
                                                              "UPLOAD_FAILURE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientUploadResponse_UploadStatus_entries[] = {
    { { ClientUploadResponse_UploadStatus_names + 0, 7 }, 0 },
    { { ClientUploadResponse_UploadStatus_names + 7, 14 }, 1 },
};

static const int ClientUploadResponse_UploadStatus_entries_by_number[] = {
    0, // 0 -> SUCCESS
    1, // 1 -> UPLOAD_FAILURE
};

const std::string& ClientUploadResponse_UploadStatus_Name(ClientUploadResponse_UploadStatus value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ClientUploadResponse_UploadStatus_entries, ClientUploadResponse_UploadStatus_entries_by_number, 2, ClientUploadResponse_UploadStatus_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ClientUploadResponse_UploadStatus_entries, ClientUploadResponse_UploadStatus_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientUploadResponse_UploadStatus_strings[idx].get();
}
bool ClientUploadResponse_UploadStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientUploadResponse_UploadStatus* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientUploadResponse_UploadStatus_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<ClientUploadResponse_UploadStatus>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientUploadResponse_UploadStatus ClientUploadResponse::SUCCESS;
constexpr ClientUploadResponse_UploadStatus ClientUploadResponse::UPLOAD_FAILURE;
constexpr ClientUploadResponse_UploadStatus ClientUploadResponse::UploadStatus_MIN;
constexpr ClientUploadResponse_UploadStatus ClientUploadResponse::UploadStatus_MAX;
constexpr int ClientUploadResponse::UploadStatus_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_strings[7]
    = {};

static const char ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names[] = "BYPASS_CHANGED"
                                                                                                   "BYPASS_CLEARED"
                                                                                                   "CHANGED"
                                                                                                   "CLEARED"
                                                                                                   "UNKNOWN"
                                                                                                   "UNTRUSTED_UNKNOWN_VALUE"
                                                                                                   "WEAK_LEGACY_OBSOLETE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_entries[] = {
    { { ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names + 0, 14 }, 6 },
    { { ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names + 14, 14 }, 5 },
    { { ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names + 28, 7 }, 3 },
    { { ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names + 35, 7 }, 1 },
    { { ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names + 42, 7 }, 0 },
    { { ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names + 49, 23 }, 4 },
    { { ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_names + 72, 20 }, 2 },
};

static const int ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_entries_by_number[] = {
    4, // 0 -> UNKNOWN
    3, // 1 -> CLEARED
    6, // 2 -> WEAK_LEGACY_OBSOLETE
    2, // 3 -> CHANGED
    5, // 4 -> UNTRUSTED_UNKNOWN_VALUE
    1, // 5 -> BYPASS_CLEARED
    0, // 6 -> BYPASS_CHANGED
};

const std::string& ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_Name(
    ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_entries,
            ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_entries_by_number, 7,
            ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_entries,
        ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_entries_by_number, 7, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_strings[idx].get();
}
bool ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_entries, 7, name, &int_value);
    if (success) {
        *value = static_cast<ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::UNKNOWN;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::CLEARED;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState
    ClientIncidentReport_IncidentData_TrackedPreferenceIncident::WEAK_LEGACY_OBSOLETE;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::CHANGED;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState
    ClientIncidentReport_IncidentData_TrackedPreferenceIncident::UNTRUSTED_UNKNOWN_VALUE;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::BYPASS_CLEARED;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::BYPASS_CHANGED;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::ValueState_MIN;
constexpr ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState ClientIncidentReport_IncidentData_TrackedPreferenceIncident::ValueState_MAX;
constexpr int ClientIncidentReport_IncidentData_TrackedPreferenceIncident::ValueState_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_IsValid(int value)
{
    switch (value) {
    case 0:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_strings[2] = {};

static const char ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_names[] = "TYPE_PATTERN"
                                                                                           "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_entries[] = {
    { { ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_names + 0, 12 }, 3 },
    { { ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_names + 12, 7 }, 0 },
};

static const int ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_entries_by_number[] = {
    1, // 0 -> UNKNOWN
    0, // 3 -> TYPE_PATTERN
};

const std::string& ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_Name(ClientIncidentReport_IncidentData_ResourceRequestIncident_Type value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_entries,
        ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_entries_by_number, 2,
        ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_entries,
        ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_strings[idx].get();
}
bool ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientIncidentReport_IncidentData_ResourceRequestIncident_Type* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<ClientIncidentReport_IncidentData_ResourceRequestIncident_Type>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientIncidentReport_IncidentData_ResourceRequestIncident_Type ClientIncidentReport_IncidentData_ResourceRequestIncident::UNKNOWN;
constexpr ClientIncidentReport_IncidentData_ResourceRequestIncident_Type ClientIncidentReport_IncidentData_ResourceRequestIncident::TYPE_PATTERN;
constexpr ClientIncidentReport_IncidentData_ResourceRequestIncident_Type ClientIncidentReport_IncidentData_ResourceRequestIncident::Type_MIN;
constexpr ClientIncidentReport_IncidentData_ResourceRequestIncident_Type ClientIncidentReport_IncidentData_ResourceRequestIncident::Type_MAX;
constexpr int ClientIncidentReport_IncidentData_ResourceRequestIncident::Type_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientIncidentReport_EnvironmentData_Process_Dll_Feature_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientIncidentReport_EnvironmentData_Process_Dll_Feature_strings[2] = {};

static const char ClientIncidentReport_EnvironmentData_Process_Dll_Feature_names[] = "LSP"
                                                                                     "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientIncidentReport_EnvironmentData_Process_Dll_Feature_entries[] = {
    { { ClientIncidentReport_EnvironmentData_Process_Dll_Feature_names + 0, 3 }, 1 },
    { { ClientIncidentReport_EnvironmentData_Process_Dll_Feature_names + 3, 7 }, 0 },
};

static const int ClientIncidentReport_EnvironmentData_Process_Dll_Feature_entries_by_number[] = {
    1, // 0 -> UNKNOWN
    0, // 1 -> LSP
};

const std::string& ClientIncidentReport_EnvironmentData_Process_Dll_Feature_Name(ClientIncidentReport_EnvironmentData_Process_Dll_Feature value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientIncidentReport_EnvironmentData_Process_Dll_Feature_entries,
        ClientIncidentReport_EnvironmentData_Process_Dll_Feature_entries_by_number, 2, ClientIncidentReport_EnvironmentData_Process_Dll_Feature_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ClientIncidentReport_EnvironmentData_Process_Dll_Feature_entries, ClientIncidentReport_EnvironmentData_Process_Dll_Feature_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientIncidentReport_EnvironmentData_Process_Dll_Feature_strings[idx].get();
}
bool ClientIncidentReport_EnvironmentData_Process_Dll_Feature_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientIncidentReport_EnvironmentData_Process_Dll_Feature* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientIncidentReport_EnvironmentData_Process_Dll_Feature_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<ClientIncidentReport_EnvironmentData_Process_Dll_Feature>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientIncidentReport_EnvironmentData_Process_Dll_Feature ClientIncidentReport_EnvironmentData_Process_Dll::UNKNOWN;
constexpr ClientIncidentReport_EnvironmentData_Process_Dll_Feature ClientIncidentReport_EnvironmentData_Process_Dll::LSP;
constexpr ClientIncidentReport_EnvironmentData_Process_Dll_Feature ClientIncidentReport_EnvironmentData_Process_Dll::Feature_MIN;
constexpr ClientIncidentReport_EnvironmentData_Process_Dll_Feature ClientIncidentReport_EnvironmentData_Process_Dll::Feature_MAX;
constexpr int ClientIncidentReport_EnvironmentData_Process_Dll::Feature_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_strings[4]
    = {};

static const char ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_names[] = "MODULE_STATE_MODIFIED"
                                                                                                   "MODULE_STATE_UNKNOWN"
                                                                                                   "MODULE_STATE_UNMODIFIED"
                                                                                                   "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_entries[] = {
    { { ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_names + 0, 21 }, 3 },
    { { ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_names + 21, 20 }, 1 },
    { { ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_names + 41, 23 }, 2 },
    { { ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_names + 64, 7 }, 0 },
};

static const int ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_entries_by_number[] = {
    3, // 0 -> UNKNOWN
    1, // 1 -> MODULE_STATE_UNKNOWN
    2, // 2 -> MODULE_STATE_UNMODIFIED
    0, // 3 -> MODULE_STATE_MODIFIED
};

const std::string& ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_Name(
    ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_entries,
            ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_entries_by_number, 4,
            ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_entries,
        ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_strings[idx].get();
}
bool ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState ClientIncidentReport_EnvironmentData_Process_ModuleState::UNKNOWN;
constexpr ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState ClientIncidentReport_EnvironmentData_Process_ModuleState::MODULE_STATE_UNKNOWN;
constexpr ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState
    ClientIncidentReport_EnvironmentData_Process_ModuleState::MODULE_STATE_UNMODIFIED;
constexpr ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState
    ClientIncidentReport_EnvironmentData_Process_ModuleState::MODULE_STATE_MODIFIED;
constexpr ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState ClientIncidentReport_EnvironmentData_Process_ModuleState::ModifiedState_MIN;
constexpr ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState ClientIncidentReport_EnvironmentData_Process_ModuleState::ModifiedState_MAX;
constexpr int ClientIncidentReport_EnvironmentData_Process_ModuleState::ModifiedState_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientIncidentReport_EnvironmentData_Process_Channel_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientIncidentReport_EnvironmentData_Process_Channel_strings[5] = {};

static const char ClientIncidentReport_EnvironmentData_Process_Channel_names[] = "CHANNEL_BETA"
                                                                                 "CHANNEL_CANARY"
                                                                                 "CHANNEL_DEV"
                                                                                 "CHANNEL_STABLE"
                                                                                 "CHANNEL_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientIncidentReport_EnvironmentData_Process_Channel_entries[] = {
    { { ClientIncidentReport_EnvironmentData_Process_Channel_names + 0, 12 }, 3 },
    { { ClientIncidentReport_EnvironmentData_Process_Channel_names + 12, 14 }, 1 },
    { { ClientIncidentReport_EnvironmentData_Process_Channel_names + 26, 11 }, 2 },
    { { ClientIncidentReport_EnvironmentData_Process_Channel_names + 37, 14 }, 4 },
    { { ClientIncidentReport_EnvironmentData_Process_Channel_names + 51, 15 }, 0 },
};

static const int ClientIncidentReport_EnvironmentData_Process_Channel_entries_by_number[] = {
    4, // 0 -> CHANNEL_UNKNOWN
    1, // 1 -> CHANNEL_CANARY
    2, // 2 -> CHANNEL_DEV
    0, // 3 -> CHANNEL_BETA
    3, // 4 -> CHANNEL_STABLE
};

const std::string& ClientIncidentReport_EnvironmentData_Process_Channel_Name(ClientIncidentReport_EnvironmentData_Process_Channel value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientIncidentReport_EnvironmentData_Process_Channel_entries,
        ClientIncidentReport_EnvironmentData_Process_Channel_entries_by_number, 5, ClientIncidentReport_EnvironmentData_Process_Channel_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ClientIncidentReport_EnvironmentData_Process_Channel_entries, ClientIncidentReport_EnvironmentData_Process_Channel_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientIncidentReport_EnvironmentData_Process_Channel_strings[idx].get();
}
bool ClientIncidentReport_EnvironmentData_Process_Channel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientIncidentReport_EnvironmentData_Process_Channel* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientIncidentReport_EnvironmentData_Process_Channel_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<ClientIncidentReport_EnvironmentData_Process_Channel>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientIncidentReport_EnvironmentData_Process_Channel ClientIncidentReport_EnvironmentData_Process::CHANNEL_UNKNOWN;
constexpr ClientIncidentReport_EnvironmentData_Process_Channel ClientIncidentReport_EnvironmentData_Process::CHANNEL_CANARY;
constexpr ClientIncidentReport_EnvironmentData_Process_Channel ClientIncidentReport_EnvironmentData_Process::CHANNEL_DEV;
constexpr ClientIncidentReport_EnvironmentData_Process_Channel ClientIncidentReport_EnvironmentData_Process::CHANNEL_BETA;
constexpr ClientIncidentReport_EnvironmentData_Process_Channel ClientIncidentReport_EnvironmentData_Process::CHANNEL_STABLE;
constexpr ClientIncidentReport_EnvironmentData_Process_Channel ClientIncidentReport_EnvironmentData_Process::Channel_MIN;
constexpr ClientIncidentReport_EnvironmentData_Process_Channel ClientIncidentReport_EnvironmentData_Process::Channel_MAX;
constexpr int ClientIncidentReport_EnvironmentData_Process::Channel_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_strings[6] = {};

static const char ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_names[] = "STATE_BLOCKED"
                                                                                            "STATE_BLOCKLISTED"
                                                                                            "STATE_DISABLED"
                                                                                            "STATE_ENABLED"
                                                                                            "STATE_TERMINATED"
                                                                                            "STATE_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_entries[] = {
    { { ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_names + 0, 13 }, 4 },
    { { ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_names + 13, 17 }, 3 },
    { { ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_names + 30, 14 }, 2 },
    { { ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_names + 44, 13 }, 1 },
    { { ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_names + 57, 16 }, 5 },
    { { ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_names + 73, 13 }, 0 },
};

static const int ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_entries_by_number[] = {
    5, // 0 -> STATE_UNKNOWN
    3, // 1 -> STATE_ENABLED
    2, // 2 -> STATE_DISABLED
    1, // 3 -> STATE_BLOCKLISTED
    0, // 4 -> STATE_BLOCKED
    4, // 5 -> STATE_TERMINATED
};

const std::string& ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_Name(ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_entries,
        ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_entries_by_number, 6,
        ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_entries,
        ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_strings[idx].get();
}
bool ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::STATE_UNKNOWN;
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::STATE_ENABLED;
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::STATE_DISABLED;
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::STATE_BLOCKLISTED;
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::STATE_BLOCKED;
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::STATE_TERMINATED;
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::ExtensionState_MIN;
constexpr ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState ClientIncidentReport_ExtensionData_ExtensionInfo::ExtensionState_MAX;
constexpr int ClientIncidentReport_ExtensionData_ExtensionInfo::ExtensionState_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_strings[6] = {};

static const char ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_names[] = "BUBBLE_MAINPAGE"
                                                                                          "BUBBLE_SUBPAGE"
                                                                                          "DOWNLOADS_PAGE"
                                                                                          "DOWNLOAD_NOTIFICATION"
                                                                                          "DOWNLOAD_PROMPT"
                                                                                          "SURFACE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_entries[] = {
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_names + 0, 15 }, 1 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_names + 15, 14 }, 2 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_names + 29, 14 }, 3 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_names + 43, 21 }, 5 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_names + 64, 15 }, 4 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_names + 79, 19 }, 0 },
};

static const int ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_entries_by_number[] = {
    5, // 0 -> SURFACE_UNSPECIFIED
    0, // 1 -> BUBBLE_MAINPAGE
    1, // 2 -> BUBBLE_SUBPAGE
    2, // 3 -> DOWNLOADS_PAGE
    4, // 4 -> DOWNLOAD_PROMPT
    3, // 5 -> DOWNLOAD_NOTIFICATION
};

const std::string& ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_Name(ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_entries,
        ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_entries_by_number, 6,
        ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_entries,
        ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_strings[idx].get();
}
bool ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface ClientSafeBrowsingReportRequest_DownloadWarningAction::SURFACE_UNSPECIFIED;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface ClientSafeBrowsingReportRequest_DownloadWarningAction::BUBBLE_MAINPAGE;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface ClientSafeBrowsingReportRequest_DownloadWarningAction::BUBBLE_SUBPAGE;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface ClientSafeBrowsingReportRequest_DownloadWarningAction::DOWNLOADS_PAGE;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface ClientSafeBrowsingReportRequest_DownloadWarningAction::DOWNLOAD_PROMPT;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface ClientSafeBrowsingReportRequest_DownloadWarningAction::DOWNLOAD_NOTIFICATION;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface ClientSafeBrowsingReportRequest_DownloadWarningAction::Surface_MIN;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface ClientSafeBrowsingReportRequest_DownloadWarningAction::Surface_MAX;
constexpr int ClientSafeBrowsingReportRequest_DownloadWarningAction::Surface_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_strings[12] = {};

static const char ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_names[] = "ACCEPT_DEEP_SCAN"
                                                                                         "ACTION_UNSPECIFIED"
                                                                                         "BACK"
                                                                                         "CANCEL"
                                                                                         "CLOSE"
                                                                                         "DISCARD"
                                                                                         "DISMISS"
                                                                                         "KEEP"
                                                                                         "OPEN_LEARN_MORE_LINK"
                                                                                         "OPEN_SUBPAGE"
                                                                                         "PROCEED"
                                                                                         "PROCEED_DEEP_SCAN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_entries[] = {
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_names + 0, 16 }, 11 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_names + 16, 18 }, 0 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_names + 34, 4 }, 7 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_names + 38, 6 }, 5 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_names + 44, 5 }, 4 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_names + 49, 7 }, 2 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_names + 56, 7 }, 6 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_names + 63, 4 }, 3 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_names + 67, 20 }, 10 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_names + 87, 12 }, 8 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_names + 99, 7 }, 1 },
    { { ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_names + 106, 17 }, 9 },
};

static const int ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_entries_by_number[] = {
    1, // 0 -> ACTION_UNSPECIFIED
    10, // 1 -> PROCEED
    5, // 2 -> DISCARD
    7, // 3 -> KEEP
    4, // 4 -> CLOSE
    3, // 5 -> CANCEL
    6, // 6 -> DISMISS
    2, // 7 -> BACK
    9, // 8 -> OPEN_SUBPAGE
    11, // 9 -> PROCEED_DEEP_SCAN
    8, // 10 -> OPEN_LEARN_MORE_LINK
    0, // 11 -> ACCEPT_DEEP_SCAN
};

const std::string& ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_Name(ClientSafeBrowsingReportRequest_DownloadWarningAction_Action value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_entries,
        ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_entries_by_number, 12,
        ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_entries,
        ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_entries_by_number, 12, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_strings[idx].get();
}
bool ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSafeBrowsingReportRequest_DownloadWarningAction_Action* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_entries, 12, name, &int_value);
    if (success) {
        *value = static_cast<ClientSafeBrowsingReportRequest_DownloadWarningAction_Action>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Action ClientSafeBrowsingReportRequest_DownloadWarningAction::ACTION_UNSPECIFIED;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Action ClientSafeBrowsingReportRequest_DownloadWarningAction::PROCEED;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Action ClientSafeBrowsingReportRequest_DownloadWarningAction::DISCARD;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Action ClientSafeBrowsingReportRequest_DownloadWarningAction::KEEP;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Action ClientSafeBrowsingReportRequest_DownloadWarningAction::CLOSE;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Action ClientSafeBrowsingReportRequest_DownloadWarningAction::CANCEL;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Action ClientSafeBrowsingReportRequest_DownloadWarningAction::DISMISS;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Action ClientSafeBrowsingReportRequest_DownloadWarningAction::BACK;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Action ClientSafeBrowsingReportRequest_DownloadWarningAction::OPEN_SUBPAGE;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Action ClientSafeBrowsingReportRequest_DownloadWarningAction::PROCEED_DEEP_SCAN;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Action ClientSafeBrowsingReportRequest_DownloadWarningAction::OPEN_LEARN_MORE_LINK;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Action ClientSafeBrowsingReportRequest_DownloadWarningAction::ACCEPT_DEEP_SCAN;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Action ClientSafeBrowsingReportRequest_DownloadWarningAction::Action_MIN;
constexpr ClientSafeBrowsingReportRequest_DownloadWarningAction_Action ClientSafeBrowsingReportRequest_DownloadWarningAction::Action_MAX;
constexpr int ClientSafeBrowsingReportRequest_DownloadWarningAction::Action_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_strings[5] = {};

static const char ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_names[] = "BILLING"
                                                                                                               "MALWARE"
                                                                                                               "PHISHING"
                                                                                                               "SAFE_OR_OTHER"
                                                                                                               "UNWANTED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_entries[] = {
    { { ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_names + 0, 7 }, 4 },
    { { ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_names + 7, 7 }, 1 },
    { { ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_names + 14, 8 }, 2 },
    { { ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_names + 22, 13 }, 0 },
    { { ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_names + 35, 8 }, 3 },
};

static const int ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_entries_by_number[] = {
    3, // 0 -> SAFE_OR_OTHER
    1, // 1 -> MALWARE
    2, // 2 -> PHISHING
    4, // 3 -> UNWANTED
    0, // 4 -> BILLING
};

const std::string& ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_Name(
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_entries,
            ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_entries_by_number, 5,
            ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_entries,
        ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_strings[idx].get();
}
bool ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::SAFE_OR_OTHER;
constexpr ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::MALWARE;
constexpr ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::PHISHING;
constexpr ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::UNWANTED;
constexpr ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::BILLING;
constexpr ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::ExperimentThreatType_MIN;
constexpr ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::ExperimentThreatType_MAX;
constexpr int ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::ExperimentThreatType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_strings[16] = {};

static const char ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names[] = "CMD_CLOSE_INTERSTITIAL_WITHOUT_UI"
                                                                                                                    "CMD_DONT_PROCEED"
                                                                                                                    "CMD_DONT_REPORT"
                                                                                                                    "CMD_DO_REPORT"
                                                                                                                    "CMD_OPEN_DATE_SETTINGS"
                                                                                                                    "CMD_OPEN_DIAGNOSTIC"
                                                                                                                    "CMD_OPEN_ENHANCED_PROTECTION_SETTINGS"
                                                                                                                    "CMD_OPEN_HELP_CENTER"
                                                                                                                    "CMD_OPEN_LOGIN"
                                                                                                                    "CMD_OPEN_REPORTING_PRIVACY"
                                                                                                                    "CMD_OPEN_WHITEPAPER"
                                                                                                                    "CMD_PROCEED"
                                                                                                                    "CMD_RELOAD"
                                                                                                                    "CMD_REPORT_PHISHING_ERROR"
                                                                                                                    "CMD_SHOW_MORE_SECTION"
                                                                                                                    "UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_entries[] = {
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 0, 33 }, 15 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 33, 16 }, 1 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 49, 15 }, 10 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 64, 13 }, 9 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 77, 22 }, 7 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 99, 19 }, 5 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 118, 37 }, 14 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 155, 20 }, 4 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 175, 14 }, 8 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 189, 26 }, 11 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 215, 19 }, 12 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 234, 11 }, 2 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 245, 10 }, 6 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 255, 25 }, 13 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 280, 21 }, 3 },
    { { ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_names + 301, 11 }, 0 },
};

static const int ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_entries_by_number[] = {
    15, // 0 -> UNSPECIFIED
    1, // 1 -> CMD_DONT_PROCEED
    11, // 2 -> CMD_PROCEED
    14, // 3 -> CMD_SHOW_MORE_SECTION
    7, // 4 -> CMD_OPEN_HELP_CENTER
    5, // 5 -> CMD_OPEN_DIAGNOSTIC
    12, // 6 -> CMD_RELOAD
    4, // 7 -> CMD_OPEN_DATE_SETTINGS
    8, // 8 -> CMD_OPEN_LOGIN
    3, // 9 -> CMD_DO_REPORT
    2, // 10 -> CMD_DONT_REPORT
    9, // 11 -> CMD_OPEN_REPORTING_PRIVACY
    10, // 12 -> CMD_OPEN_WHITEPAPER
    13, // 13 -> CMD_REPORT_PHISHING_ERROR
    6, // 14 -> CMD_OPEN_ENHANCED_PROTECTION_SETTINGS
    0, // 15 -> CMD_CLOSE_INTERSTITIAL_WITHOUT_UI
};

const std::string& ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_Name(
    ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_entries,
        ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_entries_by_number, 16,
        ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_entries,
        ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_entries_by_number, 16, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_strings[idx].get();
}
bool ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_entries, 16, name, &int_value);
    if (success) {
        *value = static_cast<ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::UNSPECIFIED;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_DONT_PROCEED;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_PROCEED;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_SHOW_MORE_SECTION;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_OPEN_HELP_CENTER;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_OPEN_DIAGNOSTIC;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_RELOAD;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_OPEN_DATE_SETTINGS;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_OPEN_LOGIN;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_DO_REPORT;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_DONT_REPORT;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_OPEN_REPORTING_PRIVACY;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_OPEN_WHITEPAPER;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_REPORT_PHISHING_ERROR;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_OPEN_ENHANCED_PROTECTION_SETTINGS;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::CMD_CLOSE_INTERSTITIAL_WITHOUT_UI;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::SecurityInterstitialInteraction_MIN;
constexpr ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction
    ClientSafeBrowsingReportRequest_InterstitialInteraction::SecurityInterstitialInteraction_MAX;
constexpr int ClientSafeBrowsingReportRequest_InterstitialInteraction::SecurityInterstitialInteraction_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_strings[4] = {};

static const char ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_names[] = "PHISHY_CLICK_EVENT"
                                                                                                            "PHISHY_KEY_EVENT"
                                                                                                            "PHISHY_PASTE_EVENT"
                                                                                                            "UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_entries[] = {
    { { ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_names + 0, 18 }, 1 },
    { { ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_names + 18, 16 }, 2 },
    { { ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_names + 34, 18 }, 3 },
    { { ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_names + 52, 11 }, 0 },
};

static const int ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_entries_by_number[] = {
    3, // 0 -> UNSPECIFIED
    0, // 1 -> PHISHY_CLICK_EVENT
    1, // 2 -> PHISHY_KEY_EVENT
    2, // 3 -> PHISHY_PASTE_EVENT
};

const std::string& ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_Name(
    ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_entries,
            ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_entries_by_number, 4,
            ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_entries,
        ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_strings[idx].get();
}
bool ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType ClientSafeBrowsingReportRequest_PhishySiteInteraction::UNSPECIFIED;
constexpr ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType
    ClientSafeBrowsingReportRequest_PhishySiteInteraction::PHISHY_CLICK_EVENT;
constexpr ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType
    ClientSafeBrowsingReportRequest_PhishySiteInteraction::PHISHY_KEY_EVENT;
constexpr ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType
    ClientSafeBrowsingReportRequest_PhishySiteInteraction::PHISHY_PASTE_EVENT;
constexpr ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType
    ClientSafeBrowsingReportRequest_PhishySiteInteraction::PhishySiteInteractionType_MIN;
constexpr ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType
    ClientSafeBrowsingReportRequest_PhishySiteInteraction::PhishySiteInteractionType_MAX;
constexpr int ClientSafeBrowsingReportRequest_PhishySiteInteraction::PhishySiteInteractionType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_strings[7] = {};

static const char ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_names[] = "BILLING_INTERSTITIAL"
                                                                                           "BINARY_MALWARE_DOWNLOAD_WARNING"
                                                                                           "CLIENT_SIDE_PHISHING_INTERSTITIAL"
                                                                                           "MALWARE_INTERSTITIAL"
                                                                                           "PHISHING_INTERSTITIAL"
                                                                                           "UNKNOWN"
                                                                                           "UWS_INTERSTITIAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_entries[] = {
    { { ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_names + 0, 20 }, 5 },
    { { ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_names + 20, 31 }, 6 },
    { { ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_names + 51, 33 }, 2 },
    { { ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_names + 84, 20 }, 3 },
    { { ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_names + 104, 21 }, 1 },
    { { ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_names + 125, 7 }, 0 },
    { { ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_names + 132, 16 }, 4 },
};

static const int ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_entries_by_number[] = {
    5, // 0 -> UNKNOWN
    4, // 1 -> PHISHING_INTERSTITIAL
    2, // 2 -> CLIENT_SIDE_PHISHING_INTERSTITIAL
    3, // 3 -> MALWARE_INTERSTITIAL
    6, // 4 -> UWS_INTERSTITIAL
    0, // 5 -> BILLING_INTERSTITIAL
    1, // 6 -> BINARY_MALWARE_DOWNLOAD_WARNING
};

const std::string& ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_Name(ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_entries,
        ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_entries_by_number, 7,
        ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_entries,
        ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_entries_by_number, 7, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_strings[idx].get();
}
bool ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_entries, 7, name, &int_value);
    if (success) {
        *value = static_cast<ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType ClientSafeBrowsingReportRequest_WarningShownInfo::UNKNOWN;
constexpr ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType ClientSafeBrowsingReportRequest_WarningShownInfo::PHISHING_INTERSTITIAL;
constexpr ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType ClientSafeBrowsingReportRequest_WarningShownInfo::CLIENT_SIDE_PHISHING_INTERSTITIAL;
constexpr ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType ClientSafeBrowsingReportRequest_WarningShownInfo::MALWARE_INTERSTITIAL;
constexpr ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType ClientSafeBrowsingReportRequest_WarningShownInfo::UWS_INTERSTITIAL;
constexpr ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType ClientSafeBrowsingReportRequest_WarningShownInfo::BILLING_INTERSTITIAL;
constexpr ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType ClientSafeBrowsingReportRequest_WarningShownInfo::BINARY_MALWARE_DOWNLOAD_WARNING;
constexpr ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType ClientSafeBrowsingReportRequest_WarningShownInfo::WarningUXType_MIN;
constexpr ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType ClientSafeBrowsingReportRequest_WarningShownInfo::WarningUXType_MAX;
constexpr int ClientSafeBrowsingReportRequest_WarningShownInfo::WarningUXType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_strings[5] = {};

static const char ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_names[] = "BILLING"
                                                                                                                       "MALWARE"
                                                                                                                       "PHISHING"
                                                                                                                       "SAFE_OR_OTHER"
                                                                                                                       "UNWANTED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_entries[]
    = {
          { { ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_names + 0, 7 }, 4 },
          { { ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_names + 7, 7 }, 1 },
          { { ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_names + 14, 8 }, 2 },
          { { ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_names + 22, 13 }, 0 },
          { { ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_names + 35, 8 }, 3 },
      };

static const int ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_entries_by_number[] = {
    3, // 0 -> SAFE_OR_OTHER
    1, // 1 -> MALWARE
    2, // 2 -> PHISHING
    4, // 3 -> UNWANTED
    0, // 4 -> BILLING
};

const std::string& ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_Name(
    ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_entries,
        ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_entries_by_number, 5,
        ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_strings);
    (void)dummy;
    int idx
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_entries,
            ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_strings[idx].get();
}
bool ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType
    ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::SAFE_OR_OTHER;
constexpr ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType
    ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::MALWARE;
constexpr ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType
    ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::PHISHING;
constexpr ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType
    ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::UNWANTED;
constexpr ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType
    ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::BILLING;
constexpr ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType
    ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::LookupThreatType_MIN;
constexpr ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType
    ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::LookupThreatType_MAX;
constexpr int ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::LookupThreatType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientSafeBrowsingReportRequest_ReportType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 10:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientSafeBrowsingReportRequest_ReportType_strings[25] = {};

static const char ClientSafeBrowsingReportRequest_ReportType_names[] = "AD_SAMPLE"
                                                                       "APK_DOWNLOAD"
                                                                       "BILLING"
                                                                       "BLOCKED_AD_POPUP"
                                                                       "BLOCKED_AD_REDIRECT"
                                                                       "DANGEROUS_DOWNLOAD_AUTO_DELETED"
                                                                       "DANGEROUS_DOWNLOAD_BY_API"
                                                                       "DANGEROUS_DOWNLOAD_OPENED"
                                                                       "DANGEROUS_DOWNLOAD_PROFILE_CLOSED"
                                                                       "DANGEROUS_DOWNLOAD_RECOVERY"
                                                                       "DANGEROUS_DOWNLOAD_WARNING"
                                                                       "EXTERNAL_APP_REDIRECT"
                                                                       "HASH_PREFIX_REAL_TIME_EXPERIMENT"
                                                                       "NOTIFICATION_PERMISSION_ACCEPTED"
                                                                       "PHISHY_SITE_INTERACTIONS"
                                                                       "UNKNOWN"
                                                                       "URL_CLIENT_SIDE_MALWARE"
                                                                       "URL_CLIENT_SIDE_PHISHING"
                                                                       "URL_MALWARE"
                                                                       "URL_PASSWORD_PROTECTION_PHISHING"
                                                                       "URL_PHISHING"
                                                                       "URL_REALTIME_AND_HASH_REALTIME_DISCREPANCY"
                                                                       "URL_SUSPICIOUS"
                                                                       "URL_UNWANTED"
                                                                       "WARNING_SHOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSafeBrowsingReportRequest_ReportType_entries[] = {
    { { ClientSafeBrowsingReportRequest_ReportType_names + 0, 9 }, 14 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 9, 12 }, 17 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 21, 7 }, 16 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 28, 16 }, 20 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 44, 19 }, 19 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 63, 31 }, 25 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 94, 25 }, 10 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 119, 25 }, 13 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 144, 33 }, 26 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 177, 27 }, 6 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 204, 26 }, 7 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 230, 21 }, 28 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 251, 32 }, 21 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 283, 32 }, 24 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 315, 24 }, 22 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 339, 7 }, 0 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 346, 23 }, 5 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 369, 24 }, 4 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 393, 11 }, 2 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 404, 32 }, 12 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 436, 12 }, 1 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 448, 42 }, 27 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 490, 14 }, 15 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 504, 12 }, 3 },
    { { ClientSafeBrowsingReportRequest_ReportType_names + 516, 13 }, 23 },
};

static const int ClientSafeBrowsingReportRequest_ReportType_entries_by_number[] = {
    15, // 0 -> UNKNOWN
    20, // 1 -> URL_PHISHING
    18, // 2 -> URL_MALWARE
    23, // 3 -> URL_UNWANTED
    17, // 4 -> URL_CLIENT_SIDE_PHISHING
    16, // 5 -> URL_CLIENT_SIDE_MALWARE
    9, // 6 -> DANGEROUS_DOWNLOAD_RECOVERY
    10, // 7 -> DANGEROUS_DOWNLOAD_WARNING
    6, // 10 -> DANGEROUS_DOWNLOAD_BY_API
    19, // 12 -> URL_PASSWORD_PROTECTION_PHISHING
    7, // 13 -> DANGEROUS_DOWNLOAD_OPENED
    0, // 14 -> AD_SAMPLE
    22, // 15 -> URL_SUSPICIOUS
    2, // 16 -> BILLING
    1, // 17 -> APK_DOWNLOAD
    4, // 19 -> BLOCKED_AD_REDIRECT
    3, // 20 -> BLOCKED_AD_POPUP
    12, // 21 -> HASH_PREFIX_REAL_TIME_EXPERIMENT
    14, // 22 -> PHISHY_SITE_INTERACTIONS
    24, // 23 -> WARNING_SHOWN
    13, // 24 -> NOTIFICATION_PERMISSION_ACCEPTED
    5, // 25 -> DANGEROUS_DOWNLOAD_AUTO_DELETED
    8, // 26 -> DANGEROUS_DOWNLOAD_PROFILE_CLOSED
    21, // 27 -> URL_REALTIME_AND_HASH_REALTIME_DISCREPANCY
    11, // 28 -> EXTERNAL_APP_REDIRECT
};

const std::string& ClientSafeBrowsingReportRequest_ReportType_Name(ClientSafeBrowsingReportRequest_ReportType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientSafeBrowsingReportRequest_ReportType_entries,
        ClientSafeBrowsingReportRequest_ReportType_entries_by_number, 25, ClientSafeBrowsingReportRequest_ReportType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ClientSafeBrowsingReportRequest_ReportType_entries, ClientSafeBrowsingReportRequest_ReportType_entries_by_number, 25, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientSafeBrowsingReportRequest_ReportType_strings[idx].get();
}
bool ClientSafeBrowsingReportRequest_ReportType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSafeBrowsingReportRequest_ReportType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientSafeBrowsingReportRequest_ReportType_entries, 25, name, &int_value);
    if (success) {
        *value = static_cast<ClientSafeBrowsingReportRequest_ReportType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::UNKNOWN;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::URL_PHISHING;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::URL_MALWARE;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::URL_UNWANTED;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::URL_CLIENT_SIDE_PHISHING;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::URL_CLIENT_SIDE_MALWARE;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::DANGEROUS_DOWNLOAD_RECOVERY;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::DANGEROUS_DOWNLOAD_WARNING;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::DANGEROUS_DOWNLOAD_BY_API;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::URL_PASSWORD_PROTECTION_PHISHING;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::DANGEROUS_DOWNLOAD_OPENED;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::AD_SAMPLE;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::URL_SUSPICIOUS;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::BILLING;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::APK_DOWNLOAD;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::BLOCKED_AD_REDIRECT;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::BLOCKED_AD_POPUP;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::HASH_PREFIX_REAL_TIME_EXPERIMENT;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::PHISHY_SITE_INTERACTIONS;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::WARNING_SHOWN;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::NOTIFICATION_PERMISSION_ACCEPTED;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::DANGEROUS_DOWNLOAD_AUTO_DELETED;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::DANGEROUS_DOWNLOAD_PROFILE_CLOSED;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::URL_REALTIME_AND_HASH_REALTIME_DISCREPANCY;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::EXTERNAL_APP_REDIRECT;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::ReportType_MIN;
constexpr ClientSafeBrowsingReportRequest_ReportType ClientSafeBrowsingReportRequest::ReportType_MAX;
constexpr int ClientSafeBrowsingReportRequest::ReportType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_strings[10] = {};

static const char ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names[] = "ANDROID_SAFEBROWSING"
                                                                                   "ANDROID_SAFEBROWSING_REAL_TIME"
                                                                                   "ANDROID_SAFETYNET"
                                                                                   "CLIENT_SIDE_DETECTION"
                                                                                   "FLYWHEEL"
                                                                                   "PVER3_NATIVE"
                                                                                   "PVER4_NATIVE"
                                                                                   "PVER5_NATIVE_REAL_TIME"
                                                                                   "REAL_TIME"
                                                                                   "SAFE_BROWSING_URL_API_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_entries[] = {
    { { ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 0, 20 }, 8 },
    { { ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 20, 30 }, 7 },
    { { ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 50, 17 }, 3 },
    { { ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 67, 21 }, 9 },
    { { ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 88, 8 }, 4 },
    { { ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 96, 12 }, 1 },
    { { ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 108, 12 }, 2 },
    { { ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 120, 22 }, 6 },
    { { ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 142, 9 }, 5 },
    { { ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_names + 151, 38 }, 0 },
};

static const int ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_entries_by_number[] = {
    9, // 0 -> SAFE_BROWSING_URL_API_TYPE_UNSPECIFIED
    5, // 1 -> PVER3_NATIVE
    6, // 2 -> PVER4_NATIVE
    2, // 3 -> ANDROID_SAFETYNET
    4, // 4 -> FLYWHEEL
    8, // 5 -> REAL_TIME
    7, // 6 -> PVER5_NATIVE_REAL_TIME
    1, // 7 -> ANDROID_SAFEBROWSING_REAL_TIME
    0, // 8 -> ANDROID_SAFEBROWSING
    3, // 9 -> CLIENT_SIDE_DETECTION
};

const std::string& ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_Name(ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_entries,
        ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_entries_by_number, 10, ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_entries, ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_entries_by_number, 10, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_strings[idx].get();
}
bool ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_entries, 10, name, &int_value);
    if (success) {
        *value = static_cast<ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::SAFE_BROWSING_URL_API_TYPE_UNSPECIFIED;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::PVER3_NATIVE;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::PVER4_NATIVE;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::ANDROID_SAFETYNET;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::FLYWHEEL;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::REAL_TIME;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::PVER5_NATIVE_REAL_TIME;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::ANDROID_SAFEBROWSING_REAL_TIME;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::ANDROID_SAFEBROWSING;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::CLIENT_SIDE_DETECTION;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::SafeBrowsingUrlApiType_MIN;
constexpr ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType ClientSafeBrowsingReportRequest::SafeBrowsingUrlApiType_MAX;
constexpr int ClientSafeBrowsingReportRequest::SafeBrowsingUrlApiType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ClientSafeBrowsingReportRequest_UrlRequestDestination_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientSafeBrowsingReportRequest_UrlRequestDestination_strings[29] = {};

static const char ClientSafeBrowsingReportRequest_UrlRequestDestination_names[] = "AUDIO"
                                                                                  "AUDIO_WORKLET"
                                                                                  "DICTIONARY"
                                                                                  "DOCUMENT"
                                                                                  "EMBED"
                                                                                  "EMPTY"
                                                                                  "FENCED_FRAME"
                                                                                  "FONT"
                                                                                  "FRAME"
                                                                                  "IFRAME"
                                                                                  "IMAGE"
                                                                                  "JSON"
                                                                                  "MANIFEST"
                                                                                  "OBJECT"
                                                                                  "PAINT_WORKLET"
                                                                                  "REPORT"
                                                                                  "REQUEST_DESTINATION_UNSPECIFIED"
                                                                                  "SCRIPT"
                                                                                  "SERVICE_WORKER"
                                                                                  "SHARED_STORAGE_WORKLET"
                                                                                  "SHARED_WORKER"
                                                                                  "SPECULATION_RULES"
                                                                                  "STYLE"
                                                                                  "TRACK"
                                                                                  "VIDEO"
                                                                                  "WEB_BUNDLE"
                                                                                  "WEB_IDENTITY"
                                                                                  "WORKER"
                                                                                  "XSLT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSafeBrowsingReportRequest_UrlRequestDestination_entries[] = {
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 0, 5 }, 2 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 5, 13 }, 3 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 18, 10 }, 25 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 28, 8 }, 4 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 36, 5 }, 5 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 41, 5 }, 1 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 46, 12 }, 23 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 58, 4 }, 6 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 62, 5 }, 7 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 67, 6 }, 8 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 73, 5 }, 9 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 78, 4 }, 27 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 82, 8 }, 10 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 90, 6 }, 11 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 96, 13 }, 12 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 109, 6 }, 13 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 115, 31 }, 0 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 146, 6 }, 14 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 152, 14 }, 15 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 166, 22 }, 28 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 188, 13 }, 16 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 201, 17 }, 26 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 218, 5 }, 17 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 223, 5 }, 18 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 228, 5 }, 19 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 233, 10 }, 20 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 243, 12 }, 24 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 255, 6 }, 21 },
    { { ClientSafeBrowsingReportRequest_UrlRequestDestination_names + 261, 4 }, 22 },
};

static const int ClientSafeBrowsingReportRequest_UrlRequestDestination_entries_by_number[] = {
    16, // 0 -> REQUEST_DESTINATION_UNSPECIFIED
    5, // 1 -> EMPTY
    0, // 2 -> AUDIO
    1, // 3 -> AUDIO_WORKLET
    3, // 4 -> DOCUMENT
    4, // 5 -> EMBED
    7, // 6 -> FONT
    8, // 7 -> FRAME
    9, // 8 -> IFRAME
    10, // 9 -> IMAGE
    12, // 10 -> MANIFEST
    13, // 11 -> OBJECT
    14, // 12 -> PAINT_WORKLET
    15, // 13 -> REPORT
    17, // 14 -> SCRIPT
    18, // 15 -> SERVICE_WORKER
    20, // 16 -> SHARED_WORKER
    22, // 17 -> STYLE
    23, // 18 -> TRACK
    24, // 19 -> VIDEO
    25, // 20 -> WEB_BUNDLE
    27, // 21 -> WORKER
    28, // 22 -> XSLT
    6, // 23 -> FENCED_FRAME
    26, // 24 -> WEB_IDENTITY
    2, // 25 -> DICTIONARY
    21, // 26 -> SPECULATION_RULES
    11, // 27 -> JSON
    19, // 28 -> SHARED_STORAGE_WORKLET
};

const std::string& ClientSafeBrowsingReportRequest_UrlRequestDestination_Name(ClientSafeBrowsingReportRequest_UrlRequestDestination value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ClientSafeBrowsingReportRequest_UrlRequestDestination_entries,
        ClientSafeBrowsingReportRequest_UrlRequestDestination_entries_by_number, 29, ClientSafeBrowsingReportRequest_UrlRequestDestination_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ClientSafeBrowsingReportRequest_UrlRequestDestination_entries, ClientSafeBrowsingReportRequest_UrlRequestDestination_entries_by_number, 29, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientSafeBrowsingReportRequest_UrlRequestDestination_strings[idx].get();
}
bool ClientSafeBrowsingReportRequest_UrlRequestDestination_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSafeBrowsingReportRequest_UrlRequestDestination* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientSafeBrowsingReportRequest_UrlRequestDestination_entries, 29, name, &int_value);
    if (success) {
        *value = static_cast<ClientSafeBrowsingReportRequest_UrlRequestDestination>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::REQUEST_DESTINATION_UNSPECIFIED;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::EMPTY;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::AUDIO;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::AUDIO_WORKLET;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::DOCUMENT;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::EMBED;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::FONT;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::FRAME;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::IFRAME;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::IMAGE;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::MANIFEST;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::OBJECT;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::PAINT_WORKLET;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::REPORT;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::SCRIPT;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::SERVICE_WORKER;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::SHARED_WORKER;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::STYLE;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::TRACK;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::VIDEO;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::WEB_BUNDLE;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::WORKER;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::XSLT;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::FENCED_FRAME;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::WEB_IDENTITY;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::DICTIONARY;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::SPECULATION_RULES;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::JSON;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::SHARED_STORAGE_WORKLET;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::UrlRequestDestination_MIN;
constexpr ClientSafeBrowsingReportRequest_UrlRequestDestination ClientSafeBrowsingReportRequest::UrlRequestDestination_MAX;
constexpr int ClientSafeBrowsingReportRequest::UrlRequestDestination_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionTelemetryReportRequest_ExtensionInfo_Type_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionTelemetryReportRequest_ExtensionInfo_Type_strings[9] = {};

static const char ExtensionTelemetryReportRequest_ExtensionInfo_Type_names[] = "EXTENSION"
                                                                               "HOSTED_APP"
                                                                               "LEGACY_PACKAGED_APP"
                                                                               "LOGIN_SCREEN_EXTENSION"
                                                                               "PLATFORM_APP"
                                                                               "SHARED_MODULE"
                                                                               "THEME"
                                                                               "UNKNOWN_TYPE"
                                                                               "USER_SCRIPT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionTelemetryReportRequest_ExtensionInfo_Type_entries[] = {
    { { ExtensionTelemetryReportRequest_ExtensionInfo_Type_names + 0, 9 }, 1 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_Type_names + 9, 10 }, 4 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_Type_names + 19, 19 }, 5 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_Type_names + 38, 22 }, 8 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_Type_names + 60, 12 }, 6 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_Type_names + 72, 13 }, 7 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_Type_names + 85, 5 }, 2 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_Type_names + 90, 12 }, 0 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_Type_names + 102, 11 }, 3 },
};

static const int ExtensionTelemetryReportRequest_ExtensionInfo_Type_entries_by_number[] = {
    7, // 0 -> UNKNOWN_TYPE
    0, // 1 -> EXTENSION
    6, // 2 -> THEME
    8, // 3 -> USER_SCRIPT
    1, // 4 -> HOSTED_APP
    2, // 5 -> LEGACY_PACKAGED_APP
    4, // 6 -> PLATFORM_APP
    5, // 7 -> SHARED_MODULE
    3, // 8 -> LOGIN_SCREEN_EXTENSION
};

const std::string& ExtensionTelemetryReportRequest_ExtensionInfo_Type_Name(ExtensionTelemetryReportRequest_ExtensionInfo_Type value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ExtensionTelemetryReportRequest_ExtensionInfo_Type_entries,
        ExtensionTelemetryReportRequest_ExtensionInfo_Type_entries_by_number, 9, ExtensionTelemetryReportRequest_ExtensionInfo_Type_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ExtensionTelemetryReportRequest_ExtensionInfo_Type_entries, ExtensionTelemetryReportRequest_ExtensionInfo_Type_entries_by_number, 9, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ExtensionTelemetryReportRequest_ExtensionInfo_Type_strings[idx].get();
}
bool ExtensionTelemetryReportRequest_ExtensionInfo_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionTelemetryReportRequest_ExtensionInfo_Type* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ExtensionTelemetryReportRequest_ExtensionInfo_Type_entries, 9, name, &int_value);
    if (success) {
        *value = static_cast<ExtensionTelemetryReportRequest_ExtensionInfo_Type>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_Type ExtensionTelemetryReportRequest_ExtensionInfo::UNKNOWN_TYPE;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_Type ExtensionTelemetryReportRequest_ExtensionInfo::EXTENSION;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_Type ExtensionTelemetryReportRequest_ExtensionInfo::THEME;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_Type ExtensionTelemetryReportRequest_ExtensionInfo::USER_SCRIPT;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_Type ExtensionTelemetryReportRequest_ExtensionInfo::HOSTED_APP;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_Type ExtensionTelemetryReportRequest_ExtensionInfo::LEGACY_PACKAGED_APP;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_Type ExtensionTelemetryReportRequest_ExtensionInfo::PLATFORM_APP;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_Type ExtensionTelemetryReportRequest_ExtensionInfo::SHARED_MODULE;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_Type ExtensionTelemetryReportRequest_ExtensionInfo::LOGIN_SCREEN_EXTENSION;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_Type ExtensionTelemetryReportRequest_ExtensionInfo::Type_MIN;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_Type ExtensionTelemetryReportRequest_ExtensionInfo::Type_MAX;
constexpr int ExtensionTelemetryReportRequest_ExtensionInfo::Type_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_strings[11] = {};

static const char ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_names[] = "COMMAND_LINE"
                                                                                          "COMPONENT"
                                                                                          "EXTERNAL_COMPONENT"
                                                                                          "EXTERNAL_POLICY"
                                                                                          "EXTERNAL_POLICY_DOWNLOAD"
                                                                                          "EXTERNAL_PREF"
                                                                                          "EXTERNAL_PREF_DOWNLOAD"
                                                                                          "EXTERNAL_REGISTRY"
                                                                                          "INTERNAL"
                                                                                          "UNKNOWN_LOCATION"
                                                                                          "UNPACKED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_entries[] = {
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_names + 0, 12 }, 8 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_names + 12, 9 }, 5 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_names + 21, 18 }, 10 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_names + 39, 15 }, 9 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_names + 54, 24 }, 7 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_names + 78, 13 }, 2 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_names + 91, 22 }, 6 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_names + 113, 17 }, 3 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_names + 130, 8 }, 1 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_names + 138, 16 }, 0 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_names + 154, 8 }, 4 },
};

static const int ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_entries_by_number[] = {
    9, // 0 -> UNKNOWN_LOCATION
    8, // 1 -> INTERNAL
    5, // 2 -> EXTERNAL_PREF
    7, // 3 -> EXTERNAL_REGISTRY
    10, // 4 -> UNPACKED
    1, // 5 -> COMPONENT
    6, // 6 -> EXTERNAL_PREF_DOWNLOAD
    4, // 7 -> EXTERNAL_POLICY_DOWNLOAD
    0, // 8 -> COMMAND_LINE
    3, // 9 -> EXTERNAL_POLICY
    2, // 10 -> EXTERNAL_COMPONENT
};

const std::string& ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_Name(ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_entries,
        ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_entries_by_number, 11,
        ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_entries,
        ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_entries_by_number, 11, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_strings[idx].get();
}
bool ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_entries, 11, name, &int_value);
    if (success) {
        *value = static_cast<ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation ExtensionTelemetryReportRequest_ExtensionInfo::UNKNOWN_LOCATION;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation ExtensionTelemetryReportRequest_ExtensionInfo::INTERNAL;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation ExtensionTelemetryReportRequest_ExtensionInfo::EXTERNAL_PREF;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation ExtensionTelemetryReportRequest_ExtensionInfo::EXTERNAL_REGISTRY;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation ExtensionTelemetryReportRequest_ExtensionInfo::UNPACKED;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation ExtensionTelemetryReportRequest_ExtensionInfo::COMPONENT;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation ExtensionTelemetryReportRequest_ExtensionInfo::EXTERNAL_PREF_DOWNLOAD;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation ExtensionTelemetryReportRequest_ExtensionInfo::EXTERNAL_POLICY_DOWNLOAD;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation ExtensionTelemetryReportRequest_ExtensionInfo::COMMAND_LINE;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation ExtensionTelemetryReportRequest_ExtensionInfo::EXTERNAL_POLICY;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation ExtensionTelemetryReportRequest_ExtensionInfo::EXTERNAL_COMPONENT;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation ExtensionTelemetryReportRequest_ExtensionInfo::InstallLocation_MIN;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation ExtensionTelemetryReportRequest_ExtensionInfo::InstallLocation_MAX;
constexpr int ExtensionTelemetryReportRequest_ExtensionInfo::InstallLocation_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_strings[6] = {};

static const char ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_names[] = "BLOCKLISTED_CWS_POLICY_VIOLATION"
                                                                                         "BLOCKLISTED_MALWARE"
                                                                                         "BLOCKLISTED_POTENTIALLY_UNWANTED"
                                                                                         "BLOCKLISTED_SECURITY_VULNERABILITY"
                                                                                         "BLOCKLISTED_UNKNOWN"
                                                                                         "NOT_BLOCKLISTED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_entries[] = {
    { { ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_names + 0, 32 }, 3 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_names + 32, 19 }, 1 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_names + 51, 32 }, 4 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_names + 83, 34 }, 2 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_names + 117, 19 }, 5 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_names + 136, 15 }, 0 },
};

static const int ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_entries_by_number[] = {
    5, // 0 -> NOT_BLOCKLISTED
    1, // 1 -> BLOCKLISTED_MALWARE
    3, // 2 -> BLOCKLISTED_SECURITY_VULNERABILITY
    0, // 3 -> BLOCKLISTED_CWS_POLICY_VIOLATION
    2, // 4 -> BLOCKLISTED_POTENTIALLY_UNWANTED
    4, // 5 -> BLOCKLISTED_UNKNOWN
};

const std::string& ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_Name(ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_entries,
        ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_entries_by_number, 6,
        ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_entries,
        ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_strings[idx].get();
}
bool ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState ExtensionTelemetryReportRequest_ExtensionInfo::NOT_BLOCKLISTED;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState ExtensionTelemetryReportRequest_ExtensionInfo::BLOCKLISTED_MALWARE;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState ExtensionTelemetryReportRequest_ExtensionInfo::BLOCKLISTED_SECURITY_VULNERABILITY;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState ExtensionTelemetryReportRequest_ExtensionInfo::BLOCKLISTED_CWS_POLICY_VIOLATION;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState ExtensionTelemetryReportRequest_ExtensionInfo::BLOCKLISTED_POTENTIALLY_UNWANTED;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState ExtensionTelemetryReportRequest_ExtensionInfo::BLOCKLISTED_UNKNOWN;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState ExtensionTelemetryReportRequest_ExtensionInfo::BlocklistState_MIN;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState ExtensionTelemetryReportRequest_ExtensionInfo::BlocklistState_MAX;
constexpr int ExtensionTelemetryReportRequest_ExtensionInfo::BlocklistState_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_strings[6] = {};

static const char ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_names[] = "INSTALLATION_ALLOWED"
                                                                                             "INSTALLATION_BLOCKED"
                                                                                             "INSTALLATION_FORCED"
                                                                                             "INSTALLATION_RECOMMENDED"
                                                                                             "INSTALLATION_REMOVED"
                                                                                             "NO_POLICY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_entries[] = {
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_names + 0, 20 }, 1 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_names + 20, 20 }, 2 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_names + 40, 19 }, 3 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_names + 59, 24 }, 4 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_names + 83, 20 }, 5 },
    { { ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_names + 103, 9 }, 0 },
};

static const int ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_entries_by_number[] = {
    5, // 0 -> NO_POLICY
    0, // 1 -> INSTALLATION_ALLOWED
    1, // 2 -> INSTALLATION_BLOCKED
    2, // 3 -> INSTALLATION_FORCED
    3, // 4 -> INSTALLATION_RECOMMENDED
    4, // 5 -> INSTALLATION_REMOVED
};

const std::string& ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_Name(ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_entries,
        ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_entries_by_number, 6,
        ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_entries,
        ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_strings[idx].get();
}
bool ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy ExtensionTelemetryReportRequest_ExtensionInfo::NO_POLICY;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy ExtensionTelemetryReportRequest_ExtensionInfo::INSTALLATION_ALLOWED;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy ExtensionTelemetryReportRequest_ExtensionInfo::INSTALLATION_BLOCKED;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy ExtensionTelemetryReportRequest_ExtensionInfo::INSTALLATION_FORCED;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy ExtensionTelemetryReportRequest_ExtensionInfo::INSTALLATION_RECOMMENDED;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy ExtensionTelemetryReportRequest_ExtensionInfo::INSTALLATION_REMOVED;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy ExtensionTelemetryReportRequest_ExtensionInfo::InstallationPolicy_MIN;
constexpr ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy ExtensionTelemetryReportRequest_ExtensionInfo::InstallationPolicy_MAX;
constexpr int ExtensionTelemetryReportRequest_ExtensionInfo::InstallationPolicy_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_strings[3] = {};

static const char ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_names[] = "HTTP_HTTPS"
                                                                                                                           "UNSPECIFIED"
                                                                                                                           "WEBSOCKET";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_entries[]
    = {
          { { ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_names + 0, 10 }, 1 },
          { { ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_names + 10, 11 }, 0 },
          { { ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_names + 21, 9 }, 2 },
      };

static const int ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_entries_by_number[] = {
    1, // 0 -> UNSPECIFIED
    0, // 1 -> HTTP_HTTPS
    2, // 2 -> WEBSOCKET
};

const std::string& ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_Name(
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_entries,
        ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_entries_by_number, 3,
        ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_entries,
        ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_strings[idx].get();
}
bool ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::UNSPECIFIED;
constexpr ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::HTTP_HTTPS;
constexpr ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::WEBSOCKET;
constexpr ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::ProtocolType_MIN;
constexpr ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::ProtocolType_MAX;
constexpr int ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::ProtocolType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_strings[3] = {};

static const char ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_names[] = "CONTACT_INITIATOR_UNSPECIFIED"
                                                                                                                               "CONTENT_SCRIPT"
                                                                                                                               "EXTENSION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_entries[]
    = {
          { { ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_names + 0, 29 }, 0 },
          { { ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_names + 29, 14 }, 2 },
          { { ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_names + 43, 9 }, 1 },
      };

static const int ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_entries_by_number[] = {
    0, // 0 -> CONTACT_INITIATOR_UNSPECIFIED
    2, // 1 -> EXTENSION
    1, // 2 -> CONTENT_SCRIPT
};

const std::string& ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_Name(
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_entries,
        ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_entries_by_number, 3,
        ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_entries,
        ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_strings[idx].get();
}
bool ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::CONTACT_INITIATOR_UNSPECIFIED;
constexpr ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::EXTENSION;
constexpr ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::CONTENT_SCRIPT;
constexpr ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::ContactInitiator_MIN;
constexpr ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::ContactInitiator_MAX;
constexpr int ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::ContactInitiator_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_strings[5] = {};

static const char ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_names[]
    = "GMAIL"
      "GSUITE"
      "NON_GAIA_ENTERPRISE"
      "SAVED_PASSWORD"
      "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_entries[]
    = {
          { { ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_names + 0, 5 }, 2 },
          { { ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_names + 5, 6 }, 1 },
          { { ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_names + 11, 19 },
              3 },
          { { ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_names + 30, 14 },
              4 },
          { { ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_names + 44, 7 },
              0 },
      };

static const int
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_entries_by_number[]
    = {
          4, // 0 -> UNKNOWN
          1, // 1 -> GSUITE
          0, // 2 -> GMAIL
          2, // 3 -> NON_GAIA_ENTERPRISE
          3, // 4 -> SAVED_PASSWORD
      };

const std::string& ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_Name(
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_entries,
        ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_entries_by_number, 5,
        ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_entries,
        ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_entries_by_number, 5,
        value);
    return idx == -1
        ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
        : ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_strings[idx].get();
}
bool ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_entries, 5, name,
        &int_value);
    if (success) {
        *value = static_cast<ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType>(
            int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::UNKNOWN;
constexpr ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::GSUITE;
constexpr ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::GMAIL;
constexpr ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::NON_GAIA_ENTERPRISE;
constexpr ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::SAVED_PASSWORD;
constexpr ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::AccountType_MIN;
constexpr ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::AccountType_MAX;
constexpr int ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::AccountType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_strings[5] = {};

static const char ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_names[] = "API_METHOD_UNSPECIFIED"
                                                                                             "CAPTURE_VISIBLE_TAB"
                                                                                             "CREATE"
                                                                                             "REMOVE"
                                                                                             "UPDATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_entries[] = {
    { { ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_names + 0, 22 }, 0 },
    { { ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_names + 22, 19 }, 4 },
    { { ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_names + 41, 6 }, 1 },
    { { ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_names + 47, 6 }, 3 },
    { { ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_names + 53, 6 }, 2 },
};

static const int ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_entries_by_number[] = {
    0, // 0 -> API_METHOD_UNSPECIFIED
    2, // 1 -> CREATE
    4, // 2 -> UPDATE
    3, // 3 -> REMOVE
    1, // 4 -> CAPTURE_VISIBLE_TAB
};

const std::string& ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_Name(ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_entries,
        ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_entries_by_number, 5,
        ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_entries,
        ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_strings[idx].get();
}
bool ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::API_METHOD_UNSPECIFIED;
constexpr ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::CREATE;
constexpr ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::UPDATE;
constexpr ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::REMOVE;
constexpr ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::CAPTURE_VISIBLE_TAB;
constexpr ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::ApiMethod_MIN;
constexpr ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::ApiMethod_MAX;
constexpr int ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::ApiMethod_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_strings[2] = {};

static const char ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_names[] = "ACTION_TYPE_UNSPECIFIED"
                                                                                                                  "REDIRECT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_entries[] = {
    { { ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_names + 0, 23 }, 0 },
    { { ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_names + 23, 8 }, 1 },
};

static const int ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_entries_by_number[] = {
    0, // 0 -> ACTION_TYPE_UNSPECIFIED
    1, // 1 -> REDIRECT
};

const std::string& ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_Name(
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_entries,
        ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_entries_by_number, 2,
        ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_entries,
        ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_strings[idx].get();
}
bool ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::ACTION_TYPE_UNSPECIFIED;
constexpr ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::REDIRECT;
constexpr ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::ActionType_MIN;
constexpr ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::ActionType_MAX;
constexpr int ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::ActionType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_strings[4] = {};

static const char ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_names[] = "FULLY_TRUSTED"
                                                                                               "LOW"
                                                                                               "NONE"
                                                                                               "TRUSTED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_entries[] = {
    { { ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_names + 0, 13 }, 3 },
    { { ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_names + 13, 3 }, 1 },
    { { ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_names + 16, 4 }, 0 },
    { { ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_names + 20, 7 }, 2 },
};

static const int ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_entries_by_number[] = {
    2, // 0 -> NONE
    1, // 1 -> LOW
    3, // 2 -> TRUSTED
    0, // 3 -> FULLY_TRUSTED
};

const std::string& ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_Name(
    ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_entries,
            ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_entries_by_number, 4,
            ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_entries,
        ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_strings[idx].get();
}
bool ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness ExtensionTelemetryReportRequest::NONE;
constexpr ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness ExtensionTelemetryReportRequest::LOW;
constexpr ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness ExtensionTelemetryReportRequest::TRUSTED;
constexpr ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness ExtensionTelemetryReportRequest::FULLY_TRUSTED;
constexpr ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness ExtensionTelemetryReportRequest::ManagementAuthorityTrustworthiness_MIN;
constexpr ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness ExtensionTelemetryReportRequest::ManagementAuthorityTrustworthiness_MAX;
constexpr int ExtensionTelemetryReportRequest::ManagementAuthorityTrustworthiness_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionTelemetryReportRequest_ManagementAuthority_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExtensionTelemetryReportRequest_ManagementAuthority_strings[5] = {};

static const char ExtensionTelemetryReportRequest_ManagementAuthority_names[] = "MANAGEMENT_AUTHORITY_FULLY_TRUSTED"
                                                                                "MANAGEMENT_AUTHORITY_LOW"
                                                                                "MANAGEMENT_AUTHORITY_NONE"
                                                                                "MANAGEMENT_AUTHORITY_TRUSTED"
                                                                                "MANAGEMENT_AUTHORITY_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionTelemetryReportRequest_ManagementAuthority_entries[] = {
    { { ExtensionTelemetryReportRequest_ManagementAuthority_names + 0, 34 }, 4 },
    { { ExtensionTelemetryReportRequest_ManagementAuthority_names + 34, 24 }, 2 },
    { { ExtensionTelemetryReportRequest_ManagementAuthority_names + 58, 25 }, 1 },
    { { ExtensionTelemetryReportRequest_ManagementAuthority_names + 83, 28 }, 3 },
    { { ExtensionTelemetryReportRequest_ManagementAuthority_names + 111, 32 }, 0 },
};

static const int ExtensionTelemetryReportRequest_ManagementAuthority_entries_by_number[] = {
    4, // 0 -> MANAGEMENT_AUTHORITY_UNSPECIFIED
    2, // 1 -> MANAGEMENT_AUTHORITY_NONE
    1, // 2 -> MANAGEMENT_AUTHORITY_LOW
    3, // 3 -> MANAGEMENT_AUTHORITY_TRUSTED
    0, // 4 -> MANAGEMENT_AUTHORITY_FULLY_TRUSTED
};

const std::string& ExtensionTelemetryReportRequest_ManagementAuthority_Name(ExtensionTelemetryReportRequest_ManagementAuthority value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(ExtensionTelemetryReportRequest_ManagementAuthority_entries,
        ExtensionTelemetryReportRequest_ManagementAuthority_entries_by_number, 5, ExtensionTelemetryReportRequest_ManagementAuthority_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        ExtensionTelemetryReportRequest_ManagementAuthority_entries, ExtensionTelemetryReportRequest_ManagementAuthority_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ExtensionTelemetryReportRequest_ManagementAuthority_strings[idx].get();
}
bool ExtensionTelemetryReportRequest_ManagementAuthority_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionTelemetryReportRequest_ManagementAuthority* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ExtensionTelemetryReportRequest_ManagementAuthority_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<ExtensionTelemetryReportRequest_ManagementAuthority>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionTelemetryReportRequest_ManagementAuthority ExtensionTelemetryReportRequest::MANAGEMENT_AUTHORITY_UNSPECIFIED;
constexpr ExtensionTelemetryReportRequest_ManagementAuthority ExtensionTelemetryReportRequest::MANAGEMENT_AUTHORITY_NONE;
constexpr ExtensionTelemetryReportRequest_ManagementAuthority ExtensionTelemetryReportRequest::MANAGEMENT_AUTHORITY_LOW;
constexpr ExtensionTelemetryReportRequest_ManagementAuthority ExtensionTelemetryReportRequest::MANAGEMENT_AUTHORITY_TRUSTED;
constexpr ExtensionTelemetryReportRequest_ManagementAuthority ExtensionTelemetryReportRequest::MANAGEMENT_AUTHORITY_FULLY_TRUSTED;
constexpr ExtensionTelemetryReportRequest_ManagementAuthority ExtensionTelemetryReportRequest::ManagementAuthority_MIN;
constexpr ExtensionTelemetryReportRequest_ManagementAuthority ExtensionTelemetryReportRequest::ManagementAuthority_MAX;
constexpr int ExtensionTelemetryReportRequest::ManagementAuthority_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string>
    ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_strings[3] = {};

static const char ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_names[] = "MALWARE"
                                                                                                                   "NONE"
                                                                                                                   "UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_entries[] = {
    { { ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_names + 0, 7 }, 2 },
    { { ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_names + 7, 4 }, 1 },
    { { ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_names + 11, 11 }, 0 },
};

static const int ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_entries_by_number[] = {
    2, // 0 -> UNSPECIFIED
    1, // 1 -> NONE
    0, // 2 -> MALWARE
};

const std::string& ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_Name(
    ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_entries,
        ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_entries_by_number, 3,
        ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_entries,
        ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString()
                     : ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_strings[idx].get();
}
bool ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
        ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType
    ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::UNSPECIFIED;
constexpr ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType
    ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::NONE;
constexpr ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType
    ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::MALWARE;
constexpr ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType
    ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::OffstoreExtensionVerdictType_MIN;
constexpr ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType
    ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::OffstoreExtensionVerdictType_MAX;
constexpr int ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::OffstoreExtensionVerdictType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PreClassificationCheckResult_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PreClassificationCheckResult_strings[20] = {};

static const char PreClassificationCheckResult_names[] = "CLASSIFY"
                                                         "DEPRECATED_NO_CLASSIFY_NOT_HTTP_URL"
                                                         "NO_CLASSIFY_ALLOWLISTED_BY_POLICY"
                                                         "NO_CLASSIFY_CANCEL"
                                                         "NO_CLASSIFY_CHROME_UI_PAGE"
                                                         "NO_CLASSIFY_HAS_DELAYED_WARNING"
                                                         "NO_CLASSIFY_KILLSWITCH"
                                                         "NO_CLASSIFY_LOCAL_RESOURCE"
                                                         "NO_CLASSIFY_MATCH_CSD_ALLOWLIST"
                                                         "NO_CLASSIFY_MATCH_HC_ALLOWLIST"
                                                         "NO_CLASSIFY_MAX"
                                                         "NO_CLASSIFY_NO_DATABASE_MANAGER"
                                                         "NO_CLASSIFY_OFF_THE_RECORD"
                                                         "NO_CLASSIFY_PRIVATE_IP"
                                                         "NO_CLASSIFY_RESULT_FROM_CACHE"
                                                         "NO_CLASSIFY_SCHEME_NOT_SUPPORTED"
                                                         "NO_CLASSIFY_TOO_MANY_REPORTS"
                                                         "NO_CLASSIFY_UNSUPPORTED_MIME_TYPE"
                                                         "OBSOLETE_NO_CLASSIFY_NOT_ALLOWED_BY_POLICY"
                                                         "OBSOLETE_NO_CLASSIFY_PROXY_FETCH";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PreClassificationCheckResult_entries[] = {
    { { PreClassificationCheckResult_names + 0, 8 }, 13 },
    { { PreClassificationCheckResult_names + 8, 35 }, 10 },
    { { PreClassificationCheckResult_names + 43, 33 }, 12 },
    { { PreClassificationCheckResult_names + 76, 18 }, 8 },
    { { PreClassificationCheckResult_names + 94, 26 }, 16 },
    { { PreClassificationCheckResult_names + 120, 31 }, 14 },
    { { PreClassificationCheckResult_names + 151, 22 }, 7 },
    { { PreClassificationCheckResult_names + 173, 26 }, 15 },
    { { PreClassificationCheckResult_names + 199, 31 }, 3 },
    { { PreClassificationCheckResult_names + 230, 30 }, 18 },
    { { PreClassificationCheckResult_names + 260, 15 }, 19 },
    { { PreClassificationCheckResult_names + 275, 31 }, 6 },
    { { PreClassificationCheckResult_names + 306, 26 }, 2 },
    { { PreClassificationCheckResult_names + 332, 22 }, 1 },
    { { PreClassificationCheckResult_names + 354, 29 }, 9 },
    { { PreClassificationCheckResult_names + 383, 32 }, 11 },
    { { PreClassificationCheckResult_names + 415, 28 }, 4 },
    { { PreClassificationCheckResult_names + 443, 33 }, 5 },
    { { PreClassificationCheckResult_names + 476, 42 }, 17 },
    { { PreClassificationCheckResult_names + 518, 32 }, 0 },
};

static const int PreClassificationCheckResult_entries_by_number[] = {
    19, // 0 -> OBSOLETE_NO_CLASSIFY_PROXY_FETCH
    13, // 1 -> NO_CLASSIFY_PRIVATE_IP
    12, // 2 -> NO_CLASSIFY_OFF_THE_RECORD
    8, // 3 -> NO_CLASSIFY_MATCH_CSD_ALLOWLIST
    16, // 4 -> NO_CLASSIFY_TOO_MANY_REPORTS
    17, // 5 -> NO_CLASSIFY_UNSUPPORTED_MIME_TYPE
    11, // 6 -> NO_CLASSIFY_NO_DATABASE_MANAGER
    6, // 7 -> NO_CLASSIFY_KILLSWITCH
    3, // 8 -> NO_CLASSIFY_CANCEL
    14, // 9 -> NO_CLASSIFY_RESULT_FROM_CACHE
    1, // 10 -> DEPRECATED_NO_CLASSIFY_NOT_HTTP_URL
    15, // 11 -> NO_CLASSIFY_SCHEME_NOT_SUPPORTED
    2, // 12 -> NO_CLASSIFY_ALLOWLISTED_BY_POLICY
    0, // 13 -> CLASSIFY
    5, // 14 -> NO_CLASSIFY_HAS_DELAYED_WARNING
    7, // 15 -> NO_CLASSIFY_LOCAL_RESOURCE
    4, // 16 -> NO_CLASSIFY_CHROME_UI_PAGE
    18, // 17 -> OBSOLETE_NO_CLASSIFY_NOT_ALLOWED_BY_POLICY
    9, // 18 -> NO_CLASSIFY_MATCH_HC_ALLOWLIST
    10, // 19 -> NO_CLASSIFY_MAX
};

const std::string& PreClassificationCheckResult_Name(PreClassificationCheckResult value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        PreClassificationCheckResult_entries, PreClassificationCheckResult_entries_by_number, 20, PreClassificationCheckResult_strings);
    (void)dummy;
    int idx
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(PreClassificationCheckResult_entries, PreClassificationCheckResult_entries_by_number, 20, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : PreClassificationCheckResult_strings[idx].get();
}
bool PreClassificationCheckResult_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PreClassificationCheckResult* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(PreClassificationCheckResult_entries, 20, name, &int_value);
    if (success) {
        *value = static_cast<PreClassificationCheckResult>(int_value);
    }
    return success;
}
bool PhishingDetectorResult_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PhishingDetectorResult_strings[11] = {};

static const char PhishingDetectorResult_names[] = "CLASSIFICATION_CANCELLED"
                                                   "CLASSIFICATION_SUCCESS"
                                                   "CLASSIFIER_NOT_READY"
                                                   "DOM_EXTRACTION_FAILED"
                                                   "FORWARD_BACK_TRANSITION"
                                                   "INVALID_DOCUMENT_LOADER"
                                                   "INVALID_SCORE"
                                                   "INVALID_URL_FORMAT_REQUEST"
                                                   "TERM_EXTRACTION_FAILED"
                                                   "URL_FEATURE_EXTRACTION_FAILED"
                                                   "VISUAL_EXTRACTION_FAILED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PhishingDetectorResult_entries[] = {
    { { PhishingDetectorResult_names + 0, 24 }, 2 },
    { { PhishingDetectorResult_names + 24, 22 }, 0 },
    { { PhishingDetectorResult_names + 46, 20 }, 1 },
    { { PhishingDetectorResult_names + 66, 21 }, 8 },
    { { PhishingDetectorResult_names + 87, 23 }, 3 },
    { { PhishingDetectorResult_names + 110, 23 }, 6 },
    { { PhishingDetectorResult_names + 133, 13 }, 4 },
    { { PhishingDetectorResult_names + 146, 26 }, 5 },
    { { PhishingDetectorResult_names + 172, 22 }, 9 },
    { { PhishingDetectorResult_names + 194, 29 }, 7 },
    { { PhishingDetectorResult_names + 223, 24 }, 10 },
};

static const int PhishingDetectorResult_entries_by_number[] = {
    1, // 0 -> CLASSIFICATION_SUCCESS
    2, // 1 -> CLASSIFIER_NOT_READY
    0, // 2 -> CLASSIFICATION_CANCELLED
    4, // 3 -> FORWARD_BACK_TRANSITION
    6, // 4 -> INVALID_SCORE
    7, // 5 -> INVALID_URL_FORMAT_REQUEST
    5, // 6 -> INVALID_DOCUMENT_LOADER
    9, // 7 -> URL_FEATURE_EXTRACTION_FAILED
    3, // 8 -> DOM_EXTRACTION_FAILED
    8, // 9 -> TERM_EXTRACTION_FAILED
    10, // 10 -> VISUAL_EXTRACTION_FAILED
};

const std::string& PhishingDetectorResult_Name(PhishingDetectorResult value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        PhishingDetectorResult_entries, PhishingDetectorResult_entries_by_number, 11, PhishingDetectorResult_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(PhishingDetectorResult_entries, PhishingDetectorResult_entries_by_number, 11, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : PhishingDetectorResult_strings[idx].get();
}
bool PhishingDetectorResult_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PhishingDetectorResult* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(PhishingDetectorResult_entries, 11, name, &int_value);
    if (success) {
        *value = static_cast<PhishingDetectorResult>(int_value);
    }
    return success;
}
bool ClientSideDetectionType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientSideDetectionType_strings[7] = {};

static const char ClientSideDetectionType_names[] = "CLIENT_SIDE_DETECTION_TYPE_UNSPECIFIED"
                                                    "FORCE_REQUEST"
                                                    "KEYBOARD_LOCK_REQUESTED"
                                                    "NOTIFICATION_PERMISSION_PROMPT"
                                                    "POINTER_LOCK_REQUESTED"
                                                    "TRIGGER_MODELS"
                                                    "VIBRATION_API";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientSideDetectionType_entries[] = {
    { { ClientSideDetectionType_names + 0, 38 }, 0 },
    { { ClientSideDetectionType_names + 38, 13 }, 1 },
    { { ClientSideDetectionType_names + 51, 23 }, 4 },
    { { ClientSideDetectionType_names + 74, 30 }, 3 },
    { { ClientSideDetectionType_names + 104, 22 }, 5 },
    { { ClientSideDetectionType_names + 126, 14 }, 2 },
    { { ClientSideDetectionType_names + 140, 13 }, 6 },
};

static const int ClientSideDetectionType_entries_by_number[] = {
    0, // 0 -> CLIENT_SIDE_DETECTION_TYPE_UNSPECIFIED
    1, // 1 -> FORCE_REQUEST
    5, // 2 -> TRIGGER_MODELS
    3, // 3 -> NOTIFICATION_PERMISSION_PROMPT
    2, // 4 -> KEYBOARD_LOCK_REQUESTED
    4, // 5 -> POINTER_LOCK_REQUESTED
    6, // 6 -> VIBRATION_API
};

const std::string& ClientSideDetectionType_Name(ClientSideDetectionType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ClientSideDetectionType_entries, ClientSideDetectionType_entries_by_number, 7, ClientSideDetectionType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientSideDetectionType_entries, ClientSideDetectionType_entries_by_number, 7, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientSideDetectionType_strings[idx].get();
}
bool ClientSideDetectionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientSideDetectionType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientSideDetectionType_entries, 7, name, &int_value);
    if (success) {
        *value = static_cast<ClientSideDetectionType>(int_value);
    }
    return success;
}

// ===================================================================

class ChromeUserPopulation_PageLoadToken::_Internal {
public:
    using HasBits = decltype(std::declval<ChromeUserPopulation_PageLoadToken>()._impl_._has_bits_);
    static void set_has_token_source(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_token_time_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_token_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ChromeUserPopulation_PageLoadToken::ChromeUserPopulation_PageLoadToken(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ChromeUserPopulation.PageLoadToken)
}
ChromeUserPopulation_PageLoadToken::ChromeUserPopulation_PageLoadToken(const ChromeUserPopulation_PageLoadToken& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ChromeUserPopulation_PageLoadToken* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.token_value_) {},
        decltype(_impl_.token_time_msec_) {}, decltype(_impl_.token_source_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.token_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_token_value()) {
        _this->_impl_.token_value_.Set(from._internal_token_value(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.token_time_msec_, &from._impl_.token_time_msec_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.token_source_) - reinterpret_cast<char*>(&_impl_.token_time_msec_)) + sizeof(_impl_.token_source_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ChromeUserPopulation.PageLoadToken)
}

inline void ChromeUserPopulation_PageLoadToken::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.token_value_) {},
        decltype(_impl_.token_time_msec_) { int64_t { 0 } }, decltype(_impl_.token_source_) { 0 } };
    _impl_.token_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChromeUserPopulation_PageLoadToken::~ChromeUserPopulation_PageLoadToken()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ChromeUserPopulation.PageLoadToken)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ChromeUserPopulation_PageLoadToken::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.token_value_.Destroy();
}

void ChromeUserPopulation_PageLoadToken::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ChromeUserPopulation_PageLoadToken::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ChromeUserPopulation.PageLoadToken)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.token_value_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.token_time_msec_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.token_source_) - reinterpret_cast<char*>(&_impl_.token_time_msec_))
                + sizeof(_impl_.token_source_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ChromeUserPopulation_PageLoadToken::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ChromeUserPopulation.PageLoadToken.TokenSource token_source = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ChromeUserPopulation_PageLoadToken_TokenSource_IsValid(val))) {
                    _internal_set_token_source(static_cast<::safe_browsing::ChromeUserPopulation_PageLoadToken_TokenSource>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 token_time_msec = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_token_time_msec(&has_bits);
                _impl_.token_time_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes token_value = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_token_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ChromeUserPopulation_PageLoadToken::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ChromeUserPopulation.PageLoadToken)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ChromeUserPopulation.PageLoadToken.TokenSource token_source = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_token_source(), target);
    }

    // optional int64 token_time_msec = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_token_time_msec(), target);
    }

    // optional bytes token_value = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_token_value(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ChromeUserPopulation.PageLoadToken)
    return target;
}

size_t ChromeUserPopulation_PageLoadToken::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ChromeUserPopulation.PageLoadToken)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional bytes token_value = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_token_value());
        }

        // optional int64 token_time_msec = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_token_time_msec());
        }

        // optional .safe_browsing.ChromeUserPopulation.PageLoadToken.TokenSource token_source = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_token_source());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ChromeUserPopulation_PageLoadToken::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ChromeUserPopulation_PageLoadToken*>(&from));
}

void ChromeUserPopulation_PageLoadToken::MergeFrom(const ChromeUserPopulation_PageLoadToken& from)
{
    ChromeUserPopulation_PageLoadToken* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ChromeUserPopulation.PageLoadToken)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_token_value(from._internal_token_value());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.token_time_msec_ = from._impl_.token_time_msec_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.token_source_ = from._impl_.token_source_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeUserPopulation_PageLoadToken::CopyFrom(const ChromeUserPopulation_PageLoadToken& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ChromeUserPopulation.PageLoadToken)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ChromeUserPopulation_PageLoadToken::IsInitialized() const
{
    return true;
}

void ChromeUserPopulation_PageLoadToken::InternalSwap(ChromeUserPopulation_PageLoadToken* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.token_value_, lhs_arena, &other->_impl_.token_value_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ChromeUserPopulation_PageLoadToken, _impl_.token_source_)
        + sizeof(ChromeUserPopulation_PageLoadToken::_impl_.token_source_)
        - PROTOBUF_FIELD_OFFSET(ChromeUserPopulation_PageLoadToken, _impl_.token_time_msec_)>(
        reinterpret_cast<char*>(&_impl_.token_time_msec_), reinterpret_cast<char*>(&other->_impl_.token_time_msec_));
}

std::string ChromeUserPopulation_PageLoadToken::GetTypeName() const
{
    return "safe_browsing.ChromeUserPopulation.PageLoadToken";
}

// ===================================================================

class ChromeUserPopulation::_Internal {
public:
    using HasBits = decltype(std::declval<ChromeUserPopulation>()._impl_._has_bits_);
    static void set_has_user_population(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_is_history_sync_enabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_profile_management_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_is_under_advanced_protection(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_is_incognito(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_is_mbb_enabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_user_agent(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_number_of_profiles(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_number_of_loaded_profiles(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_is_aesb_enabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_aesb_last_update_time_windows_epoch_micros(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_is_signed_in(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
};

ChromeUserPopulation::ChromeUserPopulation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ChromeUserPopulation)
}
ChromeUserPopulation::ChromeUserPopulation(const ChromeUserPopulation& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ChromeUserPopulation* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.finch_active_groups_) { from._impl_.finch_active_groups_ }, decltype(_impl_.page_load_tokens_) { from._impl_.page_load_tokens_ },
        decltype(_impl_.user_agent_) {}, decltype(_impl_.user_population_) {}, decltype(_impl_.profile_management_status_) {},
        decltype(_impl_.is_history_sync_enabled_) {}, decltype(_impl_.is_under_advanced_protection_) {}, decltype(_impl_.is_incognito_) {},
        decltype(_impl_.is_mbb_enabled_) {}, decltype(_impl_.number_of_profiles_) {}, decltype(_impl_.number_of_loaded_profiles_) {},
        decltype(_impl_.is_aesb_enabled_) {}, decltype(_impl_.is_signed_in_) {}, decltype(_impl_.aesb_last_update_time_windows_epoch_micros_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.user_agent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_agent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_user_agent()) {
        _this->_impl_.user_agent_.Set(from._internal_user_agent(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.user_population_, &from._impl_.user_population_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.aesb_last_update_time_windows_epoch_micros_) - reinterpret_cast<char*>(&_impl_.user_population_))
            + sizeof(_impl_.aesb_last_update_time_windows_epoch_micros_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ChromeUserPopulation)
}

inline void ChromeUserPopulation::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.finch_active_groups_) { arena },
        decltype(_impl_.page_load_tokens_) { arena }, decltype(_impl_.user_agent_) {}, decltype(_impl_.user_population_) { 0 },
        decltype(_impl_.profile_management_status_) { 0 }, decltype(_impl_.is_history_sync_enabled_) { false },
        decltype(_impl_.is_under_advanced_protection_) { false }, decltype(_impl_.is_incognito_) { false }, decltype(_impl_.is_mbb_enabled_) { false },
        decltype(_impl_.number_of_profiles_) { 0 }, decltype(_impl_.number_of_loaded_profiles_) { 0 }, decltype(_impl_.is_aesb_enabled_) { false },
        decltype(_impl_.is_signed_in_) { false }, decltype(_impl_.aesb_last_update_time_windows_epoch_micros_) { int64_t { 0 } } };
    _impl_.user_agent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_agent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChromeUserPopulation::~ChromeUserPopulation()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ChromeUserPopulation)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ChromeUserPopulation::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.finch_active_groups_.~RepeatedPtrField();
    _impl_.page_load_tokens_.~RepeatedPtrField();
    _impl_.user_agent_.Destroy();
}

void ChromeUserPopulation::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ChromeUserPopulation::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ChromeUserPopulation)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.finch_active_groups_.Clear();
    _impl_.page_load_tokens_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.user_agent_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x000000feu) {
        ::memset(&_impl_.user_population_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.number_of_profiles_) - reinterpret_cast<char*>(&_impl_.user_population_))
                + sizeof(_impl_.number_of_profiles_));
    }
    if (cached_has_bits & 0x00000f00u) {
        ::memset(&_impl_.number_of_loaded_profiles_, 0,
            static_cast<size_t>(
                reinterpret_cast<char*>(&_impl_.aesb_last_update_time_windows_epoch_micros_) - reinterpret_cast<char*>(&_impl_.number_of_loaded_profiles_))
                + sizeof(_impl_.aesb_last_update_time_windows_epoch_micros_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ChromeUserPopulation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ChromeUserPopulation.UserPopulation user_population = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ChromeUserPopulation_UserPopulation_IsValid(val))) {
                    _internal_set_user_population(static_cast<::safe_browsing::ChromeUserPopulation_UserPopulation>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional bool is_history_sync_enabled = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_is_history_sync_enabled(&has_bits);
                _impl_.is_history_sync_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string finch_active_groups = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_finch_active_groups();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ChromeUserPopulation.ProfileManagementStatus profile_management_status = 5 [default = UNKNOWN];
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ChromeUserPopulation_ProfileManagementStatus_IsValid(val))) {
                    _internal_set_profile_management_status(static_cast<::safe_browsing::ChromeUserPopulation_ProfileManagementStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional bool is_under_advanced_protection = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_is_under_advanced_protection(&has_bits);
                _impl_.is_under_advanced_protection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_incognito = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_is_incognito(&has_bits);
                _impl_.is_incognito_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_mbb_enabled = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_is_mbb_enabled(&has_bits);
                _impl_.is_mbb_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string user_agent = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                auto str = _internal_mutable_user_agent();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 number_of_profiles = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                _Internal::set_has_number_of_profiles(&has_bits);
                _impl_.number_of_profiles_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 number_of_loaded_profiles = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
                _Internal::set_has_number_of_loaded_profiles(&has_bits);
                _impl_.number_of_loaded_profiles_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ChromeUserPopulation.PageLoadToken page_load_tokens = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_page_load_tokens(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<114>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool is_aesb_enabled = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
                _Internal::set_has_is_aesb_enabled(&has_bits);
                _impl_.is_aesb_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 aesb_last_update_time_windows_epoch_micros = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
                _Internal::set_has_aesb_last_update_time_windows_epoch_micros(&has_bits);
                _impl_.aesb_last_update_time_windows_epoch_micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_signed_in = 18;
        case 18:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
                _Internal::set_has_is_signed_in(&has_bits);
                _impl_.is_signed_in_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ChromeUserPopulation::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ChromeUserPopulation)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ChromeUserPopulation.UserPopulation user_population = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_user_population(), target);
    }

    // optional bool is_history_sync_enabled = 2;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_history_sync_enabled(), target);
    }

    // repeated string finch_active_groups = 4;
    for (int i = 0, n = this->_internal_finch_active_groups_size(); i < n; i++) {
        const auto& s = this->_internal_finch_active_groups(i);
        target = stream->WriteString(4, s, target);
    }

    // optional .safe_browsing.ChromeUserPopulation.ProfileManagementStatus profile_management_status = 5 [default = UNKNOWN];
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_profile_management_status(), target);
    }

    // optional bool is_under_advanced_protection = 6;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_under_advanced_protection(), target);
    }

    // optional bool is_incognito = 7;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_is_incognito(), target);
    }

    // optional bool is_mbb_enabled = 8;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_is_mbb_enabled(), target);
    }

    // optional string user_agent = 9;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(9, this->_internal_user_agent(), target);
    }

    // optional int32 number_of_profiles = 10;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_number_of_profiles(), target);
    }

    // optional int32 number_of_loaded_profiles = 11;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_number_of_loaded_profiles(), target);
    }

    // repeated .safe_browsing.ChromeUserPopulation.PageLoadToken page_load_tokens = 14;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_page_load_tokens_size()); i < n; i++) {
        const auto& repfield = this->_internal_page_load_tokens(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(14, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bool is_aesb_enabled = 15;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_is_aesb_enabled(), target);
    }

    // optional int64 aesb_last_update_time_windows_epoch_micros = 16;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(16, this->_internal_aesb_last_update_time_windows_epoch_micros(), target);
    }

    // optional bool is_signed_in = 18;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_is_signed_in(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ChromeUserPopulation)
    return target;
}

size_t ChromeUserPopulation::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ChromeUserPopulation)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string finch_active_groups = 4;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.finch_active_groups_.size());
    for (int i = 0, n = _impl_.finch_active_groups_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.finch_active_groups_.Get(i));
    }

    // repeated .safe_browsing.ChromeUserPopulation.PageLoadToken page_load_tokens = 14;
    total_size += 1UL * this->_internal_page_load_tokens_size();
    for (const auto& msg : this->_impl_.page_load_tokens_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string user_agent = 9;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_user_agent());
        }

        // optional .safe_browsing.ChromeUserPopulation.UserPopulation user_population = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_user_population());
        }

        // optional .safe_browsing.ChromeUserPopulation.ProfileManagementStatus profile_management_status = 5 [default = UNKNOWN];
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_profile_management_status());
        }

        // optional bool is_history_sync_enabled = 2;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }

        // optional bool is_under_advanced_protection = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }

        // optional bool is_incognito = 7;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 1;
        }

        // optional bool is_mbb_enabled = 8;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + 1;
        }

        // optional int32 number_of_profiles = 10;
        if (cached_has_bits & 0x00000080u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_number_of_profiles());
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        // optional int32 number_of_loaded_profiles = 11;
        if (cached_has_bits & 0x00000100u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_number_of_loaded_profiles());
        }

        // optional bool is_aesb_enabled = 15;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + 1;
        }

        // optional bool is_signed_in = 18;
        if (cached_has_bits & 0x00000400u) {
            total_size += 2 + 1;
        }

        // optional int64 aesb_last_update_time_windows_epoch_micros = 16;
        if (cached_has_bits & 0x00000800u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_aesb_last_update_time_windows_epoch_micros());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ChromeUserPopulation::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ChromeUserPopulation*>(&from));
}

void ChromeUserPopulation::MergeFrom(const ChromeUserPopulation& from)
{
    ChromeUserPopulation* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ChromeUserPopulation)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.finch_active_groups_.MergeFrom(from._impl_.finch_active_groups_);
    _this->_impl_.page_load_tokens_.MergeFrom(from._impl_.page_load_tokens_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_user_agent(from._internal_user_agent());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.user_population_ = from._impl_.user_population_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.profile_management_status_ = from._impl_.profile_management_status_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.is_history_sync_enabled_ = from._impl_.is_history_sync_enabled_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.is_under_advanced_protection_ = from._impl_.is_under_advanced_protection_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.is_incognito_ = from._impl_.is_incognito_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.is_mbb_enabled_ = from._impl_.is_mbb_enabled_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.number_of_profiles_ = from._impl_.number_of_profiles_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00000f00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.number_of_loaded_profiles_ = from._impl_.number_of_loaded_profiles_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.is_aesb_enabled_ = from._impl_.is_aesb_enabled_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.is_signed_in_ = from._impl_.is_signed_in_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.aesb_last_update_time_windows_epoch_micros_ = from._impl_.aesb_last_update_time_windows_epoch_micros_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeUserPopulation::CopyFrom(const ChromeUserPopulation& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ChromeUserPopulation)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ChromeUserPopulation::IsInitialized() const
{
    return true;
}

void ChromeUserPopulation::InternalSwap(ChromeUserPopulation* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.finch_active_groups_.InternalSwap(&other->_impl_.finch_active_groups_);
    _impl_.page_load_tokens_.InternalSwap(&other->_impl_.page_load_tokens_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.user_agent_, lhs_arena, &other->_impl_.user_agent_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ChromeUserPopulation, _impl_.aesb_last_update_time_windows_epoch_micros_)
        + sizeof(ChromeUserPopulation::_impl_.aesb_last_update_time_windows_epoch_micros_)
        - PROTOBUF_FIELD_OFFSET(ChromeUserPopulation, _impl_.user_population_)>(
        reinterpret_cast<char*>(&_impl_.user_population_), reinterpret_cast<char*>(&other->_impl_.user_population_));
}

std::string ChromeUserPopulation::GetTypeName() const
{
    return "safe_browsing.ChromeUserPopulation";
}

// ===================================================================

class ImageFeatureEmbedding::_Internal {
public:
    using HasBits = decltype(std::declval<ImageFeatureEmbedding>()._impl_._has_bits_);
    static void set_has_embedding_model_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ImageFeatureEmbedding::ImageFeatureEmbedding(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ImageFeatureEmbedding)
}
ImageFeatureEmbedding::ImageFeatureEmbedding(const ImageFeatureEmbedding& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ImageFeatureEmbedding* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.embedding_value_) { from._impl_.embedding_value_ }, decltype(_impl_.embedding_model_version_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.embedding_model_version_ = from._impl_.embedding_model_version_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ImageFeatureEmbedding)
}

inline void ImageFeatureEmbedding::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.embedding_value_) { arena },
        decltype(_impl_.embedding_model_version_) { 0 } };
}

ImageFeatureEmbedding::~ImageFeatureEmbedding()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ImageFeatureEmbedding)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ImageFeatureEmbedding::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.embedding_value_.~RepeatedField();
}

void ImageFeatureEmbedding::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ImageFeatureEmbedding::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ImageFeatureEmbedding)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.embedding_value_.Clear();
    _impl_.embedding_model_version_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ImageFeatureEmbedding::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 embedding_model_version = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_embedding_model_version(&has_bits);
                _impl_.embedding_model_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated float embedding_value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_embedding_value(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
                    ptr += sizeof(float);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<21>(ptr));
            } else if (static_cast<uint8_t>(tag) == 18) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_embedding_value(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ImageFeatureEmbedding::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ImageFeatureEmbedding)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 embedding_model_version = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_embedding_model_version(), target);
    }

    // repeated float embedding_value = 2;
    for (int i = 0, n = this->_internal_embedding_value_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_embedding_value(i), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ImageFeatureEmbedding)
    return target;
}

size_t ImageFeatureEmbedding::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ImageFeatureEmbedding)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated float embedding_value = 2;
    {
        unsigned int count = static_cast<unsigned int>(this->_internal_embedding_value_size());
        size_t data_size = 4UL * count;
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_embedding_value_size());
        total_size += data_size;
    }

    // optional int32 embedding_model_version = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_embedding_model_version());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ImageFeatureEmbedding::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ImageFeatureEmbedding*>(&from));
}

void ImageFeatureEmbedding::MergeFrom(const ImageFeatureEmbedding& from)
{
    ImageFeatureEmbedding* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ImageFeatureEmbedding)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.embedding_value_.MergeFrom(from._impl_.embedding_value_);
    if (from._internal_has_embedding_model_version()) {
        _this->_internal_set_embedding_model_version(from._internal_embedding_model_version());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ImageFeatureEmbedding::CopyFrom(const ImageFeatureEmbedding& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ImageFeatureEmbedding)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ImageFeatureEmbedding::IsInitialized() const
{
    return true;
}

void ImageFeatureEmbedding::InternalSwap(ImageFeatureEmbedding* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.embedding_value_.InternalSwap(&other->_impl_.embedding_value_);
    swap(_impl_.embedding_model_version_, other->_impl_.embedding_model_version_);
}

std::string ImageFeatureEmbedding::GetTypeName() const
{
    return "safe_browsing.ImageFeatureEmbedding";
}

// ===================================================================

class LlamaTriggerRuleInfo::_Internal {
public:
    using HasBits = decltype(std::declval<LlamaTriggerRuleInfo>()._impl_._has_bits_);
    static void set_has_llama_trigger_rule_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_intelligent_scan(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

LlamaTriggerRuleInfo::LlamaTriggerRuleInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.LlamaTriggerRuleInfo)
}
LlamaTriggerRuleInfo::LlamaTriggerRuleInfo(const LlamaTriggerRuleInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LlamaTriggerRuleInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.llama_trigger_rule_id_) {}, decltype(_impl_.intelligent_scan_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.llama_trigger_rule_id_, &from._impl_.llama_trigger_rule_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.intelligent_scan_) - reinterpret_cast<char*>(&_impl_.llama_trigger_rule_id_))
            + sizeof(_impl_.intelligent_scan_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.LlamaTriggerRuleInfo)
}

inline void LlamaTriggerRuleInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.llama_trigger_rule_id_) { 0 },
        decltype(_impl_.intelligent_scan_) { false } };
}

LlamaTriggerRuleInfo::~LlamaTriggerRuleInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.LlamaTriggerRuleInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LlamaTriggerRuleInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LlamaTriggerRuleInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LlamaTriggerRuleInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.LlamaTriggerRuleInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.llama_trigger_rule_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.intelligent_scan_) - reinterpret_cast<char*>(&_impl_.llama_trigger_rule_id_))
                + sizeof(_impl_.intelligent_scan_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LlamaTriggerRuleInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 llama_trigger_rule_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_llama_trigger_rule_id(&has_bits);
                _impl_.llama_trigger_rule_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool intelligent_scan = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_intelligent_scan(&has_bits);
                _impl_.intelligent_scan_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LlamaTriggerRuleInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LlamaTriggerRuleInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 llama_trigger_rule_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_llama_trigger_rule_id(), target);
    }

    // optional bool intelligent_scan = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_intelligent_scan(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LlamaTriggerRuleInfo)
    return target;
}

size_t LlamaTriggerRuleInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.LlamaTriggerRuleInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int32 llama_trigger_rule_id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_llama_trigger_rule_id());
        }

        // optional bool intelligent_scan = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LlamaTriggerRuleInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LlamaTriggerRuleInfo*>(&from));
}

void LlamaTriggerRuleInfo::MergeFrom(const LlamaTriggerRuleInfo& from)
{
    LlamaTriggerRuleInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LlamaTriggerRuleInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.llama_trigger_rule_id_ = from._impl_.llama_trigger_rule_id_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.intelligent_scan_ = from._impl_.intelligent_scan_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LlamaTriggerRuleInfo::CopyFrom(const LlamaTriggerRuleInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LlamaTriggerRuleInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LlamaTriggerRuleInfo::IsInitialized() const
{
    return true;
}

void LlamaTriggerRuleInfo::InternalSwap(LlamaTriggerRuleInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(LlamaTriggerRuleInfo, _impl_.intelligent_scan_)
        + sizeof(LlamaTriggerRuleInfo::_impl_.intelligent_scan_) - PROTOBUF_FIELD_OFFSET(LlamaTriggerRuleInfo, _impl_.llama_trigger_rule_id_)>(
        reinterpret_cast<char*>(&_impl_.llama_trigger_rule_id_), reinterpret_cast<char*>(&other->_impl_.llama_trigger_rule_id_));
}

std::string LlamaTriggerRuleInfo::GetTypeName() const
{
    return "safe_browsing.LlamaTriggerRuleInfo";
}

// ===================================================================

class LlamaForcedTriggerInfo::_Internal {
public:
    using HasBits = decltype(std::declval<LlamaForcedTriggerInfo>()._impl_._has_bits_);
    static void set_has_intelligent_scan(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

LlamaForcedTriggerInfo::LlamaForcedTriggerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.LlamaForcedTriggerInfo)
}
LlamaForcedTriggerInfo::LlamaForcedTriggerInfo(const LlamaForcedTriggerInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LlamaForcedTriggerInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.llama_trigger_rule_infos_) { from._impl_.llama_trigger_rule_infos_ }, decltype(_impl_.intelligent_scan_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.intelligent_scan_ = from._impl_.intelligent_scan_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.LlamaForcedTriggerInfo)
}

inline void LlamaForcedTriggerInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.llama_trigger_rule_infos_) { arena },
        decltype(_impl_.intelligent_scan_) { false } };
}

LlamaForcedTriggerInfo::~LlamaForcedTriggerInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.LlamaForcedTriggerInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LlamaForcedTriggerInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.llama_trigger_rule_infos_.~RepeatedPtrField();
}

void LlamaForcedTriggerInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LlamaForcedTriggerInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.LlamaForcedTriggerInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.llama_trigger_rule_infos_.Clear();
    _impl_.intelligent_scan_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LlamaForcedTriggerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.LlamaTriggerRuleInfo llama_trigger_rule_infos = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_llama_trigger_rule_infos(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool intelligent_scan = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_intelligent_scan(&has_bits);
                _impl_.intelligent_scan_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LlamaForcedTriggerInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LlamaForcedTriggerInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.LlamaTriggerRuleInfo llama_trigger_rule_infos = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_llama_trigger_rule_infos_size()); i < n; i++) {
        const auto& repfield = this->_internal_llama_trigger_rule_infos(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool intelligent_scan = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_intelligent_scan(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LlamaForcedTriggerInfo)
    return target;
}

size_t LlamaForcedTriggerInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.LlamaForcedTriggerInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.LlamaTriggerRuleInfo llama_trigger_rule_infos = 1;
    total_size += 1UL * this->_internal_llama_trigger_rule_infos_size();
    for (const auto& msg : this->_impl_.llama_trigger_rule_infos_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional bool intelligent_scan = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + 1;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LlamaForcedTriggerInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LlamaForcedTriggerInfo*>(&from));
}

void LlamaForcedTriggerInfo::MergeFrom(const LlamaForcedTriggerInfo& from)
{
    LlamaForcedTriggerInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LlamaForcedTriggerInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.llama_trigger_rule_infos_.MergeFrom(from._impl_.llama_trigger_rule_infos_);
    if (from._internal_has_intelligent_scan()) {
        _this->_internal_set_intelligent_scan(from._internal_intelligent_scan());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LlamaForcedTriggerInfo::CopyFrom(const LlamaForcedTriggerInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LlamaForcedTriggerInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LlamaForcedTriggerInfo::IsInitialized() const
{
    return true;
}

void LlamaForcedTriggerInfo::InternalSwap(LlamaForcedTriggerInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.llama_trigger_rule_infos_.InternalSwap(&other->_impl_.llama_trigger_rule_infos_);
    swap(_impl_.intelligent_scan_, other->_impl_.intelligent_scan_);
}

std::string LlamaForcedTriggerInfo::GetTypeName() const
{
    return "safe_browsing.LlamaForcedTriggerInfo";
}

// ===================================================================

class ClientPhishingRequest_Feature::_Internal {
public:
    using HasBits = decltype(std::declval<ClientPhishingRequest_Feature>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
    }
};

ClientPhishingRequest_Feature::ClientPhishingRequest_Feature(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientPhishingRequest.Feature)
}
ClientPhishingRequest_Feature::ClientPhishingRequest_Feature(const ClientPhishingRequest_Feature& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientPhishingRequest_Feature* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {},
        decltype(_impl_.value_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _this->_impl_.value_ = from._impl_.value_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientPhishingRequest.Feature)
}

inline void ClientPhishingRequest_Feature::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {}, decltype(_impl_.value_) { 0 } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientPhishingRequest_Feature::~ClientPhishingRequest_Feature()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientPhishingRequest.Feature)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientPhishingRequest_Feature::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_.Destroy();
}

void ClientPhishingRequest_Feature::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientPhishingRequest_Feature::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientPhishingRequest.Feature)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.name_.ClearNonDefaultToEmpty();
    }
    _impl_.value_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientPhishingRequest_Feature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required double value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
                _Internal::set_has_value(&has_bits);
                _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
                ptr += sizeof(double);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientPhishingRequest_Feature::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientPhishingRequest.Feature)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // required double value = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_value(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientPhishingRequest.Feature)
    return target;
}

size_t ClientPhishingRequest_Feature::RequiredFieldsByteSizeFallback() const
{
    // @@protoc_insertion_point(required_fields_byte_size_fallback_start:safe_browsing.ClientPhishingRequest.Feature)
    size_t total_size = 0;

    if (_internal_has_name()) {
        // required string name = 1;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
    }

    if (_internal_has_value()) {
        // required double value = 2;
        total_size += 1 + 8;
    }

    return total_size;
}
size_t ClientPhishingRequest_Feature::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientPhishingRequest.Feature)
    size_t total_size = 0;

    if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) { // All required fields are present.
        // required string name = 1;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());

        // required double value = 2;
        total_size += 1 + 8;

    } else {
        total_size += RequiredFieldsByteSizeFallback();
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientPhishingRequest_Feature::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientPhishingRequest_Feature*>(&from));
}

void ClientPhishingRequest_Feature::MergeFrom(const ClientPhishingRequest_Feature& from)
{
    ClientPhishingRequest_Feature* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientPhishingRequest.Feature)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.value_ = from._impl_.value_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientPhishingRequest_Feature::CopyFrom(const ClientPhishingRequest_Feature& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientPhishingRequest.Feature)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientPhishingRequest_Feature::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    return true;
}

void ClientPhishingRequest_Feature::InternalSwap(ClientPhishingRequest_Feature* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    swap(_impl_.value_, other->_impl_.value_);
}

std::string ClientPhishingRequest_Feature::GetTypeName() const
{
    return "safe_browsing.ClientPhishingRequest.Feature";
}

// ===================================================================

class ClientPhishingRequest_CategoryScore::_Internal {
public:
    using HasBits = decltype(std::declval<ClientPhishingRequest_CategoryScore>()._impl_._has_bits_);
    static void set_has_label(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ClientPhishingRequest_CategoryScore::ClientPhishingRequest_CategoryScore(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientPhishingRequest.CategoryScore)
}
ClientPhishingRequest_CategoryScore::ClientPhishingRequest_CategoryScore(const ClientPhishingRequest_CategoryScore& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientPhishingRequest_CategoryScore* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.label_) {},
        decltype(_impl_.value_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_label()) {
        _this->_impl_.label_.Set(from._internal_label(), _this->GetArenaForAllocation());
    }
    _this->_impl_.value_ = from._impl_.value_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientPhishingRequest.CategoryScore)
}

inline void ClientPhishingRequest_CategoryScore::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.label_) {}, decltype(_impl_.value_) { 0 } };
    _impl_.label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientPhishingRequest_CategoryScore::~ClientPhishingRequest_CategoryScore()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientPhishingRequest.CategoryScore)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientPhishingRequest_CategoryScore::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.label_.Destroy();
}

void ClientPhishingRequest_CategoryScore::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientPhishingRequest_CategoryScore::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientPhishingRequest.CategoryScore)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.label_.ClearNonDefaultToEmpty();
    }
    _impl_.value_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientPhishingRequest_CategoryScore::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string label = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_label();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional float value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
                _Internal::set_has_value(&has_bits);
                _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientPhishingRequest_CategoryScore::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientPhishingRequest.CategoryScore)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string label = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_label(), target);
    }

    // optional float value = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_value(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientPhishingRequest.CategoryScore)
    return target;
}

size_t ClientPhishingRequest_CategoryScore::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientPhishingRequest.CategoryScore)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string label = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_label());
        }

        // optional float value = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 4;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientPhishingRequest_CategoryScore::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientPhishingRequest_CategoryScore*>(&from));
}

void ClientPhishingRequest_CategoryScore::MergeFrom(const ClientPhishingRequest_CategoryScore& from)
{
    ClientPhishingRequest_CategoryScore* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientPhishingRequest.CategoryScore)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_label(from._internal_label());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.value_ = from._impl_.value_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientPhishingRequest_CategoryScore::CopyFrom(const ClientPhishingRequest_CategoryScore& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientPhishingRequest.CategoryScore)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientPhishingRequest_CategoryScore::IsInitialized() const
{
    return true;
}

void ClientPhishingRequest_CategoryScore::InternalSwap(ClientPhishingRequest_CategoryScore* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.label_, lhs_arena, &other->_impl_.label_, rhs_arena);
    swap(_impl_.value_, other->_impl_.value_);
}

std::string ClientPhishingRequest_CategoryScore::GetTypeName() const
{
    return "safe_browsing.ClientPhishingRequest.CategoryScore";
}

// ===================================================================

class ClientPhishingRequest::_Internal {
public:
    using HasBits = decltype(std::declval<ClientPhishingRequest>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_obsolete_hash_prefix(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_client_score(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_is_phishing(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_dom_model_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static void set_has_model_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_obsolete_referrer_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_deprecated_model_filename(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::safe_browsing::ChromeUserPopulation& population(const ClientPhishingRequest* msg);
    static void set_has_population(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_is_dom_match(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_tflite_model_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static void set_has_is_tflite_match(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static const ::safe_browsing::VisualFeatures& visual_features(const ClientPhishingRequest* msg);
    static void set_has_visual_features(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_client_side_detection_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32768u;
    }
    static const ::safe_browsing::ImageFeatureEmbedding& image_feature_embedding(const ClientPhishingRequest* msg);
    static void set_has_image_feature_embedding(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_report_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 65536u;
    }
    static const ::safe_browsing::LlamaForcedTriggerInfo& llama_forced_trigger_info(const ClientPhishingRequest* msg);
    static void set_has_llama_forced_trigger_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000100) ^ 0x00000100) != 0;
    }
};

const ::safe_browsing::ChromeUserPopulation& ClientPhishingRequest::_Internal::population(const ClientPhishingRequest* msg)
{
    return *msg->_impl_.population_;
}
const ::safe_browsing::VisualFeatures& ClientPhishingRequest::_Internal::visual_features(const ClientPhishingRequest* msg)
{
    return *msg->_impl_.visual_features_;
}
const ::safe_browsing::ImageFeatureEmbedding& ClientPhishingRequest::_Internal::image_feature_embedding(const ClientPhishingRequest* msg)
{
    return *msg->_impl_.image_feature_embedding_;
}
const ::safe_browsing::LlamaForcedTriggerInfo& ClientPhishingRequest::_Internal::llama_forced_trigger_info(const ClientPhishingRequest* msg)
{
    return *msg->_impl_.llama_forced_trigger_info_;
}
ClientPhishingRequest::ClientPhishingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientPhishingRequest)
}
ClientPhishingRequest::ClientPhishingRequest(const ClientPhishingRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientPhishingRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.feature_map_) { from._impl_.feature_map_ }, decltype(_impl_.non_model_feature_map_) { from._impl_.non_model_feature_map_ },
        decltype(_impl_.shingle_hashes_) { from._impl_.shingle_hashes_ }, /*decltype(_impl_._shingle_hashes_cached_byte_size_)*/ { 0 },
        decltype(_impl_.referrer_chain_) { from._impl_.referrer_chain_ }, decltype(_impl_.tflite_model_scores_) { from._impl_.tflite_model_scores_ },
        decltype(_impl_.url_) {}, decltype(_impl_.obsolete_referrer_url_) {}, decltype(_impl_.obsolete_hash_prefix_) {},
        decltype(_impl_.deprecated_model_filename_) {}, decltype(_impl_.population_) { nullptr }, decltype(_impl_.visual_features_) { nullptr },
        decltype(_impl_.image_feature_embedding_) { nullptr }, decltype(_impl_.llama_forced_trigger_info_) { nullptr }, decltype(_impl_.client_score_) {},
        decltype(_impl_.model_version_) {}, decltype(_impl_.is_phishing_) {}, decltype(_impl_.is_dom_match_) {}, decltype(_impl_.is_tflite_match_) {},
        decltype(_impl_.tflite_model_version_) {}, decltype(_impl_.dom_model_version_) {}, decltype(_impl_.client_side_detection_type_) {},
        decltype(_impl_.report_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _impl_.obsolete_referrer_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_referrer_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_obsolete_referrer_url()) {
        _this->_impl_.obsolete_referrer_url_.Set(from._internal_obsolete_referrer_url(), _this->GetArenaForAllocation());
    }
    _impl_.obsolete_hash_prefix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_hash_prefix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_obsolete_hash_prefix()) {
        _this->_impl_.obsolete_hash_prefix_.Set(from._internal_obsolete_hash_prefix(), _this->GetArenaForAllocation());
    }
    _impl_.deprecated_model_filename_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_model_filename_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_deprecated_model_filename()) {
        _this->_impl_.deprecated_model_filename_.Set(from._internal_deprecated_model_filename(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_population()) {
        _this->_impl_.population_ = new ::safe_browsing::ChromeUserPopulation(*from._impl_.population_);
    }
    if (from._internal_has_visual_features()) {
        _this->_impl_.visual_features_ = new ::safe_browsing::VisualFeatures(*from._impl_.visual_features_);
    }
    if (from._internal_has_image_feature_embedding()) {
        _this->_impl_.image_feature_embedding_ = new ::safe_browsing::ImageFeatureEmbedding(*from._impl_.image_feature_embedding_);
    }
    if (from._internal_has_llama_forced_trigger_info()) {
        _this->_impl_.llama_forced_trigger_info_ = new ::safe_browsing::LlamaForcedTriggerInfo(*from._impl_.llama_forced_trigger_info_);
    }
    ::memcpy(&_impl_.client_score_, &from._impl_.client_score_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.report_type_) - reinterpret_cast<char*>(&_impl_.client_score_)) + sizeof(_impl_.report_type_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientPhishingRequest)
}

inline void ClientPhishingRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.feature_map_) { arena },
        decltype(_impl_.non_model_feature_map_) { arena }, decltype(_impl_.shingle_hashes_) { arena },
        /*decltype(_impl_._shingle_hashes_cached_byte_size_)*/ { 0 }, decltype(_impl_.referrer_chain_) { arena },
        decltype(_impl_.tflite_model_scores_) { arena }, decltype(_impl_.url_) {}, decltype(_impl_.obsolete_referrer_url_) {},
        decltype(_impl_.obsolete_hash_prefix_) {}, decltype(_impl_.deprecated_model_filename_) {}, decltype(_impl_.population_) { nullptr },
        decltype(_impl_.visual_features_) { nullptr }, decltype(_impl_.image_feature_embedding_) { nullptr },
        decltype(_impl_.llama_forced_trigger_info_) { nullptr }, decltype(_impl_.client_score_) { 0 }, decltype(_impl_.model_version_) { 0 },
        decltype(_impl_.is_phishing_) { false }, decltype(_impl_.is_dom_match_) { false }, decltype(_impl_.is_tflite_match_) { false },
        decltype(_impl_.tflite_model_version_) { 0 }, decltype(_impl_.dom_model_version_) { 0 }, decltype(_impl_.client_side_detection_type_) { 0 },
        decltype(_impl_.report_type_) { 0 } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_referrer_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_referrer_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_hash_prefix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obsolete_hash_prefix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_model_filename_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_model_filename_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientPhishingRequest::~ClientPhishingRequest()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientPhishingRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientPhishingRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.feature_map_.~RepeatedPtrField();
    _impl_.non_model_feature_map_.~RepeatedPtrField();
    _impl_.shingle_hashes_.~RepeatedField();
    _impl_.referrer_chain_.~RepeatedPtrField();
    _impl_.tflite_model_scores_.~RepeatedPtrField();
    _impl_.url_.Destroy();
    _impl_.obsolete_referrer_url_.Destroy();
    _impl_.obsolete_hash_prefix_.Destroy();
    _impl_.deprecated_model_filename_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.population_;
    if (this != internal_default_instance())
        delete _impl_.visual_features_;
    if (this != internal_default_instance())
        delete _impl_.image_feature_embedding_;
    if (this != internal_default_instance())
        delete _impl_.llama_forced_trigger_info_;
}

void ClientPhishingRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientPhishingRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientPhishingRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.feature_map_.Clear();
    _impl_.non_model_feature_map_.Clear();
    _impl_.shingle_hashes_.Clear();
    _impl_.referrer_chain_.Clear();
    _impl_.tflite_model_scores_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.obsolete_referrer_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.obsolete_hash_prefix_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.deprecated_model_filename_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.population_ != nullptr);
            _impl_.population_->Clear();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.visual_features_ != nullptr);
            _impl_.visual_features_->Clear();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.image_feature_embedding_ != nullptr);
            _impl_.image_feature_embedding_->Clear();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.llama_forced_trigger_info_ != nullptr);
            _impl_.llama_forced_trigger_info_->Clear();
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        ::memset(&_impl_.client_score_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.client_side_detection_type_) - reinterpret_cast<char*>(&_impl_.client_score_))
                + sizeof(_impl_.client_side_detection_type_));
    }
    _impl_.report_type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientPhishingRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required float client_score = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
                _Internal::set_has_client_score(&has_bits);
                _impl_.client_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_phishing = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_is_phishing(&has_bits);
                _impl_.is_phishing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientPhishingRequest.Feature feature_map = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_feature_map(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional int32 model_version = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_model_version(&has_bits);
                _impl_.model_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientPhishingRequest.Feature non_model_feature_map = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_non_model_feature_map(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string OBSOLETE_referrer_url = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                auto str = _internal_mutable_obsolete_referrer_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes OBSOLETE_hash_prefix = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                auto str = _internal_mutable_obsolete_hash_prefix();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated uint32 shingle_hashes = 12 [packed = true];
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_shingle_hashes(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 96) {
                _internal_add_shingle_hashes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string DEPRECATED_model_filename = 13 [deprecated = true];
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                auto str = _internal_mutable_deprecated_model_filename();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ChromeUserPopulation population = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                ptr = ctx->ParseMessage(_internal_mutable_population(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_dom_match = 21;
        case 21:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
                _Internal::set_has_is_dom_match(&has_bits);
                _impl_.is_dom_match_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 22;
        case 22:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_referrer_chain(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional int32 tflite_model_version = 23;
        case 23:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
                _Internal::set_has_tflite_model_version(&has_bits);
                _impl_.tflite_model_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientPhishingRequest.CategoryScore tflite_model_scores = 24;
        case 24:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_tflite_model_scores(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<194>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool is_tflite_match = 25;
        case 25:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
                _Internal::set_has_is_tflite_match(&has_bits);
                _impl_.is_tflite_match_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.VisualFeatures visual_features = 26;
        case 26:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
                ptr = ctx->ParseMessage(_internal_mutable_visual_features(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 dom_model_version = 27;
        case 27:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
                _Internal::set_has_dom_model_version(&has_bits);
                _impl_.dom_model_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSideDetectionType client_side_detection_type = 28;
        case 28:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientSideDetectionType_IsValid(val))) {
                    _internal_set_client_side_detection_type(static_cast<::safe_browsing::ClientSideDetectionType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(28, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ImageFeatureEmbedding image_feature_embedding = 29;
        case 29:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
                ptr = ctx->ParseMessage(_internal_mutable_image_feature_embedding(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientPhishingRequest.ReportType report_type = 30;
        case 30:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientPhishingRequest_ReportType_IsValid(val))) {
                    _internal_set_report_type(static_cast<::safe_browsing::ClientPhishingRequest_ReportType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(30, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.LlamaForcedTriggerInfo llama_forced_trigger_info = 31;
        case 31:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
                ptr = ctx->ParseMessage(_internal_mutable_llama_forced_trigger_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientPhishingRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientPhishingRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // required float client_score = 2;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_client_score(), target);
    }

    // optional bool is_phishing = 4;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_phishing(), target);
    }

    // repeated .safe_browsing.ClientPhishingRequest.Feature feature_map = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_feature_map_size()); i < n; i++) {
        const auto& repfield = this->_internal_feature_map(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional int32 model_version = 6;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_model_version(), target);
    }

    // repeated .safe_browsing.ClientPhishingRequest.Feature non_model_feature_map = 8;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_non_model_feature_map_size()); i < n; i++) {
        const auto& repfield = this->_internal_non_model_feature_map(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional string OBSOLETE_referrer_url = 9;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(9, this->_internal_obsolete_referrer_url(), target);
    }

    // optional bytes OBSOLETE_hash_prefix = 10;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteBytesMaybeAliased(10, this->_internal_obsolete_hash_prefix(), target);
    }

    // repeated uint32 shingle_hashes = 12 [packed = true];
    {
        int byte_size = _impl_._shingle_hashes_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteUInt32Packed(12, _internal_shingle_hashes(), byte_size, target);
        }
    }

    // optional string DEPRECATED_model_filename = 13 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(13, this->_internal_deprecated_model_filename(), target);
    }

    // optional .safe_browsing.ChromeUserPopulation population = 14;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            14, _Internal::population(this), _Internal::population(this).GetCachedSize(), target, stream);
    }

    // optional bool is_dom_match = 21;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_is_dom_match(), target);
    }

    // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 22;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_referrer_chain_size()); i < n; i++) {
        const auto& repfield = this->_internal_referrer_chain(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional int32 tflite_model_version = 23;
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(23, this->_internal_tflite_model_version(), target);
    }

    // repeated .safe_browsing.ClientPhishingRequest.CategoryScore tflite_model_scores = 24;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_tflite_model_scores_size()); i < n; i++) {
        const auto& repfield = this->_internal_tflite_model_scores(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(24, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bool is_tflite_match = 25;
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_is_tflite_match(), target);
    }

    // optional .safe_browsing.VisualFeatures visual_features = 26;
    if (cached_has_bits & 0x00000020u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            26, _Internal::visual_features(this), _Internal::visual_features(this).GetCachedSize(), target, stream);
    }

    // optional int32 dom_model_version = 27;
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(27, this->_internal_dom_model_version(), target);
    }

    // optional .safe_browsing.ClientSideDetectionType client_side_detection_type = 28;
    if (cached_has_bits & 0x00008000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(28, this->_internal_client_side_detection_type(), target);
    }

    // optional .safe_browsing.ImageFeatureEmbedding image_feature_embedding = 29;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            29, _Internal::image_feature_embedding(this), _Internal::image_feature_embedding(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientPhishingRequest.ReportType report_type = 30;
    if (cached_has_bits & 0x00010000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(30, this->_internal_report_type(), target);
    }

    // optional .safe_browsing.LlamaForcedTriggerInfo llama_forced_trigger_info = 31;
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            31, _Internal::llama_forced_trigger_info(this), _Internal::llama_forced_trigger_info(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientPhishingRequest)
    return target;
}

size_t ClientPhishingRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientPhishingRequest)
    size_t total_size = 0;

    // required float client_score = 2;
    if (_internal_has_client_score()) {
        total_size += 1 + 4;
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientPhishingRequest.Feature feature_map = 5;
    total_size += 1UL * this->_internal_feature_map_size();
    for (const auto& msg : this->_impl_.feature_map_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .safe_browsing.ClientPhishingRequest.Feature non_model_feature_map = 8;
    total_size += 1UL * this->_internal_non_model_feature_map_size();
    for (const auto& msg : this->_impl_.non_model_feature_map_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated uint32 shingle_hashes = 12 [packed = true];
    {
        size_t data_size = ::_pbi::WireFormatLite::UInt32Size(this->_impl_.shingle_hashes_);
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._shingle_hashes_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 22;
    total_size += 2UL * this->_internal_referrer_chain_size();
    for (const auto& msg : this->_impl_.referrer_chain_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .safe_browsing.ClientPhishingRequest.CategoryScore tflite_model_scores = 24;
    total_size += 2UL * this->_internal_tflite_model_scores_size();
    for (const auto& msg : this->_impl_.tflite_model_scores_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional string OBSOLETE_referrer_url = 9;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_obsolete_referrer_url());
        }

        // optional bytes OBSOLETE_hash_prefix = 10;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_obsolete_hash_prefix());
        }

        // optional string DEPRECATED_model_filename = 13 [deprecated = true];
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_deprecated_model_filename());
        }

        // optional .safe_browsing.ChromeUserPopulation population = 14;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.population_);
        }

        // optional .safe_browsing.VisualFeatures visual_features = 26;
        if (cached_has_bits & 0x00000020u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.visual_features_);
        }

        // optional .safe_browsing.ImageFeatureEmbedding image_feature_embedding = 29;
        if (cached_has_bits & 0x00000040u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.image_feature_embedding_);
        }

        // optional .safe_browsing.LlamaForcedTriggerInfo llama_forced_trigger_info = 31;
        if (cached_has_bits & 0x00000080u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.llama_forced_trigger_info_);
        }
    }
    if (cached_has_bits & 0x0000fe00u) {
        // optional int32 model_version = 6;
        if (cached_has_bits & 0x00000200u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_model_version());
        }

        // optional bool is_phishing = 4;
        if (cached_has_bits & 0x00000400u) {
            total_size += 1 + 1;
        }

        // optional bool is_dom_match = 21;
        if (cached_has_bits & 0x00000800u) {
            total_size += 2 + 1;
        }

        // optional bool is_tflite_match = 25;
        if (cached_has_bits & 0x00001000u) {
            total_size += 2 + 1;
        }

        // optional int32 tflite_model_version = 23;
        if (cached_has_bits & 0x00002000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int32Size(this->_internal_tflite_model_version());
        }

        // optional int32 dom_model_version = 27;
        if (cached_has_bits & 0x00004000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int32Size(this->_internal_dom_model_version());
        }

        // optional .safe_browsing.ClientSideDetectionType client_side_detection_type = 28;
        if (cached_has_bits & 0x00008000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_client_side_detection_type());
        }
    }
    // optional .safe_browsing.ClientPhishingRequest.ReportType report_type = 30;
    if (cached_has_bits & 0x00010000u) {
        total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_report_type());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientPhishingRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientPhishingRequest*>(&from));
}

void ClientPhishingRequest::MergeFrom(const ClientPhishingRequest& from)
{
    ClientPhishingRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientPhishingRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.feature_map_.MergeFrom(from._impl_.feature_map_);
    _this->_impl_.non_model_feature_map_.MergeFrom(from._impl_.non_model_feature_map_);
    _this->_impl_.shingle_hashes_.MergeFrom(from._impl_.shingle_hashes_);
    _this->_impl_.referrer_chain_.MergeFrom(from._impl_.referrer_chain_);
    _this->_impl_.tflite_model_scores_.MergeFrom(from._impl_.tflite_model_scores_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_obsolete_referrer_url(from._internal_obsolete_referrer_url());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_obsolete_hash_prefix(from._internal_obsolete_hash_prefix());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_deprecated_model_filename(from._internal_deprecated_model_filename());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_population()->::safe_browsing::ChromeUserPopulation::MergeFrom(from._internal_population());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_visual_features()->::safe_browsing::VisualFeatures::MergeFrom(from._internal_visual_features());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_image_feature_embedding()->::safe_browsing::ImageFeatureEmbedding::MergeFrom(from._internal_image_feature_embedding());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_llama_forced_trigger_info()->::safe_browsing::LlamaForcedTriggerInfo::MergeFrom(
                from._internal_llama_forced_trigger_info());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.client_score_ = from._impl_.client_score_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.model_version_ = from._impl_.model_version_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.is_phishing_ = from._impl_.is_phishing_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.is_dom_match_ = from._impl_.is_dom_match_;
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.is_tflite_match_ = from._impl_.is_tflite_match_;
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.tflite_model_version_ = from._impl_.tflite_model_version_;
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.dom_model_version_ = from._impl_.dom_model_version_;
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_impl_.client_side_detection_type_ = from._impl_.client_side_detection_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00010000u) {
        _this->_internal_set_report_type(from._internal_report_type());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientPhishingRequest::CopyFrom(const ClientPhishingRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientPhishingRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientPhishingRequest::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.feature_map_))
        return false;
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.non_model_feature_map_))
        return false;
    return true;
}

void ClientPhishingRequest::InternalSwap(ClientPhishingRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.feature_map_.InternalSwap(&other->_impl_.feature_map_);
    _impl_.non_model_feature_map_.InternalSwap(&other->_impl_.non_model_feature_map_);
    _impl_.shingle_hashes_.InternalSwap(&other->_impl_.shingle_hashes_);
    _impl_.referrer_chain_.InternalSwap(&other->_impl_.referrer_chain_);
    _impl_.tflite_model_scores_.InternalSwap(&other->_impl_.tflite_model_scores_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.obsolete_referrer_url_, lhs_arena, &other->_impl_.obsolete_referrer_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.obsolete_hash_prefix_, lhs_arena, &other->_impl_.obsolete_hash_prefix_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.deprecated_model_filename_, lhs_arena, &other->_impl_.deprecated_model_filename_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientPhishingRequest, _impl_.report_type_)
        + sizeof(ClientPhishingRequest::_impl_.report_type_) - PROTOBUF_FIELD_OFFSET(ClientPhishingRequest, _impl_.population_)>(
        reinterpret_cast<char*>(&_impl_.population_), reinterpret_cast<char*>(&other->_impl_.population_));
}

std::string ClientPhishingRequest::GetTypeName() const
{
    return "safe_browsing.ClientPhishingRequest";
}

// ===================================================================

class ClientPhishingResponse::_Internal {
public:
    using HasBits = decltype(std::declval<ClientPhishingResponse>()._impl_._has_bits_);
    static void set_has_phishy(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
    }
};

ClientPhishingResponse::ClientPhishingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientPhishingResponse)
}
ClientPhishingResponse::ClientPhishingResponse(const ClientPhishingResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientPhishingResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.obsolete_allowlist_expression_) { from._impl_.obsolete_allowlist_expression_ }, decltype(_impl_.phishy_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.phishy_ = from._impl_.phishy_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientPhishingResponse)
}

inline void ClientPhishingResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.obsolete_allowlist_expression_) { arena },
        decltype(_impl_.phishy_) { false } };
}

ClientPhishingResponse::~ClientPhishingResponse()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientPhishingResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientPhishingResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.obsolete_allowlist_expression_.~RepeatedPtrField();
}

void ClientPhishingResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientPhishingResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientPhishingResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.obsolete_allowlist_expression_.Clear();
    _impl_.phishy_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientPhishingResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required bool phishy = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_phishy(&has_bits);
                _impl_.phishy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string OBSOLETE_allowlist_expression = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_obsolete_allowlist_expression();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientPhishingResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientPhishingResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required bool phishy = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_phishy(), target);
    }

    // repeated string OBSOLETE_allowlist_expression = 2;
    for (int i = 0, n = this->_internal_obsolete_allowlist_expression_size(); i < n; i++) {
        const auto& s = this->_internal_obsolete_allowlist_expression(i);
        target = stream->WriteString(2, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientPhishingResponse)
    return target;
}

size_t ClientPhishingResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientPhishingResponse)
    size_t total_size = 0;

    // required bool phishy = 1;
    if (_internal_has_phishy()) {
        total_size += 1 + 1;
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string OBSOLETE_allowlist_expression = 2;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.obsolete_allowlist_expression_.size());
    for (int i = 0, n = _impl_.obsolete_allowlist_expression_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.obsolete_allowlist_expression_.Get(i));
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientPhishingResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientPhishingResponse*>(&from));
}

void ClientPhishingResponse::MergeFrom(const ClientPhishingResponse& from)
{
    ClientPhishingResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientPhishingResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.obsolete_allowlist_expression_.MergeFrom(from._impl_.obsolete_allowlist_expression_);
    if (from._internal_has_phishy()) {
        _this->_internal_set_phishy(from._internal_phishy());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientPhishingResponse::CopyFrom(const ClientPhishingResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientPhishingResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientPhishingResponse::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    return true;
}

void ClientPhishingResponse::InternalSwap(ClientPhishingResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.obsolete_allowlist_expression_.InternalSwap(&other->_impl_.obsolete_allowlist_expression_);
    swap(_impl_.phishy_, other->_impl_.phishy_);
}

std::string ClientPhishingResponse::GetTypeName() const
{
    return "safe_browsing.ClientPhishingResponse";
}

// ===================================================================

class LoginReputationClientRequest_Frame_Form::_Internal {
public:
    using HasBits = decltype(std::declval<LoginReputationClientRequest_Frame_Form>()._impl_._has_bits_);
    static void set_has_action_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_has_password_field(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

LoginReputationClientRequest_Frame_Form::LoginReputationClientRequest_Frame_Form(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.LoginReputationClientRequest.Frame.Form)
}
LoginReputationClientRequest_Frame_Form::LoginReputationClientRequest_Frame_Form(const LoginReputationClientRequest_Frame_Form& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LoginReputationClientRequest_Frame_Form* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.action_url_) {},
        decltype(_impl_.has_password_field_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.action_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_action_url()) {
        _this->_impl_.action_url_.Set(from._internal_action_url(), _this->GetArenaForAllocation());
    }
    _this->_impl_.has_password_field_ = from._impl_.has_password_field_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.LoginReputationClientRequest.Frame.Form)
}

inline void LoginReputationClientRequest_Frame_Form::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.action_url_) {},
        decltype(_impl_.has_password_field_) { false } };
    _impl_.action_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginReputationClientRequest_Frame_Form::~LoginReputationClientRequest_Frame_Form()
{
    // @@protoc_insertion_point(destructor:safe_browsing.LoginReputationClientRequest.Frame.Form)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LoginReputationClientRequest_Frame_Form::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.action_url_.Destroy();
}

void LoginReputationClientRequest_Frame_Form::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LoginReputationClientRequest_Frame_Form::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.LoginReputationClientRequest.Frame.Form)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.action_url_.ClearNonDefaultToEmpty();
    }
    _impl_.has_password_field_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LoginReputationClientRequest_Frame_Form::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string action_url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_action_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool has_password_field = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_has_password_field(&has_bits);
                _impl_.has_password_field_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LoginReputationClientRequest_Frame_Form::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LoginReputationClientRequest.Frame.Form)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string action_url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_action_url(), target);
    }

    // optional bool has_password_field = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_has_password_field(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LoginReputationClientRequest.Frame.Form)
    return target;
}

size_t LoginReputationClientRequest_Frame_Form::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.LoginReputationClientRequest.Frame.Form)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string action_url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_action_url());
        }

        // optional bool has_password_field = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LoginReputationClientRequest_Frame_Form::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LoginReputationClientRequest_Frame_Form*>(&from));
}

void LoginReputationClientRequest_Frame_Form::MergeFrom(const LoginReputationClientRequest_Frame_Form& from)
{
    LoginReputationClientRequest_Frame_Form* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LoginReputationClientRequest.Frame.Form)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_action_url(from._internal_action_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.has_password_field_ = from._impl_.has_password_field_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginReputationClientRequest_Frame_Form::CopyFrom(const LoginReputationClientRequest_Frame_Form& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LoginReputationClientRequest.Frame.Form)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LoginReputationClientRequest_Frame_Form::IsInitialized() const
{
    return true;
}

void LoginReputationClientRequest_Frame_Form::InternalSwap(LoginReputationClientRequest_Frame_Form* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.action_url_, lhs_arena, &other->_impl_.action_url_, rhs_arena);
    swap(_impl_.has_password_field_, other->_impl_.has_password_field_);
}

std::string LoginReputationClientRequest_Frame_Form::GetTypeName() const
{
    return "safe_browsing.LoginReputationClientRequest.Frame.Form";
}

// ===================================================================

class LoginReputationClientRequest_Frame::_Internal {
public:
    using HasBits = decltype(std::declval<LoginReputationClientRequest_Frame>()._impl_._has_bits_);
    static void set_has_frame_index(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_parent_frame_index(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_has_password_field(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::safe_browsing::ReferrerChainOptions& referrer_chain_options(const LoginReputationClientRequest_Frame* msg);
    static void set_has_referrer_chain_options(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::safe_browsing::ReferrerChainOptions& LoginReputationClientRequest_Frame::_Internal::referrer_chain_options(
    const LoginReputationClientRequest_Frame* msg)
{
    return *msg->_impl_.referrer_chain_options_;
}
LoginReputationClientRequest_Frame::LoginReputationClientRequest_Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.LoginReputationClientRequest.Frame)
}
LoginReputationClientRequest_Frame::LoginReputationClientRequest_Frame(const LoginReputationClientRequest_Frame& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LoginReputationClientRequest_Frame* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.referrer_chain_) { from._impl_.referrer_chain_ }, decltype(_impl_.forms_) { from._impl_.forms_ }, decltype(_impl_.url_) {},
        decltype(_impl_.referrer_chain_options_) { nullptr }, decltype(_impl_.frame_index_) {}, decltype(_impl_.parent_frame_index_) {},
        decltype(_impl_.has_password_field_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_referrer_chain_options()) {
        _this->_impl_.referrer_chain_options_ = new ::safe_browsing::ReferrerChainOptions(*from._impl_.referrer_chain_options_);
    }
    ::memcpy(&_impl_.frame_index_, &from._impl_.frame_index_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.has_password_field_) - reinterpret_cast<char*>(&_impl_.frame_index_))
            + sizeof(_impl_.has_password_field_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.LoginReputationClientRequest.Frame)
}

inline void LoginReputationClientRequest_Frame::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.referrer_chain_) { arena },
        decltype(_impl_.forms_) { arena }, decltype(_impl_.url_) {}, decltype(_impl_.referrer_chain_options_) { nullptr }, decltype(_impl_.frame_index_) { 0 },
        decltype(_impl_.parent_frame_index_) { 0 }, decltype(_impl_.has_password_field_) { false } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginReputationClientRequest_Frame::~LoginReputationClientRequest_Frame()
{
    // @@protoc_insertion_point(destructor:safe_browsing.LoginReputationClientRequest.Frame)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LoginReputationClientRequest_Frame::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.referrer_chain_.~RepeatedPtrField();
    _impl_.forms_.~RepeatedPtrField();
    _impl_.url_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.referrer_chain_options_;
}

void LoginReputationClientRequest_Frame::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LoginReputationClientRequest_Frame::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.LoginReputationClientRequest.Frame)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.referrer_chain_.Clear();
    _impl_.forms_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.referrer_chain_options_ != nullptr);
            _impl_.referrer_chain_options_->Clear();
        }
    }
    if (cached_has_bits & 0x0000001cu) {
        ::memset(&_impl_.frame_index_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.has_password_field_) - reinterpret_cast<char*>(&_impl_.frame_index_))
                + sizeof(_impl_.has_password_field_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LoginReputationClientRequest_Frame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 frame_index = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_frame_index(&has_bits);
                _impl_.frame_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 parent_frame_index = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_parent_frame_index(&has_bits);
                _impl_.parent_frame_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string url = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool has_password_field = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_has_password_field(&has_bits);
                _impl_.has_password_field_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_referrer_chain(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.LoginReputationClientRequest.Frame.Form forms = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_forms(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ReferrerChainOptions referrer_chain_options = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_referrer_chain_options(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LoginReputationClientRequest_Frame::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LoginReputationClientRequest.Frame)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 frame_index = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_frame_index(), target);
    }

    // optional int32 parent_frame_index = 2;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_parent_frame_index(), target);
    }

    // optional string url = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_url(), target);
    }

    // optional bool has_password_field = 4;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_has_password_field(), target);
    }

    // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_referrer_chain_size()); i < n; i++) {
        const auto& repfield = this->_internal_referrer_chain(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .safe_browsing.LoginReputationClientRequest.Frame.Form forms = 6;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_forms_size()); i < n; i++) {
        const auto& repfield = this->_internal_forms(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ReferrerChainOptions referrer_chain_options = 7;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::referrer_chain_options(this), _Internal::referrer_chain_options(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LoginReputationClientRequest.Frame)
    return target;
}

size_t LoginReputationClientRequest_Frame::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.LoginReputationClientRequest.Frame)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 5;
    total_size += 1UL * this->_internal_referrer_chain_size();
    for (const auto& msg : this->_impl_.referrer_chain_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .safe_browsing.LoginReputationClientRequest.Frame.Form forms = 6;
    total_size += 1UL * this->_internal_forms_size();
    for (const auto& msg : this->_impl_.forms_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string url = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional .safe_browsing.ReferrerChainOptions referrer_chain_options = 7;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.referrer_chain_options_);
        }

        // optional int32 frame_index = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_frame_index());
        }

        // optional int32 parent_frame_index = 2;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_parent_frame_index());
        }

        // optional bool has_password_field = 4;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LoginReputationClientRequest_Frame::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LoginReputationClientRequest_Frame*>(&from));
}

void LoginReputationClientRequest_Frame::MergeFrom(const LoginReputationClientRequest_Frame& from)
{
    LoginReputationClientRequest_Frame* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LoginReputationClientRequest.Frame)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.referrer_chain_.MergeFrom(from._impl_.referrer_chain_);
    _this->_impl_.forms_.MergeFrom(from._impl_.forms_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_referrer_chain_options()->::safe_browsing::ReferrerChainOptions::MergeFrom(from._internal_referrer_chain_options());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.frame_index_ = from._impl_.frame_index_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.parent_frame_index_ = from._impl_.parent_frame_index_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.has_password_field_ = from._impl_.has_password_field_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginReputationClientRequest_Frame::CopyFrom(const LoginReputationClientRequest_Frame& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LoginReputationClientRequest.Frame)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LoginReputationClientRequest_Frame::IsInitialized() const
{
    return true;
}

void LoginReputationClientRequest_Frame::InternalSwap(LoginReputationClientRequest_Frame* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.referrer_chain_.InternalSwap(&other->_impl_.referrer_chain_);
    _impl_.forms_.InternalSwap(&other->_impl_.forms_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest_Frame, _impl_.has_password_field_)
        + sizeof(LoginReputationClientRequest_Frame::_impl_.has_password_field_)
        - PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest_Frame, _impl_.referrer_chain_options_)>(
        reinterpret_cast<char*>(&_impl_.referrer_chain_options_), reinterpret_cast<char*>(&other->_impl_.referrer_chain_options_));
}

std::string LoginReputationClientRequest_Frame::GetTypeName() const
{
    return "safe_browsing.LoginReputationClientRequest.Frame";
}

// ===================================================================

class LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::_Internal {
public:
    using HasBits = decltype(std::declval<LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType>()._impl_._has_bits_);
    static void set_has_is_account_syncing(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_account_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType)
}
LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType(
    const LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.is_account_syncing_) {}, decltype(_impl_.account_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.is_account_syncing_, &from._impl_.is_account_syncing_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.account_type_) - reinterpret_cast<char*>(&_impl_.is_account_syncing_))
            + sizeof(_impl_.account_type_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType)
}

inline void LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.is_account_syncing_) { false },
        decltype(_impl_.account_type_) { 0 } };
}

LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::~LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType()
{
    // @@protoc_insertion_point(destructor:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.is_account_syncing_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.account_type_) - reinterpret_cast<char*>(&_impl_.is_account_syncing_))
                + sizeof(_impl_.account_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bool is_account_syncing = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_is_account_syncing(&has_bits);
                _impl_.is_account_syncing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType.AccountType account_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(
                        ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType_IsValid(val))) {
                    _internal_set_account_type(
                        static_cast<::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType_AccountType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool is_account_syncing = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_account_syncing(), target);
    }

    // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType.AccountType account_type = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_account_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType)
    return target;
}

size_t LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional bool is_account_syncing = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 1;
        }

        // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType.AccountType account_type = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_account_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType*>(&from));
}

void LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::MergeFrom(
    const LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType& from)
{
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.is_account_syncing_ = from._impl_.is_account_syncing_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.account_type_ = from._impl_.account_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::CopyFrom(
    const LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::IsInitialized() const
{
    return true;
}

void LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::InternalSwap(
    LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(
                                                   LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType, _impl_.account_type_)
        + sizeof(LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::_impl_.account_type_)
        - PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType, _impl_.is_account_syncing_)>(
        reinterpret_cast<char*>(&_impl_.is_account_syncing_), reinterpret_cast<char*>(&other->_impl_.is_account_syncing_));
}

std::string LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::GetTypeName() const
{
    return "safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType";
}

// ===================================================================

class LoginReputationClientRequest_PasswordReuseEvent::_Internal {
public:
    using HasBits = decltype(std::declval<LoginReputationClientRequest_PasswordReuseEvent>()._impl_._has_bits_);
    static void set_has_frame_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_sync_account_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_reused_password_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType& reused_password_account_type(
        const LoginReputationClientRequest_PasswordReuseEvent* msg);
    static void set_has_reused_password_account_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType&
LoginReputationClientRequest_PasswordReuseEvent::_Internal::reused_password_account_type(const LoginReputationClientRequest_PasswordReuseEvent* msg)
{
    return *msg->_impl_.reused_password_account_type_;
}
LoginReputationClientRequest_PasswordReuseEvent::LoginReputationClientRequest_PasswordReuseEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
}
LoginReputationClientRequest_PasswordReuseEvent::LoginReputationClientRequest_PasswordReuseEvent(const LoginReputationClientRequest_PasswordReuseEvent& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LoginReputationClientRequest_PasswordReuseEvent* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.domains_matching_password_) { from._impl_.domains_matching_password_ }, decltype(_impl_.reused_password_account_type_) { nullptr },
        decltype(_impl_.frame_id_) {}, decltype(_impl_.sync_account_type_) {}, decltype(_impl_.reused_password_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_reused_password_account_type()) {
        _this->_impl_.reused_password_account_type_
            = new ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType(*from._impl_.reused_password_account_type_);
    }
    ::memcpy(&_impl_.frame_id_, &from._impl_.frame_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.reused_password_type_) - reinterpret_cast<char*>(&_impl_.frame_id_))
            + sizeof(_impl_.reused_password_type_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
}

inline void LoginReputationClientRequest_PasswordReuseEvent::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.domains_matching_password_) { arena },
        decltype(_impl_.reused_password_account_type_) { nullptr }, decltype(_impl_.frame_id_) { 0 }, decltype(_impl_.sync_account_type_) { 0 },
        decltype(_impl_.reused_password_type_) { 0 } };
}

LoginReputationClientRequest_PasswordReuseEvent::~LoginReputationClientRequest_PasswordReuseEvent()
{
    // @@protoc_insertion_point(destructor:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LoginReputationClientRequest_PasswordReuseEvent::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.domains_matching_password_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.reused_password_account_type_;
}

void LoginReputationClientRequest_PasswordReuseEvent::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LoginReputationClientRequest_PasswordReuseEvent::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.domains_matching_password_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.reused_password_account_type_ != nullptr);
        _impl_.reused_password_account_type_->Clear();
    }
    if (cached_has_bits & 0x0000000eu) {
        ::memset(&_impl_.frame_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.reused_password_type_) - reinterpret_cast<char*>(&_impl_.frame_id_))
                + sizeof(_impl_.reused_password_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LoginReputationClientRequest_PasswordReuseEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated string domains_matching_password = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_domains_matching_password();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional int32 frame_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_frame_id(&has_bits);
                _impl_.frame_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.SyncAccountType sync_account_type = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType_IsValid(val))) {
                    _internal_set_sync_account_type(static_cast<::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_SyncAccountType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordType reused_password_type = 5 [default = REUSED_PASSWORD_TYPE_UNKNOWN];
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType_IsValid(val))) {
                    _internal_set_reused_password_type(static_cast<::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType reused_password_account_type = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_reused_password_account_type(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LoginReputationClientRequest_PasswordReuseEvent::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated string domains_matching_password = 1;
    for (int i = 0, n = this->_internal_domains_matching_password_size(); i < n; i++) {
        const auto& s = this->_internal_domains_matching_password(i);
        target = stream->WriteString(1, s, target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 frame_id = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_frame_id(), target);
    }

    // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.SyncAccountType sync_account_type = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_sync_account_type(), target);
    }

    // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordType reused_password_type = 5 [default = REUSED_PASSWORD_TYPE_UNKNOWN];
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_reused_password_type(), target);
    }

    // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType reused_password_account_type = 6;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::reused_password_account_type(this), _Internal::reused_password_account_type(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
    return target;
}

size_t LoginReputationClientRequest_PasswordReuseEvent::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string domains_matching_password = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.domains_matching_password_.size());
    for (int i = 0, n = _impl_.domains_matching_password_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.domains_matching_password_.Get(i));
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordAccountType reused_password_account_type = 6;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.reused_password_account_type_);
        }

        // optional int32 frame_id = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_frame_id());
        }

        // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.SyncAccountType sync_account_type = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_sync_account_type());
        }

        // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent.ReusedPasswordType reused_password_type = 5 [default = REUSED_PASSWORD_TYPE_UNKNOWN];
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_reused_password_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LoginReputationClientRequest_PasswordReuseEvent::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LoginReputationClientRequest_PasswordReuseEvent*>(&from));
}

void LoginReputationClientRequest_PasswordReuseEvent::MergeFrom(const LoginReputationClientRequest_PasswordReuseEvent& from)
{
    LoginReputationClientRequest_PasswordReuseEvent* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.domains_matching_password_.MergeFrom(from._impl_.domains_matching_password_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_reused_password_account_type()
                ->::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType::MergeFrom(
                    from._internal_reused_password_account_type());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.frame_id_ = from._impl_.frame_id_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.sync_account_type_ = from._impl_.sync_account_type_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.reused_password_type_ = from._impl_.reused_password_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginReputationClientRequest_PasswordReuseEvent::CopyFrom(const LoginReputationClientRequest_PasswordReuseEvent& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LoginReputationClientRequest.PasswordReuseEvent)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LoginReputationClientRequest_PasswordReuseEvent::IsInitialized() const
{
    return true;
}

void LoginReputationClientRequest_PasswordReuseEvent::InternalSwap(LoginReputationClientRequest_PasswordReuseEvent* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.domains_matching_password_.InternalSwap(&other->_impl_.domains_matching_password_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest_PasswordReuseEvent, _impl_.reused_password_type_)
        + sizeof(LoginReputationClientRequest_PasswordReuseEvent::_impl_.reused_password_type_)
        - PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest_PasswordReuseEvent, _impl_.reused_password_account_type_)>(
        reinterpret_cast<char*>(&_impl_.reused_password_account_type_), reinterpret_cast<char*>(&other->_impl_.reused_password_account_type_));
}

std::string LoginReputationClientRequest_PasswordReuseEvent::GetTypeName() const
{
    return "safe_browsing.LoginReputationClientRequest.PasswordReuseEvent";
}

// ===================================================================

class LoginReputationClientRequest_UrlDisplayExperiment::_Internal {
public:
    using HasBits = decltype(std::declval<LoginReputationClientRequest_UrlDisplayExperiment>()._impl_._has_bits_);
    static void set_has_delayed_warnings_enabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_delayed_warnings_mouse_clicks_enabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_reveal_on_hover(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_hide_on_interaction(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_elide_to_registrable_domain(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_simplified_url_display_enabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
};

LoginReputationClientRequest_UrlDisplayExperiment::LoginReputationClientRequest_UrlDisplayExperiment(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.LoginReputationClientRequest.UrlDisplayExperiment)
}
LoginReputationClientRequest_UrlDisplayExperiment::LoginReputationClientRequest_UrlDisplayExperiment(
    const LoginReputationClientRequest_UrlDisplayExperiment& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LoginReputationClientRequest_UrlDisplayExperiment* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.delayed_warnings_enabled_) {}, decltype(_impl_.delayed_warnings_mouse_clicks_enabled_) {}, decltype(_impl_.reveal_on_hover_) {},
        decltype(_impl_.hide_on_interaction_) {}, decltype(_impl_.elide_to_registrable_domain_) {}, decltype(_impl_.simplified_url_display_enabled_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.delayed_warnings_enabled_, &from._impl_.delayed_warnings_enabled_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.simplified_url_display_enabled_) - reinterpret_cast<char*>(&_impl_.delayed_warnings_enabled_))
            + sizeof(_impl_.simplified_url_display_enabled_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.LoginReputationClientRequest.UrlDisplayExperiment)
}

inline void LoginReputationClientRequest_UrlDisplayExperiment::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.delayed_warnings_enabled_) { false },
        decltype(_impl_.delayed_warnings_mouse_clicks_enabled_) { false }, decltype(_impl_.reveal_on_hover_) { false },
        decltype(_impl_.hide_on_interaction_) { false }, decltype(_impl_.elide_to_registrable_domain_) { false },
        decltype(_impl_.simplified_url_display_enabled_) { false } };
}

LoginReputationClientRequest_UrlDisplayExperiment::~LoginReputationClientRequest_UrlDisplayExperiment()
{
    // @@protoc_insertion_point(destructor:safe_browsing.LoginReputationClientRequest.UrlDisplayExperiment)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LoginReputationClientRequest_UrlDisplayExperiment::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LoginReputationClientRequest_UrlDisplayExperiment::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LoginReputationClientRequest_UrlDisplayExperiment::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.LoginReputationClientRequest.UrlDisplayExperiment)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        ::memset(&_impl_.delayed_warnings_enabled_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.simplified_url_display_enabled_) - reinterpret_cast<char*>(&_impl_.delayed_warnings_enabled_))
                + sizeof(_impl_.simplified_url_display_enabled_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LoginReputationClientRequest_UrlDisplayExperiment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bool delayed_warnings_enabled = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_delayed_warnings_enabled(&has_bits);
                _impl_.delayed_warnings_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool delayed_warnings_mouse_clicks_enabled = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_delayed_warnings_mouse_clicks_enabled(&has_bits);
                _impl_.delayed_warnings_mouse_clicks_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool reveal_on_hover = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_reveal_on_hover(&has_bits);
                _impl_.reveal_on_hover_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool hide_on_interaction = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_hide_on_interaction(&has_bits);
                _impl_.hide_on_interaction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool elide_to_registrable_domain = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_elide_to_registrable_domain(&has_bits);
                _impl_.elide_to_registrable_domain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool simplified_url_display_enabled = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_simplified_url_display_enabled(&has_bits);
                _impl_.simplified_url_display_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LoginReputationClientRequest_UrlDisplayExperiment::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LoginReputationClientRequest.UrlDisplayExperiment)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool delayed_warnings_enabled = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_delayed_warnings_enabled(), target);
    }

    // optional bool delayed_warnings_mouse_clicks_enabled = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_delayed_warnings_mouse_clicks_enabled(), target);
    }

    // optional bool reveal_on_hover = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_reveal_on_hover(), target);
    }

    // optional bool hide_on_interaction = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_hide_on_interaction(), target);
    }

    // optional bool elide_to_registrable_domain = 5;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_elide_to_registrable_domain(), target);
    }

    // optional bool simplified_url_display_enabled = 6;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_simplified_url_display_enabled(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LoginReputationClientRequest.UrlDisplayExperiment)
    return target;
}

size_t LoginReputationClientRequest_UrlDisplayExperiment::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.LoginReputationClientRequest.UrlDisplayExperiment)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional bool delayed_warnings_enabled = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 1;
        }

        // optional bool delayed_warnings_mouse_clicks_enabled = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }

        // optional bool reveal_on_hover = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }

        // optional bool hide_on_interaction = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }

        // optional bool elide_to_registrable_domain = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }

        // optional bool simplified_url_display_enabled = 6;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LoginReputationClientRequest_UrlDisplayExperiment::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LoginReputationClientRequest_UrlDisplayExperiment*>(&from));
}

void LoginReputationClientRequest_UrlDisplayExperiment::MergeFrom(const LoginReputationClientRequest_UrlDisplayExperiment& from)
{
    LoginReputationClientRequest_UrlDisplayExperiment* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LoginReputationClientRequest.UrlDisplayExperiment)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.delayed_warnings_enabled_ = from._impl_.delayed_warnings_enabled_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.delayed_warnings_mouse_clicks_enabled_ = from._impl_.delayed_warnings_mouse_clicks_enabled_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.reveal_on_hover_ = from._impl_.reveal_on_hover_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.hide_on_interaction_ = from._impl_.hide_on_interaction_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.elide_to_registrable_domain_ = from._impl_.elide_to_registrable_domain_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.simplified_url_display_enabled_ = from._impl_.simplified_url_display_enabled_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginReputationClientRequest_UrlDisplayExperiment::CopyFrom(const LoginReputationClientRequest_UrlDisplayExperiment& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LoginReputationClientRequest.UrlDisplayExperiment)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LoginReputationClientRequest_UrlDisplayExperiment::IsInitialized() const
{
    return true;
}

void LoginReputationClientRequest_UrlDisplayExperiment::InternalSwap(LoginReputationClientRequest_UrlDisplayExperiment* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest_UrlDisplayExperiment, _impl_.simplified_url_display_enabled_)
        + sizeof(LoginReputationClientRequest_UrlDisplayExperiment::_impl_.simplified_url_display_enabled_)
        - PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest_UrlDisplayExperiment, _impl_.delayed_warnings_enabled_)>(
        reinterpret_cast<char*>(&_impl_.delayed_warnings_enabled_), reinterpret_cast<char*>(&other->_impl_.delayed_warnings_enabled_));
}

std::string LoginReputationClientRequest_UrlDisplayExperiment::GetTypeName() const
{
    return "safe_browsing.LoginReputationClientRequest.UrlDisplayExperiment";
}

// ===================================================================

class LoginReputationClientRequest_ReferringAppInfo::_Internal {
public:
    using HasBits = decltype(std::declval<LoginReputationClientRequest_ReferringAppInfo>()._impl_._has_bits_);
    static void set_has_referring_app_source(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_referring_app_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

LoginReputationClientRequest_ReferringAppInfo::LoginReputationClientRequest_ReferringAppInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.LoginReputationClientRequest.ReferringAppInfo)
}
LoginReputationClientRequest_ReferringAppInfo::LoginReputationClientRequest_ReferringAppInfo(const LoginReputationClientRequest_ReferringAppInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LoginReputationClientRequest_ReferringAppInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.referring_app_name_) {}, decltype(_impl_.referring_app_source_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.referring_app_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referring_app_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_referring_app_name()) {
        _this->_impl_.referring_app_name_.Set(from._internal_referring_app_name(), _this->GetArenaForAllocation());
    }
    _this->_impl_.referring_app_source_ = from._impl_.referring_app_source_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.LoginReputationClientRequest.ReferringAppInfo)
}

inline void LoginReputationClientRequest_ReferringAppInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.referring_app_name_) {},
        decltype(_impl_.referring_app_source_) { 0 } };
    _impl_.referring_app_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referring_app_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginReputationClientRequest_ReferringAppInfo::~LoginReputationClientRequest_ReferringAppInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.LoginReputationClientRequest.ReferringAppInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LoginReputationClientRequest_ReferringAppInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.referring_app_name_.Destroy();
}

void LoginReputationClientRequest_ReferringAppInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LoginReputationClientRequest_ReferringAppInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.LoginReputationClientRequest.ReferringAppInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.referring_app_name_.ClearNonDefaultToEmpty();
    }
    _impl_.referring_app_source_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LoginReputationClientRequest_ReferringAppInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.LoginReputationClientRequest.ReferringAppInfo.ReferringAppSource referring_app_source = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource_IsValid(val))) {
                    _internal_set_referring_app_source(static_cast<::safe_browsing::LoginReputationClientRequest_ReferringAppInfo_ReferringAppSource>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string referring_app_name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_referring_app_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LoginReputationClientRequest_ReferringAppInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LoginReputationClientRequest.ReferringAppInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.LoginReputationClientRequest.ReferringAppInfo.ReferringAppSource referring_app_source = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_referring_app_source(), target);
    }

    // optional string referring_app_name = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_referring_app_name(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LoginReputationClientRequest.ReferringAppInfo)
    return target;
}

size_t LoginReputationClientRequest_ReferringAppInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.LoginReputationClientRequest.ReferringAppInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string referring_app_name = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_referring_app_name());
        }

        // optional .safe_browsing.LoginReputationClientRequest.ReferringAppInfo.ReferringAppSource referring_app_source = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_referring_app_source());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LoginReputationClientRequest_ReferringAppInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LoginReputationClientRequest_ReferringAppInfo*>(&from));
}

void LoginReputationClientRequest_ReferringAppInfo::MergeFrom(const LoginReputationClientRequest_ReferringAppInfo& from)
{
    LoginReputationClientRequest_ReferringAppInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LoginReputationClientRequest.ReferringAppInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_referring_app_name(from._internal_referring_app_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.referring_app_source_ = from._impl_.referring_app_source_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginReputationClientRequest_ReferringAppInfo::CopyFrom(const LoginReputationClientRequest_ReferringAppInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LoginReputationClientRequest.ReferringAppInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LoginReputationClientRequest_ReferringAppInfo::IsInitialized() const
{
    return true;
}

void LoginReputationClientRequest_ReferringAppInfo::InternalSwap(LoginReputationClientRequest_ReferringAppInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.referring_app_name_, lhs_arena, &other->_impl_.referring_app_name_, rhs_arena);
    swap(_impl_.referring_app_source_, other->_impl_.referring_app_source_);
}

std::string LoginReputationClientRequest_ReferringAppInfo::GetTypeName() const
{
    return "safe_browsing.LoginReputationClientRequest.ReferringAppInfo";
}

// ===================================================================

class LoginReputationClientRequest_DebuggingMetadata::_Internal {
public:
    using HasBits = decltype(std::declval<LoginReputationClientRequest_DebuggingMetadata>()._impl_._has_bits_);
    static void set_has_csd_model_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_preclassification_check_result(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_phishing_detector_result(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_local_model_detects_phishing(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_forced_request(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_network_result(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
};

LoginReputationClientRequest_DebuggingMetadata::LoginReputationClientRequest_DebuggingMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.LoginReputationClientRequest.DebuggingMetadata)
}
LoginReputationClientRequest_DebuggingMetadata::LoginReputationClientRequest_DebuggingMetadata(const LoginReputationClientRequest_DebuggingMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LoginReputationClientRequest_DebuggingMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.csd_model_version_) {},
        decltype(_impl_.preclassification_check_result_) {}, decltype(_impl_.phishing_detector_result_) {}, decltype(_impl_.local_model_detects_phishing_) {},
        decltype(_impl_.forced_request_) {}, decltype(_impl_.network_result_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.csd_model_version_, &from._impl_.csd_model_version_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.network_result_) - reinterpret_cast<char*>(&_impl_.csd_model_version_))
            + sizeof(_impl_.network_result_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.LoginReputationClientRequest.DebuggingMetadata)
}

inline void LoginReputationClientRequest_DebuggingMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.csd_model_version_) { 0 },
        decltype(_impl_.preclassification_check_result_) { 0 }, decltype(_impl_.phishing_detector_result_) { 0 },
        decltype(_impl_.local_model_detects_phishing_) { false }, decltype(_impl_.forced_request_) { false }, decltype(_impl_.network_result_) { 0 } };
}

LoginReputationClientRequest_DebuggingMetadata::~LoginReputationClientRequest_DebuggingMetadata()
{
    // @@protoc_insertion_point(destructor:safe_browsing.LoginReputationClientRequest.DebuggingMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LoginReputationClientRequest_DebuggingMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LoginReputationClientRequest_DebuggingMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LoginReputationClientRequest_DebuggingMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.LoginReputationClientRequest.DebuggingMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        ::memset(&_impl_.csd_model_version_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.network_result_) - reinterpret_cast<char*>(&_impl_.csd_model_version_))
                + sizeof(_impl_.network_result_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LoginReputationClientRequest_DebuggingMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 csd_model_version = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_csd_model_version(&has_bits);
                _impl_.csd_model_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.PreClassificationCheckResult preclassification_check_result = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::PreClassificationCheckResult_IsValid(val))) {
                    _internal_set_preclassification_check_result(static_cast<::safe_browsing::PreClassificationCheckResult>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.PhishingDetectorResult phishing_detector_result = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::PhishingDetectorResult_IsValid(val))) {
                    _internal_set_phishing_detector_result(static_cast<::safe_browsing::PhishingDetectorResult>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional bool local_model_detects_phishing = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_local_model_detects_phishing(&has_bits);
                _impl_.local_model_detects_phishing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool forced_request = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_forced_request(&has_bits);
                _impl_.forced_request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 network_result = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_network_result(&has_bits);
                _impl_.network_result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LoginReputationClientRequest_DebuggingMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LoginReputationClientRequest.DebuggingMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 csd_model_version = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_csd_model_version(), target);
    }

    // optional .safe_browsing.PreClassificationCheckResult preclassification_check_result = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_preclassification_check_result(), target);
    }

    // optional .safe_browsing.PhishingDetectorResult phishing_detector_result = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_phishing_detector_result(), target);
    }

    // optional bool local_model_detects_phishing = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_local_model_detects_phishing(), target);
    }

    // optional bool forced_request = 5;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_forced_request(), target);
    }

    // optional int32 network_result = 6;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_network_result(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LoginReputationClientRequest.DebuggingMetadata)
    return target;
}

size_t LoginReputationClientRequest_DebuggingMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.LoginReputationClientRequest.DebuggingMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional int32 csd_model_version = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_csd_model_version());
        }

        // optional .safe_browsing.PreClassificationCheckResult preclassification_check_result = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_preclassification_check_result());
        }

        // optional .safe_browsing.PhishingDetectorResult phishing_detector_result = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_phishing_detector_result());
        }

        // optional bool local_model_detects_phishing = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }

        // optional bool forced_request = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }

        // optional int32 network_result = 6;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_network_result());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LoginReputationClientRequest_DebuggingMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LoginReputationClientRequest_DebuggingMetadata*>(&from));
}

void LoginReputationClientRequest_DebuggingMetadata::MergeFrom(const LoginReputationClientRequest_DebuggingMetadata& from)
{
    LoginReputationClientRequest_DebuggingMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LoginReputationClientRequest.DebuggingMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.csd_model_version_ = from._impl_.csd_model_version_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.preclassification_check_result_ = from._impl_.preclassification_check_result_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.phishing_detector_result_ = from._impl_.phishing_detector_result_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.local_model_detects_phishing_ = from._impl_.local_model_detects_phishing_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.forced_request_ = from._impl_.forced_request_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.network_result_ = from._impl_.network_result_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginReputationClientRequest_DebuggingMetadata::CopyFrom(const LoginReputationClientRequest_DebuggingMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LoginReputationClientRequest.DebuggingMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LoginReputationClientRequest_DebuggingMetadata::IsInitialized() const
{
    return true;
}

void LoginReputationClientRequest_DebuggingMetadata::InternalSwap(LoginReputationClientRequest_DebuggingMetadata* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest_DebuggingMetadata, _impl_.network_result_)
        + sizeof(LoginReputationClientRequest_DebuggingMetadata::_impl_.network_result_)
        - PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest_DebuggingMetadata, _impl_.csd_model_version_)>(
        reinterpret_cast<char*>(&_impl_.csd_model_version_), reinterpret_cast<char*>(&other->_impl_.csd_model_version_));
}

std::string LoginReputationClientRequest_DebuggingMetadata::GetTypeName() const
{
    return "safe_browsing.LoginReputationClientRequest.DebuggingMetadata";
}

// ===================================================================

class LoginReputationClientRequest::_Internal {
public:
    using HasBits = decltype(std::declval<LoginReputationClientRequest>()._impl_._has_bits_);
    static void set_has_page_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_trigger_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static const ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent& password_reuse_event(const LoginReputationClientRequest* msg);
    static void set_has_password_reuse_event(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_stored_verdict_cnt(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static const ::safe_browsing::ChromeUserPopulation& population(const LoginReputationClientRequest* msg);
    static void set_has_population(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_clicked_through_interstitial(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_content_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_content_area_height(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static void set_has_content_area_width(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static const ::safe_browsing::VisualFeatures& visual_features(const LoginReputationClientRequest* msg);
    static void set_has_visual_features(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::safe_browsing::DomFeatures& dom_features(const LoginReputationClientRequest* msg);
    static void set_has_dom_features(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_report_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static const ::safe_browsing::LoginReputationClientRequest_UrlDisplayExperiment& url_display_experiment(const LoginReputationClientRequest* msg);
    static void set_has_url_display_experiment(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static const ::safe_browsing::LoginReputationClientRequest_ReferringAppInfo& referring_app_info(const LoginReputationClientRequest* msg);
    static void set_has_referring_app_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static const ::safe_browsing::LoginReputationClientRequest_DebuggingMetadata& csd_debugging_metadata(const LoginReputationClientRequest* msg);
    static void set_has_csd_debugging_metadata(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
};

const ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent& LoginReputationClientRequest::_Internal::password_reuse_event(
    const LoginReputationClientRequest* msg)
{
    return *msg->_impl_.password_reuse_event_;
}
const ::safe_browsing::ChromeUserPopulation& LoginReputationClientRequest::_Internal::population(const LoginReputationClientRequest* msg)
{
    return *msg->_impl_.population_;
}
const ::safe_browsing::VisualFeatures& LoginReputationClientRequest::_Internal::visual_features(const LoginReputationClientRequest* msg)
{
    return *msg->_impl_.visual_features_;
}
const ::safe_browsing::DomFeatures& LoginReputationClientRequest::_Internal::dom_features(const LoginReputationClientRequest* msg)
{
    return *msg->_impl_.dom_features_;
}
const ::safe_browsing::LoginReputationClientRequest_UrlDisplayExperiment& LoginReputationClientRequest::_Internal::url_display_experiment(
    const LoginReputationClientRequest* msg)
{
    return *msg->_impl_.url_display_experiment_;
}
const ::safe_browsing::LoginReputationClientRequest_ReferringAppInfo& LoginReputationClientRequest::_Internal::referring_app_info(
    const LoginReputationClientRequest* msg)
{
    return *msg->_impl_.referring_app_info_;
}
const ::safe_browsing::LoginReputationClientRequest_DebuggingMetadata& LoginReputationClientRequest::_Internal::csd_debugging_metadata(
    const LoginReputationClientRequest* msg)
{
    return *msg->_impl_.csd_debugging_metadata_;
}
LoginReputationClientRequest::LoginReputationClientRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.LoginReputationClientRequest)
}
LoginReputationClientRequest::LoginReputationClientRequest(const LoginReputationClientRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LoginReputationClientRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.frames_) { from._impl_.frames_ }, decltype(_impl_.page_url_) {}, decltype(_impl_.content_type_) {},
        decltype(_impl_.password_reuse_event_) { nullptr }, decltype(_impl_.population_) { nullptr }, decltype(_impl_.visual_features_) { nullptr },
        decltype(_impl_.dom_features_) { nullptr }, decltype(_impl_.url_display_experiment_) { nullptr }, decltype(_impl_.referring_app_info_) { nullptr },
        decltype(_impl_.csd_debugging_metadata_) { nullptr }, decltype(_impl_.trigger_type_) {}, decltype(_impl_.stored_verdict_cnt_) {},
        decltype(_impl_.clicked_through_interstitial_) {}, decltype(_impl_.content_area_height_) {}, decltype(_impl_.content_area_width_) {},
        decltype(_impl_.report_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.page_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_page_url()) {
        _this->_impl_.page_url_.Set(from._internal_page_url(), _this->GetArenaForAllocation());
    }
    _impl_.content_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_content_type()) {
        _this->_impl_.content_type_.Set(from._internal_content_type(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_password_reuse_event()) {
        _this->_impl_.password_reuse_event_ = new ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent(*from._impl_.password_reuse_event_);
    }
    if (from._internal_has_population()) {
        _this->_impl_.population_ = new ::safe_browsing::ChromeUserPopulation(*from._impl_.population_);
    }
    if (from._internal_has_visual_features()) {
        _this->_impl_.visual_features_ = new ::safe_browsing::VisualFeatures(*from._impl_.visual_features_);
    }
    if (from._internal_has_dom_features()) {
        _this->_impl_.dom_features_ = new ::safe_browsing::DomFeatures(*from._impl_.dom_features_);
    }
    if (from._internal_has_url_display_experiment()) {
        _this->_impl_.url_display_experiment_ = new ::safe_browsing::LoginReputationClientRequest_UrlDisplayExperiment(*from._impl_.url_display_experiment_);
    }
    if (from._internal_has_referring_app_info()) {
        _this->_impl_.referring_app_info_ = new ::safe_browsing::LoginReputationClientRequest_ReferringAppInfo(*from._impl_.referring_app_info_);
    }
    if (from._internal_has_csd_debugging_metadata()) {
        _this->_impl_.csd_debugging_metadata_ = new ::safe_browsing::LoginReputationClientRequest_DebuggingMetadata(*from._impl_.csd_debugging_metadata_);
    }
    ::memcpy(&_impl_.trigger_type_, &from._impl_.trigger_type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.report_type_) - reinterpret_cast<char*>(&_impl_.trigger_type_)) + sizeof(_impl_.report_type_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.LoginReputationClientRequest)
}

inline void LoginReputationClientRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.frames_) { arena }, decltype(_impl_.page_url_) {},
            decltype(_impl_.content_type_) {}, decltype(_impl_.password_reuse_event_) { nullptr }, decltype(_impl_.population_) { nullptr },
            decltype(_impl_.visual_features_) { nullptr }, decltype(_impl_.dom_features_) { nullptr }, decltype(_impl_.url_display_experiment_) { nullptr },
            decltype(_impl_.referring_app_info_) { nullptr }, decltype(_impl_.csd_debugging_metadata_) { nullptr }, decltype(_impl_.trigger_type_) { 0 },
            decltype(_impl_.stored_verdict_cnt_) { 0 }, decltype(_impl_.clicked_through_interstitial_) { false }, decltype(_impl_.content_area_height_) { 0 },
            decltype(_impl_.content_area_width_) { 0 }, decltype(_impl_.report_type_) { 0 } };
    _impl_.page_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.content_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginReputationClientRequest::~LoginReputationClientRequest()
{
    // @@protoc_insertion_point(destructor:safe_browsing.LoginReputationClientRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LoginReputationClientRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.frames_.~RepeatedPtrField();
    _impl_.page_url_.Destroy();
    _impl_.content_type_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.password_reuse_event_;
    if (this != internal_default_instance())
        delete _impl_.population_;
    if (this != internal_default_instance())
        delete _impl_.visual_features_;
    if (this != internal_default_instance())
        delete _impl_.dom_features_;
    if (this != internal_default_instance())
        delete _impl_.url_display_experiment_;
    if (this != internal_default_instance())
        delete _impl_.referring_app_info_;
    if (this != internal_default_instance())
        delete _impl_.csd_debugging_metadata_;
}

void LoginReputationClientRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LoginReputationClientRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.LoginReputationClientRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.frames_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.page_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.content_type_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.password_reuse_event_ != nullptr);
            _impl_.password_reuse_event_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.population_ != nullptr);
            _impl_.population_->Clear();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.visual_features_ != nullptr);
            _impl_.visual_features_->Clear();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.dom_features_ != nullptr);
            _impl_.dom_features_->Clear();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.url_display_experiment_ != nullptr);
            _impl_.url_display_experiment_->Clear();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.referring_app_info_ != nullptr);
            _impl_.referring_app_info_->Clear();
        }
    }
    if (cached_has_bits & 0x00000100u) {
        GOOGLE_DCHECK(_impl_.csd_debugging_metadata_ != nullptr);
        _impl_.csd_debugging_metadata_->Clear();
    }
    if (cached_has_bits & 0x00007e00u) {
        ::memset(&_impl_.trigger_type_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.report_type_) - reinterpret_cast<char*>(&_impl_.trigger_type_)) + sizeof(_impl_.report_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LoginReputationClientRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string page_url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_page_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.LoginReputationClientRequest.TriggerType trigger_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::LoginReputationClientRequest_TriggerType_IsValid(val))) {
                    _internal_set_trigger_type(static_cast<::safe_browsing::LoginReputationClientRequest_TriggerType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.LoginReputationClientRequest.Frame frames = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_frames(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent password_reuse_event = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_password_reuse_event(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 stored_verdict_cnt = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_stored_verdict_cnt(&has_bits);
                _impl_.stored_verdict_cnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ChromeUserPopulation population = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_population(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool clicked_through_interstitial = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_clicked_through_interstitial(&has_bits);
                _impl_.clicked_through_interstitial_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string content_type = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_content_type();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 content_area_height = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _Internal::set_has_content_area_height(&has_bits);
                _impl_.content_area_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 content_area_width = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                _Internal::set_has_content_area_width(&has_bits);
                _impl_.content_area_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.VisualFeatures visual_features = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_visual_features(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.DomFeatures dom_features = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                ptr = ctx->ParseMessage(_internal_mutable_dom_features(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.LoginReputationClientRequest.ReportType report_type = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::LoginReputationClientRequest_ReportType_IsValid(val))) {
                    _internal_set_report_type(static_cast<::safe_browsing::LoginReputationClientRequest_ReportType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.LoginReputationClientRequest.UrlDisplayExperiment url_display_experiment = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                ptr = ctx->ParseMessage(_internal_mutable_url_display_experiment(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.LoginReputationClientRequest.ReferringAppInfo referring_app_info = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
                ptr = ctx->ParseMessage(_internal_mutable_referring_app_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.LoginReputationClientRequest.DebuggingMetadata csd_debugging_metadata = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                ptr = ctx->ParseMessage(_internal_mutable_csd_debugging_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LoginReputationClientRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LoginReputationClientRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string page_url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_page_url(), target);
    }

    // optional .safe_browsing.LoginReputationClientRequest.TriggerType trigger_type = 2;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_trigger_type(), target);
    }

    // repeated .safe_browsing.LoginReputationClientRequest.Frame frames = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_frames_size()); i < n; i++) {
        const auto& repfield = this->_internal_frames(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent password_reuse_event = 4;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::password_reuse_event(this), _Internal::password_reuse_event(this).GetCachedSize(), target, stream);
    }

    // optional int32 stored_verdict_cnt = 5;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_stored_verdict_cnt(), target);
    }

    // optional .safe_browsing.ChromeUserPopulation population = 6;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::population(this), _Internal::population(this).GetCachedSize(), target, stream);
    }

    // optional bool clicked_through_interstitial = 7;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_clicked_through_interstitial(), target);
    }

    // optional string content_type = 8;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_content_type(), target);
    }

    // optional int32 content_area_height = 9;
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_content_area_height(), target);
    }

    // optional int32 content_area_width = 10;
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_content_area_width(), target);
    }

    // optional .safe_browsing.VisualFeatures visual_features = 11;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::visual_features(this), _Internal::visual_features(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.DomFeatures dom_features = 12;
    if (cached_has_bits & 0x00000020u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            12, _Internal::dom_features(this), _Internal::dom_features(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.LoginReputationClientRequest.ReportType report_type = 13;
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(13, this->_internal_report_type(), target);
    }

    // optional .safe_browsing.LoginReputationClientRequest.UrlDisplayExperiment url_display_experiment = 14;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            14, _Internal::url_display_experiment(this), _Internal::url_display_experiment(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.LoginReputationClientRequest.ReferringAppInfo referring_app_info = 15;
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            15, _Internal::referring_app_info(this), _Internal::referring_app_info(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.LoginReputationClientRequest.DebuggingMetadata csd_debugging_metadata = 16;
    if (cached_has_bits & 0x00000100u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            16, _Internal::csd_debugging_metadata(this), _Internal::csd_debugging_metadata(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LoginReputationClientRequest)
    return target;
}

size_t LoginReputationClientRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.LoginReputationClientRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.LoginReputationClientRequest.Frame frames = 3;
    total_size += 1UL * this->_internal_frames_size();
    for (const auto& msg : this->_impl_.frames_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string page_url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_page_url());
        }

        // optional string content_type = 8;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_content_type());
        }

        // optional .safe_browsing.LoginReputationClientRequest.PasswordReuseEvent password_reuse_event = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.password_reuse_event_);
        }

        // optional .safe_browsing.ChromeUserPopulation population = 6;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.population_);
        }

        // optional .safe_browsing.VisualFeatures visual_features = 11;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.visual_features_);
        }

        // optional .safe_browsing.DomFeatures dom_features = 12;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.dom_features_);
        }

        // optional .safe_browsing.LoginReputationClientRequest.UrlDisplayExperiment url_display_experiment = 14;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.url_display_experiment_);
        }

        // optional .safe_browsing.LoginReputationClientRequest.ReferringAppInfo referring_app_info = 15;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.referring_app_info_);
        }
    }
    if (cached_has_bits & 0x00007f00u) {
        // optional .safe_browsing.LoginReputationClientRequest.DebuggingMetadata csd_debugging_metadata = 16;
        if (cached_has_bits & 0x00000100u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.csd_debugging_metadata_);
        }

        // optional .safe_browsing.LoginReputationClientRequest.TriggerType trigger_type = 2;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_trigger_type());
        }

        // optional int32 stored_verdict_cnt = 5;
        if (cached_has_bits & 0x00000400u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_stored_verdict_cnt());
        }

        // optional bool clicked_through_interstitial = 7;
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + 1;
        }

        // optional int32 content_area_height = 9;
        if (cached_has_bits & 0x00001000u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_content_area_height());
        }

        // optional int32 content_area_width = 10;
        if (cached_has_bits & 0x00002000u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_content_area_width());
        }

        // optional .safe_browsing.LoginReputationClientRequest.ReportType report_type = 13;
        if (cached_has_bits & 0x00004000u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_report_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LoginReputationClientRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LoginReputationClientRequest*>(&from));
}

void LoginReputationClientRequest::MergeFrom(const LoginReputationClientRequest& from)
{
    LoginReputationClientRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LoginReputationClientRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.frames_.MergeFrom(from._impl_.frames_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_page_url(from._internal_page_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_content_type(from._internal_content_type());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_password_reuse_event()->::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent::MergeFrom(
                from._internal_password_reuse_event());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_population()->::safe_browsing::ChromeUserPopulation::MergeFrom(from._internal_population());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_visual_features()->::safe_browsing::VisualFeatures::MergeFrom(from._internal_visual_features());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_dom_features()->::safe_browsing::DomFeatures::MergeFrom(from._internal_dom_features());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_url_display_experiment()->::safe_browsing::LoginReputationClientRequest_UrlDisplayExperiment::MergeFrom(
                from._internal_url_display_experiment());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_referring_app_info()->::safe_browsing::LoginReputationClientRequest_ReferringAppInfo::MergeFrom(
                from._internal_referring_app_info());
        }
    }
    if (cached_has_bits & 0x00007f00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_mutable_csd_debugging_metadata()->::safe_browsing::LoginReputationClientRequest_DebuggingMetadata::MergeFrom(
                from._internal_csd_debugging_metadata());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.trigger_type_ = from._impl_.trigger_type_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.stored_verdict_cnt_ = from._impl_.stored_verdict_cnt_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.clicked_through_interstitial_ = from._impl_.clicked_through_interstitial_;
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.content_area_height_ = from._impl_.content_area_height_;
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.content_area_width_ = from._impl_.content_area_width_;
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.report_type_ = from._impl_.report_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginReputationClientRequest::CopyFrom(const LoginReputationClientRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LoginReputationClientRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LoginReputationClientRequest::IsInitialized() const
{
    return true;
}

void LoginReputationClientRequest::InternalSwap(LoginReputationClientRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.frames_.InternalSwap(&other->_impl_.frames_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.page_url_, lhs_arena, &other->_impl_.page_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.content_type_, lhs_arena, &other->_impl_.content_type_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest, _impl_.report_type_)
        + sizeof(LoginReputationClientRequest::_impl_.report_type_) - PROTOBUF_FIELD_OFFSET(LoginReputationClientRequest, _impl_.password_reuse_event_)>(
        reinterpret_cast<char*>(&_impl_.password_reuse_event_), reinterpret_cast<char*>(&other->_impl_.password_reuse_event_));
}

std::string LoginReputationClientRequest::GetTypeName() const
{
    return "safe_browsing.LoginReputationClientRequest";
}

// ===================================================================

class LoginReputationClientResponse::_Internal {
public:
    using HasBits = decltype(std::declval<LoginReputationClientResponse>()._impl_._has_bits_);
    static void set_has_verdict_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_cache_duration_sec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_cache_expression(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_deprecated_cache_expression_exact_match(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_verdict_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

LoginReputationClientResponse::LoginReputationClientResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.LoginReputationClientResponse)
}
LoginReputationClientResponse::LoginReputationClientResponse(const LoginReputationClientResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LoginReputationClientResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cache_expression_) {},
        decltype(_impl_.verdict_token_) {}, decltype(_impl_.cache_duration_sec_) {}, decltype(_impl_.verdict_type_) {},
        decltype(_impl_.deprecated_cache_expression_exact_match_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.cache_expression_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_expression_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_cache_expression()) {
        _this->_impl_.cache_expression_.Set(from._internal_cache_expression(), _this->GetArenaForAllocation());
    }
    _impl_.verdict_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verdict_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_verdict_token()) {
        _this->_impl_.verdict_token_.Set(from._internal_verdict_token(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.cache_duration_sec_, &from._impl_.cache_duration_sec_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.deprecated_cache_expression_exact_match_) - reinterpret_cast<char*>(&_impl_.cache_duration_sec_))
            + sizeof(_impl_.deprecated_cache_expression_exact_match_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.LoginReputationClientResponse)
}

inline void LoginReputationClientResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cache_expression_) {},
        decltype(_impl_.verdict_token_) {}, decltype(_impl_.cache_duration_sec_) { int64_t { 0 } }, decltype(_impl_.verdict_type_) { 0 },
        decltype(_impl_.deprecated_cache_expression_exact_match_) { false } };
    _impl_.cache_expression_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_expression_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verdict_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verdict_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoginReputationClientResponse::~LoginReputationClientResponse()
{
    // @@protoc_insertion_point(destructor:safe_browsing.LoginReputationClientResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LoginReputationClientResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.cache_expression_.Destroy();
    _impl_.verdict_token_.Destroy();
}

void LoginReputationClientResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LoginReputationClientResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.LoginReputationClientResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.cache_expression_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.verdict_token_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000001cu) {
        ::memset(&_impl_.cache_duration_sec_, 0,
            static_cast<size_t>(
                reinterpret_cast<char*>(&_impl_.deprecated_cache_expression_exact_match_) - reinterpret_cast<char*>(&_impl_.cache_duration_sec_))
                + sizeof(_impl_.deprecated_cache_expression_exact_match_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LoginReputationClientResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.LoginReputationClientResponse.VerdictType verdict_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::LoginReputationClientResponse_VerdictType_IsValid(val))) {
                    _internal_set_verdict_type(static_cast<::safe_browsing::LoginReputationClientResponse_VerdictType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 cache_duration_sec = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_cache_duration_sec(&has_bits);
                _impl_.cache_duration_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string cache_expression = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_cache_expression();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool DEPRECATED_cache_expression_exact_match = 4 [deprecated = true];
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_deprecated_cache_expression_exact_match(&has_bits);
                _impl_.deprecated_cache_expression_exact_match_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes verdict_token = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_verdict_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LoginReputationClientResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.LoginReputationClientResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.LoginReputationClientResponse.VerdictType verdict_type = 1;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_verdict_type(), target);
    }

    // optional int64 cache_duration_sec = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_cache_duration_sec(), target);
    }

    // optional string cache_expression = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_cache_expression(), target);
    }

    // optional bool DEPRECATED_cache_expression_exact_match = 4 [deprecated = true];
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_deprecated_cache_expression_exact_match(), target);
    }

    // optional bytes verdict_token = 5;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(5, this->_internal_verdict_token(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.LoginReputationClientResponse)
    return target;
}

size_t LoginReputationClientResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.LoginReputationClientResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string cache_expression = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_cache_expression());
        }

        // optional bytes verdict_token = 5;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_verdict_token());
        }

        // optional int64 cache_duration_sec = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_cache_duration_sec());
        }

        // optional .safe_browsing.LoginReputationClientResponse.VerdictType verdict_type = 1;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_verdict_type());
        }

        // optional bool DEPRECATED_cache_expression_exact_match = 4 [deprecated = true];
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LoginReputationClientResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LoginReputationClientResponse*>(&from));
}

void LoginReputationClientResponse::MergeFrom(const LoginReputationClientResponse& from)
{
    LoginReputationClientResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.LoginReputationClientResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_cache_expression(from._internal_cache_expression());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_verdict_token(from._internal_verdict_token());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.cache_duration_sec_ = from._impl_.cache_duration_sec_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.verdict_type_ = from._impl_.verdict_type_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.deprecated_cache_expression_exact_match_ = from._impl_.deprecated_cache_expression_exact_match_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoginReputationClientResponse::CopyFrom(const LoginReputationClientResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.LoginReputationClientResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LoginReputationClientResponse::IsInitialized() const
{
    return true;
}

void LoginReputationClientResponse::InternalSwap(LoginReputationClientResponse* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.cache_expression_, lhs_arena, &other->_impl_.cache_expression_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.verdict_token_, lhs_arena, &other->_impl_.verdict_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(LoginReputationClientResponse, _impl_.deprecated_cache_expression_exact_match_)
        + sizeof(LoginReputationClientResponse::_impl_.deprecated_cache_expression_exact_match_)
        - PROTOBUF_FIELD_OFFSET(LoginReputationClientResponse, _impl_.cache_duration_sec_)>(
        reinterpret_cast<char*>(&_impl_.cache_duration_sec_), reinterpret_cast<char*>(&other->_impl_.cache_duration_sec_));
}

std::string LoginReputationClientResponse::GetTypeName() const
{
    return "safe_browsing.LoginReputationClientResponse";
}

// ===================================================================

class VisualFeatures_BlurredImage::_Internal {
public:
    using HasBits = decltype(std::declval<VisualFeatures_BlurredImage>()._impl_._has_bits_);
    static void set_has_width(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_height(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

VisualFeatures_BlurredImage::VisualFeatures_BlurredImage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.VisualFeatures.BlurredImage)
}
VisualFeatures_BlurredImage::VisualFeatures_BlurredImage(const VisualFeatures_BlurredImage& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    VisualFeatures_BlurredImage* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.data_) {},
        decltype(_impl_.width_) {}, decltype(_impl_.height_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_data()) {
        _this->_impl_.data_.Set(from._internal_data(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.width_, &from._impl_.width_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) - reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.height_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.VisualFeatures.BlurredImage)
}

inline void VisualFeatures_BlurredImage::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.data_) {}, decltype(_impl_.width_) { 0 },
        decltype(_impl_.height_) { 0 } };
    _impl_.data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VisualFeatures_BlurredImage::~VisualFeatures_BlurredImage()
{
    // @@protoc_insertion_point(destructor:safe_browsing.VisualFeatures.BlurredImage)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void VisualFeatures_BlurredImage::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.data_.Destroy();
}

void VisualFeatures_BlurredImage::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void VisualFeatures_BlurredImage::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.VisualFeatures.BlurredImage)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.width_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) - reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.height_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* VisualFeatures_BlurredImage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 width = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_width(&has_bits);
                _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 height = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_height(&has_bits);
                _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes data = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_data();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* VisualFeatures_BlurredImage::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.VisualFeatures.BlurredImage)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 width = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_width(), target);
    }

    // optional int32 height = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_height(), target);
    }

    // optional bytes data = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_data(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.VisualFeatures.BlurredImage)
    return target;
}

size_t VisualFeatures_BlurredImage::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.VisualFeatures.BlurredImage)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional bytes data = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_data());
        }

        // optional int32 width = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
        }

        // optional int32 height = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void VisualFeatures_BlurredImage::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const VisualFeatures_BlurredImage*>(&from));
}

void VisualFeatures_BlurredImage::MergeFrom(const VisualFeatures_BlurredImage& from)
{
    VisualFeatures_BlurredImage* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.VisualFeatures.BlurredImage)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_data(from._internal_data());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.width_ = from._impl_.width_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.height_ = from._impl_.height_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VisualFeatures_BlurredImage::CopyFrom(const VisualFeatures_BlurredImage& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.VisualFeatures.BlurredImage)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool VisualFeatures_BlurredImage::IsInitialized() const
{
    return true;
}

void VisualFeatures_BlurredImage::InternalSwap(VisualFeatures_BlurredImage* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.data_, lhs_arena, &other->_impl_.data_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(VisualFeatures_BlurredImage, _impl_.height_)
        + sizeof(VisualFeatures_BlurredImage::_impl_.height_) - PROTOBUF_FIELD_OFFSET(VisualFeatures_BlurredImage, _impl_.width_)>(
        reinterpret_cast<char*>(&_impl_.width_), reinterpret_cast<char*>(&other->_impl_.width_));
}

std::string VisualFeatures_BlurredImage::GetTypeName() const
{
    return "safe_browsing.VisualFeatures.BlurredImage";
}

// ===================================================================

class VisualFeatures::_Internal {
public:
    using HasBits = decltype(std::declval<VisualFeatures>()._impl_._has_bits_);
    static const ::safe_browsing::VisualFeatures_BlurredImage& image(const VisualFeatures* msg);
    static void set_has_image(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::safe_browsing::VisualFeatures_BlurredImage& VisualFeatures::_Internal::image(const VisualFeatures* msg)
{
    return *msg->_impl_.image_;
}
VisualFeatures::VisualFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.VisualFeatures)
}
VisualFeatures::VisualFeatures(const VisualFeatures& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    VisualFeatures* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.image_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_image()) {
        _this->_impl_.image_ = new ::safe_browsing::VisualFeatures_BlurredImage(*from._impl_.image_);
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.VisualFeatures)
}

inline void VisualFeatures::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.image_) { nullptr } };
}

VisualFeatures::~VisualFeatures()
{
    // @@protoc_insertion_point(destructor:safe_browsing.VisualFeatures)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void VisualFeatures::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.image_;
}

void VisualFeatures::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void VisualFeatures::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.VisualFeatures)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.image_ != nullptr);
        _impl_.image_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* VisualFeatures::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.VisualFeatures.BlurredImage image = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_image(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* VisualFeatures::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.VisualFeatures)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.VisualFeatures.BlurredImage image = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::image(this), _Internal::image(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.VisualFeatures)
    return target;
}

size_t VisualFeatures::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.VisualFeatures)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .safe_browsing.VisualFeatures.BlurredImage image = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.image_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void VisualFeatures::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const VisualFeatures*>(&from));
}

void VisualFeatures::MergeFrom(const VisualFeatures& from)
{
    VisualFeatures* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.VisualFeatures)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_image()) {
        _this->_internal_mutable_image()->::safe_browsing::VisualFeatures_BlurredImage::MergeFrom(from._internal_image());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VisualFeatures::CopyFrom(const VisualFeatures& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.VisualFeatures)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool VisualFeatures::IsInitialized() const
{
    return true;
}

void VisualFeatures::InternalSwap(VisualFeatures* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.image_, other->_impl_.image_);
}

std::string VisualFeatures::GetTypeName() const
{
    return "safe_browsing.VisualFeatures";
}

// ===================================================================

class DomFeatures_Feature::_Internal {
public:
    using HasBits = decltype(std::declval<DomFeatures_Feature>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

DomFeatures_Feature::DomFeatures_Feature(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.DomFeatures.Feature)
}
DomFeatures_Feature::DomFeatures_Feature(const DomFeatures_Feature& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DomFeatures_Feature* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {},
        decltype(_impl_.value_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _this->_impl_.value_ = from._impl_.value_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.DomFeatures.Feature)
}

inline void DomFeatures_Feature::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {}, decltype(_impl_.value_) { 0 } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DomFeatures_Feature::~DomFeatures_Feature()
{
    // @@protoc_insertion_point(destructor:safe_browsing.DomFeatures.Feature)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DomFeatures_Feature::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_.Destroy();
}

void DomFeatures_Feature::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DomFeatures_Feature::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.DomFeatures.Feature)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.name_.ClearNonDefaultToEmpty();
    }
    _impl_.value_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DomFeatures_Feature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional double value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
                _Internal::set_has_value(&has_bits);
                _impl_.value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
                ptr += sizeof(double);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DomFeatures_Feature::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.DomFeatures.Feature)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional double value = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_value(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.DomFeatures.Feature)
    return target;
}

size_t DomFeatures_Feature::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.DomFeatures.Feature)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional double value = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 8;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DomFeatures_Feature::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DomFeatures_Feature*>(&from));
}

void DomFeatures_Feature::MergeFrom(const DomFeatures_Feature& from)
{
    DomFeatures_Feature* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.DomFeatures.Feature)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.value_ = from._impl_.value_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DomFeatures_Feature::CopyFrom(const DomFeatures_Feature& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.DomFeatures.Feature)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DomFeatures_Feature::IsInitialized() const
{
    return true;
}

void DomFeatures_Feature::InternalSwap(DomFeatures_Feature* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    swap(_impl_.value_, other->_impl_.value_);
}

std::string DomFeatures_Feature::GetTypeName() const
{
    return "safe_browsing.DomFeatures.Feature";
}

// ===================================================================

class DomFeatures::_Internal {
public:
    using HasBits = decltype(std::declval<DomFeatures>()._impl_._has_bits_);
    static void set_has_model_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

DomFeatures::DomFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.DomFeatures)
}
DomFeatures::DomFeatures(const DomFeatures& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DomFeatures* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.feature_map_) { from._impl_.feature_map_ }, decltype(_impl_.shingle_hashes_) { from._impl_.shingle_hashes_ },
        /*decltype(_impl_._shingle_hashes_cached_byte_size_)*/ { 0 }, decltype(_impl_.model_version_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.model_version_ = from._impl_.model_version_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.DomFeatures)
}

inline void DomFeatures::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.feature_map_) { arena },
        decltype(_impl_.shingle_hashes_) { arena }, /*decltype(_impl_._shingle_hashes_cached_byte_size_)*/ { 0 }, decltype(_impl_.model_version_) { 0 } };
}

DomFeatures::~DomFeatures()
{
    // @@protoc_insertion_point(destructor:safe_browsing.DomFeatures)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DomFeatures::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.feature_map_.~RepeatedPtrField();
    _impl_.shingle_hashes_.~RepeatedField();
}

void DomFeatures::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DomFeatures::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.DomFeatures)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.feature_map_.Clear();
    _impl_.shingle_hashes_.Clear();
    _impl_.model_version_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DomFeatures::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.DomFeatures.Feature feature_map = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_feature_map(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated uint32 shingle_hashes = 2 [packed = true];
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_shingle_hashes(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 16) {
                _internal_add_shingle_hashes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 model_version = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_model_version(&has_bits);
                _impl_.model_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DomFeatures::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.DomFeatures)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.DomFeatures.Feature feature_map = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_feature_map_size()); i < n; i++) {
        const auto& repfield = this->_internal_feature_map(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated uint32 shingle_hashes = 2 [packed = true];
    {
        int byte_size = _impl_._shingle_hashes_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteUInt32Packed(2, _internal_shingle_hashes(), byte_size, target);
        }
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 model_version = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_model_version(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.DomFeatures)
    return target;
}

size_t DomFeatures::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.DomFeatures)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.DomFeatures.Feature feature_map = 1;
    total_size += 1UL * this->_internal_feature_map_size();
    for (const auto& msg : this->_impl_.feature_map_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated uint32 shingle_hashes = 2 [packed = true];
    {
        size_t data_size = ::_pbi::WireFormatLite::UInt32Size(this->_impl_.shingle_hashes_);
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._shingle_hashes_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    // optional int32 model_version = 3;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_model_version());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DomFeatures::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DomFeatures*>(&from));
}

void DomFeatures::MergeFrom(const DomFeatures& from)
{
    DomFeatures* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.DomFeatures)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.feature_map_.MergeFrom(from._impl_.feature_map_);
    _this->_impl_.shingle_hashes_.MergeFrom(from._impl_.shingle_hashes_);
    if (from._internal_has_model_version()) {
        _this->_internal_set_model_version(from._internal_model_version());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DomFeatures::CopyFrom(const DomFeatures& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.DomFeatures)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DomFeatures::IsInitialized() const
{
    return true;
}

void DomFeatures::InternalSwap(DomFeatures* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.feature_map_.InternalSwap(&other->_impl_.feature_map_);
    _impl_.shingle_hashes_.InternalSwap(&other->_impl_.shingle_hashes_);
    swap(_impl_.model_version_, other->_impl_.model_version_);
}

std::string DomFeatures::GetTypeName() const
{
    return "safe_browsing.DomFeatures";
}

// ===================================================================

class ClientDownloadRequest_Digests::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest_Digests>()._impl_._has_bits_);
    static void set_has_sha256(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_sha1(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_md5(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

ClientDownloadRequest_Digests::ClientDownloadRequest_Digests(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.Digests)
}
ClientDownloadRequest_Digests::ClientDownloadRequest_Digests(const ClientDownloadRequest_Digests& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_Digests* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.sha256_) {},
        decltype(_impl_.sha1_) {}, decltype(_impl_.md5_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.sha256_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sha256()) {
        _this->_impl_.sha256_.Set(from._internal_sha256(), _this->GetArenaForAllocation());
    }
    _impl_.sha1_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha1_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sha1()) {
        _this->_impl_.sha1_.Set(from._internal_sha1(), _this->GetArenaForAllocation());
    }
    _impl_.md5_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.md5_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_md5()) {
        _this->_impl_.md5_.Set(from._internal_md5(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.Digests)
}

inline void ClientDownloadRequest_Digests::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.sha256_) {}, decltype(_impl_.sha1_) {},
        decltype(_impl_.md5_) {} };
    _impl_.sha256_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha1_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha1_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.md5_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.md5_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_Digests::~ClientDownloadRequest_Digests()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.Digests)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_Digests::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.sha256_.Destroy();
    _impl_.sha1_.Destroy();
    _impl_.md5_.Destroy();
}

void ClientDownloadRequest_Digests::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_Digests::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.Digests)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.sha256_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.sha1_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.md5_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_Digests::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bytes sha256 = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_sha256();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes sha1 = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_sha1();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes md5 = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_md5();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_Digests::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.Digests)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bytes sha256 = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_sha256(), target);
    }

    // optional bytes sha1 = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_sha1(), target);
    }

    // optional bytes md5 = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_md5(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.Digests)
    return target;
}

size_t ClientDownloadRequest_Digests::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.Digests)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional bytes sha256 = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_sha256());
        }

        // optional bytes sha1 = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_sha1());
        }

        // optional bytes md5 = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_md5());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_Digests::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_Digests*>(&from));
}

void ClientDownloadRequest_Digests::MergeFrom(const ClientDownloadRequest_Digests& from)
{
    ClientDownloadRequest_Digests* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.Digests)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_sha256(from._internal_sha256());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_sha1(from._internal_sha1());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_md5(from._internal_md5());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_Digests::CopyFrom(const ClientDownloadRequest_Digests& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.Digests)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_Digests::IsInitialized() const
{
    return true;
}

void ClientDownloadRequest_Digests::InternalSwap(ClientDownloadRequest_Digests* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.sha256_, lhs_arena, &other->_impl_.sha256_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.sha1_, lhs_arena, &other->_impl_.sha1_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.md5_, lhs_arena, &other->_impl_.md5_, rhs_arena);
}

std::string ClientDownloadRequest_Digests::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.Digests";
}

// ===================================================================

class ClientDownloadRequest_Resource::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest_Resource>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_remote_ip(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_referrer(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000009) ^ 0x00000009) != 0;
    }
};

ClientDownloadRequest_Resource::ClientDownloadRequest_Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.Resource)
}
ClientDownloadRequest_Resource::ClientDownloadRequest_Resource(const ClientDownloadRequest_Resource& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_Resource* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {},
        decltype(_impl_.remote_ip_) {}, decltype(_impl_.referrer_) {}, decltype(_impl_.type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _impl_.remote_ip_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_ip_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_remote_ip()) {
        _this->_impl_.remote_ip_.Set(from._internal_remote_ip(), _this->GetArenaForAllocation());
    }
    _impl_.referrer_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_referrer()) {
        _this->_impl_.referrer_.Set(from._internal_referrer(), _this->GetArenaForAllocation());
    }
    _this->_impl_.type_ = from._impl_.type_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.Resource)
}

inline void ClientDownloadRequest_Resource::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {}, decltype(_impl_.remote_ip_) {},
        decltype(_impl_.referrer_) {}, decltype(_impl_.type_) { 0 } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_ip_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_ip_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_Resource::~ClientDownloadRequest_Resource()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.Resource)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_Resource::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
    _impl_.remote_ip_.Destroy();
    _impl_.referrer_.Destroy();
}

void ClientDownloadRequest_Resource::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_Resource::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.Resource)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.remote_ip_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.referrer_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_Resource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required .safe_browsing.ClientDownloadRequest.ResourceType type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadRequest_ResourceType_IsValid(val))) {
                    _internal_set_type(static_cast<::safe_browsing::ClientDownloadRequest_ResourceType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional bytes remote_ip = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_remote_ip();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string referrer = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_referrer();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_Resource::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.Resource)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // required .safe_browsing.ClientDownloadRequest.ResourceType type = 2;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_type(), target);
    }

    // optional bytes remote_ip = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_remote_ip(), target);
    }

    // optional string referrer = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_referrer(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.Resource)
    return target;
}

size_t ClientDownloadRequest_Resource::RequiredFieldsByteSizeFallback() const
{
    // @@protoc_insertion_point(required_fields_byte_size_fallback_start:safe_browsing.ClientDownloadRequest.Resource)
    size_t total_size = 0;

    if (_internal_has_url()) {
        // required string url = 1;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
    }

    if (_internal_has_type()) {
        // required .safe_browsing.ClientDownloadRequest.ResourceType type = 2;
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    return total_size;
}
size_t ClientDownloadRequest_Resource::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.Resource)
    size_t total_size = 0;

    if (((_impl_._has_bits_[0] & 0x00000009) ^ 0x00000009) == 0) { // All required fields are present.
        // required string url = 1;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());

        // required .safe_browsing.ClientDownloadRequest.ResourceType type = 2;
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());

    } else {
        total_size += RequiredFieldsByteSizeFallback();
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000006u) {
        // optional bytes remote_ip = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_remote_ip());
        }

        // optional string referrer = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_referrer());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_Resource::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_Resource*>(&from));
}

void ClientDownloadRequest_Resource::MergeFrom(const ClientDownloadRequest_Resource& from)
{
    ClientDownloadRequest_Resource* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.Resource)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_remote_ip(from._internal_remote_ip());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_referrer(from._internal_referrer());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_Resource::CopyFrom(const ClientDownloadRequest_Resource& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.Resource)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_Resource::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    return true;
}

void ClientDownloadRequest_Resource::InternalSwap(ClientDownloadRequest_Resource* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.remote_ip_, lhs_arena, &other->_impl_.remote_ip_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.referrer_, lhs_arena, &other->_impl_.referrer_, rhs_arena);
    swap(_impl_.type_, other->_impl_.type_);
}

std::string ClientDownloadRequest_Resource::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.Resource";
}

// ===================================================================

class ClientDownloadRequest_CertificateChain_Element::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest_CertificateChain_Element>()._impl_._has_bits_);
    static void set_has_certificate(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ClientDownloadRequest_CertificateChain_Element::ClientDownloadRequest_CertificateChain_Element(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
}
ClientDownloadRequest_CertificateChain_Element::ClientDownloadRequest_CertificateChain_Element(const ClientDownloadRequest_CertificateChain_Element& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_CertificateChain_Element* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.certificate_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.certificate_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.certificate_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_certificate()) {
        _this->_impl_.certificate_.Set(from._internal_certificate(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
}

inline void ClientDownloadRequest_CertificateChain_Element::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.certificate_) {} };
    _impl_.certificate_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.certificate_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_CertificateChain_Element::~ClientDownloadRequest_CertificateChain_Element()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_CertificateChain_Element::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.certificate_.Destroy();
}

void ClientDownloadRequest_CertificateChain_Element::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_CertificateChain_Element::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.certificate_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_CertificateChain_Element::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bytes certificate = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_certificate();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_CertificateChain_Element::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bytes certificate = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_certificate(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
    return target;
}

size_t ClientDownloadRequest_CertificateChain_Element::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional bytes certificate = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_certificate());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_CertificateChain_Element::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_CertificateChain_Element*>(&from));
}

void ClientDownloadRequest_CertificateChain_Element::MergeFrom(const ClientDownloadRequest_CertificateChain_Element& from)
{
    ClientDownloadRequest_CertificateChain_Element* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_certificate()) {
        _this->_internal_set_certificate(from._internal_certificate());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_CertificateChain_Element::CopyFrom(const ClientDownloadRequest_CertificateChain_Element& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.CertificateChain.Element)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_CertificateChain_Element::IsInitialized() const
{
    return true;
}

void ClientDownloadRequest_CertificateChain_Element::InternalSwap(ClientDownloadRequest_CertificateChain_Element* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.certificate_, lhs_arena, &other->_impl_.certificate_, rhs_arena);
}

std::string ClientDownloadRequest_CertificateChain_Element::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.CertificateChain.Element";
}

// ===================================================================

class ClientDownloadRequest_CertificateChain::_Internal {
public:
};

ClientDownloadRequest_CertificateChain::ClientDownloadRequest_CertificateChain(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.CertificateChain)
}
ClientDownloadRequest_CertificateChain::ClientDownloadRequest_CertificateChain(const ClientDownloadRequest_CertificateChain& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_CertificateChain* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.element_) { from._impl_.element_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.CertificateChain)
}

inline void ClientDownloadRequest_CertificateChain::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.element_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ClientDownloadRequest_CertificateChain::~ClientDownloadRequest_CertificateChain()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.CertificateChain)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_CertificateChain::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.element_.~RepeatedPtrField();
}

void ClientDownloadRequest_CertificateChain::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_CertificateChain::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.CertificateChain)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.element_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_CertificateChain::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.ClientDownloadRequest.CertificateChain.Element element = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_element(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_CertificateChain::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.CertificateChain)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientDownloadRequest.CertificateChain.Element element = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_element_size()); i < n; i++) {
        const auto& repfield = this->_internal_element(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.CertificateChain)
    return target;
}

size_t ClientDownloadRequest_CertificateChain::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.CertificateChain)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientDownloadRequest.CertificateChain.Element element = 1;
    total_size += 1UL * this->_internal_element_size();
    for (const auto& msg : this->_impl_.element_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_CertificateChain::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_CertificateChain*>(&from));
}

void ClientDownloadRequest_CertificateChain::MergeFrom(const ClientDownloadRequest_CertificateChain& from)
{
    ClientDownloadRequest_CertificateChain* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.CertificateChain)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.element_.MergeFrom(from._impl_.element_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_CertificateChain::CopyFrom(const ClientDownloadRequest_CertificateChain& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.CertificateChain)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_CertificateChain::IsInitialized() const
{
    return true;
}

void ClientDownloadRequest_CertificateChain::InternalSwap(ClientDownloadRequest_CertificateChain* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.element_.InternalSwap(&other->_impl_.element_);
}

std::string ClientDownloadRequest_CertificateChain::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.CertificateChain";
}

// ===================================================================

class ClientDownloadRequest_ExtendedAttr::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest_ExtendedAttr>()._impl_._has_bits_);
    static void set_has_key(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
    }
};

ClientDownloadRequest_ExtendedAttr::ClientDownloadRequest_ExtendedAttr(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.ExtendedAttr)
}
ClientDownloadRequest_ExtendedAttr::ClientDownloadRequest_ExtendedAttr(const ClientDownloadRequest_ExtendedAttr& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_ExtendedAttr* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.key_) {},
        decltype(_impl_.value_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_key()) {
        _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
    }
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_value()) {
        _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.ExtendedAttr)
}

inline void ClientDownloadRequest_ExtendedAttr::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.key_) {}, decltype(_impl_.value_) {} };
    _impl_.key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_ExtendedAttr::~ClientDownloadRequest_ExtendedAttr()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.ExtendedAttr)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_ExtendedAttr::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.key_.Destroy();
    _impl_.value_.Destroy();
}

void ClientDownloadRequest_ExtendedAttr::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_ExtendedAttr::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.ExtendedAttr)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.key_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.value_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_ExtendedAttr::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required string key = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_ExtendedAttr::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.ExtendedAttr)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required string key = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_key(), target);
    }

    // optional bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_value(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.ExtendedAttr)
    return target;
}

size_t ClientDownloadRequest_ExtendedAttr::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.ExtendedAttr)
    size_t total_size = 0;

    // required string key = 1;
    if (_internal_has_key()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_key());
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional bytes value = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000002u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_value());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_ExtendedAttr::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_ExtendedAttr*>(&from));
}

void ClientDownloadRequest_ExtendedAttr::MergeFrom(const ClientDownloadRequest_ExtendedAttr& from)
{
    ClientDownloadRequest_ExtendedAttr* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.ExtendedAttr)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_key(from._internal_key());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_value(from._internal_value());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_ExtendedAttr::CopyFrom(const ClientDownloadRequest_ExtendedAttr& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.ExtendedAttr)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_ExtendedAttr::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    return true;
}

void ClientDownloadRequest_ExtendedAttr::InternalSwap(ClientDownloadRequest_ExtendedAttr* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena, &other->_impl_.key_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena, &other->_impl_.value_, rhs_arena);
}

std::string ClientDownloadRequest_ExtendedAttr::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.ExtendedAttr";
}

// ===================================================================

class ClientDownloadRequest_SignatureInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest_SignatureInfo>()._impl_._has_bits_);
    static void set_has_trusted(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ClientDownloadRequest_SignatureInfo::ClientDownloadRequest_SignatureInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.SignatureInfo)
}
ClientDownloadRequest_SignatureInfo::ClientDownloadRequest_SignatureInfo(const ClientDownloadRequest_SignatureInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_SignatureInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.certificate_chain_) { from._impl_.certificate_chain_ }, decltype(_impl_.signed_data_) { from._impl_.signed_data_ },
        decltype(_impl_.xattr_) { from._impl_.xattr_ }, decltype(_impl_.trusted_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.trusted_ = from._impl_.trusted_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.SignatureInfo)
}

inline void ClientDownloadRequest_SignatureInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.certificate_chain_) { arena },
        decltype(_impl_.signed_data_) { arena }, decltype(_impl_.xattr_) { arena }, decltype(_impl_.trusted_) { false } };
}

ClientDownloadRequest_SignatureInfo::~ClientDownloadRequest_SignatureInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.SignatureInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_SignatureInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.certificate_chain_.~RepeatedPtrField();
    _impl_.signed_data_.~RepeatedPtrField();
    _impl_.xattr_.~RepeatedPtrField();
}

void ClientDownloadRequest_SignatureInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_SignatureInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.SignatureInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.certificate_chain_.Clear();
    _impl_.signed_data_.Clear();
    _impl_.xattr_.Clear();
    _impl_.trusted_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_SignatureInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.ClientDownloadRequest.CertificateChain certificate_chain = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_certificate_chain(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool trusted = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_trusted(&has_bits);
                _impl_.trusted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated bytes signed_data = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_signed_data();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientDownloadRequest.ExtendedAttr xattr = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_xattr(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_SignatureInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.SignatureInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientDownloadRequest.CertificateChain certificate_chain = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_certificate_chain_size()); i < n; i++) {
        const auto& repfield = this->_internal_certificate_chain(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool trusted = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_trusted(), target);
    }

    // repeated bytes signed_data = 3;
    for (int i = 0, n = this->_internal_signed_data_size(); i < n; i++) {
        const auto& s = this->_internal_signed_data(i);
        target = stream->WriteBytes(3, s, target);
    }

    // repeated .safe_browsing.ClientDownloadRequest.ExtendedAttr xattr = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_xattr_size()); i < n; i++) {
        const auto& repfield = this->_internal_xattr(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.SignatureInfo)
    return target;
}

size_t ClientDownloadRequest_SignatureInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.SignatureInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientDownloadRequest.CertificateChain certificate_chain = 1;
    total_size += 1UL * this->_internal_certificate_chain_size();
    for (const auto& msg : this->_impl_.certificate_chain_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated bytes signed_data = 3;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.signed_data_.size());
    for (int i = 0, n = _impl_.signed_data_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(_impl_.signed_data_.Get(i));
    }

    // repeated .safe_browsing.ClientDownloadRequest.ExtendedAttr xattr = 4;
    total_size += 1UL * this->_internal_xattr_size();
    for (const auto& msg : this->_impl_.xattr_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional bool trusted = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + 1;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_SignatureInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_SignatureInfo*>(&from));
}

void ClientDownloadRequest_SignatureInfo::MergeFrom(const ClientDownloadRequest_SignatureInfo& from)
{
    ClientDownloadRequest_SignatureInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.SignatureInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.certificate_chain_.MergeFrom(from._impl_.certificate_chain_);
    _this->_impl_.signed_data_.MergeFrom(from._impl_.signed_data_);
    _this->_impl_.xattr_.MergeFrom(from._impl_.xattr_);
    if (from._internal_has_trusted()) {
        _this->_internal_set_trusted(from._internal_trusted());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_SignatureInfo::CopyFrom(const ClientDownloadRequest_SignatureInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.SignatureInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_SignatureInfo::IsInitialized() const
{
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.xattr_))
        return false;
    return true;
}

void ClientDownloadRequest_SignatureInfo::InternalSwap(ClientDownloadRequest_SignatureInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.certificate_chain_.InternalSwap(&other->_impl_.certificate_chain_);
    _impl_.signed_data_.InternalSwap(&other->_impl_.signed_data_);
    _impl_.xattr_.InternalSwap(&other->_impl_.xattr_);
    swap(_impl_.trusted_, other->_impl_.trusted_);
}

std::string ClientDownloadRequest_SignatureInfo::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.SignatureInfo";
}

// ===================================================================

class ClientDownloadRequest_PEImageHeaders_DebugData::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest_PEImageHeaders_DebugData>()._impl_._has_bits_);
    static void set_has_directory_entry(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_raw_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ClientDownloadRequest_PEImageHeaders_DebugData::ClientDownloadRequest_PEImageHeaders_DebugData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
}
ClientDownloadRequest_PEImageHeaders_DebugData::ClientDownloadRequest_PEImageHeaders_DebugData(const ClientDownloadRequest_PEImageHeaders_DebugData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_PEImageHeaders_DebugData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.directory_entry_) {},
        decltype(_impl_.raw_data_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.directory_entry_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.directory_entry_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_directory_entry()) {
        _this->_impl_.directory_entry_.Set(from._internal_directory_entry(), _this->GetArenaForAllocation());
    }
    _impl_.raw_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.raw_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_raw_data()) {
        _this->_impl_.raw_data_.Set(from._internal_raw_data(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
}

inline void ClientDownloadRequest_PEImageHeaders_DebugData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.directory_entry_) {}, decltype(_impl_.raw_data_) {} };
    _impl_.directory_entry_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.directory_entry_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.raw_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.raw_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_PEImageHeaders_DebugData::~ClientDownloadRequest_PEImageHeaders_DebugData()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_PEImageHeaders_DebugData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.directory_entry_.Destroy();
    _impl_.raw_data_.Destroy();
}

void ClientDownloadRequest_PEImageHeaders_DebugData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_PEImageHeaders_DebugData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.directory_entry_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.raw_data_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_PEImageHeaders_DebugData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bytes directory_entry = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_directory_entry();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes raw_data = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_raw_data();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_PEImageHeaders_DebugData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bytes directory_entry = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_directory_entry(), target);
    }

    // optional bytes raw_data = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_raw_data(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
    return target;
}

size_t ClientDownloadRequest_PEImageHeaders_DebugData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional bytes directory_entry = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_directory_entry());
        }

        // optional bytes raw_data = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_raw_data());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_PEImageHeaders_DebugData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_PEImageHeaders_DebugData*>(&from));
}

void ClientDownloadRequest_PEImageHeaders_DebugData::MergeFrom(const ClientDownloadRequest_PEImageHeaders_DebugData& from)
{
    ClientDownloadRequest_PEImageHeaders_DebugData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_directory_entry(from._internal_directory_entry());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_raw_data(from._internal_raw_data());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_PEImageHeaders_DebugData::CopyFrom(const ClientDownloadRequest_PEImageHeaders_DebugData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_PEImageHeaders_DebugData::IsInitialized() const
{
    return true;
}

void ClientDownloadRequest_PEImageHeaders_DebugData::InternalSwap(ClientDownloadRequest_PEImageHeaders_DebugData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.directory_entry_, lhs_arena, &other->_impl_.directory_entry_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.raw_data_, lhs_arena, &other->_impl_.raw_data_, rhs_arena);
}

std::string ClientDownloadRequest_PEImageHeaders_DebugData::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData";
}

// ===================================================================

class ClientDownloadRequest_PEImageHeaders::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest_PEImageHeaders>()._impl_._has_bits_);
    static void set_has_dos_header(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_file_header(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_optional_headers32(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_optional_headers64(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_export_section_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

ClientDownloadRequest_PEImageHeaders::ClientDownloadRequest_PEImageHeaders(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.PEImageHeaders)
}
ClientDownloadRequest_PEImageHeaders::ClientDownloadRequest_PEImageHeaders(const ClientDownloadRequest_PEImageHeaders& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_PEImageHeaders* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.section_header_) { from._impl_.section_header_ }, decltype(_impl_.debug_data_) { from._impl_.debug_data_ },
        decltype(_impl_.dos_header_) {}, decltype(_impl_.file_header_) {}, decltype(_impl_.optional_headers32_) {}, decltype(_impl_.optional_headers64_) {},
        decltype(_impl_.export_section_data_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.dos_header_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dos_header_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_dos_header()) {
        _this->_impl_.dos_header_.Set(from._internal_dos_header(), _this->GetArenaForAllocation());
    }
    _impl_.file_header_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_header_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_file_header()) {
        _this->_impl_.file_header_.Set(from._internal_file_header(), _this->GetArenaForAllocation());
    }
    _impl_.optional_headers32_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.optional_headers32_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_optional_headers32()) {
        _this->_impl_.optional_headers32_.Set(from._internal_optional_headers32(), _this->GetArenaForAllocation());
    }
    _impl_.optional_headers64_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.optional_headers64_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_optional_headers64()) {
        _this->_impl_.optional_headers64_.Set(from._internal_optional_headers64(), _this->GetArenaForAllocation());
    }
    _impl_.export_section_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.export_section_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_export_section_data()) {
        _this->_impl_.export_section_data_.Set(from._internal_export_section_data(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.PEImageHeaders)
}

inline void ClientDownloadRequest_PEImageHeaders::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.section_header_) { arena },
        decltype(_impl_.debug_data_) { arena }, decltype(_impl_.dos_header_) {}, decltype(_impl_.file_header_) {}, decltype(_impl_.optional_headers32_) {},
        decltype(_impl_.optional_headers64_) {}, decltype(_impl_.export_section_data_) {} };
    _impl_.dos_header_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dos_header_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_header_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_header_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.optional_headers32_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.optional_headers32_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.optional_headers64_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.optional_headers64_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.export_section_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.export_section_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_PEImageHeaders::~ClientDownloadRequest_PEImageHeaders()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.PEImageHeaders)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_PEImageHeaders::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.section_header_.~RepeatedPtrField();
    _impl_.debug_data_.~RepeatedPtrField();
    _impl_.dos_header_.Destroy();
    _impl_.file_header_.Destroy();
    _impl_.optional_headers32_.Destroy();
    _impl_.optional_headers64_.Destroy();
    _impl_.export_section_data_.Destroy();
}

void ClientDownloadRequest_PEImageHeaders::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_PEImageHeaders::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.PEImageHeaders)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.section_header_.Clear();
    _impl_.debug_data_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.dos_header_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.file_header_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.optional_headers32_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.optional_headers64_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.export_section_data_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_PEImageHeaders::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bytes dos_header = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_dos_header();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes file_header = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_file_header();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes optional_headers32 = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_optional_headers32();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes optional_headers64 = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_optional_headers64();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated bytes section_header = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_section_header();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bytes export_section_data = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_export_section_data();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData debug_data = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_debug_data(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_PEImageHeaders::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.PEImageHeaders)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bytes dos_header = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_dos_header(), target);
    }

    // optional bytes file_header = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_file_header(), target);
    }

    // optional bytes optional_headers32 = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_optional_headers32(), target);
    }

    // optional bytes optional_headers64 = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteBytesMaybeAliased(4, this->_internal_optional_headers64(), target);
    }

    // repeated bytes section_header = 5;
    for (int i = 0, n = this->_internal_section_header_size(); i < n; i++) {
        const auto& s = this->_internal_section_header(i);
        target = stream->WriteBytes(5, s, target);
    }

    // optional bytes export_section_data = 6;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteBytesMaybeAliased(6, this->_internal_export_section_data(), target);
    }

    // repeated .safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData debug_data = 7;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_debug_data_size()); i < n; i++) {
        const auto& repfield = this->_internal_debug_data(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.PEImageHeaders)
    return target;
}

size_t ClientDownloadRequest_PEImageHeaders::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.PEImageHeaders)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated bytes section_header = 5;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.section_header_.size());
    for (int i = 0, n = _impl_.section_header_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(_impl_.section_header_.Get(i));
    }

    // repeated .safe_browsing.ClientDownloadRequest.PEImageHeaders.DebugData debug_data = 7;
    total_size += 1UL * this->_internal_debug_data_size();
    for (const auto& msg : this->_impl_.debug_data_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional bytes dos_header = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_dos_header());
        }

        // optional bytes file_header = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_file_header());
        }

        // optional bytes optional_headers32 = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_optional_headers32());
        }

        // optional bytes optional_headers64 = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_optional_headers64());
        }

        // optional bytes export_section_data = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_export_section_data());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_PEImageHeaders::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_PEImageHeaders*>(&from));
}

void ClientDownloadRequest_PEImageHeaders::MergeFrom(const ClientDownloadRequest_PEImageHeaders& from)
{
    ClientDownloadRequest_PEImageHeaders* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.PEImageHeaders)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.section_header_.MergeFrom(from._impl_.section_header_);
    _this->_impl_.debug_data_.MergeFrom(from._impl_.debug_data_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_dos_header(from._internal_dos_header());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_file_header(from._internal_file_header());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_optional_headers32(from._internal_optional_headers32());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_optional_headers64(from._internal_optional_headers64());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_export_section_data(from._internal_export_section_data());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_PEImageHeaders::CopyFrom(const ClientDownloadRequest_PEImageHeaders& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.PEImageHeaders)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_PEImageHeaders::IsInitialized() const
{
    return true;
}

void ClientDownloadRequest_PEImageHeaders::InternalSwap(ClientDownloadRequest_PEImageHeaders* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.section_header_.InternalSwap(&other->_impl_.section_header_);
    _impl_.debug_data_.InternalSwap(&other->_impl_.debug_data_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.dos_header_, lhs_arena, &other->_impl_.dos_header_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.file_header_, lhs_arena, &other->_impl_.file_header_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.optional_headers32_, lhs_arena, &other->_impl_.optional_headers32_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.optional_headers64_, lhs_arena, &other->_impl_.optional_headers64_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.export_section_data_, lhs_arena, &other->_impl_.export_section_data_, rhs_arena);
}

std::string ClientDownloadRequest_PEImageHeaders::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.PEImageHeaders";
}

// ===================================================================

class ClientDownloadRequest_MachOHeaders_LoadCommand::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest_MachOHeaders_LoadCommand>()._impl_._has_bits_);
    static void set_has_command_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_command(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
    }
};

ClientDownloadRequest_MachOHeaders_LoadCommand::ClientDownloadRequest_MachOHeaders_LoadCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
}
ClientDownloadRequest_MachOHeaders_LoadCommand::ClientDownloadRequest_MachOHeaders_LoadCommand(const ClientDownloadRequest_MachOHeaders_LoadCommand& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_MachOHeaders_LoadCommand* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.command_) {},
        decltype(_impl_.command_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.command_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.command_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_command()) {
        _this->_impl_.command_.Set(from._internal_command(), _this->GetArenaForAllocation());
    }
    _this->_impl_.command_id_ = from._impl_.command_id_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
}

inline void ClientDownloadRequest_MachOHeaders_LoadCommand::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.command_) {}, decltype(_impl_.command_id_) { 0u } };
    _impl_.command_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.command_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_MachOHeaders_LoadCommand::~ClientDownloadRequest_MachOHeaders_LoadCommand()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_MachOHeaders_LoadCommand::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.command_.Destroy();
}

void ClientDownloadRequest_MachOHeaders_LoadCommand::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_MachOHeaders_LoadCommand::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.command_.ClearNonDefaultToEmpty();
    }
    _impl_.command_id_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_MachOHeaders_LoadCommand::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required uint32 command_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_command_id(&has_bits);
                _impl_.command_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required bytes command = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_command();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_MachOHeaders_LoadCommand::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required uint32 command_id = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_command_id(), target);
    }

    // required bytes command = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_command(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
    return target;
}

size_t ClientDownloadRequest_MachOHeaders_LoadCommand::RequiredFieldsByteSizeFallback() const
{
    // @@protoc_insertion_point(required_fields_byte_size_fallback_start:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
    size_t total_size = 0;

    if (_internal_has_command()) {
        // required bytes command = 2;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_command());
    }

    if (_internal_has_command_id()) {
        // required uint32 command_id = 1;
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_command_id());
    }

    return total_size;
}
size_t ClientDownloadRequest_MachOHeaders_LoadCommand::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
    size_t total_size = 0;

    if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) { // All required fields are present.
        // required bytes command = 2;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_command());

        // required uint32 command_id = 1;
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_command_id());

    } else {
        total_size += RequiredFieldsByteSizeFallback();
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_MachOHeaders_LoadCommand::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_MachOHeaders_LoadCommand*>(&from));
}

void ClientDownloadRequest_MachOHeaders_LoadCommand::MergeFrom(const ClientDownloadRequest_MachOHeaders_LoadCommand& from)
{
    ClientDownloadRequest_MachOHeaders_LoadCommand* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_command(from._internal_command());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.command_id_ = from._impl_.command_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_MachOHeaders_LoadCommand::CopyFrom(const ClientDownloadRequest_MachOHeaders_LoadCommand& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_MachOHeaders_LoadCommand::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    return true;
}

void ClientDownloadRequest_MachOHeaders_LoadCommand::InternalSwap(ClientDownloadRequest_MachOHeaders_LoadCommand* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.command_, lhs_arena, &other->_impl_.command_, rhs_arena);
    swap(_impl_.command_id_, other->_impl_.command_id_);
}

std::string ClientDownloadRequest_MachOHeaders_LoadCommand::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand";
}

// ===================================================================

class ClientDownloadRequest_MachOHeaders::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest_MachOHeaders>()._impl_._has_bits_);
    static void set_has_mach_header(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
    }
};

ClientDownloadRequest_MachOHeaders::ClientDownloadRequest_MachOHeaders(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.MachOHeaders)
}
ClientDownloadRequest_MachOHeaders::ClientDownloadRequest_MachOHeaders(const ClientDownloadRequest_MachOHeaders& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_MachOHeaders* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.load_commands_) { from._impl_.load_commands_ }, decltype(_impl_.mach_header_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.mach_header_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mach_header_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_mach_header()) {
        _this->_impl_.mach_header_.Set(from._internal_mach_header(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.MachOHeaders)
}

inline void ClientDownloadRequest_MachOHeaders::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.load_commands_) { arena },
        decltype(_impl_.mach_header_) {} };
    _impl_.mach_header_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mach_header_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_MachOHeaders::~ClientDownloadRequest_MachOHeaders()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.MachOHeaders)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_MachOHeaders::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.load_commands_.~RepeatedPtrField();
    _impl_.mach_header_.Destroy();
}

void ClientDownloadRequest_MachOHeaders::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_MachOHeaders::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.MachOHeaders)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.load_commands_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.mach_header_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_MachOHeaders::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required bytes mach_header = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_mach_header();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand load_commands = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_load_commands(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_MachOHeaders::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.MachOHeaders)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required bytes mach_header = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_mach_header(), target);
    }

    // repeated .safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand load_commands = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_load_commands_size()); i < n; i++) {
        const auto& repfield = this->_internal_load_commands(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.MachOHeaders)
    return target;
}

size_t ClientDownloadRequest_MachOHeaders::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.MachOHeaders)
    size_t total_size = 0;

    // required bytes mach_header = 1;
    if (_internal_has_mach_header()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_mach_header());
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientDownloadRequest.MachOHeaders.LoadCommand load_commands = 2;
    total_size += 1UL * this->_internal_load_commands_size();
    for (const auto& msg : this->_impl_.load_commands_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_MachOHeaders::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_MachOHeaders*>(&from));
}

void ClientDownloadRequest_MachOHeaders::MergeFrom(const ClientDownloadRequest_MachOHeaders& from)
{
    ClientDownloadRequest_MachOHeaders* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.MachOHeaders)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.load_commands_.MergeFrom(from._impl_.load_commands_);
    if (from._internal_has_mach_header()) {
        _this->_internal_set_mach_header(from._internal_mach_header());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_MachOHeaders::CopyFrom(const ClientDownloadRequest_MachOHeaders& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.MachOHeaders)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_MachOHeaders::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.load_commands_))
        return false;
    return true;
}

void ClientDownloadRequest_MachOHeaders::InternalSwap(ClientDownloadRequest_MachOHeaders* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.load_commands_.InternalSwap(&other->_impl_.load_commands_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.mach_header_, lhs_arena, &other->_impl_.mach_header_, rhs_arena);
}

std::string ClientDownloadRequest_MachOHeaders::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.MachOHeaders";
}

// ===================================================================

class ClientDownloadRequest_ImageHeaders::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest_ImageHeaders>()._impl_._has_bits_);
    static const ::safe_browsing::ClientDownloadRequest_PEImageHeaders& pe_headers(const ClientDownloadRequest_ImageHeaders* msg);
    static void set_has_pe_headers(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::safe_browsing::ClientDownloadRequest_PEImageHeaders& ClientDownloadRequest_ImageHeaders::_Internal::pe_headers(
    const ClientDownloadRequest_ImageHeaders* msg)
{
    return *msg->_impl_.pe_headers_;
}
ClientDownloadRequest_ImageHeaders::ClientDownloadRequest_ImageHeaders(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.ImageHeaders)
}
ClientDownloadRequest_ImageHeaders::ClientDownloadRequest_ImageHeaders(const ClientDownloadRequest_ImageHeaders& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_ImageHeaders* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.mach_o_headers_) { from._impl_.mach_o_headers_ }, decltype(_impl_.pe_headers_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_pe_headers()) {
        _this->_impl_.pe_headers_ = new ::safe_browsing::ClientDownloadRequest_PEImageHeaders(*from._impl_.pe_headers_);
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.ImageHeaders)
}

inline void ClientDownloadRequest_ImageHeaders::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.mach_o_headers_) { arena },
        decltype(_impl_.pe_headers_) { nullptr } };
}

ClientDownloadRequest_ImageHeaders::~ClientDownloadRequest_ImageHeaders()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.ImageHeaders)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_ImageHeaders::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.mach_o_headers_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.pe_headers_;
}

void ClientDownloadRequest_ImageHeaders::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_ImageHeaders::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.ImageHeaders)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.mach_o_headers_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.pe_headers_ != nullptr);
        _impl_.pe_headers_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_ImageHeaders::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientDownloadRequest.PEImageHeaders pe_headers = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_pe_headers(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientDownloadRequest.MachOHeaders mach_o_headers = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_mach_o_headers(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_ImageHeaders::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.ImageHeaders)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientDownloadRequest.PEImageHeaders pe_headers = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::pe_headers(this), _Internal::pe_headers(this).GetCachedSize(), target, stream);
    }

    // repeated .safe_browsing.ClientDownloadRequest.MachOHeaders mach_o_headers = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_mach_o_headers_size()); i < n; i++) {
        const auto& repfield = this->_internal_mach_o_headers(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.ImageHeaders)
    return target;
}

size_t ClientDownloadRequest_ImageHeaders::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.ImageHeaders)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientDownloadRequest.MachOHeaders mach_o_headers = 2;
    total_size += 1UL * this->_internal_mach_o_headers_size();
    for (const auto& msg : this->_impl_.mach_o_headers_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional .safe_browsing.ClientDownloadRequest.PEImageHeaders pe_headers = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.pe_headers_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_ImageHeaders::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_ImageHeaders*>(&from));
}

void ClientDownloadRequest_ImageHeaders::MergeFrom(const ClientDownloadRequest_ImageHeaders& from)
{
    ClientDownloadRequest_ImageHeaders* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.ImageHeaders)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.mach_o_headers_.MergeFrom(from._impl_.mach_o_headers_);
    if (from._internal_has_pe_headers()) {
        _this->_internal_mutable_pe_headers()->::safe_browsing::ClientDownloadRequest_PEImageHeaders::MergeFrom(from._internal_pe_headers());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_ImageHeaders::CopyFrom(const ClientDownloadRequest_ImageHeaders& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.ImageHeaders)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_ImageHeaders::IsInitialized() const
{
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.mach_o_headers_))
        return false;
    return true;
}

void ClientDownloadRequest_ImageHeaders::InternalSwap(ClientDownloadRequest_ImageHeaders* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.mach_o_headers_.InternalSwap(&other->_impl_.mach_o_headers_);
    swap(_impl_.pe_headers_, other->_impl_.pe_headers_);
}

std::string ClientDownloadRequest_ImageHeaders::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.ImageHeaders";
}

// ===================================================================

class ClientDownloadRequest_ArchivedBinary::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest_ArchivedBinary>()._impl_._has_bits_);
    static void set_has_file_path(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_download_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::safe_browsing::ClientDownloadRequest_Digests& digests(const ClientDownloadRequest_ArchivedBinary* msg);
    static void set_has_digests(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::safe_browsing::ClientDownloadRequest_SignatureInfo& signature(const ClientDownloadRequest_ArchivedBinary* msg);
    static void set_has_signature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::safe_browsing::ClientDownloadRequest_ImageHeaders& image_headers(const ClientDownloadRequest_ArchivedBinary* msg);
    static void set_has_image_headers(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_is_encrypted(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_is_executable(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_is_archive(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
};

const ::safe_browsing::ClientDownloadRequest_Digests& ClientDownloadRequest_ArchivedBinary::_Internal::digests(const ClientDownloadRequest_ArchivedBinary* msg)
{
    return *msg->_impl_.digests_;
}
const ::safe_browsing::ClientDownloadRequest_SignatureInfo& ClientDownloadRequest_ArchivedBinary::_Internal::signature(
    const ClientDownloadRequest_ArchivedBinary* msg)
{
    return *msg->_impl_.signature_;
}
const ::safe_browsing::ClientDownloadRequest_ImageHeaders& ClientDownloadRequest_ArchivedBinary::_Internal::image_headers(
    const ClientDownloadRequest_ArchivedBinary* msg)
{
    return *msg->_impl_.image_headers_;
}
ClientDownloadRequest_ArchivedBinary::ClientDownloadRequest_ArchivedBinary(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.ArchivedBinary)
}
ClientDownloadRequest_ArchivedBinary::ClientDownloadRequest_ArchivedBinary(const ClientDownloadRequest_ArchivedBinary& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_ArchivedBinary* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.file_path_) {},
        decltype(_impl_.digests_) { nullptr }, decltype(_impl_.signature_) { nullptr }, decltype(_impl_.image_headers_) { nullptr },
        decltype(_impl_.length_) {}, decltype(_impl_.download_type_) {}, decltype(_impl_.is_encrypted_) {}, decltype(_impl_.is_executable_) {},
        decltype(_impl_.is_archive_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.file_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_file_path()) {
        _this->_impl_.file_path_.Set(from._internal_file_path(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_digests()) {
        _this->_impl_.digests_ = new ::safe_browsing::ClientDownloadRequest_Digests(*from._impl_.digests_);
    }
    if (from._internal_has_signature()) {
        _this->_impl_.signature_ = new ::safe_browsing::ClientDownloadRequest_SignatureInfo(*from._impl_.signature_);
    }
    if (from._internal_has_image_headers()) {
        _this->_impl_.image_headers_ = new ::safe_browsing::ClientDownloadRequest_ImageHeaders(*from._impl_.image_headers_);
    }
    ::memcpy(&_impl_.length_, &from._impl_.length_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_archive_) - reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.is_archive_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.ArchivedBinary)
}

inline void ClientDownloadRequest_ArchivedBinary::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.file_path_) {},
        decltype(_impl_.digests_) { nullptr }, decltype(_impl_.signature_) { nullptr }, decltype(_impl_.image_headers_) { nullptr },
        decltype(_impl_.length_) { int64_t { 0 } }, decltype(_impl_.download_type_) { 0 }, decltype(_impl_.is_encrypted_) { false },
        decltype(_impl_.is_executable_) { false }, decltype(_impl_.is_archive_) { false } };
    _impl_.file_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_ArchivedBinary::~ClientDownloadRequest_ArchivedBinary()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.ArchivedBinary)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_ArchivedBinary::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.file_path_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.digests_;
    if (this != internal_default_instance())
        delete _impl_.signature_;
    if (this != internal_default_instance())
        delete _impl_.image_headers_;
}

void ClientDownloadRequest_ArchivedBinary::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_ArchivedBinary::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.ArchivedBinary)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.file_path_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.digests_ != nullptr);
            _impl_.digests_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.signature_ != nullptr);
            _impl_.signature_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.image_headers_ != nullptr);
            _impl_.image_headers_->Clear();
        }
    }
    if (cached_has_bits & 0x000000f0u) {
        ::memset(&_impl_.length_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_executable_) - reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.is_executable_));
    }
    _impl_.is_archive_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_ArchivedBinary::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string file_path = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_file_path();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadRequest_DownloadType_IsValid(val))) {
                    _internal_set_download_type(static_cast<::safe_browsing::ClientDownloadRequest_DownloadType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest.Digests digests = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_digests(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 length = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_length(&has_bits);
                _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_signature(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_image_headers(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_encrypted = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_is_encrypted(&has_bits);
                _impl_.is_encrypted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_executable = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_is_executable(&has_bits);
                _impl_.is_executable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_archive = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _Internal::set_has_is_archive(&has_bits);
                _impl_.is_archive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_ArchivedBinary::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.ArchivedBinary)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string file_path = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_file_path(), target);
    }

    // optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 2;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_download_type(), target);
    }

    // optional .safe_browsing.ClientDownloadRequest.Digests digests = 3;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::digests(this), _Internal::digests(this).GetCachedSize(), target, stream);
    }

    // optional int64 length = 4;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_length(), target);
    }

    // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::signature(this), _Internal::signature(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 6;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::image_headers(this), _Internal::image_headers(this).GetCachedSize(), target, stream);
    }

    // optional bool is_encrypted = 7;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_is_encrypted(), target);
    }

    // optional bool is_executable = 8;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_is_executable(), target);
    }

    // optional bool is_archive = 9;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_is_archive(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.ArchivedBinary)
    return target;
}

size_t ClientDownloadRequest_ArchivedBinary::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.ArchivedBinary)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string file_path = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_file_path());
        }

        // optional .safe_browsing.ClientDownloadRequest.Digests digests = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.digests_);
        }

        // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.signature_);
        }

        // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 6;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.image_headers_);
        }

        // optional int64 length = 4;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_length());
        }

        // optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 2;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_download_type());
        }

        // optional bool is_encrypted = 7;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + 1;
        }

        // optional bool is_executable = 8;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + 1;
        }
    }
    // optional bool is_archive = 9;
    if (cached_has_bits & 0x00000100u) {
        total_size += 1 + 1;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_ArchivedBinary::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_ArchivedBinary*>(&from));
}

void ClientDownloadRequest_ArchivedBinary::MergeFrom(const ClientDownloadRequest_ArchivedBinary& from)
{
    ClientDownloadRequest_ArchivedBinary* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.ArchivedBinary)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_file_path(from._internal_file_path());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_digests()->::safe_browsing::ClientDownloadRequest_Digests::MergeFrom(from._internal_digests());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_signature()->::safe_browsing::ClientDownloadRequest_SignatureInfo::MergeFrom(from._internal_signature());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_image_headers()->::safe_browsing::ClientDownloadRequest_ImageHeaders::MergeFrom(from._internal_image_headers());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.length_ = from._impl_.length_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.download_type_ = from._impl_.download_type_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.is_encrypted_ = from._impl_.is_encrypted_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.is_executable_ = from._impl_.is_executable_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00000100u) {
        _this->_internal_set_is_archive(from._internal_is_archive());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_ArchivedBinary::CopyFrom(const ClientDownloadRequest_ArchivedBinary& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.ArchivedBinary)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_ArchivedBinary::IsInitialized() const
{
    if (_internal_has_signature()) {
        if (!_impl_.signature_->IsInitialized())
            return false;
    }
    if (_internal_has_image_headers()) {
        if (!_impl_.image_headers_->IsInitialized())
            return false;
    }
    return true;
}

void ClientDownloadRequest_ArchivedBinary::InternalSwap(ClientDownloadRequest_ArchivedBinary* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.file_path_, lhs_arena, &other->_impl_.file_path_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientDownloadRequest_ArchivedBinary, _impl_.is_archive_)
        + sizeof(ClientDownloadRequest_ArchivedBinary::_impl_.is_archive_) - PROTOBUF_FIELD_OFFSET(ClientDownloadRequest_ArchivedBinary, _impl_.digests_)>(
        reinterpret_cast<char*>(&_impl_.digests_), reinterpret_cast<char*>(&other->_impl_.digests_));
}

std::string ClientDownloadRequest_ArchivedBinary::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.ArchivedBinary";
}

// ===================================================================

class ClientDownloadRequest_DetachedCodeSignature::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest_DetachedCodeSignature>()._impl_._has_bits_);
    static void set_has_file_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_contents(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
    }
};

ClientDownloadRequest_DetachedCodeSignature::ClientDownloadRequest_DetachedCodeSignature(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.DetachedCodeSignature)
}
ClientDownloadRequest_DetachedCodeSignature::ClientDownloadRequest_DetachedCodeSignature(const ClientDownloadRequest_DetachedCodeSignature& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_DetachedCodeSignature* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.file_name_) {},
        decltype(_impl_.contents_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.file_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_file_name()) {
        _this->_impl_.file_name_.Set(from._internal_file_name(), _this->GetArenaForAllocation());
    }
    _impl_.contents_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contents_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_contents()) {
        _this->_impl_.contents_.Set(from._internal_contents(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.DetachedCodeSignature)
}

inline void ClientDownloadRequest_DetachedCodeSignature::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.file_name_) {}, decltype(_impl_.contents_) {} };
    _impl_.file_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contents_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contents_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest_DetachedCodeSignature::~ClientDownloadRequest_DetachedCodeSignature()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.DetachedCodeSignature)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_DetachedCodeSignature::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.file_name_.Destroy();
    _impl_.contents_.Destroy();
}

void ClientDownloadRequest_DetachedCodeSignature::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_DetachedCodeSignature::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.DetachedCodeSignature)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.file_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.contents_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_DetachedCodeSignature::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required string file_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_file_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required bytes contents = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_contents();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_DetachedCodeSignature::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.DetachedCodeSignature)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required string file_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_file_name(), target);
    }

    // required bytes contents = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_contents(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.DetachedCodeSignature)
    return target;
}

size_t ClientDownloadRequest_DetachedCodeSignature::RequiredFieldsByteSizeFallback() const
{
    // @@protoc_insertion_point(required_fields_byte_size_fallback_start:safe_browsing.ClientDownloadRequest.DetachedCodeSignature)
    size_t total_size = 0;

    if (_internal_has_file_name()) {
        // required string file_name = 1;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_file_name());
    }

    if (_internal_has_contents()) {
        // required bytes contents = 2;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_contents());
    }

    return total_size;
}
size_t ClientDownloadRequest_DetachedCodeSignature::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.DetachedCodeSignature)
    size_t total_size = 0;

    if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) { // All required fields are present.
        // required string file_name = 1;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_file_name());

        // required bytes contents = 2;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_contents());

    } else {
        total_size += RequiredFieldsByteSizeFallback();
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_DetachedCodeSignature::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_DetachedCodeSignature*>(&from));
}

void ClientDownloadRequest_DetachedCodeSignature::MergeFrom(const ClientDownloadRequest_DetachedCodeSignature& from)
{
    ClientDownloadRequest_DetachedCodeSignature* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.DetachedCodeSignature)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_file_name(from._internal_file_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_contents(from._internal_contents());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_DetachedCodeSignature::CopyFrom(const ClientDownloadRequest_DetachedCodeSignature& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.DetachedCodeSignature)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_DetachedCodeSignature::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    return true;
}

void ClientDownloadRequest_DetachedCodeSignature::InternalSwap(ClientDownloadRequest_DetachedCodeSignature* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.file_name_, lhs_arena, &other->_impl_.file_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.contents_, lhs_arena, &other->_impl_.contents_, rhs_arena);
}

std::string ClientDownloadRequest_DetachedCodeSignature::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.DetachedCodeSignature";
}

// ===================================================================

class ClientDownloadRequest_ArchiveSummary::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest_ArchiveSummary>()._impl_._has_bits_);
    static void set_has_parser_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_file_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_directory_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_is_encrypted(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

ClientDownloadRequest_ArchiveSummary::ClientDownloadRequest_ArchiveSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.ArchiveSummary)
}
ClientDownloadRequest_ArchiveSummary::ClientDownloadRequest_ArchiveSummary(const ClientDownloadRequest_ArchiveSummary& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_ArchiveSummary* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.parser_status_) {},
        decltype(_impl_.file_count_) {}, decltype(_impl_.directory_count_) {}, decltype(_impl_.is_encrypted_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.parser_status_, &from._impl_.parser_status_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_encrypted_) - reinterpret_cast<char*>(&_impl_.parser_status_)) + sizeof(_impl_.is_encrypted_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.ArchiveSummary)
}

inline void ClientDownloadRequest_ArchiveSummary::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.parser_status_) { 0 },
        decltype(_impl_.file_count_) { 0 }, decltype(_impl_.directory_count_) { 0 }, decltype(_impl_.is_encrypted_) { false } };
}

ClientDownloadRequest_ArchiveSummary::~ClientDownloadRequest_ArchiveSummary()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.ArchiveSummary)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_ArchiveSummary::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientDownloadRequest_ArchiveSummary::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_ArchiveSummary::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.ArchiveSummary)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        ::memset(&_impl_.parser_status_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_encrypted_) - reinterpret_cast<char*>(&_impl_.parser_status_))
                + sizeof(_impl_.is_encrypted_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_ArchiveSummary::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientDownloadRequest.ArchiveSummary.Status parser_status = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadRequest_ArchiveSummary_Status_IsValid(val))) {
                    _internal_set_parser_status(static_cast<::safe_browsing::ClientDownloadRequest_ArchiveSummary_Status>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int32 file_count = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_file_count(&has_bits);
                _impl_.file_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 directory_count = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_directory_count(&has_bits);
                _impl_.directory_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_encrypted = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_is_encrypted(&has_bits);
                _impl_.is_encrypted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_ArchiveSummary::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.ArchiveSummary)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientDownloadRequest.ArchiveSummary.Status parser_status = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_parser_status(), target);
    }

    // optional int32 file_count = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_file_count(), target);
    }

    // optional int32 directory_count = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_directory_count(), target);
    }

    // optional bool is_encrypted = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_encrypted(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.ArchiveSummary)
    return target;
}

size_t ClientDownloadRequest_ArchiveSummary::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.ArchiveSummary)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .safe_browsing.ClientDownloadRequest.ArchiveSummary.Status parser_status = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_parser_status());
        }

        // optional int32 file_count = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_file_count());
        }

        // optional int32 directory_count = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_directory_count());
        }

        // optional bool is_encrypted = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_ArchiveSummary::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_ArchiveSummary*>(&from));
}

void ClientDownloadRequest_ArchiveSummary::MergeFrom(const ClientDownloadRequest_ArchiveSummary& from)
{
    ClientDownloadRequest_ArchiveSummary* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.ArchiveSummary)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.parser_status_ = from._impl_.parser_status_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.file_count_ = from._impl_.file_count_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.directory_count_ = from._impl_.directory_count_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.is_encrypted_ = from._impl_.is_encrypted_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_ArchiveSummary::CopyFrom(const ClientDownloadRequest_ArchiveSummary& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.ArchiveSummary)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_ArchiveSummary::IsInitialized() const
{
    return true;
}

void ClientDownloadRequest_ArchiveSummary::InternalSwap(ClientDownloadRequest_ArchiveSummary* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientDownloadRequest_ArchiveSummary, _impl_.is_encrypted_)
        + sizeof(ClientDownloadRequest_ArchiveSummary::_impl_.is_encrypted_)
        - PROTOBUF_FIELD_OFFSET(ClientDownloadRequest_ArchiveSummary, _impl_.parser_status_)>(
        reinterpret_cast<char*>(&_impl_.parser_status_), reinterpret_cast<char*>(&other->_impl_.parser_status_));
}

std::string ClientDownloadRequest_ArchiveSummary::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.ArchiveSummary";
}

// ===================================================================

class ClientDownloadRequest_TailoredInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest_TailoredInfo>()._impl_._has_bits_);
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ClientDownloadRequest_TailoredInfo::ClientDownloadRequest_TailoredInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest.TailoredInfo)
}
ClientDownloadRequest_TailoredInfo::ClientDownloadRequest_TailoredInfo(const ClientDownloadRequest_TailoredInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest_TailoredInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.version_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.version_ = from._impl_.version_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest.TailoredInfo)
}

inline void ClientDownloadRequest_TailoredInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.version_) { 0 } };
}

ClientDownloadRequest_TailoredInfo::~ClientDownloadRequest_TailoredInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest.TailoredInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest_TailoredInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientDownloadRequest_TailoredInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest_TailoredInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest.TailoredInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.version_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest_TailoredInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 version = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_version(&has_bits);
                _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest_TailoredInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest.TailoredInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 version = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_version(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest.TailoredInfo)
    return target;
}

size_t ClientDownloadRequest_TailoredInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest.TailoredInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional int32 version = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_version());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest_TailoredInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest_TailoredInfo*>(&from));
}

void ClientDownloadRequest_TailoredInfo::MergeFrom(const ClientDownloadRequest_TailoredInfo& from)
{
    ClientDownloadRequest_TailoredInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest.TailoredInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_version()) {
        _this->_internal_set_version(from._internal_version());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest_TailoredInfo::CopyFrom(const ClientDownloadRequest_TailoredInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest.TailoredInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest_TailoredInfo::IsInitialized() const
{
    return true;
}

void ClientDownloadRequest_TailoredInfo::InternalSwap(ClientDownloadRequest_TailoredInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.version_, other->_impl_.version_);
}

std::string ClientDownloadRequest_TailoredInfo::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest.TailoredInfo";
}

// ===================================================================

class ClientDownloadRequest::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadRequest>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::safe_browsing::ClientDownloadRequest_Digests& digests(const ClientDownloadRequest* msg);
    static void set_has_digests(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static const ::safe_browsing::ClientDownloadRequest_SignatureInfo& signature(const ClientDownloadRequest* msg);
    static void set_has_signature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_user_initiated(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32768u;
    }
    static void set_has_file_basename(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_download_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static void set_has_locale(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::safe_browsing::ClientDownloadRequest_ImageHeaders& image_headers(const ClientDownloadRequest* msg);
    static void set_has_image_headers(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static const ::safe_browsing::ChromeUserPopulation& population(const ClientDownloadRequest* msg);
    static void set_has_population(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_deprecated_archive_valid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 65536u;
    }
    static void set_has_skipped_url_allowlist(HasBits* has_bits)
    {
        (*has_bits)[0] |= 131072u;
    }
    static void set_has_skipped_certificate_allowlist(HasBits* has_bits)
    {
        (*has_bits)[0] |= 262144u;
    }
    static const ::safe_browsing::ReferrerChainOptions& referrer_chain_options(const ClientDownloadRequest* msg);
    static void set_has_referrer_chain_options(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_deprecated_download_attribution_finch_enabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 524288u;
    }
    static void set_has_udif_code_signature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_request_ap_verdicts(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1048576u;
    }
    static void set_has_deprecated_archive_file_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2097152u;
    }
    static void set_has_deprecated_archive_directory_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4194304u;
    }
    static void set_has_access_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::safe_browsing::ClientDownloadRequest_ArchiveSummary& archive_summary(const ClientDownloadRequest* msg);
    static void set_has_archive_summary(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static const ::safe_browsing::ClientDownloadRequest_TailoredInfo& tailored_info(const ClientDownloadRequest* msg);
    static void set_has_tailored_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static void set_has_previous_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00002041) ^ 0x00002041) != 0;
    }
};

const ::safe_browsing::ClientDownloadRequest_Digests& ClientDownloadRequest::_Internal::digests(const ClientDownloadRequest* msg)
{
    return *msg->_impl_.digests_;
}
const ::safe_browsing::ClientDownloadRequest_SignatureInfo& ClientDownloadRequest::_Internal::signature(const ClientDownloadRequest* msg)
{
    return *msg->_impl_.signature_;
}
const ::safe_browsing::ClientDownloadRequest_ImageHeaders& ClientDownloadRequest::_Internal::image_headers(const ClientDownloadRequest* msg)
{
    return *msg->_impl_.image_headers_;
}
const ::safe_browsing::ChromeUserPopulation& ClientDownloadRequest::_Internal::population(const ClientDownloadRequest* msg)
{
    return *msg->_impl_.population_;
}
const ::safe_browsing::ReferrerChainOptions& ClientDownloadRequest::_Internal::referrer_chain_options(const ClientDownloadRequest* msg)
{
    return *msg->_impl_.referrer_chain_options_;
}
const ::safe_browsing::ClientDownloadRequest_ArchiveSummary& ClientDownloadRequest::_Internal::archive_summary(const ClientDownloadRequest* msg)
{
    return *msg->_impl_.archive_summary_;
}
const ::safe_browsing::ClientDownloadRequest_TailoredInfo& ClientDownloadRequest::_Internal::tailored_info(const ClientDownloadRequest* msg)
{
    return *msg->_impl_.tailored_info_;
}
ClientDownloadRequest::ClientDownloadRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadRequest)
}
ClientDownloadRequest::ClientDownloadRequest(const ClientDownloadRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.resources_) { from._impl_.resources_ }, decltype(_impl_.archived_binary_) { from._impl_.archived_binary_ },
        decltype(_impl_.alternate_extensions_) { from._impl_.alternate_extensions_ }, decltype(_impl_.referrer_chain_) { from._impl_.referrer_chain_ },
        decltype(_impl_.detached_code_signature_) { from._impl_.detached_code_signature_ }, decltype(_impl_.url_) {}, decltype(_impl_.file_basename_) {},
        decltype(_impl_.locale_) {}, decltype(_impl_.udif_code_signature_) {}, decltype(_impl_.access_token_) {}, decltype(_impl_.previous_token_) {},
        decltype(_impl_.digests_) { nullptr }, decltype(_impl_.signature_) { nullptr }, decltype(_impl_.image_headers_) { nullptr },
        decltype(_impl_.population_) { nullptr }, decltype(_impl_.referrer_chain_options_) { nullptr }, decltype(_impl_.archive_summary_) { nullptr },
        decltype(_impl_.tailored_info_) { nullptr }, decltype(_impl_.length_) {}, decltype(_impl_.download_type_) {}, decltype(_impl_.user_initiated_) {},
        decltype(_impl_.deprecated_archive_valid_) {}, decltype(_impl_.skipped_url_allowlist_) {}, decltype(_impl_.skipped_certificate_allowlist_) {},
        decltype(_impl_.deprecated_download_attribution_finch_enabled_) {}, decltype(_impl_.request_ap_verdicts_) {},
        decltype(_impl_.deprecated_archive_file_count_) {}, decltype(_impl_.deprecated_archive_directory_count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _impl_.file_basename_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_basename_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_file_basename()) {
        _this->_impl_.file_basename_.Set(from._internal_file_basename(), _this->GetArenaForAllocation());
    }
    _impl_.locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_locale()) {
        _this->_impl_.locale_.Set(from._internal_locale(), _this->GetArenaForAllocation());
    }
    _impl_.udif_code_signature_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.udif_code_signature_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_udif_code_signature()) {
        _this->_impl_.udif_code_signature_.Set(from._internal_udif_code_signature(), _this->GetArenaForAllocation());
    }
    _impl_.access_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.access_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_access_token()) {
        _this->_impl_.access_token_.Set(from._internal_access_token(), _this->GetArenaForAllocation());
    }
    _impl_.previous_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.previous_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_previous_token()) {
        _this->_impl_.previous_token_.Set(from._internal_previous_token(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_digests()) {
        _this->_impl_.digests_ = new ::safe_browsing::ClientDownloadRequest_Digests(*from._impl_.digests_);
    }
    if (from._internal_has_signature()) {
        _this->_impl_.signature_ = new ::safe_browsing::ClientDownloadRequest_SignatureInfo(*from._impl_.signature_);
    }
    if (from._internal_has_image_headers()) {
        _this->_impl_.image_headers_ = new ::safe_browsing::ClientDownloadRequest_ImageHeaders(*from._impl_.image_headers_);
    }
    if (from._internal_has_population()) {
        _this->_impl_.population_ = new ::safe_browsing::ChromeUserPopulation(*from._impl_.population_);
    }
    if (from._internal_has_referrer_chain_options()) {
        _this->_impl_.referrer_chain_options_ = new ::safe_browsing::ReferrerChainOptions(*from._impl_.referrer_chain_options_);
    }
    if (from._internal_has_archive_summary()) {
        _this->_impl_.archive_summary_ = new ::safe_browsing::ClientDownloadRequest_ArchiveSummary(*from._impl_.archive_summary_);
    }
    if (from._internal_has_tailored_info()) {
        _this->_impl_.tailored_info_ = new ::safe_browsing::ClientDownloadRequest_TailoredInfo(*from._impl_.tailored_info_);
    }
    ::memcpy(&_impl_.length_, &from._impl_.length_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.deprecated_archive_directory_count_) - reinterpret_cast<char*>(&_impl_.length_))
            + sizeof(_impl_.deprecated_archive_directory_count_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadRequest)
}

inline void ClientDownloadRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.resources_) { arena },
        decltype(_impl_.archived_binary_) { arena }, decltype(_impl_.alternate_extensions_) { arena }, decltype(_impl_.referrer_chain_) { arena },
        decltype(_impl_.detached_code_signature_) { arena }, decltype(_impl_.url_) {}, decltype(_impl_.file_basename_) {}, decltype(_impl_.locale_) {},
        decltype(_impl_.udif_code_signature_) {}, decltype(_impl_.access_token_) {}, decltype(_impl_.previous_token_) {}, decltype(_impl_.digests_) { nullptr },
        decltype(_impl_.signature_) { nullptr }, decltype(_impl_.image_headers_) { nullptr }, decltype(_impl_.population_) { nullptr },
        decltype(_impl_.referrer_chain_options_) { nullptr }, decltype(_impl_.archive_summary_) { nullptr }, decltype(_impl_.tailored_info_) { nullptr },
        decltype(_impl_.length_) { int64_t { 0 } }, decltype(_impl_.download_type_) { 0 }, decltype(_impl_.user_initiated_) { false },
        decltype(_impl_.deprecated_archive_valid_) { false }, decltype(_impl_.skipped_url_allowlist_) { false },
        decltype(_impl_.skipped_certificate_allowlist_) { false }, decltype(_impl_.deprecated_download_attribution_finch_enabled_) { false },
        decltype(_impl_.request_ap_verdicts_) { false }, decltype(_impl_.deprecated_archive_file_count_) { 0 },
        decltype(_impl_.deprecated_archive_directory_count_) { 0 } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_basename_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_basename_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.udif_code_signature_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.udif_code_signature_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.access_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.access_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.previous_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.previous_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadRequest::~ClientDownloadRequest()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.resources_.~RepeatedPtrField();
    _impl_.archived_binary_.~RepeatedPtrField();
    _impl_.alternate_extensions_.~RepeatedPtrField();
    _impl_.referrer_chain_.~RepeatedPtrField();
    _impl_.detached_code_signature_.~RepeatedPtrField();
    _impl_.url_.Destroy();
    _impl_.file_basename_.Destroy();
    _impl_.locale_.Destroy();
    _impl_.udif_code_signature_.Destroy();
    _impl_.access_token_.Destroy();
    _impl_.previous_token_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.digests_;
    if (this != internal_default_instance())
        delete _impl_.signature_;
    if (this != internal_default_instance())
        delete _impl_.image_headers_;
    if (this != internal_default_instance())
        delete _impl_.population_;
    if (this != internal_default_instance())
        delete _impl_.referrer_chain_options_;
    if (this != internal_default_instance())
        delete _impl_.archive_summary_;
    if (this != internal_default_instance())
        delete _impl_.tailored_info_;
}

void ClientDownloadRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.resources_.Clear();
    _impl_.archived_binary_.Clear();
    _impl_.alternate_extensions_.Clear();
    _impl_.referrer_chain_.Clear();
    _impl_.detached_code_signature_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.file_basename_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.locale_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.udif_code_signature_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.access_token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.previous_token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.digests_ != nullptr);
            _impl_.digests_->Clear();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.signature_ != nullptr);
            _impl_.signature_->Clear();
        }
    }
    if (cached_has_bits & 0x00001f00u) {
        if (cached_has_bits & 0x00000100u) {
            GOOGLE_DCHECK(_impl_.image_headers_ != nullptr);
            _impl_.image_headers_->Clear();
        }
        if (cached_has_bits & 0x00000200u) {
            GOOGLE_DCHECK(_impl_.population_ != nullptr);
            _impl_.population_->Clear();
        }
        if (cached_has_bits & 0x00000400u) {
            GOOGLE_DCHECK(_impl_.referrer_chain_options_ != nullptr);
            _impl_.referrer_chain_options_->Clear();
        }
        if (cached_has_bits & 0x00000800u) {
            GOOGLE_DCHECK(_impl_.archive_summary_ != nullptr);
            _impl_.archive_summary_->Clear();
        }
        if (cached_has_bits & 0x00001000u) {
            GOOGLE_DCHECK(_impl_.tailored_info_ != nullptr);
            _impl_.tailored_info_->Clear();
        }
    }
    if (cached_has_bits & 0x0000e000u) {
        ::memset(&_impl_.length_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.user_initiated_) - reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.user_initiated_));
    }
    if (cached_has_bits & 0x007f0000u) {
        ::memset(&_impl_.deprecated_archive_valid_, 0,
            static_cast<size_t>(
                reinterpret_cast<char*>(&_impl_.deprecated_archive_directory_count_) - reinterpret_cast<char*>(&_impl_.deprecated_archive_valid_))
                + sizeof(_impl_.deprecated_archive_directory_count_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required .safe_browsing.ClientDownloadRequest.Digests digests = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_digests(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required int64 length = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_length(&has_bits);
                _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientDownloadRequest.Resource resources = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_resources(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_signature(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool user_initiated = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_user_initiated(&has_bits);
                _impl_.user_initiated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string file_basename = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                auto str = _internal_mutable_file_basename();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 10 [default = WIN_EXECUTABLE];
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadRequest_DownloadType_IsValid(val))) {
                    _internal_set_download_type(static_cast<::safe_browsing::ClientDownloadRequest_DownloadType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string locale = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                auto str = _internal_mutable_locale();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 18;
        case 18:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
                ptr = ctx->ParseMessage(_internal_mutable_image_headers(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientDownloadRequest.ArchivedBinary archived_binary = 22;
        case 22:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_archived_binary(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<178>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ChromeUserPopulation population = 24;
        case 24:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
                ptr = ctx->ParseMessage(_internal_mutable_population(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool DEPRECATED_archive_valid = 26 [deprecated = true];
        case 26:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
                _Internal::set_has_deprecated_archive_valid(&has_bits);
                _impl_.deprecated_archive_valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool skipped_url_allowlist = 28;
        case 28:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
                _Internal::set_has_skipped_url_allowlist(&has_bits);
                _impl_.skipped_url_allowlist_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool skipped_certificate_allowlist = 31;
        case 31:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
                _Internal::set_has_skipped_certificate_allowlist(&has_bits);
                _impl_.skipped_certificate_allowlist_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string alternate_extensions = 35;
        case 35:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    auto str = _internal_add_alternate_extensions();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<282>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 36;
        case 36:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_referrer_chain(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<290>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool DEPRECATED_download_attribution_finch_enabled = 39 [deprecated = true];
        case 39:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_deprecated_download_attribution_finch_enabled(&has_bits);
                _impl_.deprecated_download_attribution_finch_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes udif_code_signature = 40;
        case 40:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_udif_code_signature();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ReferrerChainOptions referrer_chain_options = 50;
        case 50:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
                ptr = ctx->ParseMessage(_internal_mutable_referrer_chain_options(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientDownloadRequest.DetachedCodeSignature detached_code_signature = 59;
        case 59:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_detached_code_signature(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<474>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool request_ap_verdicts = 67;
        case 67:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_request_ap_verdicts(&has_bits);
                _impl_.request_ap_verdicts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 DEPRECATED_archive_file_count = 68 [deprecated = true];
        case 68:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_deprecated_archive_file_count(&has_bits);
                _impl_.deprecated_archive_file_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 DEPRECATED_archive_directory_count = 69 [deprecated = true];
        case 69:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_deprecated_archive_directory_count(&has_bits);
                _impl_.deprecated_archive_directory_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string access_token = 78;
        case 78:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                auto str = _internal_mutable_access_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest.ArchiveSummary archive_summary = 85;
        case 85:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
                ptr = ctx->ParseMessage(_internal_mutable_archive_summary(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest.TailoredInfo tailored_info = 86;
        case 86:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
                ptr = ctx->ParseMessage(_internal_mutable_tailored_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes previous_token = 91;
        case 91:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
                auto str = _internal_mutable_previous_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // required .safe_browsing.ClientDownloadRequest.Digests digests = 2;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::digests(this), _Internal::digests(this).GetCachedSize(), target, stream);
    }

    // required int64 length = 3;
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_length(), target);
    }

    // repeated .safe_browsing.ClientDownloadRequest.Resource resources = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_resources_size()); i < n; i++) {
        const auto& repfield = this->_internal_resources(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::signature(this), _Internal::signature(this).GetCachedSize(), target, stream);
    }

    // optional bool user_initiated = 6;
    if (cached_has_bits & 0x00008000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_user_initiated(), target);
    }

    // optional string file_basename = 9;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(9, this->_internal_file_basename(), target);
    }

    // optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 10 [default = WIN_EXECUTABLE];
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(10, this->_internal_download_type(), target);
    }

    // optional string locale = 11;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(11, this->_internal_locale(), target);
    }

    // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 18;
    if (cached_has_bits & 0x00000100u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            18, _Internal::image_headers(this), _Internal::image_headers(this).GetCachedSize(), target, stream);
    }

    // repeated .safe_browsing.ClientDownloadRequest.ArchivedBinary archived_binary = 22;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_archived_binary_size()); i < n; i++) {
        const auto& repfield = this->_internal_archived_binary(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(22, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ChromeUserPopulation population = 24;
    if (cached_has_bits & 0x00000200u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            24, _Internal::population(this), _Internal::population(this).GetCachedSize(), target, stream);
    }

    // optional bool DEPRECATED_archive_valid = 26 [deprecated = true];
    if (cached_has_bits & 0x00010000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_deprecated_archive_valid(), target);
    }

    // optional bool skipped_url_allowlist = 28;
    if (cached_has_bits & 0x00020000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(28, this->_internal_skipped_url_allowlist(), target);
    }

    // optional bool skipped_certificate_allowlist = 31;
    if (cached_has_bits & 0x00040000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(31, this->_internal_skipped_certificate_allowlist(), target);
    }

    // repeated string alternate_extensions = 35;
    for (int i = 0, n = this->_internal_alternate_extensions_size(); i < n; i++) {
        const auto& s = this->_internal_alternate_extensions(i);
        target = stream->WriteString(35, s, target);
    }

    // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 36;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_referrer_chain_size()); i < n; i++) {
        const auto& repfield = this->_internal_referrer_chain(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(36, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bool DEPRECATED_download_attribution_finch_enabled = 39 [deprecated = true];
    if (cached_has_bits & 0x00080000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(39, this->_internal_deprecated_download_attribution_finch_enabled(), target);
    }

    // optional bytes udif_code_signature = 40;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteBytesMaybeAliased(40, this->_internal_udif_code_signature(), target);
    }

    // optional .safe_browsing.ReferrerChainOptions referrer_chain_options = 50;
    if (cached_has_bits & 0x00000400u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            50, _Internal::referrer_chain_options(this), _Internal::referrer_chain_options(this).GetCachedSize(), target, stream);
    }

    // repeated .safe_browsing.ClientDownloadRequest.DetachedCodeSignature detached_code_signature = 59;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_detached_code_signature_size()); i < n; i++) {
        const auto& repfield = this->_internal_detached_code_signature(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(59, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bool request_ap_verdicts = 67;
    if (cached_has_bits & 0x00100000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(67, this->_internal_request_ap_verdicts(), target);
    }

    // optional int32 DEPRECATED_archive_file_count = 68 [deprecated = true];
    if (cached_has_bits & 0x00200000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(68, this->_internal_deprecated_archive_file_count(), target);
    }

    // optional int32 DEPRECATED_archive_directory_count = 69 [deprecated = true];
    if (cached_has_bits & 0x00400000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(69, this->_internal_deprecated_archive_directory_count(), target);
    }

    // optional string access_token = 78;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(78, this->_internal_access_token(), target);
    }

    // optional .safe_browsing.ClientDownloadRequest.ArchiveSummary archive_summary = 85;
    if (cached_has_bits & 0x00000800u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            85, _Internal::archive_summary(this), _Internal::archive_summary(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientDownloadRequest.TailoredInfo tailored_info = 86;
    if (cached_has_bits & 0x00001000u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            86, _Internal::tailored_info(this), _Internal::tailored_info(this).GetCachedSize(), target, stream);
    }

    // optional bytes previous_token = 91;
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteBytesMaybeAliased(91, this->_internal_previous_token(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadRequest)
    return target;
}

size_t ClientDownloadRequest::RequiredFieldsByteSizeFallback() const
{
    // @@protoc_insertion_point(required_fields_byte_size_fallback_start:safe_browsing.ClientDownloadRequest)
    size_t total_size = 0;

    if (_internal_has_url()) {
        // required string url = 1;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
    }

    if (_internal_has_digests()) {
        // required .safe_browsing.ClientDownloadRequest.Digests digests = 2;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.digests_);
    }

    if (_internal_has_length()) {
        // required int64 length = 3;
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_length());
    }

    return total_size;
}
size_t ClientDownloadRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadRequest)
    size_t total_size = 0;

    if (((_impl_._has_bits_[0] & 0x00002041) ^ 0x00002041) == 0) { // All required fields are present.
        // required string url = 1;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());

        // required .safe_browsing.ClientDownloadRequest.Digests digests = 2;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.digests_);

        // required int64 length = 3;
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_length());

    } else {
        total_size += RequiredFieldsByteSizeFallback();
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientDownloadRequest.Resource resources = 4;
    total_size += 1UL * this->_internal_resources_size();
    for (const auto& msg : this->_impl_.resources_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .safe_browsing.ClientDownloadRequest.ArchivedBinary archived_binary = 22;
    total_size += 2UL * this->_internal_archived_binary_size();
    for (const auto& msg : this->_impl_.archived_binary_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated string alternate_extensions = 35;
    total_size += 2 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.alternate_extensions_.size());
    for (int i = 0, n = _impl_.alternate_extensions_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.alternate_extensions_.Get(i));
    }

    // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 36;
    total_size += 2UL * this->_internal_referrer_chain_size();
    for (const auto& msg : this->_impl_.referrer_chain_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .safe_browsing.ClientDownloadRequest.DetachedCodeSignature detached_code_signature = 59;
    total_size += 2UL * this->_internal_detached_code_signature_size();
    for (const auto& msg : this->_impl_.detached_code_signature_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003eu) {
        // optional string file_basename = 9;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_file_basename());
        }

        // optional string locale = 11;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_locale());
        }

        // optional bytes udif_code_signature = 40;
        if (cached_has_bits & 0x00000008u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_udif_code_signature());
        }

        // optional string access_token = 78;
        if (cached_has_bits & 0x00000010u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_access_token());
        }

        // optional bytes previous_token = 91;
        if (cached_has_bits & 0x00000020u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_previous_token());
        }
    }
    // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 5;
    if (cached_has_bits & 0x00000080u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.signature_);
    }

    if (cached_has_bits & 0x00001f00u) {
        // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 18;
        if (cached_has_bits & 0x00000100u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.image_headers_);
        }

        // optional .safe_browsing.ChromeUserPopulation population = 24;
        if (cached_has_bits & 0x00000200u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.population_);
        }

        // optional .safe_browsing.ReferrerChainOptions referrer_chain_options = 50;
        if (cached_has_bits & 0x00000400u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.referrer_chain_options_);
        }

        // optional .safe_browsing.ClientDownloadRequest.ArchiveSummary archive_summary = 85;
        if (cached_has_bits & 0x00000800u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.archive_summary_);
        }

        // optional .safe_browsing.ClientDownloadRequest.TailoredInfo tailored_info = 86;
        if (cached_has_bits & 0x00001000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.tailored_info_);
        }
    }
    if (cached_has_bits & 0x0000c000u) {
        // optional .safe_browsing.ClientDownloadRequest.DownloadType download_type = 10 [default = WIN_EXECUTABLE];
        if (cached_has_bits & 0x00004000u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_download_type());
        }

        // optional bool user_initiated = 6;
        if (cached_has_bits & 0x00008000u) {
            total_size += 1 + 1;
        }
    }
    if (cached_has_bits & 0x007f0000u) {
        // optional bool DEPRECATED_archive_valid = 26 [deprecated = true];
        if (cached_has_bits & 0x00010000u) {
            total_size += 2 + 1;
        }

        // optional bool skipped_url_allowlist = 28;
        if (cached_has_bits & 0x00020000u) {
            total_size += 2 + 1;
        }

        // optional bool skipped_certificate_allowlist = 31;
        if (cached_has_bits & 0x00040000u) {
            total_size += 2 + 1;
        }

        // optional bool DEPRECATED_download_attribution_finch_enabled = 39 [deprecated = true];
        if (cached_has_bits & 0x00080000u) {
            total_size += 2 + 1;
        }

        // optional bool request_ap_verdicts = 67;
        if (cached_has_bits & 0x00100000u) {
            total_size += 2 + 1;
        }

        // optional int32 DEPRECATED_archive_file_count = 68 [deprecated = true];
        if (cached_has_bits & 0x00200000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int32Size(this->_internal_deprecated_archive_file_count());
        }

        // optional int32 DEPRECATED_archive_directory_count = 69 [deprecated = true];
        if (cached_has_bits & 0x00400000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int32Size(this->_internal_deprecated_archive_directory_count());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadRequest*>(&from));
}

void ClientDownloadRequest::MergeFrom(const ClientDownloadRequest& from)
{
    ClientDownloadRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.resources_.MergeFrom(from._impl_.resources_);
    _this->_impl_.archived_binary_.MergeFrom(from._impl_.archived_binary_);
    _this->_impl_.alternate_extensions_.MergeFrom(from._impl_.alternate_extensions_);
    _this->_impl_.referrer_chain_.MergeFrom(from._impl_.referrer_chain_);
    _this->_impl_.detached_code_signature_.MergeFrom(from._impl_.detached_code_signature_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_file_basename(from._internal_file_basename());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_locale(from._internal_locale());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_udif_code_signature(from._internal_udif_code_signature());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_access_token(from._internal_access_token());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_previous_token(from._internal_previous_token());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_digests()->::safe_browsing::ClientDownloadRequest_Digests::MergeFrom(from._internal_digests());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_signature()->::safe_browsing::ClientDownloadRequest_SignatureInfo::MergeFrom(from._internal_signature());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_mutable_image_headers()->::safe_browsing::ClientDownloadRequest_ImageHeaders::MergeFrom(from._internal_image_headers());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_internal_mutable_population()->::safe_browsing::ChromeUserPopulation::MergeFrom(from._internal_population());
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_internal_mutable_referrer_chain_options()->::safe_browsing::ReferrerChainOptions::MergeFrom(from._internal_referrer_chain_options());
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_internal_mutable_archive_summary()->::safe_browsing::ClientDownloadRequest_ArchiveSummary::MergeFrom(from._internal_archive_summary());
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_internal_mutable_tailored_info()->::safe_browsing::ClientDownloadRequest_TailoredInfo::MergeFrom(from._internal_tailored_info());
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.length_ = from._impl_.length_;
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.download_type_ = from._impl_.download_type_;
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_impl_.user_initiated_ = from._impl_.user_initiated_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x007f0000u) {
        if (cached_has_bits & 0x00010000u) {
            _this->_impl_.deprecated_archive_valid_ = from._impl_.deprecated_archive_valid_;
        }
        if (cached_has_bits & 0x00020000u) {
            _this->_impl_.skipped_url_allowlist_ = from._impl_.skipped_url_allowlist_;
        }
        if (cached_has_bits & 0x00040000u) {
            _this->_impl_.skipped_certificate_allowlist_ = from._impl_.skipped_certificate_allowlist_;
        }
        if (cached_has_bits & 0x00080000u) {
            _this->_impl_.deprecated_download_attribution_finch_enabled_ = from._impl_.deprecated_download_attribution_finch_enabled_;
        }
        if (cached_has_bits & 0x00100000u) {
            _this->_impl_.request_ap_verdicts_ = from._impl_.request_ap_verdicts_;
        }
        if (cached_has_bits & 0x00200000u) {
            _this->_impl_.deprecated_archive_file_count_ = from._impl_.deprecated_archive_file_count_;
        }
        if (cached_has_bits & 0x00400000u) {
            _this->_impl_.deprecated_archive_directory_count_ = from._impl_.deprecated_archive_directory_count_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadRequest::CopyFrom(const ClientDownloadRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadRequest::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.resources_))
        return false;
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.archived_binary_))
        return false;
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.detached_code_signature_))
        return false;
    if (_internal_has_signature()) {
        if (!_impl_.signature_->IsInitialized())
            return false;
    }
    if (_internal_has_image_headers()) {
        if (!_impl_.image_headers_->IsInitialized())
            return false;
    }
    return true;
}

void ClientDownloadRequest::InternalSwap(ClientDownloadRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.resources_.InternalSwap(&other->_impl_.resources_);
    _impl_.archived_binary_.InternalSwap(&other->_impl_.archived_binary_);
    _impl_.alternate_extensions_.InternalSwap(&other->_impl_.alternate_extensions_);
    _impl_.referrer_chain_.InternalSwap(&other->_impl_.referrer_chain_);
    _impl_.detached_code_signature_.InternalSwap(&other->_impl_.detached_code_signature_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.file_basename_, lhs_arena, &other->_impl_.file_basename_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.locale_, lhs_arena, &other->_impl_.locale_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.udif_code_signature_, lhs_arena, &other->_impl_.udif_code_signature_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.access_token_, lhs_arena, &other->_impl_.access_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.previous_token_, lhs_arena, &other->_impl_.previous_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientDownloadRequest, _impl_.deprecated_archive_directory_count_)
        + sizeof(ClientDownloadRequest::_impl_.deprecated_archive_directory_count_) - PROTOBUF_FIELD_OFFSET(ClientDownloadRequest, _impl_.digests_)>(
        reinterpret_cast<char*>(&_impl_.digests_), reinterpret_cast<char*>(&other->_impl_.digests_));
}

std::string ClientDownloadRequest::GetTypeName() const
{
    return "safe_browsing.ClientDownloadRequest";
}

// ===================================================================

class ReferrerChainOptions::_Internal {
public:
    using HasBits = decltype(std::declval<ReferrerChainOptions>()._impl_._has_bits_);
    static void set_has_recent_navigations_to_collect(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ReferrerChainOptions::ReferrerChainOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ReferrerChainOptions)
}
ReferrerChainOptions::ReferrerChainOptions(const ReferrerChainOptions& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ReferrerChainOptions* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.recent_navigations_to_collect_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.recent_navigations_to_collect_ = from._impl_.recent_navigations_to_collect_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ReferrerChainOptions)
}

inline void ReferrerChainOptions::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.recent_navigations_to_collect_) { 0 } };
}

ReferrerChainOptions::~ReferrerChainOptions()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ReferrerChainOptions)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ReferrerChainOptions::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReferrerChainOptions::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ReferrerChainOptions::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ReferrerChainOptions)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.recent_navigations_to_collect_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ReferrerChainOptions::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 recent_navigations_to_collect = 1 [default = 0];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_recent_navigations_to_collect(&has_bits);
                _impl_.recent_navigations_to_collect_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ReferrerChainOptions::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ReferrerChainOptions)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 recent_navigations_to_collect = 1 [default = 0];
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_recent_navigations_to_collect(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ReferrerChainOptions)
    return target;
}

size_t ReferrerChainOptions::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ReferrerChainOptions)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional int32 recent_navigations_to_collect = 1 [default = 0];
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_recent_navigations_to_collect());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ReferrerChainOptions::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ReferrerChainOptions*>(&from));
}

void ReferrerChainOptions::MergeFrom(const ReferrerChainOptions& from)
{
    ReferrerChainOptions* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ReferrerChainOptions)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_recent_navigations_to_collect()) {
        _this->_internal_set_recent_navigations_to_collect(from._internal_recent_navigations_to_collect());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReferrerChainOptions::CopyFrom(const ReferrerChainOptions& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ReferrerChainOptions)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ReferrerChainOptions::IsInitialized() const
{
    return true;
}

void ReferrerChainOptions::InternalSwap(ReferrerChainOptions* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.recent_navigations_to_collect_, other->_impl_.recent_navigations_to_collect_);
}

std::string ReferrerChainOptions::GetTypeName() const
{
    return "safe_browsing.ReferrerChainOptions";
}

// ===================================================================

class ReferrerChainEntry_ServerRedirect::_Internal {
public:
    using HasBits = decltype(std::declval<ReferrerChainEntry_ServerRedirect>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ReferrerChainEntry_ServerRedirect::ReferrerChainEntry_ServerRedirect(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ReferrerChainEntry.ServerRedirect)
}
ReferrerChainEntry_ServerRedirect::ReferrerChainEntry_ServerRedirect(const ReferrerChainEntry_ServerRedirect& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ReferrerChainEntry_ServerRedirect* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ReferrerChainEntry.ServerRedirect)
}

inline void ReferrerChainEntry_ServerRedirect::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {} };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReferrerChainEntry_ServerRedirect::~ReferrerChainEntry_ServerRedirect()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ReferrerChainEntry.ServerRedirect)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ReferrerChainEntry_ServerRedirect::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
}

void ReferrerChainEntry_ServerRedirect::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ReferrerChainEntry_ServerRedirect::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ReferrerChainEntry.ServerRedirect)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.url_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ReferrerChainEntry_ServerRedirect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ReferrerChainEntry_ServerRedirect::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ReferrerChainEntry.ServerRedirect)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ReferrerChainEntry.ServerRedirect)
    return target;
}

size_t ReferrerChainEntry_ServerRedirect::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ReferrerChainEntry.ServerRedirect)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string url = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ReferrerChainEntry_ServerRedirect::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ReferrerChainEntry_ServerRedirect*>(&from));
}

void ReferrerChainEntry_ServerRedirect::MergeFrom(const ReferrerChainEntry_ServerRedirect& from)
{
    ReferrerChainEntry_ServerRedirect* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ReferrerChainEntry.ServerRedirect)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_url()) {
        _this->_internal_set_url(from._internal_url());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReferrerChainEntry_ServerRedirect::CopyFrom(const ReferrerChainEntry_ServerRedirect& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ReferrerChainEntry.ServerRedirect)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ReferrerChainEntry_ServerRedirect::IsInitialized() const
{
    return true;
}

void ReferrerChainEntry_ServerRedirect::InternalSwap(ReferrerChainEntry_ServerRedirect* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
}

std::string ReferrerChainEntry_ServerRedirect::GetTypeName() const
{
    return "safe_browsing.ReferrerChainEntry.ServerRedirect";
}

// ===================================================================

class ReferrerChainEntry::_Internal {
public:
    using HasBits = decltype(std::declval<ReferrerChainEntry>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_main_frame_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_referrer_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_referrer_main_frame_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_is_retargeting(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_navigation_time_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_navigation_initiation(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_maybe_launched_by_external_application(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_is_subframe_url_removed(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_is_subframe_referrer_url_removed(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_is_url_removed_by_policy(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
};

ReferrerChainEntry::ReferrerChainEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ReferrerChainEntry)
}
ReferrerChainEntry::ReferrerChainEntry(const ReferrerChainEntry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ReferrerChainEntry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.ip_addresses_) { from._impl_.ip_addresses_ }, decltype(_impl_.server_redirect_chain_) { from._impl_.server_redirect_chain_ },
        decltype(_impl_.url_) {}, decltype(_impl_.referrer_url_) {}, decltype(_impl_.referrer_main_frame_url_) {}, decltype(_impl_.main_frame_url_) {},
        decltype(_impl_.navigation_time_msec_) {}, decltype(_impl_.navigation_initiation_) {}, decltype(_impl_.is_retargeting_) {},
        decltype(_impl_.maybe_launched_by_external_application_) {}, decltype(_impl_.is_subframe_url_removed_) {},
        decltype(_impl_.is_subframe_referrer_url_removed_) {}, decltype(_impl_.is_url_removed_by_policy_) {}, decltype(_impl_.type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _impl_.referrer_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_referrer_url()) {
        _this->_impl_.referrer_url_.Set(from._internal_referrer_url(), _this->GetArenaForAllocation());
    }
    _impl_.referrer_main_frame_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_main_frame_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_referrer_main_frame_url()) {
        _this->_impl_.referrer_main_frame_url_.Set(from._internal_referrer_main_frame_url(), _this->GetArenaForAllocation());
    }
    _impl_.main_frame_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.main_frame_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_main_frame_url()) {
        _this->_impl_.main_frame_url_.Set(from._internal_main_frame_url(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.navigation_time_msec_, &from._impl_.navigation_time_msec_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) - reinterpret_cast<char*>(&_impl_.navigation_time_msec_)) + sizeof(_impl_.type_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ReferrerChainEntry)
}

inline void ReferrerChainEntry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.ip_addresses_) { arena },
        decltype(_impl_.server_redirect_chain_) { arena }, decltype(_impl_.url_) {}, decltype(_impl_.referrer_url_) {},
        decltype(_impl_.referrer_main_frame_url_) {}, decltype(_impl_.main_frame_url_) {}, decltype(_impl_.navigation_time_msec_) { 0 },
        decltype(_impl_.navigation_initiation_) { 0 }, decltype(_impl_.is_retargeting_) { false },
        decltype(_impl_.maybe_launched_by_external_application_) { false }, decltype(_impl_.is_subframe_url_removed_) { false },
        decltype(_impl_.is_subframe_referrer_url_removed_) { false }, decltype(_impl_.is_url_removed_by_policy_) { false }, decltype(_impl_.type_) { 4 } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_main_frame_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_main_frame_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.main_frame_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.main_frame_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReferrerChainEntry::~ReferrerChainEntry()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ReferrerChainEntry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ReferrerChainEntry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.ip_addresses_.~RepeatedPtrField();
    _impl_.server_redirect_chain_.~RepeatedPtrField();
    _impl_.url_.Destroy();
    _impl_.referrer_url_.Destroy();
    _impl_.referrer_main_frame_url_.Destroy();
    _impl_.main_frame_url_.Destroy();
}

void ReferrerChainEntry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ReferrerChainEntry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ReferrerChainEntry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.ip_addresses_.Clear();
    _impl_.server_redirect_chain_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.referrer_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.referrer_main_frame_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.main_frame_url_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x000000f0u) {
        ::memset(&_impl_.navigation_time_msec_, 0,
            static_cast<size_t>(
                reinterpret_cast<char*>(&_impl_.maybe_launched_by_external_application_) - reinterpret_cast<char*>(&_impl_.navigation_time_msec_))
                + sizeof(_impl_.maybe_launched_by_external_application_));
    }
    if (cached_has_bits & 0x00000f00u) {
        ::memset(&_impl_.is_subframe_url_removed_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_url_removed_by_policy_) - reinterpret_cast<char*>(&_impl_.is_subframe_url_removed_))
                + sizeof(_impl_.is_url_removed_by_policy_));
        _impl_.type_ = 4;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ReferrerChainEntry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ReferrerChainEntry.URLType type = 2 [default = CLIENT_REDIRECT];
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ReferrerChainEntry_URLType_IsValid(val))) {
                    _internal_set_type(static_cast<::safe_browsing::ReferrerChainEntry_URLType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated string ip_addresses = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_ip_addresses();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string referrer_url = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_referrer_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string referrer_main_frame_url = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_referrer_main_frame_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_retargeting = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_is_retargeting(&has_bits);
                _impl_.is_retargeting_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional double navigation_time_msec = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
                _Internal::set_has_navigation_time_msec(&has_bits);
                _impl_.navigation_time_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
                ptr += sizeof(double);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ReferrerChainEntry.ServerRedirect server_redirect_chain = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_server_redirect_chain(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string main_frame_url = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                auto str = _internal_mutable_main_frame_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ReferrerChainEntry.NavigationInitiation navigation_initiation = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ReferrerChainEntry_NavigationInitiation_IsValid(val))) {
                    _internal_set_navigation_initiation(static_cast<::safe_browsing::ReferrerChainEntry_NavigationInitiation>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional bool maybe_launched_by_external_application = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
                _Internal::set_has_maybe_launched_by_external_application(&has_bits);
                _impl_.maybe_launched_by_external_application_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_subframe_url_removed = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                _Internal::set_has_is_subframe_url_removed(&has_bits);
                _impl_.is_subframe_url_removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_subframe_referrer_url_removed = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                _Internal::set_has_is_subframe_referrer_url_removed(&has_bits);
                _impl_.is_subframe_referrer_url_removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_url_removed_by_policy = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
                _Internal::set_has_is_url_removed_by_policy(&has_bits);
                _impl_.is_url_removed_by_policy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ReferrerChainEntry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ReferrerChainEntry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // optional .safe_browsing.ReferrerChainEntry.URLType type = 2 [default = CLIENT_REDIRECT];
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_type(), target);
    }

    // repeated string ip_addresses = 3;
    for (int i = 0, n = this->_internal_ip_addresses_size(); i < n; i++) {
        const auto& s = this->_internal_ip_addresses(i);
        target = stream->WriteString(3, s, target);
    }

    // optional string referrer_url = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_referrer_url(), target);
    }

    // optional string referrer_main_frame_url = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_referrer_main_frame_url(), target);
    }

    // optional bool is_retargeting = 6;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_retargeting(), target);
    }

    // optional double navigation_time_msec = 7;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_navigation_time_msec(), target);
    }

    // repeated .safe_browsing.ReferrerChainEntry.ServerRedirect server_redirect_chain = 8;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_server_redirect_chain_size()); i < n; i++) {
        const auto& repfield = this->_internal_server_redirect_chain(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional string main_frame_url = 9;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(9, this->_internal_main_frame_url(), target);
    }

    // optional .safe_browsing.ReferrerChainEntry.NavigationInitiation navigation_initiation = 10;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(10, this->_internal_navigation_initiation(), target);
    }

    // optional bool maybe_launched_by_external_application = 11;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_maybe_launched_by_external_application(), target);
    }

    // optional bool is_subframe_url_removed = 12;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_is_subframe_url_removed(), target);
    }

    // optional bool is_subframe_referrer_url_removed = 13;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_is_subframe_referrer_url_removed(), target);
    }

    // optional bool is_url_removed_by_policy = 14;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_is_url_removed_by_policy(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ReferrerChainEntry)
    return target;
}

size_t ReferrerChainEntry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ReferrerChainEntry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string ip_addresses = 3;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.ip_addresses_.size());
    for (int i = 0, n = _impl_.ip_addresses_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.ip_addresses_.Get(i));
    }

    // repeated .safe_browsing.ReferrerChainEntry.ServerRedirect server_redirect_chain = 8;
    total_size += 1UL * this->_internal_server_redirect_chain_size();
    for (const auto& msg : this->_impl_.server_redirect_chain_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional string referrer_url = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_referrer_url());
        }

        // optional string referrer_main_frame_url = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_referrer_main_frame_url());
        }

        // optional string main_frame_url = 9;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_main_frame_url());
        }

        // optional double navigation_time_msec = 7;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 8;
        }

        // optional .safe_browsing.ReferrerChainEntry.NavigationInitiation navigation_initiation = 10;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_navigation_initiation());
        }

        // optional bool is_retargeting = 6;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + 1;
        }

        // optional bool maybe_launched_by_external_application = 11;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + 1;
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        // optional bool is_subframe_url_removed = 12;
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + 1;
        }

        // optional bool is_subframe_referrer_url_removed = 13;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + 1;
        }

        // optional bool is_url_removed_by_policy = 14;
        if (cached_has_bits & 0x00000400u) {
            total_size += 1 + 1;
        }

        // optional .safe_browsing.ReferrerChainEntry.URLType type = 2 [default = CLIENT_REDIRECT];
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ReferrerChainEntry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ReferrerChainEntry*>(&from));
}

void ReferrerChainEntry::MergeFrom(const ReferrerChainEntry& from)
{
    ReferrerChainEntry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ReferrerChainEntry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.ip_addresses_.MergeFrom(from._impl_.ip_addresses_);
    _this->_impl_.server_redirect_chain_.MergeFrom(from._impl_.server_redirect_chain_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_referrer_url(from._internal_referrer_url());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_referrer_main_frame_url(from._internal_referrer_main_frame_url());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_main_frame_url(from._internal_main_frame_url());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.navigation_time_msec_ = from._impl_.navigation_time_msec_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.navigation_initiation_ = from._impl_.navigation_initiation_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.is_retargeting_ = from._impl_.is_retargeting_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.maybe_launched_by_external_application_ = from._impl_.maybe_launched_by_external_application_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00000f00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.is_subframe_url_removed_ = from._impl_.is_subframe_url_removed_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.is_subframe_referrer_url_removed_ = from._impl_.is_subframe_referrer_url_removed_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.is_url_removed_by_policy_ = from._impl_.is_url_removed_by_policy_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReferrerChainEntry::CopyFrom(const ReferrerChainEntry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ReferrerChainEntry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ReferrerChainEntry::IsInitialized() const
{
    return true;
}

void ReferrerChainEntry::InternalSwap(ReferrerChainEntry* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.ip_addresses_.InternalSwap(&other->_impl_.ip_addresses_);
    _impl_.server_redirect_chain_.InternalSwap(&other->_impl_.server_redirect_chain_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.referrer_url_, lhs_arena, &other->_impl_.referrer_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.referrer_main_frame_url_, lhs_arena, &other->_impl_.referrer_main_frame_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.main_frame_url_, lhs_arena, &other->_impl_.main_frame_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ReferrerChainEntry, _impl_.is_url_removed_by_policy_)
        + sizeof(ReferrerChainEntry::_impl_.is_url_removed_by_policy_) - PROTOBUF_FIELD_OFFSET(ReferrerChainEntry, _impl_.navigation_time_msec_)>(
        reinterpret_cast<char*>(&_impl_.navigation_time_msec_), reinterpret_cast<char*>(&other->_impl_.navigation_time_msec_));
    swap(_impl_.type_, other->_impl_.type_);
}

std::string ReferrerChainEntry::GetTypeName() const
{
    return "safe_browsing.ReferrerChainEntry";
}

// ===================================================================

class ClientDownloadResponse_MoreInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadResponse_MoreInfo>()._impl_._has_bits_);
    static void set_has_description(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ClientDownloadResponse_MoreInfo::ClientDownloadResponse_MoreInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadResponse.MoreInfo)
}
ClientDownloadResponse_MoreInfo::ClientDownloadResponse_MoreInfo(const ClientDownloadResponse_MoreInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadResponse_MoreInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.description_) {},
        decltype(_impl_.url_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_description()) {
        _this->_impl_.description_.Set(from._internal_description(), _this->GetArenaForAllocation());
    }
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadResponse.MoreInfo)
}

inline void ClientDownloadResponse_MoreInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.description_) {}, decltype(_impl_.url_) {} };
    _impl_.description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadResponse_MoreInfo::~ClientDownloadResponse_MoreInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadResponse.MoreInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadResponse_MoreInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.description_.Destroy();
    _impl_.url_.Destroy();
}

void ClientDownloadResponse_MoreInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadResponse_MoreInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadResponse.MoreInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.description_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadResponse_MoreInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string description = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_description();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string url = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadResponse_MoreInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadResponse.MoreInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string description = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_description(), target);
    }

    // optional string url = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_url(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadResponse.MoreInfo)
    return target;
}

size_t ClientDownloadResponse_MoreInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadResponse.MoreInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string description = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_description());
        }

        // optional string url = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadResponse_MoreInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadResponse_MoreInfo*>(&from));
}

void ClientDownloadResponse_MoreInfo::MergeFrom(const ClientDownloadResponse_MoreInfo& from)
{
    ClientDownloadResponse_MoreInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadResponse.MoreInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_description(from._internal_description());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_url(from._internal_url());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadResponse_MoreInfo::CopyFrom(const ClientDownloadResponse_MoreInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadResponse.MoreInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadResponse_MoreInfo::IsInitialized() const
{
    return true;
}

void ClientDownloadResponse_MoreInfo::InternalSwap(ClientDownloadResponse_MoreInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.description_, lhs_arena, &other->_impl_.description_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
}

std::string ClientDownloadResponse_MoreInfo::GetTypeName() const
{
    return "safe_browsing.ClientDownloadResponse.MoreInfo";
}

// ===================================================================

class ClientDownloadResponse_TailoredVerdict::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadResponse_TailoredVerdict>()._impl_._has_bits_);
    static void set_has_tailored_verdict_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ClientDownloadResponse_TailoredVerdict::ClientDownloadResponse_TailoredVerdict(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadResponse.TailoredVerdict)
}
ClientDownloadResponse_TailoredVerdict::ClientDownloadResponse_TailoredVerdict(const ClientDownloadResponse_TailoredVerdict& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadResponse_TailoredVerdict* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.adjustments_) { from._impl_.adjustments_ }, /*decltype(_impl_._adjustments_cached_byte_size_)*/ { 0 },
        decltype(_impl_.tailored_verdict_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.tailored_verdict_type_ = from._impl_.tailored_verdict_type_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadResponse.TailoredVerdict)
}

inline void ClientDownloadResponse_TailoredVerdict::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.adjustments_) { arena },
        /*decltype(_impl_._adjustments_cached_byte_size_)*/ { 0 }, decltype(_impl_.tailored_verdict_type_) { 0 } };
}

ClientDownloadResponse_TailoredVerdict::~ClientDownloadResponse_TailoredVerdict()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadResponse.TailoredVerdict)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadResponse_TailoredVerdict::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.adjustments_.~RepeatedField();
}

void ClientDownloadResponse_TailoredVerdict::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadResponse_TailoredVerdict::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadResponse.TailoredVerdict)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.adjustments_.Clear();
    _impl_.tailored_verdict_type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadResponse_TailoredVerdict::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientDownloadResponse.TailoredVerdict.TailoredVerdictType tailored_verdict_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadResponse_TailoredVerdict_TailoredVerdictType_IsValid(val))) {
                    _internal_set_tailored_verdict_type(static_cast<::safe_browsing::ClientDownloadResponse_TailoredVerdict_TailoredVerdictType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientDownloadResponse.TailoredVerdict.ExperimentalWarningAdjustment adjustments = 2 [packed = true];
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_adjustments(), ptr, ctx,
                    ::safe_browsing::ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_IsValid, &_internal_metadata_, 2);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 16) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment_IsValid(val))) {
                    _internal_add_adjustments(static_cast<::safe_browsing::ClientDownloadResponse_TailoredVerdict_ExperimentalWarningAdjustment>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadResponse_TailoredVerdict::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadResponse.TailoredVerdict)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientDownloadResponse.TailoredVerdict.TailoredVerdictType tailored_verdict_type = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_tailored_verdict_type(), target);
    }

    // repeated .safe_browsing.ClientDownloadResponse.TailoredVerdict.ExperimentalWarningAdjustment adjustments = 2 [packed = true];
    {
        int byte_size = _impl_._adjustments_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteEnumPacked(2, _impl_.adjustments_, byte_size, target);
        }
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadResponse.TailoredVerdict)
    return target;
}

size_t ClientDownloadResponse_TailoredVerdict::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadResponse.TailoredVerdict)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientDownloadResponse.TailoredVerdict.ExperimentalWarningAdjustment adjustments = 2 [packed = true];
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_adjustments_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_adjustments(static_cast<int>(i)));
        }
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._adjustments_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    // optional .safe_browsing.ClientDownloadResponse.TailoredVerdict.TailoredVerdictType tailored_verdict_type = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_tailored_verdict_type());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadResponse_TailoredVerdict::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadResponse_TailoredVerdict*>(&from));
}

void ClientDownloadResponse_TailoredVerdict::MergeFrom(const ClientDownloadResponse_TailoredVerdict& from)
{
    ClientDownloadResponse_TailoredVerdict* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadResponse.TailoredVerdict)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.adjustments_.MergeFrom(from._impl_.adjustments_);
    if (from._internal_has_tailored_verdict_type()) {
        _this->_internal_set_tailored_verdict_type(from._internal_tailored_verdict_type());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadResponse_TailoredVerdict::CopyFrom(const ClientDownloadResponse_TailoredVerdict& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadResponse.TailoredVerdict)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadResponse_TailoredVerdict::IsInitialized() const
{
    return true;
}

void ClientDownloadResponse_TailoredVerdict::InternalSwap(ClientDownloadResponse_TailoredVerdict* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.adjustments_.InternalSwap(&other->_impl_.adjustments_);
    swap(_impl_.tailored_verdict_type_, other->_impl_.tailored_verdict_type_);
}

std::string ClientDownloadResponse_TailoredVerdict::GetTypeName() const
{
    return "safe_browsing.ClientDownloadResponse.TailoredVerdict";
}

// ===================================================================

class ClientDownloadResponse::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadResponse>()._impl_._has_bits_);
    static void set_has_verdict(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::safe_browsing::ClientDownloadResponse_MoreInfo& more_info(const ClientDownloadResponse* msg);
    static void set_has_more_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_upload(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_request_deep_scan(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::safe_browsing::ClientDownloadResponse_TailoredVerdict& tailored_verdict(const ClientDownloadResponse* msg);
    static void set_has_tailored_verdict(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_is_suspicious_encrypted_archive(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
};

const ::safe_browsing::ClientDownloadResponse_MoreInfo& ClientDownloadResponse::_Internal::more_info(const ClientDownloadResponse* msg)
{
    return *msg->_impl_.more_info_;
}
const ::safe_browsing::ClientDownloadResponse_TailoredVerdict& ClientDownloadResponse::_Internal::tailored_verdict(const ClientDownloadResponse* msg)
{
    return *msg->_impl_.tailored_verdict_;
}
ClientDownloadResponse::ClientDownloadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadResponse)
}
ClientDownloadResponse::ClientDownloadResponse(const ClientDownloadResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.token_) {},
        decltype(_impl_.more_info_) { nullptr }, decltype(_impl_.tailored_verdict_) { nullptr }, decltype(_impl_.verdict_) {}, decltype(_impl_.upload_) {},
        decltype(_impl_.request_deep_scan_) {}, decltype(_impl_.is_suspicious_encrypted_archive_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_token()) {
        _this->_impl_.token_.Set(from._internal_token(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_more_info()) {
        _this->_impl_.more_info_ = new ::safe_browsing::ClientDownloadResponse_MoreInfo(*from._impl_.more_info_);
    }
    if (from._internal_has_tailored_verdict()) {
        _this->_impl_.tailored_verdict_ = new ::safe_browsing::ClientDownloadResponse_TailoredVerdict(*from._impl_.tailored_verdict_);
    }
    ::memcpy(&_impl_.verdict_, &from._impl_.verdict_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_suspicious_encrypted_archive_) - reinterpret_cast<char*>(&_impl_.verdict_))
            + sizeof(_impl_.is_suspicious_encrypted_archive_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadResponse)
}

inline void ClientDownloadResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.token_) {},
        decltype(_impl_.more_info_) { nullptr }, decltype(_impl_.tailored_verdict_) { nullptr }, decltype(_impl_.verdict_) { 0 },
        decltype(_impl_.upload_) { false }, decltype(_impl_.request_deep_scan_) { false }, decltype(_impl_.is_suspicious_encrypted_archive_) { false } };
    _impl_.token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadResponse::~ClientDownloadResponse()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.token_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.more_info_;
    if (this != internal_default_instance())
        delete _impl_.tailored_verdict_;
}

void ClientDownloadResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.more_info_ != nullptr);
            _impl_.more_info_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.tailored_verdict_ != nullptr);
            _impl_.tailored_verdict_->Clear();
        }
    }
    if (cached_has_bits & 0x00000078u) {
        ::memset(&_impl_.verdict_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_suspicious_encrypted_archive_) - reinterpret_cast<char*>(&_impl_.verdict_))
                + sizeof(_impl_.is_suspicious_encrypted_archive_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientDownloadResponse.Verdict verdict = 1 [default = SAFE];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadResponse_Verdict_IsValid(val))) {
                    _internal_set_verdict(static_cast<::safe_browsing::ClientDownloadResponse_Verdict>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadResponse.MoreInfo more_info = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_more_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes token = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool upload = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_upload(&has_bits);
                _impl_.upload_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool request_deep_scan = 19;
        case 19:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
                _Internal::set_has_request_deep_scan(&has_bits);
                _impl_.request_deep_scan_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadResponse.TailoredVerdict tailored_verdict = 20;
        case 20:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
                ptr = ctx->ParseMessage(_internal_mutable_tailored_verdict(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_suspicious_encrypted_archive = 21;
        case 21:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
                _Internal::set_has_is_suspicious_encrypted_archive(&has_bits);
                _impl_.is_suspicious_encrypted_archive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientDownloadResponse.Verdict verdict = 1 [default = SAFE];
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_verdict(), target);
    }

    // optional .safe_browsing.ClientDownloadResponse.MoreInfo more_info = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::more_info(this), _Internal::more_info(this).GetCachedSize(), target, stream);
    }

    // optional bytes token = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_token(), target);
    }

    // optional bool upload = 5;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_upload(), target);
    }

    // optional bool request_deep_scan = 19;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_request_deep_scan(), target);
    }

    // optional .safe_browsing.ClientDownloadResponse.TailoredVerdict tailored_verdict = 20;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            20, _Internal::tailored_verdict(this), _Internal::tailored_verdict(this).GetCachedSize(), target, stream);
    }

    // optional bool is_suspicious_encrypted_archive = 21;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_is_suspicious_encrypted_archive(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadResponse)
    return target;
}

size_t ClientDownloadResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        // optional bytes token = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_token());
        }

        // optional .safe_browsing.ClientDownloadResponse.MoreInfo more_info = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.more_info_);
        }

        // optional .safe_browsing.ClientDownloadResponse.TailoredVerdict tailored_verdict = 20;
        if (cached_has_bits & 0x00000004u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.tailored_verdict_);
        }

        // optional .safe_browsing.ClientDownloadResponse.Verdict verdict = 1 [default = SAFE];
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_verdict());
        }

        // optional bool upload = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }

        // optional bool request_deep_scan = 19;
        if (cached_has_bits & 0x00000020u) {
            total_size += 2 + 1;
        }

        // optional bool is_suspicious_encrypted_archive = 21;
        if (cached_has_bits & 0x00000040u) {
            total_size += 2 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadResponse*>(&from));
}

void ClientDownloadResponse::MergeFrom(const ClientDownloadResponse& from)
{
    ClientDownloadResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_token(from._internal_token());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_more_info()->::safe_browsing::ClientDownloadResponse_MoreInfo::MergeFrom(from._internal_more_info());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_tailored_verdict()->::safe_browsing::ClientDownloadResponse_TailoredVerdict::MergeFrom(from._internal_tailored_verdict());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.verdict_ = from._impl_.verdict_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.upload_ = from._impl_.upload_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.request_deep_scan_ = from._impl_.request_deep_scan_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.is_suspicious_encrypted_archive_ = from._impl_.is_suspicious_encrypted_archive_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadResponse::CopyFrom(const ClientDownloadResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadResponse::IsInitialized() const
{
    return true;
}

void ClientDownloadResponse::InternalSwap(ClientDownloadResponse* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.token_, lhs_arena, &other->_impl_.token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientDownloadResponse, _impl_.is_suspicious_encrypted_archive_)
        + sizeof(ClientDownloadResponse::_impl_.is_suspicious_encrypted_archive_) - PROTOBUF_FIELD_OFFSET(ClientDownloadResponse, _impl_.more_info_)>(
        reinterpret_cast<char*>(&_impl_.more_info_), reinterpret_cast<char*>(&other->_impl_.more_info_));
}

std::string ClientDownloadResponse::GetTypeName() const
{
    return "safe_browsing.ClientDownloadResponse";
}

// ===================================================================

class ClientDownloadReport_UserInformation::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadReport_UserInformation>()._impl_._has_bits_);
    static void set_has_email(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ClientDownloadReport_UserInformation::ClientDownloadReport_UserInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadReport.UserInformation)
}
ClientDownloadReport_UserInformation::ClientDownloadReport_UserInformation(const ClientDownloadReport_UserInformation& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadReport_UserInformation* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.email_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_email()) {
        _this->_impl_.email_.Set(from._internal_email(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadReport.UserInformation)
}

inline void ClientDownloadReport_UserInformation::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.email_) {} };
    _impl_.email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadReport_UserInformation::~ClientDownloadReport_UserInformation()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadReport.UserInformation)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadReport_UserInformation::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.email_.Destroy();
}

void ClientDownloadReport_UserInformation::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadReport_UserInformation::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadReport.UserInformation)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.email_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadReport_UserInformation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string email = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_email();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadReport_UserInformation::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadReport.UserInformation)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string email = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_email(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadReport.UserInformation)
    return target;
}

size_t ClientDownloadReport_UserInformation::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadReport.UserInformation)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string email = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_email());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadReport_UserInformation::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadReport_UserInformation*>(&from));
}

void ClientDownloadReport_UserInformation::MergeFrom(const ClientDownloadReport_UserInformation& from)
{
    ClientDownloadReport_UserInformation* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadReport.UserInformation)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_email()) {
        _this->_internal_set_email(from._internal_email());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadReport_UserInformation::CopyFrom(const ClientDownloadReport_UserInformation& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadReport.UserInformation)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadReport_UserInformation::IsInitialized() const
{
    return true;
}

void ClientDownloadReport_UserInformation::InternalSwap(ClientDownloadReport_UserInformation* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.email_, lhs_arena, &other->_impl_.email_, rhs_arena);
}

std::string ClientDownloadReport_UserInformation::GetTypeName() const
{
    return "safe_browsing.ClientDownloadReport.UserInformation";
}

// ===================================================================

class ClientDownloadReport::_Internal {
public:
    using HasBits = decltype(std::declval<ClientDownloadReport>()._impl_._has_bits_);
    static void set_has_reason(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::safe_browsing::ClientDownloadRequest& download_request(const ClientDownloadReport* msg);
    static void set_has_download_request(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::safe_browsing::ClientDownloadReport_UserInformation& user_information(const ClientDownloadReport* msg);
    static void set_has_user_information(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_comment(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::safe_browsing::ClientDownloadResponse& download_response(const ClientDownloadReport* msg);
    static void set_has_download_response(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::safe_browsing::ClientDownloadRequest& ClientDownloadReport::_Internal::download_request(const ClientDownloadReport* msg)
{
    return *msg->_impl_.download_request_;
}
const ::safe_browsing::ClientDownloadReport_UserInformation& ClientDownloadReport::_Internal::user_information(const ClientDownloadReport* msg)
{
    return *msg->_impl_.user_information_;
}
const ::safe_browsing::ClientDownloadResponse& ClientDownloadReport::_Internal::download_response(const ClientDownloadReport* msg)
{
    return *msg->_impl_.download_response_;
}
ClientDownloadReport::ClientDownloadReport(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientDownloadReport)
}
ClientDownloadReport::ClientDownloadReport(const ClientDownloadReport& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientDownloadReport* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.comment_) {},
        decltype(_impl_.download_request_) { nullptr }, decltype(_impl_.user_information_) { nullptr }, decltype(_impl_.download_response_) { nullptr },
        decltype(_impl_.reason_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.comment_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_comment()) {
        _this->_impl_.comment_.Set(from._internal_comment(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_download_request()) {
        _this->_impl_.download_request_ = new ::safe_browsing::ClientDownloadRequest(*from._impl_.download_request_);
    }
    if (from._internal_has_user_information()) {
        _this->_impl_.user_information_ = new ::safe_browsing::ClientDownloadReport_UserInformation(*from._impl_.user_information_);
    }
    if (from._internal_has_download_response()) {
        _this->_impl_.download_response_ = new ::safe_browsing::ClientDownloadResponse(*from._impl_.download_response_);
    }
    _this->_impl_.reason_ = from._impl_.reason_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientDownloadReport)
}

inline void ClientDownloadReport::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.comment_) {},
        decltype(_impl_.download_request_) { nullptr }, decltype(_impl_.user_information_) { nullptr }, decltype(_impl_.download_response_) { nullptr },
        decltype(_impl_.reason_) { 0 } };
    _impl_.comment_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.comment_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientDownloadReport::~ClientDownloadReport()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientDownloadReport)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientDownloadReport::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.comment_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.download_request_;
    if (this != internal_default_instance())
        delete _impl_.user_information_;
    if (this != internal_default_instance())
        delete _impl_.download_response_;
}

void ClientDownloadReport::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientDownloadReport::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientDownloadReport)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.comment_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.download_request_ != nullptr);
            _impl_.download_request_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.user_information_ != nullptr);
            _impl_.user_information_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.download_response_ != nullptr);
            _impl_.download_response_->Clear();
        }
    }
    _impl_.reason_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientDownloadReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientDownloadReport.Reason reason = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadReport_Reason_IsValid(val))) {
                    _internal_set_reason(static_cast<::safe_browsing::ClientDownloadReport_Reason>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest download_request = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_download_request(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadReport.UserInformation user_information = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_user_information(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes comment = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_comment();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadResponse download_response = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_download_response(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientDownloadReport::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientDownloadReport)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientDownloadReport.Reason reason = 1;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_reason(), target);
    }

    // optional .safe_browsing.ClientDownloadRequest download_request = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::download_request(this), _Internal::download_request(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientDownloadReport.UserInformation user_information = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::user_information(this), _Internal::user_information(this).GetCachedSize(), target, stream);
    }

    // optional bytes comment = 4;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(4, this->_internal_comment(), target);
    }

    // optional .safe_browsing.ClientDownloadResponse download_response = 5;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::download_response(this), _Internal::download_response(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientDownloadReport)
    return target;
}

size_t ClientDownloadReport::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientDownloadReport)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional bytes comment = 4;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_comment());
        }

        // optional .safe_browsing.ClientDownloadRequest download_request = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.download_request_);
        }

        // optional .safe_browsing.ClientDownloadReport.UserInformation user_information = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.user_information_);
        }

        // optional .safe_browsing.ClientDownloadResponse download_response = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.download_response_);
        }

        // optional .safe_browsing.ClientDownloadReport.Reason reason = 1;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_reason());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientDownloadReport::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientDownloadReport*>(&from));
}

void ClientDownloadReport::MergeFrom(const ClientDownloadReport& from)
{
    ClientDownloadReport* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientDownloadReport)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_comment(from._internal_comment());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_download_request()->::safe_browsing::ClientDownloadRequest::MergeFrom(from._internal_download_request());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_user_information()->::safe_browsing::ClientDownloadReport_UserInformation::MergeFrom(from._internal_user_information());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_download_response()->::safe_browsing::ClientDownloadResponse::MergeFrom(from._internal_download_response());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.reason_ = from._impl_.reason_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientDownloadReport::CopyFrom(const ClientDownloadReport& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientDownloadReport)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientDownloadReport::IsInitialized() const
{
    if (_internal_has_download_request()) {
        if (!_impl_.download_request_->IsInitialized())
            return false;
    }
    return true;
}

void ClientDownloadReport::InternalSwap(ClientDownloadReport* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.comment_, lhs_arena, &other->_impl_.comment_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientDownloadReport, _impl_.reason_) + sizeof(ClientDownloadReport::_impl_.reason_)
        - PROTOBUF_FIELD_OFFSET(ClientDownloadReport, _impl_.download_request_)>(
        reinterpret_cast<char*>(&_impl_.download_request_), reinterpret_cast<char*>(&other->_impl_.download_request_));
}

std::string ClientDownloadReport::GetTypeName() const
{
    return "safe_browsing.ClientDownloadReport";
}

// ===================================================================

class ClientUploadResponse::_Internal {
public:
    using HasBits = decltype(std::declval<ClientUploadResponse>()._impl_._has_bits_);
    static void set_has_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_permalink(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ClientUploadResponse::ClientUploadResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientUploadResponse)
}
ClientUploadResponse::ClientUploadResponse(const ClientUploadResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientUploadResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.permalink_) {},
        decltype(_impl_.status_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.permalink_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.permalink_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_permalink()) {
        _this->_impl_.permalink_.Set(from._internal_permalink(), _this->GetArenaForAllocation());
    }
    _this->_impl_.status_ = from._impl_.status_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientUploadResponse)
}

inline void ClientUploadResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.permalink_) {}, decltype(_impl_.status_) { 0 } };
    _impl_.permalink_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.permalink_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientUploadResponse::~ClientUploadResponse()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientUploadResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientUploadResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.permalink_.Destroy();
}

void ClientUploadResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientUploadResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientUploadResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.permalink_.ClearNonDefaultToEmpty();
    }
    _impl_.status_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientUploadResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientUploadResponse.UploadStatus status = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientUploadResponse_UploadStatus_IsValid(val))) {
                    _internal_set_status(static_cast<::safe_browsing::ClientUploadResponse_UploadStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string permalink = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_permalink();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientUploadResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientUploadResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientUploadResponse.UploadStatus status = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_status(), target);
    }

    // optional string permalink = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_permalink(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientUploadResponse)
    return target;
}

size_t ClientUploadResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientUploadResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string permalink = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_permalink());
        }

        // optional .safe_browsing.ClientUploadResponse.UploadStatus status = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientUploadResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientUploadResponse*>(&from));
}

void ClientUploadResponse::MergeFrom(const ClientUploadResponse& from)
{
    ClientUploadResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientUploadResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_permalink(from._internal_permalink());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.status_ = from._impl_.status_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientUploadResponse::CopyFrom(const ClientUploadResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientUploadResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientUploadResponse::IsInitialized() const
{
    return true;
}

void ClientUploadResponse::InternalSwap(ClientUploadResponse* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.permalink_, lhs_arena, &other->_impl_.permalink_, rhs_arena);
    swap(_impl_.status_, other->_impl_.status_);
}

std::string ClientUploadResponse::GetTypeName() const
{
    return "safe_browsing.ClientUploadResponse";
}

// ===================================================================

class ClientIncidentReport_IncidentData_TrackedPreferenceIncident::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_IncidentData_TrackedPreferenceIncident>()._impl_._has_bits_);
    static void set_has_path(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_atomic_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_value_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

ClientIncidentReport_IncidentData_TrackedPreferenceIncident::ClientIncidentReport_IncidentData_TrackedPreferenceIncident(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
}
ClientIncidentReport_IncidentData_TrackedPreferenceIncident::ClientIncidentReport_IncidentData_TrackedPreferenceIncident(
    const ClientIncidentReport_IncidentData_TrackedPreferenceIncident& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_IncidentData_TrackedPreferenceIncident* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.split_key_) { from._impl_.split_key_ }, decltype(_impl_.path_) {}, decltype(_impl_.atomic_value_) {},
        decltype(_impl_.value_state_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_path()) {
        _this->_impl_.path_.Set(from._internal_path(), _this->GetArenaForAllocation());
    }
    _impl_.atomic_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.atomic_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_atomic_value()) {
        _this->_impl_.atomic_value_.Set(from._internal_atomic_value(), _this->GetArenaForAllocation());
    }
    _this->_impl_.value_state_ = from._impl_.value_state_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
}

inline void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.split_key_) { arena },
        decltype(_impl_.path_) {}, decltype(_impl_.atomic_value_) {}, decltype(_impl_.value_state_) { 0 } };
    _impl_.path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.atomic_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.atomic_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_IncidentData_TrackedPreferenceIncident::~ClientIncidentReport_IncidentData_TrackedPreferenceIncident()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.split_key_.~RepeatedPtrField();
    _impl_.path_.Destroy();
    _impl_.atomic_value_.Destroy();
}

void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.split_key_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.path_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.atomic_value_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.value_state_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_IncidentData_TrackedPreferenceIncident::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string path = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_path();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string atomic_value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_atomic_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string split_key = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_split_key();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident.ValueState value_state = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState_IsValid(val))) {
                    _internal_set_value_state(static_cast<::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident_ValueState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_IncidentData_TrackedPreferenceIncident::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string path = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_path(), target);
    }

    // optional string atomic_value = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_atomic_value(), target);
    }

    // repeated string split_key = 3;
    for (int i = 0, n = this->_internal_split_key_size(); i < n; i++) {
        const auto& s = this->_internal_split_key(i);
        target = stream->WriteString(3, s, target);
    }

    // optional .safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident.ValueState value_state = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_value_state(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
    return target;
}

size_t ClientIncidentReport_IncidentData_TrackedPreferenceIncident::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string split_key = 3;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.split_key_.size());
    for (int i = 0, n = _impl_.split_key_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.split_key_.Get(i));
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string path = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_path());
        }

        // optional string atomic_value = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_atomic_value());
        }

        // optional .safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident.ValueState value_state = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_value_state());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_IncidentData_TrackedPreferenceIncident*>(&from));
}

void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::MergeFrom(const ClientIncidentReport_IncidentData_TrackedPreferenceIncident& from)
{
    ClientIncidentReport_IncidentData_TrackedPreferenceIncident* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.split_key_.MergeFrom(from._impl_.split_key_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_path(from._internal_path());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_atomic_value(from._internal_atomic_value());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.value_state_ = from._impl_.value_state_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::CopyFrom(const ClientIncidentReport_IncidentData_TrackedPreferenceIncident& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_IncidentData_TrackedPreferenceIncident::IsInitialized() const
{
    return true;
}

void ClientIncidentReport_IncidentData_TrackedPreferenceIncident::InternalSwap(ClientIncidentReport_IncidentData_TrackedPreferenceIncident* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.split_key_.InternalSwap(&other->_impl_.split_key_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.path_, lhs_arena, &other->_impl_.path_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.atomic_value_, lhs_arena, &other->_impl_.atomic_value_, rhs_arena);
    swap(_impl_.value_state_, other->_impl_.value_state_);
}

std::string ClientIncidentReport_IncidentData_TrackedPreferenceIncident::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident";
}

// ===================================================================

class ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile>()._impl_._has_bits_);
    static void set_has_relative_path(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::safe_browsing::ClientDownloadRequest_SignatureInfo& signature(
        const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile* msg);
    static void set_has_signature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::safe_browsing::ClientDownloadRequest_ImageHeaders& image_headers(
        const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile* msg);
    static void set_has_image_headers(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::safe_browsing::ClientDownloadRequest_SignatureInfo& ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::_Internal::signature(
    const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile* msg)
{
    return *msg->_impl_.signature_;
}
const ::safe_browsing::ClientDownloadRequest_ImageHeaders& ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::_Internal::image_headers(
    const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile* msg)
{
    return *msg->_impl_.image_headers_;
}
ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
}
ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile(
    const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.relative_path_) {},
        decltype(_impl_.signature_) { nullptr }, decltype(_impl_.image_headers_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.relative_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relative_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_relative_path()) {
        _this->_impl_.relative_path_.Set(from._internal_relative_path(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_signature()) {
        _this->_impl_.signature_ = new ::safe_browsing::ClientDownloadRequest_SignatureInfo(*from._impl_.signature_);
    }
    if (from._internal_has_image_headers()) {
        _this->_impl_.image_headers_ = new ::safe_browsing::ClientDownloadRequest_ImageHeaders(*from._impl_.image_headers_);
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
}

inline void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.relative_path_) {},
        decltype(_impl_.signature_) { nullptr }, decltype(_impl_.image_headers_) { nullptr } };
    _impl_.relative_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.relative_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::~ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.relative_path_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.signature_;
    if (this != internal_default_instance())
        delete _impl_.image_headers_;
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.relative_path_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.signature_ != nullptr);
            _impl_.signature_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.image_headers_ != nullptr);
            _impl_.image_headers_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string relative_path = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_relative_path();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_signature(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_image_headers(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string relative_path = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_relative_path(), target);
    }

    // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::signature(this), _Internal::signature(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::image_headers(this), _Internal::image_headers(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
    return target;
}

size_t ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string relative_path = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_relative_path());
        }

        // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.signature_);
        }

        // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.image_headers_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile*>(&from));
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::MergeFrom(
    const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile& from)
{
    ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_relative_path(from._internal_relative_path());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_signature()->::safe_browsing::ClientDownloadRequest_SignatureInfo::MergeFrom(from._internal_signature());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_image_headers()->::safe_browsing::ClientDownloadRequest_ImageHeaders::MergeFrom(from._internal_image_headers());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::CopyFrom(
    const ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::IsInitialized() const
{
    if (_internal_has_signature()) {
        if (!_impl_.signature_->IsInitialized())
            return false;
    }
    if (_internal_has_image_headers()) {
        if (!_impl_.image_headers_->IsInitialized())
            return false;
    }
    return true;
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::InternalSwap(
    ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.relative_path_, lhs_arena, &other->_impl_.relative_path_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(
                                                   ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile, _impl_.image_headers_)
        + sizeof(ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::_impl_.image_headers_)
        - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile, _impl_.signature_)>(
        reinterpret_cast<char*>(&_impl_.signature_), reinterpret_cast<char*>(&other->_impl_.signature_));
}

std::string ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile";
}

// ===================================================================

class ClientIncidentReport_IncidentData_BinaryIntegrityIncident::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_IncidentData_BinaryIntegrityIncident>()._impl_._has_bits_);
    static void set_has_file_basename(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::safe_browsing::ClientDownloadRequest_SignatureInfo& signature(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident* msg);
    static void set_has_signature(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::safe_browsing::ClientDownloadRequest_ImageHeaders& image_headers(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident* msg);
    static void set_has_image_headers(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_sec_error(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::safe_browsing::ClientDownloadRequest_SignatureInfo& ClientIncidentReport_IncidentData_BinaryIntegrityIncident::_Internal::signature(
    const ClientIncidentReport_IncidentData_BinaryIntegrityIncident* msg)
{
    return *msg->_impl_.signature_;
}
const ::safe_browsing::ClientDownloadRequest_ImageHeaders& ClientIncidentReport_IncidentData_BinaryIntegrityIncident::_Internal::image_headers(
    const ClientIncidentReport_IncidentData_BinaryIntegrityIncident* msg)
{
    return *msg->_impl_.image_headers_;
}
ClientIncidentReport_IncidentData_BinaryIntegrityIncident::ClientIncidentReport_IncidentData_BinaryIntegrityIncident(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
}
ClientIncidentReport_IncidentData_BinaryIntegrityIncident::ClientIncidentReport_IncidentData_BinaryIntegrityIncident(
    const ClientIncidentReport_IncidentData_BinaryIntegrityIncident& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_IncidentData_BinaryIntegrityIncident* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.contained_file_) { from._impl_.contained_file_ }, decltype(_impl_.file_basename_) {}, decltype(_impl_.signature_) { nullptr },
        decltype(_impl_.image_headers_) { nullptr }, decltype(_impl_.sec_error_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.file_basename_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_basename_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_file_basename()) {
        _this->_impl_.file_basename_.Set(from._internal_file_basename(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_signature()) {
        _this->_impl_.signature_ = new ::safe_browsing::ClientDownloadRequest_SignatureInfo(*from._impl_.signature_);
    }
    if (from._internal_has_image_headers()) {
        _this->_impl_.image_headers_ = new ::safe_browsing::ClientDownloadRequest_ImageHeaders(*from._impl_.image_headers_);
    }
    _this->_impl_.sec_error_ = from._impl_.sec_error_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
}

inline void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.contained_file_) { arena },
        decltype(_impl_.file_basename_) {}, decltype(_impl_.signature_) { nullptr }, decltype(_impl_.image_headers_) { nullptr },
        decltype(_impl_.sec_error_) { 0 } };
    _impl_.file_basename_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_basename_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_IncidentData_BinaryIntegrityIncident::~ClientIncidentReport_IncidentData_BinaryIntegrityIncident()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.contained_file_.~RepeatedPtrField();
    _impl_.file_basename_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.signature_;
    if (this != internal_default_instance())
        delete _impl_.image_headers_;
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.contained_file_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.file_basename_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.signature_ != nullptr);
            _impl_.signature_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.image_headers_ != nullptr);
            _impl_.image_headers_->Clear();
        }
    }
    _impl_.sec_error_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_IncidentData_BinaryIntegrityIncident::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string file_basename = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_file_basename();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_signature(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_image_headers(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 sec_error = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_sec_error(&has_bits);
                _impl_.sec_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile contained_file = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_contained_file(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_IncidentData_BinaryIntegrityIncident::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string file_basename = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_file_basename(), target);
    }

    // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::signature(this), _Internal::signature(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::image_headers(this), _Internal::image_headers(this).GetCachedSize(), target, stream);
    }

    // optional int32 sec_error = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_sec_error(), target);
    }

    // repeated .safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile contained_file = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_contained_file_size()); i < n; i++) {
        const auto& repfield = this->_internal_contained_file(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
    return target;
}

size_t ClientIncidentReport_IncidentData_BinaryIntegrityIncident::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident.ContainedFile contained_file = 5;
    total_size += 1UL * this->_internal_contained_file_size();
    for (const auto& msg : this->_impl_.contained_file_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string file_basename = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_file_basename());
        }

        // optional .safe_browsing.ClientDownloadRequest.SignatureInfo signature = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.signature_);
        }

        // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.image_headers_);
        }

        // optional int32 sec_error = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sec_error());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_IncidentData_BinaryIntegrityIncident*>(&from));
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::MergeFrom(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident& from)
{
    ClientIncidentReport_IncidentData_BinaryIntegrityIncident* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.contained_file_.MergeFrom(from._impl_.contained_file_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_file_basename(from._internal_file_basename());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_signature()->::safe_browsing::ClientDownloadRequest_SignatureInfo::MergeFrom(from._internal_signature());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_image_headers()->::safe_browsing::ClientDownloadRequest_ImageHeaders::MergeFrom(from._internal_image_headers());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.sec_error_ = from._impl_.sec_error_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::CopyFrom(const ClientIncidentReport_IncidentData_BinaryIntegrityIncident& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_IncidentData_BinaryIntegrityIncident::IsInitialized() const
{
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.contained_file_))
        return false;
    if (_internal_has_signature()) {
        if (!_impl_.signature_->IsInitialized())
            return false;
    }
    if (_internal_has_image_headers()) {
        if (!_impl_.image_headers_->IsInitialized())
            return false;
    }
    return true;
}

void ClientIncidentReport_IncidentData_BinaryIntegrityIncident::InternalSwap(ClientIncidentReport_IncidentData_BinaryIntegrityIncident* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.contained_file_.InternalSwap(&other->_impl_.contained_file_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.file_basename_, lhs_arena, &other->_impl_.file_basename_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientIncidentReport_IncidentData_BinaryIntegrityIncident, _impl_.sec_error_)
        + sizeof(ClientIncidentReport_IncidentData_BinaryIntegrityIncident::_impl_.sec_error_)
        - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_IncidentData_BinaryIntegrityIncident, _impl_.signature_)>(
        reinterpret_cast<char*>(&_impl_.signature_), reinterpret_cast<char*>(&other->_impl_.signature_));
}

std::string ClientIncidentReport_IncidentData_BinaryIntegrityIncident::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident";
}

// ===================================================================

class ClientIncidentReport_IncidentData_ResourceRequestIncident::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_IncidentData_ResourceRequestIncident>()._impl_._has_bits_);
    static void set_has_digest(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_origin(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

ClientIncidentReport_IncidentData_ResourceRequestIncident::ClientIncidentReport_IncidentData_ResourceRequestIncident(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
}
ClientIncidentReport_IncidentData_ResourceRequestIncident::ClientIncidentReport_IncidentData_ResourceRequestIncident(
    const ClientIncidentReport_IncidentData_ResourceRequestIncident& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_IncidentData_ResourceRequestIncident* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.digest_) {},
        decltype(_impl_.origin_) {}, decltype(_impl_.type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.digest_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.digest_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_digest()) {
        _this->_impl_.digest_.Set(from._internal_digest(), _this->GetArenaForAllocation());
    }
    _impl_.origin_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_origin()) {
        _this->_impl_.origin_.Set(from._internal_origin(), _this->GetArenaForAllocation());
    }
    _this->_impl_.type_ = from._impl_.type_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
}

inline void ClientIncidentReport_IncidentData_ResourceRequestIncident::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.digest_) {}, decltype(_impl_.origin_) {},
        decltype(_impl_.type_) { 0 } };
    _impl_.digest_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.digest_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_IncidentData_ResourceRequestIncident::~ClientIncidentReport_IncidentData_ResourceRequestIncident()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_IncidentData_ResourceRequestIncident::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.digest_.Destroy();
    _impl_.origin_.Destroy();
}

void ClientIncidentReport_IncidentData_ResourceRequestIncident::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_IncidentData_ResourceRequestIncident::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.digest_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.origin_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_IncidentData_ResourceRequestIncident::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bytes digest = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_digest();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string origin = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_origin();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident.Type type = 3 [default = UNKNOWN];
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident_Type_IsValid(val))) {
                    _internal_set_type(static_cast<::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident_Type>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_IncidentData_ResourceRequestIncident::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bytes digest = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_digest(), target);
    }

    // optional string origin = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_origin(), target);
    }

    // optional .safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident.Type type = 3 [default = UNKNOWN];
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
    return target;
}

size_t ClientIncidentReport_IncidentData_ResourceRequestIncident::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional bytes digest = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_digest());
        }

        // optional string origin = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_origin());
        }

        // optional .safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident.Type type = 3 [default = UNKNOWN];
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_IncidentData_ResourceRequestIncident::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_IncidentData_ResourceRequestIncident*>(&from));
}

void ClientIncidentReport_IncidentData_ResourceRequestIncident::MergeFrom(const ClientIncidentReport_IncidentData_ResourceRequestIncident& from)
{
    ClientIncidentReport_IncidentData_ResourceRequestIncident* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_digest(from._internal_digest());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_origin(from._internal_origin());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_IncidentData_ResourceRequestIncident::CopyFrom(const ClientIncidentReport_IncidentData_ResourceRequestIncident& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_IncidentData_ResourceRequestIncident::IsInitialized() const
{
    return true;
}

void ClientIncidentReport_IncidentData_ResourceRequestIncident::InternalSwap(ClientIncidentReport_IncidentData_ResourceRequestIncident* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.digest_, lhs_arena, &other->_impl_.digest_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.origin_, lhs_arena, &other->_impl_.origin_, rhs_arena);
    swap(_impl_.type_, other->_impl_.type_);
}

std::string ClientIncidentReport_IncidentData_ResourceRequestIncident::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident";
}

// ===================================================================

class ClientIncidentReport_IncidentData::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_IncidentData>()._impl_._has_bits_);
    static void set_has_incident_time_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident& tracked_preference(const ClientIncidentReport_IncidentData* msg);
    static void set_has_tracked_preference(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident& binary_integrity(const ClientIncidentReport_IncidentData* msg);
    static void set_has_binary_integrity(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident& resource_request(const ClientIncidentReport_IncidentData* msg);
    static void set_has_resource_request(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident& ClientIncidentReport_IncidentData::_Internal::tracked_preference(
    const ClientIncidentReport_IncidentData* msg)
{
    return *msg->_impl_.tracked_preference_;
}
const ::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident& ClientIncidentReport_IncidentData::_Internal::binary_integrity(
    const ClientIncidentReport_IncidentData* msg)
{
    return *msg->_impl_.binary_integrity_;
}
const ::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident& ClientIncidentReport_IncidentData::_Internal::resource_request(
    const ClientIncidentReport_IncidentData* msg)
{
    return *msg->_impl_.resource_request_;
}
ClientIncidentReport_IncidentData::ClientIncidentReport_IncidentData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.IncidentData)
}
ClientIncidentReport_IncidentData::ClientIncidentReport_IncidentData(const ClientIncidentReport_IncidentData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_IncidentData* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.tracked_preference_) { nullptr },
            decltype(_impl_.binary_integrity_) { nullptr }, decltype(_impl_.resource_request_) { nullptr }, decltype(_impl_.incident_time_msec_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_tracked_preference()) {
        _this->_impl_.tracked_preference_ = new ::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident(*from._impl_.tracked_preference_);
    }
    if (from._internal_has_binary_integrity()) {
        _this->_impl_.binary_integrity_ = new ::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident(*from._impl_.binary_integrity_);
    }
    if (from._internal_has_resource_request()) {
        _this->_impl_.resource_request_ = new ::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident(*from._impl_.resource_request_);
    }
    _this->_impl_.incident_time_msec_ = from._impl_.incident_time_msec_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.IncidentData)
}

inline void ClientIncidentReport_IncidentData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.tracked_preference_) { nullptr },
        decltype(_impl_.binary_integrity_) { nullptr }, decltype(_impl_.resource_request_) { nullptr },
        decltype(_impl_.incident_time_msec_) { int64_t { 0 } } };
}

ClientIncidentReport_IncidentData::~ClientIncidentReport_IncidentData()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.IncidentData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_IncidentData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.tracked_preference_;
    if (this != internal_default_instance())
        delete _impl_.binary_integrity_;
    if (this != internal_default_instance())
        delete _impl_.resource_request_;
}

void ClientIncidentReport_IncidentData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_IncidentData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.IncidentData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.tracked_preference_ != nullptr);
            _impl_.tracked_preference_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.binary_integrity_ != nullptr);
            _impl_.binary_integrity_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.resource_request_ != nullptr);
            _impl_.resource_request_->Clear();
        }
    }
    _impl_.incident_time_msec_ = int64_t { 0 };
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_IncidentData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 incident_time_msec = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_incident_time_msec(&has_bits);
                _impl_.incident_time_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident tracked_preference = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_tracked_preference(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident binary_integrity = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_binary_integrity(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident resource_request = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_resource_request(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_IncidentData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.IncidentData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 incident_time_msec = 1;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_incident_time_msec(), target);
    }

    // optional .safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident tracked_preference = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::tracked_preference(this), _Internal::tracked_preference(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident binary_integrity = 3;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::binary_integrity(this), _Internal::binary_integrity(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident resource_request = 7;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::resource_request(this), _Internal::resource_request(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.IncidentData)
    return target;
}

size_t ClientIncidentReport_IncidentData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.IncidentData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .safe_browsing.ClientIncidentReport.IncidentData.TrackedPreferenceIncident tracked_preference = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.tracked_preference_);
        }

        // optional .safe_browsing.ClientIncidentReport.IncidentData.BinaryIntegrityIncident binary_integrity = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.binary_integrity_);
        }

        // optional .safe_browsing.ClientIncidentReport.IncidentData.ResourceRequestIncident resource_request = 7;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.resource_request_);
        }

        // optional int64 incident_time_msec = 1;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_incident_time_msec());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_IncidentData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_IncidentData*>(&from));
}

void ClientIncidentReport_IncidentData::MergeFrom(const ClientIncidentReport_IncidentData& from)
{
    ClientIncidentReport_IncidentData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.IncidentData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_tracked_preference()->::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident::MergeFrom(
                from._internal_tracked_preference());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_binary_integrity()->::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident::MergeFrom(
                from._internal_binary_integrity());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_resource_request()->::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident::MergeFrom(
                from._internal_resource_request());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.incident_time_msec_ = from._impl_.incident_time_msec_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_IncidentData::CopyFrom(const ClientIncidentReport_IncidentData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.IncidentData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_IncidentData::IsInitialized() const
{
    if (_internal_has_binary_integrity()) {
        if (!_impl_.binary_integrity_->IsInitialized())
            return false;
    }
    return true;
}

void ClientIncidentReport_IncidentData::InternalSwap(ClientIncidentReport_IncidentData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientIncidentReport_IncidentData, _impl_.incident_time_msec_)
        + sizeof(ClientIncidentReport_IncidentData::_impl_.incident_time_msec_)
        - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_IncidentData, _impl_.tracked_preference_)>(
        reinterpret_cast<char*>(&_impl_.tracked_preference_), reinterpret_cast<char*>(&other->_impl_.tracked_preference_));
}

std::string ClientIncidentReport_IncidentData::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.IncidentData";
}

// ===================================================================

class ClientIncidentReport_DownloadDetails::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_DownloadDetails>()._impl_._has_bits_);
    static void set_has_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::safe_browsing::ClientDownloadRequest& download(const ClientIncidentReport_DownloadDetails* msg);
    static void set_has_download(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_download_time_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_open_time_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::safe_browsing::ClientDownloadRequest& ClientIncidentReport_DownloadDetails::_Internal::download(const ClientIncidentReport_DownloadDetails* msg)
{
    return *msg->_impl_.download_;
}
ClientIncidentReport_DownloadDetails::ClientIncidentReport_DownloadDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.DownloadDetails)
}
ClientIncidentReport_DownloadDetails::ClientIncidentReport_DownloadDetails(const ClientIncidentReport_DownloadDetails& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_DownloadDetails* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.token_) {},
        decltype(_impl_.download_) { nullptr }, decltype(_impl_.download_time_msec_) {}, decltype(_impl_.open_time_msec_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_token()) {
        _this->_impl_.token_.Set(from._internal_token(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_download()) {
        _this->_impl_.download_ = new ::safe_browsing::ClientDownloadRequest(*from._impl_.download_);
    }
    ::memcpy(&_impl_.download_time_msec_, &from._impl_.download_time_msec_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.open_time_msec_) - reinterpret_cast<char*>(&_impl_.download_time_msec_))
            + sizeof(_impl_.open_time_msec_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.DownloadDetails)
}

inline void ClientIncidentReport_DownloadDetails::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.token_) {},
        decltype(_impl_.download_) { nullptr }, decltype(_impl_.download_time_msec_) { int64_t { 0 } }, decltype(_impl_.open_time_msec_) { int64_t { 0 } } };
    _impl_.token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_DownloadDetails::~ClientIncidentReport_DownloadDetails()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.DownloadDetails)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_DownloadDetails::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.token_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.download_;
}

void ClientIncidentReport_DownloadDetails::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_DownloadDetails::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.DownloadDetails)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.download_ != nullptr);
            _impl_.download_->Clear();
        }
    }
    if (cached_has_bits & 0x0000000cu) {
        ::memset(&_impl_.download_time_msec_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.open_time_msec_) - reinterpret_cast<char*>(&_impl_.download_time_msec_))
                + sizeof(_impl_.open_time_msec_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_DownloadDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bytes token = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest download = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_download(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 download_time_msec = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_download_time_msec(&has_bits);
                _impl_.download_time_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 open_time_msec = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_open_time_msec(&has_bits);
                _impl_.open_time_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_DownloadDetails::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.DownloadDetails)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bytes token = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_token(), target);
    }

    // optional .safe_browsing.ClientDownloadRequest download = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::download(this), _Internal::download(this).GetCachedSize(), target, stream);
    }

    // optional int64 download_time_msec = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_download_time_msec(), target);
    }

    // optional int64 open_time_msec = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_open_time_msec(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.DownloadDetails)
    return target;
}

size_t ClientIncidentReport_DownloadDetails::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.DownloadDetails)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional bytes token = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_token());
        }

        // optional .safe_browsing.ClientDownloadRequest download = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.download_);
        }

        // optional int64 download_time_msec = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_download_time_msec());
        }

        // optional int64 open_time_msec = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_open_time_msec());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_DownloadDetails::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_DownloadDetails*>(&from));
}

void ClientIncidentReport_DownloadDetails::MergeFrom(const ClientIncidentReport_DownloadDetails& from)
{
    ClientIncidentReport_DownloadDetails* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.DownloadDetails)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_token(from._internal_token());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_download()->::safe_browsing::ClientDownloadRequest::MergeFrom(from._internal_download());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.download_time_msec_ = from._impl_.download_time_msec_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.open_time_msec_ = from._impl_.open_time_msec_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_DownloadDetails::CopyFrom(const ClientIncidentReport_DownloadDetails& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.DownloadDetails)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_DownloadDetails::IsInitialized() const
{
    if (_internal_has_download()) {
        if (!_impl_.download_->IsInitialized())
            return false;
    }
    return true;
}

void ClientIncidentReport_DownloadDetails::InternalSwap(ClientIncidentReport_DownloadDetails* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.token_, lhs_arena, &other->_impl_.token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientIncidentReport_DownloadDetails, _impl_.open_time_msec_)
        + sizeof(ClientIncidentReport_DownloadDetails::_impl_.open_time_msec_) - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_DownloadDetails, _impl_.download_)>(
        reinterpret_cast<char*>(&_impl_.download_), reinterpret_cast<char*>(&other->_impl_.download_));
}

std::string ClientIncidentReport_DownloadDetails::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.DownloadDetails";
}

// ===================================================================

class ClientIncidentReport_EnvironmentData_OS_RegistryValue::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_OS_RegistryValue>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ClientIncidentReport_EnvironmentData_OS_RegistryValue::ClientIncidentReport_EnvironmentData_OS_RegistryValue(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
}
ClientIncidentReport_EnvironmentData_OS_RegistryValue::ClientIncidentReport_EnvironmentData_OS_RegistryValue(
    const ClientIncidentReport_EnvironmentData_OS_RegistryValue& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_EnvironmentData_OS_RegistryValue* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {},
        decltype(_impl_.data_) {}, decltype(_impl_.type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_data()) {
        _this->_impl_.data_.Set(from._internal_data(), _this->GetArenaForAllocation());
    }
    _this->_impl_.type_ = from._impl_.type_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
}

inline void ClientIncidentReport_EnvironmentData_OS_RegistryValue::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {}, decltype(_impl_.data_) {},
        decltype(_impl_.type_) { 0u } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_OS_RegistryValue::~ClientIncidentReport_EnvironmentData_OS_RegistryValue()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_OS_RegistryValue::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_.Destroy();
    _impl_.data_.Destroy();
}

void ClientIncidentReport_EnvironmentData_OS_RegistryValue::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_OS_RegistryValue::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.data_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.type_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_OS_RegistryValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_type(&has_bits);
                _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes data = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_data();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_OS_RegistryValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional uint32 type = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_type(), target);
    }

    // optional bytes data = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_data(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
    return target;
}

size_t ClientIncidentReport_EnvironmentData_OS_RegistryValue::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional bytes data = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_data());
        }

        // optional uint32 type = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_EnvironmentData_OS_RegistryValue::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_OS_RegistryValue*>(&from));
}

void ClientIncidentReport_EnvironmentData_OS_RegistryValue::MergeFrom(const ClientIncidentReport_EnvironmentData_OS_RegistryValue& from)
{
    ClientIncidentReport_EnvironmentData_OS_RegistryValue* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_data(from._internal_data());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_OS_RegistryValue::CopyFrom(const ClientIncidentReport_EnvironmentData_OS_RegistryValue& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_OS_RegistryValue::IsInitialized() const
{
    return true;
}

void ClientIncidentReport_EnvironmentData_OS_RegistryValue::InternalSwap(ClientIncidentReport_EnvironmentData_OS_RegistryValue* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.data_, lhs_arena, &other->_impl_.data_, rhs_arena);
    swap(_impl_.type_, other->_impl_.type_);
}

std::string ClientIncidentReport_EnvironmentData_OS_RegistryValue::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue";
}

// ===================================================================

class ClientIncidentReport_EnvironmentData_OS_RegistryKey::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_OS_RegistryKey>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ClientIncidentReport_EnvironmentData_OS_RegistryKey::ClientIncidentReport_EnvironmentData_OS_RegistryKey(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
}
ClientIncidentReport_EnvironmentData_OS_RegistryKey::ClientIncidentReport_EnvironmentData_OS_RegistryKey(
    const ClientIncidentReport_EnvironmentData_OS_RegistryKey& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_EnvironmentData_OS_RegistryKey* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.value_) { from._impl_.value_ }, decltype(_impl_.key_) { from._impl_.key_ }, decltype(_impl_.name_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
}

inline void ClientIncidentReport_EnvironmentData_OS_RegistryKey::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.value_) { arena },
        decltype(_impl_.key_) { arena }, decltype(_impl_.name_) {} };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_OS_RegistryKey::~ClientIncidentReport_EnvironmentData_OS_RegistryKey()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_OS_RegistryKey::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.value_.~RepeatedPtrField();
    _impl_.key_.~RepeatedPtrField();
    _impl_.name_.Destroy();
}

void ClientIncidentReport_EnvironmentData_OS_RegistryKey::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_OS_RegistryKey::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.value_.Clear();
    _impl_.key_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.name_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_OS_RegistryKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_value(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey key = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_key(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_OS_RegistryKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue value = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_value_size()); i < n; i++) {
        const auto& repfield = this->_internal_value(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey key = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_key_size()); i < n; i++) {
        const auto& repfield = this->_internal_key(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
    return target;
}

size_t ClientIncidentReport_EnvironmentData_OS_RegistryKey::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryValue value = 2;
    total_size += 1UL * this->_internal_value_size();
    for (const auto& msg : this->_impl_.value_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey key = 3;
    total_size += 1UL * this->_internal_key_size();
    for (const auto& msg : this->_impl_.key_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional string name = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_EnvironmentData_OS_RegistryKey::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_OS_RegistryKey*>(&from));
}

void ClientIncidentReport_EnvironmentData_OS_RegistryKey::MergeFrom(const ClientIncidentReport_EnvironmentData_OS_RegistryKey& from)
{
    ClientIncidentReport_EnvironmentData_OS_RegistryKey* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.value_.MergeFrom(from._impl_.value_);
    _this->_impl_.key_.MergeFrom(from._impl_.key_);
    if (from._internal_has_name()) {
        _this->_internal_set_name(from._internal_name());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_OS_RegistryKey::CopyFrom(const ClientIncidentReport_EnvironmentData_OS_RegistryKey& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_OS_RegistryKey::IsInitialized() const
{
    return true;
}

void ClientIncidentReport_EnvironmentData_OS_RegistryKey::InternalSwap(ClientIncidentReport_EnvironmentData_OS_RegistryKey* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.value_.InternalSwap(&other->_impl_.value_);
    _impl_.key_.InternalSwap(&other->_impl_.key_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
}

std::string ClientIncidentReport_EnvironmentData_OS_RegistryKey::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey";
}

// ===================================================================

class ClientIncidentReport_EnvironmentData_OS::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_OS>()._impl_._has_bits_);
    static void set_has_os_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_os_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_is_enrolled_to_domain(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

ClientIncidentReport_EnvironmentData_OS::ClientIncidentReport_EnvironmentData_OS(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
}
ClientIncidentReport_EnvironmentData_OS::ClientIncidentReport_EnvironmentData_OS(const ClientIncidentReport_EnvironmentData_OS& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_EnvironmentData_OS* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.registry_key_) { from._impl_.registry_key_ }, decltype(_impl_.os_name_) {}, decltype(_impl_.os_version_) {},
        decltype(_impl_.is_enrolled_to_domain_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.os_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_os_name()) {
        _this->_impl_.os_name_.Set(from._internal_os_name(), _this->GetArenaForAllocation());
    }
    _impl_.os_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_os_version()) {
        _this->_impl_.os_version_.Set(from._internal_os_version(), _this->GetArenaForAllocation());
    }
    _this->_impl_.is_enrolled_to_domain_ = from._impl_.is_enrolled_to_domain_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
}

inline void ClientIncidentReport_EnvironmentData_OS::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.registry_key_) { arena },
        decltype(_impl_.os_name_) {}, decltype(_impl_.os_version_) {}, decltype(_impl_.is_enrolled_to_domain_) { false } };
    _impl_.os_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.os_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_OS::~ClientIncidentReport_EnvironmentData_OS()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_OS::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.registry_key_.~RepeatedPtrField();
    _impl_.os_name_.Destroy();
    _impl_.os_version_.Destroy();
}

void ClientIncidentReport_EnvironmentData_OS::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_OS::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.registry_key_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.os_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.os_version_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.is_enrolled_to_domain_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_OS::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string os_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_os_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string os_version = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_os_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey registry_key = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_registry_key(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool is_enrolled_to_domain = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_is_enrolled_to_domain(&has_bits);
                _impl_.is_enrolled_to_domain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_OS::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string os_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_os_name(), target);
    }

    // optional string os_version = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_os_version(), target);
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey registry_key = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_registry_key_size()); i < n; i++) {
        const auto& repfield = this->_internal_registry_key(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bool is_enrolled_to_domain = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_enrolled_to_domain(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
    return target;
}

size_t ClientIncidentReport_EnvironmentData_OS::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.OS.RegistryKey registry_key = 3;
    total_size += 1UL * this->_internal_registry_key_size();
    for (const auto& msg : this->_impl_.registry_key_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string os_name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_os_name());
        }

        // optional string os_version = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_os_version());
        }

        // optional bool is_enrolled_to_domain = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_EnvironmentData_OS::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_OS*>(&from));
}

void ClientIncidentReport_EnvironmentData_OS::MergeFrom(const ClientIncidentReport_EnvironmentData_OS& from)
{
    ClientIncidentReport_EnvironmentData_OS* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.registry_key_.MergeFrom(from._impl_.registry_key_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_os_name(from._internal_os_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_os_version(from._internal_os_version());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.is_enrolled_to_domain_ = from._impl_.is_enrolled_to_domain_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_OS::CopyFrom(const ClientIncidentReport_EnvironmentData_OS& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.OS)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_OS::IsInitialized() const
{
    return true;
}

void ClientIncidentReport_EnvironmentData_OS::InternalSwap(ClientIncidentReport_EnvironmentData_OS* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.registry_key_.InternalSwap(&other->_impl_.registry_key_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.os_name_, lhs_arena, &other->_impl_.os_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.os_version_, lhs_arena, &other->_impl_.os_version_, rhs_arena);
    swap(_impl_.is_enrolled_to_domain_, other->_impl_.is_enrolled_to_domain_);
}

std::string ClientIncidentReport_EnvironmentData_OS::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.EnvironmentData.OS";
}

// ===================================================================

class ClientIncidentReport_EnvironmentData_Machine::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_Machine>()._impl_._has_bits_);
    static void set_has_cpu_architecture(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_cpu_vendor(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_cpuid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

ClientIncidentReport_EnvironmentData_Machine::ClientIncidentReport_EnvironmentData_Machine(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
}
ClientIncidentReport_EnvironmentData_Machine::ClientIncidentReport_EnvironmentData_Machine(const ClientIncidentReport_EnvironmentData_Machine& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_EnvironmentData_Machine* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cpu_architecture_) {},
        decltype(_impl_.cpu_vendor_) {}, decltype(_impl_.cpuid_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.cpu_architecture_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_architecture_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_cpu_architecture()) {
        _this->_impl_.cpu_architecture_.Set(from._internal_cpu_architecture(), _this->GetArenaForAllocation());
    }
    _impl_.cpu_vendor_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_vendor_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_cpu_vendor()) {
        _this->_impl_.cpu_vendor_.Set(from._internal_cpu_vendor(), _this->GetArenaForAllocation());
    }
    _this->_impl_.cpuid_ = from._impl_.cpuid_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
}

inline void ClientIncidentReport_EnvironmentData_Machine::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cpu_architecture_) {},
        decltype(_impl_.cpu_vendor_) {}, decltype(_impl_.cpuid_) { 0u } };
    _impl_.cpu_architecture_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_architecture_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_vendor_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cpu_vendor_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_Machine::~ClientIncidentReport_EnvironmentData_Machine()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_Machine::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.cpu_architecture_.Destroy();
    _impl_.cpu_vendor_.Destroy();
}

void ClientIncidentReport_EnvironmentData_Machine::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_Machine::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.cpu_architecture_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.cpu_vendor_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.cpuid_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_Machine::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string cpu_architecture = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_cpu_architecture();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string cpu_vendor = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_cpu_vendor();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 cpuid = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_cpuid(&has_bits);
                _impl_.cpuid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_Machine::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string cpu_architecture = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_cpu_architecture(), target);
    }

    // optional string cpu_vendor = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_cpu_vendor(), target);
    }

    // optional uint32 cpuid = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_cpuid(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
    return target;
}

size_t ClientIncidentReport_EnvironmentData_Machine::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string cpu_architecture = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_cpu_architecture());
        }

        // optional string cpu_vendor = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_cpu_vendor());
        }

        // optional uint32 cpuid = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_cpuid());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_EnvironmentData_Machine::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_Machine*>(&from));
}

void ClientIncidentReport_EnvironmentData_Machine::MergeFrom(const ClientIncidentReport_EnvironmentData_Machine& from)
{
    ClientIncidentReport_EnvironmentData_Machine* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_cpu_architecture(from._internal_cpu_architecture());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_cpu_vendor(from._internal_cpu_vendor());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.cpuid_ = from._impl_.cpuid_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_Machine::CopyFrom(const ClientIncidentReport_EnvironmentData_Machine& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Machine)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_Machine::IsInitialized() const
{
    return true;
}

void ClientIncidentReport_EnvironmentData_Machine::InternalSwap(ClientIncidentReport_EnvironmentData_Machine* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.cpu_architecture_, lhs_arena, &other->_impl_.cpu_architecture_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.cpu_vendor_, lhs_arena, &other->_impl_.cpu_vendor_, rhs_arena);
    swap(_impl_.cpuid_, other->_impl_.cpuid_);
}

std::string ClientIncidentReport_EnvironmentData_Machine::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.EnvironmentData.Machine";
}

// ===================================================================

class ClientIncidentReport_EnvironmentData_Process_Patch::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_Process_Patch>()._impl_._has_bits_);
    static void set_has_function(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_target_dll(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ClientIncidentReport_EnvironmentData_Process_Patch::ClientIncidentReport_EnvironmentData_Process_Patch(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
}
ClientIncidentReport_EnvironmentData_Process_Patch::ClientIncidentReport_EnvironmentData_Process_Patch(
    const ClientIncidentReport_EnvironmentData_Process_Patch& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_EnvironmentData_Process_Patch* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.function_) {},
        decltype(_impl_.target_dll_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.function_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_function()) {
        _this->_impl_.function_.Set(from._internal_function(), _this->GetArenaForAllocation());
    }
    _impl_.target_dll_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_dll_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_target_dll()) {
        _this->_impl_.target_dll_.Set(from._internal_target_dll(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
}

inline void ClientIncidentReport_EnvironmentData_Process_Patch::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.function_) {}, decltype(_impl_.target_dll_) {} };
    _impl_.function_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_dll_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_dll_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_Process_Patch::~ClientIncidentReport_EnvironmentData_Process_Patch()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_Process_Patch::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.function_.Destroy();
    _impl_.target_dll_.Destroy();
}

void ClientIncidentReport_EnvironmentData_Process_Patch::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_Process_Patch::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.function_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.target_dll_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_Process_Patch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string function = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_function();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string target_dll = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_target_dll();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_Process_Patch::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string function = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_function(), target);
    }

    // optional string target_dll = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_target_dll(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
    return target;
}

size_t ClientIncidentReport_EnvironmentData_Process_Patch::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string function = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_function());
        }

        // optional string target_dll = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_target_dll());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_EnvironmentData_Process_Patch::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_Process_Patch*>(&from));
}

void ClientIncidentReport_EnvironmentData_Process_Patch::MergeFrom(const ClientIncidentReport_EnvironmentData_Process_Patch& from)
{
    ClientIncidentReport_EnvironmentData_Process_Patch* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_function(from._internal_function());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_target_dll(from._internal_target_dll());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_Process_Patch::CopyFrom(const ClientIncidentReport_EnvironmentData_Process_Patch& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_Process_Patch::IsInitialized() const
{
    return true;
}

void ClientIncidentReport_EnvironmentData_Process_Patch::InternalSwap(ClientIncidentReport_EnvironmentData_Process_Patch* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.function_, lhs_arena, &other->_impl_.function_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.target_dll_, lhs_arena, &other->_impl_.target_dll_, rhs_arena);
}

std::string ClientIncidentReport_EnvironmentData_Process_Patch::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch";
}

// ===================================================================

class ClientIncidentReport_EnvironmentData_Process_NetworkProvider::_Internal {
public:
};

ClientIncidentReport_EnvironmentData_Process_NetworkProvider::ClientIncidentReport_EnvironmentData_Process_NetworkProvider(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
}
ClientIncidentReport_EnvironmentData_Process_NetworkProvider::ClientIncidentReport_EnvironmentData_Process_NetworkProvider(
    const ClientIncidentReport_EnvironmentData_Process_NetworkProvider& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_EnvironmentData_Process_NetworkProvider* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
}

inline void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

ClientIncidentReport_EnvironmentData_Process_NetworkProvider::~ClientIncidentReport_EnvironmentData_Process_NetworkProvider()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_Process_NetworkProvider::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_Process_NetworkProvider::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
    return target;
}

size_t ClientIncidentReport_EnvironmentData_Process_NetworkProvider::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_Process_NetworkProvider*>(&from));
}

void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::MergeFrom(const ClientIncidentReport_EnvironmentData_Process_NetworkProvider& from)
{
    ClientIncidentReport_EnvironmentData_Process_NetworkProvider* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::CopyFrom(const ClientIncidentReport_EnvironmentData_Process_NetworkProvider& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_Process_NetworkProvider::IsInitialized() const
{
    return true;
}

void ClientIncidentReport_EnvironmentData_Process_NetworkProvider::InternalSwap(ClientIncidentReport_EnvironmentData_Process_NetworkProvider* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ClientIncidentReport_EnvironmentData_Process_NetworkProvider::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider";
}

// ===================================================================

class ClientIncidentReport_EnvironmentData_Process_Dll::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_Process_Dll>()._impl_._has_bits_);
    static void set_has_path(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_base_address(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::safe_browsing::ClientDownloadRequest_ImageHeaders& image_headers(const ClientIncidentReport_EnvironmentData_Process_Dll* msg);
    static void set_has_image_headers(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::safe_browsing::ClientDownloadRequest_ImageHeaders& ClientIncidentReport_EnvironmentData_Process_Dll::_Internal::image_headers(
    const ClientIncidentReport_EnvironmentData_Process_Dll* msg)
{
    return *msg->_impl_.image_headers_;
}
ClientIncidentReport_EnvironmentData_Process_Dll::ClientIncidentReport_EnvironmentData_Process_Dll(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
}
ClientIncidentReport_EnvironmentData_Process_Dll::ClientIncidentReport_EnvironmentData_Process_Dll(const ClientIncidentReport_EnvironmentData_Process_Dll& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_EnvironmentData_Process_Dll* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.feature_) { from._impl_.feature_ }, decltype(_impl_.path_) {}, decltype(_impl_.image_headers_) { nullptr },
        decltype(_impl_.base_address_) {}, decltype(_impl_.length_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_path()) {
        _this->_impl_.path_.Set(from._internal_path(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_image_headers()) {
        _this->_impl_.image_headers_ = new ::safe_browsing::ClientDownloadRequest_ImageHeaders(*from._impl_.image_headers_);
    }
    ::memcpy(&_impl_.base_address_, &from._impl_.base_address_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.length_) - reinterpret_cast<char*>(&_impl_.base_address_)) + sizeof(_impl_.length_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
}

inline void ClientIncidentReport_EnvironmentData_Process_Dll::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.feature_) { arena }, decltype(_impl_.path_) {},
        decltype(_impl_.image_headers_) { nullptr }, decltype(_impl_.base_address_) { uint64_t { 0u } }, decltype(_impl_.length_) { 0u } };
    _impl_.path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_Process_Dll::~ClientIncidentReport_EnvironmentData_Process_Dll()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_Process_Dll::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.feature_.~RepeatedField();
    _impl_.path_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.image_headers_;
}

void ClientIncidentReport_EnvironmentData_Process_Dll::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_Process_Dll::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.feature_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.path_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.image_headers_ != nullptr);
            _impl_.image_headers_->Clear();
        }
    }
    if (cached_has_bits & 0x0000000cu) {
        ::memset(&_impl_.base_address_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.length_) - reinterpret_cast<char*>(&_impl_.base_address_)) + sizeof(_impl_.length_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_Process_Dll::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string path = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_path();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint64 base_address = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_base_address(&has_bits);
                _impl_.base_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 length = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_length(&has_bits);
                _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll.Feature feature = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Dll_Feature_IsValid(val))) {
                        _internal_add_feature(static_cast<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Dll_Feature>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
            } else if (static_cast<uint8_t>(tag) == 34) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_feature(), ptr, ctx,
                    ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Dll_Feature_IsValid, &_internal_metadata_, 4);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_image_headers(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_Process_Dll::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string path = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_path(), target);
    }

    // optional uint64 base_address = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_base_address(), target);
    }

    // optional uint32 length = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_length(), target);
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll.Feature feature = 4;
    for (int i = 0, n = this->_internal_feature_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_feature(i), target);
    }

    // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 5;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::image_headers(this), _Internal::image_headers(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
    return target;
}

size_t ClientIncidentReport_EnvironmentData_Process_Dll::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll.Feature feature = 4;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_feature_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_feature(static_cast<int>(i)));
        }
        total_size += (1UL * count) + data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string path = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_path());
        }

        // optional .safe_browsing.ClientDownloadRequest.ImageHeaders image_headers = 5;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.image_headers_);
        }

        // optional uint64 base_address = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_base_address());
        }

        // optional uint32 length = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_length());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_EnvironmentData_Process_Dll::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_Process_Dll*>(&from));
}

void ClientIncidentReport_EnvironmentData_Process_Dll::MergeFrom(const ClientIncidentReport_EnvironmentData_Process_Dll& from)
{
    ClientIncidentReport_EnvironmentData_Process_Dll* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.feature_.MergeFrom(from._impl_.feature_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_path(from._internal_path());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_image_headers()->::safe_browsing::ClientDownloadRequest_ImageHeaders::MergeFrom(from._internal_image_headers());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.base_address_ = from._impl_.base_address_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.length_ = from._impl_.length_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_Process_Dll::CopyFrom(const ClientIncidentReport_EnvironmentData_Process_Dll& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_Process_Dll::IsInitialized() const
{
    if (_internal_has_image_headers()) {
        if (!_impl_.image_headers_->IsInitialized())
            return false;
    }
    return true;
}

void ClientIncidentReport_EnvironmentData_Process_Dll::InternalSwap(ClientIncidentReport_EnvironmentData_Process_Dll* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.feature_.InternalSwap(&other->_impl_.feature_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.path_, lhs_arena, &other->_impl_.path_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData_Process_Dll, _impl_.length_)
        + sizeof(ClientIncidentReport_EnvironmentData_Process_Dll::_impl_.length_)
        - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData_Process_Dll, _impl_.image_headers_)>(
        reinterpret_cast<char*>(&_impl_.image_headers_), reinterpret_cast<char*>(&other->_impl_.image_headers_));
}

std::string ClientIncidentReport_EnvironmentData_Process_Dll::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll";
}

// ===================================================================

class ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification>()._impl_._has_bits_);
    static void set_has_file_offset(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_byte_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_modified_bytes(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_export_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
}
ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification(
    const ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.modified_bytes_) {},
        decltype(_impl_.export_name_) {}, decltype(_impl_.file_offset_) {}, decltype(_impl_.byte_count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.modified_bytes_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.modified_bytes_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_modified_bytes()) {
        _this->_impl_.modified_bytes_.Set(from._internal_modified_bytes(), _this->GetArenaForAllocation());
    }
    _impl_.export_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.export_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_export_name()) {
        _this->_impl_.export_name_.Set(from._internal_export_name(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.file_offset_, &from._impl_.file_offset_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.byte_count_) - reinterpret_cast<char*>(&_impl_.file_offset_)) + sizeof(_impl_.byte_count_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
}

inline void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.modified_bytes_) {},
        decltype(_impl_.export_name_) {}, decltype(_impl_.file_offset_) { 0u }, decltype(_impl_.byte_count_) { 0 } };
    _impl_.modified_bytes_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.modified_bytes_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.export_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.export_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::~ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.modified_bytes_.Destroy();
    _impl_.export_name_.Destroy();
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.modified_bytes_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.export_name_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000000cu) {
        ::memset(&_impl_.file_offset_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.byte_count_) - reinterpret_cast<char*>(&_impl_.file_offset_)) + sizeof(_impl_.byte_count_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint32 file_offset = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_file_offset(&has_bits);
                _impl_.file_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 byte_count = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_byte_count(&has_bits);
                _impl_.byte_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes modified_bytes = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_modified_bytes();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string export_name = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_export_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 file_offset = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_file_offset(), target);
    }

    // optional int32 byte_count = 2;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_byte_count(), target);
    }

    // optional bytes modified_bytes = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_modified_bytes(), target);
    }

    // optional string export_name = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_export_name(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
    return target;
}

size_t ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional bytes modified_bytes = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_modified_bytes());
        }

        // optional string export_name = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_export_name());
        }

        // optional uint32 file_offset = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_file_offset());
        }

        // optional int32 byte_count = 2;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_byte_count());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification*>(&from));
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::MergeFrom(
    const ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification& from)
{
    ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_modified_bytes(from._internal_modified_bytes());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_export_name(from._internal_export_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.file_offset_ = from._impl_.file_offset_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.byte_count_ = from._impl_.byte_count_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::CopyFrom(
    const ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::IsInitialized() const
{
    return true;
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::InternalSwap(
    ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.modified_bytes_, lhs_arena, &other->_impl_.modified_bytes_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.export_name_, lhs_arena, &other->_impl_.export_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification, _impl_.byte_count_)
        + sizeof(ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::_impl_.byte_count_)
        - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification, _impl_.file_offset_)>(
        reinterpret_cast<char*>(&_impl_.file_offset_), reinterpret_cast<char*>(&other->_impl_.file_offset_));
}

std::string ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification";
}

// ===================================================================

class ClientIncidentReport_EnvironmentData_Process_ModuleState::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_Process_ModuleState>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_modified_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ClientIncidentReport_EnvironmentData_Process_ModuleState::ClientIncidentReport_EnvironmentData_Process_ModuleState(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
}
ClientIncidentReport_EnvironmentData_Process_ModuleState::ClientIncidentReport_EnvironmentData_Process_ModuleState(
    const ClientIncidentReport_EnvironmentData_Process_ModuleState& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_EnvironmentData_Process_ModuleState* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.obsolete_modified_export_) { from._impl_.obsolete_modified_export_ }, decltype(_impl_.modification_) { from._impl_.modification_ },
        decltype(_impl_.name_) {}, decltype(_impl_.modified_state_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _this->_impl_.modified_state_ = from._impl_.modified_state_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
}

inline void ClientIncidentReport_EnvironmentData_Process_ModuleState::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.obsolete_modified_export_) { arena },
        decltype(_impl_.modification_) { arena }, decltype(_impl_.name_) {}, decltype(_impl_.modified_state_) { 0 } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_Process_ModuleState::~ClientIncidentReport_EnvironmentData_Process_ModuleState()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_Process_ModuleState::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.obsolete_modified_export_.~RepeatedPtrField();
    _impl_.modification_.~RepeatedPtrField();
    _impl_.name_.Destroy();
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.obsolete_modified_export_.Clear();
    _impl_.modification_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.name_.ClearNonDefaultToEmpty();
    }
    _impl_.modified_state_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_Process_ModuleState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.ModifiedState modified_state = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState_IsValid(val))) {
                    _internal_set_modified_state(static_cast<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState_ModifiedState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated string OBSOLETE_modified_export = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_obsolete_modified_export();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification modification = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_modification(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_Process_ModuleState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.ModifiedState modified_state = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_modified_state(), target);
    }

    // repeated string OBSOLETE_modified_export = 3;
    for (int i = 0, n = this->_internal_obsolete_modified_export_size(); i < n; i++) {
        const auto& s = this->_internal_obsolete_modified_export(i);
        target = stream->WriteString(3, s, target);
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification modification = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_modification_size()); i < n; i++) {
        const auto& repfield = this->_internal_modification(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
    return target;
}

size_t ClientIncidentReport_EnvironmentData_Process_ModuleState::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string OBSOLETE_modified_export = 3;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.obsolete_modified_export_.size());
    for (int i = 0, n = _impl_.obsolete_modified_export_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.obsolete_modified_export_.Get(i));
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.Modification modification = 4;
    total_size += 1UL * this->_internal_modification_size();
    for (const auto& msg : this->_impl_.modification_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState.ModifiedState modified_state = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_modified_state());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_Process_ModuleState*>(&from));
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState::MergeFrom(const ClientIncidentReport_EnvironmentData_Process_ModuleState& from)
{
    ClientIncidentReport_EnvironmentData_Process_ModuleState* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.obsolete_modified_export_.MergeFrom(from._impl_.obsolete_modified_export_);
    _this->_impl_.modification_.MergeFrom(from._impl_.modification_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.modified_state_ = from._impl_.modified_state_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState::CopyFrom(const ClientIncidentReport_EnvironmentData_Process_ModuleState& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_Process_ModuleState::IsInitialized() const
{
    return true;
}

void ClientIncidentReport_EnvironmentData_Process_ModuleState::InternalSwap(ClientIncidentReport_EnvironmentData_Process_ModuleState* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.obsolete_modified_export_.InternalSwap(&other->_impl_.obsolete_modified_export_);
    _impl_.modification_.InternalSwap(&other->_impl_.modification_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    swap(_impl_.modified_state_, other->_impl_.modified_state_);
}

std::string ClientIncidentReport_EnvironmentData_Process_ModuleState::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState";
}

// ===================================================================

class ClientIncidentReport_EnvironmentData_Process::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData_Process>()._impl_._has_bits_);
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_chrome_update_channel(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_uptime_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_metrics_consent(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_obsolete_extended_consent(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_obsolete_field_trial_participant(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
};

ClientIncidentReport_EnvironmentData_Process::ClientIncidentReport_EnvironmentData_Process(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
}
ClientIncidentReport_EnvironmentData_Process::ClientIncidentReport_EnvironmentData_Process(const ClientIncidentReport_EnvironmentData_Process& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_EnvironmentData_Process* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.obsolete_dlls_) { from._impl_.obsolete_dlls_ }, decltype(_impl_.patches_) { from._impl_.patches_ },
        decltype(_impl_.network_providers_) { from._impl_.network_providers_ }, decltype(_impl_.dll_) { from._impl_.dll_ },
        decltype(_impl_.blocklisted_dll_) { from._impl_.blocklisted_dll_ }, decltype(_impl_.module_state_) { from._impl_.module_state_ },
        decltype(_impl_.version_) {}, decltype(_impl_.uptime_msec_) {}, decltype(_impl_.chrome_update_channel_) {}, decltype(_impl_.metrics_consent_) {},
        decltype(_impl_.obsolete_extended_consent_) {}, decltype(_impl_.obsolete_field_trial_participant_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_version()) {
        _this->_impl_.version_.Set(from._internal_version(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.uptime_msec_, &from._impl_.uptime_msec_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.obsolete_field_trial_participant_) - reinterpret_cast<char*>(&_impl_.uptime_msec_))
            + sizeof(_impl_.obsolete_field_trial_participant_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
}

inline void ClientIncidentReport_EnvironmentData_Process::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.obsolete_dlls_) { arena },
        decltype(_impl_.patches_) { arena }, decltype(_impl_.network_providers_) { arena }, decltype(_impl_.dll_) { arena },
        decltype(_impl_.blocklisted_dll_) { arena }, decltype(_impl_.module_state_) { arena }, decltype(_impl_.version_) {},
        decltype(_impl_.uptime_msec_) { int64_t { 0 } }, decltype(_impl_.chrome_update_channel_) { 0 }, decltype(_impl_.metrics_consent_) { false },
        decltype(_impl_.obsolete_extended_consent_) { false }, decltype(_impl_.obsolete_field_trial_participant_) { false } };
    _impl_.version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_EnvironmentData_Process::~ClientIncidentReport_EnvironmentData_Process()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData_Process::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.obsolete_dlls_.~RepeatedPtrField();
    _impl_.patches_.~RepeatedPtrField();
    _impl_.network_providers_.~RepeatedPtrField();
    _impl_.dll_.~RepeatedPtrField();
    _impl_.blocklisted_dll_.~RepeatedPtrField();
    _impl_.module_state_.~RepeatedPtrField();
    _impl_.version_.Destroy();
}

void ClientIncidentReport_EnvironmentData_Process::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData_Process::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.obsolete_dlls_.Clear();
    _impl_.patches_.Clear();
    _impl_.network_providers_.Clear();
    _impl_.dll_.Clear();
    _impl_.blocklisted_dll_.Clear();
    _impl_.module_state_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x0000003eu) {
        ::memset(&_impl_.uptime_msec_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.obsolete_field_trial_participant_) - reinterpret_cast<char*>(&_impl_.uptime_msec_))
                + sizeof(_impl_.obsolete_field_trial_participant_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData_Process::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string version = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string OBSOLETE_dlls = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_obsolete_dlls();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch patches = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_patches(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider network_providers = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_network_providers(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Channel chrome_update_channel = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Channel_IsValid(val))) {
                    _internal_set_chrome_update_channel(static_cast<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Channel>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 uptime_msec = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_uptime_msec(&has_bits);
                _impl_.uptime_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool metrics_consent = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_metrics_consent(&has_bits);
                _impl_.metrics_consent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool OBSOLETE_extended_consent = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_obsolete_extended_consent(&has_bits);
                _impl_.obsolete_extended_consent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll dll = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_dll(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string blocklisted_dll = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_blocklisted_dll();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState module_state = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_module_state(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool OBSOLETE_field_trial_participant = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                _Internal::set_has_obsolete_field_trial_participant(&has_bits);
                _impl_.obsolete_field_trial_participant_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData_Process::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string version = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_version(), target);
    }

    // repeated string OBSOLETE_dlls = 2;
    for (int i = 0, n = this->_internal_obsolete_dlls_size(); i < n; i++) {
        const auto& s = this->_internal_obsolete_dlls(i);
        target = stream->WriteString(2, s, target);
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch patches = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_patches_size()); i < n; i++) {
        const auto& repfield = this->_internal_patches(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider network_providers = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_network_providers_size()); i < n; i++) {
        const auto& repfield = this->_internal_network_providers(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Channel chrome_update_channel = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_chrome_update_channel(), target);
    }

    // optional int64 uptime_msec = 6;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_uptime_msec(), target);
    }

    // optional bool metrics_consent = 7;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_metrics_consent(), target);
    }

    // optional bool OBSOLETE_extended_consent = 8;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_obsolete_extended_consent(), target);
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll dll = 9;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_dll_size()); i < n; i++) {
        const auto& repfield = this->_internal_dll(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated string blocklisted_dll = 10;
    for (int i = 0, n = this->_internal_blocklisted_dll_size(); i < n; i++) {
        const auto& s = this->_internal_blocklisted_dll(i);
        target = stream->WriteString(10, s, target);
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState module_state = 11;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_module_state_size()); i < n; i++) {
        const auto& repfield = this->_internal_module_state(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bool OBSOLETE_field_trial_participant = 12;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_obsolete_field_trial_participant(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
    return target;
}

size_t ClientIncidentReport_EnvironmentData_Process::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string OBSOLETE_dlls = 2;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.obsolete_dlls_.size());
    for (int i = 0, n = _impl_.obsolete_dlls_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.obsolete_dlls_.Get(i));
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Patch patches = 3;
    total_size += 1UL * this->_internal_patches_size();
    for (const auto& msg : this->_impl_.patches_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.NetworkProvider network_providers = 4;
    total_size += 1UL * this->_internal_network_providers_size();
    for (const auto& msg : this->_impl_.network_providers_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Dll dll = 9;
    total_size += 1UL * this->_internal_dll_size();
    for (const auto& msg : this->_impl_.dll_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated string blocklisted_dll = 10;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.blocklisted_dll_.size());
    for (int i = 0, n = _impl_.blocklisted_dll_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.blocklisted_dll_.Get(i));
    }

    // repeated .safe_browsing.ClientIncidentReport.EnvironmentData.Process.ModuleState module_state = 11;
    total_size += 1UL * this->_internal_module_state_size();
    for (const auto& msg : this->_impl_.module_state_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional string version = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_version());
        }

        // optional int64 uptime_msec = 6;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_uptime_msec());
        }

        // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process.Channel chrome_update_channel = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_chrome_update_channel());
        }

        // optional bool metrics_consent = 7;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }

        // optional bool OBSOLETE_extended_consent = 8;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }

        // optional bool OBSOLETE_field_trial_participant = 12;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_EnvironmentData_Process::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData_Process*>(&from));
}

void ClientIncidentReport_EnvironmentData_Process::MergeFrom(const ClientIncidentReport_EnvironmentData_Process& from)
{
    ClientIncidentReport_EnvironmentData_Process* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.obsolete_dlls_.MergeFrom(from._impl_.obsolete_dlls_);
    _this->_impl_.patches_.MergeFrom(from._impl_.patches_);
    _this->_impl_.network_providers_.MergeFrom(from._impl_.network_providers_);
    _this->_impl_.dll_.MergeFrom(from._impl_.dll_);
    _this->_impl_.blocklisted_dll_.MergeFrom(from._impl_.blocklisted_dll_);
    _this->_impl_.module_state_.MergeFrom(from._impl_.module_state_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_version(from._internal_version());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.uptime_msec_ = from._impl_.uptime_msec_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.chrome_update_channel_ = from._impl_.chrome_update_channel_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.metrics_consent_ = from._impl_.metrics_consent_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.obsolete_extended_consent_ = from._impl_.obsolete_extended_consent_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.obsolete_field_trial_participant_ = from._impl_.obsolete_field_trial_participant_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData_Process::CopyFrom(const ClientIncidentReport_EnvironmentData_Process& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData.Process)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData_Process::IsInitialized() const
{
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.dll_))
        return false;
    return true;
}

void ClientIncidentReport_EnvironmentData_Process::InternalSwap(ClientIncidentReport_EnvironmentData_Process* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.obsolete_dlls_.InternalSwap(&other->_impl_.obsolete_dlls_);
    _impl_.patches_.InternalSwap(&other->_impl_.patches_);
    _impl_.network_providers_.InternalSwap(&other->_impl_.network_providers_);
    _impl_.dll_.InternalSwap(&other->_impl_.dll_);
    _impl_.blocklisted_dll_.InternalSwap(&other->_impl_.blocklisted_dll_);
    _impl_.module_state_.InternalSwap(&other->_impl_.module_state_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.version_, lhs_arena, &other->_impl_.version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData_Process, _impl_.obsolete_field_trial_participant_)
        + sizeof(ClientIncidentReport_EnvironmentData_Process::_impl_.obsolete_field_trial_participant_)
        - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData_Process, _impl_.uptime_msec_)>(
        reinterpret_cast<char*>(&_impl_.uptime_msec_), reinterpret_cast<char*>(&other->_impl_.uptime_msec_));
}

std::string ClientIncidentReport_EnvironmentData_Process::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.EnvironmentData.Process";
}

// ===================================================================

class ClientIncidentReport_EnvironmentData::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_EnvironmentData>()._impl_._has_bits_);
    static const ::safe_browsing::ClientIncidentReport_EnvironmentData_OS& os(const ClientIncidentReport_EnvironmentData* msg);
    static void set_has_os(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::safe_browsing::ClientIncidentReport_EnvironmentData_Machine& machine(const ClientIncidentReport_EnvironmentData* msg);
    static void set_has_machine(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::safe_browsing::ClientIncidentReport_EnvironmentData_Process& process(const ClientIncidentReport_EnvironmentData* msg);
    static void set_has_process(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::safe_browsing::ClientIncidentReport_EnvironmentData_OS& ClientIncidentReport_EnvironmentData::_Internal::os(
    const ClientIncidentReport_EnvironmentData* msg)
{
    return *msg->_impl_.os_;
}
const ::safe_browsing::ClientIncidentReport_EnvironmentData_Machine& ClientIncidentReport_EnvironmentData::_Internal::machine(
    const ClientIncidentReport_EnvironmentData* msg)
{
    return *msg->_impl_.machine_;
}
const ::safe_browsing::ClientIncidentReport_EnvironmentData_Process& ClientIncidentReport_EnvironmentData::_Internal::process(
    const ClientIncidentReport_EnvironmentData* msg)
{
    return *msg->_impl_.process_;
}
ClientIncidentReport_EnvironmentData::ClientIncidentReport_EnvironmentData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.EnvironmentData)
}
ClientIncidentReport_EnvironmentData::ClientIncidentReport_EnvironmentData(const ClientIncidentReport_EnvironmentData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_EnvironmentData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.os_) { nullptr },
        decltype(_impl_.machine_) { nullptr }, decltype(_impl_.process_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_os()) {
        _this->_impl_.os_ = new ::safe_browsing::ClientIncidentReport_EnvironmentData_OS(*from._impl_.os_);
    }
    if (from._internal_has_machine()) {
        _this->_impl_.machine_ = new ::safe_browsing::ClientIncidentReport_EnvironmentData_Machine(*from._impl_.machine_);
    }
    if (from._internal_has_process()) {
        _this->_impl_.process_ = new ::safe_browsing::ClientIncidentReport_EnvironmentData_Process(*from._impl_.process_);
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.EnvironmentData)
}

inline void ClientIncidentReport_EnvironmentData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.os_) { nullptr },
        decltype(_impl_.machine_) { nullptr }, decltype(_impl_.process_) { nullptr } };
}

ClientIncidentReport_EnvironmentData::~ClientIncidentReport_EnvironmentData()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.EnvironmentData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_EnvironmentData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.os_;
    if (this != internal_default_instance())
        delete _impl_.machine_;
    if (this != internal_default_instance())
        delete _impl_.process_;
}

void ClientIncidentReport_EnvironmentData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_EnvironmentData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.EnvironmentData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.os_ != nullptr);
            _impl_.os_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.machine_ != nullptr);
            _impl_.machine_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.process_ != nullptr);
            _impl_.process_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_EnvironmentData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientIncidentReport.EnvironmentData.OS os = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_os(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Machine machine = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_machine(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process process = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_process(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_EnvironmentData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.EnvironmentData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientIncidentReport.EnvironmentData.OS os = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::os(this), _Internal::os(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Machine machine = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::machine(this), _Internal::machine(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process process = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::process(this), _Internal::process(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.EnvironmentData)
    return target;
}

size_t ClientIncidentReport_EnvironmentData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.EnvironmentData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional .safe_browsing.ClientIncidentReport.EnvironmentData.OS os = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.os_);
        }

        // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Machine machine = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.machine_);
        }

        // optional .safe_browsing.ClientIncidentReport.EnvironmentData.Process process = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.process_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_EnvironmentData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_EnvironmentData*>(&from));
}

void ClientIncidentReport_EnvironmentData::MergeFrom(const ClientIncidentReport_EnvironmentData& from)
{
    ClientIncidentReport_EnvironmentData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.EnvironmentData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_os()->::safe_browsing::ClientIncidentReport_EnvironmentData_OS::MergeFrom(from._internal_os());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_machine()->::safe_browsing::ClientIncidentReport_EnvironmentData_Machine::MergeFrom(from._internal_machine());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_process()->::safe_browsing::ClientIncidentReport_EnvironmentData_Process::MergeFrom(from._internal_process());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_EnvironmentData::CopyFrom(const ClientIncidentReport_EnvironmentData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.EnvironmentData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_EnvironmentData::IsInitialized() const
{
    if (_internal_has_process()) {
        if (!_impl_.process_->IsInitialized())
            return false;
    }
    return true;
}

void ClientIncidentReport_EnvironmentData::InternalSwap(ClientIncidentReport_EnvironmentData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData, _impl_.process_)
        + sizeof(ClientIncidentReport_EnvironmentData::_impl_.process_) - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_EnvironmentData, _impl_.os_)>(
        reinterpret_cast<char*>(&_impl_.os_), reinterpret_cast<char*>(&other->_impl_.os_));
}

std::string ClientIncidentReport_EnvironmentData::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.EnvironmentData";
}

// ===================================================================

class ClientIncidentReport_ExtensionData_ExtensionInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_ExtensionData_ExtensionInfo>()._impl_._has_bits_);
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_description(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_update_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_has_signature_validation(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_signature_is_valid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_installed_by_custodian(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_installed_by_default(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_installed_by_oem(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static void set_has_from_bookmark(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static void set_has_from_webstore(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static void set_has_converted_from_user_script(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32768u;
    }
    static void set_has_may_be_untrusted(HasBits* has_bits)
    {
        (*has_bits)[0] |= 131072u;
    }
    static void set_has_install_time_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 65536u;
    }
    static void set_has_manifest_location_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 262144u;
    }
    static void set_has_manifest(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
};

ClientIncidentReport_ExtensionData_ExtensionInfo::ClientIncidentReport_ExtensionData_ExtensionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
}
ClientIncidentReport_ExtensionData_ExtensionInfo::ClientIncidentReport_ExtensionData_ExtensionInfo(const ClientIncidentReport_ExtensionData_ExtensionInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_ExtensionData_ExtensionInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.id_) {},
        decltype(_impl_.version_) {}, decltype(_impl_.name_) {}, decltype(_impl_.description_) {}, decltype(_impl_.update_url_) {},
        decltype(_impl_.manifest_) {}, decltype(_impl_.state_) {}, decltype(_impl_.type_) {}, decltype(_impl_.has_signature_validation_) {},
        decltype(_impl_.signature_is_valid_) {}, decltype(_impl_.installed_by_custodian_) {}, decltype(_impl_.installed_by_default_) {},
        decltype(_impl_.installed_by_oem_) {}, decltype(_impl_.from_bookmark_) {}, decltype(_impl_.from_webstore_) {},
        decltype(_impl_.converted_from_user_script_) {}, decltype(_impl_.install_time_msec_) {}, decltype(_impl_.may_be_untrusted_) {},
        decltype(_impl_.manifest_location_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_id()) {
        _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
    }
    _impl_.version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_version()) {
        _this->_impl_.version_.Set(from._internal_version(), _this->GetArenaForAllocation());
    }
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_description()) {
        _this->_impl_.description_.Set(from._internal_description(), _this->GetArenaForAllocation());
    }
    _impl_.update_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.update_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_update_url()) {
        _this->_impl_.update_url_.Set(from._internal_update_url(), _this->GetArenaForAllocation());
    }
    _impl_.manifest_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manifest_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_manifest()) {
        _this->_impl_.manifest_.Set(from._internal_manifest(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.state_, &from._impl_.state_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.manifest_location_type_) - reinterpret_cast<char*>(&_impl_.state_))
            + sizeof(_impl_.manifest_location_type_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
}

inline void ClientIncidentReport_ExtensionData_ExtensionInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.id_) {}, decltype(_impl_.version_) {},
        decltype(_impl_.name_) {}, decltype(_impl_.description_) {}, decltype(_impl_.update_url_) {}, decltype(_impl_.manifest_) {},
        decltype(_impl_.state_) { 0 }, decltype(_impl_.type_) { 0 }, decltype(_impl_.has_signature_validation_) { false },
        decltype(_impl_.signature_is_valid_) { false }, decltype(_impl_.installed_by_custodian_) { false }, decltype(_impl_.installed_by_default_) { false },
        decltype(_impl_.installed_by_oem_) { false }, decltype(_impl_.from_bookmark_) { false }, decltype(_impl_.from_webstore_) { false },
        decltype(_impl_.converted_from_user_script_) { false }, decltype(_impl_.install_time_msec_) { int64_t { 0 } },
        decltype(_impl_.may_be_untrusted_) { false }, decltype(_impl_.manifest_location_type_) { 0 } };
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.update_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.update_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manifest_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manifest_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_ExtensionData_ExtensionInfo::~ClientIncidentReport_ExtensionData_ExtensionInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_ExtensionData_ExtensionInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.id_.Destroy();
    _impl_.version_.Destroy();
    _impl_.name_.Destroy();
    _impl_.description_.Destroy();
    _impl_.update_url_.Destroy();
    _impl_.manifest_.Destroy();
}

void ClientIncidentReport_ExtensionData_ExtensionInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_ExtensionData_ExtensionInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.version_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.description_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.update_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.manifest_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x000000c0u) {
        ::memset(
            &_impl_.state_, 0, static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) - reinterpret_cast<char*>(&_impl_.state_)) + sizeof(_impl_.type_));
    }
    if (cached_has_bits & 0x0000ff00u) {
        ::memset(&_impl_.has_signature_validation_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.converted_from_user_script_) - reinterpret_cast<char*>(&_impl_.has_signature_validation_))
                + sizeof(_impl_.converted_from_user_script_));
    }
    if (cached_has_bits & 0x00070000u) {
        ::memset(&_impl_.install_time_msec_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.manifest_location_type_) - reinterpret_cast<char*>(&_impl_.install_time_msec_))
                + sizeof(_impl_.manifest_location_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_ExtensionData_ExtensionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string version = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string name = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string description = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_description();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo.ExtensionState state = 5 [default = STATE_UNKNOWN];
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState_IsValid(val))) {
                    _internal_set_state(static_cast<::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo_ExtensionState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int32 type = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_type(&has_bits);
                _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string update_url = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_update_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool has_signature_validation = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_has_signature_validation(&has_bits);
                _impl_.has_signature_validation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool signature_is_valid = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _Internal::set_has_signature_is_valid(&has_bits);
                _impl_.signature_is_valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool installed_by_custodian = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                _Internal::set_has_installed_by_custodian(&has_bits);
                _impl_.installed_by_custodian_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool installed_by_default = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
                _Internal::set_has_installed_by_default(&has_bits);
                _impl_.installed_by_default_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool installed_by_oem = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                _Internal::set_has_installed_by_oem(&has_bits);
                _impl_.installed_by_oem_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool from_bookmark = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                _Internal::set_has_from_bookmark(&has_bits);
                _impl_.from_bookmark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool from_webstore = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
                _Internal::set_has_from_webstore(&has_bits);
                _impl_.from_webstore_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool converted_from_user_script = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
                _Internal::set_has_converted_from_user_script(&has_bits);
                _impl_.converted_from_user_script_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool may_be_untrusted = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
                _Internal::set_has_may_be_untrusted(&has_bits);
                _impl_.may_be_untrusted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 install_time_msec = 17;
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
                _Internal::set_has_install_time_msec(&has_bits);
                _impl_.install_time_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 manifest_location_type = 18;
        case 18:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
                _Internal::set_has_manifest_location_type(&has_bits);
                _impl_.manifest_location_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string manifest = 19;
        case 19:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
                auto str = _internal_mutable_manifest();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_ExtensionData_ExtensionInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_id(), target);
    }

    // optional string version = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_version(), target);
    }

    // optional string name = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_name(), target);
    }

    // optional string description = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_description(), target);
    }

    // optional .safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo.ExtensionState state = 5 [default = STATE_UNKNOWN];
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_state(), target);
    }

    // optional int32 type = 6;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_type(), target);
    }

    // optional string update_url = 7;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_update_url(), target);
    }

    // optional bool has_signature_validation = 8;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_has_signature_validation(), target);
    }

    // optional bool signature_is_valid = 9;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_signature_is_valid(), target);
    }

    // optional bool installed_by_custodian = 10;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_installed_by_custodian(), target);
    }

    // optional bool installed_by_default = 11;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_installed_by_default(), target);
    }

    // optional bool installed_by_oem = 12;
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_installed_by_oem(), target);
    }

    // optional bool from_bookmark = 13;
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_from_bookmark(), target);
    }

    // optional bool from_webstore = 14;
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_from_webstore(), target);
    }

    // optional bool converted_from_user_script = 15;
    if (cached_has_bits & 0x00008000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_converted_from_user_script(), target);
    }

    // optional bool may_be_untrusted = 16;
    if (cached_has_bits & 0x00020000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_may_be_untrusted(), target);
    }

    // optional int64 install_time_msec = 17;
    if (cached_has_bits & 0x00010000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(17, this->_internal_install_time_msec(), target);
    }

    // optional int32 manifest_location_type = 18;
    if (cached_has_bits & 0x00040000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(18, this->_internal_manifest_location_type(), target);
    }

    // optional string manifest = 19;
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteStringMaybeAliased(19, this->_internal_manifest(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
    return target;
}

size_t ClientIncidentReport_ExtensionData_ExtensionInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_id());
        }

        // optional string version = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_version());
        }

        // optional string name = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string description = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_description());
        }

        // optional string update_url = 7;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_update_url());
        }

        // optional string manifest = 19;
        if (cached_has_bits & 0x00000020u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_manifest());
        }

        // optional .safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo.ExtensionState state = 5 [default = STATE_UNKNOWN];
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
        }

        // optional int32 type = 6;
        if (cached_has_bits & 0x00000080u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        // optional bool has_signature_validation = 8;
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + 1;
        }

        // optional bool signature_is_valid = 9;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + 1;
        }

        // optional bool installed_by_custodian = 10;
        if (cached_has_bits & 0x00000400u) {
            total_size += 1 + 1;
        }

        // optional bool installed_by_default = 11;
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + 1;
        }

        // optional bool installed_by_oem = 12;
        if (cached_has_bits & 0x00001000u) {
            total_size += 1 + 1;
        }

        // optional bool from_bookmark = 13;
        if (cached_has_bits & 0x00002000u) {
            total_size += 1 + 1;
        }

        // optional bool from_webstore = 14;
        if (cached_has_bits & 0x00004000u) {
            total_size += 1 + 1;
        }

        // optional bool converted_from_user_script = 15;
        if (cached_has_bits & 0x00008000u) {
            total_size += 1 + 1;
        }
    }
    if (cached_has_bits & 0x00070000u) {
        // optional int64 install_time_msec = 17;
        if (cached_has_bits & 0x00010000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_install_time_msec());
        }

        // optional bool may_be_untrusted = 16;
        if (cached_has_bits & 0x00020000u) {
            total_size += 2 + 1;
        }

        // optional int32 manifest_location_type = 18;
        if (cached_has_bits & 0x00040000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int32Size(this->_internal_manifest_location_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_ExtensionData_ExtensionInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_ExtensionData_ExtensionInfo*>(&from));
}

void ClientIncidentReport_ExtensionData_ExtensionInfo::MergeFrom(const ClientIncidentReport_ExtensionData_ExtensionInfo& from)
{
    ClientIncidentReport_ExtensionData_ExtensionInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_id(from._internal_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_version(from._internal_version());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_description(from._internal_description());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_update_url(from._internal_update_url());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_manifest(from._internal_manifest());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.state_ = from._impl_.state_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.has_signature_validation_ = from._impl_.has_signature_validation_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.signature_is_valid_ = from._impl_.signature_is_valid_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.installed_by_custodian_ = from._impl_.installed_by_custodian_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.installed_by_default_ = from._impl_.installed_by_default_;
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.installed_by_oem_ = from._impl_.installed_by_oem_;
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.from_bookmark_ = from._impl_.from_bookmark_;
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.from_webstore_ = from._impl_.from_webstore_;
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_impl_.converted_from_user_script_ = from._impl_.converted_from_user_script_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00070000u) {
        if (cached_has_bits & 0x00010000u) {
            _this->_impl_.install_time_msec_ = from._impl_.install_time_msec_;
        }
        if (cached_has_bits & 0x00020000u) {
            _this->_impl_.may_be_untrusted_ = from._impl_.may_be_untrusted_;
        }
        if (cached_has_bits & 0x00040000u) {
            _this->_impl_.manifest_location_type_ = from._impl_.manifest_location_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_ExtensionData_ExtensionInfo::CopyFrom(const ClientIncidentReport_ExtensionData_ExtensionInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_ExtensionData_ExtensionInfo::IsInitialized() const
{
    return true;
}

void ClientIncidentReport_ExtensionData_ExtensionInfo::InternalSwap(ClientIncidentReport_ExtensionData_ExtensionInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena, &other->_impl_.id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.version_, lhs_arena, &other->_impl_.version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.description_, lhs_arena, &other->_impl_.description_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.update_url_, lhs_arena, &other->_impl_.update_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.manifest_, lhs_arena, &other->_impl_.manifest_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientIncidentReport_ExtensionData_ExtensionInfo, _impl_.manifest_location_type_)
        + sizeof(ClientIncidentReport_ExtensionData_ExtensionInfo::_impl_.manifest_location_type_)
        - PROTOBUF_FIELD_OFFSET(ClientIncidentReport_ExtensionData_ExtensionInfo, _impl_.state_)>(
        reinterpret_cast<char*>(&_impl_.state_), reinterpret_cast<char*>(&other->_impl_.state_));
}

std::string ClientIncidentReport_ExtensionData_ExtensionInfo::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo";
}

// ===================================================================

class ClientIncidentReport_ExtensionData::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_ExtensionData>()._impl_._has_bits_);
    static const ::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo& last_installed_extension(const ClientIncidentReport_ExtensionData* msg);
    static void set_has_last_installed_extension(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo& ClientIncidentReport_ExtensionData::_Internal::last_installed_extension(
    const ClientIncidentReport_ExtensionData* msg)
{
    return *msg->_impl_.last_installed_extension_;
}
ClientIncidentReport_ExtensionData::ClientIncidentReport_ExtensionData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.ExtensionData)
}
ClientIncidentReport_ExtensionData::ClientIncidentReport_ExtensionData(const ClientIncidentReport_ExtensionData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_ExtensionData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.last_installed_extension_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_last_installed_extension()) {
        _this->_impl_.last_installed_extension_ = new ::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo(*from._impl_.last_installed_extension_);
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.ExtensionData)
}

inline void ClientIncidentReport_ExtensionData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.last_installed_extension_) { nullptr } };
}

ClientIncidentReport_ExtensionData::~ClientIncidentReport_ExtensionData()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.ExtensionData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_ExtensionData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.last_installed_extension_;
}

void ClientIncidentReport_ExtensionData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_ExtensionData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.ExtensionData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.last_installed_extension_ != nullptr);
        _impl_.last_installed_extension_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_ExtensionData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo last_installed_extension = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_last_installed_extension(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_ExtensionData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.ExtensionData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo last_installed_extension = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::last_installed_extension(this), _Internal::last_installed_extension(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.ExtensionData)
    return target;
}

size_t ClientIncidentReport_ExtensionData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.ExtensionData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .safe_browsing.ClientIncidentReport.ExtensionData.ExtensionInfo last_installed_extension = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.last_installed_extension_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_ExtensionData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_ExtensionData*>(&from));
}

void ClientIncidentReport_ExtensionData::MergeFrom(const ClientIncidentReport_ExtensionData& from)
{
    ClientIncidentReport_ExtensionData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.ExtensionData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_last_installed_extension()) {
        _this->_internal_mutable_last_installed_extension()->::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo::MergeFrom(
            from._internal_last_installed_extension());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_ExtensionData::CopyFrom(const ClientIncidentReport_ExtensionData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.ExtensionData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_ExtensionData::IsInitialized() const
{
    return true;
}

void ClientIncidentReport_ExtensionData::InternalSwap(ClientIncidentReport_ExtensionData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.last_installed_extension_, other->_impl_.last_installed_extension_);
}

std::string ClientIncidentReport_ExtensionData::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.ExtensionData";
}

// ===================================================================

class ClientIncidentReport_NonBinaryDownloadDetails::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport_NonBinaryDownloadDetails>()._impl_._has_bits_);
    static void set_has_file_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_url_spec_sha256(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_host(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

ClientIncidentReport_NonBinaryDownloadDetails::ClientIncidentReport_NonBinaryDownloadDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
}
ClientIncidentReport_NonBinaryDownloadDetails::ClientIncidentReport_NonBinaryDownloadDetails(const ClientIncidentReport_NonBinaryDownloadDetails& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport_NonBinaryDownloadDetails* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.file_type_) {},
        decltype(_impl_.url_spec_sha256_) {}, decltype(_impl_.host_) {}, decltype(_impl_.length_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.file_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_file_type()) {
        _this->_impl_.file_type_.Set(from._internal_file_type(), _this->GetArenaForAllocation());
    }
    _impl_.url_spec_sha256_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_spec_sha256_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url_spec_sha256()) {
        _this->_impl_.url_spec_sha256_.Set(from._internal_url_spec_sha256(), _this->GetArenaForAllocation());
    }
    _impl_.host_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_host()) {
        _this->_impl_.host_.Set(from._internal_host(), _this->GetArenaForAllocation());
    }
    _this->_impl_.length_ = from._impl_.length_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
}

inline void ClientIncidentReport_NonBinaryDownloadDetails::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.file_type_) {},
        decltype(_impl_.url_spec_sha256_) {}, decltype(_impl_.host_) {}, decltype(_impl_.length_) { int64_t { 0 } } };
    _impl_.file_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_spec_sha256_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_spec_sha256_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentReport_NonBinaryDownloadDetails::~ClientIncidentReport_NonBinaryDownloadDetails()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport_NonBinaryDownloadDetails::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.file_type_.Destroy();
    _impl_.url_spec_sha256_.Destroy();
    _impl_.host_.Destroy();
}

void ClientIncidentReport_NonBinaryDownloadDetails::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport_NonBinaryDownloadDetails::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.file_type_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.url_spec_sha256_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.host_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.length_ = int64_t { 0 };
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport_NonBinaryDownloadDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string file_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_file_type();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes url_spec_sha256 = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_url_spec_sha256();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string host = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_host();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 length = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_length(&has_bits);
                _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport_NonBinaryDownloadDetails::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string file_type = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_file_type(), target);
    }

    // optional bytes url_spec_sha256 = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_url_spec_sha256(), target);
    }

    // optional string host = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_host(), target);
    }

    // optional int64 length = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_length(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
    return target;
}

size_t ClientIncidentReport_NonBinaryDownloadDetails::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string file_type = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_file_type());
        }

        // optional bytes url_spec_sha256 = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_url_spec_sha256());
        }

        // optional string host = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_host());
        }

        // optional int64 length = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_length());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport_NonBinaryDownloadDetails::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport_NonBinaryDownloadDetails*>(&from));
}

void ClientIncidentReport_NonBinaryDownloadDetails::MergeFrom(const ClientIncidentReport_NonBinaryDownloadDetails& from)
{
    ClientIncidentReport_NonBinaryDownloadDetails* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_file_type(from._internal_file_type());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_url_spec_sha256(from._internal_url_spec_sha256());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_host(from._internal_host());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.length_ = from._impl_.length_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport_NonBinaryDownloadDetails::CopyFrom(const ClientIncidentReport_NonBinaryDownloadDetails& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport_NonBinaryDownloadDetails::IsInitialized() const
{
    return true;
}

void ClientIncidentReport_NonBinaryDownloadDetails::InternalSwap(ClientIncidentReport_NonBinaryDownloadDetails* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.file_type_, lhs_arena, &other->_impl_.file_type_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_spec_sha256_, lhs_arena, &other->_impl_.url_spec_sha256_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.host_, lhs_arena, &other->_impl_.host_, rhs_arena);
    swap(_impl_.length_, other->_impl_.length_);
}

std::string ClientIncidentReport_NonBinaryDownloadDetails::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails";
}

// ===================================================================

class ClientIncidentReport::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentReport>()._impl_._has_bits_);
    static const ::safe_browsing::ClientIncidentReport_DownloadDetails& download(const ClientIncidentReport* msg);
    static void set_has_download(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::safe_browsing::ClientIncidentReport_EnvironmentData& environment(const ClientIncidentReport* msg);
    static void set_has_environment(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::safe_browsing::ChromeUserPopulation& population(const ClientIncidentReport* msg);
    static void set_has_population(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::safe_browsing::ClientIncidentReport_ExtensionData& extension_data(const ClientIncidentReport* msg);
    static void set_has_extension_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::safe_browsing::ClientIncidentReport_NonBinaryDownloadDetails& non_binary_download(const ClientIncidentReport* msg);
    static void set_has_non_binary_download(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

const ::safe_browsing::ClientIncidentReport_DownloadDetails& ClientIncidentReport::_Internal::download(const ClientIncidentReport* msg)
{
    return *msg->_impl_.download_;
}
const ::safe_browsing::ClientIncidentReport_EnvironmentData& ClientIncidentReport::_Internal::environment(const ClientIncidentReport* msg)
{
    return *msg->_impl_.environment_;
}
const ::safe_browsing::ChromeUserPopulation& ClientIncidentReport::_Internal::population(const ClientIncidentReport* msg)
{
    return *msg->_impl_.population_;
}
const ::safe_browsing::ClientIncidentReport_ExtensionData& ClientIncidentReport::_Internal::extension_data(const ClientIncidentReport* msg)
{
    return *msg->_impl_.extension_data_;
}
const ::safe_browsing::ClientIncidentReport_NonBinaryDownloadDetails& ClientIncidentReport::_Internal::non_binary_download(const ClientIncidentReport* msg)
{
    return *msg->_impl_.non_binary_download_;
}
ClientIncidentReport::ClientIncidentReport(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentReport)
}
ClientIncidentReport::ClientIncidentReport(const ClientIncidentReport& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentReport* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.incident_) { from._impl_.incident_ }, decltype(_impl_.download_) { nullptr }, decltype(_impl_.environment_) { nullptr },
        decltype(_impl_.population_) { nullptr }, decltype(_impl_.extension_data_) { nullptr }, decltype(_impl_.non_binary_download_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_download()) {
        _this->_impl_.download_ = new ::safe_browsing::ClientIncidentReport_DownloadDetails(*from._impl_.download_);
    }
    if (from._internal_has_environment()) {
        _this->_impl_.environment_ = new ::safe_browsing::ClientIncidentReport_EnvironmentData(*from._impl_.environment_);
    }
    if (from._internal_has_population()) {
        _this->_impl_.population_ = new ::safe_browsing::ChromeUserPopulation(*from._impl_.population_);
    }
    if (from._internal_has_extension_data()) {
        _this->_impl_.extension_data_ = new ::safe_browsing::ClientIncidentReport_ExtensionData(*from._impl_.extension_data_);
    }
    if (from._internal_has_non_binary_download()) {
        _this->_impl_.non_binary_download_ = new ::safe_browsing::ClientIncidentReport_NonBinaryDownloadDetails(*from._impl_.non_binary_download_);
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentReport)
}

inline void ClientIncidentReport::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.incident_) { arena },
        decltype(_impl_.download_) { nullptr }, decltype(_impl_.environment_) { nullptr }, decltype(_impl_.population_) { nullptr },
        decltype(_impl_.extension_data_) { nullptr }, decltype(_impl_.non_binary_download_) { nullptr } };
}

ClientIncidentReport::~ClientIncidentReport()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentReport)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentReport::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.incident_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.download_;
    if (this != internal_default_instance())
        delete _impl_.environment_;
    if (this != internal_default_instance())
        delete _impl_.population_;
    if (this != internal_default_instance())
        delete _impl_.extension_data_;
    if (this != internal_default_instance())
        delete _impl_.non_binary_download_;
}

void ClientIncidentReport::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentReport::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentReport)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.incident_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.download_ != nullptr);
            _impl_.download_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.environment_ != nullptr);
            _impl_.environment_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.population_ != nullptr);
            _impl_.population_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.extension_data_ != nullptr);
            _impl_.extension_data_->Clear();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.non_binary_download_ != nullptr);
            _impl_.non_binary_download_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.ClientIncidentReport.IncidentData incident = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_incident(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.DownloadDetails download = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_download(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.EnvironmentData environment = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_environment(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ChromeUserPopulation population = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_population(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.ExtensionData extension_data = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_extension_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails non_binary_download = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr = ctx->ParseMessage(_internal_mutable_non_binary_download(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentReport::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentReport)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientIncidentReport.IncidentData incident = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_incident_size()); i < n; i++) {
        const auto& repfield = this->_internal_incident(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientIncidentReport.DownloadDetails download = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::download(this), _Internal::download(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientIncidentReport.EnvironmentData environment = 3;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::environment(this), _Internal::environment(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ChromeUserPopulation population = 7;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::population(this), _Internal::population(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientIncidentReport.ExtensionData extension_data = 8;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            8, _Internal::extension_data(this), _Internal::extension_data(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails non_binary_download = 9;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            9, _Internal::non_binary_download(this), _Internal::non_binary_download(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentReport)
    return target;
}

size_t ClientIncidentReport::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentReport)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientIncidentReport.IncidentData incident = 1;
    total_size += 1UL * this->_internal_incident_size();
    for (const auto& msg : this->_impl_.incident_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional .safe_browsing.ClientIncidentReport.DownloadDetails download = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.download_);
        }

        // optional .safe_browsing.ClientIncidentReport.EnvironmentData environment = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.environment_);
        }

        // optional .safe_browsing.ChromeUserPopulation population = 7;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.population_);
        }

        // optional .safe_browsing.ClientIncidentReport.ExtensionData extension_data = 8;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.extension_data_);
        }

        // optional .safe_browsing.ClientIncidentReport.NonBinaryDownloadDetails non_binary_download = 9;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.non_binary_download_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentReport::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentReport*>(&from));
}

void ClientIncidentReport::MergeFrom(const ClientIncidentReport& from)
{
    ClientIncidentReport* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentReport)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.incident_.MergeFrom(from._impl_.incident_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_download()->::safe_browsing::ClientIncidentReport_DownloadDetails::MergeFrom(from._internal_download());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_environment()->::safe_browsing::ClientIncidentReport_EnvironmentData::MergeFrom(from._internal_environment());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_population()->::safe_browsing::ChromeUserPopulation::MergeFrom(from._internal_population());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_extension_data()->::safe_browsing::ClientIncidentReport_ExtensionData::MergeFrom(from._internal_extension_data());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_non_binary_download()->::safe_browsing::ClientIncidentReport_NonBinaryDownloadDetails::MergeFrom(
                from._internal_non_binary_download());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentReport::CopyFrom(const ClientIncidentReport& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentReport)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentReport::IsInitialized() const
{
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.incident_))
        return false;
    if (_internal_has_download()) {
        if (!_impl_.download_->IsInitialized())
            return false;
    }
    if (_internal_has_environment()) {
        if (!_impl_.environment_->IsInitialized())
            return false;
    }
    return true;
}

void ClientIncidentReport::InternalSwap(ClientIncidentReport* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.incident_.InternalSwap(&other->_impl_.incident_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientIncidentReport, _impl_.non_binary_download_)
        + sizeof(ClientIncidentReport::_impl_.non_binary_download_) - PROTOBUF_FIELD_OFFSET(ClientIncidentReport, _impl_.download_)>(
        reinterpret_cast<char*>(&_impl_.download_), reinterpret_cast<char*>(&other->_impl_.download_));
}

std::string ClientIncidentReport::GetTypeName() const
{
    return "safe_browsing.ClientIncidentReport";
}

// ===================================================================

class ClientIncidentResponse_EnvironmentRequest::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentResponse_EnvironmentRequest>()._impl_._has_bits_);
    static void set_has_dll_index(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ClientIncidentResponse_EnvironmentRequest::ClientIncidentResponse_EnvironmentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
}
ClientIncidentResponse_EnvironmentRequest::ClientIncidentResponse_EnvironmentRequest(const ClientIncidentResponse_EnvironmentRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentResponse_EnvironmentRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.dll_index_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.dll_index_ = from._impl_.dll_index_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
}

inline void ClientIncidentResponse_EnvironmentRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.dll_index_) { 0 } };
}

ClientIncidentResponse_EnvironmentRequest::~ClientIncidentResponse_EnvironmentRequest()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentResponse_EnvironmentRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientIncidentResponse_EnvironmentRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentResponse_EnvironmentRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.dll_index_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentResponse_EnvironmentRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 dll_index = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_dll_index(&has_bits);
                _impl_.dll_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentResponse_EnvironmentRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 dll_index = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_dll_index(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
    return target;
}

size_t ClientIncidentResponse_EnvironmentRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional int32 dll_index = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dll_index());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentResponse_EnvironmentRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentResponse_EnvironmentRequest*>(&from));
}

void ClientIncidentResponse_EnvironmentRequest::MergeFrom(const ClientIncidentResponse_EnvironmentRequest& from)
{
    ClientIncidentResponse_EnvironmentRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_dll_index()) {
        _this->_internal_set_dll_index(from._internal_dll_index());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentResponse_EnvironmentRequest::CopyFrom(const ClientIncidentResponse_EnvironmentRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentResponse.EnvironmentRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentResponse_EnvironmentRequest::IsInitialized() const
{
    return true;
}

void ClientIncidentResponse_EnvironmentRequest::InternalSwap(ClientIncidentResponse_EnvironmentRequest* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.dll_index_, other->_impl_.dll_index_);
}

std::string ClientIncidentResponse_EnvironmentRequest::GetTypeName() const
{
    return "safe_browsing.ClientIncidentResponse.EnvironmentRequest";
}

// ===================================================================

class ClientIncidentResponse::_Internal {
public:
    using HasBits = decltype(std::declval<ClientIncidentResponse>()._impl_._has_bits_);
    static void set_has_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_download_requested(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ClientIncidentResponse::ClientIncidentResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientIncidentResponse)
}
ClientIncidentResponse::ClientIncidentResponse(const ClientIncidentResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientIncidentResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.environment_requests_) { from._impl_.environment_requests_ }, decltype(_impl_.token_) {}, decltype(_impl_.download_requested_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_token()) {
        _this->_impl_.token_.Set(from._internal_token(), _this->GetArenaForAllocation());
    }
    _this->_impl_.download_requested_ = from._impl_.download_requested_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientIncidentResponse)
}

inline void ClientIncidentResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.environment_requests_) { arena },
        decltype(_impl_.token_) {}, decltype(_impl_.download_requested_) { false } };
    _impl_.token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientIncidentResponse::~ClientIncidentResponse()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientIncidentResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientIncidentResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.environment_requests_.~RepeatedPtrField();
    _impl_.token_.Destroy();
}

void ClientIncidentResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientIncidentResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientIncidentResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.environment_requests_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.token_.ClearNonDefaultToEmpty();
    }
    _impl_.download_requested_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientIncidentResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bytes token = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool download_requested = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_download_requested(&has_bits);
                _impl_.download_requested_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientIncidentResponse.EnvironmentRequest environment_requests = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_environment_requests(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientIncidentResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientIncidentResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bytes token = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_token(), target);
    }

    // optional bool download_requested = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_download_requested(), target);
    }

    // repeated .safe_browsing.ClientIncidentResponse.EnvironmentRequest environment_requests = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_environment_requests_size()); i < n; i++) {
        const auto& repfield = this->_internal_environment_requests(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientIncidentResponse)
    return target;
}

size_t ClientIncidentResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientIncidentResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientIncidentResponse.EnvironmentRequest environment_requests = 3;
    total_size += 1UL * this->_internal_environment_requests_size();
    for (const auto& msg : this->_impl_.environment_requests_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional bytes token = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_token());
        }

        // optional bool download_requested = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientIncidentResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientIncidentResponse*>(&from));
}

void ClientIncidentResponse::MergeFrom(const ClientIncidentResponse& from)
{
    ClientIncidentResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientIncidentResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.environment_requests_.MergeFrom(from._impl_.environment_requests_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_token(from._internal_token());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.download_requested_ = from._impl_.download_requested_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientIncidentResponse::CopyFrom(const ClientIncidentResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientIncidentResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientIncidentResponse::IsInitialized() const
{
    return true;
}

void ClientIncidentResponse::InternalSwap(ClientIncidentResponse* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.environment_requests_.InternalSwap(&other->_impl_.environment_requests_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.token_, lhs_arena, &other->_impl_.token_, rhs_arena);
    swap(_impl_.download_requested_, other->_impl_.download_requested_);
}

std::string ClientIncidentResponse::GetTypeName() const
{
    return "safe_browsing.ClientIncidentResponse";
}

// ===================================================================

class DownloadMetadata::_Internal {
public:
    using HasBits = decltype(std::declval<DownloadMetadata>()._impl_._has_bits_);
    static void set_has_download_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::safe_browsing::ClientIncidentReport_DownloadDetails& download(const DownloadMetadata* msg);
    static void set_has_download(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::safe_browsing::ClientIncidentReport_DownloadDetails& DownloadMetadata::_Internal::download(const DownloadMetadata* msg)
{
    return *msg->_impl_.download_;
}
DownloadMetadata::DownloadMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.DownloadMetadata)
}
DownloadMetadata::DownloadMetadata(const DownloadMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DownloadMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.download_) { nullptr },
        decltype(_impl_.download_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_download()) {
        _this->_impl_.download_ = new ::safe_browsing::ClientIncidentReport_DownloadDetails(*from._impl_.download_);
    }
    _this->_impl_.download_id_ = from._impl_.download_id_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.DownloadMetadata)
}

inline void DownloadMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.download_) { nullptr },
        decltype(_impl_.download_id_) { 0u } };
}

DownloadMetadata::~DownloadMetadata()
{
    // @@protoc_insertion_point(destructor:safe_browsing.DownloadMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DownloadMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.download_;
}

void DownloadMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DownloadMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.DownloadMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.download_ != nullptr);
        _impl_.download_->Clear();
    }
    _impl_.download_id_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DownloadMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint32 download_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_download_id(&has_bits);
                _impl_.download_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientIncidentReport.DownloadDetails download = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_download(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DownloadMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.DownloadMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 download_id = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_download_id(), target);
    }

    // optional .safe_browsing.ClientIncidentReport.DownloadDetails download = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::download(this), _Internal::download(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.DownloadMetadata)
    return target;
}

size_t DownloadMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.DownloadMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .safe_browsing.ClientIncidentReport.DownloadDetails download = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.download_);
        }

        // optional uint32 download_id = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_download_id());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DownloadMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DownloadMetadata*>(&from));
}

void DownloadMetadata::MergeFrom(const DownloadMetadata& from)
{
    DownloadMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.DownloadMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_download()->::safe_browsing::ClientIncidentReport_DownloadDetails::MergeFrom(from._internal_download());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.download_id_ = from._impl_.download_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DownloadMetadata::CopyFrom(const DownloadMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.DownloadMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DownloadMetadata::IsInitialized() const
{
    if (_internal_has_download()) {
        if (!_impl_.download_->IsInitialized())
            return false;
    }
    return true;
}

void DownloadMetadata::InternalSwap(DownloadMetadata* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(DownloadMetadata, _impl_.download_id_) + sizeof(DownloadMetadata::_impl_.download_id_)
        - PROTOBUF_FIELD_OFFSET(DownloadMetadata, _impl_.download_)>(
        reinterpret_cast<char*>(&_impl_.download_), reinterpret_cast<char*>(&other->_impl_.download_));
}

std::string DownloadMetadata::GetTypeName() const
{
    return "safe_browsing.DownloadMetadata";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_HTTPHeader::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_HTTPHeader>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
    }
};

ClientSafeBrowsingReportRequest_HTTPHeader::ClientSafeBrowsingReportRequest_HTTPHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
}
ClientSafeBrowsingReportRequest_HTTPHeader::ClientSafeBrowsingReportRequest_HTTPHeader(const ClientSafeBrowsingReportRequest_HTTPHeader& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_HTTPHeader* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {},
        decltype(_impl_.value_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_value()) {
        _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
}

inline void ClientSafeBrowsingReportRequest_HTTPHeader::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {}, decltype(_impl_.value_) {} };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_HTTPHeader::~ClientSafeBrowsingReportRequest_HTTPHeader()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_HTTPHeader::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_.Destroy();
    _impl_.value_.Destroy();
}

void ClientSafeBrowsingReportRequest_HTTPHeader::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_HTTPHeader::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.value_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_HTTPHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required bytes name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_HTTPHeader::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required bytes name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_name(), target);
    }

    // optional bytes value = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_value(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
    return target;
}

size_t ClientSafeBrowsingReportRequest_HTTPHeader::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
    size_t total_size = 0;

    // required bytes name = 1;
    if (_internal_has_name()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_name());
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional bytes value = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000002u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_value());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_HTTPHeader::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_HTTPHeader*>(&from));
}

void ClientSafeBrowsingReportRequest_HTTPHeader::MergeFrom(const ClientSafeBrowsingReportRequest_HTTPHeader& from)
{
    ClientSafeBrowsingReportRequest_HTTPHeader* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_value(from._internal_value());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_HTTPHeader::CopyFrom(const ClientSafeBrowsingReportRequest_HTTPHeader& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_HTTPHeader::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    return true;
}

void ClientSafeBrowsingReportRequest_HTTPHeader::InternalSwap(ClientSafeBrowsingReportRequest_HTTPHeader* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena, &other->_impl_.value_, rhs_arena);
}

std::string ClientSafeBrowsingReportRequest_HTTPHeader::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine>()._impl_._has_bits_);
    static void set_has_verb(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_uri(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
}
ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine(
    const ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.verb_) {},
        decltype(_impl_.uri_) {}, decltype(_impl_.version_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.verb_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verb_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_verb()) {
        _this->_impl_.verb_.Set(from._internal_verb(), _this->GetArenaForAllocation());
    }
    _impl_.uri_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uri_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_uri()) {
        _this->_impl_.uri_.Set(from._internal_uri(), _this->GetArenaForAllocation());
    }
    _impl_.version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_version()) {
        _this->_impl_.version_.Set(from._internal_version(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
}

inline void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.verb_) {}, decltype(_impl_.uri_) {},
        decltype(_impl_.version_) {} };
    _impl_.verb_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.verb_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uri_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.uri_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::~ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.verb_.Destroy();
    _impl_.uri_.Destroy();
    _impl_.version_.Destroy();
}

void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.verb_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.uri_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.version_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bytes verb = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_verb();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes uri = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_uri();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes version = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bytes verb = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_verb(), target);
    }

    // optional bytes uri = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_uri(), target);
    }

    // optional bytes version = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_version(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
    return target;
}

size_t ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional bytes verb = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_verb());
        }

        // optional bytes uri = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_uri());
        }

        // optional bytes version = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_version());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine*>(&from));
}

void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::MergeFrom(const ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine& from)
{
    ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_verb(from._internal_verb());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_uri(from._internal_uri());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_version(from._internal_version());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::CopyFrom(const ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::IsInitialized() const
{
    return true;
}

void ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::InternalSwap(ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.verb_, lhs_arena, &other->_impl_.verb_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.uri_, lhs_arena, &other->_impl_.uri_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.version_, lhs_arena, &other->_impl_.version_, rhs_arena);
}

std::string ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_HTTPRequest::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_HTTPRequest>()._impl_._has_bits_);
    static const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine& firstline(const ClientSafeBrowsingReportRequest_HTTPRequest* msg);
    static void set_has_firstline(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_body(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_bodydigest(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_bodylength(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine& ClientSafeBrowsingReportRequest_HTTPRequest::_Internal::firstline(
    const ClientSafeBrowsingReportRequest_HTTPRequest* msg)
{
    return *msg->_impl_.firstline_;
}
ClientSafeBrowsingReportRequest_HTTPRequest::ClientSafeBrowsingReportRequest_HTTPRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
}
ClientSafeBrowsingReportRequest_HTTPRequest::ClientSafeBrowsingReportRequest_HTTPRequest(const ClientSafeBrowsingReportRequest_HTTPRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_HTTPRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.headers_) { from._impl_.headers_ }, decltype(_impl_.body_) {}, decltype(_impl_.bodydigest_) {}, decltype(_impl_.firstline_) { nullptr },
        decltype(_impl_.bodylength_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.body_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_body()) {
        _this->_impl_.body_.Set(from._internal_body(), _this->GetArenaForAllocation());
    }
    _impl_.bodydigest_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bodydigest_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_bodydigest()) {
        _this->_impl_.bodydigest_.Set(from._internal_bodydigest(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_firstline()) {
        _this->_impl_.firstline_ = new ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine(*from._impl_.firstline_);
    }
    _this->_impl_.bodylength_ = from._impl_.bodylength_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
}

inline void ClientSafeBrowsingReportRequest_HTTPRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.headers_) { arena }, decltype(_impl_.body_) {},
        decltype(_impl_.bodydigest_) {}, decltype(_impl_.firstline_) { nullptr }, decltype(_impl_.bodylength_) { 0 } };
    _impl_.body_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bodydigest_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bodydigest_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_HTTPRequest::~ClientSafeBrowsingReportRequest_HTTPRequest()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_HTTPRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.headers_.~RepeatedPtrField();
    _impl_.body_.Destroy();
    _impl_.bodydigest_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.firstline_;
}

void ClientSafeBrowsingReportRequest_HTTPRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_HTTPRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.headers_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.body_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.bodydigest_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.firstline_ != nullptr);
            _impl_.firstline_->Clear();
        }
    }
    _impl_.bodylength_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_HTTPRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine firstline = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_firstline(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader headers = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_headers(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bytes body = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_body();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes bodydigest = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_bodydigest();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 bodylength = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_bodylength(&has_bits);
                _impl_.bodylength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_HTTPRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine firstline = 1;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::firstline(this), _Internal::firstline(this).GetCachedSize(), target, stream);
    }

    // repeated .safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader headers = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_headers_size()); i < n; i++) {
        const auto& repfield = this->_internal_headers(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bytes body = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_body(), target);
    }

    // optional bytes bodydigest = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(4, this->_internal_bodydigest(), target);
    }

    // optional int32 bodylength = 5;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_bodylength(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
    return target;
}

size_t ClientSafeBrowsingReportRequest_HTTPRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader headers = 2;
    total_size += 1UL * this->_internal_headers_size();
    for (const auto& msg : this->_impl_.headers_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional bytes body = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_body());
        }

        // optional bytes bodydigest = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_bodydigest());
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest.FirstLine firstline = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.firstline_);
        }

        // optional int32 bodylength = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bodylength());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_HTTPRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_HTTPRequest*>(&from));
}

void ClientSafeBrowsingReportRequest_HTTPRequest::MergeFrom(const ClientSafeBrowsingReportRequest_HTTPRequest& from)
{
    ClientSafeBrowsingReportRequest_HTTPRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.headers_.MergeFrom(from._impl_.headers_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_body(from._internal_body());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_bodydigest(from._internal_bodydigest());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_firstline()->::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine::MergeFrom(from._internal_firstline());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.bodylength_ = from._impl_.bodylength_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_HTTPRequest::CopyFrom(const ClientSafeBrowsingReportRequest_HTTPRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_HTTPRequest::IsInitialized() const
{
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.headers_))
        return false;
    return true;
}

void ClientSafeBrowsingReportRequest_HTTPRequest::InternalSwap(ClientSafeBrowsingReportRequest_HTTPRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.headers_.InternalSwap(&other->_impl_.headers_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.body_, lhs_arena, &other->_impl_.body_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.bodydigest_, lhs_arena, &other->_impl_.bodydigest_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_HTTPRequest, _impl_.bodylength_)
        + sizeof(ClientSafeBrowsingReportRequest_HTTPRequest::_impl_.bodylength_)
        - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_HTTPRequest, _impl_.firstline_)>(
        reinterpret_cast<char*>(&_impl_.firstline_), reinterpret_cast<char*>(&other->_impl_.firstline_));
}

std::string ClientSafeBrowsingReportRequest_HTTPRequest::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine>()._impl_._has_bits_);
    static void set_has_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_message(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
}
ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine(
    const ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.message_) {},
        decltype(_impl_.version_) {}, decltype(_impl_.code_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_message()) {
        _this->_impl_.message_.Set(from._internal_message(), _this->GetArenaForAllocation());
    }
    _impl_.version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_version()) {
        _this->_impl_.version_.Set(from._internal_version(), _this->GetArenaForAllocation());
    }
    _this->_impl_.code_ = from._impl_.code_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
}

inline void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.message_) {}, decltype(_impl_.version_) {},
        decltype(_impl_.code_) { 0 } };
    _impl_.message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::~ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.message_.Destroy();
    _impl_.version_.Destroy();
}

void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.message_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.version_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.code_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 code = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_code(&has_bits);
                _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes message = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_message();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes version = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 code = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_code(), target);
    }

    // optional bytes message = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_message(), target);
    }

    // optional bytes version = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_version(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
    return target;
}

size_t ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional bytes message = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_message());
        }

        // optional bytes version = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_version());
        }

        // optional int32 code = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine*>(&from));
}

void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::MergeFrom(const ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine& from)
{
    ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_message(from._internal_message());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_version(from._internal_version());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.code_ = from._impl_.code_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::CopyFrom(const ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::IsInitialized() const
{
    return true;
}

void ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::InternalSwap(ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.message_, lhs_arena, &other->_impl_.message_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.version_, lhs_arena, &other->_impl_.version_, rhs_arena);
    swap(_impl_.code_, other->_impl_.code_);
}

std::string ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_HTTPResponse::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_HTTPResponse>()._impl_._has_bits_);
    static const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine& firstline(const ClientSafeBrowsingReportRequest_HTTPResponse* msg);
    static void set_has_firstline(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_body(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_bodydigest(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_bodylength(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_remote_ip(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine& ClientSafeBrowsingReportRequest_HTTPResponse::_Internal::firstline(
    const ClientSafeBrowsingReportRequest_HTTPResponse* msg)
{
    return *msg->_impl_.firstline_;
}
ClientSafeBrowsingReportRequest_HTTPResponse::ClientSafeBrowsingReportRequest_HTTPResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
}
ClientSafeBrowsingReportRequest_HTTPResponse::ClientSafeBrowsingReportRequest_HTTPResponse(const ClientSafeBrowsingReportRequest_HTTPResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_HTTPResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.headers_) { from._impl_.headers_ }, decltype(_impl_.body_) {}, decltype(_impl_.bodydigest_) {}, decltype(_impl_.remote_ip_) {},
        decltype(_impl_.firstline_) { nullptr }, decltype(_impl_.bodylength_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.body_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_body()) {
        _this->_impl_.body_.Set(from._internal_body(), _this->GetArenaForAllocation());
    }
    _impl_.bodydigest_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bodydigest_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_bodydigest()) {
        _this->_impl_.bodydigest_.Set(from._internal_bodydigest(), _this->GetArenaForAllocation());
    }
    _impl_.remote_ip_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_ip_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_remote_ip()) {
        _this->_impl_.remote_ip_.Set(from._internal_remote_ip(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_firstline()) {
        _this->_impl_.firstline_ = new ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine(*from._impl_.firstline_);
    }
    _this->_impl_.bodylength_ = from._impl_.bodylength_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
}

inline void ClientSafeBrowsingReportRequest_HTTPResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.headers_) { arena }, decltype(_impl_.body_) {},
        decltype(_impl_.bodydigest_) {}, decltype(_impl_.remote_ip_) {}, decltype(_impl_.firstline_) { nullptr }, decltype(_impl_.bodylength_) { 0 } };
    _impl_.body_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bodydigest_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bodydigest_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_ip_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_ip_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_HTTPResponse::~ClientSafeBrowsingReportRequest_HTTPResponse()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_HTTPResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.headers_.~RepeatedPtrField();
    _impl_.body_.Destroy();
    _impl_.bodydigest_.Destroy();
    _impl_.remote_ip_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.firstline_;
}

void ClientSafeBrowsingReportRequest_HTTPResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_HTTPResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.headers_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.body_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.bodydigest_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.remote_ip_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.firstline_ != nullptr);
            _impl_.firstline_->Clear();
        }
    }
    _impl_.bodylength_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_HTTPResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine firstline = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_firstline(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader headers = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_headers(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bytes body = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_body();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes bodydigest = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_bodydigest();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 bodylength = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_bodylength(&has_bits);
                _impl_.bodylength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes remote_ip = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_remote_ip();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_HTTPResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine firstline = 1;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::firstline(this), _Internal::firstline(this).GetCachedSize(), target, stream);
    }

    // repeated .safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader headers = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_headers_size()); i < n; i++) {
        const auto& repfield = this->_internal_headers(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bytes body = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_body(), target);
    }

    // optional bytes bodydigest = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(4, this->_internal_bodydigest(), target);
    }

    // optional int32 bodylength = 5;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_bodylength(), target);
    }

    // optional bytes remote_ip = 6;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteBytesMaybeAliased(6, this->_internal_remote_ip(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
    return target;
}

size_t ClientSafeBrowsingReportRequest_HTTPResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientSafeBrowsingReportRequest.HTTPHeader headers = 2;
    total_size += 1UL * this->_internal_headers_size();
    for (const auto& msg : this->_impl_.headers_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional bytes body = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_body());
        }

        // optional bytes bodydigest = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_bodydigest());
        }

        // optional bytes remote_ip = 6;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_remote_ip());
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse.FirstLine firstline = 1;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.firstline_);
        }

        // optional int32 bodylength = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bodylength());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_HTTPResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_HTTPResponse*>(&from));
}

void ClientSafeBrowsingReportRequest_HTTPResponse::MergeFrom(const ClientSafeBrowsingReportRequest_HTTPResponse& from)
{
    ClientSafeBrowsingReportRequest_HTTPResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.headers_.MergeFrom(from._impl_.headers_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_body(from._internal_body());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_bodydigest(from._internal_bodydigest());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_remote_ip(from._internal_remote_ip());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_firstline()->::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine::MergeFrom(
                from._internal_firstline());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.bodylength_ = from._impl_.bodylength_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_HTTPResponse::CopyFrom(const ClientSafeBrowsingReportRequest_HTTPResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_HTTPResponse::IsInitialized() const
{
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.headers_))
        return false;
    return true;
}

void ClientSafeBrowsingReportRequest_HTTPResponse::InternalSwap(ClientSafeBrowsingReportRequest_HTTPResponse* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.headers_.InternalSwap(&other->_impl_.headers_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.body_, lhs_arena, &other->_impl_.body_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.bodydigest_, lhs_arena, &other->_impl_.bodydigest_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.remote_ip_, lhs_arena, &other->_impl_.remote_ip_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_HTTPResponse, _impl_.bodylength_)
        + sizeof(ClientSafeBrowsingReportRequest_HTTPResponse::_impl_.bodylength_)
        - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_HTTPResponse, _impl_.firstline_)>(
        reinterpret_cast<char*>(&_impl_.firstline_), reinterpret_cast<char*>(&other->_impl_.firstline_));
}

std::string ClientSafeBrowsingReportRequest_HTTPResponse::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_Resource::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_Resource>()._impl_._has_bits_);
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest& request(const ClientSafeBrowsingReportRequest_Resource* msg);
    static void set_has_request(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse& response(const ClientSafeBrowsingReportRequest_Resource* msg);
    static void set_has_response(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_parent_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_tag_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000010) ^ 0x00000010) != 0;
    }
};

const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest& ClientSafeBrowsingReportRequest_Resource::_Internal::request(
    const ClientSafeBrowsingReportRequest_Resource* msg)
{
    return *msg->_impl_.request_;
}
const ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse& ClientSafeBrowsingReportRequest_Resource::_Internal::response(
    const ClientSafeBrowsingReportRequest_Resource* msg)
{
    return *msg->_impl_.response_;
}
ClientSafeBrowsingReportRequest_Resource::ClientSafeBrowsingReportRequest_Resource(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
}
ClientSafeBrowsingReportRequest_Resource::ClientSafeBrowsingReportRequest_Resource(const ClientSafeBrowsingReportRequest_Resource& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_Resource* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.child_ids_) { from._impl_.child_ids_ }, decltype(_impl_.url_) {}, decltype(_impl_.tag_name_) {}, decltype(_impl_.request_) { nullptr },
        decltype(_impl_.response_) { nullptr }, decltype(_impl_.id_) {}, decltype(_impl_.parent_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _impl_.tag_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_tag_name()) {
        _this->_impl_.tag_name_.Set(from._internal_tag_name(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_request()) {
        _this->_impl_.request_ = new ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest(*from._impl_.request_);
    }
    if (from._internal_has_response()) {
        _this->_impl_.response_ = new ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse(*from._impl_.response_);
    }
    ::memcpy(&_impl_.id_, &from._impl_.id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.parent_id_) - reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.parent_id_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
}

inline void ClientSafeBrowsingReportRequest_Resource::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.child_ids_) { arena },
        decltype(_impl_.url_) {}, decltype(_impl_.tag_name_) {}, decltype(_impl_.request_) { nullptr }, decltype(_impl_.response_) { nullptr },
        decltype(_impl_.id_) { 0 }, decltype(_impl_.parent_id_) { 0 } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_Resource::~ClientSafeBrowsingReportRequest_Resource()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_Resource::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.child_ids_.~RepeatedField();
    _impl_.url_.Destroy();
    _impl_.tag_name_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.request_;
    if (this != internal_default_instance())
        delete _impl_.response_;
}

void ClientSafeBrowsingReportRequest_Resource::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_Resource::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.child_ids_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.tag_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.request_ != nullptr);
            _impl_.request_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.response_ != nullptr);
            _impl_.response_->Clear();
        }
    }
    if (cached_has_bits & 0x00000030u) {
        ::memset(&_impl_.id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.parent_id_) - reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.parent_id_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_Resource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required int32 id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_id(&has_bits);
                _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string url = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest request = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_request(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse response = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_response(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 parent_id = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_parent_id(&has_bits);
                _impl_.parent_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated int32 child_ids = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_child_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
            } else if (static_cast<uint8_t>(tag) == 50) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_child_ids(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string tag_name = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_tag_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_Resource::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required int32 id = 1;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
    }

    // optional string url = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_url(), target);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest request = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::request(this), _Internal::request(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse response = 4;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::response(this), _Internal::response(this).GetCachedSize(), target, stream);
    }

    // optional int32 parent_id = 5;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_parent_id(), target);
    }

    // repeated int32 child_ids = 6;
    for (int i = 0, n = this->_internal_child_ids_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_child_ids(i), target);
    }

    // optional string tag_name = 7;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_tag_name(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
    return target;
}

size_t ClientSafeBrowsingReportRequest_Resource::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
    size_t total_size = 0;

    // required int32 id = 1;
    if (_internal_has_id()) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 child_ids = 6;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.child_ids_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_child_ids_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string url = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional string tag_name = 7;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_tag_name());
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPRequest request = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.request_);
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HTTPResponse response = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.response_);
        }
    }
    // optional int32 parent_id = 5;
    if (cached_has_bits & 0x00000020u) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_parent_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_Resource::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_Resource*>(&from));
}

void ClientSafeBrowsingReportRequest_Resource::MergeFrom(const ClientSafeBrowsingReportRequest_Resource& from)
{
    ClientSafeBrowsingReportRequest_Resource* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.child_ids_.MergeFrom(from._impl_.child_ids_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_tag_name(from._internal_tag_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_request()->::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest::MergeFrom(from._internal_request());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_response()->::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse::MergeFrom(from._internal_response());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.id_ = from._impl_.id_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.parent_id_ = from._impl_.parent_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_Resource::CopyFrom(const ClientSafeBrowsingReportRequest_Resource& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.Resource)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_Resource::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    if (_internal_has_request()) {
        if (!_impl_.request_->IsInitialized())
            return false;
    }
    if (_internal_has_response()) {
        if (!_impl_.response_->IsInitialized())
            return false;
    }
    return true;
}

void ClientSafeBrowsingReportRequest_Resource::InternalSwap(ClientSafeBrowsingReportRequest_Resource* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.child_ids_.InternalSwap(&other->_impl_.child_ids_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.tag_name_, lhs_arena, &other->_impl_.tag_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_Resource, _impl_.parent_id_)
        + sizeof(ClientSafeBrowsingReportRequest_Resource::_impl_.parent_id_)
        - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_Resource, _impl_.request_)>(
        reinterpret_cast<char*>(&_impl_.request_), reinterpret_cast<char*>(&other->_impl_.request_));
}

std::string ClientSafeBrowsingReportRequest_Resource::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.Resource";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties>()._impl_._has_bits_);
    static void set_has_client_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_google_play_services_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_is_instant_apps(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_url_api_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_is_async_check(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_app_verification_enabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
};

ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
}
ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties(
    const ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.client_version_) {},
        decltype(_impl_.google_play_services_version_) {}, decltype(_impl_.url_api_type_) {}, decltype(_impl_.is_instant_apps_) {},
        decltype(_impl_.is_async_check_) {}, decltype(_impl_.app_verification_enabled_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.client_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_client_version()) {
        _this->_impl_.client_version_.Set(from._internal_client_version(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.google_play_services_version_, &from._impl_.google_play_services_version_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.app_verification_enabled_) - reinterpret_cast<char*>(&_impl_.google_play_services_version_))
            + sizeof(_impl_.app_verification_enabled_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
}

inline void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.client_version_) {},
        decltype(_impl_.google_play_services_version_) { int64_t { 0 } }, decltype(_impl_.url_api_type_) { 0 }, decltype(_impl_.is_instant_apps_) { false },
        decltype(_impl_.is_async_check_) { false }, decltype(_impl_.app_verification_enabled_) { false } };
    _impl_.client_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::~ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.client_version_.Destroy();
}

void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.client_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x0000003eu) {
        ::memset(&_impl_.google_play_services_version_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.app_verification_enabled_) - reinterpret_cast<char*>(&_impl_.google_play_services_version_))
                + sizeof(_impl_.app_verification_enabled_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string client_version = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_client_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 google_play_services_version = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_google_play_services_version(&has_bits);
                _impl_.google_play_services_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_instant_apps = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_is_instant_apps(&has_bits);
                _impl_.is_instant_apps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingUrlApiType url_api_type = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType_IsValid(val))) {
                    _internal_set_url_api_type(static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingUrlApiType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional bool is_async_check = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_is_async_check(&has_bits);
                _impl_.is_async_check_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool app_verification_enabled = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_app_verification_enabled(&has_bits);
                _impl_.app_verification_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string client_version = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_client_version(), target);
    }

    // optional int64 google_play_services_version = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_google_play_services_version(), target);
    }

    // optional bool is_instant_apps = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_instant_apps(), target);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingUrlApiType url_api_type = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_url_api_type(), target);
    }

    // optional bool is_async_check = 7;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_is_async_check(), target);
    }

    // optional bool app_verification_enabled = 8;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_app_verification_enabled(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
    return target;
}

size_t ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional string client_version = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_client_version());
        }

        // optional int64 google_play_services_version = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_google_play_services_version());
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingUrlApiType url_api_type = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_url_api_type());
        }

        // optional bool is_instant_apps = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }

        // optional bool is_async_check = 7;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }

        // optional bool app_verification_enabled = 8;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties*>(&from));
}

void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::MergeFrom(const ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties& from)
{
    ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_client_version(from._internal_client_version());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.google_play_services_version_ = from._impl_.google_play_services_version_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.url_api_type_ = from._impl_.url_api_type_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.is_instant_apps_ = from._impl_.is_instant_apps_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.is_async_check_ = from._impl_.is_async_check_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.app_verification_enabled_ = from._impl_.app_verification_enabled_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::CopyFrom(const ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::IsInitialized() const
{
    return true;
}

void ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::InternalSwap(ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.client_version_, lhs_arena, &other->_impl_.client_version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(
                                                   ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties, _impl_.app_verification_enabled_)
        + sizeof(ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::_impl_.app_verification_enabled_)
        - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties, _impl_.google_play_services_version_)>(
        reinterpret_cast<char*>(&_impl_.google_play_services_version_), reinterpret_cast<char*>(&other->_impl_.google_play_services_version_));
}

std::string ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests>()._impl_._has_bits_);
    static void set_has_sha256(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo.Digests)
}
ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests(
    const ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.sha256_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.sha256_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sha256()) {
        _this->_impl_.sha256_.Set(from._internal_sha256(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo.Digests)
}

inline void ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.sha256_) {} };
    _impl_.sha256_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::~ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo.Digests)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.sha256_.Destroy();
}

void ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo.Digests)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.sha256_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bytes sha256 = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_sha256();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo.Digests)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bytes sha256 = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_sha256(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo.Digests)
    return target;
}

size_t ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo.Digests)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional bytes sha256 = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_sha256());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests*>(&from));
}

void ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::MergeFrom(const ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests& from)
{
    ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo.Digests)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_sha256()) {
        _this->_internal_set_sha256(from._internal_sha256());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::CopyFrom(const ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo.Digests)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::IsInitialized() const
{
    return true;
}

void ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::InternalSwap(ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.sha256_, lhs_arena, &other->_impl_.sha256_, rhs_arena);
}

std::string ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo.Digests";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_DownloadItemInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_DownloadItemInfo>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::safe_browsing::ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests& digests(
        const ClientSafeBrowsingReportRequest_DownloadItemInfo* msg);
    static void set_has_digests(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_file_basename(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::safe_browsing::ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests& ClientSafeBrowsingReportRequest_DownloadItemInfo::_Internal::digests(
    const ClientSafeBrowsingReportRequest_DownloadItemInfo* msg)
{
    return *msg->_impl_.digests_;
}
ClientSafeBrowsingReportRequest_DownloadItemInfo::ClientSafeBrowsingReportRequest_DownloadItemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo)
}
ClientSafeBrowsingReportRequest_DownloadItemInfo::ClientSafeBrowsingReportRequest_DownloadItemInfo(const ClientSafeBrowsingReportRequest_DownloadItemInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_DownloadItemInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {},
        decltype(_impl_.file_basename_) {}, decltype(_impl_.digests_) { nullptr }, decltype(_impl_.length_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _impl_.file_basename_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_basename_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_file_basename()) {
        _this->_impl_.file_basename_.Set(from._internal_file_basename(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_digests()) {
        _this->_impl_.digests_ = new ::safe_browsing::ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests(*from._impl_.digests_);
    }
    _this->_impl_.length_ = from._impl_.length_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo)
}

inline void ClientSafeBrowsingReportRequest_DownloadItemInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {}, decltype(_impl_.file_basename_) {},
        decltype(_impl_.digests_) { nullptr }, decltype(_impl_.length_) { int64_t { 0 } } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_basename_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.file_basename_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_DownloadItemInfo::~ClientSafeBrowsingReportRequest_DownloadItemInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_DownloadItemInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
    _impl_.file_basename_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.digests_;
}

void ClientSafeBrowsingReportRequest_DownloadItemInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_DownloadItemInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.file_basename_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.digests_ != nullptr);
            _impl_.digests_->Clear();
        }
    }
    _impl_.length_ = int64_t { 0 };
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_DownloadItemInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo.Digests digests = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_digests(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 length = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_length(&has_bits);
                _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string file_basename = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_file_basename();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_DownloadItemInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo.Digests digests = 2;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::digests(this), _Internal::digests(this).GetCachedSize(), target, stream);
    }

    // optional int64 length = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_length(), target);
    }

    // optional string file_basename = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_file_basename(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo)
    return target;
}

size_t ClientSafeBrowsingReportRequest_DownloadItemInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional string file_basename = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_file_basename());
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo.Digests digests = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.digests_);
        }

        // optional int64 length = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_length());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_DownloadItemInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_DownloadItemInfo*>(&from));
}

void ClientSafeBrowsingReportRequest_DownloadItemInfo::MergeFrom(const ClientSafeBrowsingReportRequest_DownloadItemInfo& from)
{
    ClientSafeBrowsingReportRequest_DownloadItemInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_file_basename(from._internal_file_basename());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_digests()->::safe_browsing::ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests::MergeFrom(from._internal_digests());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.length_ = from._impl_.length_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_DownloadItemInfo::CopyFrom(const ClientSafeBrowsingReportRequest_DownloadItemInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_DownloadItemInfo::IsInitialized() const
{
    return true;
}

void ClientSafeBrowsingReportRequest_DownloadItemInfo::InternalSwap(ClientSafeBrowsingReportRequest_DownloadItemInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.file_basename_, lhs_arena, &other->_impl_.file_basename_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_DownloadItemInfo, _impl_.length_)
        + sizeof(ClientSafeBrowsingReportRequest_DownloadItemInfo::_impl_.length_)
        - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_DownloadItemInfo, _impl_.digests_)>(
        reinterpret_cast<char*>(&_impl_.digests_), reinterpret_cast<char*>(&other->_impl_.digests_));
}

std::string ClientSafeBrowsingReportRequest_DownloadItemInfo::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_DownloadWarningAction::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_DownloadWarningAction>()._impl_._has_bits_);
    static void set_has_surface(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_action(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_is_terminal_action(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_interval_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

ClientSafeBrowsingReportRequest_DownloadWarningAction::ClientSafeBrowsingReportRequest_DownloadWarningAction(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction)
}
ClientSafeBrowsingReportRequest_DownloadWarningAction::ClientSafeBrowsingReportRequest_DownloadWarningAction(
    const ClientSafeBrowsingReportRequest_DownloadWarningAction& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_DownloadWarningAction* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.surface_) {},
        decltype(_impl_.action_) {}, decltype(_impl_.interval_msec_) {}, decltype(_impl_.is_terminal_action_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.surface_, &from._impl_.surface_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_terminal_action_) - reinterpret_cast<char*>(&_impl_.surface_))
            + sizeof(_impl_.is_terminal_action_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction)
}

inline void ClientSafeBrowsingReportRequest_DownloadWarningAction::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.surface_) { 0 },
        decltype(_impl_.action_) { 0 }, decltype(_impl_.interval_msec_) { int64_t { 0 } }, decltype(_impl_.is_terminal_action_) { false } };
}

ClientSafeBrowsingReportRequest_DownloadWarningAction::~ClientSafeBrowsingReportRequest_DownloadWarningAction()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_DownloadWarningAction::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientSafeBrowsingReportRequest_DownloadWarningAction::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_DownloadWarningAction::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        ::memset(&_impl_.surface_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_terminal_action_) - reinterpret_cast<char*>(&_impl_.surface_))
                + sizeof(_impl_.is_terminal_action_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_DownloadWarningAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction.Surface surface = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface_IsValid(val))) {
                    _internal_set_surface(static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_DownloadWarningAction_Surface>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction.Action action = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientSafeBrowsingReportRequest_DownloadWarningAction_Action_IsValid(val))) {
                    _internal_set_action(static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_DownloadWarningAction_Action>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional bool is_terminal_action = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_is_terminal_action(&has_bits);
                _impl_.is_terminal_action_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 interval_msec = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_interval_msec(&has_bits);
                _impl_.interval_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_DownloadWarningAction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction.Surface surface = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_surface(), target);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction.Action action = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_action(), target);
    }

    // optional bool is_terminal_action = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_terminal_action(), target);
    }

    // optional int64 interval_msec = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_interval_msec(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction)
    return target;
}

size_t ClientSafeBrowsingReportRequest_DownloadWarningAction::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction.Surface surface = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_surface());
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction.Action action = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
        }

        // optional int64 interval_msec = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_interval_msec());
        }

        // optional bool is_terminal_action = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_DownloadWarningAction::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_DownloadWarningAction*>(&from));
}

void ClientSafeBrowsingReportRequest_DownloadWarningAction::MergeFrom(const ClientSafeBrowsingReportRequest_DownloadWarningAction& from)
{
    ClientSafeBrowsingReportRequest_DownloadWarningAction* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.surface_ = from._impl_.surface_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.action_ = from._impl_.action_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.interval_msec_ = from._impl_.interval_msec_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.is_terminal_action_ = from._impl_.is_terminal_action_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_DownloadWarningAction::CopyFrom(const ClientSafeBrowsingReportRequest_DownloadWarningAction& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_DownloadWarningAction::IsInitialized() const
{
    return true;
}

void ClientSafeBrowsingReportRequest_DownloadWarningAction::InternalSwap(ClientSafeBrowsingReportRequest_DownloadWarningAction* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_DownloadWarningAction, _impl_.is_terminal_action_)
        + sizeof(ClientSafeBrowsingReportRequest_DownloadWarningAction::_impl_.is_terminal_action_)
        - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_DownloadWarningAction, _impl_.surface_)>(
        reinterpret_cast<char*>(&_impl_.surface_), reinterpret_cast<char*>(&other->_impl_.surface_));
}

std::string ClientSafeBrowsingReportRequest_DownloadWarningAction::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails>()._impl_._has_bits_);
    static void set_has_threat_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_matched_global_cache(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_locally_cached_results_threat_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails)
}
ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails(
    const ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.threat_type_) {},
        decltype(_impl_.matched_global_cache_) {}, decltype(_impl_.locally_cached_results_threat_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.threat_type_, &from._impl_.threat_type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.locally_cached_results_threat_type_) - reinterpret_cast<char*>(&_impl_.threat_type_))
            + sizeof(_impl_.locally_cached_results_threat_type_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails)
}

inline void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.threat_type_) { 0 },
        decltype(_impl_.matched_global_cache_) { false }, decltype(_impl_.locally_cached_results_threat_type_) { 0 } };
}

ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::~ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        ::memset(&_impl_.threat_type_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.locally_cached_results_threat_type_) - reinterpret_cast<char*>(&_impl_.threat_type_))
                + sizeof(_impl_.locally_cached_results_threat_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.ExperimentThreatType threat_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_IsValid(val))) {
                    _internal_set_threat_type(
                        static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional bool matched_global_cache = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_matched_global_cache(&has_bits);
                _impl_.matched_global_cache_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.ExperimentThreatType locally_cached_results_threat_type = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_IsValid(val))) {
                    _internal_set_locally_cached_results_threat_type(
                        static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.ExperimentThreatType threat_type = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_threat_type(), target);
    }

    // optional bool matched_global_cache = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_matched_global_cache(), target);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.ExperimentThreatType locally_cached_results_threat_type = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_locally_cached_results_threat_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails)
    return target;
}

size_t ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.ExperimentThreatType threat_type = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_type());
        }

        // optional bool matched_global_cache = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.ExperimentThreatType locally_cached_results_threat_type = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_locally_cached_results_threat_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails*>(&from));
}

void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::MergeFrom(
    const ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails& from)
{
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.threat_type_ = from._impl_.threat_type_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.matched_global_cache_ = from._impl_.matched_global_cache_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.locally_cached_results_threat_type_ = from._impl_.locally_cached_results_threat_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::CopyFrom(
    const ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::IsInitialized() const
{
    return true;
}

void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::InternalSwap(
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails,
                                                   _impl_.locally_cached_results_threat_type_)
        + sizeof(ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::_impl_.locally_cached_results_threat_type_)
        - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails, _impl_.threat_type_)>(
        reinterpret_cast<char*>(&_impl_.threat_type_), reinterpret_cast<char*>(&other->_impl_.threat_type_));
}

std::string ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails>()._impl_._has_bits_);
    static void set_has_hash_database_threat_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails& url_realtime_details(
        const ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails* msg);
    static void set_has_url_realtime_details(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails& hash_realtime_details(
        const ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails* msg);
    static void set_has_hash_realtime_details(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails&
ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::_Internal::url_realtime_details(
    const ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails* msg)
{
    return *msg->_impl_.url_realtime_details_;
}
const ::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails&
ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::_Internal::hash_realtime_details(
    const ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails* msg)
{
    return *msg->_impl_.hash_realtime_details_;
}
ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails)
}
ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails(
    const ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.url_realtime_details_) { nullptr }, decltype(_impl_.hash_realtime_details_) { nullptr },
        decltype(_impl_.hash_database_threat_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_url_realtime_details()) {
        _this->_impl_.url_realtime_details_
            = new ::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails(*from._impl_.url_realtime_details_);
    }
    if (from._internal_has_hash_realtime_details()) {
        _this->_impl_.hash_realtime_details_
            = new ::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails(*from._impl_.hash_realtime_details_);
    }
    _this->_impl_.hash_database_threat_type_ = from._impl_.hash_database_threat_type_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails)
}

inline void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_realtime_details_) { nullptr },
        decltype(_impl_.hash_realtime_details_) { nullptr }, decltype(_impl_.hash_database_threat_type_) { 0 } };
}

ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::~ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.url_realtime_details_;
    if (this != internal_default_instance())
        delete _impl_.hash_realtime_details_;
}

void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.url_realtime_details_ != nullptr);
            _impl_.url_realtime_details_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.hash_realtime_details_ != nullptr);
            _impl_.hash_realtime_details_->Clear();
        }
    }
    _impl_.hash_database_threat_type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.ExperimentThreatType hash_database_threat_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType_IsValid(val))) {
                    _internal_set_hash_database_threat_type(
                        static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_ExperimentThreatType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails url_realtime_details = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_url_realtime_details(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails hash_realtime_details = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_hash_realtime_details(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.ExperimentThreatType hash_database_threat_type = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_hash_database_threat_type(), target);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails url_realtime_details = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::url_realtime_details(this), _Internal::url_realtime_details(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails hash_realtime_details = 3;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::hash_realtime_details(this), _Internal::hash_realtime_details(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails)
    return target;
}

size_t ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails url_realtime_details = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.url_realtime_details_);
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.RealTimeDetails hash_realtime_details = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.hash_realtime_details_);
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails.ExperimentThreatType hash_database_threat_type = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_hash_database_threat_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails*>(&from));
}

void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::MergeFrom(const ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails& from)
{
    ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_url_realtime_details()
                ->::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::MergeFrom(
                    from._internal_url_realtime_details());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_hash_realtime_details()
                ->::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails::MergeFrom(
                    from._internal_hash_realtime_details());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.hash_database_threat_type_ = from._impl_.hash_database_threat_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::CopyFrom(const ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::IsInitialized() const
{
    return true;
}

void ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::InternalSwap(ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(
                                                   ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails, _impl_.hash_database_threat_type_)
        + sizeof(ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::_impl_.hash_database_threat_type_)
        - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails, _impl_.url_realtime_details_)>(
        reinterpret_cast<char*>(&_impl_.url_realtime_details_), reinterpret_cast<char*>(&other->_impl_.url_realtime_details_));
}

std::string ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_InterstitialInteraction::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_InterstitialInteraction>()._impl_._has_bits_);
    static void set_has_security_interstitial_interaction(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_occurrence_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_first_interaction_timestamp_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_last_interaction_timestamp_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

ClientSafeBrowsingReportRequest_InterstitialInteraction::ClientSafeBrowsingReportRequest_InterstitialInteraction(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction)
}
ClientSafeBrowsingReportRequest_InterstitialInteraction::ClientSafeBrowsingReportRequest_InterstitialInteraction(
    const ClientSafeBrowsingReportRequest_InterstitialInteraction& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_InterstitialInteraction* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.security_interstitial_interaction_) {}, decltype(_impl_.occurrence_count_) {}, decltype(_impl_.first_interaction_timestamp_msec_) {},
        decltype(_impl_.last_interaction_timestamp_msec_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.security_interstitial_interaction_, &from._impl_.security_interstitial_interaction_,
        static_cast<size_t>(
            reinterpret_cast<char*>(&_impl_.last_interaction_timestamp_msec_) - reinterpret_cast<char*>(&_impl_.security_interstitial_interaction_))
            + sizeof(_impl_.last_interaction_timestamp_msec_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction)
}

inline void ClientSafeBrowsingReportRequest_InterstitialInteraction::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.security_interstitial_interaction_) { 0 },
        decltype(_impl_.occurrence_count_) { 0 }, decltype(_impl_.first_interaction_timestamp_msec_) { int64_t { 0 } },
        decltype(_impl_.last_interaction_timestamp_msec_) { int64_t { 0 } } };
}

ClientSafeBrowsingReportRequest_InterstitialInteraction::~ClientSafeBrowsingReportRequest_InterstitialInteraction()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_InterstitialInteraction::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientSafeBrowsingReportRequest_InterstitialInteraction::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_InterstitialInteraction::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        ::memset(&_impl_.security_interstitial_interaction_, 0,
            static_cast<size_t>(
                reinterpret_cast<char*>(&_impl_.last_interaction_timestamp_msec_) - reinterpret_cast<char*>(&_impl_.security_interstitial_interaction_))
                + sizeof(_impl_.last_interaction_timestamp_msec_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_InterstitialInteraction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction.SecurityInterstitialInteraction security_interstitial_interaction = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(
                        ::safe_browsing::ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction_IsValid(val))) {
                    _internal_set_security_interstitial_interaction(
                        static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_InterstitialInteraction_SecurityInterstitialInteraction>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int32 occurrence_count = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_occurrence_count(&has_bits);
                _impl_.occurrence_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 first_interaction_timestamp_msec = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_first_interaction_timestamp_msec(&has_bits);
                _impl_.first_interaction_timestamp_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 last_interaction_timestamp_msec = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_last_interaction_timestamp_msec(&has_bits);
                _impl_.last_interaction_timestamp_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_InterstitialInteraction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction.SecurityInterstitialInteraction security_interstitial_interaction = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_security_interstitial_interaction(), target);
    }

    // optional int32 occurrence_count = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_occurrence_count(), target);
    }

    // optional int64 first_interaction_timestamp_msec = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_first_interaction_timestamp_msec(), target);
    }

    // optional int64 last_interaction_timestamp_msec = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_last_interaction_timestamp_msec(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction)
    return target;
}

size_t ClientSafeBrowsingReportRequest_InterstitialInteraction::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction.SecurityInterstitialInteraction security_interstitial_interaction = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_security_interstitial_interaction());
        }

        // optional int32 occurrence_count = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_occurrence_count());
        }

        // optional int64 first_interaction_timestamp_msec = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_first_interaction_timestamp_msec());
        }

        // optional int64 last_interaction_timestamp_msec = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_interaction_timestamp_msec());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_InterstitialInteraction::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_InterstitialInteraction*>(&from));
}

void ClientSafeBrowsingReportRequest_InterstitialInteraction::MergeFrom(const ClientSafeBrowsingReportRequest_InterstitialInteraction& from)
{
    ClientSafeBrowsingReportRequest_InterstitialInteraction* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.security_interstitial_interaction_ = from._impl_.security_interstitial_interaction_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.occurrence_count_ = from._impl_.occurrence_count_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.first_interaction_timestamp_msec_ = from._impl_.first_interaction_timestamp_msec_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.last_interaction_timestamp_msec_ = from._impl_.last_interaction_timestamp_msec_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_InterstitialInteraction::CopyFrom(const ClientSafeBrowsingReportRequest_InterstitialInteraction& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_InterstitialInteraction::IsInitialized() const
{
    return true;
}

void ClientSafeBrowsingReportRequest_InterstitialInteraction::InternalSwap(ClientSafeBrowsingReportRequest_InterstitialInteraction* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(
                                                   ClientSafeBrowsingReportRequest_InterstitialInteraction, _impl_.last_interaction_timestamp_msec_)
        + sizeof(ClientSafeBrowsingReportRequest_InterstitialInteraction::_impl_.last_interaction_timestamp_msec_)
        - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_InterstitialInteraction, _impl_.security_interstitial_interaction_)>(
        reinterpret_cast<char*>(&_impl_.security_interstitial_interaction_), reinterpret_cast<char*>(&other->_impl_.security_interstitial_interaction_));
}

std::string ClientSafeBrowsingReportRequest_InterstitialInteraction::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_PhishySiteInteraction::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_PhishySiteInteraction>()._impl_._has_bits_);
    static void set_has_phishy_site_interaction_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_occurrence_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_first_interaction_timestamp_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_last_interaction_timestamp_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

ClientSafeBrowsingReportRequest_PhishySiteInteraction::ClientSafeBrowsingReportRequest_PhishySiteInteraction(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction)
}
ClientSafeBrowsingReportRequest_PhishySiteInteraction::ClientSafeBrowsingReportRequest_PhishySiteInteraction(
    const ClientSafeBrowsingReportRequest_PhishySiteInteraction& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_PhishySiteInteraction* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.phishy_site_interaction_type_) {}, decltype(_impl_.occurrence_count_) {}, decltype(_impl_.first_interaction_timestamp_msec_) {},
        decltype(_impl_.last_interaction_timestamp_msec_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.phishy_site_interaction_type_, &from._impl_.phishy_site_interaction_type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_interaction_timestamp_msec_) - reinterpret_cast<char*>(&_impl_.phishy_site_interaction_type_))
            + sizeof(_impl_.last_interaction_timestamp_msec_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction)
}

inline void ClientSafeBrowsingReportRequest_PhishySiteInteraction::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.phishy_site_interaction_type_) { 0 },
        decltype(_impl_.occurrence_count_) { 0 }, decltype(_impl_.first_interaction_timestamp_msec_) { int64_t { 0 } },
        decltype(_impl_.last_interaction_timestamp_msec_) { int64_t { 0 } } };
}

ClientSafeBrowsingReportRequest_PhishySiteInteraction::~ClientSafeBrowsingReportRequest_PhishySiteInteraction()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_PhishySiteInteraction::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientSafeBrowsingReportRequest_PhishySiteInteraction::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_PhishySiteInteraction::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        ::memset(&_impl_.phishy_site_interaction_type_, 0,
            static_cast<size_t>(
                reinterpret_cast<char*>(&_impl_.last_interaction_timestamp_msec_) - reinterpret_cast<char*>(&_impl_.phishy_site_interaction_type_))
                + sizeof(_impl_.last_interaction_timestamp_msec_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_PhishySiteInteraction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction.PhishySiteInteractionType phishy_site_interaction_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType_IsValid(val))) {
                    _internal_set_phishy_site_interaction_type(
                        static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_PhishySiteInteraction_PhishySiteInteractionType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int32 occurrence_count = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_occurrence_count(&has_bits);
                _impl_.occurrence_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 first_interaction_timestamp_msec = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_first_interaction_timestamp_msec(&has_bits);
                _impl_.first_interaction_timestamp_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 last_interaction_timestamp_msec = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_last_interaction_timestamp_msec(&has_bits);
                _impl_.last_interaction_timestamp_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_PhishySiteInteraction::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction.PhishySiteInteractionType phishy_site_interaction_type = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_phishy_site_interaction_type(), target);
    }

    // optional int32 occurrence_count = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_occurrence_count(), target);
    }

    // optional int64 first_interaction_timestamp_msec = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_first_interaction_timestamp_msec(), target);
    }

    // optional int64 last_interaction_timestamp_msec = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_last_interaction_timestamp_msec(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction)
    return target;
}

size_t ClientSafeBrowsingReportRequest_PhishySiteInteraction::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction.PhishySiteInteractionType phishy_site_interaction_type = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_phishy_site_interaction_type());
        }

        // optional int32 occurrence_count = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_occurrence_count());
        }

        // optional int64 first_interaction_timestamp_msec = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_first_interaction_timestamp_msec());
        }

        // optional int64 last_interaction_timestamp_msec = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_interaction_timestamp_msec());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_PhishySiteInteraction::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_PhishySiteInteraction*>(&from));
}

void ClientSafeBrowsingReportRequest_PhishySiteInteraction::MergeFrom(const ClientSafeBrowsingReportRequest_PhishySiteInteraction& from)
{
    ClientSafeBrowsingReportRequest_PhishySiteInteraction* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.phishy_site_interaction_type_ = from._impl_.phishy_site_interaction_type_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.occurrence_count_ = from._impl_.occurrence_count_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.first_interaction_timestamp_msec_ = from._impl_.first_interaction_timestamp_msec_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.last_interaction_timestamp_msec_ = from._impl_.last_interaction_timestamp_msec_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_PhishySiteInteraction::CopyFrom(const ClientSafeBrowsingReportRequest_PhishySiteInteraction& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_PhishySiteInteraction::IsInitialized() const
{
    return true;
}

void ClientSafeBrowsingReportRequest_PhishySiteInteraction::InternalSwap(ClientSafeBrowsingReportRequest_PhishySiteInteraction* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(
                                                   ClientSafeBrowsingReportRequest_PhishySiteInteraction, _impl_.last_interaction_timestamp_msec_)
        + sizeof(ClientSafeBrowsingReportRequest_PhishySiteInteraction::_impl_.last_interaction_timestamp_msec_)
        - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_PhishySiteInteraction, _impl_.phishy_site_interaction_type_)>(
        reinterpret_cast<char*>(&_impl_.phishy_site_interaction_type_), reinterpret_cast<char*>(&other->_impl_.phishy_site_interaction_type_));
}

std::string ClientSafeBrowsingReportRequest_PhishySiteInteraction::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_WarningShownInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_WarningShownInfo>()._impl_._has_bits_);
    static void set_has_warning_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_post_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ClientSafeBrowsingReportRequest_WarningShownInfo::ClientSafeBrowsingReportRequest_WarningShownInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo)
}
ClientSafeBrowsingReportRequest_WarningShownInfo::ClientSafeBrowsingReportRequest_WarningShownInfo(const ClientSafeBrowsingReportRequest_WarningShownInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_WarningShownInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.post_data_) {},
        decltype(_impl_.warning_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.post_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.post_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_post_data()) {
        _this->_impl_.post_data_.Set(from._internal_post_data(), _this->GetArenaForAllocation());
    }
    _this->_impl_.warning_type_ = from._impl_.warning_type_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo)
}

inline void ClientSafeBrowsingReportRequest_WarningShownInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.post_data_) {}, decltype(_impl_.warning_type_) { 0 } };
    _impl_.post_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.post_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_WarningShownInfo::~ClientSafeBrowsingReportRequest_WarningShownInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_WarningShownInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.post_data_.Destroy();
}

void ClientSafeBrowsingReportRequest_WarningShownInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_WarningShownInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.post_data_.ClearNonDefaultToEmpty();
    }
    _impl_.warning_type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_WarningShownInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo.WarningUXType warning_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType_IsValid(val))) {
                    _internal_set_warning_type(static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_WarningShownInfo_WarningUXType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string post_data = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_post_data();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_WarningShownInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo.WarningUXType warning_type = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_warning_type(), target);
    }

    // optional string post_data = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_post_data(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo)
    return target;
}

size_t ClientSafeBrowsingReportRequest_WarningShownInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string post_data = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_post_data());
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo.WarningUXType warning_type = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_warning_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_WarningShownInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_WarningShownInfo*>(&from));
}

void ClientSafeBrowsingReportRequest_WarningShownInfo::MergeFrom(const ClientSafeBrowsingReportRequest_WarningShownInfo& from)
{
    ClientSafeBrowsingReportRequest_WarningShownInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_post_data(from._internal_post_data());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.warning_type_ = from._impl_.warning_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_WarningShownInfo::CopyFrom(const ClientSafeBrowsingReportRequest_WarningShownInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_WarningShownInfo::IsInitialized() const
{
    return true;
}

void ClientSafeBrowsingReportRequest_WarningShownInfo::InternalSwap(ClientSafeBrowsingReportRequest_WarningShownInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.post_data_, lhs_arena, &other->_impl_.post_data_, rhs_arena);
    swap(_impl_.warning_type_, other->_impl_.warning_type_);
}

std::string ClientSafeBrowsingReportRequest_WarningShownInfo::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_PermissionPromptInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_PermissionPromptInfo>()._impl_._has_bits_);
    static void set_has_origin(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_display_duration_sec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ClientSafeBrowsingReportRequest_PermissionPromptInfo::ClientSafeBrowsingReportRequest_PermissionPromptInfo(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.PermissionPromptInfo)
}
ClientSafeBrowsingReportRequest_PermissionPromptInfo::ClientSafeBrowsingReportRequest_PermissionPromptInfo(
    const ClientSafeBrowsingReportRequest_PermissionPromptInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_PermissionPromptInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.origin_) {},
        decltype(_impl_.display_duration_sec_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.origin_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_origin()) {
        _this->_impl_.origin_.Set(from._internal_origin(), _this->GetArenaForAllocation());
    }
    _this->_impl_.display_duration_sec_ = from._impl_.display_duration_sec_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.PermissionPromptInfo)
}

inline void ClientSafeBrowsingReportRequest_PermissionPromptInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.origin_) {},
        decltype(_impl_.display_duration_sec_) { int64_t { 0 } } };
    _impl_.origin_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest_PermissionPromptInfo::~ClientSafeBrowsingReportRequest_PermissionPromptInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.PermissionPromptInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_PermissionPromptInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.origin_.Destroy();
}

void ClientSafeBrowsingReportRequest_PermissionPromptInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_PermissionPromptInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.PermissionPromptInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.origin_.ClearNonDefaultToEmpty();
    }
    _impl_.display_duration_sec_ = int64_t { 0 };
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_PermissionPromptInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string origin = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_origin();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 display_duration_sec = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_display_duration_sec(&has_bits);
                _impl_.display_duration_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_PermissionPromptInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.PermissionPromptInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string origin = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_origin(), target);
    }

    // optional int64 display_duration_sec = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_display_duration_sec(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.PermissionPromptInfo)
    return target;
}

size_t ClientSafeBrowsingReportRequest_PermissionPromptInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.PermissionPromptInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string origin = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_origin());
        }

        // optional int64 display_duration_sec = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_display_duration_sec());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_PermissionPromptInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_PermissionPromptInfo*>(&from));
}

void ClientSafeBrowsingReportRequest_PermissionPromptInfo::MergeFrom(const ClientSafeBrowsingReportRequest_PermissionPromptInfo& from)
{
    ClientSafeBrowsingReportRequest_PermissionPromptInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.PermissionPromptInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_origin(from._internal_origin());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.display_duration_sec_ = from._impl_.display_duration_sec_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_PermissionPromptInfo::CopyFrom(const ClientSafeBrowsingReportRequest_PermissionPromptInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.PermissionPromptInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_PermissionPromptInfo::IsInitialized() const
{
    return true;
}

void ClientSafeBrowsingReportRequest_PermissionPromptInfo::InternalSwap(ClientSafeBrowsingReportRequest_PermissionPromptInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.origin_, lhs_arena, &other->_impl_.origin_, rhs_arena);
    swap(_impl_.display_duration_sec_, other->_impl_.display_duration_sec_);
}

std::string ClientSafeBrowsingReportRequest_PermissionPromptInfo::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.PermissionPromptInfo";
}

// ===================================================================

class ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo>()._impl_._has_bits_);
    static void set_has_hash_realtime_threat_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_url_realtime_threat_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo)
}
ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo(
    const ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.hash_realtime_threat_type_) {}, decltype(_impl_.url_realtime_threat_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.hash_realtime_threat_type_, &from._impl_.hash_realtime_threat_type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.url_realtime_threat_type_) - reinterpret_cast<char*>(&_impl_.hash_realtime_threat_type_))
            + sizeof(_impl_.url_realtime_threat_type_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo)
}

inline void ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.hash_realtime_threat_type_) { 0 },
        decltype(_impl_.url_realtime_threat_type_) { 0 } };
}

ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::~ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.hash_realtime_threat_type_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.url_realtime_threat_type_) - reinterpret_cast<char*>(&_impl_.hash_realtime_threat_type_))
                + sizeof(_impl_.url_realtime_threat_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo.LookupThreatType hash_realtime_threat_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(
                        ::safe_browsing::ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_IsValid(val))) {
                    _internal_set_hash_realtime_threat_type(
                        static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo.LookupThreatType url_realtime_threat_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(
                        ::safe_browsing::ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType_IsValid(val))) {
                    _internal_set_url_realtime_threat_type(
                        static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo_LookupThreatType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo.LookupThreatType hash_realtime_threat_type = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_hash_realtime_threat_type(), target);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo.LookupThreatType url_realtime_threat_type = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_url_realtime_threat_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo)
    return target;
}

size_t ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo.LookupThreatType hash_realtime_threat_type = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_hash_realtime_threat_type());
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo.LookupThreatType url_realtime_threat_type = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_url_realtime_threat_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo*>(&from));
}

void ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::MergeFrom(
    const ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo& from)
{
    ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.hash_realtime_threat_type_ = from._impl_.hash_realtime_threat_type_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.url_realtime_threat_type_ = from._impl_.url_realtime_threat_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::CopyFrom(
    const ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::IsInitialized() const
{
    return true;
}

void ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::InternalSwap(
    ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(
                                                   ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo, _impl_.url_realtime_threat_type_)
        + sizeof(ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::_impl_.url_realtime_threat_type_)
        - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo, _impl_.hash_realtime_threat_type_)>(
        reinterpret_cast<char*>(&_impl_.hash_realtime_threat_type_), reinterpret_cast<char*>(&other->_impl_.hash_realtime_threat_type_));
}

std::string ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo";
}

// ===================================================================

class ClientSafeBrowsingReportRequest::_Internal {
public:
    using HasBits = decltype(std::declval<ClientSafeBrowsingReportRequest>()._impl_._has_bits_);
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static void set_has_download_verdict(HasBits* has_bits)
    {
        (*has_bits)[0] |= 524288u;
    }
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_page_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_referrer_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_complete(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32768u;
    }
    static void set_has_client_country(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_did_proceed(HasBits* has_bits)
    {
        (*has_bits)[0] |= 65536u;
    }
    static void set_has_repeat_visit(HasBits* has_bits)
    {
        (*has_bits)[0] |= 131072u;
    }
    static void set_has_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties& client_properties(const ClientSafeBrowsingReportRequest* msg);
    static void set_has_client_properties(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_show_download_in_folder(HasBits* has_bits)
    {
        (*has_bits)[0] |= 262144u;
    }
    static const ::safe_browsing::ClientSafeBrowsingReportRequest_DownloadItemInfo& download_item_info(const ClientSafeBrowsingReportRequest* msg);
    static void set_has_download_item_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_safety_net_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::safe_browsing::ChromeUserPopulation& population(const ClientSafeBrowsingReportRequest* msg);
    static void set_has_population(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static const ::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails& hash_real_time_experiment_details(
        const ClientSafeBrowsingReportRequest* msg);
    static void set_has_hash_real_time_experiment_details(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_url_request_destination(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1048576u;
    }
    static void set_has_warning_shown_timestamp_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2097152u;
    }
    static const ::safe_browsing::ClientSafeBrowsingReportRequest_WarningShownInfo& warning_shown_info(const ClientSafeBrowsingReportRequest* msg);
    static void set_has_warning_shown_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static const ::safe_browsing::ClientSafeBrowsingReportRequest_PermissionPromptInfo& permission_prompt_info(const ClientSafeBrowsingReportRequest* msg);
    static void set_has_permission_prompt_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static void set_has_locale(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static const ::safe_browsing::ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo& url_real_time_and_hash_real_time_discrepancy_info(
        const ClientSafeBrowsingReportRequest* msg);
    static void set_has_url_real_time_and_hash_real_time_discrepancy_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
};

const ::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties& ClientSafeBrowsingReportRequest::_Internal::client_properties(
    const ClientSafeBrowsingReportRequest* msg)
{
    return *msg->_impl_.client_properties_;
}
const ::safe_browsing::ClientSafeBrowsingReportRequest_DownloadItemInfo& ClientSafeBrowsingReportRequest::_Internal::download_item_info(
    const ClientSafeBrowsingReportRequest* msg)
{
    return *msg->_impl_.download_item_info_;
}
const ::safe_browsing::ChromeUserPopulation& ClientSafeBrowsingReportRequest::_Internal::population(const ClientSafeBrowsingReportRequest* msg)
{
    return *msg->_impl_.population_;
}
const ::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails&
ClientSafeBrowsingReportRequest::_Internal::hash_real_time_experiment_details(const ClientSafeBrowsingReportRequest* msg)
{
    return *msg->_impl_.hash_real_time_experiment_details_;
}
const ::safe_browsing::ClientSafeBrowsingReportRequest_WarningShownInfo& ClientSafeBrowsingReportRequest::_Internal::warning_shown_info(
    const ClientSafeBrowsingReportRequest* msg)
{
    return *msg->_impl_.warning_shown_info_;
}
const ::safe_browsing::ClientSafeBrowsingReportRequest_PermissionPromptInfo& ClientSafeBrowsingReportRequest::_Internal::permission_prompt_info(
    const ClientSafeBrowsingReportRequest* msg)
{
    return *msg->_impl_.permission_prompt_info_;
}
const ::safe_browsing::ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo&
ClientSafeBrowsingReportRequest::_Internal::url_real_time_and_hash_real_time_discrepancy_info(const ClientSafeBrowsingReportRequest* msg)
{
    return *msg->_impl_.url_real_time_and_hash_real_time_discrepancy_info_;
}
ClientSafeBrowsingReportRequest::ClientSafeBrowsingReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ClientSafeBrowsingReportRequest)
}
ClientSafeBrowsingReportRequest::ClientSafeBrowsingReportRequest(const ClientSafeBrowsingReportRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientSafeBrowsingReportRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.resources_) { from._impl_.resources_ }, decltype(_impl_.client_asn_) { from._impl_.client_asn_ },
        decltype(_impl_.dom_) { from._impl_.dom_ }, decltype(_impl_.referrer_chain_) { from._impl_.referrer_chain_ },
        decltype(_impl_.download_warning_actions_) { from._impl_.download_warning_actions_ },
        decltype(_impl_.interstitial_interactions_) { from._impl_.interstitial_interactions_ },
        decltype(_impl_.phishy_site_interactions_) { from._impl_.phishy_site_interactions_ }, decltype(_impl_.url_) {}, decltype(_impl_.page_url_) {},
        decltype(_impl_.referrer_url_) {}, decltype(_impl_.client_country_) {}, decltype(_impl_.token_) {}, decltype(_impl_.safety_net_id_) {},
        decltype(_impl_.locale_) {}, decltype(_impl_.client_properties_) { nullptr }, decltype(_impl_.download_item_info_) { nullptr },
        decltype(_impl_.population_) { nullptr }, decltype(_impl_.hash_real_time_experiment_details_) { nullptr },
        decltype(_impl_.warning_shown_info_) { nullptr }, decltype(_impl_.permission_prompt_info_) { nullptr },
        decltype(_impl_.url_real_time_and_hash_real_time_discrepancy_info_) { nullptr }, decltype(_impl_.type_) {}, decltype(_impl_.complete_) {},
        decltype(_impl_.did_proceed_) {}, decltype(_impl_.repeat_visit_) {}, decltype(_impl_.show_download_in_folder_) {},
        decltype(_impl_.download_verdict_) {}, decltype(_impl_.url_request_destination_) {}, decltype(_impl_.warning_shown_timestamp_msec_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _impl_.page_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_page_url()) {
        _this->_impl_.page_url_.Set(from._internal_page_url(), _this->GetArenaForAllocation());
    }
    _impl_.referrer_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_referrer_url()) {
        _this->_impl_.referrer_url_.Set(from._internal_referrer_url(), _this->GetArenaForAllocation());
    }
    _impl_.client_country_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_country_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_client_country()) {
        _this->_impl_.client_country_.Set(from._internal_client_country(), _this->GetArenaForAllocation());
    }
    _impl_.token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_token()) {
        _this->_impl_.token_.Set(from._internal_token(), _this->GetArenaForAllocation());
    }
    _impl_.safety_net_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.safety_net_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_safety_net_id()) {
        _this->_impl_.safety_net_id_.Set(from._internal_safety_net_id(), _this->GetArenaForAllocation());
    }
    _impl_.locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_locale()) {
        _this->_impl_.locale_.Set(from._internal_locale(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_client_properties()) {
        _this->_impl_.client_properties_ = new ::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties(*from._impl_.client_properties_);
    }
    if (from._internal_has_download_item_info()) {
        _this->_impl_.download_item_info_ = new ::safe_browsing::ClientSafeBrowsingReportRequest_DownloadItemInfo(*from._impl_.download_item_info_);
    }
    if (from._internal_has_population()) {
        _this->_impl_.population_ = new ::safe_browsing::ChromeUserPopulation(*from._impl_.population_);
    }
    if (from._internal_has_hash_real_time_experiment_details()) {
        _this->_impl_.hash_real_time_experiment_details_
            = new ::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails(*from._impl_.hash_real_time_experiment_details_);
    }
    if (from._internal_has_warning_shown_info()) {
        _this->_impl_.warning_shown_info_ = new ::safe_browsing::ClientSafeBrowsingReportRequest_WarningShownInfo(*from._impl_.warning_shown_info_);
    }
    if (from._internal_has_permission_prompt_info()) {
        _this->_impl_.permission_prompt_info_ = new ::safe_browsing::ClientSafeBrowsingReportRequest_PermissionPromptInfo(*from._impl_.permission_prompt_info_);
    }
    if (from._internal_has_url_real_time_and_hash_real_time_discrepancy_info()) {
        _this->_impl_.url_real_time_and_hash_real_time_discrepancy_info_
            = new ::safe_browsing::ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo(
                *from._impl_.url_real_time_and_hash_real_time_discrepancy_info_);
    }
    ::memcpy(&_impl_.type_, &from._impl_.type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.warning_shown_timestamp_msec_) - reinterpret_cast<char*>(&_impl_.type_))
            + sizeof(_impl_.warning_shown_timestamp_msec_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ClientSafeBrowsingReportRequest)
}

inline void ClientSafeBrowsingReportRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.resources_) { arena },
        decltype(_impl_.client_asn_) { arena }, decltype(_impl_.dom_) { arena }, decltype(_impl_.referrer_chain_) { arena },
        decltype(_impl_.download_warning_actions_) { arena }, decltype(_impl_.interstitial_interactions_) { arena },
        decltype(_impl_.phishy_site_interactions_) { arena }, decltype(_impl_.url_) {}, decltype(_impl_.page_url_) {}, decltype(_impl_.referrer_url_) {},
        decltype(_impl_.client_country_) {}, decltype(_impl_.token_) {}, decltype(_impl_.safety_net_id_) {}, decltype(_impl_.locale_) {},
        decltype(_impl_.client_properties_) { nullptr }, decltype(_impl_.download_item_info_) { nullptr }, decltype(_impl_.population_) { nullptr },
        decltype(_impl_.hash_real_time_experiment_details_) { nullptr }, decltype(_impl_.warning_shown_info_) { nullptr },
        decltype(_impl_.permission_prompt_info_) { nullptr }, decltype(_impl_.url_real_time_and_hash_real_time_discrepancy_info_) { nullptr },
        decltype(_impl_.type_) { 0 }, decltype(_impl_.complete_) { false }, decltype(_impl_.did_proceed_) { false }, decltype(_impl_.repeat_visit_) { false },
        decltype(_impl_.show_download_in_folder_) { false }, decltype(_impl_.download_verdict_) { 0 }, decltype(_impl_.url_request_destination_) { 0 },
        decltype(_impl_.warning_shown_timestamp_msec_) { int64_t { 0 } } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_country_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_country_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.safety_net_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.safety_net_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.locale_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientSafeBrowsingReportRequest::~ClientSafeBrowsingReportRequest()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ClientSafeBrowsingReportRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientSafeBrowsingReportRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.resources_.~RepeatedPtrField();
    _impl_.client_asn_.~RepeatedPtrField();
    _impl_.dom_.~RepeatedPtrField();
    _impl_.referrer_chain_.~RepeatedPtrField();
    _impl_.download_warning_actions_.~RepeatedPtrField();
    _impl_.interstitial_interactions_.~RepeatedPtrField();
    _impl_.phishy_site_interactions_.~RepeatedPtrField();
    _impl_.url_.Destroy();
    _impl_.page_url_.Destroy();
    _impl_.referrer_url_.Destroy();
    _impl_.client_country_.Destroy();
    _impl_.token_.Destroy();
    _impl_.safety_net_id_.Destroy();
    _impl_.locale_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.client_properties_;
    if (this != internal_default_instance())
        delete _impl_.download_item_info_;
    if (this != internal_default_instance())
        delete _impl_.population_;
    if (this != internal_default_instance())
        delete _impl_.hash_real_time_experiment_details_;
    if (this != internal_default_instance())
        delete _impl_.warning_shown_info_;
    if (this != internal_default_instance())
        delete _impl_.permission_prompt_info_;
    if (this != internal_default_instance())
        delete _impl_.url_real_time_and_hash_real_time_discrepancy_info_;
}

void ClientSafeBrowsingReportRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientSafeBrowsingReportRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ClientSafeBrowsingReportRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.resources_.Clear();
    _impl_.client_asn_.Clear();
    _impl_.dom_.Clear();
    _impl_.referrer_chain_.Clear();
    _impl_.download_warning_actions_.Clear();
    _impl_.interstitial_interactions_.Clear();
    _impl_.phishy_site_interactions_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.page_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.referrer_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.client_country_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.safety_net_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000040u) {
            _impl_.locale_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.client_properties_ != nullptr);
            _impl_.client_properties_->Clear();
        }
    }
    if (cached_has_bits & 0x00003f00u) {
        if (cached_has_bits & 0x00000100u) {
            GOOGLE_DCHECK(_impl_.download_item_info_ != nullptr);
            _impl_.download_item_info_->Clear();
        }
        if (cached_has_bits & 0x00000200u) {
            GOOGLE_DCHECK(_impl_.population_ != nullptr);
            _impl_.population_->Clear();
        }
        if (cached_has_bits & 0x00000400u) {
            GOOGLE_DCHECK(_impl_.hash_real_time_experiment_details_ != nullptr);
            _impl_.hash_real_time_experiment_details_->Clear();
        }
        if (cached_has_bits & 0x00000800u) {
            GOOGLE_DCHECK(_impl_.warning_shown_info_ != nullptr);
            _impl_.warning_shown_info_->Clear();
        }
        if (cached_has_bits & 0x00001000u) {
            GOOGLE_DCHECK(_impl_.permission_prompt_info_ != nullptr);
            _impl_.permission_prompt_info_->Clear();
        }
        if (cached_has_bits & 0x00002000u) {
            GOOGLE_DCHECK(_impl_.url_real_time_and_hash_real_time_discrepancy_info_ != nullptr);
            _impl_.url_real_time_and_hash_real_time_discrepancy_info_->Clear();
        }
    }
    if (cached_has_bits & 0x0000c000u) {
        ::memset(&_impl_.type_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.complete_) - reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.complete_));
    }
    if (cached_has_bits & 0x003f0000u) {
        ::memset(&_impl_.did_proceed_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.warning_shown_timestamp_msec_) - reinterpret_cast<char*>(&_impl_.did_proceed_))
                + sizeof(_impl_.warning_shown_timestamp_msec_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientSafeBrowsingReportRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string page_url = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_page_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string referrer_url = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_referrer_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientSafeBrowsingReportRequest.Resource resources = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_resources(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool complete = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_complete(&has_bits);
                _impl_.complete_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string client_asn = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_client_asn();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string client_country = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_client_country();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool did_proceed = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_did_proceed(&has_bits);
                _impl_.did_proceed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool repeat_visit = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _Internal::set_has_repeat_visit(&has_bits);
                _impl_.repeat_visit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.ReportType type = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientSafeBrowsingReportRequest_ReportType_IsValid(val))) {
                    _internal_set_type(static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_ReportType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientDownloadResponse.Verdict download_verdict = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientDownloadResponse_Verdict_IsValid(val))) {
                    _internal_set_download_verdict(static_cast<::safe_browsing::ClientDownloadResponse_Verdict>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional bytes token = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
                auto str = _internal_mutable_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.HTMLElement dom = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_dom(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties client_properties = 17;
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
                ptr = ctx->ParseMessage(_internal_mutable_client_properties(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool show_download_in_folder = 18;
        case 18:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
                _Internal::set_has_show_download_in_folder(&has_bits);
                _impl_.show_download_in_folder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 23;
        case 23:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_referrer_chain(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<186>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo download_item_info = 24;
        case 24:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
                ptr = ctx->ParseMessage(_internal_mutable_download_item_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string safety_net_id = 25 [deprecated = true];
        case 25:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
                auto str = _internal_mutable_safety_net_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ChromeUserPopulation population = 26;
        case 26:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
                ptr = ctx->ParseMessage(_internal_mutable_population(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction download_warning_actions = 27;
        case 27:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_download_warning_actions(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<218>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails hash_real_time_experiment_details = 28 [deprecated = true];
        case 28:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
                ptr = ctx->ParseMessage(_internal_mutable_hash_real_time_experiment_details(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.UrlRequestDestination url_request_destination = 29;
        case 29:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientSafeBrowsingReportRequest_UrlRequestDestination_IsValid(val))) {
                    _internal_set_url_request_destination(static_cast<::safe_browsing::ClientSafeBrowsingReportRequest_UrlRequestDestination>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(29, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction interstitial_interactions = 30;
        case 30:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_interstitial_interactions(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<242>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction phishy_site_interactions = 31;
        case 31:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_phishy_site_interactions(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<250>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional int64 warning_shown_timestamp_msec = 32;
        case 32:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
                _Internal::set_has_warning_shown_timestamp_msec(&has_bits);
                _impl_.warning_shown_timestamp_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo warning_shown_info = 33;
        case 33:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_warning_shown_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.PermissionPromptInfo permission_prompt_info = 34;
        case 34:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_permission_prompt_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string locale = 35;
        case 35:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_locale();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo url_real_time_and_hash_real_time_discrepancy_info = 36;
        case 36:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_url_real_time_and_hash_real_time_discrepancy_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientSafeBrowsingReportRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ClientSafeBrowsingReportRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // optional string page_url = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_page_url(), target);
    }

    // optional string referrer_url = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_referrer_url(), target);
    }

    // repeated .safe_browsing.ClientSafeBrowsingReportRequest.Resource resources = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_resources_size()); i < n; i++) {
        const auto& repfield = this->_internal_resources(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bool complete = 5;
    if (cached_has_bits & 0x00008000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_complete(), target);
    }

    // repeated string client_asn = 6;
    for (int i = 0, n = this->_internal_client_asn_size(); i < n; i++) {
        const auto& s = this->_internal_client_asn(i);
        target = stream->WriteString(6, s, target);
    }

    // optional string client_country = 7;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_client_country(), target);
    }

    // optional bool did_proceed = 8;
    if (cached_has_bits & 0x00010000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_did_proceed(), target);
    }

    // optional bool repeat_visit = 9;
    if (cached_has_bits & 0x00020000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_repeat_visit(), target);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.ReportType type = 10;
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(10, this->_internal_type(), target);
    }

    // optional .safe_browsing.ClientDownloadResponse.Verdict download_verdict = 11;
    if (cached_has_bits & 0x00080000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(11, this->_internal_download_verdict(), target);
    }

    // optional bytes token = 15;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteBytesMaybeAliased(15, this->_internal_token(), target);
    }

    // repeated .safe_browsing.HTMLElement dom = 16;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_dom_size()); i < n; i++) {
        const auto& repfield = this->_internal_dom(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(16, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties client_properties = 17;
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            17, _Internal::client_properties(this), _Internal::client_properties(this).GetCachedSize(), target, stream);
    }

    // optional bool show_download_in_folder = 18;
    if (cached_has_bits & 0x00040000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_show_download_in_folder(), target);
    }

    // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 23;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_referrer_chain_size()); i < n; i++) {
        const auto& repfield = this->_internal_referrer_chain(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(23, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo download_item_info = 24;
    if (cached_has_bits & 0x00000100u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            24, _Internal::download_item_info(this), _Internal::download_item_info(this).GetCachedSize(), target, stream);
    }

    // optional string safety_net_id = 25 [deprecated = true];
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteStringMaybeAliased(25, this->_internal_safety_net_id(), target);
    }

    // optional .safe_browsing.ChromeUserPopulation population = 26;
    if (cached_has_bits & 0x00000200u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            26, _Internal::population(this), _Internal::population(this).GetCachedSize(), target, stream);
    }

    // repeated .safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction download_warning_actions = 27;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_download_warning_actions_size()); i < n; i++) {
        const auto& repfield = this->_internal_download_warning_actions(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(27, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails hash_real_time_experiment_details = 28 [deprecated = true];
    if (cached_has_bits & 0x00000400u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            28, _Internal::hash_real_time_experiment_details(this), _Internal::hash_real_time_experiment_details(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.UrlRequestDestination url_request_destination = 29;
    if (cached_has_bits & 0x00100000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(29, this->_internal_url_request_destination(), target);
    }

    // repeated .safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction interstitial_interactions = 30;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_interstitial_interactions_size()); i < n; i++) {
        const auto& repfield = this->_internal_interstitial_interactions(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(30, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction phishy_site_interactions = 31;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_phishy_site_interactions_size()); i < n; i++) {
        const auto& repfield = this->_internal_phishy_site_interactions(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(31, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional int64 warning_shown_timestamp_msec = 32;
    if (cached_has_bits & 0x00200000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(32, this->_internal_warning_shown_timestamp_msec(), target);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo warning_shown_info = 33;
    if (cached_has_bits & 0x00000800u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            33, _Internal::warning_shown_info(this), _Internal::warning_shown_info(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.PermissionPromptInfo permission_prompt_info = 34;
    if (cached_has_bits & 0x00001000u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            34, _Internal::permission_prompt_info(this), _Internal::permission_prompt_info(this).GetCachedSize(), target, stream);
    }

    // optional string locale = 35;
    if (cached_has_bits & 0x00000040u) {
        target = stream->WriteStringMaybeAliased(35, this->_internal_locale(), target);
    }

    // optional .safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo url_real_time_and_hash_real_time_discrepancy_info = 36;
    if (cached_has_bits & 0x00002000u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(36, _Internal::url_real_time_and_hash_real_time_discrepancy_info(this),
            _Internal::url_real_time_and_hash_real_time_discrepancy_info(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ClientSafeBrowsingReportRequest)
    return target;
}

size_t ClientSafeBrowsingReportRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ClientSafeBrowsingReportRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ClientSafeBrowsingReportRequest.Resource resources = 4;
    total_size += 1UL * this->_internal_resources_size();
    for (const auto& msg : this->_impl_.resources_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated string client_asn = 6;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.client_asn_.size());
    for (int i = 0, n = _impl_.client_asn_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.client_asn_.Get(i));
    }

    // repeated .safe_browsing.HTMLElement dom = 16;
    total_size += 2UL * this->_internal_dom_size();
    for (const auto& msg : this->_impl_.dom_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 23;
    total_size += 2UL * this->_internal_referrer_chain_size();
    for (const auto& msg : this->_impl_.referrer_chain_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .safe_browsing.ClientSafeBrowsingReportRequest.DownloadWarningAction download_warning_actions = 27;
    total_size += 2UL * this->_internal_download_warning_actions_size();
    for (const auto& msg : this->_impl_.download_warning_actions_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .safe_browsing.ClientSafeBrowsingReportRequest.InterstitialInteraction interstitial_interactions = 30;
    total_size += 2UL * this->_internal_interstitial_interactions_size();
    for (const auto& msg : this->_impl_.interstitial_interactions_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .safe_browsing.ClientSafeBrowsingReportRequest.PhishySiteInteraction phishy_site_interactions = 31;
    total_size += 2UL * this->_internal_phishy_site_interactions_size();
    for (const auto& msg : this->_impl_.phishy_site_interactions_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional string page_url = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_page_url());
        }

        // optional string referrer_url = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_referrer_url());
        }

        // optional string client_country = 7;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_client_country());
        }

        // optional bytes token = 15;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_token());
        }

        // optional string safety_net_id = 25 [deprecated = true];
        if (cached_has_bits & 0x00000020u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_safety_net_id());
        }

        // optional string locale = 35;
        if (cached_has_bits & 0x00000040u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_locale());
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.SafeBrowsingClientProperties client_properties = 17;
        if (cached_has_bits & 0x00000080u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.client_properties_);
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        // optional .safe_browsing.ClientSafeBrowsingReportRequest.DownloadItemInfo download_item_info = 24;
        if (cached_has_bits & 0x00000100u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.download_item_info_);
        }

        // optional .safe_browsing.ChromeUserPopulation population = 26;
        if (cached_has_bits & 0x00000200u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.population_);
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.HashRealTimeExperimentDetails hash_real_time_experiment_details = 28 [deprecated = true];
        if (cached_has_bits & 0x00000400u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.hash_real_time_experiment_details_);
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.WarningShownInfo warning_shown_info = 33;
        if (cached_has_bits & 0x00000800u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.warning_shown_info_);
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.PermissionPromptInfo permission_prompt_info = 34;
        if (cached_has_bits & 0x00001000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.permission_prompt_info_);
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.UrlRealTimeAndHashRealTimeDiscrepancyInfo url_real_time_and_hash_real_time_discrepancy_info = 36;
        if (cached_has_bits & 0x00002000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.url_real_time_and_hash_real_time_discrepancy_info_);
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.ReportType type = 10;
        if (cached_has_bits & 0x00004000u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }

        // optional bool complete = 5;
        if (cached_has_bits & 0x00008000u) {
            total_size += 1 + 1;
        }
    }
    if (cached_has_bits & 0x003f0000u) {
        // optional bool did_proceed = 8;
        if (cached_has_bits & 0x00010000u) {
            total_size += 1 + 1;
        }

        // optional bool repeat_visit = 9;
        if (cached_has_bits & 0x00020000u) {
            total_size += 1 + 1;
        }

        // optional bool show_download_in_folder = 18;
        if (cached_has_bits & 0x00040000u) {
            total_size += 2 + 1;
        }

        // optional .safe_browsing.ClientDownloadResponse.Verdict download_verdict = 11;
        if (cached_has_bits & 0x00080000u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_download_verdict());
        }

        // optional .safe_browsing.ClientSafeBrowsingReportRequest.UrlRequestDestination url_request_destination = 29;
        if (cached_has_bits & 0x00100000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_url_request_destination());
        }

        // optional int64 warning_shown_timestamp_msec = 32;
        if (cached_has_bits & 0x00200000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_warning_shown_timestamp_msec());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientSafeBrowsingReportRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientSafeBrowsingReportRequest*>(&from));
}

void ClientSafeBrowsingReportRequest::MergeFrom(const ClientSafeBrowsingReportRequest& from)
{
    ClientSafeBrowsingReportRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ClientSafeBrowsingReportRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.resources_.MergeFrom(from._impl_.resources_);
    _this->_impl_.client_asn_.MergeFrom(from._impl_.client_asn_);
    _this->_impl_.dom_.MergeFrom(from._impl_.dom_);
    _this->_impl_.referrer_chain_.MergeFrom(from._impl_.referrer_chain_);
    _this->_impl_.download_warning_actions_.MergeFrom(from._impl_.download_warning_actions_);
    _this->_impl_.interstitial_interactions_.MergeFrom(from._impl_.interstitial_interactions_);
    _this->_impl_.phishy_site_interactions_.MergeFrom(from._impl_.phishy_site_interactions_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_page_url(from._internal_page_url());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_referrer_url(from._internal_referrer_url());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_client_country(from._internal_client_country());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_token(from._internal_token());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_safety_net_id(from._internal_safety_net_id());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_set_locale(from._internal_locale());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_client_properties()->::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties::MergeFrom(
                from._internal_client_properties());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_mutable_download_item_info()->::safe_browsing::ClientSafeBrowsingReportRequest_DownloadItemInfo::MergeFrom(
                from._internal_download_item_info());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_internal_mutable_population()->::safe_browsing::ChromeUserPopulation::MergeFrom(from._internal_population());
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_internal_mutable_hash_real_time_experiment_details()
                ->::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails::MergeFrom(from._internal_hash_real_time_experiment_details());
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_internal_mutable_warning_shown_info()->::safe_browsing::ClientSafeBrowsingReportRequest_WarningShownInfo::MergeFrom(
                from._internal_warning_shown_info());
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_internal_mutable_permission_prompt_info()->::safe_browsing::ClientSafeBrowsingReportRequest_PermissionPromptInfo::MergeFrom(
                from._internal_permission_prompt_info());
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_internal_mutable_url_real_time_and_hash_real_time_discrepancy_info()
                ->::safe_browsing::ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo::MergeFrom(
                    from._internal_url_real_time_and_hash_real_time_discrepancy_info());
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_impl_.complete_ = from._impl_.complete_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x003f0000u) {
        if (cached_has_bits & 0x00010000u) {
            _this->_impl_.did_proceed_ = from._impl_.did_proceed_;
        }
        if (cached_has_bits & 0x00020000u) {
            _this->_impl_.repeat_visit_ = from._impl_.repeat_visit_;
        }
        if (cached_has_bits & 0x00040000u) {
            _this->_impl_.show_download_in_folder_ = from._impl_.show_download_in_folder_;
        }
        if (cached_has_bits & 0x00080000u) {
            _this->_impl_.download_verdict_ = from._impl_.download_verdict_;
        }
        if (cached_has_bits & 0x00100000u) {
            _this->_impl_.url_request_destination_ = from._impl_.url_request_destination_;
        }
        if (cached_has_bits & 0x00200000u) {
            _this->_impl_.warning_shown_timestamp_msec_ = from._impl_.warning_shown_timestamp_msec_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientSafeBrowsingReportRequest::CopyFrom(const ClientSafeBrowsingReportRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ClientSafeBrowsingReportRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientSafeBrowsingReportRequest::IsInitialized() const
{
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.resources_))
        return false;
    return true;
}

void ClientSafeBrowsingReportRequest::InternalSwap(ClientSafeBrowsingReportRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.resources_.InternalSwap(&other->_impl_.resources_);
    _impl_.client_asn_.InternalSwap(&other->_impl_.client_asn_);
    _impl_.dom_.InternalSwap(&other->_impl_.dom_);
    _impl_.referrer_chain_.InternalSwap(&other->_impl_.referrer_chain_);
    _impl_.download_warning_actions_.InternalSwap(&other->_impl_.download_warning_actions_);
    _impl_.interstitial_interactions_.InternalSwap(&other->_impl_.interstitial_interactions_);
    _impl_.phishy_site_interactions_.InternalSwap(&other->_impl_.phishy_site_interactions_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.page_url_, lhs_arena, &other->_impl_.page_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.referrer_url_, lhs_arena, &other->_impl_.referrer_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.client_country_, lhs_arena, &other->_impl_.client_country_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.token_, lhs_arena, &other->_impl_.token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.safety_net_id_, lhs_arena, &other->_impl_.safety_net_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.locale_, lhs_arena, &other->_impl_.locale_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest, _impl_.warning_shown_timestamp_msec_)
        + sizeof(ClientSafeBrowsingReportRequest::_impl_.warning_shown_timestamp_msec_)
        - PROTOBUF_FIELD_OFFSET(ClientSafeBrowsingReportRequest, _impl_.client_properties_)>(
        reinterpret_cast<char*>(&_impl_.client_properties_), reinterpret_cast<char*>(&other->_impl_.client_properties_));
}

std::string ClientSafeBrowsingReportRequest::GetTypeName() const
{
    return "safe_browsing.ClientSafeBrowsingReportRequest";
}

// ===================================================================

class HTMLElement_Attribute::_Internal {
public:
    using HasBits = decltype(std::declval<HTMLElement_Attribute>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

HTMLElement_Attribute::HTMLElement_Attribute(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.HTMLElement.Attribute)
}
HTMLElement_Attribute::HTMLElement_Attribute(const HTMLElement_Attribute& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    HTMLElement_Attribute* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {},
        decltype(_impl_.value_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_value()) {
        _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.HTMLElement.Attribute)
}

inline void HTMLElement_Attribute::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {}, decltype(_impl_.value_) {} };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HTMLElement_Attribute::~HTMLElement_Attribute()
{
    // @@protoc_insertion_point(destructor:safe_browsing.HTMLElement.Attribute)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void HTMLElement_Attribute::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_.Destroy();
    _impl_.value_.Destroy();
}

void HTMLElement_Attribute::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void HTMLElement_Attribute::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.HTMLElement.Attribute)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.value_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* HTMLElement_Attribute::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* HTMLElement_Attribute::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.HTMLElement.Attribute)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_value(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.HTMLElement.Attribute)
    return target;
}

size_t HTMLElement_Attribute::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.HTMLElement.Attribute)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string value = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_value());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void HTMLElement_Attribute::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const HTMLElement_Attribute*>(&from));
}

void HTMLElement_Attribute::MergeFrom(const HTMLElement_Attribute& from)
{
    HTMLElement_Attribute* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.HTMLElement.Attribute)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_value(from._internal_value());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HTMLElement_Attribute::CopyFrom(const HTMLElement_Attribute& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.HTMLElement.Attribute)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool HTMLElement_Attribute::IsInitialized() const
{
    return true;
}

void HTMLElement_Attribute::InternalSwap(HTMLElement_Attribute* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena, &other->_impl_.value_, rhs_arena);
}

std::string HTMLElement_Attribute::GetTypeName() const
{
    return "safe_browsing.HTMLElement.Attribute";
}

// ===================================================================

class HTMLElement::_Internal {
public:
    using HasBits = decltype(std::declval<HTMLElement>()._impl_._has_bits_);
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_tag(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_resource_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_inner_html(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

HTMLElement::HTMLElement(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.HTMLElement)
}
HTMLElement::HTMLElement(const HTMLElement& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    HTMLElement* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.child_ids_) { from._impl_.child_ids_ }, decltype(_impl_.attribute_) { from._impl_.attribute_ }, decltype(_impl_.tag_) {},
        decltype(_impl_.inner_html_) {}, decltype(_impl_.id_) {}, decltype(_impl_.resource_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_tag()) {
        _this->_impl_.tag_.Set(from._internal_tag(), _this->GetArenaForAllocation());
    }
    _impl_.inner_html_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.inner_html_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_inner_html()) {
        _this->_impl_.inner_html_.Set(from._internal_inner_html(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.id_, &from._impl_.id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.resource_id_) - reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.resource_id_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.HTMLElement)
}

inline void HTMLElement::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.child_ids_) { arena },
        decltype(_impl_.attribute_) { arena }, decltype(_impl_.tag_) {}, decltype(_impl_.inner_html_) {}, decltype(_impl_.id_) { 0 },
        decltype(_impl_.resource_id_) { 0 } };
    _impl_.tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.inner_html_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.inner_html_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HTMLElement::~HTMLElement()
{
    // @@protoc_insertion_point(destructor:safe_browsing.HTMLElement)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void HTMLElement::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.child_ids_.~RepeatedField();
    _impl_.attribute_.~RepeatedPtrField();
    _impl_.tag_.Destroy();
    _impl_.inner_html_.Destroy();
}

void HTMLElement::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void HTMLElement::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.HTMLElement)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.child_ids_.Clear();
    _impl_.attribute_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.tag_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.inner_html_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000000cu) {
        ::memset(&_impl_.id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.resource_id_) - reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.resource_id_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* HTMLElement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_id(&has_bits);
                _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string tag = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_tag();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated int32 child_ids = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_child_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
            } else if (static_cast<uint8_t>(tag) == 26) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_child_ids(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 resource_id = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_resource_id(&has_bits);
                _impl_.resource_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.HTMLElement.Attribute attribute = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_attribute(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bytes inner_html = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_inner_html();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* HTMLElement::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.HTMLElement)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 id = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
    }

    // optional string tag = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_tag(), target);
    }

    // repeated int32 child_ids = 3;
    for (int i = 0, n = this->_internal_child_ids_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_child_ids(i), target);
    }

    // optional int32 resource_id = 5;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_resource_id(), target);
    }

    // repeated .safe_browsing.HTMLElement.Attribute attribute = 6;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_attribute_size()); i < n; i++) {
        const auto& repfield = this->_internal_attribute(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bytes inner_html = 7;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(7, this->_internal_inner_html(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.HTMLElement)
    return target;
}

size_t HTMLElement::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.HTMLElement)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 child_ids = 3;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.child_ids_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_child_ids_size());
        total_size += data_size;
    }

    // repeated .safe_browsing.HTMLElement.Attribute attribute = 6;
    total_size += 1UL * this->_internal_attribute_size();
    for (const auto& msg : this->_impl_.attribute_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string tag = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_tag());
        }

        // optional bytes inner_html = 7;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_inner_html());
        }

        // optional int32 id = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
        }

        // optional int32 resource_id = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_resource_id());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void HTMLElement::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const HTMLElement*>(&from));
}

void HTMLElement::MergeFrom(const HTMLElement& from)
{
    HTMLElement* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.HTMLElement)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.child_ids_.MergeFrom(from._impl_.child_ids_);
    _this->_impl_.attribute_.MergeFrom(from._impl_.attribute_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_tag(from._internal_tag());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_inner_html(from._internal_inner_html());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.id_ = from._impl_.id_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.resource_id_ = from._impl_.resource_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HTMLElement::CopyFrom(const HTMLElement& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.HTMLElement)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool HTMLElement::IsInitialized() const
{
    return true;
}

void HTMLElement::InternalSwap(HTMLElement* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.child_ids_.InternalSwap(&other->_impl_.child_ids_);
    _impl_.attribute_.InternalSwap(&other->_impl_.attribute_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.tag_, lhs_arena, &other->_impl_.tag_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.inner_html_, lhs_arena, &other->_impl_.inner_html_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(HTMLElement, _impl_.resource_id_) + sizeof(HTMLElement::_impl_.resource_id_)
        - PROTOBUF_FIELD_OFFSET(HTMLElement, _impl_.id_)>(reinterpret_cast<char*>(&_impl_.id_), reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string HTMLElement::GetTypeName() const
{
    return "safe_browsing.HTMLElement";
}

// ===================================================================

class ExtensionWebStoreInstallRequest::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionWebStoreInstallRequest>()._impl_._has_bits_);
    static const ::safe_browsing::ReferrerChainOptions& referrer_chain_options(const ExtensionWebStoreInstallRequest* msg);
    static void set_has_referrer_chain_options(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::safe_browsing::ReferrerChainOptions& ExtensionWebStoreInstallRequest::_Internal::referrer_chain_options(const ExtensionWebStoreInstallRequest* msg)
{
    return *msg->_impl_.referrer_chain_options_;
}
ExtensionWebStoreInstallRequest::ExtensionWebStoreInstallRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionWebStoreInstallRequest)
}
ExtensionWebStoreInstallRequest::ExtensionWebStoreInstallRequest(const ExtensionWebStoreInstallRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionWebStoreInstallRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.referrer_chain_) { from._impl_.referrer_chain_ }, decltype(_impl_.referrer_chain_options_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_referrer_chain_options()) {
        _this->_impl_.referrer_chain_options_ = new ::safe_browsing::ReferrerChainOptions(*from._impl_.referrer_chain_options_);
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionWebStoreInstallRequest)
}

inline void ExtensionWebStoreInstallRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.referrer_chain_) { arena },
        decltype(_impl_.referrer_chain_options_) { nullptr } };
}

ExtensionWebStoreInstallRequest::~ExtensionWebStoreInstallRequest()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionWebStoreInstallRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionWebStoreInstallRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.referrer_chain_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.referrer_chain_options_;
}

void ExtensionWebStoreInstallRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionWebStoreInstallRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionWebStoreInstallRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.referrer_chain_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.referrer_chain_options_ != nullptr);
        _impl_.referrer_chain_options_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionWebStoreInstallRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_referrer_chain(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ReferrerChainOptions referrer_chain_options = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_referrer_chain_options(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionWebStoreInstallRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionWebStoreInstallRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_referrer_chain_size()); i < n; i++) {
        const auto& repfield = this->_internal_referrer_chain(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ReferrerChainOptions referrer_chain_options = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::referrer_chain_options(this), _Internal::referrer_chain_options(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionWebStoreInstallRequest)
    return target;
}

size_t ExtensionWebStoreInstallRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionWebStoreInstallRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 1;
    total_size += 1UL * this->_internal_referrer_chain_size();
    for (const auto& msg : this->_impl_.referrer_chain_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional .safe_browsing.ReferrerChainOptions referrer_chain_options = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.referrer_chain_options_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionWebStoreInstallRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionWebStoreInstallRequest*>(&from));
}

void ExtensionWebStoreInstallRequest::MergeFrom(const ExtensionWebStoreInstallRequest& from)
{
    ExtensionWebStoreInstallRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionWebStoreInstallRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.referrer_chain_.MergeFrom(from._impl_.referrer_chain_);
    if (from._internal_has_referrer_chain_options()) {
        _this->_internal_mutable_referrer_chain_options()->::safe_browsing::ReferrerChainOptions::MergeFrom(from._internal_referrer_chain_options());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionWebStoreInstallRequest::CopyFrom(const ExtensionWebStoreInstallRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionWebStoreInstallRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionWebStoreInstallRequest::IsInitialized() const
{
    return true;
}

void ExtensionWebStoreInstallRequest::InternalSwap(ExtensionWebStoreInstallRequest* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.referrer_chain_.InternalSwap(&other->_impl_.referrer_chain_);
    swap(_impl_.referrer_chain_options_, other->_impl_.referrer_chain_options_);
}

std::string ExtensionWebStoreInstallRequest::GetTypeName() const
{
    return "safe_browsing.ExtensionWebStoreInstallRequest";
}

// ===================================================================

class ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_hash(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.FileInfo)
}
ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo(
    const ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {},
        decltype(_impl_.hash_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_hash()) {
        _this->_impl_.hash_.Set(from._internal_hash(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.FileInfo)
}

inline void ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {}, decltype(_impl_.hash_) {} };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::~ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.FileInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_.Destroy();
    _impl_.hash_.Destroy();
}

void ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.FileInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.hash_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes hash = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_hash();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.FileInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional bytes hash = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_hash(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.FileInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.FileInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional bytes hash = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_hash());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo*>(&from));
}

void ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::MergeFrom(const ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo& from)
{
    ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.FileInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_hash(from._internal_hash());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::CopyFrom(const ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.FileInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::InternalSwap(ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.hash_, lhs_arena, &other->_impl_.hash_, rhs_arena);
}

std::string ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.FileInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_ExtensionInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_ExtensionInfo>()._impl_._has_bits_);
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_install_timestamp_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_is_default_installed(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_is_oem_installed(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_is_from_store(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_updates_from_store(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_is_converted_from_user_script(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_install_location(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_blocklist_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static void set_has_disable_reasons(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static void set_has_manifest_json(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_telemetry_blocklist_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static void set_has_installation_policy(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32768u;
    }
};

ExtensionTelemetryReportRequest_ExtensionInfo::ExtensionTelemetryReportRequest_ExtensionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo)
}
ExtensionTelemetryReportRequest_ExtensionInfo::ExtensionTelemetryReportRequest_ExtensionInfo(const ExtensionTelemetryReportRequest_ExtensionInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_ExtensionInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.file_infos_) { from._impl_.file_infos_ }, decltype(_impl_.id_) {}, decltype(_impl_.version_) {}, decltype(_impl_.name_) {},
        decltype(_impl_.manifest_json_) {}, decltype(_impl_.install_timestamp_msec_) {}, decltype(_impl_.is_default_installed_) {},
        decltype(_impl_.is_oem_installed_) {}, decltype(_impl_.is_from_store_) {}, decltype(_impl_.updates_from_store_) {},
        decltype(_impl_.is_converted_from_user_script_) {}, decltype(_impl_.type_) {}, decltype(_impl_.install_location_) {},
        decltype(_impl_.blocklist_state_) {}, decltype(_impl_.disable_reasons_) {}, decltype(_impl_.telemetry_blocklist_state_) {},
        decltype(_impl_.installation_policy_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_id()) {
        _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
    }
    _impl_.version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_version()) {
        _this->_impl_.version_.Set(from._internal_version(), _this->GetArenaForAllocation());
    }
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.manifest_json_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manifest_json_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_manifest_json()) {
        _this->_impl_.manifest_json_.Set(from._internal_manifest_json(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.install_timestamp_msec_, &from._impl_.install_timestamp_msec_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.installation_policy_) - reinterpret_cast<char*>(&_impl_.install_timestamp_msec_))
            + sizeof(_impl_.installation_policy_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo)
}

inline void ExtensionTelemetryReportRequest_ExtensionInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.file_infos_) { arena },
        decltype(_impl_.id_) {}, decltype(_impl_.version_) {}, decltype(_impl_.name_) {}, decltype(_impl_.manifest_json_) {},
        decltype(_impl_.install_timestamp_msec_) { int64_t { 0 } }, decltype(_impl_.is_default_installed_) { false },
        decltype(_impl_.is_oem_installed_) { false }, decltype(_impl_.is_from_store_) { false }, decltype(_impl_.updates_from_store_) { false },
        decltype(_impl_.is_converted_from_user_script_) { false }, decltype(_impl_.type_) { 0 }, decltype(_impl_.install_location_) { 0 },
        decltype(_impl_.blocklist_state_) { 0 }, decltype(_impl_.disable_reasons_) { 0u }, decltype(_impl_.telemetry_blocklist_state_) { 0 },
        decltype(_impl_.installation_policy_) { 0 } };
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manifest_json_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manifest_json_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionTelemetryReportRequest_ExtensionInfo::~ExtensionTelemetryReportRequest_ExtensionInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_ExtensionInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.file_infos_.~RepeatedPtrField();
    _impl_.id_.Destroy();
    _impl_.version_.Destroy();
    _impl_.name_.Destroy();
    _impl_.manifest_json_.Destroy();
}

void ExtensionTelemetryReportRequest_ExtensionInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_ExtensionInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.file_infos_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.version_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.manifest_json_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x000000f0u) {
        ::memset(&_impl_.install_timestamp_msec_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_from_store_) - reinterpret_cast<char*>(&_impl_.install_timestamp_msec_))
                + sizeof(_impl_.is_from_store_));
    }
    if (cached_has_bits & 0x0000ff00u) {
        ::memset(&_impl_.updates_from_store_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.installation_policy_) - reinterpret_cast<char*>(&_impl_.updates_from_store_))
                + sizeof(_impl_.installation_policy_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_ExtensionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string version = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string name = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 install_timestamp_msec = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_install_timestamp_msec(&has_bits);
                _impl_.install_timestamp_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_default_installed = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_is_default_installed(&has_bits);
                _impl_.is_default_installed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_oem_installed = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_is_oem_installed(&has_bits);
                _impl_.is_oem_installed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_from_store = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_is_from_store(&has_bits);
                _impl_.is_from_store_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool updates_from_store = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_updates_from_store(&has_bits);
                _impl_.updates_from_store_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_converted_from_user_script = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _Internal::set_has_is_converted_from_user_script(&has_bits);
                _impl_.is_converted_from_user_script_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.Type type = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo_Type_IsValid(val))) {
                    _internal_set_type(static_cast<::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo_Type>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.InstallLocation install_location = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation_IsValid(val))) {
                    _internal_set_install_location(static_cast<::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo_InstallLocation>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.BlocklistState blocklist_state = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_IsValid(val))) {
                    _internal_set_blocklist_state(static_cast<::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional uint32 disable_reasons = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                _Internal::set_has_disable_reasons(&has_bits);
                _impl_.disable_reasons_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string manifest_json = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                auto str = _internal_mutable_manifest_json();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.FileInfo file_infos = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_file_infos(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.BlocklistState telemetry_blocklist_state = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState_IsValid(val))) {
                    _internal_set_telemetry_blocklist_state(static_cast<::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo_BlocklistState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.InstallationPolicy installation_policy = 17;
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy_IsValid(val))) {
                    _internal_set_installation_policy(static_cast<::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo_InstallationPolicy>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(17, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_ExtensionInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_id(), target);
    }

    // optional string version = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_version(), target);
    }

    // optional string name = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_name(), target);
    }

    // optional int64 install_timestamp_msec = 4;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_install_timestamp_msec(), target);
    }

    // optional bool is_default_installed = 5;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_default_installed(), target);
    }

    // optional bool is_oem_installed = 6;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_oem_installed(), target);
    }

    // optional bool is_from_store = 7;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_is_from_store(), target);
    }

    // optional bool updates_from_store = 8;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_updates_from_store(), target);
    }

    // optional bool is_converted_from_user_script = 9;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_is_converted_from_user_script(), target);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.Type type = 10;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(10, this->_internal_type(), target);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.InstallLocation install_location = 11;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(11, this->_internal_install_location(), target);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.BlocklistState blocklist_state = 12;
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(12, this->_internal_blocklist_state(), target);
    }

    // optional uint32 disable_reasons = 13;
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_disable_reasons(), target);
    }

    // optional string manifest_json = 14;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(14, this->_internal_manifest_json(), target);
    }

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.FileInfo file_infos = 15;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_file_infos_size()); i < n; i++) {
        const auto& repfield = this->_internal_file_infos(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.BlocklistState telemetry_blocklist_state = 16;
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(16, this->_internal_telemetry_blocklist_state(), target);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.InstallationPolicy installation_policy = 17;
    if (cached_has_bits & 0x00008000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(17, this->_internal_installation_policy(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_ExtensionInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.FileInfo file_infos = 15;
    total_size += 1UL * this->_internal_file_infos_size();
    for (const auto& msg : this->_impl_.file_infos_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_id());
        }

        // optional string version = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_version());
        }

        // optional string name = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string manifest_json = 14;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_manifest_json());
        }

        // optional int64 install_timestamp_msec = 4;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_install_timestamp_msec());
        }

        // optional bool is_default_installed = 5;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 1;
        }

        // optional bool is_oem_installed = 6;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + 1;
        }

        // optional bool is_from_store = 7;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + 1;
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        // optional bool updates_from_store = 8;
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + 1;
        }

        // optional bool is_converted_from_user_script = 9;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + 1;
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.Type type = 10;
        if (cached_has_bits & 0x00000400u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.InstallLocation install_location = 11;
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_install_location());
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.BlocklistState blocklist_state = 12;
        if (cached_has_bits & 0x00001000u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_blocklist_state());
        }

        // optional uint32 disable_reasons = 13;
        if (cached_has_bits & 0x00002000u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_disable_reasons());
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.BlocklistState telemetry_blocklist_state = 16;
        if (cached_has_bits & 0x00004000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_telemetry_blocklist_state());
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo.InstallationPolicy installation_policy = 17;
        if (cached_has_bits & 0x00008000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_installation_policy());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_ExtensionInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_ExtensionInfo*>(&from));
}

void ExtensionTelemetryReportRequest_ExtensionInfo::MergeFrom(const ExtensionTelemetryReportRequest_ExtensionInfo& from)
{
    ExtensionTelemetryReportRequest_ExtensionInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.file_infos_.MergeFrom(from._impl_.file_infos_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_id(from._internal_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_version(from._internal_version());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_manifest_json(from._internal_manifest_json());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.install_timestamp_msec_ = from._impl_.install_timestamp_msec_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.is_default_installed_ = from._impl_.is_default_installed_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.is_oem_installed_ = from._impl_.is_oem_installed_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.is_from_store_ = from._impl_.is_from_store_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.updates_from_store_ = from._impl_.updates_from_store_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.is_converted_from_user_script_ = from._impl_.is_converted_from_user_script_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.install_location_ = from._impl_.install_location_;
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.blocklist_state_ = from._impl_.blocklist_state_;
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.disable_reasons_ = from._impl_.disable_reasons_;
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.telemetry_blocklist_state_ = from._impl_.telemetry_blocklist_state_;
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_impl_.installation_policy_ = from._impl_.installation_policy_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_ExtensionInfo::CopyFrom(const ExtensionTelemetryReportRequest_ExtensionInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_ExtensionInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_ExtensionInfo::InternalSwap(ExtensionTelemetryReportRequest_ExtensionInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.file_infos_.InternalSwap(&other->_impl_.file_infos_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena, &other->_impl_.id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.version_, lhs_arena, &other->_impl_.version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.manifest_json_, lhs_arena, &other->_impl_.manifest_json_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest_ExtensionInfo, _impl_.installation_policy_)
        + sizeof(ExtensionTelemetryReportRequest_ExtensionInfo::_impl_.installation_policy_)
        - PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest_ExtensionInfo, _impl_.install_timestamp_msec_)>(
        reinterpret_cast<char*>(&_impl_.install_timestamp_msec_), reinterpret_cast<char*>(&other->_impl_.install_timestamp_msec_));
}

std::string ExtensionTelemetryReportRequest_ExtensionInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame>()._impl_._has_bits_);
    static void set_has_function_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_script_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_line(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_column(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStackFrame)
}
ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame(
    const ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.function_name_) {},
        decltype(_impl_.script_name_) {}, decltype(_impl_.line_) {}, decltype(_impl_.column_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.function_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_function_name()) {
        _this->_impl_.function_name_.Set(from._internal_function_name(), _this->GetArenaForAllocation());
    }
    _impl_.script_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.script_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_script_name()) {
        _this->_impl_.script_name_.Set(from._internal_script_name(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.line_, &from._impl_.line_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.column_) - reinterpret_cast<char*>(&_impl_.line_)) + sizeof(_impl_.column_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStackFrame)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.function_name_) {},
        decltype(_impl_.script_name_) {}, decltype(_impl_.line_) { 0u }, decltype(_impl_.column_) { 0u } };
    _impl_.function_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.function_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.script_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.script_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::~ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStackFrame)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.function_name_.Destroy();
    _impl_.script_name_.Destroy();
}

void ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStackFrame)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.function_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.script_name_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000000cu) {
        ::memset(
            &_impl_.line_, 0, static_cast<size_t>(reinterpret_cast<char*>(&_impl_.column_) - reinterpret_cast<char*>(&_impl_.line_)) + sizeof(_impl_.column_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string function_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_function_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string script_name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_script_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 line = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_line(&has_bits);
                _impl_.line_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 column = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_column(&has_bits);
                _impl_.column_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStackFrame)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string function_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_function_name(), target);
    }

    // optional string script_name = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_script_name(), target);
    }

    // optional uint32 line = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_line(), target);
    }

    // optional uint32 column = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_column(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStackFrame)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStackFrame)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string function_name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_function_name());
        }

        // optional string script_name = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_script_name());
        }

        // optional uint32 line = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_line());
        }

        // optional uint32 column = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_column());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::MergeFrom(const ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStackFrame)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_function_name(from._internal_function_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_script_name(from._internal_script_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.line_ = from._impl_.line_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.column_ = from._impl_.column_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::CopyFrom(const ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStackFrame)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::InternalSwap(ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.function_name_, lhs_arena, &other->_impl_.function_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.script_name_, lhs_arena, &other->_impl_.script_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame, _impl_.column_)
        + sizeof(ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::_impl_.column_)
        - PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame, _impl_.line_)>(
        reinterpret_cast<char*>(&_impl_.line_), reinterpret_cast<char*>(&other->_impl_.line_));
}

std::string ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStackFrame";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::_Internal {
public:
};

ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::ExtensionTelemetryReportRequest_SignalInfo_JSCallStack(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack)
}
ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::ExtensionTelemetryReportRequest_SignalInfo_JSCallStack(
    const ExtensionTelemetryReportRequest_SignalInfo_JSCallStack& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_JSCallStack* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.frames_) { from._impl_.frames_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.frames_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::~ExtensionTelemetryReportRequest_SignalInfo_JSCallStack()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.frames_.~RepeatedPtrField();
}

void ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.frames_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStackFrame frames = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_frames(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStackFrame frames = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_frames_size()); i < n; i++) {
        const auto& repfield = this->_internal_frames(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStackFrame frames = 1;
    total_size += 1UL * this->_internal_frames_size();
    for (const auto& msg : this->_impl_.frames_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_JSCallStack*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::MergeFrom(const ExtensionTelemetryReportRequest_SignalInfo_JSCallStack& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_JSCallStack* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.frames_.MergeFrom(from._impl_.frames_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::CopyFrom(const ExtensionTelemetryReportRequest_SignalInfo_JSCallStack& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::InternalSwap(ExtensionTelemetryReportRequest_SignalInfo_JSCallStack* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.frames_.InternalSwap(&other->_impl_.frames_);
}

std::string ExtensionTelemetryReportRequest_SignalInfo_JSCallStack::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo>()._impl_._has_bits_);
    static void set_has_hash(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_execution_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo.ScriptInfo)
}
ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo(
    const ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.hash_) {},
        decltype(_impl_.execution_count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_hash()) {
        _this->_impl_.hash_.Set(from._internal_hash(), _this->GetArenaForAllocation());
    }
    _this->_impl_.execution_count_ = from._impl_.execution_count_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo.ScriptInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.hash_) {}, decltype(_impl_.execution_count_) { 0u } };
    _impl_.hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::~ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo.ScriptInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.hash_.Destroy();
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo.ScriptInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.hash_.ClearNonDefaultToEmpty();
    }
    _impl_.execution_count_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bytes hash = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_hash();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 execution_count = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_execution_count(&has_bits);
                _impl_.execution_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo.ScriptInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bytes hash = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_hash(), target);
    }

    // optional uint32 execution_count = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_execution_count(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo.ScriptInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo.ScriptInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional bytes hash = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_hash());
        }

        // optional uint32 execution_count = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_execution_count());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::MergeFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo.ScriptInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_hash(from._internal_hash());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.execution_count_ = from._impl_.execution_count_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::CopyFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo.ScriptInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::InternalSwap(
    ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.hash_, lhs_arena, &other->_impl_.hash_, rhs_arena);
    swap(_impl_.execution_count_, other->_impl_.execution_count_);
}

std::string ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo.ScriptInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo>()._impl_._has_bits_);
    static void set_has_max_exceeded_script_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo)
}
ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo(
    const ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.scripts_) { from._impl_.scripts_ }, decltype(_impl_.max_exceeded_script_count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.max_exceeded_script_count_ = from._impl_.max_exceeded_script_count_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.scripts_) { arena },
        decltype(_impl_.max_exceeded_script_count_) { 0u } };
}

ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::~ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.scripts_.~RepeatedPtrField();
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.scripts_.Clear();
    _impl_.max_exceeded_script_count_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo.ScriptInfo scripts = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_scripts(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional uint32 max_exceeded_script_count = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_max_exceeded_script_count(&has_bits);
                _impl_.max_exceeded_script_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo.ScriptInfo scripts = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_scripts_size()); i < n; i++) {
        const auto& repfield = this->_internal_scripts(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 max_exceeded_script_count = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_max_exceeded_script_count(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo.ScriptInfo scripts = 1;
    total_size += 1UL * this->_internal_scripts_size();
    for (const auto& msg : this->_impl_.scripts_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional uint32 max_exceeded_script_count = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_exceeded_script_count());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::MergeFrom(const ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.scripts_.MergeFrom(from._impl_.scripts_);
    if (from._internal_has_max_exceeded_script_count()) {
        _this->_internal_set_max_exceeded_script_count(from._internal_max_exceeded_script_count());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::CopyFrom(const ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::InternalSwap(ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.scripts_.InternalSwap(&other->_impl_.scripts_);
    swap(_impl_.max_exceeded_script_count_, other->_impl_.max_exceeded_script_count_);
}

std::string ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_contact_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_connection_protocol(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_contacted_by(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo)
}
ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo(
        const ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {},
        decltype(_impl_.contact_count_) {}, decltype(_impl_.connection_protocol_) {}, decltype(_impl_.contacted_by_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.contact_count_, &from._impl_.contact_count_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.contacted_by_) - reinterpret_cast<char*>(&_impl_.contact_count_)) + sizeof(_impl_.contacted_by_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {},
        decltype(_impl_.contact_count_) { 0u }, decltype(_impl_.connection_protocol_) { 0 }, decltype(_impl_.contacted_by_) { 0 } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::
    ~ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
}

void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x0000000eu) {
        ::memset(&_impl_.contact_count_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.contacted_by_) - reinterpret_cast<char*>(&_impl_.contact_count_))
                + sizeof(_impl_.contacted_by_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 contact_count = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_contact_count(&has_bits);
                _impl_.contact_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo.ProtocolType connection_protocol = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(
                        ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType_IsValid(val))) {
                    _internal_set_connection_protocol(
                        static_cast<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ProtocolType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo.ContactInitiator contacted_by = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(
                        ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator_IsValid(val))) {
                    _internal_set_contacted_by(
                        static_cast<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo_ContactInitiator>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // optional uint32 contact_count = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_contact_count(), target);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo.ProtocolType connection_protocol = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_connection_protocol(), target);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo.ContactInitiator contacted_by = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_contacted_by(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional uint32 contact_count = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_contact_count());
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo.ProtocolType connection_protocol = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_connection_protocol());
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo.ContactInitiator contacted_by = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_contacted_by());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::MergeFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.contact_count_ = from._impl_.contact_count_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.connection_protocol_ = from._impl_.connection_protocol_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.contacted_by_ = from._impl_.contacted_by_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::CopyFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::InternalSwap(
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(
                                                   ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo, _impl_.contacted_by_)
        + sizeof(ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::_impl_.contacted_by_)
        - PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo, _impl_.contact_count_)>(
        reinterpret_cast<char*>(&_impl_.contact_count_), reinterpret_cast<char*>(&other->_impl_.contact_count_));
}

std::string ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo>()._impl_._has_bits_);
    static void set_has_collected_from_new_interception(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo)
}
ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo(
    const ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.remote_host_) { from._impl_.remote_host_ }, decltype(_impl_.collected_from_new_interception_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.collected_from_new_interception_ = from._impl_.collected_from_new_interception_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.remote_host_) { arena },
        decltype(_impl_.collected_from_new_interception_) { false } };
}

ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::~ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.remote_host_.~RepeatedPtrField();
}

void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.remote_host_.Clear();
    _impl_.collected_from_new_interception_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo remote_host = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_remote_host(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool collected_from_new_interception = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_collected_from_new_interception(&has_bits);
                _impl_.collected_from_new_interception_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo remote_host = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_remote_host_size()); i < n; i++) {
        const auto& repfield = this->_internal_remote_host(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool collected_from_new_interception = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_collected_from_new_interception(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo.RemoteHostInfo remote_host = 1;
    total_size += 1UL * this->_internal_remote_host_size();
    for (const auto& msg : this->_impl_.remote_host_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional bool collected_from_new_interception = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + 1;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::MergeFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.remote_host_.MergeFrom(from._impl_.remote_host_);
    if (from._internal_has_collected_from_new_interception()) {
        _this->_internal_set_collected_from_new_interception(from._internal_collected_from_new_interception());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::CopyFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::InternalSwap(ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.remote_host_.InternalSwap(&other->_impl_.remote_host_);
    swap(_impl_.collected_from_new_interception_, other->_impl_.collected_from_new_interception_);
}

std::string ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo>()._impl_._has_bits_);
    static void set_has_domain(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_path(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_secure(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_store_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_is_session(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo.GetAllArgsInfo)
}
ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo(
    const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.js_callstacks_) { from._impl_.js_callstacks_ }, decltype(_impl_.domain_) {}, decltype(_impl_.name_) {}, decltype(_impl_.path_) {},
        decltype(_impl_.store_id_) {}, decltype(_impl_.url_) {}, decltype(_impl_.secure_) {}, decltype(_impl_.is_session_) {}, decltype(_impl_.count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.domain_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_domain()) {
        _this->_impl_.domain_.Set(from._internal_domain(), _this->GetArenaForAllocation());
    }
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_path()) {
        _this->_impl_.path_.Set(from._internal_path(), _this->GetArenaForAllocation());
    }
    _impl_.store_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_store_id()) {
        _this->_impl_.store_id_.Set(from._internal_store_id(), _this->GetArenaForAllocation());
    }
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.secure_, &from._impl_.secure_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) - reinterpret_cast<char*>(&_impl_.secure_)) + sizeof(_impl_.count_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo.GetAllArgsInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.js_callstacks_) { arena },
        decltype(_impl_.domain_) {}, decltype(_impl_.name_) {}, decltype(_impl_.path_) {}, decltype(_impl_.store_id_) {}, decltype(_impl_.url_) {},
        decltype(_impl_.secure_) { false }, decltype(_impl_.is_session_) { false }, decltype(_impl_.count_) { 0u } };
    _impl_.domain_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.domain_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::~ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo.GetAllArgsInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.js_callstacks_.~RepeatedPtrField();
    _impl_.domain_.Destroy();
    _impl_.name_.Destroy();
    _impl_.path_.Destroy();
    _impl_.store_id_.Destroy();
    _impl_.url_.Destroy();
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo.GetAllArgsInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.js_callstacks_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.domain_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.path_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.store_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x000000e0u) {
        ::memset(&_impl_.secure_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) - reinterpret_cast<char*>(&_impl_.secure_)) + sizeof(_impl_.count_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string domain = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_domain();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string path = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_path();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool secure = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_secure(&has_bits);
                _impl_.secure_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string store_id = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_store_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string url = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 count = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_count(&has_bits);
                _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_session = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _Internal::set_has_is_session(&has_bits);
                _impl_.is_session_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack js_callstacks = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_js_callstacks(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo.GetAllArgsInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string domain = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_domain(), target);
    }

    // optional string name = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_name(), target);
    }

    // optional string path = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_path(), target);
    }

    // optional bool secure = 4;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_secure(), target);
    }

    // optional string store_id = 6;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(6, this->_internal_store_id(), target);
    }

    // optional string url = 7;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_url(), target);
    }

    // optional uint32 count = 8;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_count(), target);
    }

    // optional bool is_session = 9;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_is_session(), target);
    }

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack js_callstacks = 10;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_js_callstacks_size()); i < n; i++) {
        const auto& repfield = this->_internal_js_callstacks(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo.GetAllArgsInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo.GetAllArgsInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack js_callstacks = 10;
    total_size += 1UL * this->_internal_js_callstacks_size();
    for (const auto& msg : this->_impl_.js_callstacks_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string domain = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_domain());
        }

        // optional string name = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string path = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_path());
        }

        // optional string store_id = 6;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_store_id());
        }

        // optional string url = 7;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional bool secure = 4;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 1;
        }

        // optional bool is_session = 9;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + 1;
        }

        // optional uint32 count = 8;
        if (cached_has_bits & 0x00000080u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::MergeFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo.GetAllArgsInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.js_callstacks_.MergeFrom(from._impl_.js_callstacks_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_domain(from._internal_domain());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_path(from._internal_path());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_store_id(from._internal_store_id());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.secure_ = from._impl_.secure_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.is_session_ = from._impl_.is_session_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.count_ = from._impl_.count_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::CopyFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo.GetAllArgsInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::InternalSwap(
    ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.js_callstacks_.InternalSwap(&other->_impl_.js_callstacks_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.domain_, lhs_arena, &other->_impl_.domain_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.path_, lhs_arena, &other->_impl_.path_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.store_id_, lhs_arena, &other->_impl_.store_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo, _impl_.count_)
        + sizeof(ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::_impl_.count_)
        - PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo, _impl_.secure_)>(
        reinterpret_cast<char*>(&_impl_.secure_), reinterpret_cast<char*>(&other->_impl_.secure_));
}

std::string ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo.GetAllArgsInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo>()._impl_._has_bits_);
    static void set_has_max_exceeded_args_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo)
}
ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo(
    const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.get_all_args_info_) { from._impl_.get_all_args_info_ }, decltype(_impl_.max_exceeded_args_count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.max_exceeded_args_count_ = from._impl_.max_exceeded_args_count_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.get_all_args_info_) { arena },
        decltype(_impl_.max_exceeded_args_count_) { 0u } };
}

ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::~ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.get_all_args_info_.~RepeatedPtrField();
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.get_all_args_info_.Clear();
    _impl_.max_exceeded_args_count_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo.GetAllArgsInfo get_all_args_info = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_get_all_args_info(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional uint32 max_exceeded_args_count = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_max_exceeded_args_count(&has_bits);
                _impl_.max_exceeded_args_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo.GetAllArgsInfo get_all_args_info = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_get_all_args_info_size()); i < n; i++) {
        const auto& repfield = this->_internal_get_all_args_info(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 max_exceeded_args_count = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_max_exceeded_args_count(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo.GetAllArgsInfo get_all_args_info = 1;
    total_size += 1UL * this->_internal_get_all_args_info_size();
    for (const auto& msg : this->_impl_.get_all_args_info_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional uint32 max_exceeded_args_count = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_exceeded_args_count());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::MergeFrom(const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.get_all_args_info_.MergeFrom(from._impl_.get_all_args_info_);
    if (from._internal_has_max_exceeded_args_count()) {
        _this->_internal_set_max_exceeded_args_count(from._internal_max_exceeded_args_count());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::CopyFrom(const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::InternalSwap(ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.get_all_args_info_.InternalSwap(&other->_impl_.get_all_args_info_);
    swap(_impl_.max_exceeded_args_count_, other->_impl_.max_exceeded_args_count_);
}

std::string ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_store_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo.GetArgsInfo)
}
ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo(
    const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.js_callstacks_) { from._impl_.js_callstacks_ }, decltype(_impl_.name_) {}, decltype(_impl_.url_) {}, decltype(_impl_.store_id_) {},
        decltype(_impl_.count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _impl_.store_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_store_id()) {
        _this->_impl_.store_id_.Set(from._internal_store_id(), _this->GetArenaForAllocation());
    }
    _this->_impl_.count_ = from._impl_.count_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo.GetArgsInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.js_callstacks_) { arena },
        decltype(_impl_.name_) {}, decltype(_impl_.url_) {}, decltype(_impl_.store_id_) {}, decltype(_impl_.count_) { 0u } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::~ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo.GetArgsInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.js_callstacks_.~RepeatedPtrField();
    _impl_.name_.Destroy();
    _impl_.url_.Destroy();
    _impl_.store_id_.Destroy();
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo.GetArgsInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.js_callstacks_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.store_id_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.count_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string url = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string store_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_store_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack js_callstacks = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_js_callstacks(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional uint32 count = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_count(&has_bits);
                _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo.GetArgsInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional string url = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_url(), target);
    }

    // optional string store_id = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_store_id(), target);
    }

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack js_callstacks = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_js_callstacks_size()); i < n; i++) {
        const auto& repfield = this->_internal_js_callstacks(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional uint32 count = 8;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_count(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo.GetArgsInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo.GetArgsInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack js_callstacks = 4;
    total_size += 1UL * this->_internal_js_callstacks_size();
    for (const auto& msg : this->_impl_.js_callstacks_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string url = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional string store_id = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_store_id());
        }

        // optional uint32 count = 8;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::MergeFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo.GetArgsInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.js_callstacks_.MergeFrom(from._impl_.js_callstacks_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_store_id(from._internal_store_id());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.count_ = from._impl_.count_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::CopyFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo.GetArgsInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::InternalSwap(
    ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.js_callstacks_.InternalSwap(&other->_impl_.js_callstacks_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.store_id_, lhs_arena, &other->_impl_.store_id_, rhs_arena);
    swap(_impl_.count_, other->_impl_.count_);
}

std::string ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo.GetArgsInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo>()._impl_._has_bits_);
    static void set_has_max_exceeded_args_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo)
}
ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo(
    const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.get_args_info_) { from._impl_.get_args_info_ }, decltype(_impl_.max_exceeded_args_count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.max_exceeded_args_count_ = from._impl_.max_exceeded_args_count_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.get_args_info_) { arena },
        decltype(_impl_.max_exceeded_args_count_) { 0u } };
}

ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::~ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.get_args_info_.~RepeatedPtrField();
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.get_args_info_.Clear();
    _impl_.max_exceeded_args_count_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo.GetArgsInfo get_args_info = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_get_args_info(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional uint32 max_exceeded_args_count = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_max_exceeded_args_count(&has_bits);
                _impl_.max_exceeded_args_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo.GetArgsInfo get_args_info = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_get_args_info_size()); i < n; i++) {
        const auto& repfield = this->_internal_get_args_info(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 max_exceeded_args_count = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_max_exceeded_args_count(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo.GetArgsInfo get_args_info = 1;
    total_size += 1UL * this->_internal_get_args_info_size();
    for (const auto& msg : this->_impl_.get_args_info_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional uint32 max_exceeded_args_count = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_exceeded_args_count());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::MergeFrom(const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.get_args_info_.MergeFrom(from._impl_.get_args_info_);
    if (from._internal_has_max_exceeded_args_count()) {
        _this->_internal_set_max_exceeded_args_count(from._internal_max_exceeded_args_count());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::CopyFrom(const ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::InternalSwap(ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.get_args_info_.InternalSwap(&other->_impl_.get_args_info_);
    swap(_impl_.max_exceeded_args_count_, other->_impl_.max_exceeded_args_count_);
}

std::string ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo>()._impl_._has_bits_);
    static void set_has_remote_host_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostInfo)
}
ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo(
        const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.remote_host_url_) {},
        decltype(_impl_.count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.remote_host_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_host_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_remote_host_url()) {
        _this->_impl_.remote_host_url_.Set(from._internal_remote_host_url(), _this->GetArenaForAllocation());
    }
    _this->_impl_.count_ = from._impl_.count_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.remote_host_url_) {}, decltype(_impl_.count_) { 0u } };
    _impl_.remote_host_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_host_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::
    ~ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.remote_host_url_.Destroy();
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.remote_host_url_.ClearNonDefaultToEmpty();
    }
    _impl_.count_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string remote_host_url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_remote_host_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 count = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_count(&has_bits);
                _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string remote_host_url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_remote_host_url(), target);
    }

    // optional uint32 count = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_count(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string remote_host_url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_remote_host_url());
        }

        // optional uint32 count = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::MergeFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_remote_host_url(from._internal_remote_host_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.count_ = from._impl_.count_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::CopyFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::InternalSwap(
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.remote_host_url_, lhs_arena, &other->_impl_.remote_host_url_, rhs_arena);
    swap(_impl_.count_, other->_impl_.count_);
}

std::string ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType>()
                                 ._impl_._has_bits_);
    static void set_has_is_account_syncing(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_account_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType(
        ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType)
}
ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType(
        const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.is_account_syncing_) {}, decltype(_impl_.account_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.is_account_syncing_, &from._impl_.is_account_syncing_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.account_type_) - reinterpret_cast<char*>(&_impl_.is_account_syncing_))
            + sizeof(_impl_.account_type_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.is_account_syncing_) { false },
        decltype(_impl_.account_type_) { 0 } };
}

ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::
    ~ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.is_account_syncing_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.account_type_) - reinterpret_cast<char*>(&_impl_.is_account_syncing_))
                + sizeof(_impl_.account_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bool is_account_syncing = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_is_account_syncing(&has_bits);
                _impl_.is_account_syncing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType.AccountType account_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::
                            ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType_IsValid(
                                val))) {
                    _internal_set_account_type(static_cast<::safe_browsing::
                            ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType_AccountType>(
                        val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool is_account_syncing = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_account_syncing(), target);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType.AccountType account_type = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_account_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional bool is_account_syncing = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 1;
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType.AccountType account_type = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_account_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(
        *::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::MergeFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.is_account_syncing_ = from._impl_.is_account_syncing_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.account_type_ = from._impl_.account_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::CopyFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::InternalSwap(
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<
        PROTOBUF_FIELD_OFFSET(
            ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType, _impl_.account_type_)
        + sizeof(ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::_impl_.account_type_)
        - PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType,
            _impl_.is_account_syncing_)>(reinterpret_cast<char*>(&_impl_.is_account_syncing_), reinterpret_cast<char*>(&other->_impl_.is_account_syncing_));
}

std::string ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo>()._impl_._has_bits_);
    static void set_has_is_chrome_signin_password(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType&
    reused_password_account_type(const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo* msg);
    static void set_has_reused_password_account_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType&
ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::_Internal::reused_password_account_type(
    const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo* msg)
{
    return *msg->_impl_.reused_password_account_type_;
}
ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo)
}
ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo(
        const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.domains_matching_password_) { from._impl_.domains_matching_password_ }, decltype(_impl_.reused_password_account_type_) { nullptr },
        decltype(_impl_.is_chrome_signin_password_) {}, decltype(_impl_.count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_reused_password_account_type()) {
        _this->_impl_.reused_password_account_type_
            = new ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType(
                *from._impl_.reused_password_account_type_);
    }
    ::memcpy(&_impl_.is_chrome_signin_password_, &from._impl_.is_chrome_signin_password_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) - reinterpret_cast<char*>(&_impl_.is_chrome_signin_password_)) + sizeof(_impl_.count_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.domains_matching_password_) { arena },
        decltype(_impl_.reused_password_account_type_) { nullptr }, decltype(_impl_.is_chrome_signin_password_) { false }, decltype(_impl_.count_) { 0u } };
}

ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::
    ~ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.domains_matching_password_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.reused_password_account_type_;
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.domains_matching_password_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.reused_password_account_type_ != nullptr);
        _impl_.reused_password_account_type_->Clear();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.is_chrome_signin_password_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) - reinterpret_cast<char*>(&_impl_.is_chrome_signin_password_)) + sizeof(_impl_.count_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated string domains_matching_password = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_domains_matching_password();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool is_chrome_signin_password = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_is_chrome_signin_password(&has_bits);
                _impl_.is_chrome_signin_password_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType reused_password_account_type = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_reused_password_account_type(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 count = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_count(&has_bits);
                _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated string domains_matching_password = 1;
    for (int i = 0, n = this->_internal_domains_matching_password_size(); i < n; i++) {
        const auto& s = this->_internal_domains_matching_password(i);
        target = stream->WriteString(1, s, target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool is_chrome_signin_password = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_chrome_signin_password(), target);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType reused_password_account_type = 3;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::reused_password_account_type(this), _Internal::reused_password_account_type(this).GetCachedSize(), target, stream);
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_count(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string domains_matching_password = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.domains_matching_password_.size());
    for (int i = 0, n = _impl_.domains_matching_password_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.domains_matching_password_.Get(i));
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo.ReusedPasswordAccountType reused_password_account_type = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.reused_password_account_type_);
        }

        // optional bool is_chrome_signin_password = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }

        // optional uint32 count = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::MergeFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.domains_matching_password_.MergeFrom(from._impl_.domains_matching_password_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_reused_password_account_type()
                ->::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType::MergeFrom(
                    from._internal_reused_password_account_type());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.is_chrome_signin_password_ = from._impl_.is_chrome_signin_password_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.count_ = from._impl_.count_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::CopyFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::InternalSwap(
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.domains_matching_password_.InternalSwap(&other->_impl_.domains_matching_password_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(
                                                   ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo, _impl_.count_)
        + sizeof(ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::_impl_.count_)
        - PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo, _impl_.reused_password_account_type_)>(
        reinterpret_cast<char*>(&_impl_.reused_password_account_type_), reinterpret_cast<char*>(&other->_impl_.reused_password_account_type_));
}

std::string ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData>()._impl_._has_bits_);
    static void set_has_remote_host_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostData)
}
ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData(
        const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.remote_host_url_) {},
        decltype(_impl_.count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.remote_host_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_host_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_remote_host_url()) {
        _this->_impl_.remote_host_url_.Set(from._internal_remote_host_url(), _this->GetArenaForAllocation());
    }
    _this->_impl_.count_ = from._impl_.count_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostData)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.remote_host_url_) {}, decltype(_impl_.count_) { 0u } };
    _impl_.remote_host_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_host_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::
    ~ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.remote_host_url_.Destroy();
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.remote_host_url_.ClearNonDefaultToEmpty();
    }
    _impl_.count_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string remote_host_url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_remote_host_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 count = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_count(&has_bits);
                _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string remote_host_url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_remote_host_url(), target);
    }

    // optional uint32 count = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_count(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostData)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string remote_host_url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_remote_host_url());
        }

        // optional uint32 count = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::MergeFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_remote_host_url(from._internal_remote_host_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.count_ = from._impl_.count_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::CopyFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::InternalSwap(
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.remote_host_url_, lhs_arena, &other->_impl_.remote_host_url_, rhs_arena);
    swap(_impl_.count_, other->_impl_.count_);
}

std::string ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostData";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::_Internal {
public:
};

ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo)
}
ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo(
    const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_.remote_hosts_) { from._impl_.remote_hosts_ }, decltype(_impl_.reused_password_infos_) { from._impl_.reused_password_infos_ },
            decltype(_impl_.remote_hosts_data_) { from._impl_.remote_hosts_data_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.remote_hosts_) { arena }, decltype(_impl_.reused_password_infos_) { arena },
        decltype(_impl_.remote_hosts_data_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::~ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.remote_hosts_.~RepeatedPtrField();
    _impl_.reused_password_infos_.~RepeatedPtrField();
    _impl_.remote_hosts_data_.~RepeatedPtrField();
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.remote_hosts_.Clear();
    _impl_.reused_password_infos_.Clear();
    _impl_.remote_hosts_data_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostInfo remote_hosts = 1 [deprecated = true];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_remote_hosts(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo reused_password_infos = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_reused_password_infos(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostData remote_hosts_data = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_remote_hosts_data(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostInfo remote_hosts = 1 [deprecated = true];
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_remote_hosts_size()); i < n; i++) {
        const auto& repfield = this->_internal_remote_hosts(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo reused_password_infos = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_reused_password_infos_size()); i < n; i++) {
        const auto& repfield = this->_internal_reused_password_infos(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostData remote_hosts_data = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_remote_hosts_data_size()); i < n; i++) {
        const auto& repfield = this->_internal_remote_hosts_data(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostInfo remote_hosts = 1 [deprecated = true];
    total_size += 1UL * this->_internal_remote_hosts_size();
    for (const auto& msg : this->_impl_.remote_hosts_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.PasswordReuseInfo reused_password_infos = 2;
    total_size += 1UL * this->_internal_reused_password_infos_size();
    for (const auto& msg : this->_impl_.reused_password_infos_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo.RemoteHostData remote_hosts_data = 3;
    total_size += 1UL * this->_internal_remote_hosts_data_size();
    for (const auto& msg : this->_impl_.remote_hosts_data_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::MergeFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.remote_hosts_.MergeFrom(from._impl_.remote_hosts_);
    _this->_impl_.reused_password_infos_.MergeFrom(from._impl_.reused_password_infos_);
    _this->_impl_.remote_hosts_data_.MergeFrom(from._impl_.remote_hosts_data_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::CopyFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::InternalSwap(
    ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.remote_hosts_.InternalSwap(&other->_impl_.remote_hosts_);
    _impl_.reused_password_infos_.InternalSwap(&other->_impl_.reused_password_infos_);
    _impl_.remote_hosts_data_.InternalSwap(&other->_impl_.remote_hosts_data_);
}

std::string ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo>()._impl_._has_bits_);
    static void set_has_max_exceeded_rules_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestInfo)
}
ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo(
    const ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.rules_) { from._impl_.rules_ }, decltype(_impl_.max_exceeded_rules_count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.max_exceeded_rules_count_ = from._impl_.max_exceeded_rules_count_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.rules_) { arena },
        decltype(_impl_.max_exceeded_rules_count_) { 0u } };
}

ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::~ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.rules_.~RepeatedPtrField();
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.rules_.Clear();
    _impl_.max_exceeded_rules_count_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated string rules = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_rules();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional uint32 max_exceeded_rules_count = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_max_exceeded_rules_count(&has_bits);
                _impl_.max_exceeded_rules_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated string rules = 1;
    for (int i = 0, n = this->_internal_rules_size(); i < n; i++) {
        const auto& s = this->_internal_rules(i);
        target = stream->WriteString(1, s, target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 max_exceeded_rules_count = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_max_exceeded_rules_count(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string rules = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.rules_.size());
    for (int i = 0, n = _impl_.rules_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.rules_.Get(i));
    }

    // optional uint32 max_exceeded_rules_count = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_exceeded_rules_count());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::MergeFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.rules_.MergeFrom(from._impl_.rules_);
    if (from._internal_has_max_exceeded_rules_count()) {
        _this->_internal_set_max_exceeded_rules_count(from._internal_max_exceeded_rules_count());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::CopyFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::InternalSwap(
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.rules_.InternalSwap(&other->_impl_.rules_);
    swap(_impl_.max_exceeded_rules_count_, other->_impl_.max_exceeded_rules_count_);
}

std::string ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails>()._impl_._has_bits_);
    static void set_has_method(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_new_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_current_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.CallDetails)
}
ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails(
    const ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.js_callstacks_) { from._impl_.js_callstacks_ }, decltype(_impl_.new_url_) {}, decltype(_impl_.current_url_) {},
        decltype(_impl_.method_) {}, decltype(_impl_.count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.new_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_new_url()) {
        _this->_impl_.new_url_.Set(from._internal_new_url(), _this->GetArenaForAllocation());
    }
    _impl_.current_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_current_url()) {
        _this->_impl_.current_url_.Set(from._internal_current_url(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.method_, &from._impl_.method_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) - reinterpret_cast<char*>(&_impl_.method_)) + sizeof(_impl_.count_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.CallDetails)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.js_callstacks_) { arena },
        decltype(_impl_.new_url_) {}, decltype(_impl_.current_url_) {}, decltype(_impl_.method_) { 0 }, decltype(_impl_.count_) { 0u } };
    _impl_.new_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.new_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::~ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.CallDetails)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.js_callstacks_.~RepeatedPtrField();
    _impl_.new_url_.Destroy();
    _impl_.current_url_.Destroy();
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.CallDetails)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.js_callstacks_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.new_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.current_url_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000000cu) {
        ::memset(&_impl_.method_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) - reinterpret_cast<char*>(&_impl_.method_)) + sizeof(_impl_.count_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.ApiMethod method = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod_IsValid(val))) {
                    _internal_set_method(static_cast<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_ApiMethod>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string new_url = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_new_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string current_url = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_current_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 count = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_count(&has_bits);
                _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack js_callstacks = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_js_callstacks(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.CallDetails)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.ApiMethod method = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_method(), target);
    }

    // optional string new_url = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_new_url(), target);
    }

    // optional string current_url = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_current_url(), target);
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_count(), target);
    }

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack js_callstacks = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_js_callstacks_size()); i < n; i++) {
        const auto& repfield = this->_internal_js_callstacks(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.CallDetails)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.CallDetails)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.JSCallStack js_callstacks = 5;
    total_size += 1UL * this->_internal_js_callstacks_size();
    for (const auto& msg : this->_impl_.js_callstacks_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string new_url = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_new_url());
        }

        // optional string current_url = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_current_url());
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.ApiMethod method = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_method());
        }

        // optional uint32 count = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::MergeFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.CallDetails)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.js_callstacks_.MergeFrom(from._impl_.js_callstacks_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_new_url(from._internal_new_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_current_url(from._internal_current_url());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.method_ = from._impl_.method_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.count_ = from._impl_.count_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::CopyFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.CallDetails)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::InternalSwap(ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.js_callstacks_.InternalSwap(&other->_impl_.js_callstacks_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.new_url_, lhs_arena, &other->_impl_.new_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.current_url_, lhs_arena, &other->_impl_.current_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails, _impl_.count_)
        + sizeof(ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::_impl_.count_)
        - PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails, _impl_.method_)>(
        reinterpret_cast<char*>(&_impl_.method_), reinterpret_cast<char*>(&other->_impl_.method_));
}

std::string ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.CallDetails";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::_Internal {
public:
};

ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo)
}
ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo(
    const ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.call_details_) { from._impl_.call_details_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.call_details_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::~ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.call_details_.~RepeatedPtrField();
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.call_details_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.CallDetails call_details = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_call_details(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.CallDetails call_details = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_call_details_size()); i < n; i++) {
        const auto& repfield = this->_internal_call_details(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo.CallDetails call_details = 1;
    total_size += 1UL * this->_internal_call_details_size();
    for (const auto& msg : this->_impl_.call_details_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::MergeFrom(const ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.call_details_.MergeFrom(from._impl_.call_details_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::CopyFrom(const ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::InternalSwap(ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.call_details_.InternalSwap(&other->_impl_.call_details_);
}

std::string ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails>()._impl_._has_bits_);
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_request_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_redirect_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionDetails)
}
ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails(
        const ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.request_url_) {},
        decltype(_impl_.redirect_url_) {}, decltype(_impl_.type_) {}, decltype(_impl_.count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.request_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_request_url()) {
        _this->_impl_.request_url_.Set(from._internal_request_url(), _this->GetArenaForAllocation());
    }
    _impl_.redirect_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.redirect_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_redirect_url()) {
        _this->_impl_.redirect_url_.Set(from._internal_redirect_url(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.type_, &from._impl_.type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) - reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.count_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionDetails)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.request_url_) {},
        decltype(_impl_.redirect_url_) {}, decltype(_impl_.type_) { 0 }, decltype(_impl_.count_) { 0u } };
    _impl_.request_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.request_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.redirect_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.redirect_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::
    ~ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionDetails)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.request_url_.Destroy();
    _impl_.redirect_url_.Destroy();
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionDetails)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.request_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.redirect_url_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000000cu) {
        ::memset(
            &_impl_.type_, 0, static_cast<size_t>(reinterpret_cast<char*>(&_impl_.count_) - reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.count_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionType type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(
                        ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType_IsValid(val))) {
                    _internal_set_type(
                        static_cast<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string request_url = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_request_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string redirect_url = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_redirect_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 count = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_count(&has_bits);
                _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionDetails)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionType type = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_type(), target);
    }

    // optional string request_url = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_request_url(), target);
    }

    // optional string redirect_url = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_redirect_url(), target);
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_count(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionDetails)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionDetails)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string request_url = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_request_url());
        }

        // optional string redirect_url = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_redirect_url());
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionType type = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }

        // optional uint32 count = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::MergeFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionDetails)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_request_url(from._internal_request_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_redirect_url(from._internal_redirect_url());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.count_ = from._impl_.count_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::CopyFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionDetails)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::InternalSwap(
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.request_url_, lhs_arena, &other->_impl_.request_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.redirect_url_, lhs_arena, &other->_impl_.redirect_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(
                                                   ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails, _impl_.count_)
        + sizeof(ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::_impl_.count_)
        - PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails, _impl_.type_)>(
        reinterpret_cast<char*>(&_impl_.type_), reinterpret_cast<char*>(&other->_impl_.type_));
}

std::string ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionDetails";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::_Internal {
public:
};

ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo)
}
ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo(
    const ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.action_details_) { from._impl_.action_details_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.action_details_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::~ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.action_details_.~RepeatedPtrField();
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.action_details_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionDetails action_details = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_action_details(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionDetails action_details = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_action_details_size()); i < n; i++) {
        const auto& repfield = this->_internal_action_details(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo.ActionDetails action_details = 1;
    total_size += 1UL * this->_internal_action_details_size();
    for (const auto& msg : this->_impl_.action_details_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::MergeFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.action_details_.MergeFrom(from._impl_.action_details_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::CopyFrom(
    const ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::InternalSwap(
    ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.action_details_.InternalSwap(&other->_impl_.action_details_);
}

std::string ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_SignalInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_SignalInfo>()._impl_._has_bits_);
    static const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo& tabs_execute_script_info(
        const ExtensionTelemetryReportRequest_SignalInfo* msg);
    static void set_has_tabs_execute_script_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo& remote_host_contacted_info(
        const ExtensionTelemetryReportRequest_SignalInfo* msg);
    static void set_has_remote_host_contacted_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo& cookies_get_all_info(
        const ExtensionTelemetryReportRequest_SignalInfo* msg);
    static void set_has_cookies_get_all_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo& cookies_get_info(
        const ExtensionTelemetryReportRequest_SignalInfo* msg);
    static void set_has_cookies_get_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo& potential_password_theft_info(
        const ExtensionTelemetryReportRequest_SignalInfo* msg);
    static void set_has_potential_password_theft_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo& declarative_net_request_info(
        const ExtensionTelemetryReportRequest_SignalInfo* msg);
    static void set_has_declarative_net_request_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo& tabs_api_info(const ExtensionTelemetryReportRequest_SignalInfo* msg);
    static void set_has_tabs_api_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo& declarative_net_request_action_info(
        const ExtensionTelemetryReportRequest_SignalInfo* msg);
    static void set_has_declarative_net_request_action_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
};

const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo&
ExtensionTelemetryReportRequest_SignalInfo::_Internal::tabs_execute_script_info(const ExtensionTelemetryReportRequest_SignalInfo* msg)
{
    return *msg->_impl_.tabs_execute_script_info_;
}
const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo&
ExtensionTelemetryReportRequest_SignalInfo::_Internal::remote_host_contacted_info(const ExtensionTelemetryReportRequest_SignalInfo* msg)
{
    return *msg->_impl_.remote_host_contacted_info_;
}
const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo&
ExtensionTelemetryReportRequest_SignalInfo::_Internal::cookies_get_all_info(const ExtensionTelemetryReportRequest_SignalInfo* msg)
{
    return *msg->_impl_.cookies_get_all_info_;
}
const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo& ExtensionTelemetryReportRequest_SignalInfo::_Internal::cookies_get_info(
    const ExtensionTelemetryReportRequest_SignalInfo* msg)
{
    return *msg->_impl_.cookies_get_info_;
}
const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo&
ExtensionTelemetryReportRequest_SignalInfo::_Internal::potential_password_theft_info(const ExtensionTelemetryReportRequest_SignalInfo* msg)
{
    return *msg->_impl_.potential_password_theft_info_;
}
const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo&
ExtensionTelemetryReportRequest_SignalInfo::_Internal::declarative_net_request_info(const ExtensionTelemetryReportRequest_SignalInfo* msg)
{
    return *msg->_impl_.declarative_net_request_info_;
}
const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo& ExtensionTelemetryReportRequest_SignalInfo::_Internal::tabs_api_info(
    const ExtensionTelemetryReportRequest_SignalInfo* msg)
{
    return *msg->_impl_.tabs_api_info_;
}
const ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo&
ExtensionTelemetryReportRequest_SignalInfo::_Internal::declarative_net_request_action_info(const ExtensionTelemetryReportRequest_SignalInfo* msg)
{
    return *msg->_impl_.declarative_net_request_action_info_;
}
ExtensionTelemetryReportRequest_SignalInfo::ExtensionTelemetryReportRequest_SignalInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo)
}
ExtensionTelemetryReportRequest_SignalInfo::ExtensionTelemetryReportRequest_SignalInfo(const ExtensionTelemetryReportRequest_SignalInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_SignalInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.tabs_execute_script_info_) { nullptr }, decltype(_impl_.remote_host_contacted_info_) { nullptr },
        decltype(_impl_.cookies_get_all_info_) { nullptr }, decltype(_impl_.cookies_get_info_) { nullptr },
        decltype(_impl_.potential_password_theft_info_) { nullptr }, decltype(_impl_.declarative_net_request_info_) { nullptr },
        decltype(_impl_.tabs_api_info_) { nullptr }, decltype(_impl_.declarative_net_request_action_info_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_tabs_execute_script_info()) {
        _this->_impl_.tabs_execute_script_info_
            = new ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo(*from._impl_.tabs_execute_script_info_);
    }
    if (from._internal_has_remote_host_contacted_info()) {
        _this->_impl_.remote_host_contacted_info_
            = new ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo(*from._impl_.remote_host_contacted_info_);
    }
    if (from._internal_has_cookies_get_all_info()) {
        _this->_impl_.cookies_get_all_info_
            = new ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo(*from._impl_.cookies_get_all_info_);
    }
    if (from._internal_has_cookies_get_info()) {
        _this->_impl_.cookies_get_info_ = new ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo(*from._impl_.cookies_get_info_);
    }
    if (from._internal_has_potential_password_theft_info()) {
        _this->_impl_.potential_password_theft_info_
            = new ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo(*from._impl_.potential_password_theft_info_);
    }
    if (from._internal_has_declarative_net_request_info()) {
        _this->_impl_.declarative_net_request_info_
            = new ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo(*from._impl_.declarative_net_request_info_);
    }
    if (from._internal_has_tabs_api_info()) {
        _this->_impl_.tabs_api_info_ = new ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo(*from._impl_.tabs_api_info_);
    }
    if (from._internal_has_declarative_net_request_action_info()) {
        _this->_impl_.declarative_net_request_action_info_ = new ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo(
            *from._impl_.declarative_net_request_action_info_);
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo)
}

inline void ExtensionTelemetryReportRequest_SignalInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.tabs_execute_script_info_) { nullptr },
        decltype(_impl_.remote_host_contacted_info_) { nullptr }, decltype(_impl_.cookies_get_all_info_) { nullptr },
        decltype(_impl_.cookies_get_info_) { nullptr }, decltype(_impl_.potential_password_theft_info_) { nullptr },
        decltype(_impl_.declarative_net_request_info_) { nullptr }, decltype(_impl_.tabs_api_info_) { nullptr },
        decltype(_impl_.declarative_net_request_action_info_) { nullptr } };
}

ExtensionTelemetryReportRequest_SignalInfo::~ExtensionTelemetryReportRequest_SignalInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_SignalInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.tabs_execute_script_info_;
    if (this != internal_default_instance())
        delete _impl_.remote_host_contacted_info_;
    if (this != internal_default_instance())
        delete _impl_.cookies_get_all_info_;
    if (this != internal_default_instance())
        delete _impl_.cookies_get_info_;
    if (this != internal_default_instance())
        delete _impl_.potential_password_theft_info_;
    if (this != internal_default_instance())
        delete _impl_.declarative_net_request_info_;
    if (this != internal_default_instance())
        delete _impl_.tabs_api_info_;
    if (this != internal_default_instance())
        delete _impl_.declarative_net_request_action_info_;
}

void ExtensionTelemetryReportRequest_SignalInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_SignalInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.tabs_execute_script_info_ != nullptr);
            _impl_.tabs_execute_script_info_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.remote_host_contacted_info_ != nullptr);
            _impl_.remote_host_contacted_info_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.cookies_get_all_info_ != nullptr);
            _impl_.cookies_get_all_info_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.cookies_get_info_ != nullptr);
            _impl_.cookies_get_info_->Clear();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.potential_password_theft_info_ != nullptr);
            _impl_.potential_password_theft_info_->Clear();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.declarative_net_request_info_ != nullptr);
            _impl_.declarative_net_request_info_->Clear();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.tabs_api_info_ != nullptr);
            _impl_.tabs_api_info_->Clear();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.declarative_net_request_action_info_ != nullptr);
            _impl_.declarative_net_request_action_info_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_SignalInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo tabs_execute_script_info = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_tabs_execute_script_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo remote_host_contacted_info = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_remote_host_contacted_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo cookies_get_all_info = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_cookies_get_all_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo cookies_get_info = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_cookies_get_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo potential_password_theft_info = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_potential_password_theft_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestInfo declarative_net_request_info = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_declarative_net_request_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo tabs_api_info = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_tabs_api_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo declarative_net_request_action_info = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_declarative_net_request_action_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_SignalInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo tabs_execute_script_info = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::tabs_execute_script_info(this), _Internal::tabs_execute_script_info(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo remote_host_contacted_info = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::remote_host_contacted_info(this), _Internal::remote_host_contacted_info(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo cookies_get_all_info = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::cookies_get_all_info(this), _Internal::cookies_get_all_info(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo cookies_get_info = 4;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::cookies_get_info(this), _Internal::cookies_get_info(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo potential_password_theft_info = 5;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::potential_password_theft_info(this), _Internal::potential_password_theft_info(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestInfo declarative_net_request_info = 6;
    if (cached_has_bits & 0x00000020u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::declarative_net_request_info(this), _Internal::declarative_net_request_info(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo tabs_api_info = 7;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::tabs_api_info(this), _Internal::tabs_api_info(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo declarative_net_request_action_info = 8;
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            8, _Internal::declarative_net_request_action_info(this), _Internal::declarative_net_request_action_info(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo)
    return target;
}

size_t ExtensionTelemetryReportRequest_SignalInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsExecuteScriptInfo tabs_execute_script_info = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.tabs_execute_script_info_);
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.RemoteHostContactedInfo remote_host_contacted_info = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.remote_host_contacted_info_);
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetAllInfo cookies_get_all_info = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.cookies_get_all_info_);
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.CookiesGetInfo cookies_get_info = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.cookies_get_info_);
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.PotentialPasswordTheftInfo potential_password_theft_info = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.potential_password_theft_info_);
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestInfo declarative_net_request_info = 6;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.declarative_net_request_info_);
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.TabsApiInfo tabs_api_info = 7;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.tabs_api_info_);
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo.DeclarativeNetRequestActionInfo declarative_net_request_action_info = 8;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.declarative_net_request_action_info_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_SignalInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_SignalInfo*>(&from));
}

void ExtensionTelemetryReportRequest_SignalInfo::MergeFrom(const ExtensionTelemetryReportRequest_SignalInfo& from)
{
    ExtensionTelemetryReportRequest_SignalInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_tabs_execute_script_info()->::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo::MergeFrom(
                from._internal_tabs_execute_script_info());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_remote_host_contacted_info()
                ->::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo::MergeFrom(from._internal_remote_host_contacted_info());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_cookies_get_all_info()->::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo::MergeFrom(
                from._internal_cookies_get_all_info());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_cookies_get_info()->::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo::MergeFrom(
                from._internal_cookies_get_info());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_potential_password_theft_info()
                ->::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo::MergeFrom(
                    from._internal_potential_password_theft_info());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_declarative_net_request_info()
                ->::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo::MergeFrom(
                    from._internal_declarative_net_request_info());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_tabs_api_info()->::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo::MergeFrom(
                from._internal_tabs_api_info());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_declarative_net_request_action_info()
                ->::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo::MergeFrom(
                    from._internal_declarative_net_request_action_info());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_SignalInfo::CopyFrom(const ExtensionTelemetryReportRequest_SignalInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.SignalInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_SignalInfo::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_SignalInfo::InternalSwap(ExtensionTelemetryReportRequest_SignalInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest_SignalInfo, _impl_.declarative_net_request_action_info_)
        + sizeof(ExtensionTelemetryReportRequest_SignalInfo::_impl_.declarative_net_request_action_info_)
        - PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest_SignalInfo, _impl_.tabs_execute_script_info_)>(
        reinterpret_cast<char*>(&_impl_.tabs_execute_script_info_), reinterpret_cast<char*>(&other->_impl_.tabs_execute_script_info_));
}

std::string ExtensionTelemetryReportRequest_SignalInfo::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.SignalInfo";
}

// ===================================================================

class ExtensionTelemetryReportRequest_Report::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest_Report>()._impl_._has_bits_);
    static const ::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo& extension(const ExtensionTelemetryReportRequest_Report* msg);
    static void set_has_extension(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo& ExtensionTelemetryReportRequest_Report::_Internal::extension(
    const ExtensionTelemetryReportRequest_Report* msg)
{
    return *msg->_impl_.extension_;
}
ExtensionTelemetryReportRequest_Report::ExtensionTelemetryReportRequest_Report(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest.Report)
}
ExtensionTelemetryReportRequest_Report::ExtensionTelemetryReportRequest_Report(const ExtensionTelemetryReportRequest_Report& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest_Report* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.signals_) { from._impl_.signals_ }, decltype(_impl_.extension_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_extension()) {
        _this->_impl_.extension_ = new ::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo(*from._impl_.extension_);
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest.Report)
}

inline void ExtensionTelemetryReportRequest_Report::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.signals_) { arena },
        decltype(_impl_.extension_) { nullptr } };
}

ExtensionTelemetryReportRequest_Report::~ExtensionTelemetryReportRequest_Report()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest.Report)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest_Report::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.signals_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.extension_;
}

void ExtensionTelemetryReportRequest_Report::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest_Report::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest.Report)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.signals_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.extension_ != nullptr);
        _impl_.extension_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest_Report::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo extension = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_extension(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo signals = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_signals(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest_Report::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest.Report)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo extension = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::extension(this), _Internal::extension(this).GetCachedSize(), target, stream);
    }

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo signals = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_signals_size()); i < n; i++) {
        const auto& repfield = this->_internal_signals(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest.Report)
    return target;
}

size_t ExtensionTelemetryReportRequest_Report::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest.Report)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.SignalInfo signals = 2;
    total_size += 1UL * this->_internal_signals_size();
    for (const auto& msg : this->_impl_.signals_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.ExtensionInfo extension = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.extension_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest_Report::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest_Report*>(&from));
}

void ExtensionTelemetryReportRequest_Report::MergeFrom(const ExtensionTelemetryReportRequest_Report& from)
{
    ExtensionTelemetryReportRequest_Report* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest.Report)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.signals_.MergeFrom(from._impl_.signals_);
    if (from._internal_has_extension()) {
        _this->_internal_mutable_extension()->::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo::MergeFrom(from._internal_extension());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest_Report::CopyFrom(const ExtensionTelemetryReportRequest_Report& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest.Report)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest_Report::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest_Report::InternalSwap(ExtensionTelemetryReportRequest_Report* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.signals_.InternalSwap(&other->_impl_.signals_);
    swap(_impl_.extension_, other->_impl_.extension_);
}

std::string ExtensionTelemetryReportRequest_Report::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest.Report";
}

// ===================================================================

class ExtensionTelemetryReportRequest::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportRequest>()._impl_._has_bits_);
    static void set_has_creation_timestamp_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_configuration_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_developer_mode_enabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_management_authority_trustworthiness(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_management_authority(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

ExtensionTelemetryReportRequest::ExtensionTelemetryReportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportRequest)
}
ExtensionTelemetryReportRequest::ExtensionTelemetryReportRequest(const ExtensionTelemetryReportRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.reports_) { from._impl_.reports_ }, decltype(_impl_.creation_timestamp_msec_) {}, decltype(_impl_.configuration_version_) {},
        decltype(_impl_.developer_mode_enabled_) {}, decltype(_impl_.management_authority_trustworthiness_) {}, decltype(_impl_.management_authority_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.creation_timestamp_msec_, &from._impl_.creation_timestamp_msec_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.management_authority_) - reinterpret_cast<char*>(&_impl_.creation_timestamp_msec_))
            + sizeof(_impl_.management_authority_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportRequest)
}

inline void ExtensionTelemetryReportRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.reports_) { arena },
        decltype(_impl_.creation_timestamp_msec_) { int64_t { 0 } }, decltype(_impl_.configuration_version_) { 0u },
        decltype(_impl_.developer_mode_enabled_) { false }, decltype(_impl_.management_authority_trustworthiness_) { 0 },
        decltype(_impl_.management_authority_) { 0 } };
}

ExtensionTelemetryReportRequest::~ExtensionTelemetryReportRequest()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.reports_.~RepeatedPtrField();
}

void ExtensionTelemetryReportRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.reports_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        ::memset(&_impl_.creation_timestamp_msec_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.management_authority_) - reinterpret_cast<char*>(&_impl_.creation_timestamp_msec_))
                + sizeof(_impl_.management_authority_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 creation_timestamp_msec = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_creation_timestamp_msec(&has_bits);
                _impl_.creation_timestamp_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ExtensionTelemetryReportRequest.Report reports = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_reports(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional uint32 configuration_version = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_configuration_version(&has_bits);
                _impl_.configuration_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool developer_mode_enabled = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_developer_mode_enabled(&has_bits);
                _impl_.developer_mode_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.ManagementAuthorityTrustworthiness management_authority_trustworthiness = 5 [deprecated = true];
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness_IsValid(val))) {
                    _internal_set_management_authority_trustworthiness(
                        static_cast<::safe_browsing::ExtensionTelemetryReportRequest_ManagementAuthorityTrustworthiness>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportRequest.ManagementAuthority management_authority = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ExtensionTelemetryReportRequest_ManagementAuthority_IsValid(val))) {
                    _internal_set_management_authority(static_cast<::safe_browsing::ExtensionTelemetryReportRequest_ManagementAuthority>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 creation_timestamp_msec = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_creation_timestamp_msec(), target);
    }

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.Report reports = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_reports_size()); i < n; i++) {
        const auto& repfield = this->_internal_reports(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional uint32 configuration_version = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_configuration_version(), target);
    }

    // optional bool developer_mode_enabled = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_developer_mode_enabled(), target);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.ManagementAuthorityTrustworthiness management_authority_trustworthiness = 5 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_management_authority_trustworthiness(), target);
    }

    // optional .safe_browsing.ExtensionTelemetryReportRequest.ManagementAuthority management_authority = 6;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(6, this->_internal_management_authority(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportRequest)
    return target;
}

size_t ExtensionTelemetryReportRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportRequest.Report reports = 2;
    total_size += 1UL * this->_internal_reports_size();
    for (const auto& msg : this->_impl_.reports_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional int64 creation_timestamp_msec = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_creation_timestamp_msec());
        }

        // optional uint32 configuration_version = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_configuration_version());
        }

        // optional bool developer_mode_enabled = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.ManagementAuthorityTrustworthiness management_authority_trustworthiness = 5 [deprecated = true];
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_management_authority_trustworthiness());
        }

        // optional .safe_browsing.ExtensionTelemetryReportRequest.ManagementAuthority management_authority = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_management_authority());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportRequest*>(&from));
}

void ExtensionTelemetryReportRequest::MergeFrom(const ExtensionTelemetryReportRequest& from)
{
    ExtensionTelemetryReportRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.reports_.MergeFrom(from._impl_.reports_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.creation_timestamp_msec_ = from._impl_.creation_timestamp_msec_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.configuration_version_ = from._impl_.configuration_version_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.developer_mode_enabled_ = from._impl_.developer_mode_enabled_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.management_authority_trustworthiness_ = from._impl_.management_authority_trustworthiness_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.management_authority_ = from._impl_.management_authority_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportRequest::CopyFrom(const ExtensionTelemetryReportRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportRequest::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportRequest::InternalSwap(ExtensionTelemetryReportRequest* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.reports_.InternalSwap(&other->_impl_.reports_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest, _impl_.management_authority_)
        + sizeof(ExtensionTelemetryReportRequest::_impl_.management_authority_)
        - PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportRequest, _impl_.creation_timestamp_msec_)>(
        reinterpret_cast<char*>(&_impl_.creation_timestamp_msec_), reinterpret_cast<char*>(&other->_impl_.creation_timestamp_msec_));
}

std::string ExtensionTelemetryReportRequest::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportRequest";
}

// ===================================================================

class ExtensionTelemetryReportResponse_ExtensionParameters::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportResponse_ExtensionParameters>()._impl_._has_bits_);
    static void set_has_extension_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_signal_enable_mask(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ExtensionTelemetryReportResponse_ExtensionParameters::ExtensionTelemetryReportResponse_ExtensionParameters(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportResponse.ExtensionParameters)
}
ExtensionTelemetryReportResponse_ExtensionParameters::ExtensionTelemetryReportResponse_ExtensionParameters(
    const ExtensionTelemetryReportResponse_ExtensionParameters& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportResponse_ExtensionParameters* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.extension_id_) {},
        decltype(_impl_.signal_enable_mask_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.extension_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_extension_id()) {
        _this->_impl_.extension_id_.Set(from._internal_extension_id(), _this->GetArenaForAllocation());
    }
    _this->_impl_.signal_enable_mask_ = from._impl_.signal_enable_mask_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportResponse.ExtensionParameters)
}

inline void ExtensionTelemetryReportResponse_ExtensionParameters::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.extension_id_) {},
        decltype(_impl_.signal_enable_mask_) { uint64_t { 0u } } };
    _impl_.extension_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionTelemetryReportResponse_ExtensionParameters::~ExtensionTelemetryReportResponse_ExtensionParameters()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportResponse.ExtensionParameters)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportResponse_ExtensionParameters::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.extension_id_.Destroy();
}

void ExtensionTelemetryReportResponse_ExtensionParameters::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportResponse_ExtensionParameters::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportResponse.ExtensionParameters)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.extension_id_.ClearNonDefaultToEmpty();
    }
    _impl_.signal_enable_mask_ = uint64_t { 0u };
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportResponse_ExtensionParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string extension_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_extension_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint64 signal_enable_mask = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_signal_enable_mask(&has_bits);
                _impl_.signal_enable_mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportResponse_ExtensionParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportResponse.ExtensionParameters)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string extension_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_extension_id(), target);
    }

    // optional uint64 signal_enable_mask = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_signal_enable_mask(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportResponse.ExtensionParameters)
    return target;
}

size_t ExtensionTelemetryReportResponse_ExtensionParameters::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportResponse.ExtensionParameters)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string extension_id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_extension_id());
        }

        // optional uint64 signal_enable_mask = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_signal_enable_mask());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportResponse_ExtensionParameters::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportResponse_ExtensionParameters*>(&from));
}

void ExtensionTelemetryReportResponse_ExtensionParameters::MergeFrom(const ExtensionTelemetryReportResponse_ExtensionParameters& from)
{
    ExtensionTelemetryReportResponse_ExtensionParameters* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportResponse.ExtensionParameters)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_extension_id(from._internal_extension_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.signal_enable_mask_ = from._impl_.signal_enable_mask_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportResponse_ExtensionParameters::CopyFrom(const ExtensionTelemetryReportResponse_ExtensionParameters& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportResponse.ExtensionParameters)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportResponse_ExtensionParameters::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportResponse_ExtensionParameters::InternalSwap(ExtensionTelemetryReportResponse_ExtensionParameters* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.extension_id_, lhs_arena, &other->_impl_.extension_id_, rhs_arena);
    swap(_impl_.signal_enable_mask_, other->_impl_.signal_enable_mask_);
}

std::string ExtensionTelemetryReportResponse_ExtensionParameters::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportResponse.ExtensionParameters";
}

// ===================================================================

class ExtensionTelemetryReportResponse_Configuration::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportResponse_Configuration>()._impl_._has_bits_);
    static void set_has_configuration_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_reporting_interval_seconds(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_writes_per_interval(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

ExtensionTelemetryReportResponse_Configuration::ExtensionTelemetryReportResponse_Configuration(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportResponse.Configuration)
}
ExtensionTelemetryReportResponse_Configuration::ExtensionTelemetryReportResponse_Configuration(const ExtensionTelemetryReportResponse_Configuration& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportResponse_Configuration* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.extension_parameters_) { from._impl_.extension_parameters_ }, decltype(_impl_.configuration_version_) {},
        decltype(_impl_.reporting_interval_seconds_) {}, decltype(_impl_.writes_per_interval_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.configuration_version_, &from._impl_.configuration_version_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.writes_per_interval_) - reinterpret_cast<char*>(&_impl_.configuration_version_))
            + sizeof(_impl_.writes_per_interval_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportResponse.Configuration)
}

inline void ExtensionTelemetryReportResponse_Configuration::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.extension_parameters_) { arena },
        decltype(_impl_.configuration_version_) { 0u }, decltype(_impl_.reporting_interval_seconds_) { 0u }, decltype(_impl_.writes_per_interval_) { 0u } };
}

ExtensionTelemetryReportResponse_Configuration::~ExtensionTelemetryReportResponse_Configuration()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportResponse.Configuration)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportResponse_Configuration::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.extension_parameters_.~RepeatedPtrField();
}

void ExtensionTelemetryReportResponse_Configuration::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportResponse_Configuration::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportResponse.Configuration)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.extension_parameters_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        ::memset(&_impl_.configuration_version_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.writes_per_interval_) - reinterpret_cast<char*>(&_impl_.configuration_version_))
                + sizeof(_impl_.writes_per_interval_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportResponse_Configuration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint32 configuration_version = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_configuration_version(&has_bits);
                _impl_.configuration_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 reporting_interval_seconds = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_reporting_interval_seconds(&has_bits);
                _impl_.reporting_interval_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 writes_per_interval = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_writes_per_interval(&has_bits);
                _impl_.writes_per_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ExtensionTelemetryReportResponse.ExtensionParameters extension_parameters = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_extension_parameters(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportResponse_Configuration::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportResponse.Configuration)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 configuration_version = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_configuration_version(), target);
    }

    // optional uint32 reporting_interval_seconds = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_reporting_interval_seconds(), target);
    }

    // optional uint32 writes_per_interval = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_writes_per_interval(), target);
    }

    // repeated .safe_browsing.ExtensionTelemetryReportResponse.ExtensionParameters extension_parameters = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_extension_parameters_size()); i < n; i++) {
        const auto& repfield = this->_internal_extension_parameters(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportResponse.Configuration)
    return target;
}

size_t ExtensionTelemetryReportResponse_Configuration::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportResponse.Configuration)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportResponse.ExtensionParameters extension_parameters = 4;
    total_size += 1UL * this->_internal_extension_parameters_size();
    for (const auto& msg : this->_impl_.extension_parameters_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional uint32 configuration_version = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_configuration_version());
        }

        // optional uint32 reporting_interval_seconds = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reporting_interval_seconds());
        }

        // optional uint32 writes_per_interval = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_writes_per_interval());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportResponse_Configuration::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportResponse_Configuration*>(&from));
}

void ExtensionTelemetryReportResponse_Configuration::MergeFrom(const ExtensionTelemetryReportResponse_Configuration& from)
{
    ExtensionTelemetryReportResponse_Configuration* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportResponse.Configuration)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.extension_parameters_.MergeFrom(from._impl_.extension_parameters_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.configuration_version_ = from._impl_.configuration_version_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.reporting_interval_seconds_ = from._impl_.reporting_interval_seconds_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.writes_per_interval_ = from._impl_.writes_per_interval_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportResponse_Configuration::CopyFrom(const ExtensionTelemetryReportResponse_Configuration& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportResponse.Configuration)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportResponse_Configuration::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportResponse_Configuration::InternalSwap(ExtensionTelemetryReportResponse_Configuration* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.extension_parameters_.InternalSwap(&other->_impl_.extension_parameters_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportResponse_Configuration, _impl_.writes_per_interval_)
        + sizeof(ExtensionTelemetryReportResponse_Configuration::_impl_.writes_per_interval_)
        - PROTOBUF_FIELD_OFFSET(ExtensionTelemetryReportResponse_Configuration, _impl_.configuration_version_)>(
        reinterpret_cast<char*>(&_impl_.configuration_version_), reinterpret_cast<char*>(&other->_impl_.configuration_version_));
}

std::string ExtensionTelemetryReportResponse_Configuration::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportResponse.Configuration";
}

// ===================================================================

class ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportResponse_OffstoreExtensionVerdict>()._impl_._has_bits_);
    static void set_has_extension_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_verdict_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::ExtensionTelemetryReportResponse_OffstoreExtensionVerdict(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict)
}
ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::ExtensionTelemetryReportResponse_OffstoreExtensionVerdict(
    const ExtensionTelemetryReportResponse_OffstoreExtensionVerdict& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportResponse_OffstoreExtensionVerdict* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.extension_id_) {},
        decltype(_impl_.verdict_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.extension_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_extension_id()) {
        _this->_impl_.extension_id_.Set(from._internal_extension_id(), _this->GetArenaForAllocation());
    }
    _this->_impl_.verdict_type_ = from._impl_.verdict_type_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict)
}

inline void ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.extension_id_) {},
        decltype(_impl_.verdict_type_) { 0 } };
    _impl_.extension_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::~ExtensionTelemetryReportResponse_OffstoreExtensionVerdict()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.extension_id_.Destroy();
}

void ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.extension_id_.ClearNonDefaultToEmpty();
    }
    _impl_.verdict_type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string extension_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_extension_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict.OffstoreExtensionVerdictType verdict_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(
                        ::safe_browsing::ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType_IsValid(val))) {
                    _internal_set_verdict_type(
                        static_cast<::safe_browsing::ExtensionTelemetryReportResponse_OffstoreExtensionVerdict_OffstoreExtensionVerdictType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string extension_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_extension_id(), target);
    }

    // optional .safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict.OffstoreExtensionVerdictType verdict_type = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_verdict_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict)
    return target;
}

size_t ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string extension_id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_extension_id());
        }

        // optional .safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict.OffstoreExtensionVerdictType verdict_type = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_verdict_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportResponse_OffstoreExtensionVerdict*>(&from));
}

void ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::MergeFrom(const ExtensionTelemetryReportResponse_OffstoreExtensionVerdict& from)
{
    ExtensionTelemetryReportResponse_OffstoreExtensionVerdict* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_extension_id(from._internal_extension_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.verdict_type_ = from._impl_.verdict_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::CopyFrom(const ExtensionTelemetryReportResponse_OffstoreExtensionVerdict& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::InternalSwap(ExtensionTelemetryReportResponse_OffstoreExtensionVerdict* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.extension_id_, lhs_arena, &other->_impl_.extension_id_, rhs_arena);
    swap(_impl_.verdict_type_, other->_impl_.verdict_type_);
}

std::string ExtensionTelemetryReportResponse_OffstoreExtensionVerdict::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict";
}

// ===================================================================

class ExtensionTelemetryReportResponse::_Internal {
public:
    using HasBits = decltype(std::declval<ExtensionTelemetryReportResponse>()._impl_._has_bits_);
    static const ::safe_browsing::ExtensionTelemetryReportResponse_Configuration& configuration(const ExtensionTelemetryReportResponse* msg);
    static void set_has_configuration(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::safe_browsing::ExtensionTelemetryReportResponse_Configuration& ExtensionTelemetryReportResponse::_Internal::configuration(
    const ExtensionTelemetryReportResponse* msg)
{
    return *msg->_impl_.configuration_;
}
ExtensionTelemetryReportResponse::ExtensionTelemetryReportResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.ExtensionTelemetryReportResponse)
}
ExtensionTelemetryReportResponse::ExtensionTelemetryReportResponse(const ExtensionTelemetryReportResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ExtensionTelemetryReportResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.offstore_extension_verdicts_) { from._impl_.offstore_extension_verdicts_ }, decltype(_impl_.configuration_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_configuration()) {
        _this->_impl_.configuration_ = new ::safe_browsing::ExtensionTelemetryReportResponse_Configuration(*from._impl_.configuration_);
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.ExtensionTelemetryReportResponse)
}

inline void ExtensionTelemetryReportResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.offstore_extension_verdicts_) { arena },
        decltype(_impl_.configuration_) { nullptr } };
}

ExtensionTelemetryReportResponse::~ExtensionTelemetryReportResponse()
{
    // @@protoc_insertion_point(destructor:safe_browsing.ExtensionTelemetryReportResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ExtensionTelemetryReportResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.offstore_extension_verdicts_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.configuration_;
}

void ExtensionTelemetryReportResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ExtensionTelemetryReportResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.ExtensionTelemetryReportResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.offstore_extension_verdicts_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.configuration_ != nullptr);
        _impl_.configuration_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ExtensionTelemetryReportResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.ExtensionTelemetryReportResponse.Configuration configuration = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_configuration(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict offstore_extension_verdicts = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_offstore_extension_verdicts(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ExtensionTelemetryReportResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.ExtensionTelemetryReportResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ExtensionTelemetryReportResponse.Configuration configuration = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::configuration(this), _Internal::configuration(this).GetCachedSize(), target, stream);
    }

    // repeated .safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict offstore_extension_verdicts = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_offstore_extension_verdicts_size()); i < n; i++) {
        const auto& repfield = this->_internal_offstore_extension_verdicts(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.ExtensionTelemetryReportResponse)
    return target;
}

size_t ExtensionTelemetryReportResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.ExtensionTelemetryReportResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ExtensionTelemetryReportResponse.OffstoreExtensionVerdict offstore_extension_verdicts = 2;
    total_size += 1UL * this->_internal_offstore_extension_verdicts_size();
    for (const auto& msg : this->_impl_.offstore_extension_verdicts_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional .safe_browsing.ExtensionTelemetryReportResponse.Configuration configuration = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.configuration_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ExtensionTelemetryReportResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ExtensionTelemetryReportResponse*>(&from));
}

void ExtensionTelemetryReportResponse::MergeFrom(const ExtensionTelemetryReportResponse& from)
{
    ExtensionTelemetryReportResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.ExtensionTelemetryReportResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.offstore_extension_verdicts_.MergeFrom(from._impl_.offstore_extension_verdicts_);
    if (from._internal_has_configuration()) {
        _this->_internal_mutable_configuration()->::safe_browsing::ExtensionTelemetryReportResponse_Configuration::MergeFrom(from._internal_configuration());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ExtensionTelemetryReportResponse::CopyFrom(const ExtensionTelemetryReportResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.ExtensionTelemetryReportResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ExtensionTelemetryReportResponse::IsInitialized() const
{
    return true;
}

void ExtensionTelemetryReportResponse::InternalSwap(ExtensionTelemetryReportResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.offstore_extension_verdicts_.InternalSwap(&other->_impl_.offstore_extension_verdicts_);
    swap(_impl_.configuration_, other->_impl_.configuration_);
}

std::string ExtensionTelemetryReportResponse::GetTypeName() const
{
    return "safe_browsing.ExtensionTelemetryReportResponse";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace safe_browsing
PROTOBUF_NAMESPACE_OPEN
template <>
PROTOBUF_NOINLINE ::safe_browsing::ChromeUserPopulation_PageLoadToken* Arena::CreateMaybeMessage<::safe_browsing::ChromeUserPopulation_PageLoadToken>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ChromeUserPopulation_PageLoadToken>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::ChromeUserPopulation* Arena::CreateMaybeMessage<::safe_browsing::ChromeUserPopulation>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ChromeUserPopulation>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::ImageFeatureEmbedding* Arena::CreateMaybeMessage<::safe_browsing::ImageFeatureEmbedding>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ImageFeatureEmbedding>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::LlamaTriggerRuleInfo* Arena::CreateMaybeMessage<::safe_browsing::LlamaTriggerRuleInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::LlamaTriggerRuleInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::LlamaForcedTriggerInfo* Arena::CreateMaybeMessage<::safe_browsing::LlamaForcedTriggerInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::LlamaForcedTriggerInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientPhishingRequest_Feature* Arena::CreateMaybeMessage<::safe_browsing::ClientPhishingRequest_Feature>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientPhishingRequest_Feature>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientPhishingRequest_CategoryScore* Arena::CreateMaybeMessage<::safe_browsing::ClientPhishingRequest_CategoryScore>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientPhishingRequest_CategoryScore>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::ClientPhishingRequest* Arena::CreateMaybeMessage<::safe_browsing::ClientPhishingRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientPhishingRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::ClientPhishingResponse* Arena::CreateMaybeMessage<::safe_browsing::ClientPhishingResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientPhishingResponse>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::LoginReputationClientRequest_Frame_Form* Arena::CreateMaybeMessage<::safe_browsing::LoginReputationClientRequest_Frame_Form>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::LoginReputationClientRequest_Frame_Form>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::LoginReputationClientRequest_Frame* Arena::CreateMaybeMessage<::safe_browsing::LoginReputationClientRequest_Frame>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::LoginReputationClientRequest_Frame>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType*
Arena::CreateMaybeMessage<::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent_ReusedPasswordAccountType>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent*
Arena::CreateMaybeMessage<::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::LoginReputationClientRequest_PasswordReuseEvent>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::LoginReputationClientRequest_UrlDisplayExperiment*
Arena::CreateMaybeMessage<::safe_browsing::LoginReputationClientRequest_UrlDisplayExperiment>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::LoginReputationClientRequest_UrlDisplayExperiment>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::LoginReputationClientRequest_ReferringAppInfo*
Arena::CreateMaybeMessage<::safe_browsing::LoginReputationClientRequest_ReferringAppInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::LoginReputationClientRequest_ReferringAppInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::LoginReputationClientRequest_DebuggingMetadata*
Arena::CreateMaybeMessage<::safe_browsing::LoginReputationClientRequest_DebuggingMetadata>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::LoginReputationClientRequest_DebuggingMetadata>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::LoginReputationClientRequest* Arena::CreateMaybeMessage<::safe_browsing::LoginReputationClientRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::LoginReputationClientRequest>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::LoginReputationClientResponse* Arena::CreateMaybeMessage<::safe_browsing::LoginReputationClientResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::LoginReputationClientResponse>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::VisualFeatures_BlurredImage* Arena::CreateMaybeMessage<::safe_browsing::VisualFeatures_BlurredImage>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::VisualFeatures_BlurredImage>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::VisualFeatures* Arena::CreateMaybeMessage<::safe_browsing::VisualFeatures>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::VisualFeatures>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::DomFeatures_Feature* Arena::CreateMaybeMessage<::safe_browsing::DomFeatures_Feature>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::DomFeatures_Feature>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::DomFeatures* Arena::CreateMaybeMessage<::safe_browsing::DomFeatures>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::DomFeatures>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_Digests* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_Digests>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_Digests>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_Resource* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_Resource>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_Resource>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_CertificateChain_Element*
Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_CertificateChain_Element>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_CertificateChain_Element>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_CertificateChain* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_CertificateChain>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_CertificateChain>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_ExtendedAttr* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_ExtendedAttr>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_ExtendedAttr>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_SignatureInfo* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_SignatureInfo>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_SignatureInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData*
Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_PEImageHeaders_DebugData>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_PEImageHeaders* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_PEImageHeaders>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_PEImageHeaders>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_MachOHeaders_LoadCommand*
Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_MachOHeaders_LoadCommand>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_MachOHeaders_LoadCommand>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_MachOHeaders* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_MachOHeaders>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_MachOHeaders>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_ImageHeaders* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_ImageHeaders>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_ImageHeaders>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_ArchivedBinary* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_ArchivedBinary>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_ArchivedBinary>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_DetachedCodeSignature*
Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_DetachedCodeSignature>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_DetachedCodeSignature>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_ArchiveSummary* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_ArchiveSummary>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_ArchiveSummary>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest_TailoredInfo* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest_TailoredInfo>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest_TailoredInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadRequest* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::ReferrerChainOptions* Arena::CreateMaybeMessage<::safe_browsing::ReferrerChainOptions>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ReferrerChainOptions>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ReferrerChainEntry_ServerRedirect* Arena::CreateMaybeMessage<::safe_browsing::ReferrerChainEntry_ServerRedirect>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ReferrerChainEntry_ServerRedirect>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::ReferrerChainEntry* Arena::CreateMaybeMessage<::safe_browsing::ReferrerChainEntry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ReferrerChainEntry>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadResponse_MoreInfo* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadResponse_MoreInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadResponse_MoreInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadResponse_TailoredVerdict* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadResponse_TailoredVerdict>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadResponse_TailoredVerdict>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadResponse* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadResponse>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadReport_UserInformation* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadReport_UserInformation>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadReport_UserInformation>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::ClientDownloadReport* Arena::CreateMaybeMessage<::safe_browsing::ClientDownloadReport>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientDownloadReport>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::ClientUploadResponse* Arena::CreateMaybeMessage<::safe_browsing::ClientUploadResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientUploadResponse>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_IncidentData_TrackedPreferenceIncident>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident_ContainedFile>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_IncidentData_BinaryIntegrityIncident>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_IncidentData_ResourceRequestIncident>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_IncidentData* Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_IncidentData>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_IncidentData>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_DownloadDetails* Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_DownloadDetails>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_DownloadDetails>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_OS_RegistryValue*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_EnvironmentData_OS_RegistryValue>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_EnvironmentData_OS_RegistryValue>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_OS_RegistryKey*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_EnvironmentData_OS_RegistryKey>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_EnvironmentData_OS_RegistryKey>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_OS* Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_EnvironmentData_OS>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_EnvironmentData_OS>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_Machine*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_EnvironmentData_Machine>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_EnvironmentData_Machine>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Patch*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Patch>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Patch>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_NetworkProvider*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_NetworkProvider>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_NetworkProvider>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Dll*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Dll>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_Dll>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState_Modification>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_EnvironmentData_Process_ModuleState>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData_Process*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_EnvironmentData_Process>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_EnvironmentData_Process>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_EnvironmentData* Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_EnvironmentData>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_EnvironmentData>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_ExtensionData_ExtensionInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_ExtensionData* Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_ExtensionData>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_ExtensionData>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport_NonBinaryDownloadDetails*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport_NonBinaryDownloadDetails>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport_NonBinaryDownloadDetails>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentReport* Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentReport>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentReport>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentResponse_EnvironmentRequest*
Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentResponse_EnvironmentRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentResponse_EnvironmentRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::ClientIncidentResponse* Arena::CreateMaybeMessage<::safe_browsing::ClientIncidentResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientIncidentResponse>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::DownloadMetadata* Arena::CreateMaybeMessage<::safe_browsing::DownloadMetadata>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::DownloadMetadata>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPHeader*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_HTTPHeader>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_HTTPHeader>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest_FirstLine>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_HTTPRequest>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse_FirstLine>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_HTTPResponse>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_Resource*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_Resource>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_Resource>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_SafeBrowsingClientProperties>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_DownloadItemInfo_Digests>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_DownloadItemInfo*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_DownloadItemInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_DownloadItemInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_DownloadWarningAction*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_DownloadWarningAction>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_DownloadWarningAction>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails_RealTimeDetails>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_HashRealTimeExperimentDetails>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_InterstitialInteraction*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_InterstitialInteraction>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_InterstitialInteraction>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_PhishySiteInteraction*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_PhishySiteInteraction>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_PhishySiteInteraction>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_WarningShownInfo*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_WarningShownInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_WarningShownInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_PermissionPromptInfo*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_PermissionPromptInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_PermissionPromptInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo*
Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest_UrlRealTimeAndHashRealTimeDiscrepancyInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ClientSafeBrowsingReportRequest* Arena::CreateMaybeMessage<::safe_browsing::ClientSafeBrowsingReportRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ClientSafeBrowsingReportRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::HTMLElement_Attribute* Arena::CreateMaybeMessage<::safe_browsing::HTMLElement_Attribute>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::HTMLElement_Attribute>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::HTMLElement* Arena::CreateMaybeMessage<::safe_browsing::HTMLElement>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::HTMLElement>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionWebStoreInstallRequest* Arena::CreateMaybeMessage<::safe_browsing::ExtensionWebStoreInstallRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionWebStoreInstallRequest>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo_FileInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_ExtensionInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_JSCallStackFrame>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_JSCallStack*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_JSCallStack>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_JSCallStack>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo_ScriptInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsExecuteScriptInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo_RemoteHostInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_RemoteHostContactedInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo_GetAllArgsInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetAllInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo_GetArgsInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_CookiesGetInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<
        ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo_ReusedPasswordAccountType>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_PasswordReuseInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo_RemoteHostData>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_PotentialPasswordTheftInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo_CallDetails>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_TabsApiInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo_ActionDetails>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo_DeclarativeNetRequestActionInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_SignalInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest_Report* Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest_Report>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest_Report>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportRequest* Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportRequest>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportResponse_ExtensionParameters*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportResponse_ExtensionParameters>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportResponse_ExtensionParameters>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportResponse_Configuration*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportResponse_Configuration>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportResponse_Configuration>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportResponse_OffstoreExtensionVerdict*
Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportResponse_OffstoreExtensionVerdict>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportResponse_OffstoreExtensionVerdict>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::ExtensionTelemetryReportResponse* Arena::CreateMaybeMessage<::safe_browsing::ExtensionTelemetryReportResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::ExtensionTelemetryReportResponse>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
