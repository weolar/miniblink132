// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/safe_browsing/core/common/proto/realtimeapi.proto

#include "components/safe_browsing/core/common/proto/realtimeapi.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace safe_browsing {
PROTOBUF_CONSTEXPR RTLookupRequest::RTLookupRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.referrer_chain_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.deprecated_scoped_oauth_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.dm_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.profile_dm_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.browser_dm_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.email_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.population_)*/ nullptr,
        /*decltype(_impl_.client_reporting_metadata_)*/ nullptr, /*decltype(_impl_.lookup_type_)*/ 0, /*decltype(_impl_.version_)*/ 0,
        /*decltype(_impl_.os_type_)*/ 0, /*decltype(_impl_.report_type_)*/ 0, /*decltype(_impl_.frame_type_)*/ 0 }
{
}
struct RTLookupRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR RTLookupRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~RTLookupRequestDefaultTypeInternal()
    {
    }
    union {
        RTLookupRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RTLookupRequestDefaultTypeInternal _RTLookupRequest_default_instance_;
PROTOBUF_CONSTEXPR RTLookupResponse_ThreatInfo::RTLookupResponse_ThreatInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.cache_expression_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.cache_expression_using_match_type_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.matched_url_navigation_rule_)*/ nullptr, /*decltype(_impl_.cache_duration_sec_)*/ int64_t { 0 }, /*decltype(_impl_.threat_type_)*/ 0,
        /*decltype(_impl_.verdict_type_)*/ 0, /*decltype(_impl_.cache_expression_match_type_)*/ 0 }
{
}
struct RTLookupResponse_ThreatInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR RTLookupResponse_ThreatInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~RTLookupResponse_ThreatInfoDefaultTypeInternal()
    {
    }
    union {
        RTLookupResponse_ThreatInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RTLookupResponse_ThreatInfoDefaultTypeInternal
    _RTLookupResponse_ThreatInfo_default_instance_;
PROTOBUF_CONSTEXPR RTLookupResponse::RTLookupResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.threat_info_)*/ {},
        /*decltype(_impl_.url_categories_)*/ {}, /*decltype(_impl_.llama_forced_trigger_info_)*/ nullptr, /*decltype(_impl_.client_side_detection_type_)*/ 0 }
{
}
struct RTLookupResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR RTLookupResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~RTLookupResponseDefaultTypeInternal()
    {
    }
    union {
        RTLookupResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RTLookupResponseDefaultTypeInternal _RTLookupResponse_default_instance_;
PROTOBUF_CONSTEXPR Timestamp::Timestamp(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.seconds_)*/ int64_t { 0 },
        /*decltype(_impl_.nanos_)*/ 0 }
{
}
struct TimestampDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TimestampDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TimestampDefaultTypeInternal()
    {
    }
    union {
        Timestamp _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimestampDefaultTypeInternal _Timestamp_default_instance_;
PROTOBUF_CONSTEXPR MatchedUrlNavigationRule_CustomRuleMessageSegment::MatchedUrlNavigationRule_CustomRuleMessageSegment(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.text_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.link_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct MatchedUrlNavigationRule_CustomRuleMessageSegmentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR MatchedUrlNavigationRule_CustomRuleMessageSegmentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~MatchedUrlNavigationRule_CustomRuleMessageSegmentDefaultTypeInternal()
    {
    }
    union {
        MatchedUrlNavigationRule_CustomRuleMessageSegment _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MatchedUrlNavigationRule_CustomRuleMessageSegmentDefaultTypeInternal
    _MatchedUrlNavigationRule_CustomRuleMessageSegment_default_instance_;
PROTOBUF_CONSTEXPR MatchedUrlNavigationRule_CustomMessage::MatchedUrlNavigationRule_CustomMessage(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.message_segments_)*/ {},
        /*decltype(_impl_.custom_message_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.learn_more_link_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.custom_message_with_links_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct MatchedUrlNavigationRule_CustomMessageDefaultTypeInternal {
    PROTOBUF_CONSTEXPR MatchedUrlNavigationRule_CustomMessageDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~MatchedUrlNavigationRule_CustomMessageDefaultTypeInternal()
    {
    }
    union {
        MatchedUrlNavigationRule_CustomMessage _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MatchedUrlNavigationRule_CustomMessageDefaultTypeInternal
    _MatchedUrlNavigationRule_CustomMessage_default_instance_;
PROTOBUF_CONSTEXPR MatchedUrlNavigationRule_WatermarkMessage::MatchedUrlNavigationRule_WatermarkMessage(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.watermark_message_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.user_email_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.obfuscated_device_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.timestamp_)*/ nullptr }
{
}
struct MatchedUrlNavigationRule_WatermarkMessageDefaultTypeInternal {
    PROTOBUF_CONSTEXPR MatchedUrlNavigationRule_WatermarkMessageDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~MatchedUrlNavigationRule_WatermarkMessageDefaultTypeInternal()
    {
    }
    union {
        MatchedUrlNavigationRule_WatermarkMessage _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MatchedUrlNavigationRule_WatermarkMessageDefaultTypeInternal
    _MatchedUrlNavigationRule_WatermarkMessage_default_instance_;
PROTOBUF_CONSTEXPR MatchedUrlNavigationRule::MatchedUrlNavigationRule(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.rule_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.rule_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.matched_url_category_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.custom_message_)*/ nullptr, /*decltype(_impl_.watermark_message_)*/ nullptr, /*decltype(_impl_.block_screenshot_)*/ false }
{
}
struct MatchedUrlNavigationRuleDefaultTypeInternal {
    PROTOBUF_CONSTEXPR MatchedUrlNavigationRuleDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~MatchedUrlNavigationRuleDefaultTypeInternal()
    {
    }
    union {
        MatchedUrlNavigationRule _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MatchedUrlNavigationRuleDefaultTypeInternal
    _MatchedUrlNavigationRule_default_instance_;
} // namespace safe_browsing
namespace safe_browsing {
bool RTLookupRequest_LookupType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RTLookupRequest_LookupType_strings[3] = {};

static const char RTLookupRequest_LookupType_names[] = "DOWNLOAD"
                                                       "LOOKUP_TYPE_UNSPECIFIED"
                                                       "NAVIGATION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RTLookupRequest_LookupType_entries[] = {
    { { RTLookupRequest_LookupType_names + 0, 8 }, 2 },
    { { RTLookupRequest_LookupType_names + 8, 23 }, 0 },
    { { RTLookupRequest_LookupType_names + 31, 10 }, 1 },
};

static const int RTLookupRequest_LookupType_entries_by_number[] = {
    1, // 0 -> LOOKUP_TYPE_UNSPECIFIED
    2, // 1 -> NAVIGATION
    0, // 2 -> DOWNLOAD
};

const std::string& RTLookupRequest_LookupType_Name(RTLookupRequest_LookupType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        RTLookupRequest_LookupType_entries, RTLookupRequest_LookupType_entries_by_number, 3, RTLookupRequest_LookupType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(RTLookupRequest_LookupType_entries, RTLookupRequest_LookupType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : RTLookupRequest_LookupType_strings[idx].get();
}
bool RTLookupRequest_LookupType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RTLookupRequest_LookupType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(RTLookupRequest_LookupType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<RTLookupRequest_LookupType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RTLookupRequest_LookupType RTLookupRequest::LOOKUP_TYPE_UNSPECIFIED;
constexpr RTLookupRequest_LookupType RTLookupRequest::NAVIGATION;
constexpr RTLookupRequest_LookupType RTLookupRequest::DOWNLOAD;
constexpr RTLookupRequest_LookupType RTLookupRequest::LookupType_MIN;
constexpr RTLookupRequest_LookupType RTLookupRequest::LookupType_MAX;
constexpr int RTLookupRequest::LookupType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RTLookupRequest_OSType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 5:
    case 6:
    case 7:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RTLookupRequest_OSType_strings[7] = {};

static const char RTLookupRequest_OSType_names[] = "OS_TYPE_ANDROID"
                                                   "OS_TYPE_CHROME_OS"
                                                   "OS_TYPE_IOS"
                                                   "OS_TYPE_LINUX"
                                                   "OS_TYPE_MAC"
                                                   "OS_TYPE_UNSPECIFIED"
                                                   "OS_TYPE_WINDOWS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RTLookupRequest_OSType_entries[] = {
    { { RTLookupRequest_OSType_names + 0, 15 }, 1 },
    { { RTLookupRequest_OSType_names + 15, 17 }, 2 },
    { { RTLookupRequest_OSType_names + 32, 11 }, 4 },
    { { RTLookupRequest_OSType_names + 43, 13 }, 5 },
    { { RTLookupRequest_OSType_names + 56, 11 }, 6 },
    { { RTLookupRequest_OSType_names + 67, 19 }, 0 },
    { { RTLookupRequest_OSType_names + 86, 15 }, 7 },
};

static const int RTLookupRequest_OSType_entries_by_number[] = {
    5, // 0 -> OS_TYPE_UNSPECIFIED
    0, // 1 -> OS_TYPE_ANDROID
    1, // 2 -> OS_TYPE_CHROME_OS
    2, // 4 -> OS_TYPE_IOS
    3, // 5 -> OS_TYPE_LINUX
    4, // 6 -> OS_TYPE_MAC
    6, // 7 -> OS_TYPE_WINDOWS
};

const std::string& RTLookupRequest_OSType_Name(RTLookupRequest_OSType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        RTLookupRequest_OSType_entries, RTLookupRequest_OSType_entries_by_number, 7, RTLookupRequest_OSType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(RTLookupRequest_OSType_entries, RTLookupRequest_OSType_entries_by_number, 7, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : RTLookupRequest_OSType_strings[idx].get();
}
bool RTLookupRequest_OSType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RTLookupRequest_OSType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(RTLookupRequest_OSType_entries, 7, name, &int_value);
    if (success) {
        *value = static_cast<RTLookupRequest_OSType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RTLookupRequest_OSType RTLookupRequest::OS_TYPE_UNSPECIFIED;
constexpr RTLookupRequest_OSType RTLookupRequest::OS_TYPE_ANDROID;
constexpr RTLookupRequest_OSType RTLookupRequest::OS_TYPE_CHROME_OS;
constexpr RTLookupRequest_OSType RTLookupRequest::OS_TYPE_IOS;
constexpr RTLookupRequest_OSType RTLookupRequest::OS_TYPE_LINUX;
constexpr RTLookupRequest_OSType RTLookupRequest::OS_TYPE_MAC;
constexpr RTLookupRequest_OSType RTLookupRequest::OS_TYPE_WINDOWS;
constexpr RTLookupRequest_OSType RTLookupRequest::OSType_MIN;
constexpr RTLookupRequest_OSType RTLookupRequest::OSType_MAX;
constexpr int RTLookupRequest::OSType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RTLookupRequest_ReportType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RTLookupRequest_ReportType_strings[3] = {};

static const char RTLookupRequest_ReportType_names[] = "FULL_REPORT"
                                                       "REPORT_TYPE_UNSPECIFIED"
                                                       "SAMPLED_REPORT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RTLookupRequest_ReportType_entries[] = {
    { { RTLookupRequest_ReportType_names + 0, 11 }, 1 },
    { { RTLookupRequest_ReportType_names + 11, 23 }, 0 },
    { { RTLookupRequest_ReportType_names + 34, 14 }, 2 },
};

static const int RTLookupRequest_ReportType_entries_by_number[] = {
    1, // 0 -> REPORT_TYPE_UNSPECIFIED
    0, // 1 -> FULL_REPORT
    2, // 2 -> SAMPLED_REPORT
};

const std::string& RTLookupRequest_ReportType_Name(RTLookupRequest_ReportType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        RTLookupRequest_ReportType_entries, RTLookupRequest_ReportType_entries_by_number, 3, RTLookupRequest_ReportType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(RTLookupRequest_ReportType_entries, RTLookupRequest_ReportType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : RTLookupRequest_ReportType_strings[idx].get();
}
bool RTLookupRequest_ReportType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RTLookupRequest_ReportType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(RTLookupRequest_ReportType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<RTLookupRequest_ReportType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RTLookupRequest_ReportType RTLookupRequest::REPORT_TYPE_UNSPECIFIED;
constexpr RTLookupRequest_ReportType RTLookupRequest::FULL_REPORT;
constexpr RTLookupRequest_ReportType RTLookupRequest::SAMPLED_REPORT;
constexpr RTLookupRequest_ReportType RTLookupRequest::ReportType_MIN;
constexpr RTLookupRequest_ReportType RTLookupRequest::ReportType_MAX;
constexpr int RTLookupRequest::ReportType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RTLookupRequest_FrameType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RTLookupRequest_FrameType_strings[3] = {};

static const char RTLookupRequest_FrameType_names[] = "FRAME_TYPE_UNSPECIFIED"
                                                      "MAIN_FRAME"
                                                      "SUB_FRAME";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RTLookupRequest_FrameType_entries[] = {
    { { RTLookupRequest_FrameType_names + 0, 22 }, 0 },
    { { RTLookupRequest_FrameType_names + 22, 10 }, 1 },
    { { RTLookupRequest_FrameType_names + 32, 9 }, 2 },
};

static const int RTLookupRequest_FrameType_entries_by_number[] = {
    0, // 0 -> FRAME_TYPE_UNSPECIFIED
    1, // 1 -> MAIN_FRAME
    2, // 2 -> SUB_FRAME
};

const std::string& RTLookupRequest_FrameType_Name(RTLookupRequest_FrameType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        RTLookupRequest_FrameType_entries, RTLookupRequest_FrameType_entries_by_number, 3, RTLookupRequest_FrameType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(RTLookupRequest_FrameType_entries, RTLookupRequest_FrameType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : RTLookupRequest_FrameType_strings[idx].get();
}
bool RTLookupRequest_FrameType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RTLookupRequest_FrameType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(RTLookupRequest_FrameType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<RTLookupRequest_FrameType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RTLookupRequest_FrameType RTLookupRequest::FRAME_TYPE_UNSPECIFIED;
constexpr RTLookupRequest_FrameType RTLookupRequest::MAIN_FRAME;
constexpr RTLookupRequest_FrameType RTLookupRequest::SUB_FRAME;
constexpr RTLookupRequest_FrameType RTLookupRequest::FrameType_MIN;
constexpr RTLookupRequest_FrameType RTLookupRequest::FrameType_MAX;
constexpr int RTLookupRequest::FrameType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RTLookupResponse_ThreatInfo_ThreatType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 3:
    case 4:
    case 5:
    case 6:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RTLookupResponse_ThreatInfo_ThreatType_strings[6] = {};

static const char RTLookupResponse_ThreatInfo_ThreatType_names[] = "MANAGED_POLICY"
                                                                   "SOCIAL_ENGINEERING"
                                                                   "THREAT_TYPE_UNSPECIFIED"
                                                                   "UNCLEAR_BILLING"
                                                                   "UNWANTED_SOFTWARE"
                                                                   "WEB_MALWARE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RTLookupResponse_ThreatInfo_ThreatType_entries[] = {
    { { RTLookupResponse_ThreatInfo_ThreatType_names + 0, 14 }, 6 },
    { { RTLookupResponse_ThreatInfo_ThreatType_names + 14, 18 }, 3 },
    { { RTLookupResponse_ThreatInfo_ThreatType_names + 32, 23 }, 0 },
    { { RTLookupResponse_ThreatInfo_ThreatType_names + 55, 15 }, 5 },
    { { RTLookupResponse_ThreatInfo_ThreatType_names + 70, 17 }, 4 },
    { { RTLookupResponse_ThreatInfo_ThreatType_names + 87, 11 }, 1 },
};

static const int RTLookupResponse_ThreatInfo_ThreatType_entries_by_number[] = {
    2, // 0 -> THREAT_TYPE_UNSPECIFIED
    5, // 1 -> WEB_MALWARE
    1, // 3 -> SOCIAL_ENGINEERING
    4, // 4 -> UNWANTED_SOFTWARE
    3, // 5 -> UNCLEAR_BILLING
    0, // 6 -> MANAGED_POLICY
};

const std::string& RTLookupResponse_ThreatInfo_ThreatType_Name(RTLookupResponse_ThreatInfo_ThreatType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(RTLookupResponse_ThreatInfo_ThreatType_entries,
        RTLookupResponse_ThreatInfo_ThreatType_entries_by_number, 6, RTLookupResponse_ThreatInfo_ThreatType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        RTLookupResponse_ThreatInfo_ThreatType_entries, RTLookupResponse_ThreatInfo_ThreatType_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : RTLookupResponse_ThreatInfo_ThreatType_strings[idx].get();
}
bool RTLookupResponse_ThreatInfo_ThreatType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RTLookupResponse_ThreatInfo_ThreatType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(RTLookupResponse_ThreatInfo_ThreatType_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<RTLookupResponse_ThreatInfo_ThreatType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RTLookupResponse_ThreatInfo_ThreatType RTLookupResponse_ThreatInfo::THREAT_TYPE_UNSPECIFIED;
constexpr RTLookupResponse_ThreatInfo_ThreatType RTLookupResponse_ThreatInfo::WEB_MALWARE;
constexpr RTLookupResponse_ThreatInfo_ThreatType RTLookupResponse_ThreatInfo::SOCIAL_ENGINEERING;
constexpr RTLookupResponse_ThreatInfo_ThreatType RTLookupResponse_ThreatInfo::UNWANTED_SOFTWARE;
constexpr RTLookupResponse_ThreatInfo_ThreatType RTLookupResponse_ThreatInfo::UNCLEAR_BILLING;
constexpr RTLookupResponse_ThreatInfo_ThreatType RTLookupResponse_ThreatInfo::MANAGED_POLICY;
constexpr RTLookupResponse_ThreatInfo_ThreatType RTLookupResponse_ThreatInfo::ThreatType_MIN;
constexpr RTLookupResponse_ThreatInfo_ThreatType RTLookupResponse_ThreatInfo::ThreatType_MAX;
constexpr int RTLookupResponse_ThreatInfo::ThreatType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RTLookupResponse_ThreatInfo_VerdictType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 50:
    case 75:
    case 100:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RTLookupResponse_ThreatInfo_VerdictType_strings[5] = {};

static const char RTLookupResponse_ThreatInfo_VerdictType_names[] = "DANGEROUS"
                                                                    "SAFE"
                                                                    "SUSPICIOUS"
                                                                    "VERDICT_TYPE_UNSPECIFIED"
                                                                    "WARN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RTLookupResponse_ThreatInfo_VerdictType_entries[] = {
    { { RTLookupResponse_ThreatInfo_VerdictType_names + 0, 9 }, 100 },
    { { RTLookupResponse_ThreatInfo_VerdictType_names + 9, 4 }, 1 },
    { { RTLookupResponse_ThreatInfo_VerdictType_names + 13, 10 }, 50 },
    { { RTLookupResponse_ThreatInfo_VerdictType_names + 23, 24 }, 0 },
    { { RTLookupResponse_ThreatInfo_VerdictType_names + 47, 4 }, 75 },
};

static const int RTLookupResponse_ThreatInfo_VerdictType_entries_by_number[] = {
    3, // 0 -> VERDICT_TYPE_UNSPECIFIED
    1, // 1 -> SAFE
    2, // 50 -> SUSPICIOUS
    4, // 75 -> WARN
    0, // 100 -> DANGEROUS
};

const std::string& RTLookupResponse_ThreatInfo_VerdictType_Name(RTLookupResponse_ThreatInfo_VerdictType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(RTLookupResponse_ThreatInfo_VerdictType_entries,
        RTLookupResponse_ThreatInfo_VerdictType_entries_by_number, 5, RTLookupResponse_ThreatInfo_VerdictType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        RTLookupResponse_ThreatInfo_VerdictType_entries, RTLookupResponse_ThreatInfo_VerdictType_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : RTLookupResponse_ThreatInfo_VerdictType_strings[idx].get();
}
bool RTLookupResponse_ThreatInfo_VerdictType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RTLookupResponse_ThreatInfo_VerdictType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(RTLookupResponse_ThreatInfo_VerdictType_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<RTLookupResponse_ThreatInfo_VerdictType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RTLookupResponse_ThreatInfo_VerdictType RTLookupResponse_ThreatInfo::VERDICT_TYPE_UNSPECIFIED;
constexpr RTLookupResponse_ThreatInfo_VerdictType RTLookupResponse_ThreatInfo::SAFE;
constexpr RTLookupResponse_ThreatInfo_VerdictType RTLookupResponse_ThreatInfo::SUSPICIOUS;
constexpr RTLookupResponse_ThreatInfo_VerdictType RTLookupResponse_ThreatInfo::WARN;
constexpr RTLookupResponse_ThreatInfo_VerdictType RTLookupResponse_ThreatInfo::DANGEROUS;
constexpr RTLookupResponse_ThreatInfo_VerdictType RTLookupResponse_ThreatInfo::VerdictType_MIN;
constexpr RTLookupResponse_ThreatInfo_VerdictType RTLookupResponse_ThreatInfo::VerdictType_MAX;
constexpr int RTLookupResponse_ThreatInfo::VerdictType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RTLookupResponse_ThreatInfo_CacheExpressionMatchType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RTLookupResponse_ThreatInfo_CacheExpressionMatchType_strings[3] = {};

static const char RTLookupResponse_ThreatInfo_CacheExpressionMatchType_names[] = "COVERING_MATCH"
                                                                                 "EXACT_MATCH"
                                                                                 "MATCH_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RTLookupResponse_ThreatInfo_CacheExpressionMatchType_entries[] = {
    { { RTLookupResponse_ThreatInfo_CacheExpressionMatchType_names + 0, 14 }, 1 },
    { { RTLookupResponse_ThreatInfo_CacheExpressionMatchType_names + 14, 11 }, 2 },
    { { RTLookupResponse_ThreatInfo_CacheExpressionMatchType_names + 25, 22 }, 0 },
};

static const int RTLookupResponse_ThreatInfo_CacheExpressionMatchType_entries_by_number[] = {
    2, // 0 -> MATCH_TYPE_UNSPECIFIED
    0, // 1 -> COVERING_MATCH
    1, // 2 -> EXACT_MATCH
};

const std::string& RTLookupResponse_ThreatInfo_CacheExpressionMatchType_Name(RTLookupResponse_ThreatInfo_CacheExpressionMatchType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(RTLookupResponse_ThreatInfo_CacheExpressionMatchType_entries,
        RTLookupResponse_ThreatInfo_CacheExpressionMatchType_entries_by_number, 3, RTLookupResponse_ThreatInfo_CacheExpressionMatchType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        RTLookupResponse_ThreatInfo_CacheExpressionMatchType_entries, RTLookupResponse_ThreatInfo_CacheExpressionMatchType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : RTLookupResponse_ThreatInfo_CacheExpressionMatchType_strings[idx].get();
}
bool RTLookupResponse_ThreatInfo_CacheExpressionMatchType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RTLookupResponse_ThreatInfo_CacheExpressionMatchType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(RTLookupResponse_ThreatInfo_CacheExpressionMatchType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<RTLookupResponse_ThreatInfo_CacheExpressionMatchType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RTLookupResponse_ThreatInfo_CacheExpressionMatchType RTLookupResponse_ThreatInfo::MATCH_TYPE_UNSPECIFIED;
constexpr RTLookupResponse_ThreatInfo_CacheExpressionMatchType RTLookupResponse_ThreatInfo::COVERING_MATCH;
constexpr RTLookupResponse_ThreatInfo_CacheExpressionMatchType RTLookupResponse_ThreatInfo::EXACT_MATCH;
constexpr RTLookupResponse_ThreatInfo_CacheExpressionMatchType RTLookupResponse_ThreatInfo::CacheExpressionMatchType_MIN;
constexpr RTLookupResponse_ThreatInfo_CacheExpressionMatchType RTLookupResponse_ThreatInfo::CacheExpressionMatchType_MAX;
constexpr int RTLookupResponse_ThreatInfo::CacheExpressionMatchType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class RTLookupRequest::_Internal {
public:
    using HasBits = decltype(std::declval<RTLookupRequest>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_lookup_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static const ::safe_browsing::ChromeUserPopulation& population(const RTLookupRequest* msg);
    static void set_has_population(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_deprecated_scoped_oauth_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_dm_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_profile_dm_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_browser_dm_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::enterprise_connectors::ClientMetadata& client_reporting_metadata(const RTLookupRequest* msg);
    static void set_has_client_reporting_metadata(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_email(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_os_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_report_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_frame_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
};

const ::safe_browsing::ChromeUserPopulation& RTLookupRequest::_Internal::population(const RTLookupRequest* msg)
{
    return *msg->_impl_.population_;
}
const ::enterprise_connectors::ClientMetadata& RTLookupRequest::_Internal::client_reporting_metadata(const RTLookupRequest* msg)
{
    return *msg->_impl_.client_reporting_metadata_;
}
void RTLookupRequest::clear_population()
{
    if (_impl_.population_ != nullptr)
        _impl_.population_->Clear();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
void RTLookupRequest::clear_client_reporting_metadata()
{
    if (_impl_.client_reporting_metadata_ != nullptr)
        _impl_.client_reporting_metadata_->Clear();
    _impl_._has_bits_[0] &= ~0x00000080u;
}
void RTLookupRequest::clear_referrer_chain()
{
    _impl_.referrer_chain_.Clear();
}
RTLookupRequest::RTLookupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.RTLookupRequest)
}
RTLookupRequest::RTLookupRequest(const RTLookupRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    RTLookupRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.referrer_chain_) { from._impl_.referrer_chain_ }, decltype(_impl_.url_) {}, decltype(_impl_.deprecated_scoped_oauth_token_) {},
        decltype(_impl_.dm_token_) {}, decltype(_impl_.profile_dm_token_) {}, decltype(_impl_.browser_dm_token_) {}, decltype(_impl_.email_) {},
        decltype(_impl_.population_) { nullptr }, decltype(_impl_.client_reporting_metadata_) { nullptr }, decltype(_impl_.lookup_type_) {},
        decltype(_impl_.version_) {}, decltype(_impl_.os_type_) {}, decltype(_impl_.report_type_) {}, decltype(_impl_.frame_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _impl_.deprecated_scoped_oauth_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_scoped_oauth_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_deprecated_scoped_oauth_token()) {
        _this->_impl_.deprecated_scoped_oauth_token_.Set(from._internal_deprecated_scoped_oauth_token(), _this->GetArenaForAllocation());
    }
    _impl_.dm_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dm_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_dm_token()) {
        _this->_impl_.dm_token_.Set(from._internal_dm_token(), _this->GetArenaForAllocation());
    }
    _impl_.profile_dm_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_dm_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_profile_dm_token()) {
        _this->_impl_.profile_dm_token_.Set(from._internal_profile_dm_token(), _this->GetArenaForAllocation());
    }
    _impl_.browser_dm_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_dm_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_browser_dm_token()) {
        _this->_impl_.browser_dm_token_.Set(from._internal_browser_dm_token(), _this->GetArenaForAllocation());
    }
    _impl_.email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_email()) {
        _this->_impl_.email_.Set(from._internal_email(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_population()) {
        _this->_impl_.population_ = new ::safe_browsing::ChromeUserPopulation(*from._impl_.population_);
    }
    if (from._internal_has_client_reporting_metadata()) {
        _this->_impl_.client_reporting_metadata_ = new ::enterprise_connectors::ClientMetadata(*from._impl_.client_reporting_metadata_);
    }
    ::memcpy(&_impl_.lookup_type_, &from._impl_.lookup_type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.frame_type_) - reinterpret_cast<char*>(&_impl_.lookup_type_)) + sizeof(_impl_.frame_type_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.RTLookupRequest)
}

inline void RTLookupRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.referrer_chain_) { arena },
        decltype(_impl_.url_) {}, decltype(_impl_.deprecated_scoped_oauth_token_) {}, decltype(_impl_.dm_token_) {}, decltype(_impl_.profile_dm_token_) {},
        decltype(_impl_.browser_dm_token_) {}, decltype(_impl_.email_) {}, decltype(_impl_.population_) { nullptr },
        decltype(_impl_.client_reporting_metadata_) { nullptr }, decltype(_impl_.lookup_type_) { 0 }, decltype(_impl_.version_) { 0 },
        decltype(_impl_.os_type_) { 0 }, decltype(_impl_.report_type_) { 0 }, decltype(_impl_.frame_type_) { 0 } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_scoped_oauth_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_scoped_oauth_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dm_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dm_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_dm_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_dm_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_dm_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.browser_dm_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RTLookupRequest::~RTLookupRequest()
{
    // @@protoc_insertion_point(destructor:safe_browsing.RTLookupRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void RTLookupRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.referrer_chain_.~RepeatedPtrField();
    _impl_.url_.Destroy();
    _impl_.deprecated_scoped_oauth_token_.Destroy();
    _impl_.dm_token_.Destroy();
    _impl_.profile_dm_token_.Destroy();
    _impl_.browser_dm_token_.Destroy();
    _impl_.email_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.population_;
    if (this != internal_default_instance())
        delete _impl_.client_reporting_metadata_;
}

void RTLookupRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void RTLookupRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.RTLookupRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.referrer_chain_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.deprecated_scoped_oauth_token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.dm_token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.profile_dm_token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.browser_dm_token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.email_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.population_ != nullptr);
            _impl_.population_->Clear();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.client_reporting_metadata_ != nullptr);
            _impl_.client_reporting_metadata_->Clear();
        }
    }
    if (cached_has_bits & 0x00001f00u) {
        ::memset(&_impl_.lookup_type_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.frame_type_) - reinterpret_cast<char*>(&_impl_.lookup_type_)) + sizeof(_impl_.frame_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* RTLookupRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.RTLookupRequest.LookupType lookup_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::RTLookupRequest_LookupType_IsValid(val))) {
                    _internal_set_lookup_type(static_cast<::safe_browsing::RTLookupRequest_LookupType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ChromeUserPopulation population = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_population(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string DEPRECATED_scoped_oauth_token = 4 [deprecated = true];
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_deprecated_scoped_oauth_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string dm_token = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_dm_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 version = 6 [default = 0];
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_version(&has_bits);
                _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.RTLookupRequest.OSType os_type = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::RTLookupRequest_OSType_IsValid(val))) {
                    _internal_set_os_type(static_cast<::safe_browsing::RTLookupRequest_OSType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_referrer_chain(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.RTLookupRequest.ReportType report_type = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::RTLookupRequest_ReportType_IsValid(val))) {
                    _internal_set_report_type(static_cast<::safe_browsing::RTLookupRequest_ReportType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.RTLookupRequest.FrameType frame_type = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::RTLookupRequest_FrameType_IsValid(val))) {
                    _internal_set_frame_type(static_cast<::safe_browsing::RTLookupRequest_FrameType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string profile_dm_token = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                auto str = _internal_mutable_profile_dm_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string browser_dm_token = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                auto str = _internal_mutable_browser_dm_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string email = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                auto str = _internal_mutable_email();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .enterprise_connectors.ClientMetadata client_reporting_metadata = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                ptr = ctx->ParseMessage(_internal_mutable_client_reporting_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* RTLookupRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.RTLookupRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // optional .safe_browsing.RTLookupRequest.LookupType lookup_type = 2;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_lookup_type(), target);
    }

    // optional .safe_browsing.ChromeUserPopulation population = 3;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::population(this), _Internal::population(this).GetCachedSize(), target, stream);
    }

    // optional string DEPRECATED_scoped_oauth_token = 4 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_deprecated_scoped_oauth_token(), target);
    }

    // optional string dm_token = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_dm_token(), target);
    }

    // optional int32 version = 6 [default = 0];
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_version(), target);
    }

    // optional .safe_browsing.RTLookupRequest.OSType os_type = 7;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(7, this->_internal_os_type(), target);
    }

    // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 8;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_referrer_chain_size()); i < n; i++) {
        const auto& repfield = this->_internal_referrer_chain(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.RTLookupRequest.ReportType report_type = 9;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(9, this->_internal_report_type(), target);
    }

    // optional .safe_browsing.RTLookupRequest.FrameType frame_type = 10;
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(10, this->_internal_frame_type(), target);
    }

    // optional string profile_dm_token = 11;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(11, this->_internal_profile_dm_token(), target);
    }

    // optional string browser_dm_token = 12;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(12, this->_internal_browser_dm_token(), target);
    }

    // optional string email = 13;
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteStringMaybeAliased(13, this->_internal_email(), target);
    }

    // optional .enterprise_connectors.ClientMetadata client_reporting_metadata = 14;
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            14, _Internal::client_reporting_metadata(this), _Internal::client_reporting_metadata(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.RTLookupRequest)
    return target;
}

size_t RTLookupRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.RTLookupRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 8;
    total_size += 1UL * this->_internal_referrer_chain_size();
    for (const auto& msg : this->_impl_.referrer_chain_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional string DEPRECATED_scoped_oauth_token = 4 [deprecated = true];
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_deprecated_scoped_oauth_token());
        }

        // optional string dm_token = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_dm_token());
        }

        // optional string profile_dm_token = 11;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_profile_dm_token());
        }

        // optional string browser_dm_token = 12;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_browser_dm_token());
        }

        // optional string email = 13;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_email());
        }

        // optional .safe_browsing.ChromeUserPopulation population = 3;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.population_);
        }

        // optional .enterprise_connectors.ClientMetadata client_reporting_metadata = 14;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.client_reporting_metadata_);
        }
    }
    if (cached_has_bits & 0x00001f00u) {
        // optional .safe_browsing.RTLookupRequest.LookupType lookup_type = 2;
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_lookup_type());
        }

        // optional int32 version = 6 [default = 0];
        if (cached_has_bits & 0x00000200u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_version());
        }

        // optional .safe_browsing.RTLookupRequest.OSType os_type = 7;
        if (cached_has_bits & 0x00000400u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_os_type());
        }

        // optional .safe_browsing.RTLookupRequest.ReportType report_type = 9;
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_report_type());
        }

        // optional .safe_browsing.RTLookupRequest.FrameType frame_type = 10;
        if (cached_has_bits & 0x00001000u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_frame_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void RTLookupRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const RTLookupRequest*>(&from));
}

void RTLookupRequest::MergeFrom(const RTLookupRequest& from)
{
    RTLookupRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.RTLookupRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.referrer_chain_.MergeFrom(from._impl_.referrer_chain_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_deprecated_scoped_oauth_token(from._internal_deprecated_scoped_oauth_token());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_dm_token(from._internal_dm_token());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_profile_dm_token(from._internal_profile_dm_token());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_browser_dm_token(from._internal_browser_dm_token());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_email(from._internal_email());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_population()->::safe_browsing::ChromeUserPopulation::MergeFrom(from._internal_population());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_client_reporting_metadata()->::enterprise_connectors::ClientMetadata::MergeFrom(
                from._internal_client_reporting_metadata());
        }
    }
    if (cached_has_bits & 0x00001f00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.lookup_type_ = from._impl_.lookup_type_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.version_ = from._impl_.version_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.os_type_ = from._impl_.os_type_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.report_type_ = from._impl_.report_type_;
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.frame_type_ = from._impl_.frame_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RTLookupRequest::CopyFrom(const RTLookupRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.RTLookupRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool RTLookupRequest::IsInitialized() const
{
    return true;
}

void RTLookupRequest::InternalSwap(RTLookupRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.referrer_chain_.InternalSwap(&other->_impl_.referrer_chain_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.deprecated_scoped_oauth_token_, lhs_arena, &other->_impl_.deprecated_scoped_oauth_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.dm_token_, lhs_arena, &other->_impl_.dm_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.profile_dm_token_, lhs_arena, &other->_impl_.profile_dm_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.browser_dm_token_, lhs_arena, &other->_impl_.browser_dm_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.email_, lhs_arena, &other->_impl_.email_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(RTLookupRequest, _impl_.frame_type_) + sizeof(RTLookupRequest::_impl_.frame_type_)
        - PROTOBUF_FIELD_OFFSET(RTLookupRequest, _impl_.population_)>(
        reinterpret_cast<char*>(&_impl_.population_), reinterpret_cast<char*>(&other->_impl_.population_));
}

std::string RTLookupRequest::GetTypeName() const
{
    return "safe_browsing.RTLookupRequest";
}

// ===================================================================

class RTLookupResponse_ThreatInfo::_Internal {
public:
    using HasBits = decltype(std::declval<RTLookupResponse_ThreatInfo>()._impl_._has_bits_);
    static void set_has_threat_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_cache_duration_sec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_cache_expression(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_verdict_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_cache_expression_match_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_cache_expression_using_match_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::safe_browsing::MatchedUrlNavigationRule& matched_url_navigation_rule(const RTLookupResponse_ThreatInfo* msg);
    static void set_has_matched_url_navigation_rule(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::safe_browsing::MatchedUrlNavigationRule& RTLookupResponse_ThreatInfo::_Internal::matched_url_navigation_rule(const RTLookupResponse_ThreatInfo* msg)
{
    return *msg->_impl_.matched_url_navigation_rule_;
}
RTLookupResponse_ThreatInfo::RTLookupResponse_ThreatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.RTLookupResponse.ThreatInfo)
}
RTLookupResponse_ThreatInfo::RTLookupResponse_ThreatInfo(const RTLookupResponse_ThreatInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    RTLookupResponse_ThreatInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cache_expression_) {},
        decltype(_impl_.cache_expression_using_match_type_) {}, decltype(_impl_.matched_url_navigation_rule_) { nullptr },
        decltype(_impl_.cache_duration_sec_) {}, decltype(_impl_.threat_type_) {}, decltype(_impl_.verdict_type_) {},
        decltype(_impl_.cache_expression_match_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.cache_expression_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_expression_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_cache_expression()) {
        _this->_impl_.cache_expression_.Set(from._internal_cache_expression(), _this->GetArenaForAllocation());
    }
    _impl_.cache_expression_using_match_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_expression_using_match_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_cache_expression_using_match_type()) {
        _this->_impl_.cache_expression_using_match_type_.Set(from._internal_cache_expression_using_match_type(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_matched_url_navigation_rule()) {
        _this->_impl_.matched_url_navigation_rule_ = new ::safe_browsing::MatchedUrlNavigationRule(*from._impl_.matched_url_navigation_rule_);
    }
    ::memcpy(&_impl_.cache_duration_sec_, &from._impl_.cache_duration_sec_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cache_expression_match_type_) - reinterpret_cast<char*>(&_impl_.cache_duration_sec_))
            + sizeof(_impl_.cache_expression_match_type_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.RTLookupResponse.ThreatInfo)
}

inline void RTLookupResponse_ThreatInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cache_expression_) {},
        decltype(_impl_.cache_expression_using_match_type_) {}, decltype(_impl_.matched_url_navigation_rule_) { nullptr },
        decltype(_impl_.cache_duration_sec_) { int64_t { 0 } }, decltype(_impl_.threat_type_) { 0 }, decltype(_impl_.verdict_type_) { 0 },
        decltype(_impl_.cache_expression_match_type_) { 0 } };
    _impl_.cache_expression_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_expression_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_expression_using_match_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_expression_using_match_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RTLookupResponse_ThreatInfo::~RTLookupResponse_ThreatInfo()
{
    // @@protoc_insertion_point(destructor:safe_browsing.RTLookupResponse.ThreatInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void RTLookupResponse_ThreatInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.cache_expression_.Destroy();
    _impl_.cache_expression_using_match_type_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.matched_url_navigation_rule_;
}

void RTLookupResponse_ThreatInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void RTLookupResponse_ThreatInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.RTLookupResponse.ThreatInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.cache_expression_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.cache_expression_using_match_type_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.matched_url_navigation_rule_ != nullptr);
            _impl_.matched_url_navigation_rule_->Clear();
        }
    }
    if (cached_has_bits & 0x00000078u) {
        ::memset(&_impl_.cache_duration_sec_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cache_expression_match_type_) - reinterpret_cast<char*>(&_impl_.cache_duration_sec_))
                + sizeof(_impl_.cache_expression_match_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* RTLookupResponse_ThreatInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.RTLookupResponse.ThreatInfo.ThreatType threat_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::RTLookupResponse_ThreatInfo_ThreatType_IsValid(val))) {
                    _internal_set_threat_type(static_cast<::safe_browsing::RTLookupResponse_ThreatInfo_ThreatType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 cache_duration_sec = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_cache_duration_sec(&has_bits);
                _impl_.cache_duration_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string cache_expression = 3 [deprecated = true];
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_cache_expression();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.RTLookupResponse.ThreatInfo.VerdictType verdict_type = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::RTLookupResponse_ThreatInfo_VerdictType_IsValid(val))) {
                    _internal_set_verdict_type(static_cast<::safe_browsing::RTLookupResponse_ThreatInfo_VerdictType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.RTLookupResponse.ThreatInfo.CacheExpressionMatchType cache_expression_match_type = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::RTLookupResponse_ThreatInfo_CacheExpressionMatchType_IsValid(val))) {
                    _internal_set_cache_expression_match_type(static_cast<::safe_browsing::RTLookupResponse_ThreatInfo_CacheExpressionMatchType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string cache_expression_using_match_type = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_cache_expression_using_match_type();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.MatchedUrlNavigationRule matched_url_navigation_rule = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_matched_url_navigation_rule(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* RTLookupResponse_ThreatInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.RTLookupResponse.ThreatInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.RTLookupResponse.ThreatInfo.ThreatType threat_type = 1;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_threat_type(), target);
    }

    // optional int64 cache_duration_sec = 2;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_cache_duration_sec(), target);
    }

    // optional string cache_expression = 3 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_cache_expression(), target);
    }

    // optional .safe_browsing.RTLookupResponse.ThreatInfo.VerdictType verdict_type = 4;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_verdict_type(), target);
    }

    // optional .safe_browsing.RTLookupResponse.ThreatInfo.CacheExpressionMatchType cache_expression_match_type = 5;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_cache_expression_match_type(), target);
    }

    // optional string cache_expression_using_match_type = 6;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(6, this->_internal_cache_expression_using_match_type(), target);
    }

    // optional .safe_browsing.MatchedUrlNavigationRule matched_url_navigation_rule = 7;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::matched_url_navigation_rule(this), _Internal::matched_url_navigation_rule(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.RTLookupResponse.ThreatInfo)
    return target;
}

size_t RTLookupResponse_ThreatInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.RTLookupResponse.ThreatInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        // optional string cache_expression = 3 [deprecated = true];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_cache_expression());
        }

        // optional string cache_expression_using_match_type = 6;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_cache_expression_using_match_type());
        }

        // optional .safe_browsing.MatchedUrlNavigationRule matched_url_navigation_rule = 7;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.matched_url_navigation_rule_);
        }

        // optional int64 cache_duration_sec = 2;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_cache_duration_sec());
        }

        // optional .safe_browsing.RTLookupResponse.ThreatInfo.ThreatType threat_type = 1;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_threat_type());
        }

        // optional .safe_browsing.RTLookupResponse.ThreatInfo.VerdictType verdict_type = 4;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_verdict_type());
        }

        // optional .safe_browsing.RTLookupResponse.ThreatInfo.CacheExpressionMatchType cache_expression_match_type = 5;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_cache_expression_match_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void RTLookupResponse_ThreatInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const RTLookupResponse_ThreatInfo*>(&from));
}

void RTLookupResponse_ThreatInfo::MergeFrom(const RTLookupResponse_ThreatInfo& from)
{
    RTLookupResponse_ThreatInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.RTLookupResponse.ThreatInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_cache_expression(from._internal_cache_expression());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_cache_expression_using_match_type(from._internal_cache_expression_using_match_type());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_matched_url_navigation_rule()->::safe_browsing::MatchedUrlNavigationRule::MergeFrom(
                from._internal_matched_url_navigation_rule());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.cache_duration_sec_ = from._impl_.cache_duration_sec_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.threat_type_ = from._impl_.threat_type_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.verdict_type_ = from._impl_.verdict_type_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.cache_expression_match_type_ = from._impl_.cache_expression_match_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RTLookupResponse_ThreatInfo::CopyFrom(const RTLookupResponse_ThreatInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.RTLookupResponse.ThreatInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool RTLookupResponse_ThreatInfo::IsInitialized() const
{
    return true;
}

void RTLookupResponse_ThreatInfo::InternalSwap(RTLookupResponse_ThreatInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.cache_expression_, lhs_arena, &other->_impl_.cache_expression_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.cache_expression_using_match_type_, lhs_arena, &other->_impl_.cache_expression_using_match_type_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(RTLookupResponse_ThreatInfo, _impl_.cache_expression_match_type_)
        + sizeof(RTLookupResponse_ThreatInfo::_impl_.cache_expression_match_type_)
        - PROTOBUF_FIELD_OFFSET(RTLookupResponse_ThreatInfo, _impl_.matched_url_navigation_rule_)>(
        reinterpret_cast<char*>(&_impl_.matched_url_navigation_rule_), reinterpret_cast<char*>(&other->_impl_.matched_url_navigation_rule_));
}

std::string RTLookupResponse_ThreatInfo::GetTypeName() const
{
    return "safe_browsing.RTLookupResponse.ThreatInfo";
}

// ===================================================================

class RTLookupResponse::_Internal {
public:
    using HasBits = decltype(std::declval<RTLookupResponse>()._impl_._has_bits_);
    static void set_has_client_side_detection_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::safe_browsing::LlamaForcedTriggerInfo& llama_forced_trigger_info(const RTLookupResponse* msg);
    static void set_has_llama_forced_trigger_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::safe_browsing::LlamaForcedTriggerInfo& RTLookupResponse::_Internal::llama_forced_trigger_info(const RTLookupResponse* msg)
{
    return *msg->_impl_.llama_forced_trigger_info_;
}
void RTLookupResponse::clear_llama_forced_trigger_info()
{
    if (_impl_.llama_forced_trigger_info_ != nullptr)
        _impl_.llama_forced_trigger_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
RTLookupResponse::RTLookupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.RTLookupResponse)
}
RTLookupResponse::RTLookupResponse(const RTLookupResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    RTLookupResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.threat_info_) { from._impl_.threat_info_ }, decltype(_impl_.url_categories_) { from._impl_.url_categories_ },
        decltype(_impl_.llama_forced_trigger_info_) { nullptr }, decltype(_impl_.client_side_detection_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_llama_forced_trigger_info()) {
        _this->_impl_.llama_forced_trigger_info_ = new ::safe_browsing::LlamaForcedTriggerInfo(*from._impl_.llama_forced_trigger_info_);
    }
    _this->_impl_.client_side_detection_type_ = from._impl_.client_side_detection_type_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.RTLookupResponse)
}

inline void RTLookupResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.threat_info_) { arena },
        decltype(_impl_.url_categories_) { arena }, decltype(_impl_.llama_forced_trigger_info_) { nullptr },
        decltype(_impl_.client_side_detection_type_) { 0 } };
}

RTLookupResponse::~RTLookupResponse()
{
    // @@protoc_insertion_point(destructor:safe_browsing.RTLookupResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void RTLookupResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.threat_info_.~RepeatedPtrField();
    _impl_.url_categories_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.llama_forced_trigger_info_;
}

void RTLookupResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void RTLookupResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.RTLookupResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.threat_info_.Clear();
    _impl_.url_categories_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.llama_forced_trigger_info_ != nullptr);
        _impl_.llama_forced_trigger_info_->Clear();
    }
    _impl_.client_side_detection_type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* RTLookupResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .safe_browsing.RTLookupResponse.ThreatInfo threat_info = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_threat_info(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.ClientSideDetectionType client_side_detection_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::ClientSideDetectionType_IsValid(val))) {
                    _internal_set_client_side_detection_type(static_cast<::safe_browsing::ClientSideDetectionType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated string url_categories = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_url_categories();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.LlamaForcedTriggerInfo llama_forced_trigger_info = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_llama_forced_trigger_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* RTLookupResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.RTLookupResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .safe_browsing.RTLookupResponse.ThreatInfo threat_info = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_threat_info_size()); i < n; i++) {
        const auto& repfield = this->_internal_threat_info(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.ClientSideDetectionType client_side_detection_type = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_client_side_detection_type(), target);
    }

    // repeated string url_categories = 3;
    for (int i = 0, n = this->_internal_url_categories_size(); i < n; i++) {
        const auto& s = this->_internal_url_categories(i);
        target = stream->WriteString(3, s, target);
    }

    // optional .safe_browsing.LlamaForcedTriggerInfo llama_forced_trigger_info = 4;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::llama_forced_trigger_info(this), _Internal::llama_forced_trigger_info(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.RTLookupResponse)
    return target;
}

size_t RTLookupResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.RTLookupResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.RTLookupResponse.ThreatInfo threat_info = 1;
    total_size += 1UL * this->_internal_threat_info_size();
    for (const auto& msg : this->_impl_.threat_info_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated string url_categories = 3;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.url_categories_.size());
    for (int i = 0, n = _impl_.url_categories_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.url_categories_.Get(i));
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .safe_browsing.LlamaForcedTriggerInfo llama_forced_trigger_info = 4;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.llama_forced_trigger_info_);
        }

        // optional .safe_browsing.ClientSideDetectionType client_side_detection_type = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_client_side_detection_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void RTLookupResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const RTLookupResponse*>(&from));
}

void RTLookupResponse::MergeFrom(const RTLookupResponse& from)
{
    RTLookupResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.RTLookupResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.threat_info_.MergeFrom(from._impl_.threat_info_);
    _this->_impl_.url_categories_.MergeFrom(from._impl_.url_categories_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_llama_forced_trigger_info()->::safe_browsing::LlamaForcedTriggerInfo::MergeFrom(
                from._internal_llama_forced_trigger_info());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.client_side_detection_type_ = from._impl_.client_side_detection_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RTLookupResponse::CopyFrom(const RTLookupResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.RTLookupResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool RTLookupResponse::IsInitialized() const
{
    return true;
}

void RTLookupResponse::InternalSwap(RTLookupResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.threat_info_.InternalSwap(&other->_impl_.threat_info_);
    _impl_.url_categories_.InternalSwap(&other->_impl_.url_categories_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(RTLookupResponse, _impl_.client_side_detection_type_)
        + sizeof(RTLookupResponse::_impl_.client_side_detection_type_) - PROTOBUF_FIELD_OFFSET(RTLookupResponse, _impl_.llama_forced_trigger_info_)>(
        reinterpret_cast<char*>(&_impl_.llama_forced_trigger_info_), reinterpret_cast<char*>(&other->_impl_.llama_forced_trigger_info_));
}

std::string RTLookupResponse::GetTypeName() const
{
    return "safe_browsing.RTLookupResponse";
}

// ===================================================================

class Timestamp::_Internal {
public:
    using HasBits = decltype(std::declval<Timestamp>()._impl_._has_bits_);
    static void set_has_seconds(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_nanos(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

Timestamp::Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.Timestamp)
}
Timestamp::Timestamp(const Timestamp& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Timestamp* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.seconds_) {},
        decltype(_impl_.nanos_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.seconds_, &from._impl_.seconds_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nanos_) - reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.Timestamp)
}

inline void Timestamp::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.seconds_) { int64_t { 0 } },
        decltype(_impl_.nanos_) { 0 } };
}

Timestamp::~Timestamp()
{
    // @@protoc_insertion_point(destructor:safe_browsing.Timestamp)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Timestamp::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Timestamp::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Timestamp::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.Timestamp)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.seconds_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.nanos_) - reinterpret_cast<char*>(&_impl_.seconds_)) + sizeof(_impl_.nanos_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* Timestamp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 seconds = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_seconds(&has_bits);
                _impl_.seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 nanos = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_nanos(&has_bits);
                _impl_.nanos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Timestamp::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.Timestamp)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 seconds = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_seconds(), target);
    }

    // optional int32 nanos = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_nanos(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.Timestamp)
    return target;
}

size_t Timestamp::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.Timestamp)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int64 seconds = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seconds());
        }

        // optional int32 nanos = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_nanos());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Timestamp::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Timestamp*>(&from));
}

void Timestamp::MergeFrom(const Timestamp& from)
{
    Timestamp* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.Timestamp)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.seconds_ = from._impl_.seconds_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.nanos_ = from._impl_.nanos_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Timestamp::CopyFrom(const Timestamp& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.Timestamp)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Timestamp::IsInitialized() const
{
    return true;
}

void Timestamp::InternalSwap(Timestamp* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Timestamp, _impl_.nanos_) + sizeof(Timestamp::_impl_.nanos_)
        - PROTOBUF_FIELD_OFFSET(Timestamp, _impl_.seconds_)>(reinterpret_cast<char*>(&_impl_.seconds_), reinterpret_cast<char*>(&other->_impl_.seconds_));
}

std::string Timestamp::GetTypeName() const
{
    return "safe_browsing.Timestamp";
}

// ===================================================================

class MatchedUrlNavigationRule_CustomRuleMessageSegment::_Internal {
public:
    using HasBits = decltype(std::declval<MatchedUrlNavigationRule_CustomRuleMessageSegment>()._impl_._has_bits_);
    static void set_has_text(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_link(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

MatchedUrlNavigationRule_CustomRuleMessageSegment::MatchedUrlNavigationRule_CustomRuleMessageSegment(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment)
}
MatchedUrlNavigationRule_CustomRuleMessageSegment::MatchedUrlNavigationRule_CustomRuleMessageSegment(
    const MatchedUrlNavigationRule_CustomRuleMessageSegment& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    MatchedUrlNavigationRule_CustomRuleMessageSegment* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.text_) {},
        decltype(_impl_.link_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_text()) {
        _this->_impl_.text_.Set(from._internal_text(), _this->GetArenaForAllocation());
    }
    _impl_.link_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.link_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_link()) {
        _this->_impl_.link_.Set(from._internal_link(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment)
}

inline void MatchedUrlNavigationRule_CustomRuleMessageSegment::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.text_) {}, decltype(_impl_.link_) {} };
    _impl_.text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.link_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.link_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MatchedUrlNavigationRule_CustomRuleMessageSegment::~MatchedUrlNavigationRule_CustomRuleMessageSegment()
{
    // @@protoc_insertion_point(destructor:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void MatchedUrlNavigationRule_CustomRuleMessageSegment::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.text_.Destroy();
    _impl_.link_.Destroy();
}

void MatchedUrlNavigationRule_CustomRuleMessageSegment::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void MatchedUrlNavigationRule_CustomRuleMessageSegment::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.text_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.link_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* MatchedUrlNavigationRule_CustomRuleMessageSegment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string text = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_text();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string link = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_link();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* MatchedUrlNavigationRule_CustomRuleMessageSegment::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string text = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_text(), target);
    }

    // optional string link = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_link(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment)
    return target;
}

size_t MatchedUrlNavigationRule_CustomRuleMessageSegment::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string text = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_text());
        }

        // optional string link = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_link());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void MatchedUrlNavigationRule_CustomRuleMessageSegment::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const MatchedUrlNavigationRule_CustomRuleMessageSegment*>(&from));
}

void MatchedUrlNavigationRule_CustomRuleMessageSegment::MergeFrom(const MatchedUrlNavigationRule_CustomRuleMessageSegment& from)
{
    MatchedUrlNavigationRule_CustomRuleMessageSegment* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_text(from._internal_text());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_link(from._internal_link());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MatchedUrlNavigationRule_CustomRuleMessageSegment::CopyFrom(const MatchedUrlNavigationRule_CustomRuleMessageSegment& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool MatchedUrlNavigationRule_CustomRuleMessageSegment::IsInitialized() const
{
    return true;
}

void MatchedUrlNavigationRule_CustomRuleMessageSegment::InternalSwap(MatchedUrlNavigationRule_CustomRuleMessageSegment* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.text_, lhs_arena, &other->_impl_.text_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.link_, lhs_arena, &other->_impl_.link_, rhs_arena);
}

std::string MatchedUrlNavigationRule_CustomRuleMessageSegment::GetTypeName() const
{
    return "safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment";
}

// ===================================================================

class MatchedUrlNavigationRule_CustomMessage::_Internal {
public:
    using HasBits = decltype(std::declval<MatchedUrlNavigationRule_CustomMessage>()._impl_._has_bits_);
    static void set_has_custom_message(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_learn_more_link(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_custom_message_with_links(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

MatchedUrlNavigationRule_CustomMessage::MatchedUrlNavigationRule_CustomMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.MatchedUrlNavigationRule.CustomMessage)
}
MatchedUrlNavigationRule_CustomMessage::MatchedUrlNavigationRule_CustomMessage(const MatchedUrlNavigationRule_CustomMessage& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    MatchedUrlNavigationRule_CustomMessage* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.message_segments_) { from._impl_.message_segments_ }, decltype(_impl_.custom_message_) {}, decltype(_impl_.learn_more_link_) {},
        decltype(_impl_.custom_message_with_links_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.custom_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.custom_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_custom_message()) {
        _this->_impl_.custom_message_.Set(from._internal_custom_message(), _this->GetArenaForAllocation());
    }
    _impl_.learn_more_link_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.learn_more_link_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_learn_more_link()) {
        _this->_impl_.learn_more_link_.Set(from._internal_learn_more_link(), _this->GetArenaForAllocation());
    }
    _impl_.custom_message_with_links_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.custom_message_with_links_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_custom_message_with_links()) {
        _this->_impl_.custom_message_with_links_.Set(from._internal_custom_message_with_links(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.MatchedUrlNavigationRule.CustomMessage)
}

inline void MatchedUrlNavigationRule_CustomMessage::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.message_segments_) { arena },
        decltype(_impl_.custom_message_) {}, decltype(_impl_.learn_more_link_) {}, decltype(_impl_.custom_message_with_links_) {} };
    _impl_.custom_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.custom_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.learn_more_link_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.learn_more_link_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.custom_message_with_links_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.custom_message_with_links_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MatchedUrlNavigationRule_CustomMessage::~MatchedUrlNavigationRule_CustomMessage()
{
    // @@protoc_insertion_point(destructor:safe_browsing.MatchedUrlNavigationRule.CustomMessage)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void MatchedUrlNavigationRule_CustomMessage::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.message_segments_.~RepeatedPtrField();
    _impl_.custom_message_.Destroy();
    _impl_.learn_more_link_.Destroy();
    _impl_.custom_message_with_links_.Destroy();
}

void MatchedUrlNavigationRule_CustomMessage::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void MatchedUrlNavigationRule_CustomMessage::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.MatchedUrlNavigationRule.CustomMessage)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.message_segments_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.custom_message_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.learn_more_link_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.custom_message_with_links_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* MatchedUrlNavigationRule_CustomMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string custom_message = 1 [deprecated = true];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_custom_message();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string learn_more_link = 2 [deprecated = true];
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_learn_more_link();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string custom_message_with_links = 3 [deprecated = true];
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_custom_message_with_links();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment message_segments = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_message_segments(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* MatchedUrlNavigationRule_CustomMessage::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.MatchedUrlNavigationRule.CustomMessage)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string custom_message = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_custom_message(), target);
    }

    // optional string learn_more_link = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_learn_more_link(), target);
    }

    // optional string custom_message_with_links = 3 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_custom_message_with_links(), target);
    }

    // repeated .safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment message_segments = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_message_segments_size()); i < n; i++) {
        const auto& repfield = this->_internal_message_segments(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.MatchedUrlNavigationRule.CustomMessage)
    return target;
}

size_t MatchedUrlNavigationRule_CustomMessage::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.MatchedUrlNavigationRule.CustomMessage)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment message_segments = 4;
    total_size += 1UL * this->_internal_message_segments_size();
    for (const auto& msg : this->_impl_.message_segments_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string custom_message = 1 [deprecated = true];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_custom_message());
        }

        // optional string learn_more_link = 2 [deprecated = true];
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_learn_more_link());
        }

        // optional string custom_message_with_links = 3 [deprecated = true];
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_custom_message_with_links());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void MatchedUrlNavigationRule_CustomMessage::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const MatchedUrlNavigationRule_CustomMessage*>(&from));
}

void MatchedUrlNavigationRule_CustomMessage::MergeFrom(const MatchedUrlNavigationRule_CustomMessage& from)
{
    MatchedUrlNavigationRule_CustomMessage* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.MatchedUrlNavigationRule.CustomMessage)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.message_segments_.MergeFrom(from._impl_.message_segments_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_custom_message(from._internal_custom_message());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_learn_more_link(from._internal_learn_more_link());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_custom_message_with_links(from._internal_custom_message_with_links());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MatchedUrlNavigationRule_CustomMessage::CopyFrom(const MatchedUrlNavigationRule_CustomMessage& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.MatchedUrlNavigationRule.CustomMessage)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool MatchedUrlNavigationRule_CustomMessage::IsInitialized() const
{
    return true;
}

void MatchedUrlNavigationRule_CustomMessage::InternalSwap(MatchedUrlNavigationRule_CustomMessage* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.message_segments_.InternalSwap(&other->_impl_.message_segments_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.custom_message_, lhs_arena, &other->_impl_.custom_message_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.learn_more_link_, lhs_arena, &other->_impl_.learn_more_link_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.custom_message_with_links_, lhs_arena, &other->_impl_.custom_message_with_links_, rhs_arena);
}

std::string MatchedUrlNavigationRule_CustomMessage::GetTypeName() const
{
    return "safe_browsing.MatchedUrlNavigationRule.CustomMessage";
}

// ===================================================================

class MatchedUrlNavigationRule_WatermarkMessage::_Internal {
public:
    using HasBits = decltype(std::declval<MatchedUrlNavigationRule_WatermarkMessage>()._impl_._has_bits_);
    static void set_has_watermark_message(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_user_email(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_obfuscated_device_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::safe_browsing::Timestamp& timestamp(const MatchedUrlNavigationRule_WatermarkMessage* msg);
    static void set_has_timestamp(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::safe_browsing::Timestamp& MatchedUrlNavigationRule_WatermarkMessage::_Internal::timestamp(const MatchedUrlNavigationRule_WatermarkMessage* msg)
{
    return *msg->_impl_.timestamp_;
}
MatchedUrlNavigationRule_WatermarkMessage::MatchedUrlNavigationRule_WatermarkMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage)
}
MatchedUrlNavigationRule_WatermarkMessage::MatchedUrlNavigationRule_WatermarkMessage(const MatchedUrlNavigationRule_WatermarkMessage& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    MatchedUrlNavigationRule_WatermarkMessage* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.watermark_message_) {},
        decltype(_impl_.user_email_) {}, decltype(_impl_.obfuscated_device_id_) {}, decltype(_impl_.timestamp_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.watermark_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.watermark_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_watermark_message()) {
        _this->_impl_.watermark_message_.Set(from._internal_watermark_message(), _this->GetArenaForAllocation());
    }
    _impl_.user_email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_user_email()) {
        _this->_impl_.user_email_.Set(from._internal_user_email(), _this->GetArenaForAllocation());
    }
    _impl_.obfuscated_device_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obfuscated_device_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_obfuscated_device_id()) {
        _this->_impl_.obfuscated_device_id_.Set(from._internal_obfuscated_device_id(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_timestamp()) {
        _this->_impl_.timestamp_ = new ::safe_browsing::Timestamp(*from._impl_.timestamp_);
    }
    // @@protoc_insertion_point(copy_constructor:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage)
}

inline void MatchedUrlNavigationRule_WatermarkMessage::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.watermark_message_) {},
        decltype(_impl_.user_email_) {}, decltype(_impl_.obfuscated_device_id_) {}, decltype(_impl_.timestamp_) { nullptr } };
    _impl_.watermark_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.watermark_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obfuscated_device_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.obfuscated_device_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MatchedUrlNavigationRule_WatermarkMessage::~MatchedUrlNavigationRule_WatermarkMessage()
{
    // @@protoc_insertion_point(destructor:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void MatchedUrlNavigationRule_WatermarkMessage::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.watermark_message_.Destroy();
    _impl_.user_email_.Destroy();
    _impl_.obfuscated_device_id_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.timestamp_;
}

void MatchedUrlNavigationRule_WatermarkMessage::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void MatchedUrlNavigationRule_WatermarkMessage::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.watermark_message_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.user_email_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.obfuscated_device_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.timestamp_ != nullptr);
            _impl_.timestamp_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* MatchedUrlNavigationRule_WatermarkMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string watermark_message = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_watermark_message();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string user_email = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_user_email();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string obfuscated_device_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_obfuscated_device_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.Timestamp timestamp = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* MatchedUrlNavigationRule_WatermarkMessage::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string watermark_message = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_watermark_message(), target);
    }

    // optional string user_email = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_user_email(), target);
    }

    // optional string obfuscated_device_id = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_obfuscated_device_id(), target);
    }

    // optional .safe_browsing.Timestamp timestamp = 4;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::timestamp(this), _Internal::timestamp(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage)
    return target;
}

size_t MatchedUrlNavigationRule_WatermarkMessage::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string watermark_message = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_watermark_message());
        }

        // optional string user_email = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_user_email());
        }

        // optional string obfuscated_device_id = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_obfuscated_device_id());
        }

        // optional .safe_browsing.Timestamp timestamp = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.timestamp_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void MatchedUrlNavigationRule_WatermarkMessage::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const MatchedUrlNavigationRule_WatermarkMessage*>(&from));
}

void MatchedUrlNavigationRule_WatermarkMessage::MergeFrom(const MatchedUrlNavigationRule_WatermarkMessage& from)
{
    MatchedUrlNavigationRule_WatermarkMessage* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_watermark_message(from._internal_watermark_message());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_user_email(from._internal_user_email());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_obfuscated_device_id(from._internal_obfuscated_device_id());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_timestamp()->::safe_browsing::Timestamp::MergeFrom(from._internal_timestamp());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MatchedUrlNavigationRule_WatermarkMessage::CopyFrom(const MatchedUrlNavigationRule_WatermarkMessage& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool MatchedUrlNavigationRule_WatermarkMessage::IsInitialized() const
{
    return true;
}

void MatchedUrlNavigationRule_WatermarkMessage::InternalSwap(MatchedUrlNavigationRule_WatermarkMessage* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.watermark_message_, lhs_arena, &other->_impl_.watermark_message_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.user_email_, lhs_arena, &other->_impl_.user_email_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.obfuscated_device_id_, lhs_arena, &other->_impl_.obfuscated_device_id_, rhs_arena);
    swap(_impl_.timestamp_, other->_impl_.timestamp_);
}

std::string MatchedUrlNavigationRule_WatermarkMessage::GetTypeName() const
{
    return "safe_browsing.MatchedUrlNavigationRule.WatermarkMessage";
}

// ===================================================================

class MatchedUrlNavigationRule::_Internal {
public:
    using HasBits = decltype(std::declval<MatchedUrlNavigationRule>()._impl_._has_bits_);
    static void set_has_rule_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_rule_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_matched_url_category(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::safe_browsing::MatchedUrlNavigationRule_CustomMessage& custom_message(const MatchedUrlNavigationRule* msg);
    static void set_has_custom_message(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage& watermark_message(const MatchedUrlNavigationRule* msg);
    static void set_has_watermark_message(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_block_screenshot(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
};

const ::safe_browsing::MatchedUrlNavigationRule_CustomMessage& MatchedUrlNavigationRule::_Internal::custom_message(const MatchedUrlNavigationRule* msg)
{
    return *msg->_impl_.custom_message_;
}
const ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage& MatchedUrlNavigationRule::_Internal::watermark_message(const MatchedUrlNavigationRule* msg)
{
    return *msg->_impl_.watermark_message_;
}
MatchedUrlNavigationRule::MatchedUrlNavigationRule(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.MatchedUrlNavigationRule)
}
MatchedUrlNavigationRule::MatchedUrlNavigationRule(const MatchedUrlNavigationRule& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    MatchedUrlNavigationRule* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.rule_id_) {},
        decltype(_impl_.rule_name_) {}, decltype(_impl_.matched_url_category_) {}, decltype(_impl_.custom_message_) { nullptr },
        decltype(_impl_.watermark_message_) { nullptr }, decltype(_impl_.block_screenshot_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.rule_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_rule_id()) {
        _this->_impl_.rule_id_.Set(from._internal_rule_id(), _this->GetArenaForAllocation());
    }
    _impl_.rule_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_rule_name()) {
        _this->_impl_.rule_name_.Set(from._internal_rule_name(), _this->GetArenaForAllocation());
    }
    _impl_.matched_url_category_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.matched_url_category_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_matched_url_category()) {
        _this->_impl_.matched_url_category_.Set(from._internal_matched_url_category(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_custom_message()) {
        _this->_impl_.custom_message_ = new ::safe_browsing::MatchedUrlNavigationRule_CustomMessage(*from._impl_.custom_message_);
    }
    if (from._internal_has_watermark_message()) {
        _this->_impl_.watermark_message_ = new ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage(*from._impl_.watermark_message_);
    }
    _this->_impl_.block_screenshot_ = from._impl_.block_screenshot_;
    // @@protoc_insertion_point(copy_constructor:safe_browsing.MatchedUrlNavigationRule)
}

inline void MatchedUrlNavigationRule::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.rule_id_) {}, decltype(_impl_.rule_name_) {},
        decltype(_impl_.matched_url_category_) {}, decltype(_impl_.custom_message_) { nullptr }, decltype(_impl_.watermark_message_) { nullptr },
        decltype(_impl_.block_screenshot_) { false } };
    _impl_.rule_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rule_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.matched_url_category_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.matched_url_category_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MatchedUrlNavigationRule::~MatchedUrlNavigationRule()
{
    // @@protoc_insertion_point(destructor:safe_browsing.MatchedUrlNavigationRule)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void MatchedUrlNavigationRule::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.rule_id_.Destroy();
    _impl_.rule_name_.Destroy();
    _impl_.matched_url_category_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.custom_message_;
    if (this != internal_default_instance())
        delete _impl_.watermark_message_;
}

void MatchedUrlNavigationRule::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void MatchedUrlNavigationRule::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.MatchedUrlNavigationRule)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.rule_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.rule_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.matched_url_category_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.custom_message_ != nullptr);
            _impl_.custom_message_->Clear();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.watermark_message_ != nullptr);
            _impl_.watermark_message_->Clear();
        }
    }
    _impl_.block_screenshot_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* MatchedUrlNavigationRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string rule_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_rule_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string rule_name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_rule_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string matched_url_category = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_matched_url_category();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.MatchedUrlNavigationRule.CustomMessage custom_message = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_custom_message(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.MatchedUrlNavigationRule.WatermarkMessage watermark_message = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_watermark_message(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool block_screenshot = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_block_screenshot(&has_bits);
                _impl_.block_screenshot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* MatchedUrlNavigationRule::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.MatchedUrlNavigationRule)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string rule_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_rule_id(), target);
    }

    // optional string rule_name = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_rule_name(), target);
    }

    // optional string matched_url_category = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_matched_url_category(), target);
    }

    // optional .safe_browsing.MatchedUrlNavigationRule.CustomMessage custom_message = 5;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::custom_message(this), _Internal::custom_message(this).GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.MatchedUrlNavigationRule.WatermarkMessage watermark_message = 6;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::watermark_message(this), _Internal::watermark_message(this).GetCachedSize(), target, stream);
    }

    // optional bool block_screenshot = 8;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_block_screenshot(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.MatchedUrlNavigationRule)
    return target;
}

size_t MatchedUrlNavigationRule::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.MatchedUrlNavigationRule)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional string rule_id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_rule_id());
        }

        // optional string rule_name = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_rule_name());
        }

        // optional string matched_url_category = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_matched_url_category());
        }

        // optional .safe_browsing.MatchedUrlNavigationRule.CustomMessage custom_message = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.custom_message_);
        }

        // optional .safe_browsing.MatchedUrlNavigationRule.WatermarkMessage watermark_message = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.watermark_message_);
        }

        // optional bool block_screenshot = 8;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void MatchedUrlNavigationRule::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const MatchedUrlNavigationRule*>(&from));
}

void MatchedUrlNavigationRule::MergeFrom(const MatchedUrlNavigationRule& from)
{
    MatchedUrlNavigationRule* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.MatchedUrlNavigationRule)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_rule_id(from._internal_rule_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_rule_name(from._internal_rule_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_matched_url_category(from._internal_matched_url_category());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_custom_message()->::safe_browsing::MatchedUrlNavigationRule_CustomMessage::MergeFrom(from._internal_custom_message());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_watermark_message()->::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage::MergeFrom(
                from._internal_watermark_message());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.block_screenshot_ = from._impl_.block_screenshot_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MatchedUrlNavigationRule::CopyFrom(const MatchedUrlNavigationRule& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.MatchedUrlNavigationRule)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool MatchedUrlNavigationRule::IsInitialized() const
{
    return true;
}

void MatchedUrlNavigationRule::InternalSwap(MatchedUrlNavigationRule* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.rule_id_, lhs_arena, &other->_impl_.rule_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.rule_name_, lhs_arena, &other->_impl_.rule_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.matched_url_category_, lhs_arena, &other->_impl_.matched_url_category_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(MatchedUrlNavigationRule, _impl_.block_screenshot_)
        + sizeof(MatchedUrlNavigationRule::_impl_.block_screenshot_) - PROTOBUF_FIELD_OFFSET(MatchedUrlNavigationRule, _impl_.custom_message_)>(
        reinterpret_cast<char*>(&_impl_.custom_message_), reinterpret_cast<char*>(&other->_impl_.custom_message_));
}

std::string MatchedUrlNavigationRule::GetTypeName() const
{
    return "safe_browsing.MatchedUrlNavigationRule";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace safe_browsing
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::safe_browsing::RTLookupRequest* Arena::CreateMaybeMessage<::safe_browsing::RTLookupRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::RTLookupRequest>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::RTLookupResponse_ThreatInfo* Arena::CreateMaybeMessage<::safe_browsing::RTLookupResponse_ThreatInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::RTLookupResponse_ThreatInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::RTLookupResponse* Arena::CreateMaybeMessage<::safe_browsing::RTLookupResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::RTLookupResponse>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::Timestamp* Arena::CreateMaybeMessage<::safe_browsing::Timestamp>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::Timestamp>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment*
Arena::CreateMaybeMessage<::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::MatchedUrlNavigationRule_CustomMessage* Arena::CreateMaybeMessage<::safe_browsing::MatchedUrlNavigationRule_CustomMessage>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::MatchedUrlNavigationRule_CustomMessage>(arena);
}
template <>
PROTOBUF_NOINLINE ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage*
Arena::CreateMaybeMessage<::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::MatchedUrlNavigationRule* Arena::CreateMaybeMessage<::safe_browsing::MatchedUrlNavigationRule>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::MatchedUrlNavigationRule>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
