// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/safe_browsing/core/common/proto/realtimeapi.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fsafe_5fbrowsing_2fcore_2fcommon_2fproto_2frealtimeapi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fsafe_5fbrowsing_2fcore_2fcommon_2fproto_2frealtimeapi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/enterprise/common/proto/connectors.pb.h"
#include "components/safe_browsing/core/common/proto/csd.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fsafe_5fbrowsing_2fcore_2fcommon_2fproto_2frealtimeapi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fsafe_5fbrowsing_2fcore_2fcommon_2fproto_2frealtimeapi_2eproto {
    static const uint32_t offsets[];
};
namespace safe_browsing {
class MatchedUrlNavigationRule;
struct MatchedUrlNavigationRuleDefaultTypeInternal;
extern MatchedUrlNavigationRuleDefaultTypeInternal _MatchedUrlNavigationRule_default_instance_;
class MatchedUrlNavigationRule_CustomMessage;
struct MatchedUrlNavigationRule_CustomMessageDefaultTypeInternal;
extern MatchedUrlNavigationRule_CustomMessageDefaultTypeInternal _MatchedUrlNavigationRule_CustomMessage_default_instance_;
class MatchedUrlNavigationRule_CustomRuleMessageSegment;
struct MatchedUrlNavigationRule_CustomRuleMessageSegmentDefaultTypeInternal;
extern MatchedUrlNavigationRule_CustomRuleMessageSegmentDefaultTypeInternal _MatchedUrlNavigationRule_CustomRuleMessageSegment_default_instance_;
class MatchedUrlNavigationRule_WatermarkMessage;
struct MatchedUrlNavigationRule_WatermarkMessageDefaultTypeInternal;
extern MatchedUrlNavigationRule_WatermarkMessageDefaultTypeInternal _MatchedUrlNavigationRule_WatermarkMessage_default_instance_;
class RTLookupRequest;
struct RTLookupRequestDefaultTypeInternal;
extern RTLookupRequestDefaultTypeInternal _RTLookupRequest_default_instance_;
class RTLookupResponse;
struct RTLookupResponseDefaultTypeInternal;
extern RTLookupResponseDefaultTypeInternal _RTLookupResponse_default_instance_;
class RTLookupResponse_ThreatInfo;
struct RTLookupResponse_ThreatInfoDefaultTypeInternal;
extern RTLookupResponse_ThreatInfoDefaultTypeInternal _RTLookupResponse_ThreatInfo_default_instance_;
class Timestamp;
struct TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
} // namespace safe_browsing
PROTOBUF_NAMESPACE_OPEN
template <>::safe_browsing::MatchedUrlNavigationRule* Arena::CreateMaybeMessage<::safe_browsing::MatchedUrlNavigationRule>(Arena*);
template <>::safe_browsing::MatchedUrlNavigationRule_CustomMessage* Arena::CreateMaybeMessage<::safe_browsing::MatchedUrlNavigationRule_CustomMessage>(Arena*);
template <>
::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment*
Arena::CreateMaybeMessage<::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment>(Arena*);
template <>
::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* Arena::CreateMaybeMessage<::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage>(Arena*);
template <>::safe_browsing::RTLookupRequest* Arena::CreateMaybeMessage<::safe_browsing::RTLookupRequest>(Arena*);
template <>::safe_browsing::RTLookupResponse* Arena::CreateMaybeMessage<::safe_browsing::RTLookupResponse>(Arena*);
template <>::safe_browsing::RTLookupResponse_ThreatInfo* Arena::CreateMaybeMessage<::safe_browsing::RTLookupResponse_ThreatInfo>(Arena*);
template <>::safe_browsing::Timestamp* Arena::CreateMaybeMessage<::safe_browsing::Timestamp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace safe_browsing {

enum RTLookupRequest_LookupType : int {
    RTLookupRequest_LookupType_LOOKUP_TYPE_UNSPECIFIED = 0,
    RTLookupRequest_LookupType_NAVIGATION = 1,
    RTLookupRequest_LookupType_DOWNLOAD = 2
};
bool RTLookupRequest_LookupType_IsValid(int value);
constexpr RTLookupRequest_LookupType RTLookupRequest_LookupType_LookupType_MIN = RTLookupRequest_LookupType_LOOKUP_TYPE_UNSPECIFIED;
constexpr RTLookupRequest_LookupType RTLookupRequest_LookupType_LookupType_MAX = RTLookupRequest_LookupType_DOWNLOAD;
constexpr int RTLookupRequest_LookupType_LookupType_ARRAYSIZE = RTLookupRequest_LookupType_LookupType_MAX + 1;

const std::string& RTLookupRequest_LookupType_Name(RTLookupRequest_LookupType value);
template <typename T> inline const std::string& RTLookupRequest_LookupType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, RTLookupRequest_LookupType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function RTLookupRequest_LookupType_Name.");
    return RTLookupRequest_LookupType_Name(static_cast<RTLookupRequest_LookupType>(enum_t_value));
}
bool RTLookupRequest_LookupType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RTLookupRequest_LookupType* value);
enum RTLookupRequest_OSType : int {
    RTLookupRequest_OSType_OS_TYPE_UNSPECIFIED = 0,
    RTLookupRequest_OSType_OS_TYPE_ANDROID = 1,
    RTLookupRequest_OSType_OS_TYPE_CHROME_OS = 2,
    RTLookupRequest_OSType_OS_TYPE_IOS = 4,
    RTLookupRequest_OSType_OS_TYPE_LINUX = 5,
    RTLookupRequest_OSType_OS_TYPE_MAC = 6,
    RTLookupRequest_OSType_OS_TYPE_WINDOWS = 7
};
bool RTLookupRequest_OSType_IsValid(int value);
constexpr RTLookupRequest_OSType RTLookupRequest_OSType_OSType_MIN = RTLookupRequest_OSType_OS_TYPE_UNSPECIFIED;
constexpr RTLookupRequest_OSType RTLookupRequest_OSType_OSType_MAX = RTLookupRequest_OSType_OS_TYPE_WINDOWS;
constexpr int RTLookupRequest_OSType_OSType_ARRAYSIZE = RTLookupRequest_OSType_OSType_MAX + 1;

const std::string& RTLookupRequest_OSType_Name(RTLookupRequest_OSType value);
template <typename T> inline const std::string& RTLookupRequest_OSType_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, RTLookupRequest_OSType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function RTLookupRequest_OSType_Name.");
    return RTLookupRequest_OSType_Name(static_cast<RTLookupRequest_OSType>(enum_t_value));
}
bool RTLookupRequest_OSType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RTLookupRequest_OSType* value);
enum RTLookupRequest_ReportType : int {
    RTLookupRequest_ReportType_REPORT_TYPE_UNSPECIFIED = 0,
    RTLookupRequest_ReportType_FULL_REPORT = 1,
    RTLookupRequest_ReportType_SAMPLED_REPORT = 2
};
bool RTLookupRequest_ReportType_IsValid(int value);
constexpr RTLookupRequest_ReportType RTLookupRequest_ReportType_ReportType_MIN = RTLookupRequest_ReportType_REPORT_TYPE_UNSPECIFIED;
constexpr RTLookupRequest_ReportType RTLookupRequest_ReportType_ReportType_MAX = RTLookupRequest_ReportType_SAMPLED_REPORT;
constexpr int RTLookupRequest_ReportType_ReportType_ARRAYSIZE = RTLookupRequest_ReportType_ReportType_MAX + 1;

const std::string& RTLookupRequest_ReportType_Name(RTLookupRequest_ReportType value);
template <typename T> inline const std::string& RTLookupRequest_ReportType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, RTLookupRequest_ReportType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function RTLookupRequest_ReportType_Name.");
    return RTLookupRequest_ReportType_Name(static_cast<RTLookupRequest_ReportType>(enum_t_value));
}
bool RTLookupRequest_ReportType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RTLookupRequest_ReportType* value);
enum RTLookupRequest_FrameType : int {
    RTLookupRequest_FrameType_FRAME_TYPE_UNSPECIFIED = 0,
    RTLookupRequest_FrameType_MAIN_FRAME = 1,
    RTLookupRequest_FrameType_SUB_FRAME = 2
};
bool RTLookupRequest_FrameType_IsValid(int value);
constexpr RTLookupRequest_FrameType RTLookupRequest_FrameType_FrameType_MIN = RTLookupRequest_FrameType_FRAME_TYPE_UNSPECIFIED;
constexpr RTLookupRequest_FrameType RTLookupRequest_FrameType_FrameType_MAX = RTLookupRequest_FrameType_SUB_FRAME;
constexpr int RTLookupRequest_FrameType_FrameType_ARRAYSIZE = RTLookupRequest_FrameType_FrameType_MAX + 1;

const std::string& RTLookupRequest_FrameType_Name(RTLookupRequest_FrameType value);
template <typename T> inline const std::string& RTLookupRequest_FrameType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, RTLookupRequest_FrameType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function RTLookupRequest_FrameType_Name.");
    return RTLookupRequest_FrameType_Name(static_cast<RTLookupRequest_FrameType>(enum_t_value));
}
bool RTLookupRequest_FrameType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RTLookupRequest_FrameType* value);
enum RTLookupResponse_ThreatInfo_ThreatType : int {
    RTLookupResponse_ThreatInfo_ThreatType_THREAT_TYPE_UNSPECIFIED = 0,
    RTLookupResponse_ThreatInfo_ThreatType_WEB_MALWARE = 1,
    RTLookupResponse_ThreatInfo_ThreatType_SOCIAL_ENGINEERING = 3,
    RTLookupResponse_ThreatInfo_ThreatType_UNWANTED_SOFTWARE = 4,
    RTLookupResponse_ThreatInfo_ThreatType_UNCLEAR_BILLING = 5,
    RTLookupResponse_ThreatInfo_ThreatType_MANAGED_POLICY = 6
};
bool RTLookupResponse_ThreatInfo_ThreatType_IsValid(int value);
constexpr RTLookupResponse_ThreatInfo_ThreatType RTLookupResponse_ThreatInfo_ThreatType_ThreatType_MIN
    = RTLookupResponse_ThreatInfo_ThreatType_THREAT_TYPE_UNSPECIFIED;
constexpr RTLookupResponse_ThreatInfo_ThreatType RTLookupResponse_ThreatInfo_ThreatType_ThreatType_MAX = RTLookupResponse_ThreatInfo_ThreatType_MANAGED_POLICY;
constexpr int RTLookupResponse_ThreatInfo_ThreatType_ThreatType_ARRAYSIZE = RTLookupResponse_ThreatInfo_ThreatType_ThreatType_MAX + 1;

const std::string& RTLookupResponse_ThreatInfo_ThreatType_Name(RTLookupResponse_ThreatInfo_ThreatType value);
template <typename T> inline const std::string& RTLookupResponse_ThreatInfo_ThreatType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, RTLookupResponse_ThreatInfo_ThreatType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function RTLookupResponse_ThreatInfo_ThreatType_Name.");
    return RTLookupResponse_ThreatInfo_ThreatType_Name(static_cast<RTLookupResponse_ThreatInfo_ThreatType>(enum_t_value));
}
bool RTLookupResponse_ThreatInfo_ThreatType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RTLookupResponse_ThreatInfo_ThreatType* value);
enum RTLookupResponse_ThreatInfo_VerdictType : int {
    RTLookupResponse_ThreatInfo_VerdictType_VERDICT_TYPE_UNSPECIFIED = 0,
    RTLookupResponse_ThreatInfo_VerdictType_SAFE = 1,
    RTLookupResponse_ThreatInfo_VerdictType_SUSPICIOUS = 50,
    RTLookupResponse_ThreatInfo_VerdictType_WARN = 75,
    RTLookupResponse_ThreatInfo_VerdictType_DANGEROUS = 100
};
bool RTLookupResponse_ThreatInfo_VerdictType_IsValid(int value);
constexpr RTLookupResponse_ThreatInfo_VerdictType RTLookupResponse_ThreatInfo_VerdictType_VerdictType_MIN
    = RTLookupResponse_ThreatInfo_VerdictType_VERDICT_TYPE_UNSPECIFIED;
constexpr RTLookupResponse_ThreatInfo_VerdictType RTLookupResponse_ThreatInfo_VerdictType_VerdictType_MAX = RTLookupResponse_ThreatInfo_VerdictType_DANGEROUS;
constexpr int RTLookupResponse_ThreatInfo_VerdictType_VerdictType_ARRAYSIZE = RTLookupResponse_ThreatInfo_VerdictType_VerdictType_MAX + 1;

const std::string& RTLookupResponse_ThreatInfo_VerdictType_Name(RTLookupResponse_ThreatInfo_VerdictType value);
template <typename T> inline const std::string& RTLookupResponse_ThreatInfo_VerdictType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, RTLookupResponse_ThreatInfo_VerdictType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function RTLookupResponse_ThreatInfo_VerdictType_Name.");
    return RTLookupResponse_ThreatInfo_VerdictType_Name(static_cast<RTLookupResponse_ThreatInfo_VerdictType>(enum_t_value));
}
bool RTLookupResponse_ThreatInfo_VerdictType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RTLookupResponse_ThreatInfo_VerdictType* value);
enum RTLookupResponse_ThreatInfo_CacheExpressionMatchType : int {
    RTLookupResponse_ThreatInfo_CacheExpressionMatchType_MATCH_TYPE_UNSPECIFIED = 0,
    RTLookupResponse_ThreatInfo_CacheExpressionMatchType_COVERING_MATCH = 1,
    RTLookupResponse_ThreatInfo_CacheExpressionMatchType_EXACT_MATCH = 2
};
bool RTLookupResponse_ThreatInfo_CacheExpressionMatchType_IsValid(int value);
constexpr RTLookupResponse_ThreatInfo_CacheExpressionMatchType RTLookupResponse_ThreatInfo_CacheExpressionMatchType_CacheExpressionMatchType_MIN
    = RTLookupResponse_ThreatInfo_CacheExpressionMatchType_MATCH_TYPE_UNSPECIFIED;
constexpr RTLookupResponse_ThreatInfo_CacheExpressionMatchType RTLookupResponse_ThreatInfo_CacheExpressionMatchType_CacheExpressionMatchType_MAX
    = RTLookupResponse_ThreatInfo_CacheExpressionMatchType_EXACT_MATCH;
constexpr int RTLookupResponse_ThreatInfo_CacheExpressionMatchType_CacheExpressionMatchType_ARRAYSIZE
    = RTLookupResponse_ThreatInfo_CacheExpressionMatchType_CacheExpressionMatchType_MAX + 1;

const std::string& RTLookupResponse_ThreatInfo_CacheExpressionMatchType_Name(RTLookupResponse_ThreatInfo_CacheExpressionMatchType value);
template <typename T> inline const std::string& RTLookupResponse_ThreatInfo_CacheExpressionMatchType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, RTLookupResponse_ThreatInfo_CacheExpressionMatchType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function RTLookupResponse_ThreatInfo_CacheExpressionMatchType_Name.");
    return RTLookupResponse_ThreatInfo_CacheExpressionMatchType_Name(static_cast<RTLookupResponse_ThreatInfo_CacheExpressionMatchType>(enum_t_value));
}
bool RTLookupResponse_ThreatInfo_CacheExpressionMatchType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RTLookupResponse_ThreatInfo_CacheExpressionMatchType* value);
// ===================================================================

class RTLookupRequest final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.RTLookupRequest) */ {
public:
    inline RTLookupRequest()
        : RTLookupRequest(nullptr)
    {
    }
    ~RTLookupRequest() override;
    explicit PROTOBUF_CONSTEXPR RTLookupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    RTLookupRequest(const RTLookupRequest& from);
    RTLookupRequest(RTLookupRequest&& from) noexcept
        : RTLookupRequest()
    {
        *this = ::std::move(from);
    }

    inline RTLookupRequest& operator=(const RTLookupRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline RTLookupRequest& operator=(RTLookupRequest&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const RTLookupRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const RTLookupRequest* internal_default_instance()
    {
        return reinterpret_cast<const RTLookupRequest*>(&_RTLookupRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(RTLookupRequest& a, RTLookupRequest& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(RTLookupRequest* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(RTLookupRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    RTLookupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<RTLookupRequest>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const RTLookupRequest& from);
    void MergeFrom(const RTLookupRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RTLookupRequest* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "safe_browsing.RTLookupRequest";
    }

protected:
    explicit RTLookupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef RTLookupRequest_LookupType LookupType;
    static constexpr LookupType LOOKUP_TYPE_UNSPECIFIED = RTLookupRequest_LookupType_LOOKUP_TYPE_UNSPECIFIED;
    static constexpr LookupType NAVIGATION = RTLookupRequest_LookupType_NAVIGATION;
    static constexpr LookupType DOWNLOAD = RTLookupRequest_LookupType_DOWNLOAD;
    static inline bool LookupType_IsValid(int value)
    {
        return RTLookupRequest_LookupType_IsValid(value);
    }
    static constexpr LookupType LookupType_MIN = RTLookupRequest_LookupType_LookupType_MIN;
    static constexpr LookupType LookupType_MAX = RTLookupRequest_LookupType_LookupType_MAX;
    static constexpr int LookupType_ARRAYSIZE = RTLookupRequest_LookupType_LookupType_ARRAYSIZE;
    template <typename T> static inline const std::string& LookupType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, LookupType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function LookupType_Name.");
        return RTLookupRequest_LookupType_Name(enum_t_value);
    }
    static inline bool LookupType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LookupType* value)
    {
        return RTLookupRequest_LookupType_Parse(name, value);
    }

    typedef RTLookupRequest_OSType OSType;
    static constexpr OSType OS_TYPE_UNSPECIFIED = RTLookupRequest_OSType_OS_TYPE_UNSPECIFIED;
    static constexpr OSType OS_TYPE_ANDROID = RTLookupRequest_OSType_OS_TYPE_ANDROID;
    static constexpr OSType OS_TYPE_CHROME_OS = RTLookupRequest_OSType_OS_TYPE_CHROME_OS;
    static constexpr OSType OS_TYPE_IOS = RTLookupRequest_OSType_OS_TYPE_IOS;
    static constexpr OSType OS_TYPE_LINUX = RTLookupRequest_OSType_OS_TYPE_LINUX;
    static constexpr OSType OS_TYPE_MAC = RTLookupRequest_OSType_OS_TYPE_MAC;
    static constexpr OSType OS_TYPE_WINDOWS = RTLookupRequest_OSType_OS_TYPE_WINDOWS;
    static inline bool OSType_IsValid(int value)
    {
        return RTLookupRequest_OSType_IsValid(value);
    }
    static constexpr OSType OSType_MIN = RTLookupRequest_OSType_OSType_MIN;
    static constexpr OSType OSType_MAX = RTLookupRequest_OSType_OSType_MAX;
    static constexpr int OSType_ARRAYSIZE = RTLookupRequest_OSType_OSType_ARRAYSIZE;
    template <typename T> static inline const std::string& OSType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, OSType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function OSType_Name.");
        return RTLookupRequest_OSType_Name(enum_t_value);
    }
    static inline bool OSType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OSType* value)
    {
        return RTLookupRequest_OSType_Parse(name, value);
    }

    typedef RTLookupRequest_ReportType ReportType;
    static constexpr ReportType REPORT_TYPE_UNSPECIFIED = RTLookupRequest_ReportType_REPORT_TYPE_UNSPECIFIED;
    static constexpr ReportType FULL_REPORT = RTLookupRequest_ReportType_FULL_REPORT;
    static constexpr ReportType SAMPLED_REPORT = RTLookupRequest_ReportType_SAMPLED_REPORT;
    static inline bool ReportType_IsValid(int value)
    {
        return RTLookupRequest_ReportType_IsValid(value);
    }
    static constexpr ReportType ReportType_MIN = RTLookupRequest_ReportType_ReportType_MIN;
    static constexpr ReportType ReportType_MAX = RTLookupRequest_ReportType_ReportType_MAX;
    static constexpr int ReportType_ARRAYSIZE = RTLookupRequest_ReportType_ReportType_ARRAYSIZE;
    template <typename T> static inline const std::string& ReportType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ReportType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ReportType_Name.");
        return RTLookupRequest_ReportType_Name(enum_t_value);
    }
    static inline bool ReportType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ReportType* value)
    {
        return RTLookupRequest_ReportType_Parse(name, value);
    }

    typedef RTLookupRequest_FrameType FrameType;
    static constexpr FrameType FRAME_TYPE_UNSPECIFIED = RTLookupRequest_FrameType_FRAME_TYPE_UNSPECIFIED;
    static constexpr FrameType MAIN_FRAME = RTLookupRequest_FrameType_MAIN_FRAME;
    static constexpr FrameType SUB_FRAME = RTLookupRequest_FrameType_SUB_FRAME;
    static inline bool FrameType_IsValid(int value)
    {
        return RTLookupRequest_FrameType_IsValid(value);
    }
    static constexpr FrameType FrameType_MIN = RTLookupRequest_FrameType_FrameType_MIN;
    static constexpr FrameType FrameType_MAX = RTLookupRequest_FrameType_FrameType_MAX;
    static constexpr int FrameType_ARRAYSIZE = RTLookupRequest_FrameType_FrameType_ARRAYSIZE;
    template <typename T> static inline const std::string& FrameType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, FrameType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function FrameType_Name.");
        return RTLookupRequest_FrameType_Name(enum_t_value);
    }
    static inline bool FrameType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FrameType* value)
    {
        return RTLookupRequest_FrameType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kReferrerChainFieldNumber = 8,
        kUrlFieldNumber = 1,
        kDEPRECATEDScopedOauthTokenFieldNumber = 4,
        kDmTokenFieldNumber = 5,
        kProfileDmTokenFieldNumber = 11,
        kBrowserDmTokenFieldNumber = 12,
        kEmailFieldNumber = 13,
        kPopulationFieldNumber = 3,
        kClientReportingMetadataFieldNumber = 14,
        kLookupTypeFieldNumber = 2,
        kVersionFieldNumber = 6,
        kOsTypeFieldNumber = 7,
        kReportTypeFieldNumber = 9,
        kFrameTypeFieldNumber = 10,
    };
    // repeated .safe_browsing.ReferrerChainEntry referrer_chain = 8;
    int referrer_chain_size() const;

private:
    int _internal_referrer_chain_size() const;

public:
    void clear_referrer_chain();
    ::safe_browsing::ReferrerChainEntry* mutable_referrer_chain(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::ReferrerChainEntry>* mutable_referrer_chain();

private:
    const ::safe_browsing::ReferrerChainEntry& _internal_referrer_chain(int index) const;
    ::safe_browsing::ReferrerChainEntry* _internal_add_referrer_chain();

public:
    const ::safe_browsing::ReferrerChainEntry& referrer_chain(int index) const;
    ::safe_browsing::ReferrerChainEntry* add_referrer_chain();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::ReferrerChainEntry>& referrer_chain() const;

    // optional string url = 1;
    bool has_url() const;

private:
    bool _internal_has_url() const;

public:
    void clear_url();
    const std::string& url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url();
    PROTOBUF_NODISCARD std::string* release_url();
    void set_allocated_url(std::string* url);

private:
    const std::string& _internal_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
    std::string* _internal_mutable_url();

public:
    // optional string DEPRECATED_scoped_oauth_token = 4 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_deprecated_scoped_oauth_token() const;

private:
    bool _internal_has_deprecated_scoped_oauth_token() const;

public:
    PROTOBUF_DEPRECATED void clear_deprecated_scoped_oauth_token();
    PROTOBUF_DEPRECATED const std::string& deprecated_scoped_oauth_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_deprecated_scoped_oauth_token(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_deprecated_scoped_oauth_token();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_deprecated_scoped_oauth_token();
    PROTOBUF_DEPRECATED void set_allocated_deprecated_scoped_oauth_token(std::string* deprecated_scoped_oauth_token);

private:
    const std::string& _internal_deprecated_scoped_oauth_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_deprecated_scoped_oauth_token(const std::string& value);
    std::string* _internal_mutable_deprecated_scoped_oauth_token();

public:
    // optional string dm_token = 5;
    bool has_dm_token() const;

private:
    bool _internal_has_dm_token() const;

public:
    void clear_dm_token();
    const std::string& dm_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_dm_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_dm_token();
    PROTOBUF_NODISCARD std::string* release_dm_token();
    void set_allocated_dm_token(std::string* dm_token);

private:
    const std::string& _internal_dm_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_dm_token(const std::string& value);
    std::string* _internal_mutable_dm_token();

public:
    // optional string profile_dm_token = 11;
    bool has_profile_dm_token() const;

private:
    bool _internal_has_profile_dm_token() const;

public:
    void clear_profile_dm_token();
    const std::string& profile_dm_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_profile_dm_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_profile_dm_token();
    PROTOBUF_NODISCARD std::string* release_profile_dm_token();
    void set_allocated_profile_dm_token(std::string* profile_dm_token);

private:
    const std::string& _internal_profile_dm_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_profile_dm_token(const std::string& value);
    std::string* _internal_mutable_profile_dm_token();

public:
    // optional string browser_dm_token = 12;
    bool has_browser_dm_token() const;

private:
    bool _internal_has_browser_dm_token() const;

public:
    void clear_browser_dm_token();
    const std::string& browser_dm_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_browser_dm_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_browser_dm_token();
    PROTOBUF_NODISCARD std::string* release_browser_dm_token();
    void set_allocated_browser_dm_token(std::string* browser_dm_token);

private:
    const std::string& _internal_browser_dm_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_browser_dm_token(const std::string& value);
    std::string* _internal_mutable_browser_dm_token();

public:
    // optional string email = 13;
    bool has_email() const;

private:
    bool _internal_has_email() const;

public:
    void clear_email();
    const std::string& email() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_email(ArgT0&& arg0, ArgT... args);
    std::string* mutable_email();
    PROTOBUF_NODISCARD std::string* release_email();
    void set_allocated_email(std::string* email);

private:
    const std::string& _internal_email() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
    std::string* _internal_mutable_email();

public:
    // optional .safe_browsing.ChromeUserPopulation population = 3;
    bool has_population() const;

private:
    bool _internal_has_population() const;

public:
    void clear_population();
    const ::safe_browsing::ChromeUserPopulation& population() const;
    PROTOBUF_NODISCARD ::safe_browsing::ChromeUserPopulation* release_population();
    ::safe_browsing::ChromeUserPopulation* mutable_population();
    void set_allocated_population(::safe_browsing::ChromeUserPopulation* population);

private:
    const ::safe_browsing::ChromeUserPopulation& _internal_population() const;
    ::safe_browsing::ChromeUserPopulation* _internal_mutable_population();

public:
    void unsafe_arena_set_allocated_population(::safe_browsing::ChromeUserPopulation* population);
    ::safe_browsing::ChromeUserPopulation* unsafe_arena_release_population();

    // optional .enterprise_connectors.ClientMetadata client_reporting_metadata = 14;
    bool has_client_reporting_metadata() const;

private:
    bool _internal_has_client_reporting_metadata() const;

public:
    void clear_client_reporting_metadata();
    const ::enterprise_connectors::ClientMetadata& client_reporting_metadata() const;
    PROTOBUF_NODISCARD ::enterprise_connectors::ClientMetadata* release_client_reporting_metadata();
    ::enterprise_connectors::ClientMetadata* mutable_client_reporting_metadata();
    void set_allocated_client_reporting_metadata(::enterprise_connectors::ClientMetadata* client_reporting_metadata);

private:
    const ::enterprise_connectors::ClientMetadata& _internal_client_reporting_metadata() const;
    ::enterprise_connectors::ClientMetadata* _internal_mutable_client_reporting_metadata();

public:
    void unsafe_arena_set_allocated_client_reporting_metadata(::enterprise_connectors::ClientMetadata* client_reporting_metadata);
    ::enterprise_connectors::ClientMetadata* unsafe_arena_release_client_reporting_metadata();

    // optional .safe_browsing.RTLookupRequest.LookupType lookup_type = 2;
    bool has_lookup_type() const;

private:
    bool _internal_has_lookup_type() const;

public:
    void clear_lookup_type();
    ::safe_browsing::RTLookupRequest_LookupType lookup_type() const;
    void set_lookup_type(::safe_browsing::RTLookupRequest_LookupType value);

private:
    ::safe_browsing::RTLookupRequest_LookupType _internal_lookup_type() const;
    void _internal_set_lookup_type(::safe_browsing::RTLookupRequest_LookupType value);

public:
    // optional int32 version = 6 [default = 0];
    bool has_version() const;

private:
    bool _internal_has_version() const;

public:
    void clear_version();
    int32_t version() const;
    void set_version(int32_t value);

private:
    int32_t _internal_version() const;
    void _internal_set_version(int32_t value);

public:
    // optional .safe_browsing.RTLookupRequest.OSType os_type = 7;
    bool has_os_type() const;

private:
    bool _internal_has_os_type() const;

public:
    void clear_os_type();
    ::safe_browsing::RTLookupRequest_OSType os_type() const;
    void set_os_type(::safe_browsing::RTLookupRequest_OSType value);

private:
    ::safe_browsing::RTLookupRequest_OSType _internal_os_type() const;
    void _internal_set_os_type(::safe_browsing::RTLookupRequest_OSType value);

public:
    // optional .safe_browsing.RTLookupRequest.ReportType report_type = 9;
    bool has_report_type() const;

private:
    bool _internal_has_report_type() const;

public:
    void clear_report_type();
    ::safe_browsing::RTLookupRequest_ReportType report_type() const;
    void set_report_type(::safe_browsing::RTLookupRequest_ReportType value);

private:
    ::safe_browsing::RTLookupRequest_ReportType _internal_report_type() const;
    void _internal_set_report_type(::safe_browsing::RTLookupRequest_ReportType value);

public:
    // optional .safe_browsing.RTLookupRequest.FrameType frame_type = 10;
    bool has_frame_type() const;

private:
    bool _internal_has_frame_type() const;

public:
    void clear_frame_type();
    ::safe_browsing::RTLookupRequest_FrameType frame_type() const;
    void set_frame_type(::safe_browsing::RTLookupRequest_FrameType value);

private:
    ::safe_browsing::RTLookupRequest_FrameType _internal_frame_type() const;
    void _internal_set_frame_type(::safe_browsing::RTLookupRequest_FrameType value);

public:
    // @@protoc_insertion_point(class_scope:safe_browsing.RTLookupRequest)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::ReferrerChainEntry> referrer_chain_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deprecated_scoped_oauth_token_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dm_token_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profile_dm_token_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr browser_dm_token_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
        ::safe_browsing::ChromeUserPopulation* population_;
        ::enterprise_connectors::ClientMetadata* client_reporting_metadata_;
        int lookup_type_;
        int32_t version_;
        int os_type_;
        int report_type_;
        int frame_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsafe_5fbrowsing_2fcore_2fcommon_2fproto_2frealtimeapi_2eproto;
};
// -------------------------------------------------------------------

class RTLookupResponse_ThreatInfo final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.RTLookupResponse.ThreatInfo) */ {
public:
    inline RTLookupResponse_ThreatInfo()
        : RTLookupResponse_ThreatInfo(nullptr)
    {
    }
    ~RTLookupResponse_ThreatInfo() override;
    explicit PROTOBUF_CONSTEXPR RTLookupResponse_ThreatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    RTLookupResponse_ThreatInfo(const RTLookupResponse_ThreatInfo& from);
    RTLookupResponse_ThreatInfo(RTLookupResponse_ThreatInfo&& from) noexcept
        : RTLookupResponse_ThreatInfo()
    {
        *this = ::std::move(from);
    }

    inline RTLookupResponse_ThreatInfo& operator=(const RTLookupResponse_ThreatInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline RTLookupResponse_ThreatInfo& operator=(RTLookupResponse_ThreatInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const RTLookupResponse_ThreatInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const RTLookupResponse_ThreatInfo* internal_default_instance()
    {
        return reinterpret_cast<const RTLookupResponse_ThreatInfo*>(&_RTLookupResponse_ThreatInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(RTLookupResponse_ThreatInfo& a, RTLookupResponse_ThreatInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(RTLookupResponse_ThreatInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(RTLookupResponse_ThreatInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    RTLookupResponse_ThreatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<RTLookupResponse_ThreatInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const RTLookupResponse_ThreatInfo& from);
    void MergeFrom(const RTLookupResponse_ThreatInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RTLookupResponse_ThreatInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "safe_browsing.RTLookupResponse.ThreatInfo";
    }

protected:
    explicit RTLookupResponse_ThreatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef RTLookupResponse_ThreatInfo_ThreatType ThreatType;
    static constexpr ThreatType THREAT_TYPE_UNSPECIFIED = RTLookupResponse_ThreatInfo_ThreatType_THREAT_TYPE_UNSPECIFIED;
    static constexpr ThreatType WEB_MALWARE = RTLookupResponse_ThreatInfo_ThreatType_WEB_MALWARE;
    static constexpr ThreatType SOCIAL_ENGINEERING = RTLookupResponse_ThreatInfo_ThreatType_SOCIAL_ENGINEERING;
    static constexpr ThreatType UNWANTED_SOFTWARE = RTLookupResponse_ThreatInfo_ThreatType_UNWANTED_SOFTWARE;
    static constexpr ThreatType UNCLEAR_BILLING = RTLookupResponse_ThreatInfo_ThreatType_UNCLEAR_BILLING;
    static constexpr ThreatType MANAGED_POLICY = RTLookupResponse_ThreatInfo_ThreatType_MANAGED_POLICY;
    static inline bool ThreatType_IsValid(int value)
    {
        return RTLookupResponse_ThreatInfo_ThreatType_IsValid(value);
    }
    static constexpr ThreatType ThreatType_MIN = RTLookupResponse_ThreatInfo_ThreatType_ThreatType_MIN;
    static constexpr ThreatType ThreatType_MAX = RTLookupResponse_ThreatInfo_ThreatType_ThreatType_MAX;
    static constexpr int ThreatType_ARRAYSIZE = RTLookupResponse_ThreatInfo_ThreatType_ThreatType_ARRAYSIZE;
    template <typename T> static inline const std::string& ThreatType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ThreatType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ThreatType_Name.");
        return RTLookupResponse_ThreatInfo_ThreatType_Name(enum_t_value);
    }
    static inline bool ThreatType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThreatType* value)
    {
        return RTLookupResponse_ThreatInfo_ThreatType_Parse(name, value);
    }

    typedef RTLookupResponse_ThreatInfo_VerdictType VerdictType;
    static constexpr VerdictType VERDICT_TYPE_UNSPECIFIED = RTLookupResponse_ThreatInfo_VerdictType_VERDICT_TYPE_UNSPECIFIED;
    static constexpr VerdictType SAFE = RTLookupResponse_ThreatInfo_VerdictType_SAFE;
    static constexpr VerdictType SUSPICIOUS = RTLookupResponse_ThreatInfo_VerdictType_SUSPICIOUS;
    static constexpr VerdictType WARN = RTLookupResponse_ThreatInfo_VerdictType_WARN;
    static constexpr VerdictType DANGEROUS = RTLookupResponse_ThreatInfo_VerdictType_DANGEROUS;
    static inline bool VerdictType_IsValid(int value)
    {
        return RTLookupResponse_ThreatInfo_VerdictType_IsValid(value);
    }
    static constexpr VerdictType VerdictType_MIN = RTLookupResponse_ThreatInfo_VerdictType_VerdictType_MIN;
    static constexpr VerdictType VerdictType_MAX = RTLookupResponse_ThreatInfo_VerdictType_VerdictType_MAX;
    static constexpr int VerdictType_ARRAYSIZE = RTLookupResponse_ThreatInfo_VerdictType_VerdictType_ARRAYSIZE;
    template <typename T> static inline const std::string& VerdictType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, VerdictType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function VerdictType_Name.");
        return RTLookupResponse_ThreatInfo_VerdictType_Name(enum_t_value);
    }
    static inline bool VerdictType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VerdictType* value)
    {
        return RTLookupResponse_ThreatInfo_VerdictType_Parse(name, value);
    }

    typedef RTLookupResponse_ThreatInfo_CacheExpressionMatchType CacheExpressionMatchType;
    static constexpr CacheExpressionMatchType MATCH_TYPE_UNSPECIFIED = RTLookupResponse_ThreatInfo_CacheExpressionMatchType_MATCH_TYPE_UNSPECIFIED;
    static constexpr CacheExpressionMatchType COVERING_MATCH = RTLookupResponse_ThreatInfo_CacheExpressionMatchType_COVERING_MATCH;
    static constexpr CacheExpressionMatchType EXACT_MATCH = RTLookupResponse_ThreatInfo_CacheExpressionMatchType_EXACT_MATCH;
    static inline bool CacheExpressionMatchType_IsValid(int value)
    {
        return RTLookupResponse_ThreatInfo_CacheExpressionMatchType_IsValid(value);
    }
    static constexpr CacheExpressionMatchType CacheExpressionMatchType_MIN = RTLookupResponse_ThreatInfo_CacheExpressionMatchType_CacheExpressionMatchType_MIN;
    static constexpr CacheExpressionMatchType CacheExpressionMatchType_MAX = RTLookupResponse_ThreatInfo_CacheExpressionMatchType_CacheExpressionMatchType_MAX;
    static constexpr int CacheExpressionMatchType_ARRAYSIZE = RTLookupResponse_ThreatInfo_CacheExpressionMatchType_CacheExpressionMatchType_ARRAYSIZE;
    template <typename T> static inline const std::string& CacheExpressionMatchType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, CacheExpressionMatchType>::value || ::std::is_integral<T>::value,
            "Incorrect type passed to function CacheExpressionMatchType_Name.");
        return RTLookupResponse_ThreatInfo_CacheExpressionMatchType_Name(enum_t_value);
    }
    static inline bool CacheExpressionMatchType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CacheExpressionMatchType* value)
    {
        return RTLookupResponse_ThreatInfo_CacheExpressionMatchType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kCacheExpressionFieldNumber = 3,
        kCacheExpressionUsingMatchTypeFieldNumber = 6,
        kMatchedUrlNavigationRuleFieldNumber = 7,
        kCacheDurationSecFieldNumber = 2,
        kThreatTypeFieldNumber = 1,
        kVerdictTypeFieldNumber = 4,
        kCacheExpressionMatchTypeFieldNumber = 5,
    };
    // optional string cache_expression = 3 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_cache_expression() const;

private:
    bool _internal_has_cache_expression() const;

public:
    PROTOBUF_DEPRECATED void clear_cache_expression();
    PROTOBUF_DEPRECATED const std::string& cache_expression() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_cache_expression(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_cache_expression();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_cache_expression();
    PROTOBUF_DEPRECATED void set_allocated_cache_expression(std::string* cache_expression);

private:
    const std::string& _internal_cache_expression() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_cache_expression(const std::string& value);
    std::string* _internal_mutable_cache_expression();

public:
    // optional string cache_expression_using_match_type = 6;
    bool has_cache_expression_using_match_type() const;

private:
    bool _internal_has_cache_expression_using_match_type() const;

public:
    void clear_cache_expression_using_match_type();
    const std::string& cache_expression_using_match_type() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_cache_expression_using_match_type(ArgT0&& arg0, ArgT... args);
    std::string* mutable_cache_expression_using_match_type();
    PROTOBUF_NODISCARD std::string* release_cache_expression_using_match_type();
    void set_allocated_cache_expression_using_match_type(std::string* cache_expression_using_match_type);

private:
    const std::string& _internal_cache_expression_using_match_type() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_cache_expression_using_match_type(const std::string& value);
    std::string* _internal_mutable_cache_expression_using_match_type();

public:
    // optional .safe_browsing.MatchedUrlNavigationRule matched_url_navigation_rule = 7;
    bool has_matched_url_navigation_rule() const;

private:
    bool _internal_has_matched_url_navigation_rule() const;

public:
    void clear_matched_url_navigation_rule();
    const ::safe_browsing::MatchedUrlNavigationRule& matched_url_navigation_rule() const;
    PROTOBUF_NODISCARD ::safe_browsing::MatchedUrlNavigationRule* release_matched_url_navigation_rule();
    ::safe_browsing::MatchedUrlNavigationRule* mutable_matched_url_navigation_rule();
    void set_allocated_matched_url_navigation_rule(::safe_browsing::MatchedUrlNavigationRule* matched_url_navigation_rule);

private:
    const ::safe_browsing::MatchedUrlNavigationRule& _internal_matched_url_navigation_rule() const;
    ::safe_browsing::MatchedUrlNavigationRule* _internal_mutable_matched_url_navigation_rule();

public:
    void unsafe_arena_set_allocated_matched_url_navigation_rule(::safe_browsing::MatchedUrlNavigationRule* matched_url_navigation_rule);
    ::safe_browsing::MatchedUrlNavigationRule* unsafe_arena_release_matched_url_navigation_rule();

    // optional int64 cache_duration_sec = 2;
    bool has_cache_duration_sec() const;

private:
    bool _internal_has_cache_duration_sec() const;

public:
    void clear_cache_duration_sec();
    int64_t cache_duration_sec() const;
    void set_cache_duration_sec(int64_t value);

private:
    int64_t _internal_cache_duration_sec() const;
    void _internal_set_cache_duration_sec(int64_t value);

public:
    // optional .safe_browsing.RTLookupResponse.ThreatInfo.ThreatType threat_type = 1;
    bool has_threat_type() const;

private:
    bool _internal_has_threat_type() const;

public:
    void clear_threat_type();
    ::safe_browsing::RTLookupResponse_ThreatInfo_ThreatType threat_type() const;
    void set_threat_type(::safe_browsing::RTLookupResponse_ThreatInfo_ThreatType value);

private:
    ::safe_browsing::RTLookupResponse_ThreatInfo_ThreatType _internal_threat_type() const;
    void _internal_set_threat_type(::safe_browsing::RTLookupResponse_ThreatInfo_ThreatType value);

public:
    // optional .safe_browsing.RTLookupResponse.ThreatInfo.VerdictType verdict_type = 4;
    bool has_verdict_type() const;

private:
    bool _internal_has_verdict_type() const;

public:
    void clear_verdict_type();
    ::safe_browsing::RTLookupResponse_ThreatInfo_VerdictType verdict_type() const;
    void set_verdict_type(::safe_browsing::RTLookupResponse_ThreatInfo_VerdictType value);

private:
    ::safe_browsing::RTLookupResponse_ThreatInfo_VerdictType _internal_verdict_type() const;
    void _internal_set_verdict_type(::safe_browsing::RTLookupResponse_ThreatInfo_VerdictType value);

public:
    // optional .safe_browsing.RTLookupResponse.ThreatInfo.CacheExpressionMatchType cache_expression_match_type = 5;
    bool has_cache_expression_match_type() const;

private:
    bool _internal_has_cache_expression_match_type() const;

public:
    void clear_cache_expression_match_type();
    ::safe_browsing::RTLookupResponse_ThreatInfo_CacheExpressionMatchType cache_expression_match_type() const;
    void set_cache_expression_match_type(::safe_browsing::RTLookupResponse_ThreatInfo_CacheExpressionMatchType value);

private:
    ::safe_browsing::RTLookupResponse_ThreatInfo_CacheExpressionMatchType _internal_cache_expression_match_type() const;
    void _internal_set_cache_expression_match_type(::safe_browsing::RTLookupResponse_ThreatInfo_CacheExpressionMatchType value);

public:
    // @@protoc_insertion_point(class_scope:safe_browsing.RTLookupResponse.ThreatInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cache_expression_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cache_expression_using_match_type_;
        ::safe_browsing::MatchedUrlNavigationRule* matched_url_navigation_rule_;
        int64_t cache_duration_sec_;
        int threat_type_;
        int verdict_type_;
        int cache_expression_match_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsafe_5fbrowsing_2fcore_2fcommon_2fproto_2frealtimeapi_2eproto;
};
// -------------------------------------------------------------------

class RTLookupResponse final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.RTLookupResponse) */ {
public:
    inline RTLookupResponse()
        : RTLookupResponse(nullptr)
    {
    }
    ~RTLookupResponse() override;
    explicit PROTOBUF_CONSTEXPR RTLookupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    RTLookupResponse(const RTLookupResponse& from);
    RTLookupResponse(RTLookupResponse&& from) noexcept
        : RTLookupResponse()
    {
        *this = ::std::move(from);
    }

    inline RTLookupResponse& operator=(const RTLookupResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline RTLookupResponse& operator=(RTLookupResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const RTLookupResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const RTLookupResponse* internal_default_instance()
    {
        return reinterpret_cast<const RTLookupResponse*>(&_RTLookupResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(RTLookupResponse& a, RTLookupResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(RTLookupResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(RTLookupResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    RTLookupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<RTLookupResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const RTLookupResponse& from);
    void MergeFrom(const RTLookupResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RTLookupResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "safe_browsing.RTLookupResponse";
    }

protected:
    explicit RTLookupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef RTLookupResponse_ThreatInfo ThreatInfo;

    // accessors -------------------------------------------------------

    enum : int {
        kThreatInfoFieldNumber = 1,
        kUrlCategoriesFieldNumber = 3,
        kLlamaForcedTriggerInfoFieldNumber = 4,
        kClientSideDetectionTypeFieldNumber = 2,
    };
    // repeated .safe_browsing.RTLookupResponse.ThreatInfo threat_info = 1;
    int threat_info_size() const;

private:
    int _internal_threat_info_size() const;

public:
    void clear_threat_info();
    ::safe_browsing::RTLookupResponse_ThreatInfo* mutable_threat_info(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::RTLookupResponse_ThreatInfo>* mutable_threat_info();

private:
    const ::safe_browsing::RTLookupResponse_ThreatInfo& _internal_threat_info(int index) const;
    ::safe_browsing::RTLookupResponse_ThreatInfo* _internal_add_threat_info();

public:
    const ::safe_browsing::RTLookupResponse_ThreatInfo& threat_info(int index) const;
    ::safe_browsing::RTLookupResponse_ThreatInfo* add_threat_info();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::RTLookupResponse_ThreatInfo>& threat_info() const;

    // repeated string url_categories = 3;
    int url_categories_size() const;

private:
    int _internal_url_categories_size() const;

public:
    void clear_url_categories();
    const std::string& url_categories(int index) const;
    std::string* mutable_url_categories(int index);
    void set_url_categories(int index, const std::string& value);
    void set_url_categories(int index, std::string&& value);
    void set_url_categories(int index, const char* value);
    void set_url_categories(int index, const char* value, size_t size);
    std::string* add_url_categories();
    void add_url_categories(const std::string& value);
    void add_url_categories(std::string&& value);
    void add_url_categories(const char* value);
    void add_url_categories(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& url_categories() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_url_categories();

private:
    const std::string& _internal_url_categories(int index) const;
    std::string* _internal_add_url_categories();

public:
    // optional .safe_browsing.LlamaForcedTriggerInfo llama_forced_trigger_info = 4;
    bool has_llama_forced_trigger_info() const;

private:
    bool _internal_has_llama_forced_trigger_info() const;

public:
    void clear_llama_forced_trigger_info();
    const ::safe_browsing::LlamaForcedTriggerInfo& llama_forced_trigger_info() const;
    PROTOBUF_NODISCARD ::safe_browsing::LlamaForcedTriggerInfo* release_llama_forced_trigger_info();
    ::safe_browsing::LlamaForcedTriggerInfo* mutable_llama_forced_trigger_info();
    void set_allocated_llama_forced_trigger_info(::safe_browsing::LlamaForcedTriggerInfo* llama_forced_trigger_info);

private:
    const ::safe_browsing::LlamaForcedTriggerInfo& _internal_llama_forced_trigger_info() const;
    ::safe_browsing::LlamaForcedTriggerInfo* _internal_mutable_llama_forced_trigger_info();

public:
    void unsafe_arena_set_allocated_llama_forced_trigger_info(::safe_browsing::LlamaForcedTriggerInfo* llama_forced_trigger_info);
    ::safe_browsing::LlamaForcedTriggerInfo* unsafe_arena_release_llama_forced_trigger_info();

    // optional .safe_browsing.ClientSideDetectionType client_side_detection_type = 2;
    bool has_client_side_detection_type() const;

private:
    bool _internal_has_client_side_detection_type() const;

public:
    void clear_client_side_detection_type();
    ::safe_browsing::ClientSideDetectionType client_side_detection_type() const;
    void set_client_side_detection_type(::safe_browsing::ClientSideDetectionType value);

private:
    ::safe_browsing::ClientSideDetectionType _internal_client_side_detection_type() const;
    void _internal_set_client_side_detection_type(::safe_browsing::ClientSideDetectionType value);

public:
    // @@protoc_insertion_point(class_scope:safe_browsing.RTLookupResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::RTLookupResponse_ThreatInfo> threat_info_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> url_categories_;
        ::safe_browsing::LlamaForcedTriggerInfo* llama_forced_trigger_info_;
        int client_side_detection_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsafe_5fbrowsing_2fcore_2fcommon_2fproto_2frealtimeapi_2eproto;
};
// -------------------------------------------------------------------

class Timestamp final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.Timestamp) */ {
public:
    inline Timestamp()
        : Timestamp(nullptr)
    {
    }
    ~Timestamp() override;
    explicit PROTOBUF_CONSTEXPR Timestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Timestamp(const Timestamp& from);
    Timestamp(Timestamp&& from) noexcept
        : Timestamp()
    {
        *this = ::std::move(from);
    }

    inline Timestamp& operator=(const Timestamp& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Timestamp& operator=(Timestamp&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Timestamp& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Timestamp* internal_default_instance()
    {
        return reinterpret_cast<const Timestamp*>(&_Timestamp_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(Timestamp& a, Timestamp& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Timestamp* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Timestamp* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Timestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Timestamp>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Timestamp& from);
    void MergeFrom(const Timestamp& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Timestamp* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "safe_browsing.Timestamp";
    }

protected:
    explicit Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSecondsFieldNumber = 1,
        kNanosFieldNumber = 2,
    };
    // optional int64 seconds = 1;
    bool has_seconds() const;

private:
    bool _internal_has_seconds() const;

public:
    void clear_seconds();
    int64_t seconds() const;
    void set_seconds(int64_t value);

private:
    int64_t _internal_seconds() const;
    void _internal_set_seconds(int64_t value);

public:
    // optional int32 nanos = 2;
    bool has_nanos() const;

private:
    bool _internal_has_nanos() const;

public:
    void clear_nanos();
    int32_t nanos() const;
    void set_nanos(int32_t value);

private:
    int32_t _internal_nanos() const;
    void _internal_set_nanos(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:safe_browsing.Timestamp)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int64_t seconds_;
        int32_t nanos_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsafe_5fbrowsing_2fcore_2fcommon_2fproto_2frealtimeapi_2eproto;
};
// -------------------------------------------------------------------

class MatchedUrlNavigationRule_CustomRuleMessageSegment final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment) */ {
public:
    inline MatchedUrlNavigationRule_CustomRuleMessageSegment()
        : MatchedUrlNavigationRule_CustomRuleMessageSegment(nullptr)
    {
    }
    ~MatchedUrlNavigationRule_CustomRuleMessageSegment() override;
    explicit PROTOBUF_CONSTEXPR MatchedUrlNavigationRule_CustomRuleMessageSegment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    MatchedUrlNavigationRule_CustomRuleMessageSegment(const MatchedUrlNavigationRule_CustomRuleMessageSegment& from);
    MatchedUrlNavigationRule_CustomRuleMessageSegment(MatchedUrlNavigationRule_CustomRuleMessageSegment&& from) noexcept
        : MatchedUrlNavigationRule_CustomRuleMessageSegment()
    {
        *this = ::std::move(from);
    }

    inline MatchedUrlNavigationRule_CustomRuleMessageSegment& operator=(const MatchedUrlNavigationRule_CustomRuleMessageSegment& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline MatchedUrlNavigationRule_CustomRuleMessageSegment& operator=(MatchedUrlNavigationRule_CustomRuleMessageSegment&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const MatchedUrlNavigationRule_CustomRuleMessageSegment& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const MatchedUrlNavigationRule_CustomRuleMessageSegment* internal_default_instance()
    {
        return reinterpret_cast<const MatchedUrlNavigationRule_CustomRuleMessageSegment*>(
            &_MatchedUrlNavigationRule_CustomRuleMessageSegment_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(MatchedUrlNavigationRule_CustomRuleMessageSegment& a, MatchedUrlNavigationRule_CustomRuleMessageSegment& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(MatchedUrlNavigationRule_CustomRuleMessageSegment* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(MatchedUrlNavigationRule_CustomRuleMessageSegment* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    MatchedUrlNavigationRule_CustomRuleMessageSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<MatchedUrlNavigationRule_CustomRuleMessageSegment>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const MatchedUrlNavigationRule_CustomRuleMessageSegment& from);
    void MergeFrom(const MatchedUrlNavigationRule_CustomRuleMessageSegment& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(MatchedUrlNavigationRule_CustomRuleMessageSegment* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment";
    }

protected:
    explicit MatchedUrlNavigationRule_CustomRuleMessageSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTextFieldNumber = 1,
        kLinkFieldNumber = 2,
    };
    // optional string text = 1;
    bool has_text() const;

private:
    bool _internal_has_text() const;

public:
    void clear_text();
    const std::string& text() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_text(ArgT0&& arg0, ArgT... args);
    std::string* mutable_text();
    PROTOBUF_NODISCARD std::string* release_text();
    void set_allocated_text(std::string* text);

private:
    const std::string& _internal_text() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
    std::string* _internal_mutable_text();

public:
    // optional string link = 2;
    bool has_link() const;

private:
    bool _internal_has_link() const;

public:
    void clear_link();
    const std::string& link() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_link(ArgT0&& arg0, ArgT... args);
    std::string* mutable_link();
    PROTOBUF_NODISCARD std::string* release_link();
    void set_allocated_link(std::string* link);

private:
    const std::string& _internal_link() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_link(const std::string& value);
    std::string* _internal_mutable_link();

public:
    // @@protoc_insertion_point(class_scope:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsafe_5fbrowsing_2fcore_2fcommon_2fproto_2frealtimeapi_2eproto;
};
// -------------------------------------------------------------------

class MatchedUrlNavigationRule_CustomMessage final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.MatchedUrlNavigationRule.CustomMessage) */ {
public:
    inline MatchedUrlNavigationRule_CustomMessage()
        : MatchedUrlNavigationRule_CustomMessage(nullptr)
    {
    }
    ~MatchedUrlNavigationRule_CustomMessage() override;
    explicit PROTOBUF_CONSTEXPR MatchedUrlNavigationRule_CustomMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    MatchedUrlNavigationRule_CustomMessage(const MatchedUrlNavigationRule_CustomMessage& from);
    MatchedUrlNavigationRule_CustomMessage(MatchedUrlNavigationRule_CustomMessage&& from) noexcept
        : MatchedUrlNavigationRule_CustomMessage()
    {
        *this = ::std::move(from);
    }

    inline MatchedUrlNavigationRule_CustomMessage& operator=(const MatchedUrlNavigationRule_CustomMessage& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline MatchedUrlNavigationRule_CustomMessage& operator=(MatchedUrlNavigationRule_CustomMessage&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const MatchedUrlNavigationRule_CustomMessage& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const MatchedUrlNavigationRule_CustomMessage* internal_default_instance()
    {
        return reinterpret_cast<const MatchedUrlNavigationRule_CustomMessage*>(&_MatchedUrlNavigationRule_CustomMessage_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(MatchedUrlNavigationRule_CustomMessage& a, MatchedUrlNavigationRule_CustomMessage& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(MatchedUrlNavigationRule_CustomMessage* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(MatchedUrlNavigationRule_CustomMessage* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    MatchedUrlNavigationRule_CustomMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<MatchedUrlNavigationRule_CustomMessage>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const MatchedUrlNavigationRule_CustomMessage& from);
    void MergeFrom(const MatchedUrlNavigationRule_CustomMessage& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(MatchedUrlNavigationRule_CustomMessage* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "safe_browsing.MatchedUrlNavigationRule.CustomMessage";
    }

protected:
    explicit MatchedUrlNavigationRule_CustomMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kMessageSegmentsFieldNumber = 4,
        kCustomMessageFieldNumber = 1,
        kLearnMoreLinkFieldNumber = 2,
        kCustomMessageWithLinksFieldNumber = 3,
    };
    // repeated .safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment message_segments = 4;
    int message_segments_size() const;

private:
    int _internal_message_segments_size() const;

public:
    void clear_message_segments();
    ::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment* mutable_message_segments(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment>* mutable_message_segments();

private:
    const ::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment& _internal_message_segments(int index) const;
    ::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment* _internal_add_message_segments();

public:
    const ::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment& message_segments(int index) const;
    ::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment* add_message_segments();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment>& message_segments() const;

    // optional string custom_message = 1 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_custom_message() const;

private:
    bool _internal_has_custom_message() const;

public:
    PROTOBUF_DEPRECATED void clear_custom_message();
    PROTOBUF_DEPRECATED const std::string& custom_message() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_custom_message(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_custom_message();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_custom_message();
    PROTOBUF_DEPRECATED void set_allocated_custom_message(std::string* custom_message);

private:
    const std::string& _internal_custom_message() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_custom_message(const std::string& value);
    std::string* _internal_mutable_custom_message();

public:
    // optional string learn_more_link = 2 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_learn_more_link() const;

private:
    bool _internal_has_learn_more_link() const;

public:
    PROTOBUF_DEPRECATED void clear_learn_more_link();
    PROTOBUF_DEPRECATED const std::string& learn_more_link() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_learn_more_link(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_learn_more_link();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_learn_more_link();
    PROTOBUF_DEPRECATED void set_allocated_learn_more_link(std::string* learn_more_link);

private:
    const std::string& _internal_learn_more_link() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_learn_more_link(const std::string& value);
    std::string* _internal_mutable_learn_more_link();

public:
    // optional string custom_message_with_links = 3 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_custom_message_with_links() const;

private:
    bool _internal_has_custom_message_with_links() const;

public:
    PROTOBUF_DEPRECATED void clear_custom_message_with_links();
    PROTOBUF_DEPRECATED const std::string& custom_message_with_links() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_custom_message_with_links(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_custom_message_with_links();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_custom_message_with_links();
    PROTOBUF_DEPRECATED void set_allocated_custom_message_with_links(std::string* custom_message_with_links);

private:
    const std::string& _internal_custom_message_with_links() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_custom_message_with_links(const std::string& value);
    std::string* _internal_mutable_custom_message_with_links();

public:
    // @@protoc_insertion_point(class_scope:safe_browsing.MatchedUrlNavigationRule.CustomMessage)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment> message_segments_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_message_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr learn_more_link_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_message_with_links_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsafe_5fbrowsing_2fcore_2fcommon_2fproto_2frealtimeapi_2eproto;
};
// -------------------------------------------------------------------

class MatchedUrlNavigationRule_WatermarkMessage final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage) */ {
public:
    inline MatchedUrlNavigationRule_WatermarkMessage()
        : MatchedUrlNavigationRule_WatermarkMessage(nullptr)
    {
    }
    ~MatchedUrlNavigationRule_WatermarkMessage() override;
    explicit PROTOBUF_CONSTEXPR MatchedUrlNavigationRule_WatermarkMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    MatchedUrlNavigationRule_WatermarkMessage(const MatchedUrlNavigationRule_WatermarkMessage& from);
    MatchedUrlNavigationRule_WatermarkMessage(MatchedUrlNavigationRule_WatermarkMessage&& from) noexcept
        : MatchedUrlNavigationRule_WatermarkMessage()
    {
        *this = ::std::move(from);
    }

    inline MatchedUrlNavigationRule_WatermarkMessage& operator=(const MatchedUrlNavigationRule_WatermarkMessage& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline MatchedUrlNavigationRule_WatermarkMessage& operator=(MatchedUrlNavigationRule_WatermarkMessage&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const MatchedUrlNavigationRule_WatermarkMessage& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const MatchedUrlNavigationRule_WatermarkMessage* internal_default_instance()
    {
        return reinterpret_cast<const MatchedUrlNavigationRule_WatermarkMessage*>(&_MatchedUrlNavigationRule_WatermarkMessage_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(MatchedUrlNavigationRule_WatermarkMessage& a, MatchedUrlNavigationRule_WatermarkMessage& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(MatchedUrlNavigationRule_WatermarkMessage* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(MatchedUrlNavigationRule_WatermarkMessage* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    MatchedUrlNavigationRule_WatermarkMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<MatchedUrlNavigationRule_WatermarkMessage>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const MatchedUrlNavigationRule_WatermarkMessage& from);
    void MergeFrom(const MatchedUrlNavigationRule_WatermarkMessage& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(MatchedUrlNavigationRule_WatermarkMessage* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "safe_browsing.MatchedUrlNavigationRule.WatermarkMessage";
    }

protected:
    explicit MatchedUrlNavigationRule_WatermarkMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kWatermarkMessageFieldNumber = 1,
        kUserEmailFieldNumber = 2,
        kObfuscatedDeviceIdFieldNumber = 3,
        kTimestampFieldNumber = 4,
    };
    // optional string watermark_message = 1;
    bool has_watermark_message() const;

private:
    bool _internal_has_watermark_message() const;

public:
    void clear_watermark_message();
    const std::string& watermark_message() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_watermark_message(ArgT0&& arg0, ArgT... args);
    std::string* mutable_watermark_message();
    PROTOBUF_NODISCARD std::string* release_watermark_message();
    void set_allocated_watermark_message(std::string* watermark_message);

private:
    const std::string& _internal_watermark_message() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_watermark_message(const std::string& value);
    std::string* _internal_mutable_watermark_message();

public:
    // optional string user_email = 2;
    bool has_user_email() const;

private:
    bool _internal_has_user_email() const;

public:
    void clear_user_email();
    const std::string& user_email() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_user_email(ArgT0&& arg0, ArgT... args);
    std::string* mutable_user_email();
    PROTOBUF_NODISCARD std::string* release_user_email();
    void set_allocated_user_email(std::string* user_email);

private:
    const std::string& _internal_user_email() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_email(const std::string& value);
    std::string* _internal_mutable_user_email();

public:
    // optional string obfuscated_device_id = 3;
    bool has_obfuscated_device_id() const;

private:
    bool _internal_has_obfuscated_device_id() const;

public:
    void clear_obfuscated_device_id();
    const std::string& obfuscated_device_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_obfuscated_device_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_obfuscated_device_id();
    PROTOBUF_NODISCARD std::string* release_obfuscated_device_id();
    void set_allocated_obfuscated_device_id(std::string* obfuscated_device_id);

private:
    const std::string& _internal_obfuscated_device_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_obfuscated_device_id(const std::string& value);
    std::string* _internal_mutable_obfuscated_device_id();

public:
    // optional .safe_browsing.Timestamp timestamp = 4;
    bool has_timestamp() const;

private:
    bool _internal_has_timestamp() const;

public:
    void clear_timestamp();
    const ::safe_browsing::Timestamp& timestamp() const;
    PROTOBUF_NODISCARD ::safe_browsing::Timestamp* release_timestamp();
    ::safe_browsing::Timestamp* mutable_timestamp();
    void set_allocated_timestamp(::safe_browsing::Timestamp* timestamp);

private:
    const ::safe_browsing::Timestamp& _internal_timestamp() const;
    ::safe_browsing::Timestamp* _internal_mutable_timestamp();

public:
    void unsafe_arena_set_allocated_timestamp(::safe_browsing::Timestamp* timestamp);
    ::safe_browsing::Timestamp* unsafe_arena_release_timestamp();

    // @@protoc_insertion_point(class_scope:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr watermark_message_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_email_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr obfuscated_device_id_;
        ::safe_browsing::Timestamp* timestamp_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsafe_5fbrowsing_2fcore_2fcommon_2fproto_2frealtimeapi_2eproto;
};
// -------------------------------------------------------------------

class MatchedUrlNavigationRule final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:safe_browsing.MatchedUrlNavigationRule) */ {
public:
    inline MatchedUrlNavigationRule()
        : MatchedUrlNavigationRule(nullptr)
    {
    }
    ~MatchedUrlNavigationRule() override;
    explicit PROTOBUF_CONSTEXPR MatchedUrlNavigationRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    MatchedUrlNavigationRule(const MatchedUrlNavigationRule& from);
    MatchedUrlNavigationRule(MatchedUrlNavigationRule&& from) noexcept
        : MatchedUrlNavigationRule()
    {
        *this = ::std::move(from);
    }

    inline MatchedUrlNavigationRule& operator=(const MatchedUrlNavigationRule& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline MatchedUrlNavigationRule& operator=(MatchedUrlNavigationRule&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const MatchedUrlNavigationRule& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const MatchedUrlNavigationRule* internal_default_instance()
    {
        return reinterpret_cast<const MatchedUrlNavigationRule*>(&_MatchedUrlNavigationRule_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(MatchedUrlNavigationRule& a, MatchedUrlNavigationRule& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(MatchedUrlNavigationRule* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(MatchedUrlNavigationRule* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    MatchedUrlNavigationRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<MatchedUrlNavigationRule>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const MatchedUrlNavigationRule& from);
    void MergeFrom(const MatchedUrlNavigationRule& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(MatchedUrlNavigationRule* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "safe_browsing.MatchedUrlNavigationRule";
    }

protected:
    explicit MatchedUrlNavigationRule(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef MatchedUrlNavigationRule_CustomRuleMessageSegment CustomRuleMessageSegment;
    typedef MatchedUrlNavigationRule_CustomMessage CustomMessage;
    typedef MatchedUrlNavigationRule_WatermarkMessage WatermarkMessage;

    // accessors -------------------------------------------------------

    enum : int {
        kRuleIdFieldNumber = 1,
        kRuleNameFieldNumber = 2,
        kMatchedUrlCategoryFieldNumber = 3,
        kCustomMessageFieldNumber = 5,
        kWatermarkMessageFieldNumber = 6,
        kBlockScreenshotFieldNumber = 8,
    };
    // optional string rule_id = 1;
    bool has_rule_id() const;

private:
    bool _internal_has_rule_id() const;

public:
    void clear_rule_id();
    const std::string& rule_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_rule_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_rule_id();
    PROTOBUF_NODISCARD std::string* release_rule_id();
    void set_allocated_rule_id(std::string* rule_id);

private:
    const std::string& _internal_rule_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule_id(const std::string& value);
    std::string* _internal_mutable_rule_id();

public:
    // optional string rule_name = 2;
    bool has_rule_name() const;

private:
    bool _internal_has_rule_name() const;

public:
    void clear_rule_name();
    const std::string& rule_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_rule_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_rule_name();
    PROTOBUF_NODISCARD std::string* release_rule_name();
    void set_allocated_rule_name(std::string* rule_name);

private:
    const std::string& _internal_rule_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_rule_name(const std::string& value);
    std::string* _internal_mutable_rule_name();

public:
    // optional string matched_url_category = 3;
    bool has_matched_url_category() const;

private:
    bool _internal_has_matched_url_category() const;

public:
    void clear_matched_url_category();
    const std::string& matched_url_category() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_matched_url_category(ArgT0&& arg0, ArgT... args);
    std::string* mutable_matched_url_category();
    PROTOBUF_NODISCARD std::string* release_matched_url_category();
    void set_allocated_matched_url_category(std::string* matched_url_category);

private:
    const std::string& _internal_matched_url_category() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_matched_url_category(const std::string& value);
    std::string* _internal_mutable_matched_url_category();

public:
    // optional .safe_browsing.MatchedUrlNavigationRule.CustomMessage custom_message = 5;
    bool has_custom_message() const;

private:
    bool _internal_has_custom_message() const;

public:
    void clear_custom_message();
    const ::safe_browsing::MatchedUrlNavigationRule_CustomMessage& custom_message() const;
    PROTOBUF_NODISCARD ::safe_browsing::MatchedUrlNavigationRule_CustomMessage* release_custom_message();
    ::safe_browsing::MatchedUrlNavigationRule_CustomMessage* mutable_custom_message();
    void set_allocated_custom_message(::safe_browsing::MatchedUrlNavigationRule_CustomMessage* custom_message);

private:
    const ::safe_browsing::MatchedUrlNavigationRule_CustomMessage& _internal_custom_message() const;
    ::safe_browsing::MatchedUrlNavigationRule_CustomMessage* _internal_mutable_custom_message();

public:
    void unsafe_arena_set_allocated_custom_message(::safe_browsing::MatchedUrlNavigationRule_CustomMessage* custom_message);
    ::safe_browsing::MatchedUrlNavigationRule_CustomMessage* unsafe_arena_release_custom_message();

    // optional .safe_browsing.MatchedUrlNavigationRule.WatermarkMessage watermark_message = 6;
    bool has_watermark_message() const;

private:
    bool _internal_has_watermark_message() const;

public:
    void clear_watermark_message();
    const ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage& watermark_message() const;
    PROTOBUF_NODISCARD ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* release_watermark_message();
    ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* mutable_watermark_message();
    void set_allocated_watermark_message(::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* watermark_message);

private:
    const ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage& _internal_watermark_message() const;
    ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* _internal_mutable_watermark_message();

public:
    void unsafe_arena_set_allocated_watermark_message(::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* watermark_message);
    ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* unsafe_arena_release_watermark_message();

    // optional bool block_screenshot = 8;
    bool has_block_screenshot() const;

private:
    bool _internal_has_block_screenshot() const;

public:
    void clear_block_screenshot();
    bool block_screenshot() const;
    void set_block_screenshot(bool value);

private:
    bool _internal_block_screenshot() const;
    void _internal_set_block_screenshot(bool value);

public:
    // @@protoc_insertion_point(class_scope:safe_browsing.MatchedUrlNavigationRule)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rule_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rule_name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr matched_url_category_;
        ::safe_browsing::MatchedUrlNavigationRule_CustomMessage* custom_message_;
        ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* watermark_message_;
        bool block_screenshot_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsafe_5fbrowsing_2fcore_2fcommon_2fproto_2frealtimeapi_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// RTLookupRequest

// optional string url = 1;
inline bool RTLookupRequest::_internal_has_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool RTLookupRequest::has_url() const
{
    return _internal_has_url();
}
inline void RTLookupRequest::clear_url()
{
    _impl_.url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RTLookupRequest::url() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupRequest.url)
    return _internal_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void RTLookupRequest::set_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupRequest.url)
}
inline std::string* RTLookupRequest::mutable_url()
{
    std::string* _s = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupRequest.url)
    return _s;
}
inline const std::string& RTLookupRequest::_internal_url() const
{
    return _impl_.url_.Get();
}
inline void RTLookupRequest::_internal_set_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* RTLookupRequest::_internal_mutable_url()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* RTLookupRequest::release_url()
{
    // @@protoc_insertion_point(field_release:safe_browsing.RTLookupRequest.url)
    if (!_internal_has_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void RTLookupRequest::set_allocated_url(std::string* url)
{
    if (url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.RTLookupRequest.url)
}

// optional .safe_browsing.RTLookupRequest.LookupType lookup_type = 2;
inline bool RTLookupRequest::_internal_has_lookup_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool RTLookupRequest::has_lookup_type() const
{
    return _internal_has_lookup_type();
}
inline void RTLookupRequest::clear_lookup_type()
{
    _impl_.lookup_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::safe_browsing::RTLookupRequest_LookupType RTLookupRequest::_internal_lookup_type() const
{
    return static_cast<::safe_browsing::RTLookupRequest_LookupType>(_impl_.lookup_type_);
}
inline ::safe_browsing::RTLookupRequest_LookupType RTLookupRequest::lookup_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupRequest.lookup_type)
    return _internal_lookup_type();
}
inline void RTLookupRequest::_internal_set_lookup_type(::safe_browsing::RTLookupRequest_LookupType value)
{
    assert(::safe_browsing::RTLookupRequest_LookupType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.lookup_type_ = value;
}
inline void RTLookupRequest::set_lookup_type(::safe_browsing::RTLookupRequest_LookupType value)
{
    _internal_set_lookup_type(value);
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupRequest.lookup_type)
}

// optional .safe_browsing.ChromeUserPopulation population = 3;
inline bool RTLookupRequest::_internal_has_population() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.population_ != nullptr);
    return value;
}
inline bool RTLookupRequest::has_population() const
{
    return _internal_has_population();
}
inline const ::safe_browsing::ChromeUserPopulation& RTLookupRequest::_internal_population() const
{
    const ::safe_browsing::ChromeUserPopulation* p = _impl_.population_;
    return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::ChromeUserPopulation&>(::safe_browsing::_ChromeUserPopulation_default_instance_);
}
inline const ::safe_browsing::ChromeUserPopulation& RTLookupRequest::population() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupRequest.population)
    return _internal_population();
}
inline void RTLookupRequest::unsafe_arena_set_allocated_population(::safe_browsing::ChromeUserPopulation* population)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.population_);
    }
    _impl_.population_ = population;
    if (population) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.RTLookupRequest.population)
}
inline ::safe_browsing::ChromeUserPopulation* RTLookupRequest::release_population()
{
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::safe_browsing::ChromeUserPopulation* temp = _impl_.population_;
    _impl_.population_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::safe_browsing::ChromeUserPopulation* RTLookupRequest::unsafe_arena_release_population()
{
    // @@protoc_insertion_point(field_release:safe_browsing.RTLookupRequest.population)
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::safe_browsing::ChromeUserPopulation* temp = _impl_.population_;
    _impl_.population_ = nullptr;
    return temp;
}
inline ::safe_browsing::ChromeUserPopulation* RTLookupRequest::_internal_mutable_population()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    if (_impl_.population_ == nullptr) {
        auto* p = CreateMaybeMessage<::safe_browsing::ChromeUserPopulation>(GetArenaForAllocation());
        _impl_.population_ = p;
    }
    return _impl_.population_;
}
inline ::safe_browsing::ChromeUserPopulation* RTLookupRequest::mutable_population()
{
    ::safe_browsing::ChromeUserPopulation* _msg = _internal_mutable_population();
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupRequest.population)
    return _msg;
}
inline void RTLookupRequest::set_allocated_population(::safe_browsing::ChromeUserPopulation* population)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.population_);
    }
    if (population) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(population));
        if (message_arena != submessage_arena) {
            population = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, population, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.population_ = population;
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.RTLookupRequest.population)
}

// optional string DEPRECATED_scoped_oauth_token = 4 [deprecated = true];
inline bool RTLookupRequest::_internal_has_deprecated_scoped_oauth_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool RTLookupRequest::has_deprecated_scoped_oauth_token() const
{
    return _internal_has_deprecated_scoped_oauth_token();
}
inline void RTLookupRequest::clear_deprecated_scoped_oauth_token()
{
    _impl_.deprecated_scoped_oauth_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RTLookupRequest::deprecated_scoped_oauth_token() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupRequest.DEPRECATED_scoped_oauth_token)
    return _internal_deprecated_scoped_oauth_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void RTLookupRequest::set_deprecated_scoped_oauth_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.deprecated_scoped_oauth_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupRequest.DEPRECATED_scoped_oauth_token)
}
inline std::string* RTLookupRequest::mutable_deprecated_scoped_oauth_token()
{
    std::string* _s = _internal_mutable_deprecated_scoped_oauth_token();
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupRequest.DEPRECATED_scoped_oauth_token)
    return _s;
}
inline const std::string& RTLookupRequest::_internal_deprecated_scoped_oauth_token() const
{
    return _impl_.deprecated_scoped_oauth_token_.Get();
}
inline void RTLookupRequest::_internal_set_deprecated_scoped_oauth_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.deprecated_scoped_oauth_token_.Set(value, GetArenaForAllocation());
}
inline std::string* RTLookupRequest::_internal_mutable_deprecated_scoped_oauth_token()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.deprecated_scoped_oauth_token_.Mutable(GetArenaForAllocation());
}
inline std::string* RTLookupRequest::release_deprecated_scoped_oauth_token()
{
    // @@protoc_insertion_point(field_release:safe_browsing.RTLookupRequest.DEPRECATED_scoped_oauth_token)
    if (!_internal_has_deprecated_scoped_oauth_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.deprecated_scoped_oauth_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.deprecated_scoped_oauth_token_.IsDefault()) {
        _impl_.deprecated_scoped_oauth_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void RTLookupRequest::set_allocated_deprecated_scoped_oauth_token(std::string* deprecated_scoped_oauth_token)
{
    if (deprecated_scoped_oauth_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.deprecated_scoped_oauth_token_.SetAllocated(deprecated_scoped_oauth_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.deprecated_scoped_oauth_token_.IsDefault()) {
        _impl_.deprecated_scoped_oauth_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.RTLookupRequest.DEPRECATED_scoped_oauth_token)
}

// optional string dm_token = 5;
inline bool RTLookupRequest::_internal_has_dm_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool RTLookupRequest::has_dm_token() const
{
    return _internal_has_dm_token();
}
inline void RTLookupRequest::clear_dm_token()
{
    _impl_.dm_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RTLookupRequest::dm_token() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupRequest.dm_token)
    return _internal_dm_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void RTLookupRequest::set_dm_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.dm_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupRequest.dm_token)
}
inline std::string* RTLookupRequest::mutable_dm_token()
{
    std::string* _s = _internal_mutable_dm_token();
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupRequest.dm_token)
    return _s;
}
inline const std::string& RTLookupRequest::_internal_dm_token() const
{
    return _impl_.dm_token_.Get();
}
inline void RTLookupRequest::_internal_set_dm_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.dm_token_.Set(value, GetArenaForAllocation());
}
inline std::string* RTLookupRequest::_internal_mutable_dm_token()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.dm_token_.Mutable(GetArenaForAllocation());
}
inline std::string* RTLookupRequest::release_dm_token()
{
    // @@protoc_insertion_point(field_release:safe_browsing.RTLookupRequest.dm_token)
    if (!_internal_has_dm_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.dm_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.dm_token_.IsDefault()) {
        _impl_.dm_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void RTLookupRequest::set_allocated_dm_token(std::string* dm_token)
{
    if (dm_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.dm_token_.SetAllocated(dm_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.dm_token_.IsDefault()) {
        _impl_.dm_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.RTLookupRequest.dm_token)
}

// optional string profile_dm_token = 11;
inline bool RTLookupRequest::_internal_has_profile_dm_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool RTLookupRequest::has_profile_dm_token() const
{
    return _internal_has_profile_dm_token();
}
inline void RTLookupRequest::clear_profile_dm_token()
{
    _impl_.profile_dm_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RTLookupRequest::profile_dm_token() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupRequest.profile_dm_token)
    return _internal_profile_dm_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void RTLookupRequest::set_profile_dm_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.profile_dm_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupRequest.profile_dm_token)
}
inline std::string* RTLookupRequest::mutable_profile_dm_token()
{
    std::string* _s = _internal_mutable_profile_dm_token();
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupRequest.profile_dm_token)
    return _s;
}
inline const std::string& RTLookupRequest::_internal_profile_dm_token() const
{
    return _impl_.profile_dm_token_.Get();
}
inline void RTLookupRequest::_internal_set_profile_dm_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.profile_dm_token_.Set(value, GetArenaForAllocation());
}
inline std::string* RTLookupRequest::_internal_mutable_profile_dm_token()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.profile_dm_token_.Mutable(GetArenaForAllocation());
}
inline std::string* RTLookupRequest::release_profile_dm_token()
{
    // @@protoc_insertion_point(field_release:safe_browsing.RTLookupRequest.profile_dm_token)
    if (!_internal_has_profile_dm_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.profile_dm_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.profile_dm_token_.IsDefault()) {
        _impl_.profile_dm_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void RTLookupRequest::set_allocated_profile_dm_token(std::string* profile_dm_token)
{
    if (profile_dm_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.profile_dm_token_.SetAllocated(profile_dm_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.profile_dm_token_.IsDefault()) {
        _impl_.profile_dm_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.RTLookupRequest.profile_dm_token)
}

// optional string browser_dm_token = 12;
inline bool RTLookupRequest::_internal_has_browser_dm_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool RTLookupRequest::has_browser_dm_token() const
{
    return _internal_has_browser_dm_token();
}
inline void RTLookupRequest::clear_browser_dm_token()
{
    _impl_.browser_dm_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& RTLookupRequest::browser_dm_token() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupRequest.browser_dm_token)
    return _internal_browser_dm_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void RTLookupRequest::set_browser_dm_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.browser_dm_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupRequest.browser_dm_token)
}
inline std::string* RTLookupRequest::mutable_browser_dm_token()
{
    std::string* _s = _internal_mutable_browser_dm_token();
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupRequest.browser_dm_token)
    return _s;
}
inline const std::string& RTLookupRequest::_internal_browser_dm_token() const
{
    return _impl_.browser_dm_token_.Get();
}
inline void RTLookupRequest::_internal_set_browser_dm_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.browser_dm_token_.Set(value, GetArenaForAllocation());
}
inline std::string* RTLookupRequest::_internal_mutable_browser_dm_token()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    return _impl_.browser_dm_token_.Mutable(GetArenaForAllocation());
}
inline std::string* RTLookupRequest::release_browser_dm_token()
{
    // @@protoc_insertion_point(field_release:safe_browsing.RTLookupRequest.browser_dm_token)
    if (!_internal_has_browser_dm_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000010u;
    auto* p = _impl_.browser_dm_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.browser_dm_token_.IsDefault()) {
        _impl_.browser_dm_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void RTLookupRequest::set_allocated_browser_dm_token(std::string* browser_dm_token)
{
    if (browser_dm_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.browser_dm_token_.SetAllocated(browser_dm_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.browser_dm_token_.IsDefault()) {
        _impl_.browser_dm_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.RTLookupRequest.browser_dm_token)
}

// optional .enterprise_connectors.ClientMetadata client_reporting_metadata = 14;
inline bool RTLookupRequest::_internal_has_client_reporting_metadata() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.client_reporting_metadata_ != nullptr);
    return value;
}
inline bool RTLookupRequest::has_client_reporting_metadata() const
{
    return _internal_has_client_reporting_metadata();
}
inline const ::enterprise_connectors::ClientMetadata& RTLookupRequest::_internal_client_reporting_metadata() const
{
    const ::enterprise_connectors::ClientMetadata* p = _impl_.client_reporting_metadata_;
    return p != nullptr ? *p : reinterpret_cast<const ::enterprise_connectors::ClientMetadata&>(::enterprise_connectors::_ClientMetadata_default_instance_);
}
inline const ::enterprise_connectors::ClientMetadata& RTLookupRequest::client_reporting_metadata() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupRequest.client_reporting_metadata)
    return _internal_client_reporting_metadata();
}
inline void RTLookupRequest::unsafe_arena_set_allocated_client_reporting_metadata(::enterprise_connectors::ClientMetadata* client_reporting_metadata)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_reporting_metadata_);
    }
    _impl_.client_reporting_metadata_ = client_reporting_metadata;
    if (client_reporting_metadata) {
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.RTLookupRequest.client_reporting_metadata)
}
inline ::enterprise_connectors::ClientMetadata* RTLookupRequest::release_client_reporting_metadata()
{
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::enterprise_connectors::ClientMetadata* temp = _impl_.client_reporting_metadata_;
    _impl_.client_reporting_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::enterprise_connectors::ClientMetadata* RTLookupRequest::unsafe_arena_release_client_reporting_metadata()
{
    // @@protoc_insertion_point(field_release:safe_browsing.RTLookupRequest.client_reporting_metadata)
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::enterprise_connectors::ClientMetadata* temp = _impl_.client_reporting_metadata_;
    _impl_.client_reporting_metadata_ = nullptr;
    return temp;
}
inline ::enterprise_connectors::ClientMetadata* RTLookupRequest::_internal_mutable_client_reporting_metadata()
{
    _impl_._has_bits_[0] |= 0x00000080u;
    if (_impl_.client_reporting_metadata_ == nullptr) {
        auto* p = CreateMaybeMessage<::enterprise_connectors::ClientMetadata>(GetArenaForAllocation());
        _impl_.client_reporting_metadata_ = p;
    }
    return _impl_.client_reporting_metadata_;
}
inline ::enterprise_connectors::ClientMetadata* RTLookupRequest::mutable_client_reporting_metadata()
{
    ::enterprise_connectors::ClientMetadata* _msg = _internal_mutable_client_reporting_metadata();
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupRequest.client_reporting_metadata)
    return _msg;
}
inline void RTLookupRequest::set_allocated_client_reporting_metadata(::enterprise_connectors::ClientMetadata* client_reporting_metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_reporting_metadata_);
    }
    if (client_reporting_metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_reporting_metadata));
        if (message_arena != submessage_arena) {
            client_reporting_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, client_reporting_metadata, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    _impl_.client_reporting_metadata_ = client_reporting_metadata;
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.RTLookupRequest.client_reporting_metadata)
}

// optional string email = 13;
inline bool RTLookupRequest::_internal_has_email() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool RTLookupRequest::has_email() const
{
    return _internal_has_email();
}
inline void RTLookupRequest::clear_email()
{
    _impl_.email_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& RTLookupRequest::email() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupRequest.email)
    return _internal_email();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void RTLookupRequest::set_email(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.email_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupRequest.email)
}
inline std::string* RTLookupRequest::mutable_email()
{
    std::string* _s = _internal_mutable_email();
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupRequest.email)
    return _s;
}
inline const std::string& RTLookupRequest::_internal_email() const
{
    return _impl_.email_.Get();
}
inline void RTLookupRequest::_internal_set_email(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* RTLookupRequest::_internal_mutable_email()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* RTLookupRequest::release_email()
{
    // @@protoc_insertion_point(field_release:safe_browsing.RTLookupRequest.email)
    if (!_internal_has_email()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000020u;
    auto* p = _impl_.email_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.email_.IsDefault()) {
        _impl_.email_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void RTLookupRequest::set_allocated_email(std::string* email)
{
    if (email != nullptr) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.email_.IsDefault()) {
        _impl_.email_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.RTLookupRequest.email)
}

// optional int32 version = 6 [default = 0];
inline bool RTLookupRequest::_internal_has_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool RTLookupRequest::has_version() const
{
    return _internal_has_version();
}
inline void RTLookupRequest::clear_version()
{
    _impl_.version_ = 0;
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t RTLookupRequest::_internal_version() const
{
    return _impl_.version_;
}
inline int32_t RTLookupRequest::version() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupRequest.version)
    return _internal_version();
}
inline void RTLookupRequest::_internal_set_version(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.version_ = value;
}
inline void RTLookupRequest::set_version(int32_t value)
{
    _internal_set_version(value);
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupRequest.version)
}

// optional .safe_browsing.RTLookupRequest.OSType os_type = 7;
inline bool RTLookupRequest::_internal_has_os_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    return value;
}
inline bool RTLookupRequest::has_os_type() const
{
    return _internal_has_os_type();
}
inline void RTLookupRequest::clear_os_type()
{
    _impl_.os_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::safe_browsing::RTLookupRequest_OSType RTLookupRequest::_internal_os_type() const
{
    return static_cast<::safe_browsing::RTLookupRequest_OSType>(_impl_.os_type_);
}
inline ::safe_browsing::RTLookupRequest_OSType RTLookupRequest::os_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupRequest.os_type)
    return _internal_os_type();
}
inline void RTLookupRequest::_internal_set_os_type(::safe_browsing::RTLookupRequest_OSType value)
{
    assert(::safe_browsing::RTLookupRequest_OSType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000400u;
    _impl_.os_type_ = value;
}
inline void RTLookupRequest::set_os_type(::safe_browsing::RTLookupRequest_OSType value)
{
    _internal_set_os_type(value);
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupRequest.os_type)
}

// repeated .safe_browsing.ReferrerChainEntry referrer_chain = 8;
inline int RTLookupRequest::_internal_referrer_chain_size() const
{
    return _impl_.referrer_chain_.size();
}
inline int RTLookupRequest::referrer_chain_size() const
{
    return _internal_referrer_chain_size();
}
inline ::safe_browsing::ReferrerChainEntry* RTLookupRequest::mutable_referrer_chain(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupRequest.referrer_chain)
    return _impl_.referrer_chain_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::ReferrerChainEntry>* RTLookupRequest::mutable_referrer_chain()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.RTLookupRequest.referrer_chain)
    return &_impl_.referrer_chain_;
}
inline const ::safe_browsing::ReferrerChainEntry& RTLookupRequest::_internal_referrer_chain(int index) const
{
    return _impl_.referrer_chain_.Get(index);
}
inline const ::safe_browsing::ReferrerChainEntry& RTLookupRequest::referrer_chain(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupRequest.referrer_chain)
    return _internal_referrer_chain(index);
}
inline ::safe_browsing::ReferrerChainEntry* RTLookupRequest::_internal_add_referrer_chain()
{
    return _impl_.referrer_chain_.Add();
}
inline ::safe_browsing::ReferrerChainEntry* RTLookupRequest::add_referrer_chain()
{
    ::safe_browsing::ReferrerChainEntry* _add = _internal_add_referrer_chain();
    // @@protoc_insertion_point(field_add:safe_browsing.RTLookupRequest.referrer_chain)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::ReferrerChainEntry>& RTLookupRequest::referrer_chain() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.RTLookupRequest.referrer_chain)
    return _impl_.referrer_chain_;
}

// optional .safe_browsing.RTLookupRequest.ReportType report_type = 9;
inline bool RTLookupRequest::_internal_has_report_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    return value;
}
inline bool RTLookupRequest::has_report_type() const
{
    return _internal_has_report_type();
}
inline void RTLookupRequest::clear_report_type()
{
    _impl_.report_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::safe_browsing::RTLookupRequest_ReportType RTLookupRequest::_internal_report_type() const
{
    return static_cast<::safe_browsing::RTLookupRequest_ReportType>(_impl_.report_type_);
}
inline ::safe_browsing::RTLookupRequest_ReportType RTLookupRequest::report_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupRequest.report_type)
    return _internal_report_type();
}
inline void RTLookupRequest::_internal_set_report_type(::safe_browsing::RTLookupRequest_ReportType value)
{
    assert(::safe_browsing::RTLookupRequest_ReportType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000800u;
    _impl_.report_type_ = value;
}
inline void RTLookupRequest::set_report_type(::safe_browsing::RTLookupRequest_ReportType value)
{
    _internal_set_report_type(value);
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupRequest.report_type)
}

// optional .safe_browsing.RTLookupRequest.FrameType frame_type = 10;
inline bool RTLookupRequest::_internal_has_frame_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
    return value;
}
inline bool RTLookupRequest::has_frame_type() const
{
    return _internal_has_frame_type();
}
inline void RTLookupRequest::clear_frame_type()
{
    _impl_.frame_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::safe_browsing::RTLookupRequest_FrameType RTLookupRequest::_internal_frame_type() const
{
    return static_cast<::safe_browsing::RTLookupRequest_FrameType>(_impl_.frame_type_);
}
inline ::safe_browsing::RTLookupRequest_FrameType RTLookupRequest::frame_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupRequest.frame_type)
    return _internal_frame_type();
}
inline void RTLookupRequest::_internal_set_frame_type(::safe_browsing::RTLookupRequest_FrameType value)
{
    assert(::safe_browsing::RTLookupRequest_FrameType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00001000u;
    _impl_.frame_type_ = value;
}
inline void RTLookupRequest::set_frame_type(::safe_browsing::RTLookupRequest_FrameType value)
{
    _internal_set_frame_type(value);
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupRequest.frame_type)
}

// -------------------------------------------------------------------

// RTLookupResponse_ThreatInfo

// optional .safe_browsing.RTLookupResponse.ThreatInfo.ThreatType threat_type = 1;
inline bool RTLookupResponse_ThreatInfo::_internal_has_threat_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool RTLookupResponse_ThreatInfo::has_threat_type() const
{
    return _internal_has_threat_type();
}
inline void RTLookupResponse_ThreatInfo::clear_threat_type()
{
    _impl_.threat_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::safe_browsing::RTLookupResponse_ThreatInfo_ThreatType RTLookupResponse_ThreatInfo::_internal_threat_type() const
{
    return static_cast<::safe_browsing::RTLookupResponse_ThreatInfo_ThreatType>(_impl_.threat_type_);
}
inline ::safe_browsing::RTLookupResponse_ThreatInfo_ThreatType RTLookupResponse_ThreatInfo::threat_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupResponse.ThreatInfo.threat_type)
    return _internal_threat_type();
}
inline void RTLookupResponse_ThreatInfo::_internal_set_threat_type(::safe_browsing::RTLookupResponse_ThreatInfo_ThreatType value)
{
    assert(::safe_browsing::RTLookupResponse_ThreatInfo_ThreatType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.threat_type_ = value;
}
inline void RTLookupResponse_ThreatInfo::set_threat_type(::safe_browsing::RTLookupResponse_ThreatInfo_ThreatType value)
{
    _internal_set_threat_type(value);
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupResponse.ThreatInfo.threat_type)
}

// optional int64 cache_duration_sec = 2;
inline bool RTLookupResponse_ThreatInfo::_internal_has_cache_duration_sec() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool RTLookupResponse_ThreatInfo::has_cache_duration_sec() const
{
    return _internal_has_cache_duration_sec();
}
inline void RTLookupResponse_ThreatInfo::clear_cache_duration_sec()
{
    _impl_.cache_duration_sec_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t RTLookupResponse_ThreatInfo::_internal_cache_duration_sec() const
{
    return _impl_.cache_duration_sec_;
}
inline int64_t RTLookupResponse_ThreatInfo::cache_duration_sec() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupResponse.ThreatInfo.cache_duration_sec)
    return _internal_cache_duration_sec();
}
inline void RTLookupResponse_ThreatInfo::_internal_set_cache_duration_sec(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.cache_duration_sec_ = value;
}
inline void RTLookupResponse_ThreatInfo::set_cache_duration_sec(int64_t value)
{
    _internal_set_cache_duration_sec(value);
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupResponse.ThreatInfo.cache_duration_sec)
}

// optional string cache_expression = 3 [deprecated = true];
inline bool RTLookupResponse_ThreatInfo::_internal_has_cache_expression() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool RTLookupResponse_ThreatInfo::has_cache_expression() const
{
    return _internal_has_cache_expression();
}
inline void RTLookupResponse_ThreatInfo::clear_cache_expression()
{
    _impl_.cache_expression_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RTLookupResponse_ThreatInfo::cache_expression() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupResponse.ThreatInfo.cache_expression)
    return _internal_cache_expression();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void RTLookupResponse_ThreatInfo::set_cache_expression(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.cache_expression_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupResponse.ThreatInfo.cache_expression)
}
inline std::string* RTLookupResponse_ThreatInfo::mutable_cache_expression()
{
    std::string* _s = _internal_mutable_cache_expression();
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupResponse.ThreatInfo.cache_expression)
    return _s;
}
inline const std::string& RTLookupResponse_ThreatInfo::_internal_cache_expression() const
{
    return _impl_.cache_expression_.Get();
}
inline void RTLookupResponse_ThreatInfo::_internal_set_cache_expression(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.cache_expression_.Set(value, GetArenaForAllocation());
}
inline std::string* RTLookupResponse_ThreatInfo::_internal_mutable_cache_expression()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.cache_expression_.Mutable(GetArenaForAllocation());
}
inline std::string* RTLookupResponse_ThreatInfo::release_cache_expression()
{
    // @@protoc_insertion_point(field_release:safe_browsing.RTLookupResponse.ThreatInfo.cache_expression)
    if (!_internal_has_cache_expression()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.cache_expression_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cache_expression_.IsDefault()) {
        _impl_.cache_expression_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void RTLookupResponse_ThreatInfo::set_allocated_cache_expression(std::string* cache_expression)
{
    if (cache_expression != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.cache_expression_.SetAllocated(cache_expression, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cache_expression_.IsDefault()) {
        _impl_.cache_expression_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.RTLookupResponse.ThreatInfo.cache_expression)
}

// optional .safe_browsing.RTLookupResponse.ThreatInfo.VerdictType verdict_type = 4;
inline bool RTLookupResponse_ThreatInfo::_internal_has_verdict_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool RTLookupResponse_ThreatInfo::has_verdict_type() const
{
    return _internal_has_verdict_type();
}
inline void RTLookupResponse_ThreatInfo::clear_verdict_type()
{
    _impl_.verdict_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::safe_browsing::RTLookupResponse_ThreatInfo_VerdictType RTLookupResponse_ThreatInfo::_internal_verdict_type() const
{
    return static_cast<::safe_browsing::RTLookupResponse_ThreatInfo_VerdictType>(_impl_.verdict_type_);
}
inline ::safe_browsing::RTLookupResponse_ThreatInfo_VerdictType RTLookupResponse_ThreatInfo::verdict_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupResponse.ThreatInfo.verdict_type)
    return _internal_verdict_type();
}
inline void RTLookupResponse_ThreatInfo::_internal_set_verdict_type(::safe_browsing::RTLookupResponse_ThreatInfo_VerdictType value)
{
    assert(::safe_browsing::RTLookupResponse_ThreatInfo_VerdictType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.verdict_type_ = value;
}
inline void RTLookupResponse_ThreatInfo::set_verdict_type(::safe_browsing::RTLookupResponse_ThreatInfo_VerdictType value)
{
    _internal_set_verdict_type(value);
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupResponse.ThreatInfo.verdict_type)
}

// optional .safe_browsing.RTLookupResponse.ThreatInfo.CacheExpressionMatchType cache_expression_match_type = 5;
inline bool RTLookupResponse_ThreatInfo::_internal_has_cache_expression_match_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool RTLookupResponse_ThreatInfo::has_cache_expression_match_type() const
{
    return _internal_has_cache_expression_match_type();
}
inline void RTLookupResponse_ThreatInfo::clear_cache_expression_match_type()
{
    _impl_.cache_expression_match_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::safe_browsing::RTLookupResponse_ThreatInfo_CacheExpressionMatchType RTLookupResponse_ThreatInfo::_internal_cache_expression_match_type() const
{
    return static_cast<::safe_browsing::RTLookupResponse_ThreatInfo_CacheExpressionMatchType>(_impl_.cache_expression_match_type_);
}
inline ::safe_browsing::RTLookupResponse_ThreatInfo_CacheExpressionMatchType RTLookupResponse_ThreatInfo::cache_expression_match_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupResponse.ThreatInfo.cache_expression_match_type)
    return _internal_cache_expression_match_type();
}
inline void RTLookupResponse_ThreatInfo::_internal_set_cache_expression_match_type(::safe_browsing::RTLookupResponse_ThreatInfo_CacheExpressionMatchType value)
{
    assert(::safe_browsing::RTLookupResponse_ThreatInfo_CacheExpressionMatchType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.cache_expression_match_type_ = value;
}
inline void RTLookupResponse_ThreatInfo::set_cache_expression_match_type(::safe_browsing::RTLookupResponse_ThreatInfo_CacheExpressionMatchType value)
{
    _internal_set_cache_expression_match_type(value);
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupResponse.ThreatInfo.cache_expression_match_type)
}

// optional string cache_expression_using_match_type = 6;
inline bool RTLookupResponse_ThreatInfo::_internal_has_cache_expression_using_match_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool RTLookupResponse_ThreatInfo::has_cache_expression_using_match_type() const
{
    return _internal_has_cache_expression_using_match_type();
}
inline void RTLookupResponse_ThreatInfo::clear_cache_expression_using_match_type()
{
    _impl_.cache_expression_using_match_type_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RTLookupResponse_ThreatInfo::cache_expression_using_match_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupResponse.ThreatInfo.cache_expression_using_match_type)
    return _internal_cache_expression_using_match_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void RTLookupResponse_ThreatInfo::set_cache_expression_using_match_type(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.cache_expression_using_match_type_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupResponse.ThreatInfo.cache_expression_using_match_type)
}
inline std::string* RTLookupResponse_ThreatInfo::mutable_cache_expression_using_match_type()
{
    std::string* _s = _internal_mutable_cache_expression_using_match_type();
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupResponse.ThreatInfo.cache_expression_using_match_type)
    return _s;
}
inline const std::string& RTLookupResponse_ThreatInfo::_internal_cache_expression_using_match_type() const
{
    return _impl_.cache_expression_using_match_type_.Get();
}
inline void RTLookupResponse_ThreatInfo::_internal_set_cache_expression_using_match_type(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.cache_expression_using_match_type_.Set(value, GetArenaForAllocation());
}
inline std::string* RTLookupResponse_ThreatInfo::_internal_mutable_cache_expression_using_match_type()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.cache_expression_using_match_type_.Mutable(GetArenaForAllocation());
}
inline std::string* RTLookupResponse_ThreatInfo::release_cache_expression_using_match_type()
{
    // @@protoc_insertion_point(field_release:safe_browsing.RTLookupResponse.ThreatInfo.cache_expression_using_match_type)
    if (!_internal_has_cache_expression_using_match_type()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.cache_expression_using_match_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cache_expression_using_match_type_.IsDefault()) {
        _impl_.cache_expression_using_match_type_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void RTLookupResponse_ThreatInfo::set_allocated_cache_expression_using_match_type(std::string* cache_expression_using_match_type)
{
    if (cache_expression_using_match_type != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.cache_expression_using_match_type_.SetAllocated(cache_expression_using_match_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cache_expression_using_match_type_.IsDefault()) {
        _impl_.cache_expression_using_match_type_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.RTLookupResponse.ThreatInfo.cache_expression_using_match_type)
}

// optional .safe_browsing.MatchedUrlNavigationRule matched_url_navigation_rule = 7;
inline bool RTLookupResponse_ThreatInfo::_internal_has_matched_url_navigation_rule() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.matched_url_navigation_rule_ != nullptr);
    return value;
}
inline bool RTLookupResponse_ThreatInfo::has_matched_url_navigation_rule() const
{
    return _internal_has_matched_url_navigation_rule();
}
inline void RTLookupResponse_ThreatInfo::clear_matched_url_navigation_rule()
{
    if (_impl_.matched_url_navigation_rule_ != nullptr)
        _impl_.matched_url_navigation_rule_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::safe_browsing::MatchedUrlNavigationRule& RTLookupResponse_ThreatInfo::_internal_matched_url_navigation_rule() const
{
    const ::safe_browsing::MatchedUrlNavigationRule* p = _impl_.matched_url_navigation_rule_;
    return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::MatchedUrlNavigationRule&>(::safe_browsing::_MatchedUrlNavigationRule_default_instance_);
}
inline const ::safe_browsing::MatchedUrlNavigationRule& RTLookupResponse_ThreatInfo::matched_url_navigation_rule() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupResponse.ThreatInfo.matched_url_navigation_rule)
    return _internal_matched_url_navigation_rule();
}
inline void RTLookupResponse_ThreatInfo::unsafe_arena_set_allocated_matched_url_navigation_rule(
    ::safe_browsing::MatchedUrlNavigationRule* matched_url_navigation_rule)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.matched_url_navigation_rule_);
    }
    _impl_.matched_url_navigation_rule_ = matched_url_navigation_rule;
    if (matched_url_navigation_rule) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.RTLookupResponse.ThreatInfo.matched_url_navigation_rule)
}
inline ::safe_browsing::MatchedUrlNavigationRule* RTLookupResponse_ThreatInfo::release_matched_url_navigation_rule()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::safe_browsing::MatchedUrlNavigationRule* temp = _impl_.matched_url_navigation_rule_;
    _impl_.matched_url_navigation_rule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::safe_browsing::MatchedUrlNavigationRule* RTLookupResponse_ThreatInfo::unsafe_arena_release_matched_url_navigation_rule()
{
    // @@protoc_insertion_point(field_release:safe_browsing.RTLookupResponse.ThreatInfo.matched_url_navigation_rule)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::safe_browsing::MatchedUrlNavigationRule* temp = _impl_.matched_url_navigation_rule_;
    _impl_.matched_url_navigation_rule_ = nullptr;
    return temp;
}
inline ::safe_browsing::MatchedUrlNavigationRule* RTLookupResponse_ThreatInfo::_internal_mutable_matched_url_navigation_rule()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.matched_url_navigation_rule_ == nullptr) {
        auto* p = CreateMaybeMessage<::safe_browsing::MatchedUrlNavigationRule>(GetArenaForAllocation());
        _impl_.matched_url_navigation_rule_ = p;
    }
    return _impl_.matched_url_navigation_rule_;
}
inline ::safe_browsing::MatchedUrlNavigationRule* RTLookupResponse_ThreatInfo::mutable_matched_url_navigation_rule()
{
    ::safe_browsing::MatchedUrlNavigationRule* _msg = _internal_mutable_matched_url_navigation_rule();
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupResponse.ThreatInfo.matched_url_navigation_rule)
    return _msg;
}
inline void RTLookupResponse_ThreatInfo::set_allocated_matched_url_navigation_rule(::safe_browsing::MatchedUrlNavigationRule* matched_url_navigation_rule)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.matched_url_navigation_rule_;
    }
    if (matched_url_navigation_rule) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(matched_url_navigation_rule);
        if (message_arena != submessage_arena) {
            matched_url_navigation_rule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, matched_url_navigation_rule, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.matched_url_navigation_rule_ = matched_url_navigation_rule;
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.RTLookupResponse.ThreatInfo.matched_url_navigation_rule)
}

// -------------------------------------------------------------------

// RTLookupResponse

// repeated .safe_browsing.RTLookupResponse.ThreatInfo threat_info = 1;
inline int RTLookupResponse::_internal_threat_info_size() const
{
    return _impl_.threat_info_.size();
}
inline int RTLookupResponse::threat_info_size() const
{
    return _internal_threat_info_size();
}
inline void RTLookupResponse::clear_threat_info()
{
    _impl_.threat_info_.Clear();
}
inline ::safe_browsing::RTLookupResponse_ThreatInfo* RTLookupResponse::mutable_threat_info(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupResponse.threat_info)
    return _impl_.threat_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::RTLookupResponse_ThreatInfo>* RTLookupResponse::mutable_threat_info()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.RTLookupResponse.threat_info)
    return &_impl_.threat_info_;
}
inline const ::safe_browsing::RTLookupResponse_ThreatInfo& RTLookupResponse::_internal_threat_info(int index) const
{
    return _impl_.threat_info_.Get(index);
}
inline const ::safe_browsing::RTLookupResponse_ThreatInfo& RTLookupResponse::threat_info(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupResponse.threat_info)
    return _internal_threat_info(index);
}
inline ::safe_browsing::RTLookupResponse_ThreatInfo* RTLookupResponse::_internal_add_threat_info()
{
    return _impl_.threat_info_.Add();
}
inline ::safe_browsing::RTLookupResponse_ThreatInfo* RTLookupResponse::add_threat_info()
{
    ::safe_browsing::RTLookupResponse_ThreatInfo* _add = _internal_add_threat_info();
    // @@protoc_insertion_point(field_add:safe_browsing.RTLookupResponse.threat_info)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::RTLookupResponse_ThreatInfo>& RTLookupResponse::threat_info() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.RTLookupResponse.threat_info)
    return _impl_.threat_info_;
}

// optional .safe_browsing.ClientSideDetectionType client_side_detection_type = 2;
inline bool RTLookupResponse::_internal_has_client_side_detection_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool RTLookupResponse::has_client_side_detection_type() const
{
    return _internal_has_client_side_detection_type();
}
inline void RTLookupResponse::clear_client_side_detection_type()
{
    _impl_.client_side_detection_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::safe_browsing::ClientSideDetectionType RTLookupResponse::_internal_client_side_detection_type() const
{
    return static_cast<::safe_browsing::ClientSideDetectionType>(_impl_.client_side_detection_type_);
}
inline ::safe_browsing::ClientSideDetectionType RTLookupResponse::client_side_detection_type() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupResponse.client_side_detection_type)
    return _internal_client_side_detection_type();
}
inline void RTLookupResponse::_internal_set_client_side_detection_type(::safe_browsing::ClientSideDetectionType value)
{
    assert(::safe_browsing::ClientSideDetectionType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.client_side_detection_type_ = value;
}
inline void RTLookupResponse::set_client_side_detection_type(::safe_browsing::ClientSideDetectionType value)
{
    _internal_set_client_side_detection_type(value);
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupResponse.client_side_detection_type)
}

// repeated string url_categories = 3;
inline int RTLookupResponse::_internal_url_categories_size() const
{
    return _impl_.url_categories_.size();
}
inline int RTLookupResponse::url_categories_size() const
{
    return _internal_url_categories_size();
}
inline void RTLookupResponse::clear_url_categories()
{
    _impl_.url_categories_.Clear();
}
inline std::string* RTLookupResponse::add_url_categories()
{
    std::string* _s = _internal_add_url_categories();
    // @@protoc_insertion_point(field_add_mutable:safe_browsing.RTLookupResponse.url_categories)
    return _s;
}
inline const std::string& RTLookupResponse::_internal_url_categories(int index) const
{
    return _impl_.url_categories_.Get(index);
}
inline const std::string& RTLookupResponse::url_categories(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupResponse.url_categories)
    return _internal_url_categories(index);
}
inline std::string* RTLookupResponse::mutable_url_categories(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupResponse.url_categories)
    return _impl_.url_categories_.Mutable(index);
}
inline void RTLookupResponse::set_url_categories(int index, const std::string& value)
{
    _impl_.url_categories_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupResponse.url_categories)
}
inline void RTLookupResponse::set_url_categories(int index, std::string&& value)
{
    _impl_.url_categories_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:safe_browsing.RTLookupResponse.url_categories)
}
inline void RTLookupResponse::set_url_categories(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.url_categories_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:safe_browsing.RTLookupResponse.url_categories)
}
inline void RTLookupResponse::set_url_categories(int index, const char* value, size_t size)
{
    _impl_.url_categories_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:safe_browsing.RTLookupResponse.url_categories)
}
inline std::string* RTLookupResponse::_internal_add_url_categories()
{
    return _impl_.url_categories_.Add();
}
inline void RTLookupResponse::add_url_categories(const std::string& value)
{
    _impl_.url_categories_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:safe_browsing.RTLookupResponse.url_categories)
}
inline void RTLookupResponse::add_url_categories(std::string&& value)
{
    _impl_.url_categories_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:safe_browsing.RTLookupResponse.url_categories)
}
inline void RTLookupResponse::add_url_categories(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.url_categories_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:safe_browsing.RTLookupResponse.url_categories)
}
inline void RTLookupResponse::add_url_categories(const char* value, size_t size)
{
    _impl_.url_categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:safe_browsing.RTLookupResponse.url_categories)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& RTLookupResponse::url_categories() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.RTLookupResponse.url_categories)
    return _impl_.url_categories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* RTLookupResponse::mutable_url_categories()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.RTLookupResponse.url_categories)
    return &_impl_.url_categories_;
}

// optional .safe_browsing.LlamaForcedTriggerInfo llama_forced_trigger_info = 4;
inline bool RTLookupResponse::_internal_has_llama_forced_trigger_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.llama_forced_trigger_info_ != nullptr);
    return value;
}
inline bool RTLookupResponse::has_llama_forced_trigger_info() const
{
    return _internal_has_llama_forced_trigger_info();
}
inline const ::safe_browsing::LlamaForcedTriggerInfo& RTLookupResponse::_internal_llama_forced_trigger_info() const
{
    const ::safe_browsing::LlamaForcedTriggerInfo* p = _impl_.llama_forced_trigger_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::LlamaForcedTriggerInfo&>(::safe_browsing::_LlamaForcedTriggerInfo_default_instance_);
}
inline const ::safe_browsing::LlamaForcedTriggerInfo& RTLookupResponse::llama_forced_trigger_info() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.RTLookupResponse.llama_forced_trigger_info)
    return _internal_llama_forced_trigger_info();
}
inline void RTLookupResponse::unsafe_arena_set_allocated_llama_forced_trigger_info(::safe_browsing::LlamaForcedTriggerInfo* llama_forced_trigger_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.llama_forced_trigger_info_);
    }
    _impl_.llama_forced_trigger_info_ = llama_forced_trigger_info;
    if (llama_forced_trigger_info) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.RTLookupResponse.llama_forced_trigger_info)
}
inline ::safe_browsing::LlamaForcedTriggerInfo* RTLookupResponse::release_llama_forced_trigger_info()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::safe_browsing::LlamaForcedTriggerInfo* temp = _impl_.llama_forced_trigger_info_;
    _impl_.llama_forced_trigger_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::safe_browsing::LlamaForcedTriggerInfo* RTLookupResponse::unsafe_arena_release_llama_forced_trigger_info()
{
    // @@protoc_insertion_point(field_release:safe_browsing.RTLookupResponse.llama_forced_trigger_info)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::safe_browsing::LlamaForcedTriggerInfo* temp = _impl_.llama_forced_trigger_info_;
    _impl_.llama_forced_trigger_info_ = nullptr;
    return temp;
}
inline ::safe_browsing::LlamaForcedTriggerInfo* RTLookupResponse::_internal_mutable_llama_forced_trigger_info()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.llama_forced_trigger_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::safe_browsing::LlamaForcedTriggerInfo>(GetArenaForAllocation());
        _impl_.llama_forced_trigger_info_ = p;
    }
    return _impl_.llama_forced_trigger_info_;
}
inline ::safe_browsing::LlamaForcedTriggerInfo* RTLookupResponse::mutable_llama_forced_trigger_info()
{
    ::safe_browsing::LlamaForcedTriggerInfo* _msg = _internal_mutable_llama_forced_trigger_info();
    // @@protoc_insertion_point(field_mutable:safe_browsing.RTLookupResponse.llama_forced_trigger_info)
    return _msg;
}
inline void RTLookupResponse::set_allocated_llama_forced_trigger_info(::safe_browsing::LlamaForcedTriggerInfo* llama_forced_trigger_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.llama_forced_trigger_info_);
    }
    if (llama_forced_trigger_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(llama_forced_trigger_info));
        if (message_arena != submessage_arena) {
            llama_forced_trigger_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, llama_forced_trigger_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.llama_forced_trigger_info_ = llama_forced_trigger_info;
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.RTLookupResponse.llama_forced_trigger_info)
}

// -------------------------------------------------------------------

// Timestamp

// optional int64 seconds = 1;
inline bool Timestamp::_internal_has_seconds() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Timestamp::has_seconds() const
{
    return _internal_has_seconds();
}
inline void Timestamp::clear_seconds()
{
    _impl_.seconds_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t Timestamp::_internal_seconds() const
{
    return _impl_.seconds_;
}
inline int64_t Timestamp::seconds() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.Timestamp.seconds)
    return _internal_seconds();
}
inline void Timestamp::_internal_set_seconds(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.seconds_ = value;
}
inline void Timestamp::set_seconds(int64_t value)
{
    _internal_set_seconds(value);
    // @@protoc_insertion_point(field_set:safe_browsing.Timestamp.seconds)
}

// optional int32 nanos = 2;
inline bool Timestamp::_internal_has_nanos() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Timestamp::has_nanos() const
{
    return _internal_has_nanos();
}
inline void Timestamp::clear_nanos()
{
    _impl_.nanos_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t Timestamp::_internal_nanos() const
{
    return _impl_.nanos_;
}
inline int32_t Timestamp::nanos() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.Timestamp.nanos)
    return _internal_nanos();
}
inline void Timestamp::_internal_set_nanos(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.nanos_ = value;
}
inline void Timestamp::set_nanos(int32_t value)
{
    _internal_set_nanos(value);
    // @@protoc_insertion_point(field_set:safe_browsing.Timestamp.nanos)
}

// -------------------------------------------------------------------

// MatchedUrlNavigationRule_CustomRuleMessageSegment

// optional string text = 1;
inline bool MatchedUrlNavigationRule_CustomRuleMessageSegment::_internal_has_text() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool MatchedUrlNavigationRule_CustomRuleMessageSegment::has_text() const
{
    return _internal_has_text();
}
inline void MatchedUrlNavigationRule_CustomRuleMessageSegment::clear_text()
{
    _impl_.text_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MatchedUrlNavigationRule_CustomRuleMessageSegment::text() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment.text)
    return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void MatchedUrlNavigationRule_CustomRuleMessageSegment::set_text(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.text_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment.text)
}
inline std::string* MatchedUrlNavigationRule_CustomRuleMessageSegment::mutable_text()
{
    std::string* _s = _internal_mutable_text();
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment.text)
    return _s;
}
inline const std::string& MatchedUrlNavigationRule_CustomRuleMessageSegment::_internal_text() const
{
    return _impl_.text_.Get();
}
inline void MatchedUrlNavigationRule_CustomRuleMessageSegment::_internal_set_text(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_CustomRuleMessageSegment::_internal_mutable_text()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_CustomRuleMessageSegment::release_text()
{
    // @@protoc_insertion_point(field_release:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment.text)
    if (!_internal_has_text()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.text_.IsDefault()) {
        _impl_.text_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void MatchedUrlNavigationRule_CustomRuleMessageSegment::set_allocated_text(std::string* text)
{
    if (text != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.text_.IsDefault()) {
        _impl_.text_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment.text)
}

// optional string link = 2;
inline bool MatchedUrlNavigationRule_CustomRuleMessageSegment::_internal_has_link() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool MatchedUrlNavigationRule_CustomRuleMessageSegment::has_link() const
{
    return _internal_has_link();
}
inline void MatchedUrlNavigationRule_CustomRuleMessageSegment::clear_link()
{
    _impl_.link_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MatchedUrlNavigationRule_CustomRuleMessageSegment::link() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment.link)
    return _internal_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void MatchedUrlNavigationRule_CustomRuleMessageSegment::set_link(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.link_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment.link)
}
inline std::string* MatchedUrlNavigationRule_CustomRuleMessageSegment::mutable_link()
{
    std::string* _s = _internal_mutable_link();
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment.link)
    return _s;
}
inline const std::string& MatchedUrlNavigationRule_CustomRuleMessageSegment::_internal_link() const
{
    return _impl_.link_.Get();
}
inline void MatchedUrlNavigationRule_CustomRuleMessageSegment::_internal_set_link(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.link_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_CustomRuleMessageSegment::_internal_mutable_link()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.link_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_CustomRuleMessageSegment::release_link()
{
    // @@protoc_insertion_point(field_release:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment.link)
    if (!_internal_has_link()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.link_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.link_.IsDefault()) {
        _impl_.link_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void MatchedUrlNavigationRule_CustomRuleMessageSegment::set_allocated_link(std::string* link)
{
    if (link != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.link_.SetAllocated(link, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.link_.IsDefault()) {
        _impl_.link_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment.link)
}

// -------------------------------------------------------------------

// MatchedUrlNavigationRule_CustomMessage

// optional string custom_message = 1 [deprecated = true];
inline bool MatchedUrlNavigationRule_CustomMessage::_internal_has_custom_message() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool MatchedUrlNavigationRule_CustomMessage::has_custom_message() const
{
    return _internal_has_custom_message();
}
inline void MatchedUrlNavigationRule_CustomMessage::clear_custom_message()
{
    _impl_.custom_message_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MatchedUrlNavigationRule_CustomMessage::custom_message() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.CustomMessage.custom_message)
    return _internal_custom_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void MatchedUrlNavigationRule_CustomMessage::set_custom_message(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.custom_message_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.MatchedUrlNavigationRule.CustomMessage.custom_message)
}
inline std::string* MatchedUrlNavigationRule_CustomMessage::mutable_custom_message()
{
    std::string* _s = _internal_mutable_custom_message();
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.CustomMessage.custom_message)
    return _s;
}
inline const std::string& MatchedUrlNavigationRule_CustomMessage::_internal_custom_message() const
{
    return _impl_.custom_message_.Get();
}
inline void MatchedUrlNavigationRule_CustomMessage::_internal_set_custom_message(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.custom_message_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_CustomMessage::_internal_mutable_custom_message()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.custom_message_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_CustomMessage::release_custom_message()
{
    // @@protoc_insertion_point(field_release:safe_browsing.MatchedUrlNavigationRule.CustomMessage.custom_message)
    if (!_internal_has_custom_message()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.custom_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.custom_message_.IsDefault()) {
        _impl_.custom_message_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void MatchedUrlNavigationRule_CustomMessage::set_allocated_custom_message(std::string* custom_message)
{
    if (custom_message != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.custom_message_.SetAllocated(custom_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.custom_message_.IsDefault()) {
        _impl_.custom_message_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.MatchedUrlNavigationRule.CustomMessage.custom_message)
}

// optional string learn_more_link = 2 [deprecated = true];
inline bool MatchedUrlNavigationRule_CustomMessage::_internal_has_learn_more_link() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool MatchedUrlNavigationRule_CustomMessage::has_learn_more_link() const
{
    return _internal_has_learn_more_link();
}
inline void MatchedUrlNavigationRule_CustomMessage::clear_learn_more_link()
{
    _impl_.learn_more_link_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MatchedUrlNavigationRule_CustomMessage::learn_more_link() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.CustomMessage.learn_more_link)
    return _internal_learn_more_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void MatchedUrlNavigationRule_CustomMessage::set_learn_more_link(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.learn_more_link_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.MatchedUrlNavigationRule.CustomMessage.learn_more_link)
}
inline std::string* MatchedUrlNavigationRule_CustomMessage::mutable_learn_more_link()
{
    std::string* _s = _internal_mutable_learn_more_link();
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.CustomMessage.learn_more_link)
    return _s;
}
inline const std::string& MatchedUrlNavigationRule_CustomMessage::_internal_learn_more_link() const
{
    return _impl_.learn_more_link_.Get();
}
inline void MatchedUrlNavigationRule_CustomMessage::_internal_set_learn_more_link(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.learn_more_link_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_CustomMessage::_internal_mutable_learn_more_link()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.learn_more_link_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_CustomMessage::release_learn_more_link()
{
    // @@protoc_insertion_point(field_release:safe_browsing.MatchedUrlNavigationRule.CustomMessage.learn_more_link)
    if (!_internal_has_learn_more_link()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.learn_more_link_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.learn_more_link_.IsDefault()) {
        _impl_.learn_more_link_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void MatchedUrlNavigationRule_CustomMessage::set_allocated_learn_more_link(std::string* learn_more_link)
{
    if (learn_more_link != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.learn_more_link_.SetAllocated(learn_more_link, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.learn_more_link_.IsDefault()) {
        _impl_.learn_more_link_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.MatchedUrlNavigationRule.CustomMessage.learn_more_link)
}

// optional string custom_message_with_links = 3 [deprecated = true];
inline bool MatchedUrlNavigationRule_CustomMessage::_internal_has_custom_message_with_links() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool MatchedUrlNavigationRule_CustomMessage::has_custom_message_with_links() const
{
    return _internal_has_custom_message_with_links();
}
inline void MatchedUrlNavigationRule_CustomMessage::clear_custom_message_with_links()
{
    _impl_.custom_message_with_links_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MatchedUrlNavigationRule_CustomMessage::custom_message_with_links() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.CustomMessage.custom_message_with_links)
    return _internal_custom_message_with_links();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void MatchedUrlNavigationRule_CustomMessage::set_custom_message_with_links(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.custom_message_with_links_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.MatchedUrlNavigationRule.CustomMessage.custom_message_with_links)
}
inline std::string* MatchedUrlNavigationRule_CustomMessage::mutable_custom_message_with_links()
{
    std::string* _s = _internal_mutable_custom_message_with_links();
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.CustomMessage.custom_message_with_links)
    return _s;
}
inline const std::string& MatchedUrlNavigationRule_CustomMessage::_internal_custom_message_with_links() const
{
    return _impl_.custom_message_with_links_.Get();
}
inline void MatchedUrlNavigationRule_CustomMessage::_internal_set_custom_message_with_links(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.custom_message_with_links_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_CustomMessage::_internal_mutable_custom_message_with_links()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.custom_message_with_links_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_CustomMessage::release_custom_message_with_links()
{
    // @@protoc_insertion_point(field_release:safe_browsing.MatchedUrlNavigationRule.CustomMessage.custom_message_with_links)
    if (!_internal_has_custom_message_with_links()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.custom_message_with_links_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.custom_message_with_links_.IsDefault()) {
        _impl_.custom_message_with_links_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void MatchedUrlNavigationRule_CustomMessage::set_allocated_custom_message_with_links(std::string* custom_message_with_links)
{
    if (custom_message_with_links != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.custom_message_with_links_.SetAllocated(custom_message_with_links, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.custom_message_with_links_.IsDefault()) {
        _impl_.custom_message_with_links_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.MatchedUrlNavigationRule.CustomMessage.custom_message_with_links)
}

// repeated .safe_browsing.MatchedUrlNavigationRule.CustomRuleMessageSegment message_segments = 4;
inline int MatchedUrlNavigationRule_CustomMessage::_internal_message_segments_size() const
{
    return _impl_.message_segments_.size();
}
inline int MatchedUrlNavigationRule_CustomMessage::message_segments_size() const
{
    return _internal_message_segments_size();
}
inline void MatchedUrlNavigationRule_CustomMessage::clear_message_segments()
{
    _impl_.message_segments_.Clear();
}
inline ::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment* MatchedUrlNavigationRule_CustomMessage::mutable_message_segments(int index)
{
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.CustomMessage.message_segments)
    return _impl_.message_segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment>*
MatchedUrlNavigationRule_CustomMessage::mutable_message_segments()
{
    // @@protoc_insertion_point(field_mutable_list:safe_browsing.MatchedUrlNavigationRule.CustomMessage.message_segments)
    return &_impl_.message_segments_;
}
inline const ::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment& MatchedUrlNavigationRule_CustomMessage::_internal_message_segments(
    int index) const
{
    return _impl_.message_segments_.Get(index);
}
inline const ::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment& MatchedUrlNavigationRule_CustomMessage::message_segments(int index) const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.CustomMessage.message_segments)
    return _internal_message_segments(index);
}
inline ::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment* MatchedUrlNavigationRule_CustomMessage::_internal_add_message_segments()
{
    return _impl_.message_segments_.Add();
}
inline ::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment* MatchedUrlNavigationRule_CustomMessage::add_message_segments()
{
    ::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment* _add = _internal_add_message_segments();
    // @@protoc_insertion_point(field_add:safe_browsing.MatchedUrlNavigationRule.CustomMessage.message_segments)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::safe_browsing::MatchedUrlNavigationRule_CustomRuleMessageSegment>&
MatchedUrlNavigationRule_CustomMessage::message_segments() const
{
    // @@protoc_insertion_point(field_list:safe_browsing.MatchedUrlNavigationRule.CustomMessage.message_segments)
    return _impl_.message_segments_;
}

// -------------------------------------------------------------------

// MatchedUrlNavigationRule_WatermarkMessage

// optional string watermark_message = 1;
inline bool MatchedUrlNavigationRule_WatermarkMessage::_internal_has_watermark_message() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool MatchedUrlNavigationRule_WatermarkMessage::has_watermark_message() const
{
    return _internal_has_watermark_message();
}
inline void MatchedUrlNavigationRule_WatermarkMessage::clear_watermark_message()
{
    _impl_.watermark_message_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MatchedUrlNavigationRule_WatermarkMessage::watermark_message() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.watermark_message)
    return _internal_watermark_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void MatchedUrlNavigationRule_WatermarkMessage::set_watermark_message(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.watermark_message_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.watermark_message)
}
inline std::string* MatchedUrlNavigationRule_WatermarkMessage::mutable_watermark_message()
{
    std::string* _s = _internal_mutable_watermark_message();
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.watermark_message)
    return _s;
}
inline const std::string& MatchedUrlNavigationRule_WatermarkMessage::_internal_watermark_message() const
{
    return _impl_.watermark_message_.Get();
}
inline void MatchedUrlNavigationRule_WatermarkMessage::_internal_set_watermark_message(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.watermark_message_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_WatermarkMessage::_internal_mutable_watermark_message()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.watermark_message_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_WatermarkMessage::release_watermark_message()
{
    // @@protoc_insertion_point(field_release:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.watermark_message)
    if (!_internal_has_watermark_message()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.watermark_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.watermark_message_.IsDefault()) {
        _impl_.watermark_message_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void MatchedUrlNavigationRule_WatermarkMessage::set_allocated_watermark_message(std::string* watermark_message)
{
    if (watermark_message != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.watermark_message_.SetAllocated(watermark_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.watermark_message_.IsDefault()) {
        _impl_.watermark_message_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.watermark_message)
}

// optional string user_email = 2;
inline bool MatchedUrlNavigationRule_WatermarkMessage::_internal_has_user_email() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool MatchedUrlNavigationRule_WatermarkMessage::has_user_email() const
{
    return _internal_has_user_email();
}
inline void MatchedUrlNavigationRule_WatermarkMessage::clear_user_email()
{
    _impl_.user_email_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MatchedUrlNavigationRule_WatermarkMessage::user_email() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.user_email)
    return _internal_user_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void MatchedUrlNavigationRule_WatermarkMessage::set_user_email(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.user_email_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.user_email)
}
inline std::string* MatchedUrlNavigationRule_WatermarkMessage::mutable_user_email()
{
    std::string* _s = _internal_mutable_user_email();
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.user_email)
    return _s;
}
inline const std::string& MatchedUrlNavigationRule_WatermarkMessage::_internal_user_email() const
{
    return _impl_.user_email_.Get();
}
inline void MatchedUrlNavigationRule_WatermarkMessage::_internal_set_user_email(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.user_email_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_WatermarkMessage::_internal_mutable_user_email()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.user_email_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_WatermarkMessage::release_user_email()
{
    // @@protoc_insertion_point(field_release:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.user_email)
    if (!_internal_has_user_email()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.user_email_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.user_email_.IsDefault()) {
        _impl_.user_email_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void MatchedUrlNavigationRule_WatermarkMessage::set_allocated_user_email(std::string* user_email)
{
    if (user_email != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.user_email_.SetAllocated(user_email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.user_email_.IsDefault()) {
        _impl_.user_email_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.user_email)
}

// optional string obfuscated_device_id = 3;
inline bool MatchedUrlNavigationRule_WatermarkMessage::_internal_has_obfuscated_device_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool MatchedUrlNavigationRule_WatermarkMessage::has_obfuscated_device_id() const
{
    return _internal_has_obfuscated_device_id();
}
inline void MatchedUrlNavigationRule_WatermarkMessage::clear_obfuscated_device_id()
{
    _impl_.obfuscated_device_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MatchedUrlNavigationRule_WatermarkMessage::obfuscated_device_id() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.obfuscated_device_id)
    return _internal_obfuscated_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void MatchedUrlNavigationRule_WatermarkMessage::set_obfuscated_device_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.obfuscated_device_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.obfuscated_device_id)
}
inline std::string* MatchedUrlNavigationRule_WatermarkMessage::mutable_obfuscated_device_id()
{
    std::string* _s = _internal_mutable_obfuscated_device_id();
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.obfuscated_device_id)
    return _s;
}
inline const std::string& MatchedUrlNavigationRule_WatermarkMessage::_internal_obfuscated_device_id() const
{
    return _impl_.obfuscated_device_id_.Get();
}
inline void MatchedUrlNavigationRule_WatermarkMessage::_internal_set_obfuscated_device_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.obfuscated_device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_WatermarkMessage::_internal_mutable_obfuscated_device_id()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.obfuscated_device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule_WatermarkMessage::release_obfuscated_device_id()
{
    // @@protoc_insertion_point(field_release:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.obfuscated_device_id)
    if (!_internal_has_obfuscated_device_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.obfuscated_device_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.obfuscated_device_id_.IsDefault()) {
        _impl_.obfuscated_device_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void MatchedUrlNavigationRule_WatermarkMessage::set_allocated_obfuscated_device_id(std::string* obfuscated_device_id)
{
    if (obfuscated_device_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.obfuscated_device_id_.SetAllocated(obfuscated_device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.obfuscated_device_id_.IsDefault()) {
        _impl_.obfuscated_device_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.obfuscated_device_id)
}

// optional .safe_browsing.Timestamp timestamp = 4;
inline bool MatchedUrlNavigationRule_WatermarkMessage::_internal_has_timestamp() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.timestamp_ != nullptr);
    return value;
}
inline bool MatchedUrlNavigationRule_WatermarkMessage::has_timestamp() const
{
    return _internal_has_timestamp();
}
inline void MatchedUrlNavigationRule_WatermarkMessage::clear_timestamp()
{
    if (_impl_.timestamp_ != nullptr)
        _impl_.timestamp_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::safe_browsing::Timestamp& MatchedUrlNavigationRule_WatermarkMessage::_internal_timestamp() const
{
    const ::safe_browsing::Timestamp* p = _impl_.timestamp_;
    return p != nullptr ? *p : reinterpret_cast<const ::safe_browsing::Timestamp&>(::safe_browsing::_Timestamp_default_instance_);
}
inline const ::safe_browsing::Timestamp& MatchedUrlNavigationRule_WatermarkMessage::timestamp() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.timestamp)
    return _internal_timestamp();
}
inline void MatchedUrlNavigationRule_WatermarkMessage::unsafe_arena_set_allocated_timestamp(::safe_browsing::Timestamp* timestamp)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
    }
    _impl_.timestamp_ = timestamp;
    if (timestamp) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.timestamp)
}
inline ::safe_browsing::Timestamp* MatchedUrlNavigationRule_WatermarkMessage::release_timestamp()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::safe_browsing::Timestamp* temp = _impl_.timestamp_;
    _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::safe_browsing::Timestamp* MatchedUrlNavigationRule_WatermarkMessage::unsafe_arena_release_timestamp()
{
    // @@protoc_insertion_point(field_release:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.timestamp)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::safe_browsing::Timestamp* temp = _impl_.timestamp_;
    _impl_.timestamp_ = nullptr;
    return temp;
}
inline ::safe_browsing::Timestamp* MatchedUrlNavigationRule_WatermarkMessage::_internal_mutable_timestamp()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.timestamp_ == nullptr) {
        auto* p = CreateMaybeMessage<::safe_browsing::Timestamp>(GetArenaForAllocation());
        _impl_.timestamp_ = p;
    }
    return _impl_.timestamp_;
}
inline ::safe_browsing::Timestamp* MatchedUrlNavigationRule_WatermarkMessage::mutable_timestamp()
{
    ::safe_browsing::Timestamp* _msg = _internal_mutable_timestamp();
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.timestamp)
    return _msg;
}
inline void MatchedUrlNavigationRule_WatermarkMessage::set_allocated_timestamp(::safe_browsing::Timestamp* timestamp)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.timestamp_;
    }
    if (timestamp) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timestamp);
        if (message_arena != submessage_arena) {
            timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, timestamp, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.timestamp_ = timestamp;
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.MatchedUrlNavigationRule.WatermarkMessage.timestamp)
}

// -------------------------------------------------------------------

// MatchedUrlNavigationRule

// optional string rule_id = 1;
inline bool MatchedUrlNavigationRule::_internal_has_rule_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool MatchedUrlNavigationRule::has_rule_id() const
{
    return _internal_has_rule_id();
}
inline void MatchedUrlNavigationRule::clear_rule_id()
{
    _impl_.rule_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MatchedUrlNavigationRule::rule_id() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.rule_id)
    return _internal_rule_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void MatchedUrlNavigationRule::set_rule_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.rule_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.MatchedUrlNavigationRule.rule_id)
}
inline std::string* MatchedUrlNavigationRule::mutable_rule_id()
{
    std::string* _s = _internal_mutable_rule_id();
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.rule_id)
    return _s;
}
inline const std::string& MatchedUrlNavigationRule::_internal_rule_id() const
{
    return _impl_.rule_id_.Get();
}
inline void MatchedUrlNavigationRule::_internal_set_rule_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.rule_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule::_internal_mutable_rule_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.rule_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule::release_rule_id()
{
    // @@protoc_insertion_point(field_release:safe_browsing.MatchedUrlNavigationRule.rule_id)
    if (!_internal_has_rule_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.rule_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.rule_id_.IsDefault()) {
        _impl_.rule_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void MatchedUrlNavigationRule::set_allocated_rule_id(std::string* rule_id)
{
    if (rule_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.rule_id_.SetAllocated(rule_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.rule_id_.IsDefault()) {
        _impl_.rule_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.MatchedUrlNavigationRule.rule_id)
}

// optional string rule_name = 2;
inline bool MatchedUrlNavigationRule::_internal_has_rule_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool MatchedUrlNavigationRule::has_rule_name() const
{
    return _internal_has_rule_name();
}
inline void MatchedUrlNavigationRule::clear_rule_name()
{
    _impl_.rule_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MatchedUrlNavigationRule::rule_name() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.rule_name)
    return _internal_rule_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void MatchedUrlNavigationRule::set_rule_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.rule_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.MatchedUrlNavigationRule.rule_name)
}
inline std::string* MatchedUrlNavigationRule::mutable_rule_name()
{
    std::string* _s = _internal_mutable_rule_name();
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.rule_name)
    return _s;
}
inline const std::string& MatchedUrlNavigationRule::_internal_rule_name() const
{
    return _impl_.rule_name_.Get();
}
inline void MatchedUrlNavigationRule::_internal_set_rule_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.rule_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule::_internal_mutable_rule_name()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.rule_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule::release_rule_name()
{
    // @@protoc_insertion_point(field_release:safe_browsing.MatchedUrlNavigationRule.rule_name)
    if (!_internal_has_rule_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.rule_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.rule_name_.IsDefault()) {
        _impl_.rule_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void MatchedUrlNavigationRule::set_allocated_rule_name(std::string* rule_name)
{
    if (rule_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.rule_name_.SetAllocated(rule_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.rule_name_.IsDefault()) {
        _impl_.rule_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.MatchedUrlNavigationRule.rule_name)
}

// optional string matched_url_category = 3;
inline bool MatchedUrlNavigationRule::_internal_has_matched_url_category() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool MatchedUrlNavigationRule::has_matched_url_category() const
{
    return _internal_has_matched_url_category();
}
inline void MatchedUrlNavigationRule::clear_matched_url_category()
{
    _impl_.matched_url_category_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MatchedUrlNavigationRule::matched_url_category() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.matched_url_category)
    return _internal_matched_url_category();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void MatchedUrlNavigationRule::set_matched_url_category(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.matched_url_category_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:safe_browsing.MatchedUrlNavigationRule.matched_url_category)
}
inline std::string* MatchedUrlNavigationRule::mutable_matched_url_category()
{
    std::string* _s = _internal_mutable_matched_url_category();
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.matched_url_category)
    return _s;
}
inline const std::string& MatchedUrlNavigationRule::_internal_matched_url_category() const
{
    return _impl_.matched_url_category_.Get();
}
inline void MatchedUrlNavigationRule::_internal_set_matched_url_category(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.matched_url_category_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule::_internal_mutable_matched_url_category()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.matched_url_category_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchedUrlNavigationRule::release_matched_url_category()
{
    // @@protoc_insertion_point(field_release:safe_browsing.MatchedUrlNavigationRule.matched_url_category)
    if (!_internal_has_matched_url_category()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.matched_url_category_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.matched_url_category_.IsDefault()) {
        _impl_.matched_url_category_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void MatchedUrlNavigationRule::set_allocated_matched_url_category(std::string* matched_url_category)
{
    if (matched_url_category != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.matched_url_category_.SetAllocated(matched_url_category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.matched_url_category_.IsDefault()) {
        _impl_.matched_url_category_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.MatchedUrlNavigationRule.matched_url_category)
}

// optional .safe_browsing.MatchedUrlNavigationRule.CustomMessage custom_message = 5;
inline bool MatchedUrlNavigationRule::_internal_has_custom_message() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.custom_message_ != nullptr);
    return value;
}
inline bool MatchedUrlNavigationRule::has_custom_message() const
{
    return _internal_has_custom_message();
}
inline void MatchedUrlNavigationRule::clear_custom_message()
{
    if (_impl_.custom_message_ != nullptr)
        _impl_.custom_message_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::safe_browsing::MatchedUrlNavigationRule_CustomMessage& MatchedUrlNavigationRule::_internal_custom_message() const
{
    const ::safe_browsing::MatchedUrlNavigationRule_CustomMessage* p = _impl_.custom_message_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::safe_browsing::MatchedUrlNavigationRule_CustomMessage&>(
                            ::safe_browsing::_MatchedUrlNavigationRule_CustomMessage_default_instance_);
}
inline const ::safe_browsing::MatchedUrlNavigationRule_CustomMessage& MatchedUrlNavigationRule::custom_message() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.custom_message)
    return _internal_custom_message();
}
inline void MatchedUrlNavigationRule::unsafe_arena_set_allocated_custom_message(::safe_browsing::MatchedUrlNavigationRule_CustomMessage* custom_message)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.custom_message_);
    }
    _impl_.custom_message_ = custom_message;
    if (custom_message) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.MatchedUrlNavigationRule.custom_message)
}
inline ::safe_browsing::MatchedUrlNavigationRule_CustomMessage* MatchedUrlNavigationRule::release_custom_message()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::safe_browsing::MatchedUrlNavigationRule_CustomMessage* temp = _impl_.custom_message_;
    _impl_.custom_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::safe_browsing::MatchedUrlNavigationRule_CustomMessage* MatchedUrlNavigationRule::unsafe_arena_release_custom_message()
{
    // @@protoc_insertion_point(field_release:safe_browsing.MatchedUrlNavigationRule.custom_message)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::safe_browsing::MatchedUrlNavigationRule_CustomMessage* temp = _impl_.custom_message_;
    _impl_.custom_message_ = nullptr;
    return temp;
}
inline ::safe_browsing::MatchedUrlNavigationRule_CustomMessage* MatchedUrlNavigationRule::_internal_mutable_custom_message()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.custom_message_ == nullptr) {
        auto* p = CreateMaybeMessage<::safe_browsing::MatchedUrlNavigationRule_CustomMessage>(GetArenaForAllocation());
        _impl_.custom_message_ = p;
    }
    return _impl_.custom_message_;
}
inline ::safe_browsing::MatchedUrlNavigationRule_CustomMessage* MatchedUrlNavigationRule::mutable_custom_message()
{
    ::safe_browsing::MatchedUrlNavigationRule_CustomMessage* _msg = _internal_mutable_custom_message();
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.custom_message)
    return _msg;
}
inline void MatchedUrlNavigationRule::set_allocated_custom_message(::safe_browsing::MatchedUrlNavigationRule_CustomMessage* custom_message)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.custom_message_;
    }
    if (custom_message) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(custom_message);
        if (message_arena != submessage_arena) {
            custom_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, custom_message, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.custom_message_ = custom_message;
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.MatchedUrlNavigationRule.custom_message)
}

// optional .safe_browsing.MatchedUrlNavigationRule.WatermarkMessage watermark_message = 6;
inline bool MatchedUrlNavigationRule::_internal_has_watermark_message() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.watermark_message_ != nullptr);
    return value;
}
inline bool MatchedUrlNavigationRule::has_watermark_message() const
{
    return _internal_has_watermark_message();
}
inline void MatchedUrlNavigationRule::clear_watermark_message()
{
    if (_impl_.watermark_message_ != nullptr)
        _impl_.watermark_message_->Clear();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage& MatchedUrlNavigationRule::_internal_watermark_message() const
{
    const ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* p = _impl_.watermark_message_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage&>(
                            ::safe_browsing::_MatchedUrlNavigationRule_WatermarkMessage_default_instance_);
}
inline const ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage& MatchedUrlNavigationRule::watermark_message() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.watermark_message)
    return _internal_watermark_message();
}
inline void MatchedUrlNavigationRule::unsafe_arena_set_allocated_watermark_message(
    ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* watermark_message)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.watermark_message_);
    }
    _impl_.watermark_message_ = watermark_message;
    if (watermark_message) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safe_browsing.MatchedUrlNavigationRule.watermark_message)
}
inline ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* MatchedUrlNavigationRule::release_watermark_message()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* temp = _impl_.watermark_message_;
    _impl_.watermark_message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* MatchedUrlNavigationRule::unsafe_arena_release_watermark_message()
{
    // @@protoc_insertion_point(field_release:safe_browsing.MatchedUrlNavigationRule.watermark_message)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* temp = _impl_.watermark_message_;
    _impl_.watermark_message_ = nullptr;
    return temp;
}
inline ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* MatchedUrlNavigationRule::_internal_mutable_watermark_message()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.watermark_message_ == nullptr) {
        auto* p = CreateMaybeMessage<::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage>(GetArenaForAllocation());
        _impl_.watermark_message_ = p;
    }
    return _impl_.watermark_message_;
}
inline ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* MatchedUrlNavigationRule::mutable_watermark_message()
{
    ::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* _msg = _internal_mutable_watermark_message();
    // @@protoc_insertion_point(field_mutable:safe_browsing.MatchedUrlNavigationRule.watermark_message)
    return _msg;
}
inline void MatchedUrlNavigationRule::set_allocated_watermark_message(::safe_browsing::MatchedUrlNavigationRule_WatermarkMessage* watermark_message)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.watermark_message_;
    }
    if (watermark_message) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(watermark_message);
        if (message_arena != submessage_arena) {
            watermark_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, watermark_message, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.watermark_message_ = watermark_message;
    // @@protoc_insertion_point(field_set_allocated:safe_browsing.MatchedUrlNavigationRule.watermark_message)
}

// optional bool block_screenshot = 8;
inline bool MatchedUrlNavigationRule::_internal_has_block_screenshot() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool MatchedUrlNavigationRule::has_block_screenshot() const
{
    return _internal_has_block_screenshot();
}
inline void MatchedUrlNavigationRule::clear_block_screenshot()
{
    _impl_.block_screenshot_ = false;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool MatchedUrlNavigationRule::_internal_block_screenshot() const
{
    return _impl_.block_screenshot_;
}
inline bool MatchedUrlNavigationRule::block_screenshot() const
{
    // @@protoc_insertion_point(field_get:safe_browsing.MatchedUrlNavigationRule.block_screenshot)
    return _internal_block_screenshot();
}
inline void MatchedUrlNavigationRule::_internal_set_block_screenshot(bool value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.block_screenshot_ = value;
}
inline void MatchedUrlNavigationRule::set_block_screenshot(bool value)
{
    _internal_set_block_screenshot(value);
    // @@protoc_insertion_point(field_set:safe_browsing.MatchedUrlNavigationRule.block_screenshot)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace safe_browsing

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::safe_browsing::RTLookupRequest_LookupType> : ::std::true_type { };
template <> struct is_proto_enum<::safe_browsing::RTLookupRequest_OSType> : ::std::true_type { };
template <> struct is_proto_enum<::safe_browsing::RTLookupRequest_ReportType> : ::std::true_type { };
template <> struct is_proto_enum<::safe_browsing::RTLookupRequest_FrameType> : ::std::true_type { };
template <> struct is_proto_enum<::safe_browsing::RTLookupResponse_ThreatInfo_ThreatType> : ::std::true_type { };
template <> struct is_proto_enum<::safe_browsing::RTLookupResponse_ThreatInfo_VerdictType> : ::std::true_type { };
template <> struct is_proto_enum<::safe_browsing::RTLookupResponse_ThreatInfo_CacheExpressionMatchType> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fsafe_5fbrowsing_2fcore_2fcommon_2fproto_2frealtimeapi_2eproto
