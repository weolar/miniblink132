// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: download_file_types.proto

#include "download_file_types.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace safe_browsing {
PROTOBUF_CONSTEXPR DownloadFileType_PlatformSettings::DownloadFileType_PlatformSettings(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.platform_)*/ 0,
        /*decltype(_impl_.danger_level_)*/ 0, /*decltype(_impl_.file_weight_)*/ int64_t { 0 }, /*decltype(_impl_.auto_open_hint_)*/ 0,
        /*decltype(_impl_.max_file_size_to_analyze_)*/ uint64_t { 18446744073709551615u } }
{
}
struct DownloadFileType_PlatformSettingsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DownloadFileType_PlatformSettingsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DownloadFileType_PlatformSettingsDefaultTypeInternal()
    {
    }
    union {
        DownloadFileType_PlatformSettings _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownloadFileType_PlatformSettingsDefaultTypeInternal
    _DownloadFileType_PlatformSettings_default_instance_;
PROTOBUF_CONSTEXPR DownloadFileType::DownloadFileType(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.platform_settings_)*/ {},
        /*decltype(_impl_.extension_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.uma_value_)*/ int64_t { 0 },
        /*decltype(_impl_.is_archive_)*/ false, /*decltype(_impl_.ping_setting_)*/ 0, /*decltype(_impl_.inspection_type_)*/ 0 }
{
}
struct DownloadFileTypeDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DownloadFileTypeDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DownloadFileTypeDefaultTypeInternal()
    {
    }
    union {
        DownloadFileType _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownloadFileTypeDefaultTypeInternal _DownloadFileType_default_instance_;
PROTOBUF_CONSTEXPR DownloadFileTypeConfig::DownloadFileTypeConfig(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.file_types_)*/ {},
        /*decltype(_impl_.default_file_type_)*/ nullptr, /*decltype(_impl_.version_id_)*/ 0u, /*decltype(_impl_.sampled_ping_probability_)*/ 0,
        /*decltype(_impl_.max_archived_binaries_to_report_)*/ uint64_t { 0u } }
{
}
struct DownloadFileTypeConfigDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DownloadFileTypeConfigDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DownloadFileTypeConfigDefaultTypeInternal()
    {
    }
    union {
        DownloadFileTypeConfig _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownloadFileTypeConfigDefaultTypeInternal
    _DownloadFileTypeConfig_default_instance_;
} // namespace safe_browsing
namespace safe_browsing {
bool DownloadFileType_PingSetting_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DownloadFileType_PingSetting_strings[3] = {};

static const char DownloadFileType_PingSetting_names[] = "FULL_PING"
                                                         "NO_PING"
                                                         "SAMPLED_PING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DownloadFileType_PingSetting_entries[] = {
    { { DownloadFileType_PingSetting_names + 0, 9 }, 2 },
    { { DownloadFileType_PingSetting_names + 9, 7 }, 1 },
    { { DownloadFileType_PingSetting_names + 16, 12 }, 0 },
};

static const int DownloadFileType_PingSetting_entries_by_number[] = {
    2, // 0 -> SAMPLED_PING
    1, // 1 -> NO_PING
    0, // 2 -> FULL_PING
};

const std::string& DownloadFileType_PingSetting_Name(DownloadFileType_PingSetting value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        DownloadFileType_PingSetting_entries, DownloadFileType_PingSetting_entries_by_number, 3, DownloadFileType_PingSetting_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(DownloadFileType_PingSetting_entries, DownloadFileType_PingSetting_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : DownloadFileType_PingSetting_strings[idx].get();
}
bool DownloadFileType_PingSetting_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DownloadFileType_PingSetting* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(DownloadFileType_PingSetting_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<DownloadFileType_PingSetting>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DownloadFileType_PingSetting DownloadFileType::SAMPLED_PING;
constexpr DownloadFileType_PingSetting DownloadFileType::NO_PING;
constexpr DownloadFileType_PingSetting DownloadFileType::FULL_PING;
constexpr DownloadFileType_PingSetting DownloadFileType::PingSetting_MIN;
constexpr DownloadFileType_PingSetting DownloadFileType::PingSetting_MAX;
constexpr int DownloadFileType::PingSetting_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DownloadFileType_DangerLevel_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DownloadFileType_DangerLevel_strings[3] = {};

static const char DownloadFileType_DangerLevel_names[] = "ALLOW_ON_USER_GESTURE"
                                                         "DANGEROUS"
                                                         "NOT_DANGEROUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DownloadFileType_DangerLevel_entries[] = {
    { { DownloadFileType_DangerLevel_names + 0, 21 }, 1 },
    { { DownloadFileType_DangerLevel_names + 21, 9 }, 2 },
    { { DownloadFileType_DangerLevel_names + 30, 13 }, 0 },
};

static const int DownloadFileType_DangerLevel_entries_by_number[] = {
    2, // 0 -> NOT_DANGEROUS
    0, // 1 -> ALLOW_ON_USER_GESTURE
    1, // 2 -> DANGEROUS
};

const std::string& DownloadFileType_DangerLevel_Name(DownloadFileType_DangerLevel value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        DownloadFileType_DangerLevel_entries, DownloadFileType_DangerLevel_entries_by_number, 3, DownloadFileType_DangerLevel_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(DownloadFileType_DangerLevel_entries, DownloadFileType_DangerLevel_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : DownloadFileType_DangerLevel_strings[idx].get();
}
bool DownloadFileType_DangerLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DownloadFileType_DangerLevel* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(DownloadFileType_DangerLevel_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<DownloadFileType_DangerLevel>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DownloadFileType_DangerLevel DownloadFileType::NOT_DANGEROUS;
constexpr DownloadFileType_DangerLevel DownloadFileType::ALLOW_ON_USER_GESTURE;
constexpr DownloadFileType_DangerLevel DownloadFileType::DANGEROUS;
constexpr DownloadFileType_DangerLevel DownloadFileType::DangerLevel_MIN;
constexpr DownloadFileType_DangerLevel DownloadFileType::DangerLevel_MAX;
constexpr int DownloadFileType::DangerLevel_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DownloadFileType_AutoOpenHint_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DownloadFileType_AutoOpenHint_strings[2] = {};

static const char DownloadFileType_AutoOpenHint_names[] = "ALLOW_AUTO_OPEN"
                                                          "DISALLOW_AUTO_OPEN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DownloadFileType_AutoOpenHint_entries[] = {
    { { DownloadFileType_AutoOpenHint_names + 0, 15 }, 1 },
    { { DownloadFileType_AutoOpenHint_names + 15, 18 }, 0 },
};

static const int DownloadFileType_AutoOpenHint_entries_by_number[] = {
    1, // 0 -> DISALLOW_AUTO_OPEN
    0, // 1 -> ALLOW_AUTO_OPEN
};

const std::string& DownloadFileType_AutoOpenHint_Name(DownloadFileType_AutoOpenHint value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        DownloadFileType_AutoOpenHint_entries, DownloadFileType_AutoOpenHint_entries_by_number, 2, DownloadFileType_AutoOpenHint_strings);
    (void)dummy;
    int idx
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(DownloadFileType_AutoOpenHint_entries, DownloadFileType_AutoOpenHint_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : DownloadFileType_AutoOpenHint_strings[idx].get();
}
bool DownloadFileType_AutoOpenHint_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DownloadFileType_AutoOpenHint* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(DownloadFileType_AutoOpenHint_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<DownloadFileType_AutoOpenHint>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DownloadFileType_AutoOpenHint DownloadFileType::DISALLOW_AUTO_OPEN;
constexpr DownloadFileType_AutoOpenHint DownloadFileType::ALLOW_AUTO_OPEN;
constexpr DownloadFileType_AutoOpenHint DownloadFileType::AutoOpenHint_MIN;
constexpr DownloadFileType_AutoOpenHint DownloadFileType::AutoOpenHint_MAX;
constexpr int DownloadFileType::AutoOpenHint_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DownloadFileType_PlatformType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DownloadFileType_PlatformType_strings[6] = {};

static const char DownloadFileType_PlatformType_names[] = "PLATFORM_TYPE_ANDROID"
                                                          "PLATFORM_TYPE_ANY"
                                                          "PLATFORM_TYPE_CHROME_OS"
                                                          "PLATFORM_TYPE_LINUX"
                                                          "PLATFORM_TYPE_MAC"
                                                          "PLATFORM_TYPE_WINDOWS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DownloadFileType_PlatformType_entries[] = {
    { { DownloadFileType_PlatformType_names + 0, 21 }, 1 },
    { { DownloadFileType_PlatformType_names + 21, 17 }, 0 },
    { { DownloadFileType_PlatformType_names + 38, 23 }, 2 },
    { { DownloadFileType_PlatformType_names + 61, 19 }, 3 },
    { { DownloadFileType_PlatformType_names + 80, 17 }, 4 },
    { { DownloadFileType_PlatformType_names + 97, 21 }, 5 },
};

static const int DownloadFileType_PlatformType_entries_by_number[] = {
    1, // 0 -> PLATFORM_TYPE_ANY
    0, // 1 -> PLATFORM_TYPE_ANDROID
    2, // 2 -> PLATFORM_TYPE_CHROME_OS
    3, // 3 -> PLATFORM_TYPE_LINUX
    4, // 4 -> PLATFORM_TYPE_MAC
    5, // 5 -> PLATFORM_TYPE_WINDOWS
};

const std::string& DownloadFileType_PlatformType_Name(DownloadFileType_PlatformType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        DownloadFileType_PlatformType_entries, DownloadFileType_PlatformType_entries_by_number, 6, DownloadFileType_PlatformType_strings);
    (void)dummy;
    int idx
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(DownloadFileType_PlatformType_entries, DownloadFileType_PlatformType_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : DownloadFileType_PlatformType_strings[idx].get();
}
bool DownloadFileType_PlatformType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DownloadFileType_PlatformType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(DownloadFileType_PlatformType_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<DownloadFileType_PlatformType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DownloadFileType_PlatformType DownloadFileType::PLATFORM_TYPE_ANY;
constexpr DownloadFileType_PlatformType DownloadFileType::PLATFORM_TYPE_ANDROID;
constexpr DownloadFileType_PlatformType DownloadFileType::PLATFORM_TYPE_CHROME_OS;
constexpr DownloadFileType_PlatformType DownloadFileType::PLATFORM_TYPE_LINUX;
constexpr DownloadFileType_PlatformType DownloadFileType::PLATFORM_TYPE_MAC;
constexpr DownloadFileType_PlatformType DownloadFileType::PLATFORM_TYPE_WINDOWS;
constexpr DownloadFileType_PlatformType DownloadFileType::PlatformType_MIN;
constexpr DownloadFileType_PlatformType DownloadFileType::PlatformType_MAX;
constexpr int DownloadFileType::PlatformType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DownloadFileType_InspectionType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DownloadFileType_InspectionType_strings[5] = {};

static const char DownloadFileType_InspectionType_names[] = "DMG"
                                                            "NONE"
                                                            "RAR"
                                                            "SEVEN_ZIP"
                                                            "ZIP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DownloadFileType_InspectionType_entries[] = {
    { { DownloadFileType_InspectionType_names + 0, 3 }, 3 },
    { { DownloadFileType_InspectionType_names + 3, 4 }, 0 },
    { { DownloadFileType_InspectionType_names + 7, 3 }, 2 },
    { { DownloadFileType_InspectionType_names + 10, 9 }, 5 },
    { { DownloadFileType_InspectionType_names + 19, 3 }, 1 },
};

static const int DownloadFileType_InspectionType_entries_by_number[] = {
    1, // 0 -> NONE
    4, // 1 -> ZIP
    2, // 2 -> RAR
    0, // 3 -> DMG
    3, // 5 -> SEVEN_ZIP
};

const std::string& DownloadFileType_InspectionType_Name(DownloadFileType_InspectionType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        DownloadFileType_InspectionType_entries, DownloadFileType_InspectionType_entries_by_number, 5, DownloadFileType_InspectionType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        DownloadFileType_InspectionType_entries, DownloadFileType_InspectionType_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : DownloadFileType_InspectionType_strings[idx].get();
}
bool DownloadFileType_InspectionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DownloadFileType_InspectionType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(DownloadFileType_InspectionType_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<DownloadFileType_InspectionType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DownloadFileType_InspectionType DownloadFileType::NONE;
constexpr DownloadFileType_InspectionType DownloadFileType::ZIP;
constexpr DownloadFileType_InspectionType DownloadFileType::RAR;
constexpr DownloadFileType_InspectionType DownloadFileType::DMG;
constexpr DownloadFileType_InspectionType DownloadFileType::SEVEN_ZIP;
constexpr DownloadFileType_InspectionType DownloadFileType::InspectionType_MIN;
constexpr DownloadFileType_InspectionType DownloadFileType::InspectionType_MAX;
constexpr int DownloadFileType::InspectionType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class DownloadFileType_PlatformSettings::_Internal {
public:
    using HasBits = decltype(std::declval<DownloadFileType_PlatformSettings>()._impl_._has_bits_);
    static void set_has_platform(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_danger_level(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_auto_open_hint(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_max_file_size_to_analyze(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_file_weight(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

DownloadFileType_PlatformSettings::DownloadFileType_PlatformSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.DownloadFileType.PlatformSettings)
}
DownloadFileType_PlatformSettings::DownloadFileType_PlatformSettings(const DownloadFileType_PlatformSettings& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DownloadFileType_PlatformSettings* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.platform_) {},
        decltype(_impl_.danger_level_) {}, decltype(_impl_.file_weight_) {}, decltype(_impl_.auto_open_hint_) {},
        decltype(_impl_.max_file_size_to_analyze_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.platform_, &from._impl_.platform_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_file_size_to_analyze_) - reinterpret_cast<char*>(&_impl_.platform_))
            + sizeof(_impl_.max_file_size_to_analyze_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.DownloadFileType.PlatformSettings)
}

inline void DownloadFileType_PlatformSettings::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.platform_) { 0 },
        decltype(_impl_.danger_level_) { 0 }, decltype(_impl_.file_weight_) { int64_t { 0 } }, decltype(_impl_.auto_open_hint_) { 0 },
        decltype(_impl_.max_file_size_to_analyze_) { uint64_t { 18446744073709551615u } } };
}

DownloadFileType_PlatformSettings::~DownloadFileType_PlatformSettings()
{
    // @@protoc_insertion_point(destructor:safe_browsing.DownloadFileType.PlatformSettings)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DownloadFileType_PlatformSettings::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DownloadFileType_PlatformSettings::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DownloadFileType_PlatformSettings::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.DownloadFileType.PlatformSettings)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        ::memset(&_impl_.platform_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.auto_open_hint_) - reinterpret_cast<char*>(&_impl_.platform_))
                + sizeof(_impl_.auto_open_hint_));
        _impl_.max_file_size_to_analyze_ = uint64_t { 18446744073709551615u };
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DownloadFileType_PlatformSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .safe_browsing.DownloadFileType.PlatformType platform = 1 [default = PLATFORM_TYPE_ANY];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::DownloadFileType_PlatformType_IsValid(val))) {
                    _internal_set_platform(static_cast<::safe_browsing::DownloadFileType_PlatformType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.DownloadFileType.DangerLevel danger_level = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::DownloadFileType_DangerLevel_IsValid(val))) {
                    _internal_set_danger_level(static_cast<::safe_browsing::DownloadFileType_DangerLevel>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.DownloadFileType.AutoOpenHint auto_open_hint = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::DownloadFileType_AutoOpenHint_IsValid(val))) {
                    _internal_set_auto_open_hint(static_cast<::safe_browsing::DownloadFileType_AutoOpenHint>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional uint64 max_file_size_to_analyze = 4 [default = 18446744073709551615];
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_max_file_size_to_analyze(&has_bits);
                _impl_.max_file_size_to_analyze_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 file_weight = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_file_weight(&has_bits);
                _impl_.file_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DownloadFileType_PlatformSettings::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.DownloadFileType.PlatformSettings)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .safe_browsing.DownloadFileType.PlatformType platform = 1 [default = PLATFORM_TYPE_ANY];
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_platform(), target);
    }

    // optional .safe_browsing.DownloadFileType.DangerLevel danger_level = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_danger_level(), target);
    }

    // optional .safe_browsing.DownloadFileType.AutoOpenHint auto_open_hint = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_auto_open_hint(), target);
    }

    // optional uint64 max_file_size_to_analyze = 4 [default = 18446744073709551615];
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_max_file_size_to_analyze(), target);
    }

    // optional int64 file_weight = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_file_weight(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.DownloadFileType.PlatformSettings)
    return target;
}

size_t DownloadFileType_PlatformSettings::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.DownloadFileType.PlatformSettings)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional .safe_browsing.DownloadFileType.PlatformType platform = 1 [default = PLATFORM_TYPE_ANY];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_platform());
        }

        // optional .safe_browsing.DownloadFileType.DangerLevel danger_level = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_danger_level());
        }

        // optional int64 file_weight = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_file_weight());
        }

        // optional .safe_browsing.DownloadFileType.AutoOpenHint auto_open_hint = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_auto_open_hint());
        }

        // optional uint64 max_file_size_to_analyze = 4 [default = 18446744073709551615];
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_file_size_to_analyze());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DownloadFileType_PlatformSettings::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DownloadFileType_PlatformSettings*>(&from));
}

void DownloadFileType_PlatformSettings::MergeFrom(const DownloadFileType_PlatformSettings& from)
{
    DownloadFileType_PlatformSettings* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.DownloadFileType.PlatformSettings)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.platform_ = from._impl_.platform_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.danger_level_ = from._impl_.danger_level_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.file_weight_ = from._impl_.file_weight_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.auto_open_hint_ = from._impl_.auto_open_hint_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.max_file_size_to_analyze_ = from._impl_.max_file_size_to_analyze_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DownloadFileType_PlatformSettings::CopyFrom(const DownloadFileType_PlatformSettings& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.DownloadFileType.PlatformSettings)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DownloadFileType_PlatformSettings::IsInitialized() const
{
    return true;
}

void DownloadFileType_PlatformSettings::InternalSwap(DownloadFileType_PlatformSettings* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(DownloadFileType_PlatformSettings, _impl_.auto_open_hint_)
        + sizeof(DownloadFileType_PlatformSettings::_impl_.auto_open_hint_) - PROTOBUF_FIELD_OFFSET(DownloadFileType_PlatformSettings, _impl_.platform_)>(
        reinterpret_cast<char*>(&_impl_.platform_), reinterpret_cast<char*>(&other->_impl_.platform_));
    swap(_impl_.max_file_size_to_analyze_, other->_impl_.max_file_size_to_analyze_);
}

std::string DownloadFileType_PlatformSettings::GetTypeName() const
{
    return "safe_browsing.DownloadFileType.PlatformSettings";
}

// ===================================================================

class DownloadFileType::_Internal {
public:
    using HasBits = decltype(std::declval<DownloadFileType>()._impl_._has_bits_);
    static void set_has_extension(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_uma_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_is_archive(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_ping_setting(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_inspection_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

DownloadFileType::DownloadFileType(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.DownloadFileType)
}
DownloadFileType::DownloadFileType(const DownloadFileType& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DownloadFileType* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.platform_settings_) { from._impl_.platform_settings_ }, decltype(_impl_.extension_) {}, decltype(_impl_.uma_value_) {},
        decltype(_impl_.is_archive_) {}, decltype(_impl_.ping_setting_) {}, decltype(_impl_.inspection_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.extension_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_extension()) {
        _this->_impl_.extension_.Set(from._internal_extension(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.uma_value_, &from._impl_.uma_value_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.inspection_type_) - reinterpret_cast<char*>(&_impl_.uma_value_)) + sizeof(_impl_.inspection_type_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.DownloadFileType)
}

inline void DownloadFileType::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.platform_settings_) { arena },
        decltype(_impl_.extension_) {}, decltype(_impl_.uma_value_) { int64_t { 0 } }, decltype(_impl_.is_archive_) { false },
        decltype(_impl_.ping_setting_) { 0 }, decltype(_impl_.inspection_type_) { 0 } };
    _impl_.extension_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DownloadFileType::~DownloadFileType()
{
    // @@protoc_insertion_point(destructor:safe_browsing.DownloadFileType)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DownloadFileType::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.platform_settings_.~RepeatedPtrField();
    _impl_.extension_.Destroy();
}

void DownloadFileType::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DownloadFileType::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.DownloadFileType)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.platform_settings_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.extension_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x0000001eu) {
        ::memset(&_impl_.uma_value_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.inspection_type_) - reinterpret_cast<char*>(&_impl_.uma_value_))
                + sizeof(_impl_.inspection_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DownloadFileType::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string extension = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_extension();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 uma_value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_uma_value(&has_bits);
                _impl_.uma_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_archive = 3 [default = false];
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_is_archive(&has_bits);
                _impl_.is_archive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.DownloadFileType.PingSetting ping_setting = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::DownloadFileType_PingSetting_IsValid(val))) {
                    _internal_set_ping_setting(static_cast<::safe_browsing::DownloadFileType_PingSetting>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.DownloadFileType.PlatformSettings platform_settings = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_platform_settings(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.DownloadFileType.InspectionType inspection_type = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::safe_browsing::DownloadFileType_InspectionType_IsValid(val))) {
                    _internal_set_inspection_type(static_cast<::safe_browsing::DownloadFileType_InspectionType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DownloadFileType::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.DownloadFileType)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string extension = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_extension(), target);
    }

    // optional int64 uma_value = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_uma_value(), target);
    }

    // optional bool is_archive = 3 [default = false];
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_archive(), target);
    }

    // optional .safe_browsing.DownloadFileType.PingSetting ping_setting = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_ping_setting(), target);
    }

    // repeated .safe_browsing.DownloadFileType.PlatformSettings platform_settings = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_platform_settings_size()); i < n; i++) {
        const auto& repfield = this->_internal_platform_settings(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.DownloadFileType.InspectionType inspection_type = 6;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(6, this->_internal_inspection_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.DownloadFileType)
    return target;
}

size_t DownloadFileType::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.DownloadFileType)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.DownloadFileType.PlatformSettings platform_settings = 5;
    total_size += 1UL * this->_internal_platform_settings_size();
    for (const auto& msg : this->_impl_.platform_settings_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string extension = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_extension());
        }

        // optional int64 uma_value = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_uma_value());
        }

        // optional bool is_archive = 3 [default = false];
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }

        // optional .safe_browsing.DownloadFileType.PingSetting ping_setting = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_ping_setting());
        }

        // optional .safe_browsing.DownloadFileType.InspectionType inspection_type = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_inspection_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DownloadFileType::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DownloadFileType*>(&from));
}

void DownloadFileType::MergeFrom(const DownloadFileType& from)
{
    DownloadFileType* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.DownloadFileType)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.platform_settings_.MergeFrom(from._impl_.platform_settings_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_extension(from._internal_extension());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.uma_value_ = from._impl_.uma_value_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.is_archive_ = from._impl_.is_archive_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.ping_setting_ = from._impl_.ping_setting_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.inspection_type_ = from._impl_.inspection_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DownloadFileType::CopyFrom(const DownloadFileType& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.DownloadFileType)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DownloadFileType::IsInitialized() const
{
    return true;
}

void DownloadFileType::InternalSwap(DownloadFileType* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.platform_settings_.InternalSwap(&other->_impl_.platform_settings_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.extension_, lhs_arena, &other->_impl_.extension_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(DownloadFileType, _impl_.inspection_type_)
        + sizeof(DownloadFileType::_impl_.inspection_type_) - PROTOBUF_FIELD_OFFSET(DownloadFileType, _impl_.uma_value_)>(
        reinterpret_cast<char*>(&_impl_.uma_value_), reinterpret_cast<char*>(&other->_impl_.uma_value_));
}

std::string DownloadFileType::GetTypeName() const
{
    return "safe_browsing.DownloadFileType";
}

// ===================================================================

class DownloadFileTypeConfig::_Internal {
public:
    using HasBits = decltype(std::declval<DownloadFileTypeConfig>()._impl_._has_bits_);
    static void set_has_version_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_sampled_ping_probability(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::safe_browsing::DownloadFileType& default_file_type(const DownloadFileTypeConfig* msg);
    static void set_has_default_file_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_max_archived_binaries_to_report(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::safe_browsing::DownloadFileType& DownloadFileTypeConfig::_Internal::default_file_type(const DownloadFileTypeConfig* msg)
{
    return *msg->_impl_.default_file_type_;
}
DownloadFileTypeConfig::DownloadFileTypeConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:safe_browsing.DownloadFileTypeConfig)
}
DownloadFileTypeConfig::DownloadFileTypeConfig(const DownloadFileTypeConfig& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DownloadFileTypeConfig* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.file_types_) { from._impl_.file_types_ }, decltype(_impl_.default_file_type_) { nullptr }, decltype(_impl_.version_id_) {},
        decltype(_impl_.sampled_ping_probability_) {}, decltype(_impl_.max_archived_binaries_to_report_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_default_file_type()) {
        _this->_impl_.default_file_type_ = new ::safe_browsing::DownloadFileType(*from._impl_.default_file_type_);
    }
    ::memcpy(&_impl_.version_id_, &from._impl_.version_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_archived_binaries_to_report_) - reinterpret_cast<char*>(&_impl_.version_id_))
            + sizeof(_impl_.max_archived_binaries_to_report_));
    // @@protoc_insertion_point(copy_constructor:safe_browsing.DownloadFileTypeConfig)
}

inline void DownloadFileTypeConfig::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.file_types_) { arena },
        decltype(_impl_.default_file_type_) { nullptr }, decltype(_impl_.version_id_) { 0u }, decltype(_impl_.sampled_ping_probability_) { 0 },
        decltype(_impl_.max_archived_binaries_to_report_) { uint64_t { 0u } } };
}

DownloadFileTypeConfig::~DownloadFileTypeConfig()
{
    // @@protoc_insertion_point(destructor:safe_browsing.DownloadFileTypeConfig)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DownloadFileTypeConfig::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.file_types_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.default_file_type_;
}

void DownloadFileTypeConfig::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DownloadFileTypeConfig::Clear()
{
    // @@protoc_insertion_point(message_clear_start:safe_browsing.DownloadFileTypeConfig)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.file_types_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.default_file_type_ != nullptr);
        _impl_.default_file_type_->Clear();
    }
    if (cached_has_bits & 0x0000000eu) {
        ::memset(&_impl_.version_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_archived_binaries_to_report_) - reinterpret_cast<char*>(&_impl_.version_id_))
                + sizeof(_impl_.max_archived_binaries_to_report_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DownloadFileTypeConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint32 version_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_version_id(&has_bits);
                _impl_.version_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional float sampled_ping_probability = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
                _Internal::set_has_sampled_ping_probability(&has_bits);
                _impl_.sampled_ping_probability_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // repeated .safe_browsing.DownloadFileType file_types = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_file_types(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .safe_browsing.DownloadFileType default_file_type = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_default_file_type(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint64 max_archived_binaries_to_report = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_max_archived_binaries_to_report(&has_bits);
                _impl_.max_archived_binaries_to_report_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DownloadFileTypeConfig::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:safe_browsing.DownloadFileTypeConfig)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 version_id = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version_id(), target);
    }

    // optional float sampled_ping_probability = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_sampled_ping_probability(), target);
    }

    // repeated .safe_browsing.DownloadFileType file_types = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_file_types_size()); i < n; i++) {
        const auto& repfield = this->_internal_file_types(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .safe_browsing.DownloadFileType default_file_type = 4;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::default_file_type(this), _Internal::default_file_type(this).GetCachedSize(), target, stream);
    }

    // optional uint64 max_archived_binaries_to_report = 5;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(5, this->_internal_max_archived_binaries_to_report(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:safe_browsing.DownloadFileTypeConfig)
    return target;
}

size_t DownloadFileTypeConfig::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:safe_browsing.DownloadFileTypeConfig)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .safe_browsing.DownloadFileType file_types = 3;
    total_size += 1UL * this->_internal_file_types_size();
    for (const auto& msg : this->_impl_.file_types_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .safe_browsing.DownloadFileType default_file_type = 4;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.default_file_type_);
        }

        // optional uint32 version_id = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version_id());
        }

        // optional float sampled_ping_probability = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 4;
        }

        // optional uint64 max_archived_binaries_to_report = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_max_archived_binaries_to_report());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DownloadFileTypeConfig::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DownloadFileTypeConfig*>(&from));
}

void DownloadFileTypeConfig::MergeFrom(const DownloadFileTypeConfig& from)
{
    DownloadFileTypeConfig* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:safe_browsing.DownloadFileTypeConfig)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.file_types_.MergeFrom(from._impl_.file_types_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_default_file_type()->::safe_browsing::DownloadFileType::MergeFrom(from._internal_default_file_type());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.version_id_ = from._impl_.version_id_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.sampled_ping_probability_ = from._impl_.sampled_ping_probability_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.max_archived_binaries_to_report_ = from._impl_.max_archived_binaries_to_report_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DownloadFileTypeConfig::CopyFrom(const DownloadFileTypeConfig& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:safe_browsing.DownloadFileTypeConfig)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DownloadFileTypeConfig::IsInitialized() const
{
    return true;
}

void DownloadFileTypeConfig::InternalSwap(DownloadFileTypeConfig* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.file_types_.InternalSwap(&other->_impl_.file_types_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(DownloadFileTypeConfig, _impl_.max_archived_binaries_to_report_)
        + sizeof(DownloadFileTypeConfig::_impl_.max_archived_binaries_to_report_) - PROTOBUF_FIELD_OFFSET(DownloadFileTypeConfig, _impl_.default_file_type_)>(
        reinterpret_cast<char*>(&_impl_.default_file_type_), reinterpret_cast<char*>(&other->_impl_.default_file_type_));
}

std::string DownloadFileTypeConfig::GetTypeName() const
{
    return "safe_browsing.DownloadFileTypeConfig";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace safe_browsing
PROTOBUF_NAMESPACE_OPEN
template <>
PROTOBUF_NOINLINE ::safe_browsing::DownloadFileType_PlatformSettings* Arena::CreateMaybeMessage<::safe_browsing::DownloadFileType_PlatformSettings>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::DownloadFileType_PlatformSettings>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::DownloadFileType* Arena::CreateMaybeMessage<::safe_browsing::DownloadFileType>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::DownloadFileType>(arena);
}
template <> PROTOBUF_NOINLINE ::safe_browsing::DownloadFileTypeConfig* Arena::CreateMaybeMessage<::safe_browsing::DownloadFileTypeConfig>(Arena* arena)
{
    return Arena::CreateMessageInternal<::safe_browsing::DownloadFileTypeConfig>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
