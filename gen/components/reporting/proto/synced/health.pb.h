// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/reporting/proto/synced/health.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2freporting_2fproto_2fsynced_2fhealth_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2freporting_2fproto_2fsynced_2fhealth_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include "components/reporting/proto/synced/record_constants.pb.h"
#include "components/reporting/proto/synced/status.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2freporting_2fproto_2fsynced_2fhealth_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto {
    static const uint32_t offsets[];
};
namespace reporting {
class BlockedDestinationsUpdatedCall;
struct BlockedDestinationsUpdatedCallDefaultTypeInternal;
extern BlockedDestinationsUpdatedCallDefaultTypeInternal _BlockedDestinationsUpdatedCall_default_instance_;
class BlockedRecordCall;
struct BlockedRecordCallDefaultTypeInternal;
extern BlockedRecordCallDefaultTypeInternal _BlockedRecordCall_default_instance_;
class ConfirmRecordUploadCall;
struct ConfirmRecordUploadCallDefaultTypeInternal;
extern ConfirmRecordUploadCallDefaultTypeInternal _ConfirmRecordUploadCall_default_instance_;
class ERPHealthData;
struct ERPHealthDataDefaultTypeInternal;
extern ERPHealthDataDefaultTypeInternal _ERPHealthData_default_instance_;
class EnqueueRecordCall;
struct EnqueueRecordCallDefaultTypeInternal;
extern EnqueueRecordCallDefaultTypeInternal _EnqueueRecordCall_default_instance_;
class FlushPriorityCall;
struct FlushPriorityCallDefaultTypeInternal;
extern FlushPriorityCallDefaultTypeInternal _FlushPriorityCall_default_instance_;
class HealthDataHistory;
struct HealthDataHistoryDefaultTypeInternal;
extern HealthDataHistoryDefaultTypeInternal _HealthDataHistory_default_instance_;
class StorageDequeue;
struct StorageDequeueDefaultTypeInternal;
extern StorageDequeueDefaultTypeInternal _StorageDequeue_default_instance_;
class StorageEnqueue;
struct StorageEnqueueDefaultTypeInternal;
extern StorageEnqueueDefaultTypeInternal _StorageEnqueue_default_instance_;
class StorageQueueAction;
struct StorageQueueActionDefaultTypeInternal;
extern StorageQueueActionDefaultTypeInternal _StorageQueueAction_default_instance_;
class UploadEncryptedRecordCall;
struct UploadEncryptedRecordCallDefaultTypeInternal;
extern UploadEncryptedRecordCallDefaultTypeInternal _UploadEncryptedRecordCall_default_instance_;
class UploadGapItem;
struct UploadGapItemDefaultTypeInternal;
extern UploadGapItemDefaultTypeInternal _UploadGapItem_default_instance_;
class UploadItem;
struct UploadItemDefaultTypeInternal;
extern UploadItemDefaultTypeInternal _UploadItem_default_instance_;
class UploadRecordItem;
struct UploadRecordItemDefaultTypeInternal;
extern UploadRecordItemDefaultTypeInternal _UploadRecordItem_default_instance_;
} // namespace reporting
PROTOBUF_NAMESPACE_OPEN
template <>::reporting::BlockedDestinationsUpdatedCall* Arena::CreateMaybeMessage<::reporting::BlockedDestinationsUpdatedCall>(Arena*);
template <>::reporting::BlockedRecordCall* Arena::CreateMaybeMessage<::reporting::BlockedRecordCall>(Arena*);
template <>::reporting::ConfirmRecordUploadCall* Arena::CreateMaybeMessage<::reporting::ConfirmRecordUploadCall>(Arena*);
template <>::reporting::ERPHealthData* Arena::CreateMaybeMessage<::reporting::ERPHealthData>(Arena*);
template <>::reporting::EnqueueRecordCall* Arena::CreateMaybeMessage<::reporting::EnqueueRecordCall>(Arena*);
template <>::reporting::FlushPriorityCall* Arena::CreateMaybeMessage<::reporting::FlushPriorityCall>(Arena*);
template <>::reporting::HealthDataHistory* Arena::CreateMaybeMessage<::reporting::HealthDataHistory>(Arena*);
template <>::reporting::StorageDequeue* Arena::CreateMaybeMessage<::reporting::StorageDequeue>(Arena*);
template <>::reporting::StorageEnqueue* Arena::CreateMaybeMessage<::reporting::StorageEnqueue>(Arena*);
template <>::reporting::StorageQueueAction* Arena::CreateMaybeMessage<::reporting::StorageQueueAction>(Arena*);
template <>::reporting::UploadEncryptedRecordCall* Arena::CreateMaybeMessage<::reporting::UploadEncryptedRecordCall>(Arena*);
template <>::reporting::UploadGapItem* Arena::CreateMaybeMessage<::reporting::UploadGapItem>(Arena*);
template <>::reporting::UploadItem* Arena::CreateMaybeMessage<::reporting::UploadItem>(Arena*);
template <>::reporting::UploadRecordItem* Arena::CreateMaybeMessage<::reporting::UploadRecordItem>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace reporting {

// ===================================================================

class StorageDequeue final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.StorageDequeue) */ {
public:
    inline StorageDequeue()
        : StorageDequeue(nullptr)
    {
    }
    ~StorageDequeue() override;
    explicit PROTOBUF_CONSTEXPR StorageDequeue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    StorageDequeue(const StorageDequeue& from);
    StorageDequeue(StorageDequeue&& from) noexcept
        : StorageDequeue()
    {
        *this = ::std::move(from);
    }

    inline StorageDequeue& operator=(const StorageDequeue& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline StorageDequeue& operator=(StorageDequeue&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const StorageDequeue& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const StorageDequeue* internal_default_instance()
    {
        return reinterpret_cast<const StorageDequeue*>(&_StorageDequeue_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(StorageDequeue& a, StorageDequeue& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(StorageDequeue* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(StorageDequeue* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    StorageDequeue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<StorageDequeue>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const StorageDequeue& from);
    void MergeFrom(const StorageDequeue& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(StorageDequeue* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.StorageDequeue";
    }

protected:
    explicit StorageDequeue(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSequencingIdFieldNumber = 1,
        kRecordsCountFieldNumber = 2,
    };
    // optional int64 sequencing_id = 1;
    bool has_sequencing_id() const;

private:
    bool _internal_has_sequencing_id() const;

public:
    void clear_sequencing_id();
    int64_t sequencing_id() const;
    void set_sequencing_id(int64_t value);

private:
    int64_t _internal_sequencing_id() const;
    void _internal_set_sequencing_id(int64_t value);

public:
    // optional int64 records_count = 2;
    bool has_records_count() const;

private:
    bool _internal_has_records_count() const;

public:
    void clear_records_count();
    int64_t records_count() const;
    void set_records_count(int64_t value);

private:
    int64_t _internal_records_count() const;
    void _internal_set_records_count(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.StorageDequeue)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int64_t sequencing_id_;
        int64_t records_count_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto;
};
// -------------------------------------------------------------------

class StorageEnqueue final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.StorageEnqueue) */ {
public:
    inline StorageEnqueue()
        : StorageEnqueue(nullptr)
    {
    }
    ~StorageEnqueue() override;
    explicit PROTOBUF_CONSTEXPR StorageEnqueue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    StorageEnqueue(const StorageEnqueue& from);
    StorageEnqueue(StorageEnqueue&& from) noexcept
        : StorageEnqueue()
    {
        *this = ::std::move(from);
    }

    inline StorageEnqueue& operator=(const StorageEnqueue& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline StorageEnqueue& operator=(StorageEnqueue&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const StorageEnqueue& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const StorageEnqueue* internal_default_instance()
    {
        return reinterpret_cast<const StorageEnqueue*>(&_StorageEnqueue_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(StorageEnqueue& a, StorageEnqueue& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(StorageEnqueue* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(StorageEnqueue* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    StorageEnqueue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<StorageEnqueue>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const StorageEnqueue& from);
    void MergeFrom(const StorageEnqueue& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(StorageEnqueue* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.StorageEnqueue";
    }

protected:
    explicit StorageEnqueue(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSequencingIdFieldNumber = 1,
    };
    // optional int64 sequencing_id = 1;
    bool has_sequencing_id() const;

private:
    bool _internal_has_sequencing_id() const;

public:
    void clear_sequencing_id();
    int64_t sequencing_id() const;
    void set_sequencing_id(int64_t value);

private:
    int64_t _internal_sequencing_id() const;
    void _internal_set_sequencing_id(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.StorageEnqueue)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int64_t sequencing_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto;
};
// -------------------------------------------------------------------

class StorageQueueAction final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.StorageQueueAction) */ {
public:
    inline StorageQueueAction()
        : StorageQueueAction(nullptr)
    {
    }
    ~StorageQueueAction() override;
    explicit PROTOBUF_CONSTEXPR StorageQueueAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    StorageQueueAction(const StorageQueueAction& from);
    StorageQueueAction(StorageQueueAction&& from) noexcept
        : StorageQueueAction()
    {
        *this = ::std::move(from);
    }

    inline StorageQueueAction& operator=(const StorageQueueAction& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline StorageQueueAction& operator=(StorageQueueAction&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const StorageQueueAction& default_instance()
    {
        return *internal_default_instance();
    }
    enum ActionCase {
        kStorageDequeue = 1,
        kStorageEnqueue = 2,
        ACTION_NOT_SET = 0,
    };

    static inline const StorageQueueAction* internal_default_instance()
    {
        return reinterpret_cast<const StorageQueueAction*>(&_StorageQueueAction_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(StorageQueueAction& a, StorageQueueAction& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(StorageQueueAction* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(StorageQueueAction* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    StorageQueueAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<StorageQueueAction>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const StorageQueueAction& from);
    void MergeFrom(const StorageQueueAction& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(StorageQueueAction* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.StorageQueueAction";
    }

protected:
    explicit StorageQueueAction(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStatusFieldNumber = 4,
        kPriorityFieldNumber = 3,
        kStorageDequeueFieldNumber = 1,
        kStorageEnqueueFieldNumber = 2,
    };
    // optional .reporting.StatusProto status = 4;
    bool has_status() const;

private:
    bool _internal_has_status() const;

public:
    void clear_status();
    const ::reporting::StatusProto& status() const;
    PROTOBUF_NODISCARD ::reporting::StatusProto* release_status();
    ::reporting::StatusProto* mutable_status();
    void set_allocated_status(::reporting::StatusProto* status);

private:
    const ::reporting::StatusProto& _internal_status() const;
    ::reporting::StatusProto* _internal_mutable_status();

public:
    void unsafe_arena_set_allocated_status(::reporting::StatusProto* status);
    ::reporting::StatusProto* unsafe_arena_release_status();

    // optional .reporting.Priority priority = 3;
    bool has_priority() const;

private:
    bool _internal_has_priority() const;

public:
    void clear_priority();
    ::reporting::Priority priority() const;
    void set_priority(::reporting::Priority value);

private:
    ::reporting::Priority _internal_priority() const;
    void _internal_set_priority(::reporting::Priority value);

public:
    // .reporting.StorageDequeue storage_dequeue = 1;
    bool has_storage_dequeue() const;

private:
    bool _internal_has_storage_dequeue() const;

public:
    void clear_storage_dequeue();
    const ::reporting::StorageDequeue& storage_dequeue() const;
    PROTOBUF_NODISCARD ::reporting::StorageDequeue* release_storage_dequeue();
    ::reporting::StorageDequeue* mutable_storage_dequeue();
    void set_allocated_storage_dequeue(::reporting::StorageDequeue* storage_dequeue);

private:
    const ::reporting::StorageDequeue& _internal_storage_dequeue() const;
    ::reporting::StorageDequeue* _internal_mutable_storage_dequeue();

public:
    void unsafe_arena_set_allocated_storage_dequeue(::reporting::StorageDequeue* storage_dequeue);
    ::reporting::StorageDequeue* unsafe_arena_release_storage_dequeue();

    // .reporting.StorageEnqueue storage_enqueue = 2;
    bool has_storage_enqueue() const;

private:
    bool _internal_has_storage_enqueue() const;

public:
    void clear_storage_enqueue();
    const ::reporting::StorageEnqueue& storage_enqueue() const;
    PROTOBUF_NODISCARD ::reporting::StorageEnqueue* release_storage_enqueue();
    ::reporting::StorageEnqueue* mutable_storage_enqueue();
    void set_allocated_storage_enqueue(::reporting::StorageEnqueue* storage_enqueue);

private:
    const ::reporting::StorageEnqueue& _internal_storage_enqueue() const;
    ::reporting::StorageEnqueue* _internal_mutable_storage_enqueue();

public:
    void unsafe_arena_set_allocated_storage_enqueue(::reporting::StorageEnqueue* storage_enqueue);
    ::reporting::StorageEnqueue* unsafe_arena_release_storage_enqueue();

    void clear_action();
    ActionCase action_case() const;
    // @@protoc_insertion_point(class_scope:reporting.StorageQueueAction)
private:
    class _Internal;
    void set_has_storage_dequeue();
    void set_has_storage_enqueue();

    inline bool has_action() const;
    inline void clear_has_action();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::reporting::StatusProto* status_;
        int priority_;
        union ActionUnion {
            constexpr ActionUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::reporting::StorageDequeue* storage_dequeue_;
            ::reporting::StorageEnqueue* storage_enqueue_;
        } action_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto;
};
// -------------------------------------------------------------------

class EnqueueRecordCall final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.EnqueueRecordCall) */ {
public:
    inline EnqueueRecordCall()
        : EnqueueRecordCall(nullptr)
    {
    }
    ~EnqueueRecordCall() override;
    explicit PROTOBUF_CONSTEXPR EnqueueRecordCall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    EnqueueRecordCall(const EnqueueRecordCall& from);
    EnqueueRecordCall(EnqueueRecordCall&& from) noexcept
        : EnqueueRecordCall()
    {
        *this = ::std::move(from);
    }

    inline EnqueueRecordCall& operator=(const EnqueueRecordCall& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline EnqueueRecordCall& operator=(EnqueueRecordCall&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const EnqueueRecordCall& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const EnqueueRecordCall* internal_default_instance()
    {
        return reinterpret_cast<const EnqueueRecordCall*>(&_EnqueueRecordCall_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(EnqueueRecordCall& a, EnqueueRecordCall& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(EnqueueRecordCall* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(EnqueueRecordCall* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    EnqueueRecordCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<EnqueueRecordCall>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const EnqueueRecordCall& from);
    void MergeFrom(const EnqueueRecordCall& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(EnqueueRecordCall* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.EnqueueRecordCall";
    }

protected:
    explicit EnqueueRecordCall(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStatusFieldNumber = 3,
        kPriorityFieldNumber = 1,
        kDestinationFieldNumber = 2,
    };
    // optional .reporting.StatusProto status = 3;
    bool has_status() const;

private:
    bool _internal_has_status() const;

public:
    void clear_status();
    const ::reporting::StatusProto& status() const;
    PROTOBUF_NODISCARD ::reporting::StatusProto* release_status();
    ::reporting::StatusProto* mutable_status();
    void set_allocated_status(::reporting::StatusProto* status);

private:
    const ::reporting::StatusProto& _internal_status() const;
    ::reporting::StatusProto* _internal_mutable_status();

public:
    void unsafe_arena_set_allocated_status(::reporting::StatusProto* status);
    ::reporting::StatusProto* unsafe_arena_release_status();

    // optional .reporting.Priority priority = 1;
    bool has_priority() const;

private:
    bool _internal_has_priority() const;

public:
    void clear_priority();
    ::reporting::Priority priority() const;
    void set_priority(::reporting::Priority value);

private:
    ::reporting::Priority _internal_priority() const;
    void _internal_set_priority(::reporting::Priority value);

public:
    // optional .reporting.Destination destination = 2;
    bool has_destination() const;

private:
    bool _internal_has_destination() const;

public:
    void clear_destination();
    ::reporting::Destination destination() const;
    void set_destination(::reporting::Destination value);

private:
    ::reporting::Destination _internal_destination() const;
    void _internal_set_destination(::reporting::Destination value);

public:
    // @@protoc_insertion_point(class_scope:reporting.EnqueueRecordCall)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::reporting::StatusProto* status_;
        int priority_;
        int destination_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto;
};
// -------------------------------------------------------------------

class FlushPriorityCall final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.FlushPriorityCall) */ {
public:
    inline FlushPriorityCall()
        : FlushPriorityCall(nullptr)
    {
    }
    ~FlushPriorityCall() override;
    explicit PROTOBUF_CONSTEXPR FlushPriorityCall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FlushPriorityCall(const FlushPriorityCall& from);
    FlushPriorityCall(FlushPriorityCall&& from) noexcept
        : FlushPriorityCall()
    {
        *this = ::std::move(from);
    }

    inline FlushPriorityCall& operator=(const FlushPriorityCall& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FlushPriorityCall& operator=(FlushPriorityCall&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const FlushPriorityCall& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FlushPriorityCall* internal_default_instance()
    {
        return reinterpret_cast<const FlushPriorityCall*>(&_FlushPriorityCall_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(FlushPriorityCall& a, FlushPriorityCall& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FlushPriorityCall* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FlushPriorityCall* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FlushPriorityCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FlushPriorityCall>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FlushPriorityCall& from);
    void MergeFrom(const FlushPriorityCall& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FlushPriorityCall* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.FlushPriorityCall";
    }

protected:
    explicit FlushPriorityCall(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStatusFieldNumber = 2,
        kPriorityFieldNumber = 1,
    };
    // optional .reporting.StatusProto status = 2;
    bool has_status() const;

private:
    bool _internal_has_status() const;

public:
    void clear_status();
    const ::reporting::StatusProto& status() const;
    PROTOBUF_NODISCARD ::reporting::StatusProto* release_status();
    ::reporting::StatusProto* mutable_status();
    void set_allocated_status(::reporting::StatusProto* status);

private:
    const ::reporting::StatusProto& _internal_status() const;
    ::reporting::StatusProto* _internal_mutable_status();

public:
    void unsafe_arena_set_allocated_status(::reporting::StatusProto* status);
    ::reporting::StatusProto* unsafe_arena_release_status();

    // optional .reporting.Priority priority = 1;
    bool has_priority() const;

private:
    bool _internal_has_priority() const;

public:
    void clear_priority();
    ::reporting::Priority priority() const;
    void set_priority(::reporting::Priority value);

private:
    ::reporting::Priority _internal_priority() const;
    void _internal_set_priority(::reporting::Priority value);

public:
    // @@protoc_insertion_point(class_scope:reporting.FlushPriorityCall)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::reporting::StatusProto* status_;
        int priority_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto;
};
// -------------------------------------------------------------------

class UploadRecordItem final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.UploadRecordItem) */ {
public:
    inline UploadRecordItem()
        : UploadRecordItem(nullptr)
    {
    }
    ~UploadRecordItem() override;
    explicit PROTOBUF_CONSTEXPR UploadRecordItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    UploadRecordItem(const UploadRecordItem& from);
    UploadRecordItem(UploadRecordItem&& from) noexcept
        : UploadRecordItem()
    {
        *this = ::std::move(from);
    }

    inline UploadRecordItem& operator=(const UploadRecordItem& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UploadRecordItem& operator=(UploadRecordItem&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const UploadRecordItem& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const UploadRecordItem* internal_default_instance()
    {
        return reinterpret_cast<const UploadRecordItem*>(&_UploadRecordItem_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(UploadRecordItem& a, UploadRecordItem& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(UploadRecordItem* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UploadRecordItem* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UploadRecordItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<UploadRecordItem>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const UploadRecordItem& from);
    void MergeFrom(const UploadRecordItem& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(UploadRecordItem* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.UploadRecordItem";
    }

protected:
    explicit UploadRecordItem(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSequencingIdFieldNumber = 1,
    };
    // optional int64 sequencing_id = 1;
    bool has_sequencing_id() const;

private:
    bool _internal_has_sequencing_id() const;

public:
    void clear_sequencing_id();
    int64_t sequencing_id() const;
    void set_sequencing_id(int64_t value);

private:
    int64_t _internal_sequencing_id() const;
    void _internal_set_sequencing_id(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.UploadRecordItem)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int64_t sequencing_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto;
};
// -------------------------------------------------------------------

class UploadGapItem final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.UploadGapItem) */ {
public:
    inline UploadGapItem()
        : UploadGapItem(nullptr)
    {
    }
    ~UploadGapItem() override;
    explicit PROTOBUF_CONSTEXPR UploadGapItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    UploadGapItem(const UploadGapItem& from);
    UploadGapItem(UploadGapItem&& from) noexcept
        : UploadGapItem()
    {
        *this = ::std::move(from);
    }

    inline UploadGapItem& operator=(const UploadGapItem& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UploadGapItem& operator=(UploadGapItem&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const UploadGapItem& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const UploadGapItem* internal_default_instance()
    {
        return reinterpret_cast<const UploadGapItem*>(&_UploadGapItem_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(UploadGapItem& a, UploadGapItem& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(UploadGapItem* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UploadGapItem* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UploadGapItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<UploadGapItem>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const UploadGapItem& from);
    void MergeFrom(const UploadGapItem& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(UploadGapItem* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.UploadGapItem";
    }

protected:
    explicit UploadGapItem(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSequencingIdFieldNumber = 1,
        kCountFieldNumber = 2,
    };
    // optional int64 sequencing_id = 1;
    bool has_sequencing_id() const;

private:
    bool _internal_has_sequencing_id() const;

public:
    void clear_sequencing_id();
    int64_t sequencing_id() const;
    void set_sequencing_id(int64_t value);

private:
    int64_t _internal_sequencing_id() const;
    void _internal_set_sequencing_id(int64_t value);

public:
    // optional int64 count = 2;
    bool has_count() const;

private:
    bool _internal_has_count() const;

public:
    void clear_count();
    int64_t count() const;
    void set_count(int64_t value);

private:
    int64_t _internal_count() const;
    void _internal_set_count(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.UploadGapItem)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int64_t sequencing_id_;
        int64_t count_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto;
};
// -------------------------------------------------------------------

class UploadItem final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.UploadItem) */ {
public:
    inline UploadItem()
        : UploadItem(nullptr)
    {
    }
    ~UploadItem() override;
    explicit PROTOBUF_CONSTEXPR UploadItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    UploadItem(const UploadItem& from);
    UploadItem(UploadItem&& from) noexcept
        : UploadItem()
    {
        *this = ::std::move(from);
    }

    inline UploadItem& operator=(const UploadItem& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UploadItem& operator=(UploadItem&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const UploadItem& default_instance()
    {
        return *internal_default_instance();
    }
    enum ItemCase {
        kRecord = 1,
        kGap = 2,
        ITEM_NOT_SET = 0,
    };

    static inline const UploadItem* internal_default_instance()
    {
        return reinterpret_cast<const UploadItem*>(&_UploadItem_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(UploadItem& a, UploadItem& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(UploadItem* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UploadItem* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UploadItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<UploadItem>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const UploadItem& from);
    void MergeFrom(const UploadItem& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(UploadItem* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.UploadItem";
    }

protected:
    explicit UploadItem(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kRecordFieldNumber = 1,
        kGapFieldNumber = 2,
    };
    // .reporting.UploadRecordItem record = 1;
    bool has_record() const;

private:
    bool _internal_has_record() const;

public:
    void clear_record();
    const ::reporting::UploadRecordItem& record() const;
    PROTOBUF_NODISCARD ::reporting::UploadRecordItem* release_record();
    ::reporting::UploadRecordItem* mutable_record();
    void set_allocated_record(::reporting::UploadRecordItem* record);

private:
    const ::reporting::UploadRecordItem& _internal_record() const;
    ::reporting::UploadRecordItem* _internal_mutable_record();

public:
    void unsafe_arena_set_allocated_record(::reporting::UploadRecordItem* record);
    ::reporting::UploadRecordItem* unsafe_arena_release_record();

    // .reporting.UploadGapItem gap = 2;
    bool has_gap() const;

private:
    bool _internal_has_gap() const;

public:
    void clear_gap();
    const ::reporting::UploadGapItem& gap() const;
    PROTOBUF_NODISCARD ::reporting::UploadGapItem* release_gap();
    ::reporting::UploadGapItem* mutable_gap();
    void set_allocated_gap(::reporting::UploadGapItem* gap);

private:
    const ::reporting::UploadGapItem& _internal_gap() const;
    ::reporting::UploadGapItem* _internal_mutable_gap();

public:
    void unsafe_arena_set_allocated_gap(::reporting::UploadGapItem* gap);
    ::reporting::UploadGapItem* unsafe_arena_release_gap();

    void clear_item();
    ItemCase item_case() const;
    // @@protoc_insertion_point(class_scope:reporting.UploadItem)
private:
    class _Internal;
    void set_has_record();
    void set_has_gap();

    inline bool has_item() const;
    inline void clear_has_item();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        union ItemUnion {
            constexpr ItemUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::reporting::UploadRecordItem* record_;
            ::reporting::UploadGapItem* gap_;
        } item_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto;
};
// -------------------------------------------------------------------

class UploadEncryptedRecordCall final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.UploadEncryptedRecordCall) */ {
public:
    inline UploadEncryptedRecordCall()
        : UploadEncryptedRecordCall(nullptr)
    {
    }
    ~UploadEncryptedRecordCall() override;
    explicit PROTOBUF_CONSTEXPR UploadEncryptedRecordCall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    UploadEncryptedRecordCall(const UploadEncryptedRecordCall& from);
    UploadEncryptedRecordCall(UploadEncryptedRecordCall&& from) noexcept
        : UploadEncryptedRecordCall()
    {
        *this = ::std::move(from);
    }

    inline UploadEncryptedRecordCall& operator=(const UploadEncryptedRecordCall& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UploadEncryptedRecordCall& operator=(UploadEncryptedRecordCall&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const UploadEncryptedRecordCall& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const UploadEncryptedRecordCall* internal_default_instance()
    {
        return reinterpret_cast<const UploadEncryptedRecordCall*>(&_UploadEncryptedRecordCall_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(UploadEncryptedRecordCall& a, UploadEncryptedRecordCall& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(UploadEncryptedRecordCall* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UploadEncryptedRecordCall* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UploadEncryptedRecordCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<UploadEncryptedRecordCall>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const UploadEncryptedRecordCall& from);
    void MergeFrom(const UploadEncryptedRecordCall& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(UploadEncryptedRecordCall* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.UploadEncryptedRecordCall";
    }

protected:
    explicit UploadEncryptedRecordCall(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kItemsFieldNumber = 1,
        kUploadReasonFieldNumber = 2,
        kStatusFieldNumber = 4,
        kPriorityFieldNumber = 3,
    };
    // repeated .reporting.UploadItem items = 1;
    int items_size() const;

private:
    int _internal_items_size() const;

public:
    void clear_items();
    ::reporting::UploadItem* mutable_items(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::UploadItem>* mutable_items();

private:
    const ::reporting::UploadItem& _internal_items(int index) const;
    ::reporting::UploadItem* _internal_add_items();

public:
    const ::reporting::UploadItem& items(int index) const;
    ::reporting::UploadItem* add_items();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::UploadItem>& items() const;

    // optional string upload_reason = 2;
    bool has_upload_reason() const;

private:
    bool _internal_has_upload_reason() const;

public:
    void clear_upload_reason();
    const std::string& upload_reason() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_upload_reason(ArgT0&& arg0, ArgT... args);
    std::string* mutable_upload_reason();
    PROTOBUF_NODISCARD std::string* release_upload_reason();
    void set_allocated_upload_reason(std::string* upload_reason);

private:
    const std::string& _internal_upload_reason() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_upload_reason(const std::string& value);
    std::string* _internal_mutable_upload_reason();

public:
    // optional .reporting.StatusProto status = 4;
    bool has_status() const;

private:
    bool _internal_has_status() const;

public:
    void clear_status();
    const ::reporting::StatusProto& status() const;
    PROTOBUF_NODISCARD ::reporting::StatusProto* release_status();
    ::reporting::StatusProto* mutable_status();
    void set_allocated_status(::reporting::StatusProto* status);

private:
    const ::reporting::StatusProto& _internal_status() const;
    ::reporting::StatusProto* _internal_mutable_status();

public:
    void unsafe_arena_set_allocated_status(::reporting::StatusProto* status);
    ::reporting::StatusProto* unsafe_arena_release_status();

    // optional .reporting.Priority priority = 3;
    bool has_priority() const;

private:
    bool _internal_has_priority() const;

public:
    void clear_priority();
    ::reporting::Priority priority() const;
    void set_priority(::reporting::Priority value);

private:
    ::reporting::Priority _internal_priority() const;
    void _internal_set_priority(::reporting::Priority value);

public:
    // @@protoc_insertion_point(class_scope:reporting.UploadEncryptedRecordCall)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::UploadItem> items_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr upload_reason_;
        ::reporting::StatusProto* status_;
        int priority_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto;
};
// -------------------------------------------------------------------

class ConfirmRecordUploadCall final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.ConfirmRecordUploadCall) */ {
public:
    inline ConfirmRecordUploadCall()
        : ConfirmRecordUploadCall(nullptr)
    {
    }
    ~ConfirmRecordUploadCall() override;
    explicit PROTOBUF_CONSTEXPR ConfirmRecordUploadCall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ConfirmRecordUploadCall(const ConfirmRecordUploadCall& from);
    ConfirmRecordUploadCall(ConfirmRecordUploadCall&& from) noexcept
        : ConfirmRecordUploadCall()
    {
        *this = ::std::move(from);
    }

    inline ConfirmRecordUploadCall& operator=(const ConfirmRecordUploadCall& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ConfirmRecordUploadCall& operator=(ConfirmRecordUploadCall&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ConfirmRecordUploadCall& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ConfirmRecordUploadCall* internal_default_instance()
    {
        return reinterpret_cast<const ConfirmRecordUploadCall*>(&_ConfirmRecordUploadCall_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(ConfirmRecordUploadCall& a, ConfirmRecordUploadCall& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ConfirmRecordUploadCall* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ConfirmRecordUploadCall* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ConfirmRecordUploadCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ConfirmRecordUploadCall>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ConfirmRecordUploadCall& from);
    void MergeFrom(const ConfirmRecordUploadCall& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ConfirmRecordUploadCall* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.ConfirmRecordUploadCall";
    }

protected:
    explicit ConfirmRecordUploadCall(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStatusFieldNumber = 4,
        kSequencingIdFieldNumber = 1,
        kForceConfirmFieldNumber = 2,
        kPriorityFieldNumber = 3,
    };
    // optional .reporting.StatusProto status = 4;
    bool has_status() const;

private:
    bool _internal_has_status() const;

public:
    void clear_status();
    const ::reporting::StatusProto& status() const;
    PROTOBUF_NODISCARD ::reporting::StatusProto* release_status();
    ::reporting::StatusProto* mutable_status();
    void set_allocated_status(::reporting::StatusProto* status);

private:
    const ::reporting::StatusProto& _internal_status() const;
    ::reporting::StatusProto* _internal_mutable_status();

public:
    void unsafe_arena_set_allocated_status(::reporting::StatusProto* status);
    ::reporting::StatusProto* unsafe_arena_release_status();

    // optional int64 sequencing_id = 1;
    bool has_sequencing_id() const;

private:
    bool _internal_has_sequencing_id() const;

public:
    void clear_sequencing_id();
    int64_t sequencing_id() const;
    void set_sequencing_id(int64_t value);

private:
    int64_t _internal_sequencing_id() const;
    void _internal_set_sequencing_id(int64_t value);

public:
    // optional bool force_confirm = 2;
    bool has_force_confirm() const;

private:
    bool _internal_has_force_confirm() const;

public:
    void clear_force_confirm();
    bool force_confirm() const;
    void set_force_confirm(bool value);

private:
    bool _internal_force_confirm() const;
    void _internal_set_force_confirm(bool value);

public:
    // optional .reporting.Priority priority = 3;
    bool has_priority() const;

private:
    bool _internal_has_priority() const;

public:
    void clear_priority();
    ::reporting::Priority priority() const;
    void set_priority(::reporting::Priority value);

private:
    ::reporting::Priority _internal_priority() const;
    void _internal_set_priority(::reporting::Priority value);

public:
    // @@protoc_insertion_point(class_scope:reporting.ConfirmRecordUploadCall)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::reporting::StatusProto* status_;
        int64_t sequencing_id_;
        bool force_confirm_;
        int priority_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto;
};
// -------------------------------------------------------------------

class BlockedRecordCall final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.BlockedRecordCall) */ {
public:
    inline BlockedRecordCall()
        : BlockedRecordCall(nullptr)
    {
    }
    ~BlockedRecordCall() override;
    explicit PROTOBUF_CONSTEXPR BlockedRecordCall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    BlockedRecordCall(const BlockedRecordCall& from);
    BlockedRecordCall(BlockedRecordCall&& from) noexcept
        : BlockedRecordCall()
    {
        *this = ::std::move(from);
    }

    inline BlockedRecordCall& operator=(const BlockedRecordCall& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline BlockedRecordCall& operator=(BlockedRecordCall&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const BlockedRecordCall& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const BlockedRecordCall* internal_default_instance()
    {
        return reinterpret_cast<const BlockedRecordCall*>(&_BlockedRecordCall_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 10;

    friend void swap(BlockedRecordCall& a, BlockedRecordCall& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(BlockedRecordCall* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(BlockedRecordCall* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    BlockedRecordCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<BlockedRecordCall>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const BlockedRecordCall& from);
    void MergeFrom(const BlockedRecordCall& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(BlockedRecordCall* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.BlockedRecordCall";
    }

protected:
    explicit BlockedRecordCall(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kPriorityFieldNumber = 1,
        kDestinationFieldNumber = 2,
    };
    // optional .reporting.Priority priority = 1;
    bool has_priority() const;

private:
    bool _internal_has_priority() const;

public:
    void clear_priority();
    ::reporting::Priority priority() const;
    void set_priority(::reporting::Priority value);

private:
    ::reporting::Priority _internal_priority() const;
    void _internal_set_priority(::reporting::Priority value);

public:
    // optional .reporting.Destination destination = 2;
    bool has_destination() const;

private:
    bool _internal_has_destination() const;

public:
    void clear_destination();
    ::reporting::Destination destination() const;
    void set_destination(::reporting::Destination value);

private:
    ::reporting::Destination _internal_destination() const;
    void _internal_set_destination(::reporting::Destination value);

public:
    // @@protoc_insertion_point(class_scope:reporting.BlockedRecordCall)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int priority_;
        int destination_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto;
};
// -------------------------------------------------------------------

class BlockedDestinationsUpdatedCall final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.BlockedDestinationsUpdatedCall) */ {
public:
    inline BlockedDestinationsUpdatedCall()
        : BlockedDestinationsUpdatedCall(nullptr)
    {
    }
    ~BlockedDestinationsUpdatedCall() override;
    explicit PROTOBUF_CONSTEXPR BlockedDestinationsUpdatedCall(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    BlockedDestinationsUpdatedCall(const BlockedDestinationsUpdatedCall& from);
    BlockedDestinationsUpdatedCall(BlockedDestinationsUpdatedCall&& from) noexcept
        : BlockedDestinationsUpdatedCall()
    {
        *this = ::std::move(from);
    }

    inline BlockedDestinationsUpdatedCall& operator=(const BlockedDestinationsUpdatedCall& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline BlockedDestinationsUpdatedCall& operator=(BlockedDestinationsUpdatedCall&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const BlockedDestinationsUpdatedCall& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const BlockedDestinationsUpdatedCall* internal_default_instance()
    {
        return reinterpret_cast<const BlockedDestinationsUpdatedCall*>(&_BlockedDestinationsUpdatedCall_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 11;

    friend void swap(BlockedDestinationsUpdatedCall& a, BlockedDestinationsUpdatedCall& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(BlockedDestinationsUpdatedCall* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(BlockedDestinationsUpdatedCall* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    BlockedDestinationsUpdatedCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<BlockedDestinationsUpdatedCall>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const BlockedDestinationsUpdatedCall& from);
    void MergeFrom(const BlockedDestinationsUpdatedCall& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(BlockedDestinationsUpdatedCall* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.BlockedDestinationsUpdatedCall";
    }

protected:
    explicit BlockedDestinationsUpdatedCall(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDestinationsFieldNumber = 1,
    };
    // repeated .reporting.Destination destinations = 1;
    int destinations_size() const;

private:
    int _internal_destinations_size() const;

public:
    void clear_destinations();

private:
    ::reporting::Destination _internal_destinations(int index) const;
    void _internal_add_destinations(::reporting::Destination value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_destinations();

public:
    ::reporting::Destination destinations(int index) const;
    void set_destinations(int index, ::reporting::Destination value);
    void add_destinations(::reporting::Destination value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& destinations() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_destinations();

    // @@protoc_insertion_point(class_scope:reporting.BlockedDestinationsUpdatedCall)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> destinations_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto;
};
// -------------------------------------------------------------------

class HealthDataHistory final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.HealthDataHistory) */ {
public:
    inline HealthDataHistory()
        : HealthDataHistory(nullptr)
    {
    }
    ~HealthDataHistory() override;
    explicit PROTOBUF_CONSTEXPR HealthDataHistory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    HealthDataHistory(const HealthDataHistory& from);
    HealthDataHistory(HealthDataHistory&& from) noexcept
        : HealthDataHistory()
    {
        *this = ::std::move(from);
    }

    inline HealthDataHistory& operator=(const HealthDataHistory& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline HealthDataHistory& operator=(HealthDataHistory&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const HealthDataHistory& default_instance()
    {
        return *internal_default_instance();
    }
    enum RecordCase {
        kEnqueueRecordCall = 1,
        kFlushPriorityCall = 2,
        kUploadEncryptedRecordCall = 3,
        kConfirmRecordUploadCall = 4,
        kStorageQueueAction = 5,
        kBlockedRecordCall = 7,
        kBlockedDestinationsUpdatedCall = 8,
        RECORD_NOT_SET = 0,
    };

    static inline const HealthDataHistory* internal_default_instance()
    {
        return reinterpret_cast<const HealthDataHistory*>(&_HealthDataHistory_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 12;

    friend void swap(HealthDataHistory& a, HealthDataHistory& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(HealthDataHistory* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(HealthDataHistory* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    HealthDataHistory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<HealthDataHistory>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const HealthDataHistory& from);
    void MergeFrom(const HealthDataHistory& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(HealthDataHistory* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.HealthDataHistory";
    }

protected:
    explicit HealthDataHistory(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTimestampSecondsFieldNumber = 6,
        kEnqueueRecordCallFieldNumber = 1,
        kFlushPriorityCallFieldNumber = 2,
        kUploadEncryptedRecordCallFieldNumber = 3,
        kConfirmRecordUploadCallFieldNumber = 4,
        kStorageQueueActionFieldNumber = 5,
        kBlockedRecordCallFieldNumber = 7,
        kBlockedDestinationsUpdatedCallFieldNumber = 8,
    };
    // optional int64 timestamp_seconds = 6;
    bool has_timestamp_seconds() const;

private:
    bool _internal_has_timestamp_seconds() const;

public:
    void clear_timestamp_seconds();
    int64_t timestamp_seconds() const;
    void set_timestamp_seconds(int64_t value);

private:
    int64_t _internal_timestamp_seconds() const;
    void _internal_set_timestamp_seconds(int64_t value);

public:
    // .reporting.EnqueueRecordCall enqueue_record_call = 1;
    bool has_enqueue_record_call() const;

private:
    bool _internal_has_enqueue_record_call() const;

public:
    void clear_enqueue_record_call();
    const ::reporting::EnqueueRecordCall& enqueue_record_call() const;
    PROTOBUF_NODISCARD ::reporting::EnqueueRecordCall* release_enqueue_record_call();
    ::reporting::EnqueueRecordCall* mutable_enqueue_record_call();
    void set_allocated_enqueue_record_call(::reporting::EnqueueRecordCall* enqueue_record_call);

private:
    const ::reporting::EnqueueRecordCall& _internal_enqueue_record_call() const;
    ::reporting::EnqueueRecordCall* _internal_mutable_enqueue_record_call();

public:
    void unsafe_arena_set_allocated_enqueue_record_call(::reporting::EnqueueRecordCall* enqueue_record_call);
    ::reporting::EnqueueRecordCall* unsafe_arena_release_enqueue_record_call();

    // .reporting.FlushPriorityCall flush_priority_call = 2;
    bool has_flush_priority_call() const;

private:
    bool _internal_has_flush_priority_call() const;

public:
    void clear_flush_priority_call();
    const ::reporting::FlushPriorityCall& flush_priority_call() const;
    PROTOBUF_NODISCARD ::reporting::FlushPriorityCall* release_flush_priority_call();
    ::reporting::FlushPriorityCall* mutable_flush_priority_call();
    void set_allocated_flush_priority_call(::reporting::FlushPriorityCall* flush_priority_call);

private:
    const ::reporting::FlushPriorityCall& _internal_flush_priority_call() const;
    ::reporting::FlushPriorityCall* _internal_mutable_flush_priority_call();

public:
    void unsafe_arena_set_allocated_flush_priority_call(::reporting::FlushPriorityCall* flush_priority_call);
    ::reporting::FlushPriorityCall* unsafe_arena_release_flush_priority_call();

    // .reporting.UploadEncryptedRecordCall upload_encrypted_record_call = 3;
    bool has_upload_encrypted_record_call() const;

private:
    bool _internal_has_upload_encrypted_record_call() const;

public:
    void clear_upload_encrypted_record_call();
    const ::reporting::UploadEncryptedRecordCall& upload_encrypted_record_call() const;
    PROTOBUF_NODISCARD ::reporting::UploadEncryptedRecordCall* release_upload_encrypted_record_call();
    ::reporting::UploadEncryptedRecordCall* mutable_upload_encrypted_record_call();
    void set_allocated_upload_encrypted_record_call(::reporting::UploadEncryptedRecordCall* upload_encrypted_record_call);

private:
    const ::reporting::UploadEncryptedRecordCall& _internal_upload_encrypted_record_call() const;
    ::reporting::UploadEncryptedRecordCall* _internal_mutable_upload_encrypted_record_call();

public:
    void unsafe_arena_set_allocated_upload_encrypted_record_call(::reporting::UploadEncryptedRecordCall* upload_encrypted_record_call);
    ::reporting::UploadEncryptedRecordCall* unsafe_arena_release_upload_encrypted_record_call();

    // .reporting.ConfirmRecordUploadCall confirm_record_upload_call = 4;
    bool has_confirm_record_upload_call() const;

private:
    bool _internal_has_confirm_record_upload_call() const;

public:
    void clear_confirm_record_upload_call();
    const ::reporting::ConfirmRecordUploadCall& confirm_record_upload_call() const;
    PROTOBUF_NODISCARD ::reporting::ConfirmRecordUploadCall* release_confirm_record_upload_call();
    ::reporting::ConfirmRecordUploadCall* mutable_confirm_record_upload_call();
    void set_allocated_confirm_record_upload_call(::reporting::ConfirmRecordUploadCall* confirm_record_upload_call);

private:
    const ::reporting::ConfirmRecordUploadCall& _internal_confirm_record_upload_call() const;
    ::reporting::ConfirmRecordUploadCall* _internal_mutable_confirm_record_upload_call();

public:
    void unsafe_arena_set_allocated_confirm_record_upload_call(::reporting::ConfirmRecordUploadCall* confirm_record_upload_call);
    ::reporting::ConfirmRecordUploadCall* unsafe_arena_release_confirm_record_upload_call();

    // .reporting.StorageQueueAction storage_queue_action = 5;
    bool has_storage_queue_action() const;

private:
    bool _internal_has_storage_queue_action() const;

public:
    void clear_storage_queue_action();
    const ::reporting::StorageQueueAction& storage_queue_action() const;
    PROTOBUF_NODISCARD ::reporting::StorageQueueAction* release_storage_queue_action();
    ::reporting::StorageQueueAction* mutable_storage_queue_action();
    void set_allocated_storage_queue_action(::reporting::StorageQueueAction* storage_queue_action);

private:
    const ::reporting::StorageQueueAction& _internal_storage_queue_action() const;
    ::reporting::StorageQueueAction* _internal_mutable_storage_queue_action();

public:
    void unsafe_arena_set_allocated_storage_queue_action(::reporting::StorageQueueAction* storage_queue_action);
    ::reporting::StorageQueueAction* unsafe_arena_release_storage_queue_action();

    // .reporting.BlockedRecordCall blocked_record_call = 7;
    bool has_blocked_record_call() const;

private:
    bool _internal_has_blocked_record_call() const;

public:
    void clear_blocked_record_call();
    const ::reporting::BlockedRecordCall& blocked_record_call() const;
    PROTOBUF_NODISCARD ::reporting::BlockedRecordCall* release_blocked_record_call();
    ::reporting::BlockedRecordCall* mutable_blocked_record_call();
    void set_allocated_blocked_record_call(::reporting::BlockedRecordCall* blocked_record_call);

private:
    const ::reporting::BlockedRecordCall& _internal_blocked_record_call() const;
    ::reporting::BlockedRecordCall* _internal_mutable_blocked_record_call();

public:
    void unsafe_arena_set_allocated_blocked_record_call(::reporting::BlockedRecordCall* blocked_record_call);
    ::reporting::BlockedRecordCall* unsafe_arena_release_blocked_record_call();

    // .reporting.BlockedDestinationsUpdatedCall blocked_destinations_updated_call = 8;
    bool has_blocked_destinations_updated_call() const;

private:
    bool _internal_has_blocked_destinations_updated_call() const;

public:
    void clear_blocked_destinations_updated_call();
    const ::reporting::BlockedDestinationsUpdatedCall& blocked_destinations_updated_call() const;
    PROTOBUF_NODISCARD ::reporting::BlockedDestinationsUpdatedCall* release_blocked_destinations_updated_call();
    ::reporting::BlockedDestinationsUpdatedCall* mutable_blocked_destinations_updated_call();
    void set_allocated_blocked_destinations_updated_call(::reporting::BlockedDestinationsUpdatedCall* blocked_destinations_updated_call);

private:
    const ::reporting::BlockedDestinationsUpdatedCall& _internal_blocked_destinations_updated_call() const;
    ::reporting::BlockedDestinationsUpdatedCall* _internal_mutable_blocked_destinations_updated_call();

public:
    void unsafe_arena_set_allocated_blocked_destinations_updated_call(::reporting::BlockedDestinationsUpdatedCall* blocked_destinations_updated_call);
    ::reporting::BlockedDestinationsUpdatedCall* unsafe_arena_release_blocked_destinations_updated_call();

    void clear_record();
    RecordCase record_case() const;
    // @@protoc_insertion_point(class_scope:reporting.HealthDataHistory)
private:
    class _Internal;
    void set_has_enqueue_record_call();
    void set_has_flush_priority_call();
    void set_has_upload_encrypted_record_call();
    void set_has_confirm_record_upload_call();
    void set_has_storage_queue_action();
    void set_has_blocked_record_call();
    void set_has_blocked_destinations_updated_call();

    inline bool has_record() const;
    inline void clear_has_record();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int64_t timestamp_seconds_;
        union RecordUnion {
            constexpr RecordUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::reporting::EnqueueRecordCall* enqueue_record_call_;
            ::reporting::FlushPriorityCall* flush_priority_call_;
            ::reporting::UploadEncryptedRecordCall* upload_encrypted_record_call_;
            ::reporting::ConfirmRecordUploadCall* confirm_record_upload_call_;
            ::reporting::StorageQueueAction* storage_queue_action_;
            ::reporting::BlockedRecordCall* blocked_record_call_;
            ::reporting::BlockedDestinationsUpdatedCall* blocked_destinations_updated_call_;
        } record_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto;
};
// -------------------------------------------------------------------

class ERPHealthData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.ERPHealthData) */ {
public:
    inline ERPHealthData()
        : ERPHealthData(nullptr)
    {
    }
    ~ERPHealthData() override;
    explicit PROTOBUF_CONSTEXPR ERPHealthData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ERPHealthData(const ERPHealthData& from);
    ERPHealthData(ERPHealthData&& from) noexcept
        : ERPHealthData()
    {
        *this = ::std::move(from);
    }

    inline ERPHealthData& operator=(const ERPHealthData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ERPHealthData& operator=(ERPHealthData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ERPHealthData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ERPHealthData* internal_default_instance()
    {
        return reinterpret_cast<const ERPHealthData*>(&_ERPHealthData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 13;

    friend void swap(ERPHealthData& a, ERPHealthData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ERPHealthData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ERPHealthData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ERPHealthData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ERPHealthData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ERPHealthData& from);
    void MergeFrom(const ERPHealthData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ERPHealthData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.ERPHealthData";
    }

protected:
    explicit ERPHealthData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kHistoryFieldNumber = 1,
    };
    // repeated .reporting.HealthDataHistory history = 1;
    int history_size() const;

private:
    int _internal_history_size() const;

public:
    void clear_history();
    ::reporting::HealthDataHistory* mutable_history(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::HealthDataHistory>* mutable_history();

private:
    const ::reporting::HealthDataHistory& _internal_history(int index) const;
    ::reporting::HealthDataHistory* _internal_add_history();

public:
    const ::reporting::HealthDataHistory& history(int index) const;
    ::reporting::HealthDataHistory* add_history();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::HealthDataHistory>& history() const;

    // @@protoc_insertion_point(class_scope:reporting.ERPHealthData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::HealthDataHistory> history_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fhealth_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// StorageDequeue

// optional int64 sequencing_id = 1;
inline bool StorageDequeue::_internal_has_sequencing_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool StorageDequeue::has_sequencing_id() const
{
    return _internal_has_sequencing_id();
}
inline void StorageDequeue::clear_sequencing_id()
{
    _impl_.sequencing_id_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t StorageDequeue::_internal_sequencing_id() const
{
    return _impl_.sequencing_id_;
}
inline int64_t StorageDequeue::sequencing_id() const
{
    // @@protoc_insertion_point(field_get:reporting.StorageDequeue.sequencing_id)
    return _internal_sequencing_id();
}
inline void StorageDequeue::_internal_set_sequencing_id(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.sequencing_id_ = value;
}
inline void StorageDequeue::set_sequencing_id(int64_t value)
{
    _internal_set_sequencing_id(value);
    // @@protoc_insertion_point(field_set:reporting.StorageDequeue.sequencing_id)
}

// optional int64 records_count = 2;
inline bool StorageDequeue::_internal_has_records_count() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool StorageDequeue::has_records_count() const
{
    return _internal_has_records_count();
}
inline void StorageDequeue::clear_records_count()
{
    _impl_.records_count_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t StorageDequeue::_internal_records_count() const
{
    return _impl_.records_count_;
}
inline int64_t StorageDequeue::records_count() const
{
    // @@protoc_insertion_point(field_get:reporting.StorageDequeue.records_count)
    return _internal_records_count();
}
inline void StorageDequeue::_internal_set_records_count(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.records_count_ = value;
}
inline void StorageDequeue::set_records_count(int64_t value)
{
    _internal_set_records_count(value);
    // @@protoc_insertion_point(field_set:reporting.StorageDequeue.records_count)
}

// -------------------------------------------------------------------

// StorageEnqueue

// optional int64 sequencing_id = 1;
inline bool StorageEnqueue::_internal_has_sequencing_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool StorageEnqueue::has_sequencing_id() const
{
    return _internal_has_sequencing_id();
}
inline void StorageEnqueue::clear_sequencing_id()
{
    _impl_.sequencing_id_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t StorageEnqueue::_internal_sequencing_id() const
{
    return _impl_.sequencing_id_;
}
inline int64_t StorageEnqueue::sequencing_id() const
{
    // @@protoc_insertion_point(field_get:reporting.StorageEnqueue.sequencing_id)
    return _internal_sequencing_id();
}
inline void StorageEnqueue::_internal_set_sequencing_id(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.sequencing_id_ = value;
}
inline void StorageEnqueue::set_sequencing_id(int64_t value)
{
    _internal_set_sequencing_id(value);
    // @@protoc_insertion_point(field_set:reporting.StorageEnqueue.sequencing_id)
}

// -------------------------------------------------------------------

// StorageQueueAction

// .reporting.StorageDequeue storage_dequeue = 1;
inline bool StorageQueueAction::_internal_has_storage_dequeue() const
{
    return action_case() == kStorageDequeue;
}
inline bool StorageQueueAction::has_storage_dequeue() const
{
    return _internal_has_storage_dequeue();
}
inline void StorageQueueAction::set_has_storage_dequeue()
{
    _impl_._oneof_case_[0] = kStorageDequeue;
}
inline void StorageQueueAction::clear_storage_dequeue()
{
    if (_internal_has_storage_dequeue()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.storage_dequeue_;
        }
        clear_has_action();
    }
}
inline ::reporting::StorageDequeue* StorageQueueAction::release_storage_dequeue()
{
    // @@protoc_insertion_point(field_release:reporting.StorageQueueAction.storage_dequeue)
    if (_internal_has_storage_dequeue()) {
        clear_has_action();
        ::reporting::StorageDequeue* temp = _impl_.action_.storage_dequeue_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.action_.storage_dequeue_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::StorageDequeue& StorageQueueAction::_internal_storage_dequeue() const
{
    return _internal_has_storage_dequeue() ? *_impl_.action_.storage_dequeue_
                                           : reinterpret_cast<::reporting::StorageDequeue&>(::reporting::_StorageDequeue_default_instance_);
}
inline const ::reporting::StorageDequeue& StorageQueueAction::storage_dequeue() const
{
    // @@protoc_insertion_point(field_get:reporting.StorageQueueAction.storage_dequeue)
    return _internal_storage_dequeue();
}
inline ::reporting::StorageDequeue* StorageQueueAction::unsafe_arena_release_storage_dequeue()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.StorageQueueAction.storage_dequeue)
    if (_internal_has_storage_dequeue()) {
        clear_has_action();
        ::reporting::StorageDequeue* temp = _impl_.action_.storage_dequeue_;
        _impl_.action_.storage_dequeue_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void StorageQueueAction::unsafe_arena_set_allocated_storage_dequeue(::reporting::StorageDequeue* storage_dequeue)
{
    clear_action();
    if (storage_dequeue) {
        set_has_storage_dequeue();
        _impl_.action_.storage_dequeue_ = storage_dequeue;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.StorageQueueAction.storage_dequeue)
}
inline ::reporting::StorageDequeue* StorageQueueAction::_internal_mutable_storage_dequeue()
{
    if (!_internal_has_storage_dequeue()) {
        clear_action();
        set_has_storage_dequeue();
        _impl_.action_.storage_dequeue_ = CreateMaybeMessage<::reporting::StorageDequeue>(GetArenaForAllocation());
    }
    return _impl_.action_.storage_dequeue_;
}
inline ::reporting::StorageDequeue* StorageQueueAction::mutable_storage_dequeue()
{
    ::reporting::StorageDequeue* _msg = _internal_mutable_storage_dequeue();
    // @@protoc_insertion_point(field_mutable:reporting.StorageQueueAction.storage_dequeue)
    return _msg;
}

// .reporting.StorageEnqueue storage_enqueue = 2;
inline bool StorageQueueAction::_internal_has_storage_enqueue() const
{
    return action_case() == kStorageEnqueue;
}
inline bool StorageQueueAction::has_storage_enqueue() const
{
    return _internal_has_storage_enqueue();
}
inline void StorageQueueAction::set_has_storage_enqueue()
{
    _impl_._oneof_case_[0] = kStorageEnqueue;
}
inline void StorageQueueAction::clear_storage_enqueue()
{
    if (_internal_has_storage_enqueue()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.action_.storage_enqueue_;
        }
        clear_has_action();
    }
}
inline ::reporting::StorageEnqueue* StorageQueueAction::release_storage_enqueue()
{
    // @@protoc_insertion_point(field_release:reporting.StorageQueueAction.storage_enqueue)
    if (_internal_has_storage_enqueue()) {
        clear_has_action();
        ::reporting::StorageEnqueue* temp = _impl_.action_.storage_enqueue_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.action_.storage_enqueue_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::StorageEnqueue& StorageQueueAction::_internal_storage_enqueue() const
{
    return _internal_has_storage_enqueue() ? *_impl_.action_.storage_enqueue_
                                           : reinterpret_cast<::reporting::StorageEnqueue&>(::reporting::_StorageEnqueue_default_instance_);
}
inline const ::reporting::StorageEnqueue& StorageQueueAction::storage_enqueue() const
{
    // @@protoc_insertion_point(field_get:reporting.StorageQueueAction.storage_enqueue)
    return _internal_storage_enqueue();
}
inline ::reporting::StorageEnqueue* StorageQueueAction::unsafe_arena_release_storage_enqueue()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.StorageQueueAction.storage_enqueue)
    if (_internal_has_storage_enqueue()) {
        clear_has_action();
        ::reporting::StorageEnqueue* temp = _impl_.action_.storage_enqueue_;
        _impl_.action_.storage_enqueue_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void StorageQueueAction::unsafe_arena_set_allocated_storage_enqueue(::reporting::StorageEnqueue* storage_enqueue)
{
    clear_action();
    if (storage_enqueue) {
        set_has_storage_enqueue();
        _impl_.action_.storage_enqueue_ = storage_enqueue;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.StorageQueueAction.storage_enqueue)
}
inline ::reporting::StorageEnqueue* StorageQueueAction::_internal_mutable_storage_enqueue()
{
    if (!_internal_has_storage_enqueue()) {
        clear_action();
        set_has_storage_enqueue();
        _impl_.action_.storage_enqueue_ = CreateMaybeMessage<::reporting::StorageEnqueue>(GetArenaForAllocation());
    }
    return _impl_.action_.storage_enqueue_;
}
inline ::reporting::StorageEnqueue* StorageQueueAction::mutable_storage_enqueue()
{
    ::reporting::StorageEnqueue* _msg = _internal_mutable_storage_enqueue();
    // @@protoc_insertion_point(field_mutable:reporting.StorageQueueAction.storage_enqueue)
    return _msg;
}

// optional .reporting.Priority priority = 3;
inline bool StorageQueueAction::_internal_has_priority() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool StorageQueueAction::has_priority() const
{
    return _internal_has_priority();
}
inline void StorageQueueAction::clear_priority()
{
    _impl_.priority_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::reporting::Priority StorageQueueAction::_internal_priority() const
{
    return static_cast<::reporting::Priority>(_impl_.priority_);
}
inline ::reporting::Priority StorageQueueAction::priority() const
{
    // @@protoc_insertion_point(field_get:reporting.StorageQueueAction.priority)
    return _internal_priority();
}
inline void StorageQueueAction::_internal_set_priority(::reporting::Priority value)
{
    assert(::reporting::Priority_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.priority_ = value;
}
inline void StorageQueueAction::set_priority(::reporting::Priority value)
{
    _internal_set_priority(value);
    // @@protoc_insertion_point(field_set:reporting.StorageQueueAction.priority)
}

// optional .reporting.StatusProto status = 4;
inline bool StorageQueueAction::_internal_has_status() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
    return value;
}
inline bool StorageQueueAction::has_status() const
{
    return _internal_has_status();
}
inline const ::reporting::StatusProto& StorageQueueAction::_internal_status() const
{
    const ::reporting::StatusProto* p = _impl_.status_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::StatusProto&>(::reporting::_StatusProto_default_instance_);
}
inline const ::reporting::StatusProto& StorageQueueAction::status() const
{
    // @@protoc_insertion_point(field_get:reporting.StorageQueueAction.status)
    return _internal_status();
}
inline void StorageQueueAction::unsafe_arena_set_allocated_status(::reporting::StatusProto* status)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
    }
    _impl_.status_ = status;
    if (status) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.StorageQueueAction.status)
}
inline ::reporting::StatusProto* StorageQueueAction::release_status()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::StatusProto* temp = _impl_.status_;
    _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::StatusProto* StorageQueueAction::unsafe_arena_release_status()
{
    // @@protoc_insertion_point(field_release:reporting.StorageQueueAction.status)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::StatusProto* temp = _impl_.status_;
    _impl_.status_ = nullptr;
    return temp;
}
inline ::reporting::StatusProto* StorageQueueAction::_internal_mutable_status()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.status_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::StatusProto>(GetArenaForAllocation());
        _impl_.status_ = p;
    }
    return _impl_.status_;
}
inline ::reporting::StatusProto* StorageQueueAction::mutable_status()
{
    ::reporting::StatusProto* _msg = _internal_mutable_status();
    // @@protoc_insertion_point(field_mutable:reporting.StorageQueueAction.status)
    return _msg;
}
inline void StorageQueueAction::set_allocated_status(::reporting::StatusProto* status)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
    }
    if (status) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
        if (message_arena != submessage_arena) {
            status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, status, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.status_ = status;
    // @@protoc_insertion_point(field_set_allocated:reporting.StorageQueueAction.status)
}

inline bool StorageQueueAction::has_action() const
{
    return action_case() != ACTION_NOT_SET;
}
inline void StorageQueueAction::clear_has_action()
{
    _impl_._oneof_case_[0] = ACTION_NOT_SET;
}
inline StorageQueueAction::ActionCase StorageQueueAction::action_case() const
{
    return StorageQueueAction::ActionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EnqueueRecordCall

// optional .reporting.Priority priority = 1;
inline bool EnqueueRecordCall::_internal_has_priority() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool EnqueueRecordCall::has_priority() const
{
    return _internal_has_priority();
}
inline void EnqueueRecordCall::clear_priority()
{
    _impl_.priority_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::reporting::Priority EnqueueRecordCall::_internal_priority() const
{
    return static_cast<::reporting::Priority>(_impl_.priority_);
}
inline ::reporting::Priority EnqueueRecordCall::priority() const
{
    // @@protoc_insertion_point(field_get:reporting.EnqueueRecordCall.priority)
    return _internal_priority();
}
inline void EnqueueRecordCall::_internal_set_priority(::reporting::Priority value)
{
    assert(::reporting::Priority_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.priority_ = value;
}
inline void EnqueueRecordCall::set_priority(::reporting::Priority value)
{
    _internal_set_priority(value);
    // @@protoc_insertion_point(field_set:reporting.EnqueueRecordCall.priority)
}

// optional .reporting.Destination destination = 2;
inline bool EnqueueRecordCall::_internal_has_destination() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool EnqueueRecordCall::has_destination() const
{
    return _internal_has_destination();
}
inline void EnqueueRecordCall::clear_destination()
{
    _impl_.destination_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::reporting::Destination EnqueueRecordCall::_internal_destination() const
{
    return static_cast<::reporting::Destination>(_impl_.destination_);
}
inline ::reporting::Destination EnqueueRecordCall::destination() const
{
    // @@protoc_insertion_point(field_get:reporting.EnqueueRecordCall.destination)
    return _internal_destination();
}
inline void EnqueueRecordCall::_internal_set_destination(::reporting::Destination value)
{
    assert(::reporting::Destination_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.destination_ = value;
}
inline void EnqueueRecordCall::set_destination(::reporting::Destination value)
{
    _internal_set_destination(value);
    // @@protoc_insertion_point(field_set:reporting.EnqueueRecordCall.destination)
}

// optional .reporting.StatusProto status = 3;
inline bool EnqueueRecordCall::_internal_has_status() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
    return value;
}
inline bool EnqueueRecordCall::has_status() const
{
    return _internal_has_status();
}
inline const ::reporting::StatusProto& EnqueueRecordCall::_internal_status() const
{
    const ::reporting::StatusProto* p = _impl_.status_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::StatusProto&>(::reporting::_StatusProto_default_instance_);
}
inline const ::reporting::StatusProto& EnqueueRecordCall::status() const
{
    // @@protoc_insertion_point(field_get:reporting.EnqueueRecordCall.status)
    return _internal_status();
}
inline void EnqueueRecordCall::unsafe_arena_set_allocated_status(::reporting::StatusProto* status)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
    }
    _impl_.status_ = status;
    if (status) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.EnqueueRecordCall.status)
}
inline ::reporting::StatusProto* EnqueueRecordCall::release_status()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::StatusProto* temp = _impl_.status_;
    _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::StatusProto* EnqueueRecordCall::unsafe_arena_release_status()
{
    // @@protoc_insertion_point(field_release:reporting.EnqueueRecordCall.status)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::StatusProto* temp = _impl_.status_;
    _impl_.status_ = nullptr;
    return temp;
}
inline ::reporting::StatusProto* EnqueueRecordCall::_internal_mutable_status()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.status_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::StatusProto>(GetArenaForAllocation());
        _impl_.status_ = p;
    }
    return _impl_.status_;
}
inline ::reporting::StatusProto* EnqueueRecordCall::mutable_status()
{
    ::reporting::StatusProto* _msg = _internal_mutable_status();
    // @@protoc_insertion_point(field_mutable:reporting.EnqueueRecordCall.status)
    return _msg;
}
inline void EnqueueRecordCall::set_allocated_status(::reporting::StatusProto* status)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
    }
    if (status) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
        if (message_arena != submessage_arena) {
            status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, status, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.status_ = status;
    // @@protoc_insertion_point(field_set_allocated:reporting.EnqueueRecordCall.status)
}

// -------------------------------------------------------------------

// FlushPriorityCall

// optional .reporting.Priority priority = 1;
inline bool FlushPriorityCall::_internal_has_priority() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool FlushPriorityCall::has_priority() const
{
    return _internal_has_priority();
}
inline void FlushPriorityCall::clear_priority()
{
    _impl_.priority_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::reporting::Priority FlushPriorityCall::_internal_priority() const
{
    return static_cast<::reporting::Priority>(_impl_.priority_);
}
inline ::reporting::Priority FlushPriorityCall::priority() const
{
    // @@protoc_insertion_point(field_get:reporting.FlushPriorityCall.priority)
    return _internal_priority();
}
inline void FlushPriorityCall::_internal_set_priority(::reporting::Priority value)
{
    assert(::reporting::Priority_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.priority_ = value;
}
inline void FlushPriorityCall::set_priority(::reporting::Priority value)
{
    _internal_set_priority(value);
    // @@protoc_insertion_point(field_set:reporting.FlushPriorityCall.priority)
}

// optional .reporting.StatusProto status = 2;
inline bool FlushPriorityCall::_internal_has_status() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
    return value;
}
inline bool FlushPriorityCall::has_status() const
{
    return _internal_has_status();
}
inline const ::reporting::StatusProto& FlushPriorityCall::_internal_status() const
{
    const ::reporting::StatusProto* p = _impl_.status_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::StatusProto&>(::reporting::_StatusProto_default_instance_);
}
inline const ::reporting::StatusProto& FlushPriorityCall::status() const
{
    // @@protoc_insertion_point(field_get:reporting.FlushPriorityCall.status)
    return _internal_status();
}
inline void FlushPriorityCall::unsafe_arena_set_allocated_status(::reporting::StatusProto* status)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
    }
    _impl_.status_ = status;
    if (status) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.FlushPriorityCall.status)
}
inline ::reporting::StatusProto* FlushPriorityCall::release_status()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::StatusProto* temp = _impl_.status_;
    _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::StatusProto* FlushPriorityCall::unsafe_arena_release_status()
{
    // @@protoc_insertion_point(field_release:reporting.FlushPriorityCall.status)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::StatusProto* temp = _impl_.status_;
    _impl_.status_ = nullptr;
    return temp;
}
inline ::reporting::StatusProto* FlushPriorityCall::_internal_mutable_status()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.status_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::StatusProto>(GetArenaForAllocation());
        _impl_.status_ = p;
    }
    return _impl_.status_;
}
inline ::reporting::StatusProto* FlushPriorityCall::mutable_status()
{
    ::reporting::StatusProto* _msg = _internal_mutable_status();
    // @@protoc_insertion_point(field_mutable:reporting.FlushPriorityCall.status)
    return _msg;
}
inline void FlushPriorityCall::set_allocated_status(::reporting::StatusProto* status)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
    }
    if (status) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
        if (message_arena != submessage_arena) {
            status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, status, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.status_ = status;
    // @@protoc_insertion_point(field_set_allocated:reporting.FlushPriorityCall.status)
}

// -------------------------------------------------------------------

// UploadRecordItem

// optional int64 sequencing_id = 1;
inline bool UploadRecordItem::_internal_has_sequencing_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool UploadRecordItem::has_sequencing_id() const
{
    return _internal_has_sequencing_id();
}
inline void UploadRecordItem::clear_sequencing_id()
{
    _impl_.sequencing_id_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t UploadRecordItem::_internal_sequencing_id() const
{
    return _impl_.sequencing_id_;
}
inline int64_t UploadRecordItem::sequencing_id() const
{
    // @@protoc_insertion_point(field_get:reporting.UploadRecordItem.sequencing_id)
    return _internal_sequencing_id();
}
inline void UploadRecordItem::_internal_set_sequencing_id(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.sequencing_id_ = value;
}
inline void UploadRecordItem::set_sequencing_id(int64_t value)
{
    _internal_set_sequencing_id(value);
    // @@protoc_insertion_point(field_set:reporting.UploadRecordItem.sequencing_id)
}

// -------------------------------------------------------------------

// UploadGapItem

// optional int64 sequencing_id = 1;
inline bool UploadGapItem::_internal_has_sequencing_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool UploadGapItem::has_sequencing_id() const
{
    return _internal_has_sequencing_id();
}
inline void UploadGapItem::clear_sequencing_id()
{
    _impl_.sequencing_id_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t UploadGapItem::_internal_sequencing_id() const
{
    return _impl_.sequencing_id_;
}
inline int64_t UploadGapItem::sequencing_id() const
{
    // @@protoc_insertion_point(field_get:reporting.UploadGapItem.sequencing_id)
    return _internal_sequencing_id();
}
inline void UploadGapItem::_internal_set_sequencing_id(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.sequencing_id_ = value;
}
inline void UploadGapItem::set_sequencing_id(int64_t value)
{
    _internal_set_sequencing_id(value);
    // @@protoc_insertion_point(field_set:reporting.UploadGapItem.sequencing_id)
}

// optional int64 count = 2;
inline bool UploadGapItem::_internal_has_count() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool UploadGapItem::has_count() const
{
    return _internal_has_count();
}
inline void UploadGapItem::clear_count()
{
    _impl_.count_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t UploadGapItem::_internal_count() const
{
    return _impl_.count_;
}
inline int64_t UploadGapItem::count() const
{
    // @@protoc_insertion_point(field_get:reporting.UploadGapItem.count)
    return _internal_count();
}
inline void UploadGapItem::_internal_set_count(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.count_ = value;
}
inline void UploadGapItem::set_count(int64_t value)
{
    _internal_set_count(value);
    // @@protoc_insertion_point(field_set:reporting.UploadGapItem.count)
}

// -------------------------------------------------------------------

// UploadItem

// .reporting.UploadRecordItem record = 1;
inline bool UploadItem::_internal_has_record() const
{
    return item_case() == kRecord;
}
inline bool UploadItem::has_record() const
{
    return _internal_has_record();
}
inline void UploadItem::set_has_record()
{
    _impl_._oneof_case_[0] = kRecord;
}
inline void UploadItem::clear_record()
{
    if (_internal_has_record()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.item_.record_;
        }
        clear_has_item();
    }
}
inline ::reporting::UploadRecordItem* UploadItem::release_record()
{
    // @@protoc_insertion_point(field_release:reporting.UploadItem.record)
    if (_internal_has_record()) {
        clear_has_item();
        ::reporting::UploadRecordItem* temp = _impl_.item_.record_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.item_.record_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::UploadRecordItem& UploadItem::_internal_record() const
{
    return _internal_has_record() ? *_impl_.item_.record_ : reinterpret_cast<::reporting::UploadRecordItem&>(::reporting::_UploadRecordItem_default_instance_);
}
inline const ::reporting::UploadRecordItem& UploadItem::record() const
{
    // @@protoc_insertion_point(field_get:reporting.UploadItem.record)
    return _internal_record();
}
inline ::reporting::UploadRecordItem* UploadItem::unsafe_arena_release_record()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.UploadItem.record)
    if (_internal_has_record()) {
        clear_has_item();
        ::reporting::UploadRecordItem* temp = _impl_.item_.record_;
        _impl_.item_.record_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void UploadItem::unsafe_arena_set_allocated_record(::reporting::UploadRecordItem* record)
{
    clear_item();
    if (record) {
        set_has_record();
        _impl_.item_.record_ = record;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.UploadItem.record)
}
inline ::reporting::UploadRecordItem* UploadItem::_internal_mutable_record()
{
    if (!_internal_has_record()) {
        clear_item();
        set_has_record();
        _impl_.item_.record_ = CreateMaybeMessage<::reporting::UploadRecordItem>(GetArenaForAllocation());
    }
    return _impl_.item_.record_;
}
inline ::reporting::UploadRecordItem* UploadItem::mutable_record()
{
    ::reporting::UploadRecordItem* _msg = _internal_mutable_record();
    // @@protoc_insertion_point(field_mutable:reporting.UploadItem.record)
    return _msg;
}

// .reporting.UploadGapItem gap = 2;
inline bool UploadItem::_internal_has_gap() const
{
    return item_case() == kGap;
}
inline bool UploadItem::has_gap() const
{
    return _internal_has_gap();
}
inline void UploadItem::set_has_gap()
{
    _impl_._oneof_case_[0] = kGap;
}
inline void UploadItem::clear_gap()
{
    if (_internal_has_gap()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.item_.gap_;
        }
        clear_has_item();
    }
}
inline ::reporting::UploadGapItem* UploadItem::release_gap()
{
    // @@protoc_insertion_point(field_release:reporting.UploadItem.gap)
    if (_internal_has_gap()) {
        clear_has_item();
        ::reporting::UploadGapItem* temp = _impl_.item_.gap_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.item_.gap_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::UploadGapItem& UploadItem::_internal_gap() const
{
    return _internal_has_gap() ? *_impl_.item_.gap_ : reinterpret_cast<::reporting::UploadGapItem&>(::reporting::_UploadGapItem_default_instance_);
}
inline const ::reporting::UploadGapItem& UploadItem::gap() const
{
    // @@protoc_insertion_point(field_get:reporting.UploadItem.gap)
    return _internal_gap();
}
inline ::reporting::UploadGapItem* UploadItem::unsafe_arena_release_gap()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.UploadItem.gap)
    if (_internal_has_gap()) {
        clear_has_item();
        ::reporting::UploadGapItem* temp = _impl_.item_.gap_;
        _impl_.item_.gap_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void UploadItem::unsafe_arena_set_allocated_gap(::reporting::UploadGapItem* gap)
{
    clear_item();
    if (gap) {
        set_has_gap();
        _impl_.item_.gap_ = gap;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.UploadItem.gap)
}
inline ::reporting::UploadGapItem* UploadItem::_internal_mutable_gap()
{
    if (!_internal_has_gap()) {
        clear_item();
        set_has_gap();
        _impl_.item_.gap_ = CreateMaybeMessage<::reporting::UploadGapItem>(GetArenaForAllocation());
    }
    return _impl_.item_.gap_;
}
inline ::reporting::UploadGapItem* UploadItem::mutable_gap()
{
    ::reporting::UploadGapItem* _msg = _internal_mutable_gap();
    // @@protoc_insertion_point(field_mutable:reporting.UploadItem.gap)
    return _msg;
}

inline bool UploadItem::has_item() const
{
    return item_case() != ITEM_NOT_SET;
}
inline void UploadItem::clear_has_item()
{
    _impl_._oneof_case_[0] = ITEM_NOT_SET;
}
inline UploadItem::ItemCase UploadItem::item_case() const
{
    return UploadItem::ItemCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UploadEncryptedRecordCall

// repeated .reporting.UploadItem items = 1;
inline int UploadEncryptedRecordCall::_internal_items_size() const
{
    return _impl_.items_.size();
}
inline int UploadEncryptedRecordCall::items_size() const
{
    return _internal_items_size();
}
inline void UploadEncryptedRecordCall::clear_items()
{
    _impl_.items_.Clear();
}
inline ::reporting::UploadItem* UploadEncryptedRecordCall::mutable_items(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.UploadEncryptedRecordCall.items)
    return _impl_.items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::UploadItem>* UploadEncryptedRecordCall::mutable_items()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.UploadEncryptedRecordCall.items)
    return &_impl_.items_;
}
inline const ::reporting::UploadItem& UploadEncryptedRecordCall::_internal_items(int index) const
{
    return _impl_.items_.Get(index);
}
inline const ::reporting::UploadItem& UploadEncryptedRecordCall::items(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.UploadEncryptedRecordCall.items)
    return _internal_items(index);
}
inline ::reporting::UploadItem* UploadEncryptedRecordCall::_internal_add_items()
{
    return _impl_.items_.Add();
}
inline ::reporting::UploadItem* UploadEncryptedRecordCall::add_items()
{
    ::reporting::UploadItem* _add = _internal_add_items();
    // @@protoc_insertion_point(field_add:reporting.UploadEncryptedRecordCall.items)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::UploadItem>& UploadEncryptedRecordCall::items() const
{
    // @@protoc_insertion_point(field_list:reporting.UploadEncryptedRecordCall.items)
    return _impl_.items_;
}

// optional string upload_reason = 2;
inline bool UploadEncryptedRecordCall::_internal_has_upload_reason() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool UploadEncryptedRecordCall::has_upload_reason() const
{
    return _internal_has_upload_reason();
}
inline void UploadEncryptedRecordCall::clear_upload_reason()
{
    _impl_.upload_reason_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UploadEncryptedRecordCall::upload_reason() const
{
    // @@protoc_insertion_point(field_get:reporting.UploadEncryptedRecordCall.upload_reason)
    return _internal_upload_reason();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void UploadEncryptedRecordCall::set_upload_reason(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.upload_reason_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.UploadEncryptedRecordCall.upload_reason)
}
inline std::string* UploadEncryptedRecordCall::mutable_upload_reason()
{
    std::string* _s = _internal_mutable_upload_reason();
    // @@protoc_insertion_point(field_mutable:reporting.UploadEncryptedRecordCall.upload_reason)
    return _s;
}
inline const std::string& UploadEncryptedRecordCall::_internal_upload_reason() const
{
    return _impl_.upload_reason_.Get();
}
inline void UploadEncryptedRecordCall::_internal_set_upload_reason(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.upload_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* UploadEncryptedRecordCall::_internal_mutable_upload_reason()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.upload_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* UploadEncryptedRecordCall::release_upload_reason()
{
    // @@protoc_insertion_point(field_release:reporting.UploadEncryptedRecordCall.upload_reason)
    if (!_internal_has_upload_reason()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.upload_reason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.upload_reason_.IsDefault()) {
        _impl_.upload_reason_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void UploadEncryptedRecordCall::set_allocated_upload_reason(std::string* upload_reason)
{
    if (upload_reason != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.upload_reason_.SetAllocated(upload_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.upload_reason_.IsDefault()) {
        _impl_.upload_reason_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.UploadEncryptedRecordCall.upload_reason)
}

// optional .reporting.Priority priority = 3;
inline bool UploadEncryptedRecordCall::_internal_has_priority() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool UploadEncryptedRecordCall::has_priority() const
{
    return _internal_has_priority();
}
inline void UploadEncryptedRecordCall::clear_priority()
{
    _impl_.priority_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::reporting::Priority UploadEncryptedRecordCall::_internal_priority() const
{
    return static_cast<::reporting::Priority>(_impl_.priority_);
}
inline ::reporting::Priority UploadEncryptedRecordCall::priority() const
{
    // @@protoc_insertion_point(field_get:reporting.UploadEncryptedRecordCall.priority)
    return _internal_priority();
}
inline void UploadEncryptedRecordCall::_internal_set_priority(::reporting::Priority value)
{
    assert(::reporting::Priority_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.priority_ = value;
}
inline void UploadEncryptedRecordCall::set_priority(::reporting::Priority value)
{
    _internal_set_priority(value);
    // @@protoc_insertion_point(field_set:reporting.UploadEncryptedRecordCall.priority)
}

// optional .reporting.StatusProto status = 4;
inline bool UploadEncryptedRecordCall::_internal_has_status() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
    return value;
}
inline bool UploadEncryptedRecordCall::has_status() const
{
    return _internal_has_status();
}
inline const ::reporting::StatusProto& UploadEncryptedRecordCall::_internal_status() const
{
    const ::reporting::StatusProto* p = _impl_.status_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::StatusProto&>(::reporting::_StatusProto_default_instance_);
}
inline const ::reporting::StatusProto& UploadEncryptedRecordCall::status() const
{
    // @@protoc_insertion_point(field_get:reporting.UploadEncryptedRecordCall.status)
    return _internal_status();
}
inline void UploadEncryptedRecordCall::unsafe_arena_set_allocated_status(::reporting::StatusProto* status)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
    }
    _impl_.status_ = status;
    if (status) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.UploadEncryptedRecordCall.status)
}
inline ::reporting::StatusProto* UploadEncryptedRecordCall::release_status()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::reporting::StatusProto* temp = _impl_.status_;
    _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::StatusProto* UploadEncryptedRecordCall::unsafe_arena_release_status()
{
    // @@protoc_insertion_point(field_release:reporting.UploadEncryptedRecordCall.status)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::reporting::StatusProto* temp = _impl_.status_;
    _impl_.status_ = nullptr;
    return temp;
}
inline ::reporting::StatusProto* UploadEncryptedRecordCall::_internal_mutable_status()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.status_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::StatusProto>(GetArenaForAllocation());
        _impl_.status_ = p;
    }
    return _impl_.status_;
}
inline ::reporting::StatusProto* UploadEncryptedRecordCall::mutable_status()
{
    ::reporting::StatusProto* _msg = _internal_mutable_status();
    // @@protoc_insertion_point(field_mutable:reporting.UploadEncryptedRecordCall.status)
    return _msg;
}
inline void UploadEncryptedRecordCall::set_allocated_status(::reporting::StatusProto* status)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
    }
    if (status) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
        if (message_arena != submessage_arena) {
            status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, status, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.status_ = status;
    // @@protoc_insertion_point(field_set_allocated:reporting.UploadEncryptedRecordCall.status)
}

// -------------------------------------------------------------------

// ConfirmRecordUploadCall

// optional int64 sequencing_id = 1;
inline bool ConfirmRecordUploadCall::_internal_has_sequencing_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ConfirmRecordUploadCall::has_sequencing_id() const
{
    return _internal_has_sequencing_id();
}
inline void ConfirmRecordUploadCall::clear_sequencing_id()
{
    _impl_.sequencing_id_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t ConfirmRecordUploadCall::_internal_sequencing_id() const
{
    return _impl_.sequencing_id_;
}
inline int64_t ConfirmRecordUploadCall::sequencing_id() const
{
    // @@protoc_insertion_point(field_get:reporting.ConfirmRecordUploadCall.sequencing_id)
    return _internal_sequencing_id();
}
inline void ConfirmRecordUploadCall::_internal_set_sequencing_id(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.sequencing_id_ = value;
}
inline void ConfirmRecordUploadCall::set_sequencing_id(int64_t value)
{
    _internal_set_sequencing_id(value);
    // @@protoc_insertion_point(field_set:reporting.ConfirmRecordUploadCall.sequencing_id)
}

// optional bool force_confirm = 2;
inline bool ConfirmRecordUploadCall::_internal_has_force_confirm() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ConfirmRecordUploadCall::has_force_confirm() const
{
    return _internal_has_force_confirm();
}
inline void ConfirmRecordUploadCall::clear_force_confirm()
{
    _impl_.force_confirm_ = false;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ConfirmRecordUploadCall::_internal_force_confirm() const
{
    return _impl_.force_confirm_;
}
inline bool ConfirmRecordUploadCall::force_confirm() const
{
    // @@protoc_insertion_point(field_get:reporting.ConfirmRecordUploadCall.force_confirm)
    return _internal_force_confirm();
}
inline void ConfirmRecordUploadCall::_internal_set_force_confirm(bool value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.force_confirm_ = value;
}
inline void ConfirmRecordUploadCall::set_force_confirm(bool value)
{
    _internal_set_force_confirm(value);
    // @@protoc_insertion_point(field_set:reporting.ConfirmRecordUploadCall.force_confirm)
}

// optional .reporting.Priority priority = 3;
inline bool ConfirmRecordUploadCall::_internal_has_priority() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ConfirmRecordUploadCall::has_priority() const
{
    return _internal_has_priority();
}
inline void ConfirmRecordUploadCall::clear_priority()
{
    _impl_.priority_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::reporting::Priority ConfirmRecordUploadCall::_internal_priority() const
{
    return static_cast<::reporting::Priority>(_impl_.priority_);
}
inline ::reporting::Priority ConfirmRecordUploadCall::priority() const
{
    // @@protoc_insertion_point(field_get:reporting.ConfirmRecordUploadCall.priority)
    return _internal_priority();
}
inline void ConfirmRecordUploadCall::_internal_set_priority(::reporting::Priority value)
{
    assert(::reporting::Priority_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.priority_ = value;
}
inline void ConfirmRecordUploadCall::set_priority(::reporting::Priority value)
{
    _internal_set_priority(value);
    // @@protoc_insertion_point(field_set:reporting.ConfirmRecordUploadCall.priority)
}

// optional .reporting.StatusProto status = 4;
inline bool ConfirmRecordUploadCall::_internal_has_status() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.status_ != nullptr);
    return value;
}
inline bool ConfirmRecordUploadCall::has_status() const
{
    return _internal_has_status();
}
inline const ::reporting::StatusProto& ConfirmRecordUploadCall::_internal_status() const
{
    const ::reporting::StatusProto* p = _impl_.status_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::StatusProto&>(::reporting::_StatusProto_default_instance_);
}
inline const ::reporting::StatusProto& ConfirmRecordUploadCall::status() const
{
    // @@protoc_insertion_point(field_get:reporting.ConfirmRecordUploadCall.status)
    return _internal_status();
}
inline void ConfirmRecordUploadCall::unsafe_arena_set_allocated_status(::reporting::StatusProto* status)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
    }
    _impl_.status_ = status;
    if (status) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.ConfirmRecordUploadCall.status)
}
inline ::reporting::StatusProto* ConfirmRecordUploadCall::release_status()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::StatusProto* temp = _impl_.status_;
    _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::StatusProto* ConfirmRecordUploadCall::unsafe_arena_release_status()
{
    // @@protoc_insertion_point(field_release:reporting.ConfirmRecordUploadCall.status)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::StatusProto* temp = _impl_.status_;
    _impl_.status_ = nullptr;
    return temp;
}
inline ::reporting::StatusProto* ConfirmRecordUploadCall::_internal_mutable_status()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.status_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::StatusProto>(GetArenaForAllocation());
        _impl_.status_ = p;
    }
    return _impl_.status_;
}
inline ::reporting::StatusProto* ConfirmRecordUploadCall::mutable_status()
{
    ::reporting::StatusProto* _msg = _internal_mutable_status();
    // @@protoc_insertion_point(field_mutable:reporting.ConfirmRecordUploadCall.status)
    return _msg;
}
inline void ConfirmRecordUploadCall::set_allocated_status(::reporting::StatusProto* status)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
    }
    if (status) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
        if (message_arena != submessage_arena) {
            status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, status, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.status_ = status;
    // @@protoc_insertion_point(field_set_allocated:reporting.ConfirmRecordUploadCall.status)
}

// -------------------------------------------------------------------

// BlockedRecordCall

// optional .reporting.Priority priority = 1;
inline bool BlockedRecordCall::_internal_has_priority() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool BlockedRecordCall::has_priority() const
{
    return _internal_has_priority();
}
inline void BlockedRecordCall::clear_priority()
{
    _impl_.priority_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::reporting::Priority BlockedRecordCall::_internal_priority() const
{
    return static_cast<::reporting::Priority>(_impl_.priority_);
}
inline ::reporting::Priority BlockedRecordCall::priority() const
{
    // @@protoc_insertion_point(field_get:reporting.BlockedRecordCall.priority)
    return _internal_priority();
}
inline void BlockedRecordCall::_internal_set_priority(::reporting::Priority value)
{
    assert(::reporting::Priority_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.priority_ = value;
}
inline void BlockedRecordCall::set_priority(::reporting::Priority value)
{
    _internal_set_priority(value);
    // @@protoc_insertion_point(field_set:reporting.BlockedRecordCall.priority)
}

// optional .reporting.Destination destination = 2;
inline bool BlockedRecordCall::_internal_has_destination() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool BlockedRecordCall::has_destination() const
{
    return _internal_has_destination();
}
inline void BlockedRecordCall::clear_destination()
{
    _impl_.destination_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::reporting::Destination BlockedRecordCall::_internal_destination() const
{
    return static_cast<::reporting::Destination>(_impl_.destination_);
}
inline ::reporting::Destination BlockedRecordCall::destination() const
{
    // @@protoc_insertion_point(field_get:reporting.BlockedRecordCall.destination)
    return _internal_destination();
}
inline void BlockedRecordCall::_internal_set_destination(::reporting::Destination value)
{
    assert(::reporting::Destination_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.destination_ = value;
}
inline void BlockedRecordCall::set_destination(::reporting::Destination value)
{
    _internal_set_destination(value);
    // @@protoc_insertion_point(field_set:reporting.BlockedRecordCall.destination)
}

// -------------------------------------------------------------------

// BlockedDestinationsUpdatedCall

// repeated .reporting.Destination destinations = 1;
inline int BlockedDestinationsUpdatedCall::_internal_destinations_size() const
{
    return _impl_.destinations_.size();
}
inline int BlockedDestinationsUpdatedCall::destinations_size() const
{
    return _internal_destinations_size();
}
inline void BlockedDestinationsUpdatedCall::clear_destinations()
{
    _impl_.destinations_.Clear();
}
inline ::reporting::Destination BlockedDestinationsUpdatedCall::_internal_destinations(int index) const
{
    return static_cast<::reporting::Destination>(_impl_.destinations_.Get(index));
}
inline ::reporting::Destination BlockedDestinationsUpdatedCall::destinations(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.BlockedDestinationsUpdatedCall.destinations)
    return _internal_destinations(index);
}
inline void BlockedDestinationsUpdatedCall::set_destinations(int index, ::reporting::Destination value)
{
    assert(::reporting::Destination_IsValid(value));
    _impl_.destinations_.Set(index, value);
    // @@protoc_insertion_point(field_set:reporting.BlockedDestinationsUpdatedCall.destinations)
}
inline void BlockedDestinationsUpdatedCall::_internal_add_destinations(::reporting::Destination value)
{
    assert(::reporting::Destination_IsValid(value));
    _impl_.destinations_.Add(value);
}
inline void BlockedDestinationsUpdatedCall::add_destinations(::reporting::Destination value)
{
    _internal_add_destinations(value);
    // @@protoc_insertion_point(field_add:reporting.BlockedDestinationsUpdatedCall.destinations)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& BlockedDestinationsUpdatedCall::destinations() const
{
    // @@protoc_insertion_point(field_list:reporting.BlockedDestinationsUpdatedCall.destinations)
    return _impl_.destinations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* BlockedDestinationsUpdatedCall::_internal_mutable_destinations()
{
    return &_impl_.destinations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* BlockedDestinationsUpdatedCall::mutable_destinations()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.BlockedDestinationsUpdatedCall.destinations)
    return _internal_mutable_destinations();
}

// -------------------------------------------------------------------

// HealthDataHistory

// .reporting.EnqueueRecordCall enqueue_record_call = 1;
inline bool HealthDataHistory::_internal_has_enqueue_record_call() const
{
    return record_case() == kEnqueueRecordCall;
}
inline bool HealthDataHistory::has_enqueue_record_call() const
{
    return _internal_has_enqueue_record_call();
}
inline void HealthDataHistory::set_has_enqueue_record_call()
{
    _impl_._oneof_case_[0] = kEnqueueRecordCall;
}
inline void HealthDataHistory::clear_enqueue_record_call()
{
    if (_internal_has_enqueue_record_call()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.record_.enqueue_record_call_;
        }
        clear_has_record();
    }
}
inline ::reporting::EnqueueRecordCall* HealthDataHistory::release_enqueue_record_call()
{
    // @@protoc_insertion_point(field_release:reporting.HealthDataHistory.enqueue_record_call)
    if (_internal_has_enqueue_record_call()) {
        clear_has_record();
        ::reporting::EnqueueRecordCall* temp = _impl_.record_.enqueue_record_call_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.record_.enqueue_record_call_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::EnqueueRecordCall& HealthDataHistory::_internal_enqueue_record_call() const
{
    return _internal_has_enqueue_record_call() ? *_impl_.record_.enqueue_record_call_
                                               : reinterpret_cast<::reporting::EnqueueRecordCall&>(::reporting::_EnqueueRecordCall_default_instance_);
}
inline const ::reporting::EnqueueRecordCall& HealthDataHistory::enqueue_record_call() const
{
    // @@protoc_insertion_point(field_get:reporting.HealthDataHistory.enqueue_record_call)
    return _internal_enqueue_record_call();
}
inline ::reporting::EnqueueRecordCall* HealthDataHistory::unsafe_arena_release_enqueue_record_call()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.HealthDataHistory.enqueue_record_call)
    if (_internal_has_enqueue_record_call()) {
        clear_has_record();
        ::reporting::EnqueueRecordCall* temp = _impl_.record_.enqueue_record_call_;
        _impl_.record_.enqueue_record_call_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void HealthDataHistory::unsafe_arena_set_allocated_enqueue_record_call(::reporting::EnqueueRecordCall* enqueue_record_call)
{
    clear_record();
    if (enqueue_record_call) {
        set_has_enqueue_record_call();
        _impl_.record_.enqueue_record_call_ = enqueue_record_call;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.HealthDataHistory.enqueue_record_call)
}
inline ::reporting::EnqueueRecordCall* HealthDataHistory::_internal_mutable_enqueue_record_call()
{
    if (!_internal_has_enqueue_record_call()) {
        clear_record();
        set_has_enqueue_record_call();
        _impl_.record_.enqueue_record_call_ = CreateMaybeMessage<::reporting::EnqueueRecordCall>(GetArenaForAllocation());
    }
    return _impl_.record_.enqueue_record_call_;
}
inline ::reporting::EnqueueRecordCall* HealthDataHistory::mutable_enqueue_record_call()
{
    ::reporting::EnqueueRecordCall* _msg = _internal_mutable_enqueue_record_call();
    // @@protoc_insertion_point(field_mutable:reporting.HealthDataHistory.enqueue_record_call)
    return _msg;
}

// .reporting.FlushPriorityCall flush_priority_call = 2;
inline bool HealthDataHistory::_internal_has_flush_priority_call() const
{
    return record_case() == kFlushPriorityCall;
}
inline bool HealthDataHistory::has_flush_priority_call() const
{
    return _internal_has_flush_priority_call();
}
inline void HealthDataHistory::set_has_flush_priority_call()
{
    _impl_._oneof_case_[0] = kFlushPriorityCall;
}
inline void HealthDataHistory::clear_flush_priority_call()
{
    if (_internal_has_flush_priority_call()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.record_.flush_priority_call_;
        }
        clear_has_record();
    }
}
inline ::reporting::FlushPriorityCall* HealthDataHistory::release_flush_priority_call()
{
    // @@protoc_insertion_point(field_release:reporting.HealthDataHistory.flush_priority_call)
    if (_internal_has_flush_priority_call()) {
        clear_has_record();
        ::reporting::FlushPriorityCall* temp = _impl_.record_.flush_priority_call_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.record_.flush_priority_call_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::FlushPriorityCall& HealthDataHistory::_internal_flush_priority_call() const
{
    return _internal_has_flush_priority_call() ? *_impl_.record_.flush_priority_call_
                                               : reinterpret_cast<::reporting::FlushPriorityCall&>(::reporting::_FlushPriorityCall_default_instance_);
}
inline const ::reporting::FlushPriorityCall& HealthDataHistory::flush_priority_call() const
{
    // @@protoc_insertion_point(field_get:reporting.HealthDataHistory.flush_priority_call)
    return _internal_flush_priority_call();
}
inline ::reporting::FlushPriorityCall* HealthDataHistory::unsafe_arena_release_flush_priority_call()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.HealthDataHistory.flush_priority_call)
    if (_internal_has_flush_priority_call()) {
        clear_has_record();
        ::reporting::FlushPriorityCall* temp = _impl_.record_.flush_priority_call_;
        _impl_.record_.flush_priority_call_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void HealthDataHistory::unsafe_arena_set_allocated_flush_priority_call(::reporting::FlushPriorityCall* flush_priority_call)
{
    clear_record();
    if (flush_priority_call) {
        set_has_flush_priority_call();
        _impl_.record_.flush_priority_call_ = flush_priority_call;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.HealthDataHistory.flush_priority_call)
}
inline ::reporting::FlushPriorityCall* HealthDataHistory::_internal_mutable_flush_priority_call()
{
    if (!_internal_has_flush_priority_call()) {
        clear_record();
        set_has_flush_priority_call();
        _impl_.record_.flush_priority_call_ = CreateMaybeMessage<::reporting::FlushPriorityCall>(GetArenaForAllocation());
    }
    return _impl_.record_.flush_priority_call_;
}
inline ::reporting::FlushPriorityCall* HealthDataHistory::mutable_flush_priority_call()
{
    ::reporting::FlushPriorityCall* _msg = _internal_mutable_flush_priority_call();
    // @@protoc_insertion_point(field_mutable:reporting.HealthDataHistory.flush_priority_call)
    return _msg;
}

// .reporting.UploadEncryptedRecordCall upload_encrypted_record_call = 3;
inline bool HealthDataHistory::_internal_has_upload_encrypted_record_call() const
{
    return record_case() == kUploadEncryptedRecordCall;
}
inline bool HealthDataHistory::has_upload_encrypted_record_call() const
{
    return _internal_has_upload_encrypted_record_call();
}
inline void HealthDataHistory::set_has_upload_encrypted_record_call()
{
    _impl_._oneof_case_[0] = kUploadEncryptedRecordCall;
}
inline void HealthDataHistory::clear_upload_encrypted_record_call()
{
    if (_internal_has_upload_encrypted_record_call()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.record_.upload_encrypted_record_call_;
        }
        clear_has_record();
    }
}
inline ::reporting::UploadEncryptedRecordCall* HealthDataHistory::release_upload_encrypted_record_call()
{
    // @@protoc_insertion_point(field_release:reporting.HealthDataHistory.upload_encrypted_record_call)
    if (_internal_has_upload_encrypted_record_call()) {
        clear_has_record();
        ::reporting::UploadEncryptedRecordCall* temp = _impl_.record_.upload_encrypted_record_call_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.record_.upload_encrypted_record_call_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::UploadEncryptedRecordCall& HealthDataHistory::_internal_upload_encrypted_record_call() const
{
    return _internal_has_upload_encrypted_record_call()
        ? *_impl_.record_.upload_encrypted_record_call_
        : reinterpret_cast<::reporting::UploadEncryptedRecordCall&>(::reporting::_UploadEncryptedRecordCall_default_instance_);
}
inline const ::reporting::UploadEncryptedRecordCall& HealthDataHistory::upload_encrypted_record_call() const
{
    // @@protoc_insertion_point(field_get:reporting.HealthDataHistory.upload_encrypted_record_call)
    return _internal_upload_encrypted_record_call();
}
inline ::reporting::UploadEncryptedRecordCall* HealthDataHistory::unsafe_arena_release_upload_encrypted_record_call()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.HealthDataHistory.upload_encrypted_record_call)
    if (_internal_has_upload_encrypted_record_call()) {
        clear_has_record();
        ::reporting::UploadEncryptedRecordCall* temp = _impl_.record_.upload_encrypted_record_call_;
        _impl_.record_.upload_encrypted_record_call_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void HealthDataHistory::unsafe_arena_set_allocated_upload_encrypted_record_call(::reporting::UploadEncryptedRecordCall* upload_encrypted_record_call)
{
    clear_record();
    if (upload_encrypted_record_call) {
        set_has_upload_encrypted_record_call();
        _impl_.record_.upload_encrypted_record_call_ = upload_encrypted_record_call;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.HealthDataHistory.upload_encrypted_record_call)
}
inline ::reporting::UploadEncryptedRecordCall* HealthDataHistory::_internal_mutable_upload_encrypted_record_call()
{
    if (!_internal_has_upload_encrypted_record_call()) {
        clear_record();
        set_has_upload_encrypted_record_call();
        _impl_.record_.upload_encrypted_record_call_ = CreateMaybeMessage<::reporting::UploadEncryptedRecordCall>(GetArenaForAllocation());
    }
    return _impl_.record_.upload_encrypted_record_call_;
}
inline ::reporting::UploadEncryptedRecordCall* HealthDataHistory::mutable_upload_encrypted_record_call()
{
    ::reporting::UploadEncryptedRecordCall* _msg = _internal_mutable_upload_encrypted_record_call();
    // @@protoc_insertion_point(field_mutable:reporting.HealthDataHistory.upload_encrypted_record_call)
    return _msg;
}

// .reporting.ConfirmRecordUploadCall confirm_record_upload_call = 4;
inline bool HealthDataHistory::_internal_has_confirm_record_upload_call() const
{
    return record_case() == kConfirmRecordUploadCall;
}
inline bool HealthDataHistory::has_confirm_record_upload_call() const
{
    return _internal_has_confirm_record_upload_call();
}
inline void HealthDataHistory::set_has_confirm_record_upload_call()
{
    _impl_._oneof_case_[0] = kConfirmRecordUploadCall;
}
inline void HealthDataHistory::clear_confirm_record_upload_call()
{
    if (_internal_has_confirm_record_upload_call()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.record_.confirm_record_upload_call_;
        }
        clear_has_record();
    }
}
inline ::reporting::ConfirmRecordUploadCall* HealthDataHistory::release_confirm_record_upload_call()
{
    // @@protoc_insertion_point(field_release:reporting.HealthDataHistory.confirm_record_upload_call)
    if (_internal_has_confirm_record_upload_call()) {
        clear_has_record();
        ::reporting::ConfirmRecordUploadCall* temp = _impl_.record_.confirm_record_upload_call_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.record_.confirm_record_upload_call_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::ConfirmRecordUploadCall& HealthDataHistory::_internal_confirm_record_upload_call() const
{
    return _internal_has_confirm_record_upload_call()
        ? *_impl_.record_.confirm_record_upload_call_
        : reinterpret_cast<::reporting::ConfirmRecordUploadCall&>(::reporting::_ConfirmRecordUploadCall_default_instance_);
}
inline const ::reporting::ConfirmRecordUploadCall& HealthDataHistory::confirm_record_upload_call() const
{
    // @@protoc_insertion_point(field_get:reporting.HealthDataHistory.confirm_record_upload_call)
    return _internal_confirm_record_upload_call();
}
inline ::reporting::ConfirmRecordUploadCall* HealthDataHistory::unsafe_arena_release_confirm_record_upload_call()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.HealthDataHistory.confirm_record_upload_call)
    if (_internal_has_confirm_record_upload_call()) {
        clear_has_record();
        ::reporting::ConfirmRecordUploadCall* temp = _impl_.record_.confirm_record_upload_call_;
        _impl_.record_.confirm_record_upload_call_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void HealthDataHistory::unsafe_arena_set_allocated_confirm_record_upload_call(::reporting::ConfirmRecordUploadCall* confirm_record_upload_call)
{
    clear_record();
    if (confirm_record_upload_call) {
        set_has_confirm_record_upload_call();
        _impl_.record_.confirm_record_upload_call_ = confirm_record_upload_call;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.HealthDataHistory.confirm_record_upload_call)
}
inline ::reporting::ConfirmRecordUploadCall* HealthDataHistory::_internal_mutable_confirm_record_upload_call()
{
    if (!_internal_has_confirm_record_upload_call()) {
        clear_record();
        set_has_confirm_record_upload_call();
        _impl_.record_.confirm_record_upload_call_ = CreateMaybeMessage<::reporting::ConfirmRecordUploadCall>(GetArenaForAllocation());
    }
    return _impl_.record_.confirm_record_upload_call_;
}
inline ::reporting::ConfirmRecordUploadCall* HealthDataHistory::mutable_confirm_record_upload_call()
{
    ::reporting::ConfirmRecordUploadCall* _msg = _internal_mutable_confirm_record_upload_call();
    // @@protoc_insertion_point(field_mutable:reporting.HealthDataHistory.confirm_record_upload_call)
    return _msg;
}

// .reporting.StorageQueueAction storage_queue_action = 5;
inline bool HealthDataHistory::_internal_has_storage_queue_action() const
{
    return record_case() == kStorageQueueAction;
}
inline bool HealthDataHistory::has_storage_queue_action() const
{
    return _internal_has_storage_queue_action();
}
inline void HealthDataHistory::set_has_storage_queue_action()
{
    _impl_._oneof_case_[0] = kStorageQueueAction;
}
inline void HealthDataHistory::clear_storage_queue_action()
{
    if (_internal_has_storage_queue_action()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.record_.storage_queue_action_;
        }
        clear_has_record();
    }
}
inline ::reporting::StorageQueueAction* HealthDataHistory::release_storage_queue_action()
{
    // @@protoc_insertion_point(field_release:reporting.HealthDataHistory.storage_queue_action)
    if (_internal_has_storage_queue_action()) {
        clear_has_record();
        ::reporting::StorageQueueAction* temp = _impl_.record_.storage_queue_action_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.record_.storage_queue_action_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::StorageQueueAction& HealthDataHistory::_internal_storage_queue_action() const
{
    return _internal_has_storage_queue_action() ? *_impl_.record_.storage_queue_action_
                                                : reinterpret_cast<::reporting::StorageQueueAction&>(::reporting::_StorageQueueAction_default_instance_);
}
inline const ::reporting::StorageQueueAction& HealthDataHistory::storage_queue_action() const
{
    // @@protoc_insertion_point(field_get:reporting.HealthDataHistory.storage_queue_action)
    return _internal_storage_queue_action();
}
inline ::reporting::StorageQueueAction* HealthDataHistory::unsafe_arena_release_storage_queue_action()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.HealthDataHistory.storage_queue_action)
    if (_internal_has_storage_queue_action()) {
        clear_has_record();
        ::reporting::StorageQueueAction* temp = _impl_.record_.storage_queue_action_;
        _impl_.record_.storage_queue_action_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void HealthDataHistory::unsafe_arena_set_allocated_storage_queue_action(::reporting::StorageQueueAction* storage_queue_action)
{
    clear_record();
    if (storage_queue_action) {
        set_has_storage_queue_action();
        _impl_.record_.storage_queue_action_ = storage_queue_action;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.HealthDataHistory.storage_queue_action)
}
inline ::reporting::StorageQueueAction* HealthDataHistory::_internal_mutable_storage_queue_action()
{
    if (!_internal_has_storage_queue_action()) {
        clear_record();
        set_has_storage_queue_action();
        _impl_.record_.storage_queue_action_ = CreateMaybeMessage<::reporting::StorageQueueAction>(GetArenaForAllocation());
    }
    return _impl_.record_.storage_queue_action_;
}
inline ::reporting::StorageQueueAction* HealthDataHistory::mutable_storage_queue_action()
{
    ::reporting::StorageQueueAction* _msg = _internal_mutable_storage_queue_action();
    // @@protoc_insertion_point(field_mutable:reporting.HealthDataHistory.storage_queue_action)
    return _msg;
}

// .reporting.BlockedRecordCall blocked_record_call = 7;
inline bool HealthDataHistory::_internal_has_blocked_record_call() const
{
    return record_case() == kBlockedRecordCall;
}
inline bool HealthDataHistory::has_blocked_record_call() const
{
    return _internal_has_blocked_record_call();
}
inline void HealthDataHistory::set_has_blocked_record_call()
{
    _impl_._oneof_case_[0] = kBlockedRecordCall;
}
inline void HealthDataHistory::clear_blocked_record_call()
{
    if (_internal_has_blocked_record_call()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.record_.blocked_record_call_;
        }
        clear_has_record();
    }
}
inline ::reporting::BlockedRecordCall* HealthDataHistory::release_blocked_record_call()
{
    // @@protoc_insertion_point(field_release:reporting.HealthDataHistory.blocked_record_call)
    if (_internal_has_blocked_record_call()) {
        clear_has_record();
        ::reporting::BlockedRecordCall* temp = _impl_.record_.blocked_record_call_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.record_.blocked_record_call_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::BlockedRecordCall& HealthDataHistory::_internal_blocked_record_call() const
{
    return _internal_has_blocked_record_call() ? *_impl_.record_.blocked_record_call_
                                               : reinterpret_cast<::reporting::BlockedRecordCall&>(::reporting::_BlockedRecordCall_default_instance_);
}
inline const ::reporting::BlockedRecordCall& HealthDataHistory::blocked_record_call() const
{
    // @@protoc_insertion_point(field_get:reporting.HealthDataHistory.blocked_record_call)
    return _internal_blocked_record_call();
}
inline ::reporting::BlockedRecordCall* HealthDataHistory::unsafe_arena_release_blocked_record_call()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.HealthDataHistory.blocked_record_call)
    if (_internal_has_blocked_record_call()) {
        clear_has_record();
        ::reporting::BlockedRecordCall* temp = _impl_.record_.blocked_record_call_;
        _impl_.record_.blocked_record_call_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void HealthDataHistory::unsafe_arena_set_allocated_blocked_record_call(::reporting::BlockedRecordCall* blocked_record_call)
{
    clear_record();
    if (blocked_record_call) {
        set_has_blocked_record_call();
        _impl_.record_.blocked_record_call_ = blocked_record_call;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.HealthDataHistory.blocked_record_call)
}
inline ::reporting::BlockedRecordCall* HealthDataHistory::_internal_mutable_blocked_record_call()
{
    if (!_internal_has_blocked_record_call()) {
        clear_record();
        set_has_blocked_record_call();
        _impl_.record_.blocked_record_call_ = CreateMaybeMessage<::reporting::BlockedRecordCall>(GetArenaForAllocation());
    }
    return _impl_.record_.blocked_record_call_;
}
inline ::reporting::BlockedRecordCall* HealthDataHistory::mutable_blocked_record_call()
{
    ::reporting::BlockedRecordCall* _msg = _internal_mutable_blocked_record_call();
    // @@protoc_insertion_point(field_mutable:reporting.HealthDataHistory.blocked_record_call)
    return _msg;
}

// .reporting.BlockedDestinationsUpdatedCall blocked_destinations_updated_call = 8;
inline bool HealthDataHistory::_internal_has_blocked_destinations_updated_call() const
{
    return record_case() == kBlockedDestinationsUpdatedCall;
}
inline bool HealthDataHistory::has_blocked_destinations_updated_call() const
{
    return _internal_has_blocked_destinations_updated_call();
}
inline void HealthDataHistory::set_has_blocked_destinations_updated_call()
{
    _impl_._oneof_case_[0] = kBlockedDestinationsUpdatedCall;
}
inline void HealthDataHistory::clear_blocked_destinations_updated_call()
{
    if (_internal_has_blocked_destinations_updated_call()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.record_.blocked_destinations_updated_call_;
        }
        clear_has_record();
    }
}
inline ::reporting::BlockedDestinationsUpdatedCall* HealthDataHistory::release_blocked_destinations_updated_call()
{
    // @@protoc_insertion_point(field_release:reporting.HealthDataHistory.blocked_destinations_updated_call)
    if (_internal_has_blocked_destinations_updated_call()) {
        clear_has_record();
        ::reporting::BlockedDestinationsUpdatedCall* temp = _impl_.record_.blocked_destinations_updated_call_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.record_.blocked_destinations_updated_call_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::BlockedDestinationsUpdatedCall& HealthDataHistory::_internal_blocked_destinations_updated_call() const
{
    return _internal_has_blocked_destinations_updated_call()
        ? *_impl_.record_.blocked_destinations_updated_call_
        : reinterpret_cast<::reporting::BlockedDestinationsUpdatedCall&>(::reporting::_BlockedDestinationsUpdatedCall_default_instance_);
}
inline const ::reporting::BlockedDestinationsUpdatedCall& HealthDataHistory::blocked_destinations_updated_call() const
{
    // @@protoc_insertion_point(field_get:reporting.HealthDataHistory.blocked_destinations_updated_call)
    return _internal_blocked_destinations_updated_call();
}
inline ::reporting::BlockedDestinationsUpdatedCall* HealthDataHistory::unsafe_arena_release_blocked_destinations_updated_call()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.HealthDataHistory.blocked_destinations_updated_call)
    if (_internal_has_blocked_destinations_updated_call()) {
        clear_has_record();
        ::reporting::BlockedDestinationsUpdatedCall* temp = _impl_.record_.blocked_destinations_updated_call_;
        _impl_.record_.blocked_destinations_updated_call_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void HealthDataHistory::unsafe_arena_set_allocated_blocked_destinations_updated_call(
    ::reporting::BlockedDestinationsUpdatedCall* blocked_destinations_updated_call)
{
    clear_record();
    if (blocked_destinations_updated_call) {
        set_has_blocked_destinations_updated_call();
        _impl_.record_.blocked_destinations_updated_call_ = blocked_destinations_updated_call;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.HealthDataHistory.blocked_destinations_updated_call)
}
inline ::reporting::BlockedDestinationsUpdatedCall* HealthDataHistory::_internal_mutable_blocked_destinations_updated_call()
{
    if (!_internal_has_blocked_destinations_updated_call()) {
        clear_record();
        set_has_blocked_destinations_updated_call();
        _impl_.record_.blocked_destinations_updated_call_ = CreateMaybeMessage<::reporting::BlockedDestinationsUpdatedCall>(GetArenaForAllocation());
    }
    return _impl_.record_.blocked_destinations_updated_call_;
}
inline ::reporting::BlockedDestinationsUpdatedCall* HealthDataHistory::mutable_blocked_destinations_updated_call()
{
    ::reporting::BlockedDestinationsUpdatedCall* _msg = _internal_mutable_blocked_destinations_updated_call();
    // @@protoc_insertion_point(field_mutable:reporting.HealthDataHistory.blocked_destinations_updated_call)
    return _msg;
}

// optional int64 timestamp_seconds = 6;
inline bool HealthDataHistory::_internal_has_timestamp_seconds() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool HealthDataHistory::has_timestamp_seconds() const
{
    return _internal_has_timestamp_seconds();
}
inline void HealthDataHistory::clear_timestamp_seconds()
{
    _impl_.timestamp_seconds_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t HealthDataHistory::_internal_timestamp_seconds() const
{
    return _impl_.timestamp_seconds_;
}
inline int64_t HealthDataHistory::timestamp_seconds() const
{
    // @@protoc_insertion_point(field_get:reporting.HealthDataHistory.timestamp_seconds)
    return _internal_timestamp_seconds();
}
inline void HealthDataHistory::_internal_set_timestamp_seconds(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.timestamp_seconds_ = value;
}
inline void HealthDataHistory::set_timestamp_seconds(int64_t value)
{
    _internal_set_timestamp_seconds(value);
    // @@protoc_insertion_point(field_set:reporting.HealthDataHistory.timestamp_seconds)
}

inline bool HealthDataHistory::has_record() const
{
    return record_case() != RECORD_NOT_SET;
}
inline void HealthDataHistory::clear_has_record()
{
    _impl_._oneof_case_[0] = RECORD_NOT_SET;
}
inline HealthDataHistory::RecordCase HealthDataHistory::record_case() const
{
    return HealthDataHistory::RecordCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ERPHealthData

// repeated .reporting.HealthDataHistory history = 1;
inline int ERPHealthData::_internal_history_size() const
{
    return _impl_.history_.size();
}
inline int ERPHealthData::history_size() const
{
    return _internal_history_size();
}
inline void ERPHealthData::clear_history()
{
    _impl_.history_.Clear();
}
inline ::reporting::HealthDataHistory* ERPHealthData::mutable_history(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.ERPHealthData.history)
    return _impl_.history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::HealthDataHistory>* ERPHealthData::mutable_history()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.ERPHealthData.history)
    return &_impl_.history_;
}
inline const ::reporting::HealthDataHistory& ERPHealthData::_internal_history(int index) const
{
    return _impl_.history_.Get(index);
}
inline const ::reporting::HealthDataHistory& ERPHealthData::history(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.ERPHealthData.history)
    return _internal_history(index);
}
inline ::reporting::HealthDataHistory* ERPHealthData::_internal_add_history()
{
    return _impl_.history_.Add();
}
inline ::reporting::HealthDataHistory* ERPHealthData::add_history()
{
    ::reporting::HealthDataHistory* _add = _internal_add_history();
    // @@protoc_insertion_point(field_add:reporting.ERPHealthData.history)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::HealthDataHistory>& ERPHealthData::history() const
{
    // @@protoc_insertion_point(field_list:reporting.ERPHealthData.history)
    return _impl_.history_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace reporting

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2freporting_2fproto_2fsynced_2fhealth_2eproto
