// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/reporting/proto/synced/metric_data.proto

#include "components/reporting/proto/synced/metric_data.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace reporting {
PROTOBUF_CONSTEXPR HttpsLatencyRoutineData::HttpsLatencyRoutineData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.verdict_)*/ 0, /*decltype(_impl_.problem_)*/ 0,
        /*decltype(_impl_.latency_ms_)*/ int64_t { 0 } }
{
}
struct HttpsLatencyRoutineDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR HttpsLatencyRoutineDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~HttpsLatencyRoutineDataDefaultTypeInternal()
    {
    }
    union {
        HttpsLatencyRoutineData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HttpsLatencyRoutineDataDefaultTypeInternal
    _HttpsLatencyRoutineData_default_instance_;
PROTOBUF_CONSTEXPR BandwidthData::BandwidthData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.download_speed_kbps_)*/ int64_t { 0 },
        /*decltype(_impl_.upload_speed_kbps_)*/ int64_t { 0 } }
{
}
struct BandwidthDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR BandwidthDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~BandwidthDataDefaultTypeInternal()
    {
    }
    union {
        BandwidthData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BandwidthDataDefaultTypeInternal _BandwidthData_default_instance_;
PROTOBUF_CONSTEXPR NetworkTelemetry::NetworkTelemetry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.guid_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.device_path_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.ip_address_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.gateway_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.connection_state_)*/ 0,
        /*decltype(_impl_.signal_strength_)*/ 0, /*decltype(_impl_.tx_bit_rate_mbps_)*/ int64_t { 0 }, /*decltype(_impl_.type_)*/ 0,
        /*decltype(_impl_.tx_power_dbm_)*/ 0, /*decltype(_impl_.rx_bit_rate_mbps_)*/ int64_t { 0 }, /*decltype(_impl_.link_quality_)*/ int64_t { 0 },
        /*decltype(_impl_.encryption_on_)*/ false, /*decltype(_impl_.power_management_enabled_)*/ false, /*decltype(_impl_.signal_strength_dbm_)*/ 0 }
{
}
struct NetworkTelemetryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR NetworkTelemetryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~NetworkTelemetryDefaultTypeInternal()
    {
    }
    union {
        NetworkTelemetry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkTelemetryDefaultTypeInternal _NetworkTelemetry_default_instance_;
PROTOBUF_CONSTEXPR NetworkConnectionStateChangeEventData::NetworkConnectionStateChangeEventData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.guid_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.connection_state_)*/ 0 }
{
}
struct NetworkConnectionStateChangeEventDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR NetworkConnectionStateChangeEventDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~NetworkConnectionStateChangeEventDataDefaultTypeInternal()
    {
    }
    union {
        NetworkConnectionStateChangeEventData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkConnectionStateChangeEventDataDefaultTypeInternal
    _NetworkConnectionStateChangeEventData_default_instance_;
PROTOBUF_CONSTEXPR SignalStrengthEventData::SignalStrengthEventData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.guid_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.signal_strength_dbm_)*/ 0 }
{
}
struct SignalStrengthEventDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SignalStrengthEventDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SignalStrengthEventDataDefaultTypeInternal()
    {
    }
    union {
        SignalStrengthEventData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SignalStrengthEventDataDefaultTypeInternal
    _SignalStrengthEventData_default_instance_;
PROTOBUF_CONSTEXPR NetworksTelemetry::NetworksTelemetry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.network_telemetry_)*/ {},
        /*decltype(_impl_.https_latency_data_)*/ nullptr, /*decltype(_impl_.bandwidth_data_)*/ nullptr,
        /*decltype(_impl_.network_connection_change_event_data_)*/ nullptr, /*decltype(_impl_.signal_strength_event_data_)*/ nullptr }
{
}
struct NetworksTelemetryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR NetworksTelemetryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~NetworksTelemetryDefaultTypeInternal()
    {
    }
    union {
        NetworksTelemetry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworksTelemetryDefaultTypeInternal _NetworksTelemetry_default_instance_;
PROTOBUF_CONSTEXPR ThunderboltInfo::ThunderboltInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.security_level_)*/ 0 }
{
}
struct ThunderboltInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ThunderboltInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ThunderboltInfoDefaultTypeInternal()
    {
    }
    union {
        ThunderboltInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ThunderboltInfoDefaultTypeInternal _ThunderboltInfo_default_instance_;
PROTOBUF_CONSTEXPR BusDeviceInfo::BusDeviceInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.thunderbolt_info_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct BusDeviceInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR BusDeviceInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~BusDeviceInfoDefaultTypeInternal()
    {
    }
    union {
        BusDeviceInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BusDeviceInfoDefaultTypeInternal _BusDeviceInfo_default_instance_;
PROTOBUF_CONSTEXPR TotalMemoryEncryptionInfo::TotalMemoryEncryptionInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.max_keys_)*/ int64_t { 0 },
        /*decltype(_impl_.encryption_state_)*/ 0, /*decltype(_impl_.encryption_algorithm_)*/ 0, /*decltype(_impl_.key_length_)*/ int64_t { 0 } }
{
}
struct TotalMemoryEncryptionInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TotalMemoryEncryptionInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TotalMemoryEncryptionInfoDefaultTypeInternal()
    {
    }
    union {
        TotalMemoryEncryptionInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TotalMemoryEncryptionInfoDefaultTypeInternal
    _TotalMemoryEncryptionInfo_default_instance_;
PROTOBUF_CONSTEXPR MemoryInfo::MemoryInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.tme_info_)*/ nullptr }
{
}
struct MemoryInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR MemoryInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~MemoryInfoDefaultTypeInternal()
    {
    }
    union {
        MemoryInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MemoryInfoDefaultTypeInternal _MemoryInfo_default_instance_;
PROTOBUF_CONSTEXPR NetworkInterface::NetworkInterface(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.eids_)*/ {},
        /*decltype(_impl_.mac_address_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.meid_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.imei_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.device_path_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.iccid_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.mdn_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.type_)*/ 0 }
{
}
struct NetworkInterfaceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR NetworkInterfaceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~NetworkInterfaceDefaultTypeInternal()
    {
    }
    union {
        NetworkInterface _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkInterfaceDefaultTypeInternal _NetworkInterface_default_instance_;
PROTOBUF_CONSTEXPR NetworksInfo::NetworksInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.network_interfaces_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct NetworksInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR NetworksInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~NetworksInfoDefaultTypeInternal()
    {
    }
    union {
        NetworksInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworksInfoDefaultTypeInternal _NetworksInfo_default_instance_;
PROTOBUF_CONSTEXPR TouchScreenInfo::TouchScreenInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.touch_screen_devices_)*/ {},
        /*decltype(_impl_.library_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct TouchScreenInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TouchScreenInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TouchScreenInfoDefaultTypeInternal()
    {
    }
    union {
        TouchScreenInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TouchScreenInfoDefaultTypeInternal _TouchScreenInfo_default_instance_;
PROTOBUF_CONSTEXPR TouchScreenDevice::TouchScreenDevice(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.display_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.touch_points_)*/ 0,
        /*decltype(_impl_.has_stylus_)*/ false }
{
}
struct TouchScreenDeviceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TouchScreenDeviceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TouchScreenDeviceDefaultTypeInternal()
    {
    }
    union {
        TouchScreenDevice _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TouchScreenDeviceDefaultTypeInternal _TouchScreenDevice_default_instance_;
PROTOBUF_CONSTEXPR PrivacyScreenInfo::PrivacyScreenInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.supported_)*/ false }
{
}
struct PrivacyScreenInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PrivacyScreenInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PrivacyScreenInfoDefaultTypeInternal()
    {
    }
    union {
        PrivacyScreenInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PrivacyScreenInfoDefaultTypeInternal _PrivacyScreenInfo_default_instance_;
PROTOBUF_CONSTEXPR DisplayInfo::DisplayInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.display_device_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct DisplayInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DisplayInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DisplayInfoDefaultTypeInternal()
    {
    }
    union {
        DisplayInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DisplayInfoDefaultTypeInternal _DisplayInfo_default_instance_;
PROTOBUF_CONSTEXPR DisplayDevice::DisplayDevice(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.display_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.manufacturer_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.display_width_)*/ 0,
        /*decltype(_impl_.display_height_)*/ 0, /*decltype(_impl_.is_internal_)*/ false, /*decltype(_impl_.model_id_)*/ 0,
        /*decltype(_impl_.manufacture_year_)*/ 0 }
{
}
struct DisplayDeviceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DisplayDeviceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DisplayDeviceDefaultTypeInternal()
    {
    }
    union {
        DisplayDevice _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DisplayDeviceDefaultTypeInternal _DisplayDevice_default_instance_;
PROTOBUF_CONSTEXPR KeylockerInfo::KeylockerInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.supported_)*/ false,
        /*decltype(_impl_.configured_)*/ false }
{
}
struct KeylockerInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR KeylockerInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~KeylockerInfoDefaultTypeInternal()
    {
    }
    union {
        KeylockerInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeylockerInfoDefaultTypeInternal _KeylockerInfo_default_instance_;
PROTOBUF_CONSTEXPR CpuInfo::CpuInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.keylocker_info_)*/ nullptr }
{
}
struct CpuInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CpuInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CpuInfoDefaultTypeInternal()
    {
    }
    union {
        CpuInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CpuInfoDefaultTypeInternal _CpuInfo_default_instance_;
PROTOBUF_CONSTEXPR InfoData::InfoData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.cpu_info_)*/ nullptr,
        /*decltype(_impl_.bus_device_info_)*/ nullptr, /*decltype(_impl_.memory_info_)*/ nullptr, /*decltype(_impl_.networks_info_)*/ nullptr,
        /*decltype(_impl_.touch_screen_info_)*/ nullptr, /*decltype(_impl_.privacy_screen_info_)*/ nullptr, /*decltype(_impl_.display_info_)*/ nullptr }
{
}
struct InfoDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR InfoDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~InfoDataDefaultTypeInternal()
    {
    }
    union {
        InfoData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InfoDataDefaultTypeInternal _InfoData_default_instance_;
PROTOBUF_CONSTEXPR AudioTelemetry::AudioTelemetry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.output_device_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.input_device_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.output_mute_)*/ false, /*decltype(_impl_.input_mute_)*/ false, /*decltype(_impl_.output_volume_)*/ 0,
        /*decltype(_impl_.input_gain_)*/ 0 }
{
}
struct AudioTelemetryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AudioTelemetryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AudioTelemetryDefaultTypeInternal()
    {
    }
    union {
        AudioTelemetry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioTelemetryDefaultTypeInternal _AudioTelemetry_default_instance_;
PROTOBUF_CONSTEXPR BootPerformanceTelemetry::BootPerformanceTelemetry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.shutdown_reason_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.boot_up_seconds_)*/ int64_t { 0 }, /*decltype(_impl_.boot_up_timestamp_seconds_)*/ int64_t { 0 },
        /*decltype(_impl_.shutdown_seconds_)*/ int64_t { 0 }, /*decltype(_impl_.shutdown_timestamp_seconds_)*/ int64_t { 0 } }
{
}
struct BootPerformanceTelemetryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR BootPerformanceTelemetryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~BootPerformanceTelemetryDefaultTypeInternal()
    {
    }
    union {
        BootPerformanceTelemetry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BootPerformanceTelemetryDefaultTypeInternal
    _BootPerformanceTelemetry_default_instance_;
PROTOBUF_CONSTEXPR UserStatusTelemetry::UserStatusTelemetry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.device_activity_state_)*/ 0 }
{
}
struct UserStatusTelemetryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserStatusTelemetryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserStatusTelemetryDefaultTypeInternal()
    {
    }
    union {
        UserStatusTelemetry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserStatusTelemetryDefaultTypeInternal
    _UserStatusTelemetry_default_instance_;
PROTOBUF_CONSTEXPR DisplaysTelemetry::DisplaysTelemetry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.display_status_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct DisplaysTelemetryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DisplaysTelemetryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DisplaysTelemetryDefaultTypeInternal()
    {
    }
    union {
        DisplaysTelemetry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DisplaysTelemetryDefaultTypeInternal _DisplaysTelemetry_default_instance_;
PROTOBUF_CONSTEXPR DisplayStatus::DisplayStatus(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.display_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.resolution_horizontal_)*/ 0, /*decltype(_impl_.resolution_vertical_)*/ 0, /*decltype(_impl_.refresh_rate_)*/ int64_t { 0 },
        /*decltype(_impl_.is_internal_)*/ false }
{
}
struct DisplayStatusDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DisplayStatusDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DisplayStatusDefaultTypeInternal()
    {
    }
    union {
        DisplayStatus _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DisplayStatusDefaultTypeInternal _DisplayStatus_default_instance_;
PROTOBUF_CONSTEXPR KioskHeartbeatTelemetry::KioskHeartbeatTelemetry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct KioskHeartbeatTelemetryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR KioskHeartbeatTelemetryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~KioskHeartbeatTelemetryDefaultTypeInternal()
    {
    }
    union {
        KioskHeartbeatTelemetry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KioskHeartbeatTelemetryDefaultTypeInternal
    _KioskHeartbeatTelemetry_default_instance_;
PROTOBUF_CONSTEXPR KioskVisionView::KioskVisionView(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.start_time_sec_)*/ int64_t { 0 },
        /*decltype(_impl_.end_time_sec_)*/ int64_t { 0 } }
{
}
struct KioskVisionViewDefaultTypeInternal {
    PROTOBUF_CONSTEXPR KioskVisionViewDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~KioskVisionViewDefaultTypeInternal()
    {
    }
    union {
        KioskVisionView _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KioskVisionViewDefaultTypeInternal _KioskVisionView_default_instance_;
PROTOBUF_CONSTEXPR KioskVisionAudience::KioskVisionAudience(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.views_)*/ {},
        /*decltype(_impl_.presence_start_date_sec_)*/ int64_t { 0 }, /*decltype(_impl_.presence_end_date_sec_)*/ int64_t { 0 } }
{
}
struct KioskVisionAudienceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR KioskVisionAudienceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~KioskVisionAudienceDefaultTypeInternal()
    {
    }
    union {
        KioskVisionAudience _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KioskVisionAudienceDefaultTypeInternal
    _KioskVisionAudience_default_instance_;
PROTOBUF_CONSTEXPR KioskVisionTelemetry::KioskVisionTelemetry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.audience_)*/ {},
        /*decltype(_impl_.start_date_sec_)*/ int64_t { 0 }, /*decltype(_impl_.end_date_sec_)*/ int64_t { 0 }, /*decltype(_impl_.view_count_)*/ 0,
        /*decltype(_impl_.pass_count_)*/ 0 }
{
}
struct KioskVisionTelemetryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR KioskVisionTelemetryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~KioskVisionTelemetryDefaultTypeInternal()
    {
    }
    union {
        KioskVisionTelemetry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KioskVisionTelemetryDefaultTypeInternal
    _KioskVisionTelemetry_default_instance_;
PROTOBUF_CONSTEXPR KioskVisionStatusReport::KioskVisionStatusReport(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.time_stamp_sec_)*/ int64_t { 0 },
        /*decltype(_impl_.state_change_time_stamp_sec_)*/ int64_t { 0 }, /*decltype(_impl_.state_)*/ 0 }
{
}
struct KioskVisionStatusReportDefaultTypeInternal {
    PROTOBUF_CONSTEXPR KioskVisionStatusReportDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~KioskVisionStatusReportDefaultTypeInternal()
    {
    }
    union {
        KioskVisionStatusReport _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KioskVisionStatusReportDefaultTypeInternal
    _KioskVisionStatusReport_default_instance_;
PROTOBUF_CONSTEXPR TelemetryData::TelemetryData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.networks_telemetry_)*/ nullptr,
        /*decltype(_impl_.audio_telemetry_)*/ nullptr, /*decltype(_impl_.peripherals_telemetry_)*/ nullptr,
        /*decltype(_impl_.boot_performance_telemetry_)*/ nullptr, /*decltype(_impl_.user_status_telemetry_)*/ nullptr,
        /*decltype(_impl_.displays_telemetry_)*/ nullptr, /*decltype(_impl_.app_telemetry_)*/ nullptr, /*decltype(_impl_.fatal_crash_telemetry_)*/ nullptr,
        /*decltype(_impl_.runtime_counters_telemetry_)*/ nullptr, /*decltype(_impl_.website_telemetry_)*/ nullptr,
        /*decltype(_impl_.heartbeat_telemetry_)*/ nullptr, /*decltype(_impl_.kiosk_vision_telemetry_)*/ nullptr,
        /*decltype(_impl_.kiosk_vision_status_)*/ nullptr, /*decltype(_impl_.is_event_driven_)*/ false }
{
}
struct TelemetryDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TelemetryDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TelemetryDataDefaultTypeInternal()
    {
    }
    union {
        TelemetryData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TelemetryDataDefaultTypeInternal _TelemetryData_default_instance_;
PROTOBUF_CONSTEXPR AppTelemetry::AppTelemetry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.app_metric_data_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct AppTelemetryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AppTelemetryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AppTelemetryDefaultTypeInternal()
    {
    }
    union {
        AppTelemetry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppTelemetryDefaultTypeInternal _AppTelemetry_default_instance_;
PROTOBUF_CONSTEXPR AppInstallData::AppInstallData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.app_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.app_install_source_)*/ 0,
        /*decltype(_impl_.app_install_reason_)*/ 0, /*decltype(_impl_.app_install_time_)*/ 0, /*decltype(_impl_.app_type_)*/ 0 }
{
}
struct AppInstallDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AppInstallDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AppInstallDataDefaultTypeInternal()
    {
    }
    union {
        AppInstallData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppInstallDataDefaultTypeInternal _AppInstallData_default_instance_;
PROTOBUF_CONSTEXPR AppLaunchData::AppLaunchData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.app_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.app_launch_source_)*/ 0,
        /*decltype(_impl_.app_type_)*/ 0 }
{
}
struct AppLaunchDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AppLaunchDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AppLaunchDataDefaultTypeInternal()
    {
    }
    union {
        AppLaunchData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppLaunchDataDefaultTypeInternal _AppLaunchData_default_instance_;
PROTOBUF_CONSTEXPR AppUsageData_AppUsage::AppUsageData_AppUsage(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.app_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.app_instance_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.running_time_ms_)*/ int64_t { 0 }, /*decltype(_impl_.app_type_)*/ 0 }
{
}
struct AppUsageData_AppUsageDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AppUsageData_AppUsageDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AppUsageData_AppUsageDefaultTypeInternal()
    {
    }
    union {
        AppUsageData_AppUsage _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppUsageData_AppUsageDefaultTypeInternal
    _AppUsageData_AppUsage_default_instance_;
PROTOBUF_CONSTEXPR AppUsageData::AppUsageData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.app_usage_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct AppUsageDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AppUsageDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AppUsageDataDefaultTypeInternal()
    {
    }
    union {
        AppUsageData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppUsageDataDefaultTypeInternal _AppUsageData_default_instance_;
PROTOBUF_CONSTEXPR AppUninstallData::AppUninstallData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.app_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.app_uninstall_source_)*/ 0,
        /*decltype(_impl_.app_type_)*/ 0 }
{
}
struct AppUninstallDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AppUninstallDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AppUninstallDataDefaultTypeInternal()
    {
    }
    union {
        AppUninstallData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AppUninstallDataDefaultTypeInternal _AppUninstallData_default_instance_;
PROTOBUF_CONSTEXPR WebsiteTelemetry::WebsiteTelemetry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.website_metric_data_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct WebsiteTelemetryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WebsiteTelemetryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WebsiteTelemetryDefaultTypeInternal()
    {
    }
    union {
        WebsiteTelemetry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WebsiteTelemetryDefaultTypeInternal _WebsiteTelemetry_default_instance_;
PROTOBUF_CONSTEXPR WebsiteOpenedData::WebsiteOpenedData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.render_process_host_id_)*/ 0,
        /*decltype(_impl_.render_frame_routing_id_)*/ 0 }
{
}
struct WebsiteOpenedDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WebsiteOpenedDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WebsiteOpenedDataDefaultTypeInternal()
    {
    }
    union {
        WebsiteOpenedData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WebsiteOpenedDataDefaultTypeInternal _WebsiteOpenedData_default_instance_;
PROTOBUF_CONSTEXPR WebsiteClosedData::WebsiteClosedData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.render_process_host_id_)*/ 0,
        /*decltype(_impl_.render_frame_routing_id_)*/ 0 }
{
}
struct WebsiteClosedDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WebsiteClosedDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WebsiteClosedDataDefaultTypeInternal()
    {
    }
    union {
        WebsiteClosedData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WebsiteClosedDataDefaultTypeInternal _WebsiteClosedData_default_instance_;
PROTOBUF_CONSTEXPR WebsiteUsageData_WebsiteUsage::WebsiteUsageData_WebsiteUsage(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.running_time_ms_)*/ int64_t { 0 } }
{
}
struct WebsiteUsageData_WebsiteUsageDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WebsiteUsageData_WebsiteUsageDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WebsiteUsageData_WebsiteUsageDefaultTypeInternal()
    {
    }
    union {
        WebsiteUsageData_WebsiteUsage _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WebsiteUsageData_WebsiteUsageDefaultTypeInternal
    _WebsiteUsageData_WebsiteUsage_default_instance_;
PROTOBUF_CONSTEXPR WebsiteUsageData::WebsiteUsageData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.website_usage_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct WebsiteUsageDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WebsiteUsageDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WebsiteUsageDataDefaultTypeInternal()
    {
    }
    union {
        WebsiteUsageData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WebsiteUsageDataDefaultTypeInternal _WebsiteUsageData_default_instance_;
PROTOBUF_CONSTEXPR PeripheralsTelemetry::PeripheralsTelemetry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.usb_telemetry_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct PeripheralsTelemetryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PeripheralsTelemetryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PeripheralsTelemetryDefaultTypeInternal()
    {
    }
    union {
        PeripheralsTelemetry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PeripheralsTelemetryDefaultTypeInternal
    _PeripheralsTelemetry_default_instance_;
PROTOBUF_CONSTEXPR UsbTelemetry::UsbTelemetry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.categories_)*/ {},
        /*decltype(_impl_.vendor_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.firmware_version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.vid_)*/ 0,
        /*decltype(_impl_.pid_)*/ 0, /*decltype(_impl_.class_id_)*/ 0, /*decltype(_impl_.subclass_id_)*/ 0 }
{
}
struct UsbTelemetryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UsbTelemetryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UsbTelemetryDefaultTypeInternal()
    {
    }
    union {
        UsbTelemetry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UsbTelemetryDefaultTypeInternal _UsbTelemetry_default_instance_;
PROTOBUF_CONSTEXPR FatalCrashTelemetry::FatalCrashTelemetry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.crash_report_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.local_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.event_based_log_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.affiliated_user_)*/ nullptr, /*decltype(_impl_.type_)*/ 0, /*decltype(_impl_.session_type_)*/ 0,
        /*decltype(_impl_.timestamp_us_)*/ int64_t { 0 }, /*decltype(_impl_.been_reported_without_crash_report_id_)*/ false }
{
}
struct FatalCrashTelemetryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FatalCrashTelemetryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FatalCrashTelemetryDefaultTypeInternal()
    {
    }
    union {
        FatalCrashTelemetry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FatalCrashTelemetryDefaultTypeInternal
    _FatalCrashTelemetry_default_instance_;
PROTOBUF_CONSTEXPR RuntimeCountersTelemetry::RuntimeCountersTelemetry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.uptime_runtime_seconds_)*/ int64_t { 0 },
        /*decltype(_impl_.counter_enter_sleep_)*/ int64_t { 0 }, /*decltype(_impl_.counter_enter_hibernation_)*/ int64_t { 0 },
        /*decltype(_impl_.counter_enter_poweroff_)*/ int64_t { 0 } }
{
}
struct RuntimeCountersTelemetryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR RuntimeCountersTelemetryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~RuntimeCountersTelemetryDefaultTypeInternal()
    {
    }
    union {
        RuntimeCountersTelemetry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RuntimeCountersTelemetryDefaultTypeInternal
    _RuntimeCountersTelemetry_default_instance_;
PROTOBUF_CONSTEXPR EventData::EventData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.type_)*/ 0 }
{
}
struct EventDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR EventDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~EventDataDefaultTypeInternal()
    {
    }
    union {
        EventData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventDataDefaultTypeInternal _EventData_default_instance_;
PROTOBUF_CONSTEXPR MetricData::MetricData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.event_data_)*/ nullptr,
        /*decltype(_impl_.timestamp_ms_)*/ int64_t { 0 }, /*decltype(_impl_.metric_type_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct MetricDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR MetricDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~MetricDataDefaultTypeInternal()
    {
    }
    union {
        MetricData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MetricDataDefaultTypeInternal _MetricData_default_instance_;
} // namespace reporting
namespace reporting {
bool UserStatusTelemetry_DeviceActivityState_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserStatusTelemetry_DeviceActivityState_strings[4] = {};

static const char UserStatusTelemetry_DeviceActivityState_names[] = "ACTIVE"
                                                                    "DEVICE_ACTIVITY_STATE_UNKNOWN"
                                                                    "IDLE"
                                                                    "LOCKED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserStatusTelemetry_DeviceActivityState_entries[] = {
    { { UserStatusTelemetry_DeviceActivityState_names + 0, 6 }, 1 },
    { { UserStatusTelemetry_DeviceActivityState_names + 6, 29 }, 0 },
    { { UserStatusTelemetry_DeviceActivityState_names + 35, 4 }, 2 },
    { { UserStatusTelemetry_DeviceActivityState_names + 39, 6 }, 3 },
};

static const int UserStatusTelemetry_DeviceActivityState_entries_by_number[] = {
    1, // 0 -> DEVICE_ACTIVITY_STATE_UNKNOWN
    0, // 1 -> ACTIVE
    2, // 2 -> IDLE
    3, // 3 -> LOCKED
};

const std::string& UserStatusTelemetry_DeviceActivityState_Name(UserStatusTelemetry_DeviceActivityState value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(UserStatusTelemetry_DeviceActivityState_entries,
        UserStatusTelemetry_DeviceActivityState_entries_by_number, 4, UserStatusTelemetry_DeviceActivityState_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        UserStatusTelemetry_DeviceActivityState_entries, UserStatusTelemetry_DeviceActivityState_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : UserStatusTelemetry_DeviceActivityState_strings[idx].get();
}
bool UserStatusTelemetry_DeviceActivityState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStatusTelemetry_DeviceActivityState* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(UserStatusTelemetry_DeviceActivityState_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<UserStatusTelemetry_DeviceActivityState>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UserStatusTelemetry_DeviceActivityState UserStatusTelemetry::DEVICE_ACTIVITY_STATE_UNKNOWN;
constexpr UserStatusTelemetry_DeviceActivityState UserStatusTelemetry::ACTIVE;
constexpr UserStatusTelemetry_DeviceActivityState UserStatusTelemetry::IDLE;
constexpr UserStatusTelemetry_DeviceActivityState UserStatusTelemetry::LOCKED;
constexpr UserStatusTelemetry_DeviceActivityState UserStatusTelemetry::DeviceActivityState_MIN;
constexpr UserStatusTelemetry_DeviceActivityState UserStatusTelemetry::DeviceActivityState_MAX;
constexpr int UserStatusTelemetry::DeviceActivityState_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool KioskVisionStatusReport_KioskVisionState_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> KioskVisionStatusReport_KioskVisionState_strings[3] = {};

static const char KioskVisionStatusReport_KioskVisionState_names[] = "KIOSK_VISION_STATE_ACTIVE"
                                                                     "KIOSK_VISION_STATE_CAMERA_NOT_FOUND"
                                                                     "KIOSK_VISION_STATE_UNKNOWN_ERROR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry KioskVisionStatusReport_KioskVisionState_entries[] = {
    { { KioskVisionStatusReport_KioskVisionState_names + 0, 25 }, 0 },
    { { KioskVisionStatusReport_KioskVisionState_names + 25, 35 }, 2 },
    { { KioskVisionStatusReport_KioskVisionState_names + 60, 32 }, 1 },
};

static const int KioskVisionStatusReport_KioskVisionState_entries_by_number[] = {
    0, // 0 -> KIOSK_VISION_STATE_ACTIVE
    2, // 1 -> KIOSK_VISION_STATE_UNKNOWN_ERROR
    1, // 2 -> KIOSK_VISION_STATE_CAMERA_NOT_FOUND
};

const std::string& KioskVisionStatusReport_KioskVisionState_Name(KioskVisionStatusReport_KioskVisionState value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(KioskVisionStatusReport_KioskVisionState_entries,
        KioskVisionStatusReport_KioskVisionState_entries_by_number, 3, KioskVisionStatusReport_KioskVisionState_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        KioskVisionStatusReport_KioskVisionState_entries, KioskVisionStatusReport_KioskVisionState_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : KioskVisionStatusReport_KioskVisionState_strings[idx].get();
}
bool KioskVisionStatusReport_KioskVisionState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KioskVisionStatusReport_KioskVisionState* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(KioskVisionStatusReport_KioskVisionState_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<KioskVisionStatusReport_KioskVisionState>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr KioskVisionStatusReport_KioskVisionState KioskVisionStatusReport::KIOSK_VISION_STATE_ACTIVE;
constexpr KioskVisionStatusReport_KioskVisionState KioskVisionStatusReport::KIOSK_VISION_STATE_UNKNOWN_ERROR;
constexpr KioskVisionStatusReport_KioskVisionState KioskVisionStatusReport::KIOSK_VISION_STATE_CAMERA_NOT_FOUND;
constexpr KioskVisionStatusReport_KioskVisionState KioskVisionStatusReport::KioskVisionState_MIN;
constexpr KioskVisionStatusReport_KioskVisionState KioskVisionStatusReport::KioskVisionState_MAX;
constexpr int KioskVisionStatusReport::KioskVisionState_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool FatalCrashTelemetry_CrashType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FatalCrashTelemetry_CrashType_strings[4] = {};

static const char FatalCrashTelemetry_CrashType_names[] = "CRASH_TYPE_CHROME"
                                                          "CRASH_TYPE_EMBEDDED_CONTROLLER"
                                                          "CRASH_TYPE_KERNEL"
                                                          "CRASH_TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FatalCrashTelemetry_CrashType_entries[] = {
    { { FatalCrashTelemetry_CrashType_names + 0, 17 }, 3 },
    { { FatalCrashTelemetry_CrashType_names + 17, 30 }, 2 },
    { { FatalCrashTelemetry_CrashType_names + 47, 17 }, 1 },
    { { FatalCrashTelemetry_CrashType_names + 64, 22 }, 0 },
};

static const int FatalCrashTelemetry_CrashType_entries_by_number[] = {
    3, // 0 -> CRASH_TYPE_UNSPECIFIED
    2, // 1 -> CRASH_TYPE_KERNEL
    1, // 2 -> CRASH_TYPE_EMBEDDED_CONTROLLER
    0, // 3 -> CRASH_TYPE_CHROME
};

const std::string& FatalCrashTelemetry_CrashType_Name(FatalCrashTelemetry_CrashType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        FatalCrashTelemetry_CrashType_entries, FatalCrashTelemetry_CrashType_entries_by_number, 4, FatalCrashTelemetry_CrashType_strings);
    (void)dummy;
    int idx
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(FatalCrashTelemetry_CrashType_entries, FatalCrashTelemetry_CrashType_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : FatalCrashTelemetry_CrashType_strings[idx].get();
}
bool FatalCrashTelemetry_CrashType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FatalCrashTelemetry_CrashType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(FatalCrashTelemetry_CrashType_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<FatalCrashTelemetry_CrashType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr FatalCrashTelemetry_CrashType FatalCrashTelemetry::CRASH_TYPE_UNSPECIFIED;
constexpr FatalCrashTelemetry_CrashType FatalCrashTelemetry::CRASH_TYPE_KERNEL;
constexpr FatalCrashTelemetry_CrashType FatalCrashTelemetry::CRASH_TYPE_EMBEDDED_CONTROLLER;
constexpr FatalCrashTelemetry_CrashType FatalCrashTelemetry::CRASH_TYPE_CHROME;
constexpr FatalCrashTelemetry_CrashType FatalCrashTelemetry::CrashType_MIN;
constexpr FatalCrashTelemetry_CrashType FatalCrashTelemetry::CrashType_MAX;
constexpr int FatalCrashTelemetry::CrashType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool FatalCrashTelemetry_SessionType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> FatalCrashTelemetry_SessionType_strings[9] = {};

static const char FatalCrashTelemetry_SessionType_names[] = "SESSION_TYPE_ACTIVE_DIRECTORY"
                                                            "SESSION_TYPE_ARC_KIOSK_APP"
                                                            "SESSION_TYPE_CHILD"
                                                            "SESSION_TYPE_GUEST"
                                                            "SESSION_TYPE_KIOSK_APP"
                                                            "SESSION_TYPE_PUBLIC_ACCOUNT"
                                                            "SESSION_TYPE_REGULAR"
                                                            "SESSION_TYPE_UNSPECIFIED"
                                                            "SESSION_TYPE_WEB_KIOSK_APP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry FatalCrashTelemetry_SessionType_entries[] = {
    { { FatalCrashTelemetry_SessionType_names + 0, 29 }, 8 },
    { { FatalCrashTelemetry_SessionType_names + 29, 26 }, 4 },
    { { FatalCrashTelemetry_SessionType_names + 55, 18 }, 2 },
    { { FatalCrashTelemetry_SessionType_names + 73, 18 }, 6 },
    { { FatalCrashTelemetry_SessionType_names + 91, 22 }, 3 },
    { { FatalCrashTelemetry_SessionType_names + 113, 27 }, 7 },
    { { FatalCrashTelemetry_SessionType_names + 140, 20 }, 1 },
    { { FatalCrashTelemetry_SessionType_names + 160, 24 }, 0 },
    { { FatalCrashTelemetry_SessionType_names + 184, 26 }, 5 },
};

static const int FatalCrashTelemetry_SessionType_entries_by_number[] = {
    7, // 0 -> SESSION_TYPE_UNSPECIFIED
    6, // 1 -> SESSION_TYPE_REGULAR
    2, // 2 -> SESSION_TYPE_CHILD
    4, // 3 -> SESSION_TYPE_KIOSK_APP
    1, // 4 -> SESSION_TYPE_ARC_KIOSK_APP
    8, // 5 -> SESSION_TYPE_WEB_KIOSK_APP
    3, // 6 -> SESSION_TYPE_GUEST
    5, // 7 -> SESSION_TYPE_PUBLIC_ACCOUNT
    0, // 8 -> SESSION_TYPE_ACTIVE_DIRECTORY
};

const std::string& FatalCrashTelemetry_SessionType_Name(FatalCrashTelemetry_SessionType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        FatalCrashTelemetry_SessionType_entries, FatalCrashTelemetry_SessionType_entries_by_number, 9, FatalCrashTelemetry_SessionType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        FatalCrashTelemetry_SessionType_entries, FatalCrashTelemetry_SessionType_entries_by_number, 9, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : FatalCrashTelemetry_SessionType_strings[idx].get();
}
bool FatalCrashTelemetry_SessionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FatalCrashTelemetry_SessionType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(FatalCrashTelemetry_SessionType_entries, 9, name, &int_value);
    if (success) {
        *value = static_cast<FatalCrashTelemetry_SessionType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr FatalCrashTelemetry_SessionType FatalCrashTelemetry::SESSION_TYPE_UNSPECIFIED;
constexpr FatalCrashTelemetry_SessionType FatalCrashTelemetry::SESSION_TYPE_REGULAR;
constexpr FatalCrashTelemetry_SessionType FatalCrashTelemetry::SESSION_TYPE_CHILD;
constexpr FatalCrashTelemetry_SessionType FatalCrashTelemetry::SESSION_TYPE_KIOSK_APP;
constexpr FatalCrashTelemetry_SessionType FatalCrashTelemetry::SESSION_TYPE_ARC_KIOSK_APP;
constexpr FatalCrashTelemetry_SessionType FatalCrashTelemetry::SESSION_TYPE_WEB_KIOSK_APP;
constexpr FatalCrashTelemetry_SessionType FatalCrashTelemetry::SESSION_TYPE_GUEST;
constexpr FatalCrashTelemetry_SessionType FatalCrashTelemetry::SESSION_TYPE_PUBLIC_ACCOUNT;
constexpr FatalCrashTelemetry_SessionType FatalCrashTelemetry::SESSION_TYPE_ACTIVE_DIRECTORY;
constexpr FatalCrashTelemetry_SessionType FatalCrashTelemetry::SessionType_MIN;
constexpr FatalCrashTelemetry_SessionType FatalCrashTelemetry::SessionType_MAX;
constexpr int FatalCrashTelemetry::SessionType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RoutineVerdict_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RoutineVerdict_strings[4] = {};

static const char RoutineVerdict_names[] = "NOT_RUN"
                                           "NO_PROBLEM"
                                           "PROBLEM"
                                           "ROUTINE_VERDICT_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RoutineVerdict_entries[] = {
    { { RoutineVerdict_names + 0, 7 }, 3 },
    { { RoutineVerdict_names + 7, 10 }, 1 },
    { { RoutineVerdict_names + 17, 7 }, 2 },
    { { RoutineVerdict_names + 24, 27 }, 0 },
};

static const int RoutineVerdict_entries_by_number[] = {
    3, // 0 -> ROUTINE_VERDICT_UNSPECIFIED
    1, // 1 -> NO_PROBLEM
    2, // 2 -> PROBLEM
    0, // 3 -> NOT_RUN
};

const std::string& RoutineVerdict_Name(RoutineVerdict value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(RoutineVerdict_entries, RoutineVerdict_entries_by_number, 4, RoutineVerdict_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(RoutineVerdict_entries, RoutineVerdict_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : RoutineVerdict_strings[idx].get();
}
bool RoutineVerdict_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RoutineVerdict* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(RoutineVerdict_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<RoutineVerdict>(int_value);
    }
    return success;
}
bool HttpsLatencyProblem_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> HttpsLatencyProblem_strings[5] = {};

static const char HttpsLatencyProblem_names[] = "FAILED_DNS_RESOLUTIONS"
                                                "FAILED_HTTPS_REQUESTS"
                                                "HIGH_LATENCY"
                                                "HTTPS_LATENCY_PROBLEM_UNSPECIFIED"
                                                "VERY_HIGH_LATENCY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry HttpsLatencyProblem_entries[] = {
    { { HttpsLatencyProblem_names + 0, 22 }, 1 },
    { { HttpsLatencyProblem_names + 22, 21 }, 2 },
    { { HttpsLatencyProblem_names + 43, 12 }, 3 },
    { { HttpsLatencyProblem_names + 55, 33 }, 0 },
    { { HttpsLatencyProblem_names + 88, 17 }, 4 },
};

static const int HttpsLatencyProblem_entries_by_number[] = {
    3, // 0 -> HTTPS_LATENCY_PROBLEM_UNSPECIFIED
    0, // 1 -> FAILED_DNS_RESOLUTIONS
    1, // 2 -> FAILED_HTTPS_REQUESTS
    2, // 3 -> HIGH_LATENCY
    4, // 4 -> VERY_HIGH_LATENCY
};

const std::string& HttpsLatencyProblem_Name(HttpsLatencyProblem value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        HttpsLatencyProblem_entries, HttpsLatencyProblem_entries_by_number, 5, HttpsLatencyProblem_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(HttpsLatencyProblem_entries, HttpsLatencyProblem_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : HttpsLatencyProblem_strings[idx].get();
}
bool HttpsLatencyProblem_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HttpsLatencyProblem* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(HttpsLatencyProblem_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<HttpsLatencyProblem>(int_value);
    }
    return success;
}
bool NetworkConnectionState_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetworkConnectionState_strings[6] = {};

static const char NetworkConnectionState_names[] = "CONNECTED"
                                                   "CONNECTING"
                                                   "NETWORK_CONNECTION_STATE_UNSPECIFIED"
                                                   "NOT_CONNECTED"
                                                   "ONLINE"
                                                   "PORTAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetworkConnectionState_entries[] = {
    { { NetworkConnectionState_names + 0, 9 }, 2 },
    { { NetworkConnectionState_names + 9, 10 }, 4 },
    { { NetworkConnectionState_names + 19, 36 }, 0 },
    { { NetworkConnectionState_names + 55, 13 }, 5 },
    { { NetworkConnectionState_names + 68, 6 }, 1 },
    { { NetworkConnectionState_names + 74, 6 }, 3 },
};

static const int NetworkConnectionState_entries_by_number[] = {
    2, // 0 -> NETWORK_CONNECTION_STATE_UNSPECIFIED
    4, // 1 -> ONLINE
    0, // 2 -> CONNECTED
    5, // 3 -> PORTAL
    1, // 4 -> CONNECTING
    3, // 5 -> NOT_CONNECTED
};

const std::string& NetworkConnectionState_Name(NetworkConnectionState value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        NetworkConnectionState_entries, NetworkConnectionState_entries_by_number, 6, NetworkConnectionState_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(NetworkConnectionState_entries, NetworkConnectionState_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : NetworkConnectionState_strings[idx].get();
}
bool NetworkConnectionState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkConnectionState* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(NetworkConnectionState_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<NetworkConnectionState>(int_value);
    }
    return success;
}
bool NetworkType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetworkType_strings[6] = {};

static const char NetworkType_names[] = "CELLULAR"
                                        "ETHERNET"
                                        "NETWORK_TYPE_UNSPECIFIED"
                                        "TETHER"
                                        "VPN"
                                        "WIFI";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetworkType_entries[] = {
    { { NetworkType_names + 0, 8 }, 1 },
    { { NetworkType_names + 8, 8 }, 2 },
    { { NetworkType_names + 16, 24 }, 0 },
    { { NetworkType_names + 40, 6 }, 3 },
    { { NetworkType_names + 46, 3 }, 4 },
    { { NetworkType_names + 49, 4 }, 5 },
};

static const int NetworkType_entries_by_number[] = {
    2, // 0 -> NETWORK_TYPE_UNSPECIFIED
    0, // 1 -> CELLULAR
    1, // 2 -> ETHERNET
    3, // 3 -> TETHER
    4, // 4 -> VPN
    5, // 5 -> WIFI
};

const std::string& NetworkType_Name(NetworkType value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(NetworkType_entries, NetworkType_entries_by_number, 6, NetworkType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(NetworkType_entries, NetworkType_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : NetworkType_strings[idx].get();
}
bool NetworkType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(NetworkType_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<NetworkType>(int_value);
    }
    return success;
}
bool ThunderboltSecurityLevel_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ThunderboltSecurityLevel_strings[7] = {};

static const char ThunderboltSecurityLevel_names[] = "THUNDERBOLT_SECURITY_DP_ONLY_LEVEL"
                                                     "THUNDERBOLT_SECURITY_NONE_LEVEL"
                                                     "THUNDERBOLT_SECURITY_NO_PCIE_LEVEL"
                                                     "THUNDERBOLT_SECURITY_SECURE_LEVEL"
                                                     "THUNDERBOLT_SECURITY_USB_ONLY_LEVEL"
                                                     "THUNDERBOLT_SECURITY_USER_LEVEL"
                                                     "UNSPECIFIED_THUNDERBOLT_SECURITY_LEVEL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ThunderboltSecurityLevel_entries[] = {
    { { ThunderboltSecurityLevel_names + 0, 34 }, 4 },
    { { ThunderboltSecurityLevel_names + 34, 31 }, 1 },
    { { ThunderboltSecurityLevel_names + 65, 34 }, 6 },
    { { ThunderboltSecurityLevel_names + 99, 33 }, 3 },
    { { ThunderboltSecurityLevel_names + 132, 35 }, 5 },
    { { ThunderboltSecurityLevel_names + 167, 31 }, 2 },
    { { ThunderboltSecurityLevel_names + 198, 38 }, 0 },
};

static const int ThunderboltSecurityLevel_entries_by_number[] = {
    6, // 0 -> UNSPECIFIED_THUNDERBOLT_SECURITY_LEVEL
    1, // 1 -> THUNDERBOLT_SECURITY_NONE_LEVEL
    5, // 2 -> THUNDERBOLT_SECURITY_USER_LEVEL
    3, // 3 -> THUNDERBOLT_SECURITY_SECURE_LEVEL
    0, // 4 -> THUNDERBOLT_SECURITY_DP_ONLY_LEVEL
    4, // 5 -> THUNDERBOLT_SECURITY_USB_ONLY_LEVEL
    2, // 6 -> THUNDERBOLT_SECURITY_NO_PCIE_LEVEL
};

const std::string& ThunderboltSecurityLevel_Name(ThunderboltSecurityLevel value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ThunderboltSecurityLevel_entries, ThunderboltSecurityLevel_entries_by_number, 7, ThunderboltSecurityLevel_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ThunderboltSecurityLevel_entries, ThunderboltSecurityLevel_entries_by_number, 7, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ThunderboltSecurityLevel_strings[idx].get();
}
bool ThunderboltSecurityLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThunderboltSecurityLevel* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ThunderboltSecurityLevel_entries, 7, name, &int_value);
    if (success) {
        *value = static_cast<ThunderboltSecurityLevel>(int_value);
    }
    return success;
}
bool MemoryEncryptionState_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MemoryEncryptionState_strings[5] = {};

static const char MemoryEncryptionState_names[] = "MEMORY_ENCRYPTION_STATE_DISABLED"
                                                  "MEMORY_ENCRYPTION_STATE_MKTME"
                                                  "MEMORY_ENCRYPTION_STATE_TME"
                                                  "MEMORY_ENCRYPTION_STATE_UNKNOWN"
                                                  "UNSPECIFIED_MEMORY_ENCRYPTION_STATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MemoryEncryptionState_entries[] = {
    { { MemoryEncryptionState_names + 0, 32 }, 2 },
    { { MemoryEncryptionState_names + 32, 29 }, 4 },
    { { MemoryEncryptionState_names + 61, 27 }, 3 },
    { { MemoryEncryptionState_names + 88, 31 }, 1 },
    { { MemoryEncryptionState_names + 119, 35 }, 0 },
};

static const int MemoryEncryptionState_entries_by_number[] = {
    4, // 0 -> UNSPECIFIED_MEMORY_ENCRYPTION_STATE
    3, // 1 -> MEMORY_ENCRYPTION_STATE_UNKNOWN
    0, // 2 -> MEMORY_ENCRYPTION_STATE_DISABLED
    2, // 3 -> MEMORY_ENCRYPTION_STATE_TME
    1, // 4 -> MEMORY_ENCRYPTION_STATE_MKTME
};

const std::string& MemoryEncryptionState_Name(MemoryEncryptionState value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        MemoryEncryptionState_entries, MemoryEncryptionState_entries_by_number, 5, MemoryEncryptionState_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(MemoryEncryptionState_entries, MemoryEncryptionState_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : MemoryEncryptionState_strings[idx].get();
}
bool MemoryEncryptionState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MemoryEncryptionState* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(MemoryEncryptionState_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<MemoryEncryptionState>(int_value);
    }
    return success;
}
bool MemoryEncryptionAlgorithm_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MemoryEncryptionAlgorithm_strings[4] = {};

static const char MemoryEncryptionAlgorithm_names[] = "MEMORY_ENCRYPTION_ALGORITHM_AES_XTS_128"
                                                      "MEMORY_ENCRYPTION_ALGORITHM_AES_XTS_256"
                                                      "MEMORY_ENCRYPTION_ALGORITHM_UNKNOWN"
                                                      "UNSPECIFIED_MEMORY_ENCRYPTION_ALGORITHM";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MemoryEncryptionAlgorithm_entries[] = {
    { { MemoryEncryptionAlgorithm_names + 0, 39 }, 2 },
    { { MemoryEncryptionAlgorithm_names + 39, 39 }, 3 },
    { { MemoryEncryptionAlgorithm_names + 78, 35 }, 1 },
    { { MemoryEncryptionAlgorithm_names + 113, 39 }, 0 },
};

static const int MemoryEncryptionAlgorithm_entries_by_number[] = {
    3, // 0 -> UNSPECIFIED_MEMORY_ENCRYPTION_ALGORITHM
    2, // 1 -> MEMORY_ENCRYPTION_ALGORITHM_UNKNOWN
    0, // 2 -> MEMORY_ENCRYPTION_ALGORITHM_AES_XTS_128
    1, // 3 -> MEMORY_ENCRYPTION_ALGORITHM_AES_XTS_256
};

const std::string& MemoryEncryptionAlgorithm_Name(MemoryEncryptionAlgorithm value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        MemoryEncryptionAlgorithm_entries, MemoryEncryptionAlgorithm_entries_by_number, 4, MemoryEncryptionAlgorithm_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(MemoryEncryptionAlgorithm_entries, MemoryEncryptionAlgorithm_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : MemoryEncryptionAlgorithm_strings[idx].get();
}
bool MemoryEncryptionAlgorithm_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MemoryEncryptionAlgorithm* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(MemoryEncryptionAlgorithm_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<MemoryEncryptionAlgorithm>(int_value);
    }
    return success;
}
bool NetworkDeviceType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NetworkDeviceType_strings[4] = {};

static const char NetworkDeviceType_names[] = "CELLULAR_DEVICE"
                                              "ETHERNET_DEVICE"
                                              "NETWORK_DEVICE_TYPE_UNSPECIFIED"
                                              "WIFI_DEVICE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NetworkDeviceType_entries[] = {
    { { NetworkDeviceType_names + 0, 15 }, 1 },
    { { NetworkDeviceType_names + 15, 15 }, 2 },
    { { NetworkDeviceType_names + 30, 31 }, 0 },
    { { NetworkDeviceType_names + 61, 11 }, 5 },
};

static const int NetworkDeviceType_entries_by_number[] = {
    2, // 0 -> NETWORK_DEVICE_TYPE_UNSPECIFIED
    0, // 1 -> CELLULAR_DEVICE
    1, // 2 -> ETHERNET_DEVICE
    3, // 5 -> WIFI_DEVICE
};

const std::string& NetworkDeviceType_Name(NetworkDeviceType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        NetworkDeviceType_entries, NetworkDeviceType_entries_by_number, 4, NetworkDeviceType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(NetworkDeviceType_entries, NetworkDeviceType_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : NetworkDeviceType_strings[idx].get();
}
bool NetworkDeviceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkDeviceType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(NetworkDeviceType_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<NetworkDeviceType>(int_value);
    }
    return success;
}
bool MetricEventType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> MetricEventType_strings[16] = {};

static const char MetricEventType_names[] = "APP_INSTALLED"
                                            "APP_LAUNCHED"
                                            "APP_UNINSTALLED"
                                            "AUDIO_SEVERE_UNDERRUN"
                                            "EVENT_TYPE_UNSPECIFIED"
                                            "FATAL_CRASH"
                                            "KIOSK_HEARTBEAT"
                                            "NETWORK_HTTPS_LATENCY_CHANGE"
                                            "NETWORK_STATE_CHANGE"
                                            "URL_CLOSED"
                                            "URL_OPENED"
                                            "USB_ADDED"
                                            "USB_REMOVED"
                                            "VPN_CONNECTION_STATE_CHANGE"
                                            "WIFI_SIGNAL_STRENGTH_LOW"
                                            "WIFI_SIGNAL_STRENGTH_RECOVERED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry MetricEventType_entries[] = {
    { { MetricEventType_names + 0, 13 }, 7 },
    { { MetricEventType_names + 13, 12 }, 9 },
    { { MetricEventType_names + 25, 15 }, 8 },
    { { MetricEventType_names + 40, 21 }, 4 },
    { { MetricEventType_names + 61, 22 }, 0 },
    { { MetricEventType_names + 83, 11 }, 17 },
    { { MetricEventType_names + 94, 15 }, 20 },
    { { MetricEventType_names + 109, 28 }, 1 },
    { { MetricEventType_names + 137, 20 }, 15 },
    { { MetricEventType_names + 157, 10 }, 19 },
    { { MetricEventType_names + 167, 10 }, 18 },
    { { MetricEventType_names + 177, 9 }, 5 },
    { { MetricEventType_names + 186, 11 }, 6 },
    { { MetricEventType_names + 197, 27 }, 16 },
    { { MetricEventType_names + 224, 24 }, 13 },
    { { MetricEventType_names + 248, 30 }, 14 },
};

static const int MetricEventType_entries_by_number[] = {
    4, // 0 -> EVENT_TYPE_UNSPECIFIED
    7, // 1 -> NETWORK_HTTPS_LATENCY_CHANGE
    3, // 4 -> AUDIO_SEVERE_UNDERRUN
    11, // 5 -> USB_ADDED
    12, // 6 -> USB_REMOVED
    0, // 7 -> APP_INSTALLED
    2, // 8 -> APP_UNINSTALLED
    1, // 9 -> APP_LAUNCHED
    14, // 13 -> WIFI_SIGNAL_STRENGTH_LOW
    15, // 14 -> WIFI_SIGNAL_STRENGTH_RECOVERED
    8, // 15 -> NETWORK_STATE_CHANGE
    13, // 16 -> VPN_CONNECTION_STATE_CHANGE
    5, // 17 -> FATAL_CRASH
    10, // 18 -> URL_OPENED
    9, // 19 -> URL_CLOSED
    6, // 20 -> KIOSK_HEARTBEAT
};

const std::string& MetricEventType_Name(MetricEventType value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(MetricEventType_entries, MetricEventType_entries_by_number, 16, MetricEventType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(MetricEventType_entries, MetricEventType_entries_by_number, 16, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : MetricEventType_strings[idx].get();
}
bool MetricEventType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MetricEventType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(MetricEventType_entries, 16, name, &int_value);
    if (success) {
        *value = static_cast<MetricEventType>(int_value);
    }
    return success;
}

// ===================================================================

class HttpsLatencyRoutineData::_Internal {
public:
    using HasBits = decltype(std::declval<HttpsLatencyRoutineData>()._impl_._has_bits_);
    static void set_has_verdict(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_problem(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_latency_ms(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

HttpsLatencyRoutineData::HttpsLatencyRoutineData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.HttpsLatencyRoutineData)
}
HttpsLatencyRoutineData::HttpsLatencyRoutineData(const HttpsLatencyRoutineData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    HttpsLatencyRoutineData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.verdict_) {},
        decltype(_impl_.problem_) {}, decltype(_impl_.latency_ms_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.verdict_, &from._impl_.verdict_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.latency_ms_) - reinterpret_cast<char*>(&_impl_.verdict_)) + sizeof(_impl_.latency_ms_));
    // @@protoc_insertion_point(copy_constructor:reporting.HttpsLatencyRoutineData)
}

inline void HttpsLatencyRoutineData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.verdict_) { 0 },
        decltype(_impl_.problem_) { 0 }, decltype(_impl_.latency_ms_) { int64_t { 0 } } };
}

HttpsLatencyRoutineData::~HttpsLatencyRoutineData()
{
    // @@protoc_insertion_point(destructor:reporting.HttpsLatencyRoutineData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void HttpsLatencyRoutineData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HttpsLatencyRoutineData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void HttpsLatencyRoutineData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.HttpsLatencyRoutineData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        ::memset(&_impl_.verdict_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.latency_ms_) - reinterpret_cast<char*>(&_impl_.verdict_)) + sizeof(_impl_.latency_ms_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* HttpsLatencyRoutineData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .reporting.RoutineVerdict verdict = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::reporting::RoutineVerdict_IsValid(val))) {
                    _internal_set_verdict(static_cast<::reporting::RoutineVerdict>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.HttpsLatencyProblem problem = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::reporting::HttpsLatencyProblem_IsValid(val))) {
                    _internal_set_problem(static_cast<::reporting::HttpsLatencyProblem>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 latency_ms = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_latency_ms(&has_bits);
                _impl_.latency_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* HttpsLatencyRoutineData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.HttpsLatencyRoutineData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .reporting.RoutineVerdict verdict = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_verdict(), target);
    }

    // optional .reporting.HttpsLatencyProblem problem = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_problem(), target);
    }

    // optional int64 latency_ms = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_latency_ms(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.HttpsLatencyRoutineData)
    return target;
}

size_t HttpsLatencyRoutineData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.HttpsLatencyRoutineData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional .reporting.RoutineVerdict verdict = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_verdict());
        }

        // optional .reporting.HttpsLatencyProblem problem = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_problem());
        }

        // optional int64 latency_ms = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_latency_ms());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void HttpsLatencyRoutineData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const HttpsLatencyRoutineData*>(&from));
}

void HttpsLatencyRoutineData::MergeFrom(const HttpsLatencyRoutineData& from)
{
    HttpsLatencyRoutineData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.HttpsLatencyRoutineData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.verdict_ = from._impl_.verdict_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.problem_ = from._impl_.problem_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.latency_ms_ = from._impl_.latency_ms_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HttpsLatencyRoutineData::CopyFrom(const HttpsLatencyRoutineData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.HttpsLatencyRoutineData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool HttpsLatencyRoutineData::IsInitialized() const
{
    return true;
}

void HttpsLatencyRoutineData::InternalSwap(HttpsLatencyRoutineData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(HttpsLatencyRoutineData, _impl_.latency_ms_)
        + sizeof(HttpsLatencyRoutineData::_impl_.latency_ms_) - PROTOBUF_FIELD_OFFSET(HttpsLatencyRoutineData, _impl_.verdict_)>(
        reinterpret_cast<char*>(&_impl_.verdict_), reinterpret_cast<char*>(&other->_impl_.verdict_));
}

std::string HttpsLatencyRoutineData::GetTypeName() const
{
    return "reporting.HttpsLatencyRoutineData";
}

// ===================================================================

class BandwidthData::_Internal {
public:
    using HasBits = decltype(std::declval<BandwidthData>()._impl_._has_bits_);
    static void set_has_download_speed_kbps(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_upload_speed_kbps(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

BandwidthData::BandwidthData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.BandwidthData)
}
BandwidthData::BandwidthData(const BandwidthData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    BandwidthData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.download_speed_kbps_) {}, decltype(_impl_.upload_speed_kbps_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.download_speed_kbps_, &from._impl_.download_speed_kbps_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.upload_speed_kbps_) - reinterpret_cast<char*>(&_impl_.download_speed_kbps_))
            + sizeof(_impl_.upload_speed_kbps_));
    // @@protoc_insertion_point(copy_constructor:reporting.BandwidthData)
}

inline void BandwidthData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.download_speed_kbps_) { int64_t { 0 } },
        decltype(_impl_.upload_speed_kbps_) { int64_t { 0 } } };
}

BandwidthData::~BandwidthData()
{
    // @@protoc_insertion_point(destructor:reporting.BandwidthData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void BandwidthData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BandwidthData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void BandwidthData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.BandwidthData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.download_speed_kbps_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.upload_speed_kbps_) - reinterpret_cast<char*>(&_impl_.download_speed_kbps_))
                + sizeof(_impl_.upload_speed_kbps_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* BandwidthData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 download_speed_kbps = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_download_speed_kbps(&has_bits);
                _impl_.download_speed_kbps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 upload_speed_kbps = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_upload_speed_kbps(&has_bits);
                _impl_.upload_speed_kbps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* BandwidthData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.BandwidthData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 download_speed_kbps = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_download_speed_kbps(), target);
    }

    // optional int64 upload_speed_kbps = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_upload_speed_kbps(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.BandwidthData)
    return target;
}

size_t BandwidthData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.BandwidthData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int64 download_speed_kbps = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_download_speed_kbps());
        }

        // optional int64 upload_speed_kbps = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_upload_speed_kbps());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void BandwidthData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const BandwidthData*>(&from));
}

void BandwidthData::MergeFrom(const BandwidthData& from)
{
    BandwidthData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.BandwidthData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.download_speed_kbps_ = from._impl_.download_speed_kbps_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.upload_speed_kbps_ = from._impl_.upload_speed_kbps_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BandwidthData::CopyFrom(const BandwidthData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.BandwidthData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool BandwidthData::IsInitialized() const
{
    return true;
}

void BandwidthData::InternalSwap(BandwidthData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(BandwidthData, _impl_.upload_speed_kbps_)
        + sizeof(BandwidthData::_impl_.upload_speed_kbps_) - PROTOBUF_FIELD_OFFSET(BandwidthData, _impl_.download_speed_kbps_)>(
        reinterpret_cast<char*>(&_impl_.download_speed_kbps_), reinterpret_cast<char*>(&other->_impl_.download_speed_kbps_));
}

std::string BandwidthData::GetTypeName() const
{
    return "reporting.BandwidthData";
}

// ===================================================================

class NetworkTelemetry::_Internal {
public:
    using HasBits = decltype(std::declval<NetworkTelemetry>()._impl_._has_bits_);
    static void set_has_guid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_connection_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_signal_strength(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_device_path(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_ip_address(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_gateway(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_tx_bit_rate_mbps(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_rx_bit_rate_mbps(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_tx_power_dbm(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_encryption_on(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_link_quality(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_power_management_enabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static void set_has_signal_strength_dbm(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
};

NetworkTelemetry::NetworkTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.NetworkTelemetry)
}
NetworkTelemetry::NetworkTelemetry(const NetworkTelemetry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    NetworkTelemetry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.guid_) {},
        decltype(_impl_.device_path_) {}, decltype(_impl_.ip_address_) {}, decltype(_impl_.gateway_) {}, decltype(_impl_.connection_state_) {},
        decltype(_impl_.signal_strength_) {}, decltype(_impl_.tx_bit_rate_mbps_) {}, decltype(_impl_.type_) {}, decltype(_impl_.tx_power_dbm_) {},
        decltype(_impl_.rx_bit_rate_mbps_) {}, decltype(_impl_.link_quality_) {}, decltype(_impl_.encryption_on_) {},
        decltype(_impl_.power_management_enabled_) {}, decltype(_impl_.signal_strength_dbm_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_guid()) {
        _this->_impl_.guid_.Set(from._internal_guid(), _this->GetArenaForAllocation());
    }
    _impl_.device_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_device_path()) {
        _this->_impl_.device_path_.Set(from._internal_device_path(), _this->GetArenaForAllocation());
    }
    _impl_.ip_address_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_address_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_ip_address()) {
        _this->_impl_.ip_address_.Set(from._internal_ip_address(), _this->GetArenaForAllocation());
    }
    _impl_.gateway_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gateway_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_gateway()) {
        _this->_impl_.gateway_.Set(from._internal_gateway(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.connection_state_, &from._impl_.connection_state_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.signal_strength_dbm_) - reinterpret_cast<char*>(&_impl_.connection_state_))
            + sizeof(_impl_.signal_strength_dbm_));
    // @@protoc_insertion_point(copy_constructor:reporting.NetworkTelemetry)
}

inline void NetworkTelemetry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.guid_) {}, decltype(_impl_.device_path_) {},
        decltype(_impl_.ip_address_) {}, decltype(_impl_.gateway_) {}, decltype(_impl_.connection_state_) { 0 }, decltype(_impl_.signal_strength_) { 0 },
        decltype(_impl_.tx_bit_rate_mbps_) { int64_t { 0 } }, decltype(_impl_.type_) { 0 }, decltype(_impl_.tx_power_dbm_) { 0 },
        decltype(_impl_.rx_bit_rate_mbps_) { int64_t { 0 } }, decltype(_impl_.link_quality_) { int64_t { 0 } }, decltype(_impl_.encryption_on_) { false },
        decltype(_impl_.power_management_enabled_) { false }, decltype(_impl_.signal_strength_dbm_) { 0 } };
    _impl_.guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_address_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ip_address_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gateway_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gateway_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NetworkTelemetry::~NetworkTelemetry()
{
    // @@protoc_insertion_point(destructor:reporting.NetworkTelemetry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void NetworkTelemetry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.guid_.Destroy();
    _impl_.device_path_.Destroy();
    _impl_.ip_address_.Destroy();
    _impl_.gateway_.Destroy();
}

void NetworkTelemetry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void NetworkTelemetry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.NetworkTelemetry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.guid_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.device_path_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.ip_address_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.gateway_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x000000f0u) {
        ::memset(&_impl_.connection_state_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) - reinterpret_cast<char*>(&_impl_.connection_state_)) + sizeof(_impl_.type_));
    }
    if (cached_has_bits & 0x00003f00u) {
        ::memset(&_impl_.tx_power_dbm_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.signal_strength_dbm_) - reinterpret_cast<char*>(&_impl_.tx_power_dbm_))
                + sizeof(_impl_.signal_strength_dbm_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* NetworkTelemetry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string guid = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_guid();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.NetworkConnectionState connection_state = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::reporting::NetworkConnectionState_IsValid(val))) {
                    _internal_set_connection_state(static_cast<::reporting::NetworkConnectionState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int32 signal_strength = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_signal_strength(&has_bits);
                _impl_.signal_strength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string device_path = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_device_path();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string ip_address = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_ip_address();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string gateway = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_gateway();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.NetworkType type = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::reporting::NetworkType_IsValid(val))) {
                    _internal_set_type(static_cast<::reporting::NetworkType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 tx_bit_rate_mbps = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _Internal::set_has_tx_bit_rate_mbps(&has_bits);
                _impl_.tx_bit_rate_mbps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 rx_bit_rate_mbps = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                _Internal::set_has_rx_bit_rate_mbps(&has_bits);
                _impl_.rx_bit_rate_mbps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 tx_power_dbm = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
                _Internal::set_has_tx_power_dbm(&has_bits);
                _impl_.tx_power_dbm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool encryption_on = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                _Internal::set_has_encryption_on(&has_bits);
                _impl_.encryption_on_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 link_quality = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                _Internal::set_has_link_quality(&has_bits);
                _impl_.link_quality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool power_management_enabled = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
                _Internal::set_has_power_management_enabled(&has_bits);
                _impl_.power_management_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 signal_strength_dbm = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
                _Internal::set_has_signal_strength_dbm(&has_bits);
                _impl_.signal_strength_dbm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* NetworkTelemetry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.NetworkTelemetry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string guid = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_guid(), target);
    }

    // optional .reporting.NetworkConnectionState connection_state = 2;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_connection_state(), target);
    }

    // optional int32 signal_strength = 3;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_signal_strength(), target);
    }

    // optional string device_path = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_device_path(), target);
    }

    // optional string ip_address = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_ip_address(), target);
    }

    // optional string gateway = 6;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(6, this->_internal_gateway(), target);
    }

    // optional .reporting.NetworkType type = 7;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(7, this->_internal_type(), target);
    }

    // optional int64 tx_bit_rate_mbps = 9;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_tx_bit_rate_mbps(), target);
    }

    // optional int64 rx_bit_rate_mbps = 10;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_rx_bit_rate_mbps(), target);
    }

    // optional int32 tx_power_dbm = 11;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_tx_power_dbm(), target);
    }

    // optional bool encryption_on = 12;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_encryption_on(), target);
    }

    // optional int64 link_quality = 13;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(13, this->_internal_link_quality(), target);
    }

    // optional bool power_management_enabled = 14;
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_power_management_enabled(), target);
    }

    // optional int32 signal_strength_dbm = 15;
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_signal_strength_dbm(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.NetworkTelemetry)
    return target;
}

size_t NetworkTelemetry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.NetworkTelemetry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string guid = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_guid());
        }

        // optional string device_path = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_device_path());
        }

        // optional string ip_address = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_ip_address());
        }

        // optional string gateway = 6;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_gateway());
        }

        // optional .reporting.NetworkConnectionState connection_state = 2;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_connection_state());
        }

        // optional int32 signal_strength = 3;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_signal_strength());
        }

        // optional int64 tx_bit_rate_mbps = 9;
        if (cached_has_bits & 0x00000040u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_tx_bit_rate_mbps());
        }

        // optional .reporting.NetworkType type = 7;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }
    }
    if (cached_has_bits & 0x00003f00u) {
        // optional int32 tx_power_dbm = 11;
        if (cached_has_bits & 0x00000100u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tx_power_dbm());
        }

        // optional int64 rx_bit_rate_mbps = 10;
        if (cached_has_bits & 0x00000200u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_rx_bit_rate_mbps());
        }

        // optional int64 link_quality = 13;
        if (cached_has_bits & 0x00000400u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_link_quality());
        }

        // optional bool encryption_on = 12;
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + 1;
        }

        // optional bool power_management_enabled = 14;
        if (cached_has_bits & 0x00001000u) {
            total_size += 1 + 1;
        }

        // optional int32 signal_strength_dbm = 15;
        if (cached_has_bits & 0x00002000u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_signal_strength_dbm());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void NetworkTelemetry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const NetworkTelemetry*>(&from));
}

void NetworkTelemetry::MergeFrom(const NetworkTelemetry& from)
{
    NetworkTelemetry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.NetworkTelemetry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_guid(from._internal_guid());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_device_path(from._internal_device_path());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_ip_address(from._internal_ip_address());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_gateway(from._internal_gateway());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.connection_state_ = from._impl_.connection_state_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.signal_strength_ = from._impl_.signal_strength_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.tx_bit_rate_mbps_ = from._impl_.tx_bit_rate_mbps_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00003f00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.tx_power_dbm_ = from._impl_.tx_power_dbm_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.rx_bit_rate_mbps_ = from._impl_.rx_bit_rate_mbps_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.link_quality_ = from._impl_.link_quality_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.encryption_on_ = from._impl_.encryption_on_;
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.power_management_enabled_ = from._impl_.power_management_enabled_;
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.signal_strength_dbm_ = from._impl_.signal_strength_dbm_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworkTelemetry::CopyFrom(const NetworkTelemetry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.NetworkTelemetry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool NetworkTelemetry::IsInitialized() const
{
    return true;
}

void NetworkTelemetry::InternalSwap(NetworkTelemetry* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.guid_, lhs_arena, &other->_impl_.guid_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.device_path_, lhs_arena, &other->_impl_.device_path_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.ip_address_, lhs_arena, &other->_impl_.ip_address_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.gateway_, lhs_arena, &other->_impl_.gateway_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(NetworkTelemetry, _impl_.signal_strength_dbm_)
        + sizeof(NetworkTelemetry::_impl_.signal_strength_dbm_) - PROTOBUF_FIELD_OFFSET(NetworkTelemetry, _impl_.connection_state_)>(
        reinterpret_cast<char*>(&_impl_.connection_state_), reinterpret_cast<char*>(&other->_impl_.connection_state_));
}

std::string NetworkTelemetry::GetTypeName() const
{
    return "reporting.NetworkTelemetry";
}

// ===================================================================

class NetworkConnectionStateChangeEventData::_Internal {
public:
    using HasBits = decltype(std::declval<NetworkConnectionStateChangeEventData>()._impl_._has_bits_);
    static void set_has_guid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_connection_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

NetworkConnectionStateChangeEventData::NetworkConnectionStateChangeEventData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.NetworkConnectionStateChangeEventData)
}
NetworkConnectionStateChangeEventData::NetworkConnectionStateChangeEventData(const NetworkConnectionStateChangeEventData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    NetworkConnectionStateChangeEventData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.guid_) {},
        decltype(_impl_.connection_state_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_guid()) {
        _this->_impl_.guid_.Set(from._internal_guid(), _this->GetArenaForAllocation());
    }
    _this->_impl_.connection_state_ = from._impl_.connection_state_;
    // @@protoc_insertion_point(copy_constructor:reporting.NetworkConnectionStateChangeEventData)
}

inline void NetworkConnectionStateChangeEventData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.guid_) {}, decltype(_impl_.connection_state_) { 0 } };
    _impl_.guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NetworkConnectionStateChangeEventData::~NetworkConnectionStateChangeEventData()
{
    // @@protoc_insertion_point(destructor:reporting.NetworkConnectionStateChangeEventData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void NetworkConnectionStateChangeEventData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.guid_.Destroy();
}

void NetworkConnectionStateChangeEventData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void NetworkConnectionStateChangeEventData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.NetworkConnectionStateChangeEventData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.guid_.ClearNonDefaultToEmpty();
    }
    _impl_.connection_state_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* NetworkConnectionStateChangeEventData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string guid = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_guid();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.NetworkConnectionState connection_state = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::reporting::NetworkConnectionState_IsValid(val))) {
                    _internal_set_connection_state(static_cast<::reporting::NetworkConnectionState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* NetworkConnectionStateChangeEventData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.NetworkConnectionStateChangeEventData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string guid = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_guid(), target);
    }

    // optional .reporting.NetworkConnectionState connection_state = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_connection_state(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.NetworkConnectionStateChangeEventData)
    return target;
}

size_t NetworkConnectionStateChangeEventData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.NetworkConnectionStateChangeEventData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string guid = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_guid());
        }

        // optional .reporting.NetworkConnectionState connection_state = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_connection_state());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void NetworkConnectionStateChangeEventData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const NetworkConnectionStateChangeEventData*>(&from));
}

void NetworkConnectionStateChangeEventData::MergeFrom(const NetworkConnectionStateChangeEventData& from)
{
    NetworkConnectionStateChangeEventData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.NetworkConnectionStateChangeEventData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_guid(from._internal_guid());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.connection_state_ = from._impl_.connection_state_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworkConnectionStateChangeEventData::CopyFrom(const NetworkConnectionStateChangeEventData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.NetworkConnectionStateChangeEventData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool NetworkConnectionStateChangeEventData::IsInitialized() const
{
    return true;
}

void NetworkConnectionStateChangeEventData::InternalSwap(NetworkConnectionStateChangeEventData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.guid_, lhs_arena, &other->_impl_.guid_, rhs_arena);
    swap(_impl_.connection_state_, other->_impl_.connection_state_);
}

std::string NetworkConnectionStateChangeEventData::GetTypeName() const
{
    return "reporting.NetworkConnectionStateChangeEventData";
}

// ===================================================================

class SignalStrengthEventData::_Internal {
public:
    using HasBits = decltype(std::declval<SignalStrengthEventData>()._impl_._has_bits_);
    static void set_has_guid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_signal_strength_dbm(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

SignalStrengthEventData::SignalStrengthEventData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.SignalStrengthEventData)
}
SignalStrengthEventData::SignalStrengthEventData(const SignalStrengthEventData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SignalStrengthEventData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.guid_) {},
        decltype(_impl_.signal_strength_dbm_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_guid()) {
        _this->_impl_.guid_.Set(from._internal_guid(), _this->GetArenaForAllocation());
    }
    _this->_impl_.signal_strength_dbm_ = from._impl_.signal_strength_dbm_;
    // @@protoc_insertion_point(copy_constructor:reporting.SignalStrengthEventData)
}

inline void SignalStrengthEventData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.guid_) {}, decltype(_impl_.signal_strength_dbm_) { 0 } };
    _impl_.guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SignalStrengthEventData::~SignalStrengthEventData()
{
    // @@protoc_insertion_point(destructor:reporting.SignalStrengthEventData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SignalStrengthEventData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.guid_.Destroy();
}

void SignalStrengthEventData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SignalStrengthEventData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.SignalStrengthEventData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.guid_.ClearNonDefaultToEmpty();
    }
    _impl_.signal_strength_dbm_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SignalStrengthEventData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string guid = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_guid();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 signal_strength_dbm = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_signal_strength_dbm(&has_bits);
                _impl_.signal_strength_dbm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SignalStrengthEventData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.SignalStrengthEventData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string guid = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_guid(), target);
    }

    // optional int32 signal_strength_dbm = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_signal_strength_dbm(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.SignalStrengthEventData)
    return target;
}

size_t SignalStrengthEventData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.SignalStrengthEventData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string guid = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_guid());
        }

        // optional int32 signal_strength_dbm = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_signal_strength_dbm());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SignalStrengthEventData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SignalStrengthEventData*>(&from));
}

void SignalStrengthEventData::MergeFrom(const SignalStrengthEventData& from)
{
    SignalStrengthEventData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.SignalStrengthEventData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_guid(from._internal_guid());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.signal_strength_dbm_ = from._impl_.signal_strength_dbm_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SignalStrengthEventData::CopyFrom(const SignalStrengthEventData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.SignalStrengthEventData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SignalStrengthEventData::IsInitialized() const
{
    return true;
}

void SignalStrengthEventData::InternalSwap(SignalStrengthEventData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.guid_, lhs_arena, &other->_impl_.guid_, rhs_arena);
    swap(_impl_.signal_strength_dbm_, other->_impl_.signal_strength_dbm_);
}

std::string SignalStrengthEventData::GetTypeName() const
{
    return "reporting.SignalStrengthEventData";
}

// ===================================================================

class NetworksTelemetry::_Internal {
public:
    using HasBits = decltype(std::declval<NetworksTelemetry>()._impl_._has_bits_);
    static const ::reporting::HttpsLatencyRoutineData& https_latency_data(const NetworksTelemetry* msg);
    static void set_has_https_latency_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::reporting::BandwidthData& bandwidth_data(const NetworksTelemetry* msg);
    static void set_has_bandwidth_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::reporting::NetworkConnectionStateChangeEventData& network_connection_change_event_data(const NetworksTelemetry* msg);
    static void set_has_network_connection_change_event_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::reporting::SignalStrengthEventData& signal_strength_event_data(const NetworksTelemetry* msg);
    static void set_has_signal_strength_event_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::reporting::HttpsLatencyRoutineData& NetworksTelemetry::_Internal::https_latency_data(const NetworksTelemetry* msg)
{
    return *msg->_impl_.https_latency_data_;
}
const ::reporting::BandwidthData& NetworksTelemetry::_Internal::bandwidth_data(const NetworksTelemetry* msg)
{
    return *msg->_impl_.bandwidth_data_;
}
const ::reporting::NetworkConnectionStateChangeEventData& NetworksTelemetry::_Internal::network_connection_change_event_data(const NetworksTelemetry* msg)
{
    return *msg->_impl_.network_connection_change_event_data_;
}
const ::reporting::SignalStrengthEventData& NetworksTelemetry::_Internal::signal_strength_event_data(const NetworksTelemetry* msg)
{
    return *msg->_impl_.signal_strength_event_data_;
}
NetworksTelemetry::NetworksTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.NetworksTelemetry)
}
NetworksTelemetry::NetworksTelemetry(const NetworksTelemetry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    NetworksTelemetry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.network_telemetry_) { from._impl_.network_telemetry_ }, decltype(_impl_.https_latency_data_) { nullptr },
        decltype(_impl_.bandwidth_data_) { nullptr }, decltype(_impl_.network_connection_change_event_data_) { nullptr },
        decltype(_impl_.signal_strength_event_data_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_https_latency_data()) {
        _this->_impl_.https_latency_data_ = new ::reporting::HttpsLatencyRoutineData(*from._impl_.https_latency_data_);
    }
    if (from._internal_has_bandwidth_data()) {
        _this->_impl_.bandwidth_data_ = new ::reporting::BandwidthData(*from._impl_.bandwidth_data_);
    }
    if (from._internal_has_network_connection_change_event_data()) {
        _this->_impl_.network_connection_change_event_data_
            = new ::reporting::NetworkConnectionStateChangeEventData(*from._impl_.network_connection_change_event_data_);
    }
    if (from._internal_has_signal_strength_event_data()) {
        _this->_impl_.signal_strength_event_data_ = new ::reporting::SignalStrengthEventData(*from._impl_.signal_strength_event_data_);
    }
    // @@protoc_insertion_point(copy_constructor:reporting.NetworksTelemetry)
}

inline void NetworksTelemetry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.network_telemetry_) { arena },
        decltype(_impl_.https_latency_data_) { nullptr }, decltype(_impl_.bandwidth_data_) { nullptr },
        decltype(_impl_.network_connection_change_event_data_) { nullptr }, decltype(_impl_.signal_strength_event_data_) { nullptr } };
}

NetworksTelemetry::~NetworksTelemetry()
{
    // @@protoc_insertion_point(destructor:reporting.NetworksTelemetry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void NetworksTelemetry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.network_telemetry_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.https_latency_data_;
    if (this != internal_default_instance())
        delete _impl_.bandwidth_data_;
    if (this != internal_default_instance())
        delete _impl_.network_connection_change_event_data_;
    if (this != internal_default_instance())
        delete _impl_.signal_strength_event_data_;
}

void NetworksTelemetry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void NetworksTelemetry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.NetworksTelemetry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.network_telemetry_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.https_latency_data_ != nullptr);
            _impl_.https_latency_data_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.bandwidth_data_ != nullptr);
            _impl_.bandwidth_data_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.network_connection_change_event_data_ != nullptr);
            _impl_.network_connection_change_event_data_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.signal_strength_event_data_ != nullptr);
            _impl_.signal_strength_event_data_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* NetworksTelemetry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .reporting.NetworkTelemetry network_telemetry = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_network_telemetry(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.HttpsLatencyRoutineData https_latency_data = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_https_latency_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.BandwidthData bandwidth_data = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_bandwidth_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.NetworkConnectionStateChangeEventData network_connection_change_event_data = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_network_connection_change_event_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.SignalStrengthEventData signal_strength_event_data = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_signal_strength_event_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* NetworksTelemetry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.NetworksTelemetry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .reporting.NetworkTelemetry network_telemetry = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_network_telemetry_size()); i < n; i++) {
        const auto& repfield = this->_internal_network_telemetry(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional .reporting.HttpsLatencyRoutineData https_latency_data = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::https_latency_data(this), _Internal::https_latency_data(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.BandwidthData bandwidth_data = 3;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::bandwidth_data(this), _Internal::bandwidth_data(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.NetworkConnectionStateChangeEventData network_connection_change_event_data = 4;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::network_connection_change_event_data(this), _Internal::network_connection_change_event_data(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.SignalStrengthEventData signal_strength_event_data = 5;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::signal_strength_event_data(this), _Internal::signal_strength_event_data(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.NetworksTelemetry)
    return target;
}

size_t NetworksTelemetry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.NetworksTelemetry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .reporting.NetworkTelemetry network_telemetry = 1;
    total_size += 1UL * this->_internal_network_telemetry_size();
    for (const auto& msg : this->_impl_.network_telemetry_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .reporting.HttpsLatencyRoutineData https_latency_data = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.https_latency_data_);
        }

        // optional .reporting.BandwidthData bandwidth_data = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.bandwidth_data_);
        }

        // optional .reporting.NetworkConnectionStateChangeEventData network_connection_change_event_data = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.network_connection_change_event_data_);
        }

        // optional .reporting.SignalStrengthEventData signal_strength_event_data = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.signal_strength_event_data_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void NetworksTelemetry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const NetworksTelemetry*>(&from));
}

void NetworksTelemetry::MergeFrom(const NetworksTelemetry& from)
{
    NetworksTelemetry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.NetworksTelemetry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.network_telemetry_.MergeFrom(from._impl_.network_telemetry_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_https_latency_data()->::reporting::HttpsLatencyRoutineData::MergeFrom(from._internal_https_latency_data());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_bandwidth_data()->::reporting::BandwidthData::MergeFrom(from._internal_bandwidth_data());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_network_connection_change_event_data()->::reporting::NetworkConnectionStateChangeEventData::MergeFrom(
                from._internal_network_connection_change_event_data());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_signal_strength_event_data()->::reporting::SignalStrengthEventData::MergeFrom(from._internal_signal_strength_event_data());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworksTelemetry::CopyFrom(const NetworksTelemetry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.NetworksTelemetry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool NetworksTelemetry::IsInitialized() const
{
    return true;
}

void NetworksTelemetry::InternalSwap(NetworksTelemetry* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.network_telemetry_.InternalSwap(&other->_impl_.network_telemetry_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(NetworksTelemetry, _impl_.signal_strength_event_data_)
        + sizeof(NetworksTelemetry::_impl_.signal_strength_event_data_) - PROTOBUF_FIELD_OFFSET(NetworksTelemetry, _impl_.https_latency_data_)>(
        reinterpret_cast<char*>(&_impl_.https_latency_data_), reinterpret_cast<char*>(&other->_impl_.https_latency_data_));
}

std::string NetworksTelemetry::GetTypeName() const
{
    return "reporting.NetworksTelemetry";
}

// ===================================================================

class ThunderboltInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ThunderboltInfo>()._impl_._has_bits_);
    static void set_has_security_level(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ThunderboltInfo::ThunderboltInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.ThunderboltInfo)
}
ThunderboltInfo::ThunderboltInfo(const ThunderboltInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ThunderboltInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.security_level_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.security_level_ = from._impl_.security_level_;
    // @@protoc_insertion_point(copy_constructor:reporting.ThunderboltInfo)
}

inline void ThunderboltInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.security_level_) { 0 } };
}

ThunderboltInfo::~ThunderboltInfo()
{
    // @@protoc_insertion_point(destructor:reporting.ThunderboltInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ThunderboltInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ThunderboltInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ThunderboltInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.ThunderboltInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.security_level_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ThunderboltInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .reporting.ThunderboltSecurityLevel security_level = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::reporting::ThunderboltSecurityLevel_IsValid(val))) {
                    _internal_set_security_level(static_cast<::reporting::ThunderboltSecurityLevel>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ThunderboltInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.ThunderboltInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .reporting.ThunderboltSecurityLevel security_level = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_security_level(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.ThunderboltInfo)
    return target;
}

size_t ThunderboltInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.ThunderboltInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .reporting.ThunderboltSecurityLevel security_level = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_security_level());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ThunderboltInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ThunderboltInfo*>(&from));
}

void ThunderboltInfo::MergeFrom(const ThunderboltInfo& from)
{
    ThunderboltInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.ThunderboltInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_security_level()) {
        _this->_internal_set_security_level(from._internal_security_level());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ThunderboltInfo::CopyFrom(const ThunderboltInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.ThunderboltInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ThunderboltInfo::IsInitialized() const
{
    return true;
}

void ThunderboltInfo::InternalSwap(ThunderboltInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.security_level_, other->_impl_.security_level_);
}

std::string ThunderboltInfo::GetTypeName() const
{
    return "reporting.ThunderboltInfo";
}

// ===================================================================

class BusDeviceInfo::_Internal {
public:
};

BusDeviceInfo::BusDeviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.BusDeviceInfo)
}
BusDeviceInfo::BusDeviceInfo(const BusDeviceInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    BusDeviceInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.thunderbolt_info_) { from._impl_.thunderbolt_info_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:reporting.BusDeviceInfo)
}

inline void BusDeviceInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.thunderbolt_info_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

BusDeviceInfo::~BusDeviceInfo()
{
    // @@protoc_insertion_point(destructor:reporting.BusDeviceInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void BusDeviceInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.thunderbolt_info_.~RepeatedPtrField();
}

void BusDeviceInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void BusDeviceInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.BusDeviceInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.thunderbolt_info_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* BusDeviceInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .reporting.ThunderboltInfo thunderbolt_info = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_thunderbolt_info(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* BusDeviceInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.BusDeviceInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .reporting.ThunderboltInfo thunderbolt_info = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_thunderbolt_info_size()); i < n; i++) {
        const auto& repfield = this->_internal_thunderbolt_info(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.BusDeviceInfo)
    return target;
}

size_t BusDeviceInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.BusDeviceInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .reporting.ThunderboltInfo thunderbolt_info = 1;
    total_size += 1UL * this->_internal_thunderbolt_info_size();
    for (const auto& msg : this->_impl_.thunderbolt_info_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void BusDeviceInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const BusDeviceInfo*>(&from));
}

void BusDeviceInfo::MergeFrom(const BusDeviceInfo& from)
{
    BusDeviceInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.BusDeviceInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.thunderbolt_info_.MergeFrom(from._impl_.thunderbolt_info_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BusDeviceInfo::CopyFrom(const BusDeviceInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.BusDeviceInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool BusDeviceInfo::IsInitialized() const
{
    return true;
}

void BusDeviceInfo::InternalSwap(BusDeviceInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.thunderbolt_info_.InternalSwap(&other->_impl_.thunderbolt_info_);
}

std::string BusDeviceInfo::GetTypeName() const
{
    return "reporting.BusDeviceInfo";
}

// ===================================================================

class TotalMemoryEncryptionInfo::_Internal {
public:
    using HasBits = decltype(std::declval<TotalMemoryEncryptionInfo>()._impl_._has_bits_);
    static void set_has_encryption_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_max_keys(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_key_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_encryption_algorithm(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

TotalMemoryEncryptionInfo::TotalMemoryEncryptionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.TotalMemoryEncryptionInfo)
}
TotalMemoryEncryptionInfo::TotalMemoryEncryptionInfo(const TotalMemoryEncryptionInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TotalMemoryEncryptionInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.max_keys_) {},
        decltype(_impl_.encryption_state_) {}, decltype(_impl_.encryption_algorithm_) {}, decltype(_impl_.key_length_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.max_keys_, &from._impl_.max_keys_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.key_length_) - reinterpret_cast<char*>(&_impl_.max_keys_)) + sizeof(_impl_.key_length_));
    // @@protoc_insertion_point(copy_constructor:reporting.TotalMemoryEncryptionInfo)
}

inline void TotalMemoryEncryptionInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.max_keys_) { int64_t { 0 } },
        decltype(_impl_.encryption_state_) { 0 }, decltype(_impl_.encryption_algorithm_) { 0 }, decltype(_impl_.key_length_) { int64_t { 0 } } };
}

TotalMemoryEncryptionInfo::~TotalMemoryEncryptionInfo()
{
    // @@protoc_insertion_point(destructor:reporting.TotalMemoryEncryptionInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TotalMemoryEncryptionInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TotalMemoryEncryptionInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TotalMemoryEncryptionInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.TotalMemoryEncryptionInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        ::memset(&_impl_.max_keys_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.key_length_) - reinterpret_cast<char*>(&_impl_.max_keys_)) + sizeof(_impl_.key_length_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* TotalMemoryEncryptionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .reporting.MemoryEncryptionState encryption_state = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::reporting::MemoryEncryptionState_IsValid(val))) {
                    _internal_set_encryption_state(static_cast<::reporting::MemoryEncryptionState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 max_keys = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_max_keys(&has_bits);
                _impl_.max_keys_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 key_length = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_key_length(&has_bits);
                _impl_.key_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.MemoryEncryptionAlgorithm encryption_algorithm = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::reporting::MemoryEncryptionAlgorithm_IsValid(val))) {
                    _internal_set_encryption_algorithm(static_cast<::reporting::MemoryEncryptionAlgorithm>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TotalMemoryEncryptionInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.TotalMemoryEncryptionInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .reporting.MemoryEncryptionState encryption_state = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_encryption_state(), target);
    }

    // optional int64 max_keys = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_max_keys(), target);
    }

    // optional int64 key_length = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_key_length(), target);
    }

    // optional .reporting.MemoryEncryptionAlgorithm encryption_algorithm = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_encryption_algorithm(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.TotalMemoryEncryptionInfo)
    return target;
}

size_t TotalMemoryEncryptionInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.TotalMemoryEncryptionInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional int64 max_keys = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_max_keys());
        }

        // optional .reporting.MemoryEncryptionState encryption_state = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_encryption_state());
        }

        // optional .reporting.MemoryEncryptionAlgorithm encryption_algorithm = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_encryption_algorithm());
        }

        // optional int64 key_length = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_key_length());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TotalMemoryEncryptionInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TotalMemoryEncryptionInfo*>(&from));
}

void TotalMemoryEncryptionInfo::MergeFrom(const TotalMemoryEncryptionInfo& from)
{
    TotalMemoryEncryptionInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.TotalMemoryEncryptionInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.max_keys_ = from._impl_.max_keys_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.encryption_state_ = from._impl_.encryption_state_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.encryption_algorithm_ = from._impl_.encryption_algorithm_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.key_length_ = from._impl_.key_length_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TotalMemoryEncryptionInfo::CopyFrom(const TotalMemoryEncryptionInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.TotalMemoryEncryptionInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TotalMemoryEncryptionInfo::IsInitialized() const
{
    return true;
}

void TotalMemoryEncryptionInfo::InternalSwap(TotalMemoryEncryptionInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(TotalMemoryEncryptionInfo, _impl_.key_length_)
        + sizeof(TotalMemoryEncryptionInfo::_impl_.key_length_) - PROTOBUF_FIELD_OFFSET(TotalMemoryEncryptionInfo, _impl_.max_keys_)>(
        reinterpret_cast<char*>(&_impl_.max_keys_), reinterpret_cast<char*>(&other->_impl_.max_keys_));
}

std::string TotalMemoryEncryptionInfo::GetTypeName() const
{
    return "reporting.TotalMemoryEncryptionInfo";
}

// ===================================================================

class MemoryInfo::_Internal {
public:
    using HasBits = decltype(std::declval<MemoryInfo>()._impl_._has_bits_);
    static const ::reporting::TotalMemoryEncryptionInfo& tme_info(const MemoryInfo* msg);
    static void set_has_tme_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::reporting::TotalMemoryEncryptionInfo& MemoryInfo::_Internal::tme_info(const MemoryInfo* msg)
{
    return *msg->_impl_.tme_info_;
}
MemoryInfo::MemoryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.MemoryInfo)
}
MemoryInfo::MemoryInfo(const MemoryInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    MemoryInfo* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.tme_info_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_tme_info()) {
        _this->_impl_.tme_info_ = new ::reporting::TotalMemoryEncryptionInfo(*from._impl_.tme_info_);
    }
    // @@protoc_insertion_point(copy_constructor:reporting.MemoryInfo)
}

inline void MemoryInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.tme_info_) { nullptr } };
}

MemoryInfo::~MemoryInfo()
{
    // @@protoc_insertion_point(destructor:reporting.MemoryInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void MemoryInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.tme_info_;
}

void MemoryInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void MemoryInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.MemoryInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.tme_info_ != nullptr);
        _impl_.tme_info_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* MemoryInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .reporting.TotalMemoryEncryptionInfo tme_info = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_tme_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* MemoryInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.MemoryInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .reporting.TotalMemoryEncryptionInfo tme_info = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::tme_info(this), _Internal::tme_info(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.MemoryInfo)
    return target;
}

size_t MemoryInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.MemoryInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .reporting.TotalMemoryEncryptionInfo tme_info = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.tme_info_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void MemoryInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const MemoryInfo*>(&from));
}

void MemoryInfo::MergeFrom(const MemoryInfo& from)
{
    MemoryInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.MemoryInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_tme_info()) {
        _this->_internal_mutable_tme_info()->::reporting::TotalMemoryEncryptionInfo::MergeFrom(from._internal_tme_info());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MemoryInfo::CopyFrom(const MemoryInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.MemoryInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool MemoryInfo::IsInitialized() const
{
    return true;
}

void MemoryInfo::InternalSwap(MemoryInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.tme_info_, other->_impl_.tme_info_);
}

std::string MemoryInfo::GetTypeName() const
{
    return "reporting.MemoryInfo";
}

// ===================================================================

class NetworkInterface::_Internal {
public:
    using HasBits = decltype(std::declval<NetworkInterface>()._impl_._has_bits_);
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_mac_address(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_meid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_imei(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_device_path(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_iccid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_mdn(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
};

NetworkInterface::NetworkInterface(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.NetworkInterface)
}
NetworkInterface::NetworkInterface(const NetworkInterface& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    NetworkInterface* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.eids_) { from._impl_.eids_ }, decltype(_impl_.mac_address_) {}, decltype(_impl_.meid_) {}, decltype(_impl_.imei_) {},
        decltype(_impl_.device_path_) {}, decltype(_impl_.iccid_) {}, decltype(_impl_.mdn_) {}, decltype(_impl_.type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.mac_address_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_address_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_mac_address()) {
        _this->_impl_.mac_address_.Set(from._internal_mac_address(), _this->GetArenaForAllocation());
    }
    _impl_.meid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_meid()) {
        _this->_impl_.meid_.Set(from._internal_meid(), _this->GetArenaForAllocation());
    }
    _impl_.imei_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imei_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_imei()) {
        _this->_impl_.imei_.Set(from._internal_imei(), _this->GetArenaForAllocation());
    }
    _impl_.device_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_device_path()) {
        _this->_impl_.device_path_.Set(from._internal_device_path(), _this->GetArenaForAllocation());
    }
    _impl_.iccid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iccid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_iccid()) {
        _this->_impl_.iccid_.Set(from._internal_iccid(), _this->GetArenaForAllocation());
    }
    _impl_.mdn_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mdn_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_mdn()) {
        _this->_impl_.mdn_.Set(from._internal_mdn(), _this->GetArenaForAllocation());
    }
    _this->_impl_.type_ = from._impl_.type_;
    // @@protoc_insertion_point(copy_constructor:reporting.NetworkInterface)
}

inline void NetworkInterface::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.eids_) { arena },
        decltype(_impl_.mac_address_) {}, decltype(_impl_.meid_) {}, decltype(_impl_.imei_) {}, decltype(_impl_.device_path_) {}, decltype(_impl_.iccid_) {},
        decltype(_impl_.mdn_) {}, decltype(_impl_.type_) { 0 } };
    _impl_.mac_address_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_address_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.meid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imei_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.imei_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.device_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iccid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.iccid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mdn_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mdn_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NetworkInterface::~NetworkInterface()
{
    // @@protoc_insertion_point(destructor:reporting.NetworkInterface)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void NetworkInterface::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.eids_.~RepeatedPtrField();
    _impl_.mac_address_.Destroy();
    _impl_.meid_.Destroy();
    _impl_.imei_.Destroy();
    _impl_.device_path_.Destroy();
    _impl_.iccid_.Destroy();
    _impl_.mdn_.Destroy();
}

void NetworkInterface::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void NetworkInterface::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.NetworkInterface)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.eids_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.mac_address_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.meid_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.imei_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.device_path_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.iccid_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.mdn_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* NetworkInterface::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .reporting.NetworkDeviceType type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::reporting::NetworkDeviceType_IsValid(val))) {
                    _internal_set_type(static_cast<::reporting::NetworkDeviceType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string mac_address = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_mac_address();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string meid = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_meid();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string imei = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_imei();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string device_path = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_device_path();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string iccid = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_iccid();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string mdn = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_mdn();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string eids = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_eids();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* NetworkInterface::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.NetworkInterface)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .reporting.NetworkDeviceType type = 1;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_type(), target);
    }

    // optional string mac_address = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_mac_address(), target);
    }

    // optional string meid = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_meid(), target);
    }

    // optional string imei = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_imei(), target);
    }

    // optional string device_path = 5;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_device_path(), target);
    }

    // optional string iccid = 6;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(6, this->_internal_iccid(), target);
    }

    // optional string mdn = 7;
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_mdn(), target);
    }

    // repeated string eids = 8;
    for (int i = 0, n = this->_internal_eids_size(); i < n; i++) {
        const auto& s = this->_internal_eids(i);
        target = stream->WriteString(8, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.NetworkInterface)
    return target;
}

size_t NetworkInterface::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.NetworkInterface)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string eids = 8;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.eids_.size());
    for (int i = 0, n = _impl_.eids_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.eids_.Get(i));
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        // optional string mac_address = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_mac_address());
        }

        // optional string meid = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_meid());
        }

        // optional string imei = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_imei());
        }

        // optional string device_path = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_device_path());
        }

        // optional string iccid = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_iccid());
        }

        // optional string mdn = 7;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_mdn());
        }

        // optional .reporting.NetworkDeviceType type = 1;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void NetworkInterface::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const NetworkInterface*>(&from));
}

void NetworkInterface::MergeFrom(const NetworkInterface& from)
{
    NetworkInterface* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.NetworkInterface)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.eids_.MergeFrom(from._impl_.eids_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_mac_address(from._internal_mac_address());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_meid(from._internal_meid());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_imei(from._internal_imei());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_device_path(from._internal_device_path());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_iccid(from._internal_iccid());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_mdn(from._internal_mdn());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworkInterface::CopyFrom(const NetworkInterface& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.NetworkInterface)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool NetworkInterface::IsInitialized() const
{
    return true;
}

void NetworkInterface::InternalSwap(NetworkInterface* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.eids_.InternalSwap(&other->_impl_.eids_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.mac_address_, lhs_arena, &other->_impl_.mac_address_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.meid_, lhs_arena, &other->_impl_.meid_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.imei_, lhs_arena, &other->_impl_.imei_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.device_path_, lhs_arena, &other->_impl_.device_path_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.iccid_, lhs_arena, &other->_impl_.iccid_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.mdn_, lhs_arena, &other->_impl_.mdn_, rhs_arena);
    swap(_impl_.type_, other->_impl_.type_);
}

std::string NetworkInterface::GetTypeName() const
{
    return "reporting.NetworkInterface";
}

// ===================================================================

class NetworksInfo::_Internal {
public:
};

NetworksInfo::NetworksInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.NetworksInfo)
}
NetworksInfo::NetworksInfo(const NetworksInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    NetworksInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.network_interfaces_) { from._impl_.network_interfaces_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:reporting.NetworksInfo)
}

inline void NetworksInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.network_interfaces_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

NetworksInfo::~NetworksInfo()
{
    // @@protoc_insertion_point(destructor:reporting.NetworksInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void NetworksInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.network_interfaces_.~RepeatedPtrField();
}

void NetworksInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void NetworksInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.NetworksInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.network_interfaces_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* NetworksInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .reporting.NetworkInterface network_interfaces = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_network_interfaces(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* NetworksInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.NetworksInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .reporting.NetworkInterface network_interfaces = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_network_interfaces_size()); i < n; i++) {
        const auto& repfield = this->_internal_network_interfaces(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.NetworksInfo)
    return target;
}

size_t NetworksInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.NetworksInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .reporting.NetworkInterface network_interfaces = 1;
    total_size += 1UL * this->_internal_network_interfaces_size();
    for (const auto& msg : this->_impl_.network_interfaces_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void NetworksInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const NetworksInfo*>(&from));
}

void NetworksInfo::MergeFrom(const NetworksInfo& from)
{
    NetworksInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.NetworksInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.network_interfaces_.MergeFrom(from._impl_.network_interfaces_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NetworksInfo::CopyFrom(const NetworksInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.NetworksInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool NetworksInfo::IsInitialized() const
{
    return true;
}

void NetworksInfo::InternalSwap(NetworksInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.network_interfaces_.InternalSwap(&other->_impl_.network_interfaces_);
}

std::string NetworksInfo::GetTypeName() const
{
    return "reporting.NetworksInfo";
}

// ===================================================================

class TouchScreenInfo::_Internal {
public:
    using HasBits = decltype(std::declval<TouchScreenInfo>()._impl_._has_bits_);
    static void set_has_library_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

TouchScreenInfo::TouchScreenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.TouchScreenInfo)
}
TouchScreenInfo::TouchScreenInfo(const TouchScreenInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TouchScreenInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.touch_screen_devices_) { from._impl_.touch_screen_devices_ }, decltype(_impl_.library_name_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.library_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.library_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_library_name()) {
        _this->_impl_.library_name_.Set(from._internal_library_name(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:reporting.TouchScreenInfo)
}

inline void TouchScreenInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.touch_screen_devices_) { arena },
        decltype(_impl_.library_name_) {} };
    _impl_.library_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.library_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TouchScreenInfo::~TouchScreenInfo()
{
    // @@protoc_insertion_point(destructor:reporting.TouchScreenInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TouchScreenInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.touch_screen_devices_.~RepeatedPtrField();
    _impl_.library_name_.Destroy();
}

void TouchScreenInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TouchScreenInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.TouchScreenInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.touch_screen_devices_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.library_name_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* TouchScreenInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string library_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_library_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .reporting.TouchScreenDevice touch_screen_devices = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_touch_screen_devices(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TouchScreenInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.TouchScreenInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string library_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_library_name(), target);
    }

    // repeated .reporting.TouchScreenDevice touch_screen_devices = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_touch_screen_devices_size()); i < n; i++) {
        const auto& repfield = this->_internal_touch_screen_devices(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.TouchScreenInfo)
    return target;
}

size_t TouchScreenInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.TouchScreenInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .reporting.TouchScreenDevice touch_screen_devices = 2;
    total_size += 1UL * this->_internal_touch_screen_devices_size();
    for (const auto& msg : this->_impl_.touch_screen_devices_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional string library_name = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_library_name());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TouchScreenInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TouchScreenInfo*>(&from));
}

void TouchScreenInfo::MergeFrom(const TouchScreenInfo& from)
{
    TouchScreenInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.TouchScreenInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.touch_screen_devices_.MergeFrom(from._impl_.touch_screen_devices_);
    if (from._internal_has_library_name()) {
        _this->_internal_set_library_name(from._internal_library_name());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TouchScreenInfo::CopyFrom(const TouchScreenInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.TouchScreenInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TouchScreenInfo::IsInitialized() const
{
    return true;
}

void TouchScreenInfo::InternalSwap(TouchScreenInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.touch_screen_devices_.InternalSwap(&other->_impl_.touch_screen_devices_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.library_name_, lhs_arena, &other->_impl_.library_name_, rhs_arena);
}

std::string TouchScreenInfo::GetTypeName() const
{
    return "reporting.TouchScreenInfo";
}

// ===================================================================

class TouchScreenDevice::_Internal {
public:
    using HasBits = decltype(std::declval<TouchScreenDevice>()._impl_._has_bits_);
    static void set_has_display_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_touch_points(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_has_stylus(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

TouchScreenDevice::TouchScreenDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.TouchScreenDevice)
}
TouchScreenDevice::TouchScreenDevice(const TouchScreenDevice& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TouchScreenDevice* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.display_name_) {},
        decltype(_impl_.touch_points_) {}, decltype(_impl_.has_stylus_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_display_name()) {
        _this->_impl_.display_name_.Set(from._internal_display_name(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.touch_points_, &from._impl_.touch_points_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.has_stylus_) - reinterpret_cast<char*>(&_impl_.touch_points_)) + sizeof(_impl_.has_stylus_));
    // @@protoc_insertion_point(copy_constructor:reporting.TouchScreenDevice)
}

inline void TouchScreenDevice::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.display_name_) {},
        decltype(_impl_.touch_points_) { 0 }, decltype(_impl_.has_stylus_) { false } };
    _impl_.display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TouchScreenDevice::~TouchScreenDevice()
{
    // @@protoc_insertion_point(destructor:reporting.TouchScreenDevice)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TouchScreenDevice::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.display_name_.Destroy();
}

void TouchScreenDevice::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TouchScreenDevice::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.TouchScreenDevice)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.display_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.touch_points_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.has_stylus_) - reinterpret_cast<char*>(&_impl_.touch_points_)) + sizeof(_impl_.has_stylus_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* TouchScreenDevice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string display_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_display_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 touch_points = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_touch_points(&has_bits);
                _impl_.touch_points_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool has_stylus = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_has_stylus(&has_bits);
                _impl_.has_stylus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TouchScreenDevice::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.TouchScreenDevice)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string display_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_display_name(), target);
    }

    // optional int32 touch_points = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_touch_points(), target);
    }

    // optional bool has_stylus = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_has_stylus(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.TouchScreenDevice)
    return target;
}

size_t TouchScreenDevice::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.TouchScreenDevice)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string display_name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_display_name());
        }

        // optional int32 touch_points = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_touch_points());
        }

        // optional bool has_stylus = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TouchScreenDevice::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TouchScreenDevice*>(&from));
}

void TouchScreenDevice::MergeFrom(const TouchScreenDevice& from)
{
    TouchScreenDevice* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.TouchScreenDevice)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_display_name(from._internal_display_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.touch_points_ = from._impl_.touch_points_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.has_stylus_ = from._impl_.has_stylus_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TouchScreenDevice::CopyFrom(const TouchScreenDevice& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.TouchScreenDevice)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TouchScreenDevice::IsInitialized() const
{
    return true;
}

void TouchScreenDevice::InternalSwap(TouchScreenDevice* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.display_name_, lhs_arena, &other->_impl_.display_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(TouchScreenDevice, _impl_.has_stylus_) + sizeof(TouchScreenDevice::_impl_.has_stylus_)
        - PROTOBUF_FIELD_OFFSET(TouchScreenDevice, _impl_.touch_points_)>(
        reinterpret_cast<char*>(&_impl_.touch_points_), reinterpret_cast<char*>(&other->_impl_.touch_points_));
}

std::string TouchScreenDevice::GetTypeName() const
{
    return "reporting.TouchScreenDevice";
}

// ===================================================================

class PrivacyScreenInfo::_Internal {
public:
    using HasBits = decltype(std::declval<PrivacyScreenInfo>()._impl_._has_bits_);
    static void set_has_supported(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

PrivacyScreenInfo::PrivacyScreenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.PrivacyScreenInfo)
}
PrivacyScreenInfo::PrivacyScreenInfo(const PrivacyScreenInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PrivacyScreenInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.supported_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.supported_ = from._impl_.supported_;
    // @@protoc_insertion_point(copy_constructor:reporting.PrivacyScreenInfo)
}

inline void PrivacyScreenInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.supported_) { false } };
}

PrivacyScreenInfo::~PrivacyScreenInfo()
{
    // @@protoc_insertion_point(destructor:reporting.PrivacyScreenInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PrivacyScreenInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PrivacyScreenInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PrivacyScreenInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.PrivacyScreenInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.supported_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PrivacyScreenInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bool supported = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_supported(&has_bits);
                _impl_.supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PrivacyScreenInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.PrivacyScreenInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool supported = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_supported(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.PrivacyScreenInfo)
    return target;
}

size_t PrivacyScreenInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.PrivacyScreenInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional bool supported = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + 1;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PrivacyScreenInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PrivacyScreenInfo*>(&from));
}

void PrivacyScreenInfo::MergeFrom(const PrivacyScreenInfo& from)
{
    PrivacyScreenInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.PrivacyScreenInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_supported()) {
        _this->_internal_set_supported(from._internal_supported());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PrivacyScreenInfo::CopyFrom(const PrivacyScreenInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.PrivacyScreenInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PrivacyScreenInfo::IsInitialized() const
{
    return true;
}

void PrivacyScreenInfo::InternalSwap(PrivacyScreenInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.supported_, other->_impl_.supported_);
}

std::string PrivacyScreenInfo::GetTypeName() const
{
    return "reporting.PrivacyScreenInfo";
}

// ===================================================================

class DisplayInfo::_Internal {
public:
};

DisplayInfo::DisplayInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.DisplayInfo)
}
DisplayInfo::DisplayInfo(const DisplayInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DisplayInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.display_device_) { from._impl_.display_device_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:reporting.DisplayInfo)
}

inline void DisplayInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.display_device_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

DisplayInfo::~DisplayInfo()
{
    // @@protoc_insertion_point(destructor:reporting.DisplayInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DisplayInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.display_device_.~RepeatedPtrField();
}

void DisplayInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DisplayInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.DisplayInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.display_device_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DisplayInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .reporting.DisplayDevice display_device = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_display_device(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DisplayInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.DisplayInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .reporting.DisplayDevice display_device = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_display_device_size()); i < n; i++) {
        const auto& repfield = this->_internal_display_device(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.DisplayInfo)
    return target;
}

size_t DisplayInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.DisplayInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .reporting.DisplayDevice display_device = 1;
    total_size += 1UL * this->_internal_display_device_size();
    for (const auto& msg : this->_impl_.display_device_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DisplayInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DisplayInfo*>(&from));
}

void DisplayInfo::MergeFrom(const DisplayInfo& from)
{
    DisplayInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.DisplayInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.display_device_.MergeFrom(from._impl_.display_device_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DisplayInfo::CopyFrom(const DisplayInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.DisplayInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DisplayInfo::IsInitialized() const
{
    return true;
}

void DisplayInfo::InternalSwap(DisplayInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.display_device_.InternalSwap(&other->_impl_.display_device_);
}

std::string DisplayInfo::GetTypeName() const
{
    return "reporting.DisplayInfo";
}

// ===================================================================

class DisplayDevice::_Internal {
public:
    using HasBits = decltype(std::declval<DisplayDevice>()._impl_._has_bits_);
    static void set_has_display_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_display_width(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_display_height(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_is_internal(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_manufacturer(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_model_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_manufacture_year(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
};

DisplayDevice::DisplayDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.DisplayDevice)
}
DisplayDevice::DisplayDevice(const DisplayDevice& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DisplayDevice* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.display_name_) {},
        decltype(_impl_.manufacturer_) {}, decltype(_impl_.display_width_) {}, decltype(_impl_.display_height_) {}, decltype(_impl_.is_internal_) {},
        decltype(_impl_.model_id_) {}, decltype(_impl_.manufacture_year_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_display_name()) {
        _this->_impl_.display_name_.Set(from._internal_display_name(), _this->GetArenaForAllocation());
    }
    _impl_.manufacturer_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_manufacturer()) {
        _this->_impl_.manufacturer_.Set(from._internal_manufacturer(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.display_width_, &from._impl_.display_width_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.manufacture_year_) - reinterpret_cast<char*>(&_impl_.display_width_))
            + sizeof(_impl_.manufacture_year_));
    // @@protoc_insertion_point(copy_constructor:reporting.DisplayDevice)
}

inline void DisplayDevice::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.display_name_) {},
        decltype(_impl_.manufacturer_) {}, decltype(_impl_.display_width_) { 0 }, decltype(_impl_.display_height_) { 0 },
        decltype(_impl_.is_internal_) { false }, decltype(_impl_.model_id_) { 0 }, decltype(_impl_.manufacture_year_) { 0 } };
    _impl_.display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DisplayDevice::~DisplayDevice()
{
    // @@protoc_insertion_point(destructor:reporting.DisplayDevice)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DisplayDevice::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.display_name_.Destroy();
    _impl_.manufacturer_.Destroy();
}

void DisplayDevice::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DisplayDevice::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.DisplayDevice)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.display_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.manufacturer_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000007cu) {
        ::memset(&_impl_.display_width_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.manufacture_year_) - reinterpret_cast<char*>(&_impl_.display_width_))
                + sizeof(_impl_.manufacture_year_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DisplayDevice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string display_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_display_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 display_width = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_display_width(&has_bits);
                _impl_.display_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 display_height = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_display_height(&has_bits);
                _impl_.display_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_internal = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_is_internal(&has_bits);
                _impl_.is_internal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string manufacturer = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_manufacturer();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 model_id = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_model_id(&has_bits);
                _impl_.model_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 manufacture_year = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_manufacture_year(&has_bits);
                _impl_.manufacture_year_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DisplayDevice::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.DisplayDevice)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string display_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_display_name(), target);
    }

    // optional int32 display_width = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_display_width(), target);
    }

    // optional int32 display_height = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_display_height(), target);
    }

    // optional bool is_internal = 4;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_internal(), target);
    }

    // optional string manufacturer = 5;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_manufacturer(), target);
    }

    // optional int32 model_id = 6;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_model_id(), target);
    }

    // optional int32 manufacture_year = 7;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_manufacture_year(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.DisplayDevice)
    return target;
}

size_t DisplayDevice::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.DisplayDevice)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        // optional string display_name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_display_name());
        }

        // optional string manufacturer = 5;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_manufacturer());
        }

        // optional int32 display_width = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_display_width());
        }

        // optional int32 display_height = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_display_height());
        }

        // optional bool is_internal = 4;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }

        // optional int32 model_id = 6;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_model_id());
        }

        // optional int32 manufacture_year = 7;
        if (cached_has_bits & 0x00000040u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_manufacture_year());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DisplayDevice::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DisplayDevice*>(&from));
}

void DisplayDevice::MergeFrom(const DisplayDevice& from)
{
    DisplayDevice* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.DisplayDevice)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_display_name(from._internal_display_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_manufacturer(from._internal_manufacturer());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.display_width_ = from._impl_.display_width_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.display_height_ = from._impl_.display_height_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.is_internal_ = from._impl_.is_internal_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.model_id_ = from._impl_.model_id_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.manufacture_year_ = from._impl_.manufacture_year_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DisplayDevice::CopyFrom(const DisplayDevice& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.DisplayDevice)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DisplayDevice::IsInitialized() const
{
    return true;
}

void DisplayDevice::InternalSwap(DisplayDevice* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.display_name_, lhs_arena, &other->_impl_.display_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.manufacturer_, lhs_arena, &other->_impl_.manufacturer_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(DisplayDevice, _impl_.manufacture_year_) + sizeof(DisplayDevice::_impl_.manufacture_year_)
        - PROTOBUF_FIELD_OFFSET(DisplayDevice, _impl_.display_width_)>(
        reinterpret_cast<char*>(&_impl_.display_width_), reinterpret_cast<char*>(&other->_impl_.display_width_));
}

std::string DisplayDevice::GetTypeName() const
{
    return "reporting.DisplayDevice";
}

// ===================================================================

class KeylockerInfo::_Internal {
public:
    using HasBits = decltype(std::declval<KeylockerInfo>()._impl_._has_bits_);
    static void set_has_supported(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_configured(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

KeylockerInfo::KeylockerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.KeylockerInfo)
}
KeylockerInfo::KeylockerInfo(const KeylockerInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    KeylockerInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.supported_) {},
        decltype(_impl_.configured_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.supported_, &from._impl_.supported_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.configured_) - reinterpret_cast<char*>(&_impl_.supported_)) + sizeof(_impl_.configured_));
    // @@protoc_insertion_point(copy_constructor:reporting.KeylockerInfo)
}

inline void KeylockerInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.supported_) { false },
        decltype(_impl_.configured_) { false } };
}

KeylockerInfo::~KeylockerInfo()
{
    // @@protoc_insertion_point(destructor:reporting.KeylockerInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void KeylockerInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KeylockerInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void KeylockerInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.KeylockerInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    ::memset(&_impl_.supported_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.configured_) - reinterpret_cast<char*>(&_impl_.supported_)) + sizeof(_impl_.configured_));
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* KeylockerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bool supported = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_supported(&has_bits);
                _impl_.supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool configured = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_configured(&has_bits);
                _impl_.configured_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* KeylockerInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.KeylockerInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool supported = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_supported(), target);
    }

    // optional bool configured = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_configured(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.KeylockerInfo)
    return target;
}

size_t KeylockerInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.KeylockerInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional bool supported = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 1;
        }

        // optional bool configured = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void KeylockerInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const KeylockerInfo*>(&from));
}

void KeylockerInfo::MergeFrom(const KeylockerInfo& from)
{
    KeylockerInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.KeylockerInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.supported_ = from._impl_.supported_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.configured_ = from._impl_.configured_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KeylockerInfo::CopyFrom(const KeylockerInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.KeylockerInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool KeylockerInfo::IsInitialized() const
{
    return true;
}

void KeylockerInfo::InternalSwap(KeylockerInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(KeylockerInfo, _impl_.configured_) + sizeof(KeylockerInfo::_impl_.configured_)
        - PROTOBUF_FIELD_OFFSET(KeylockerInfo, _impl_.supported_)>(
        reinterpret_cast<char*>(&_impl_.supported_), reinterpret_cast<char*>(&other->_impl_.supported_));
}

std::string KeylockerInfo::GetTypeName() const
{
    return "reporting.KeylockerInfo";
}

// ===================================================================

class CpuInfo::_Internal {
public:
    using HasBits = decltype(std::declval<CpuInfo>()._impl_._has_bits_);
    static const ::reporting::KeylockerInfo& keylocker_info(const CpuInfo* msg);
    static void set_has_keylocker_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::reporting::KeylockerInfo& CpuInfo::_Internal::keylocker_info(const CpuInfo* msg)
{
    return *msg->_impl_.keylocker_info_;
}
CpuInfo::CpuInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.CpuInfo)
}
CpuInfo::CpuInfo(const CpuInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CpuInfo* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.keylocker_info_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_keylocker_info()) {
        _this->_impl_.keylocker_info_ = new ::reporting::KeylockerInfo(*from._impl_.keylocker_info_);
    }
    // @@protoc_insertion_point(copy_constructor:reporting.CpuInfo)
}

inline void CpuInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.keylocker_info_) { nullptr } };
}

CpuInfo::~CpuInfo()
{
    // @@protoc_insertion_point(destructor:reporting.CpuInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CpuInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.keylocker_info_;
}

void CpuInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CpuInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.CpuInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.keylocker_info_ != nullptr);
        _impl_.keylocker_info_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CpuInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .reporting.KeylockerInfo keylocker_info = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_keylocker_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CpuInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.CpuInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .reporting.KeylockerInfo keylocker_info = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::keylocker_info(this), _Internal::keylocker_info(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.CpuInfo)
    return target;
}

size_t CpuInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.CpuInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .reporting.KeylockerInfo keylocker_info = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.keylocker_info_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CpuInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CpuInfo*>(&from));
}

void CpuInfo::MergeFrom(const CpuInfo& from)
{
    CpuInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.CpuInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_keylocker_info()) {
        _this->_internal_mutable_keylocker_info()->::reporting::KeylockerInfo::MergeFrom(from._internal_keylocker_info());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CpuInfo::CopyFrom(const CpuInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.CpuInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CpuInfo::IsInitialized() const
{
    return true;
}

void CpuInfo::InternalSwap(CpuInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.keylocker_info_, other->_impl_.keylocker_info_);
}

std::string CpuInfo::GetTypeName() const
{
    return "reporting.CpuInfo";
}

// ===================================================================

class InfoData::_Internal {
public:
    using HasBits = decltype(std::declval<InfoData>()._impl_._has_bits_);
    static const ::reporting::CpuInfo& cpu_info(const InfoData* msg);
    static void set_has_cpu_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::reporting::BusDeviceInfo& bus_device_info(const InfoData* msg);
    static void set_has_bus_device_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::reporting::MemoryInfo& memory_info(const InfoData* msg);
    static void set_has_memory_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::reporting::NetworksInfo& networks_info(const InfoData* msg);
    static void set_has_networks_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::reporting::TouchScreenInfo& touch_screen_info(const InfoData* msg);
    static void set_has_touch_screen_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::reporting::PrivacyScreenInfo& privacy_screen_info(const InfoData* msg);
    static void set_has_privacy_screen_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::reporting::DisplayInfo& display_info(const InfoData* msg);
    static void set_has_display_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
};

const ::reporting::CpuInfo& InfoData::_Internal::cpu_info(const InfoData* msg)
{
    return *msg->_impl_.cpu_info_;
}
const ::reporting::BusDeviceInfo& InfoData::_Internal::bus_device_info(const InfoData* msg)
{
    return *msg->_impl_.bus_device_info_;
}
const ::reporting::MemoryInfo& InfoData::_Internal::memory_info(const InfoData* msg)
{
    return *msg->_impl_.memory_info_;
}
const ::reporting::NetworksInfo& InfoData::_Internal::networks_info(const InfoData* msg)
{
    return *msg->_impl_.networks_info_;
}
const ::reporting::TouchScreenInfo& InfoData::_Internal::touch_screen_info(const InfoData* msg)
{
    return *msg->_impl_.touch_screen_info_;
}
const ::reporting::PrivacyScreenInfo& InfoData::_Internal::privacy_screen_info(const InfoData* msg)
{
    return *msg->_impl_.privacy_screen_info_;
}
const ::reporting::DisplayInfo& InfoData::_Internal::display_info(const InfoData* msg)
{
    return *msg->_impl_.display_info_;
}
InfoData::InfoData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.InfoData)
}
InfoData::InfoData(const InfoData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    InfoData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cpu_info_) { nullptr },
        decltype(_impl_.bus_device_info_) { nullptr }, decltype(_impl_.memory_info_) { nullptr }, decltype(_impl_.networks_info_) { nullptr },
        decltype(_impl_.touch_screen_info_) { nullptr }, decltype(_impl_.privacy_screen_info_) { nullptr }, decltype(_impl_.display_info_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_cpu_info()) {
        _this->_impl_.cpu_info_ = new ::reporting::CpuInfo(*from._impl_.cpu_info_);
    }
    if (from._internal_has_bus_device_info()) {
        _this->_impl_.bus_device_info_ = new ::reporting::BusDeviceInfo(*from._impl_.bus_device_info_);
    }
    if (from._internal_has_memory_info()) {
        _this->_impl_.memory_info_ = new ::reporting::MemoryInfo(*from._impl_.memory_info_);
    }
    if (from._internal_has_networks_info()) {
        _this->_impl_.networks_info_ = new ::reporting::NetworksInfo(*from._impl_.networks_info_);
    }
    if (from._internal_has_touch_screen_info()) {
        _this->_impl_.touch_screen_info_ = new ::reporting::TouchScreenInfo(*from._impl_.touch_screen_info_);
    }
    if (from._internal_has_privacy_screen_info()) {
        _this->_impl_.privacy_screen_info_ = new ::reporting::PrivacyScreenInfo(*from._impl_.privacy_screen_info_);
    }
    if (from._internal_has_display_info()) {
        _this->_impl_.display_info_ = new ::reporting::DisplayInfo(*from._impl_.display_info_);
    }
    // @@protoc_insertion_point(copy_constructor:reporting.InfoData)
}

inline void InfoData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cpu_info_) { nullptr },
        decltype(_impl_.bus_device_info_) { nullptr }, decltype(_impl_.memory_info_) { nullptr }, decltype(_impl_.networks_info_) { nullptr },
        decltype(_impl_.touch_screen_info_) { nullptr }, decltype(_impl_.privacy_screen_info_) { nullptr }, decltype(_impl_.display_info_) { nullptr } };
}

InfoData::~InfoData()
{
    // @@protoc_insertion_point(destructor:reporting.InfoData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void InfoData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.cpu_info_;
    if (this != internal_default_instance())
        delete _impl_.bus_device_info_;
    if (this != internal_default_instance())
        delete _impl_.memory_info_;
    if (this != internal_default_instance())
        delete _impl_.networks_info_;
    if (this != internal_default_instance())
        delete _impl_.touch_screen_info_;
    if (this != internal_default_instance())
        delete _impl_.privacy_screen_info_;
    if (this != internal_default_instance())
        delete _impl_.display_info_;
}

void InfoData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void InfoData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.InfoData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.cpu_info_ != nullptr);
            _impl_.cpu_info_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.bus_device_info_ != nullptr);
            _impl_.bus_device_info_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.memory_info_ != nullptr);
            _impl_.memory_info_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.networks_info_ != nullptr);
            _impl_.networks_info_->Clear();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.touch_screen_info_ != nullptr);
            _impl_.touch_screen_info_->Clear();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.privacy_screen_info_ != nullptr);
            _impl_.privacy_screen_info_->Clear();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.display_info_ != nullptr);
            _impl_.display_info_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* InfoData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .reporting.CpuInfo cpu_info = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_cpu_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.BusDeviceInfo bus_device_info = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_bus_device_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.MemoryInfo memory_info = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_memory_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.NetworksInfo networks_info = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_networks_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.TouchScreenInfo touch_screen_info = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_touch_screen_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.PrivacyScreenInfo privacy_screen_info = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_privacy_screen_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.DisplayInfo display_info = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_display_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* InfoData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.InfoData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .reporting.CpuInfo cpu_info = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::cpu_info(this), _Internal::cpu_info(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.BusDeviceInfo bus_device_info = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::bus_device_info(this), _Internal::bus_device_info(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.MemoryInfo memory_info = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::memory_info(this), _Internal::memory_info(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.NetworksInfo networks_info = 4;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::networks_info(this), _Internal::networks_info(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.TouchScreenInfo touch_screen_info = 5;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::touch_screen_info(this), _Internal::touch_screen_info(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.PrivacyScreenInfo privacy_screen_info = 6;
    if (cached_has_bits & 0x00000020u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::privacy_screen_info(this), _Internal::privacy_screen_info(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.DisplayInfo display_info = 7;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::display_info(this), _Internal::display_info(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.InfoData)
    return target;
}

size_t InfoData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.InfoData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        // optional .reporting.CpuInfo cpu_info = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.cpu_info_);
        }

        // optional .reporting.BusDeviceInfo bus_device_info = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.bus_device_info_);
        }

        // optional .reporting.MemoryInfo memory_info = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.memory_info_);
        }

        // optional .reporting.NetworksInfo networks_info = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.networks_info_);
        }

        // optional .reporting.TouchScreenInfo touch_screen_info = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.touch_screen_info_);
        }

        // optional .reporting.PrivacyScreenInfo privacy_screen_info = 6;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.privacy_screen_info_);
        }

        // optional .reporting.DisplayInfo display_info = 7;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.display_info_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void InfoData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const InfoData*>(&from));
}

void InfoData::MergeFrom(const InfoData& from)
{
    InfoData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.InfoData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_cpu_info()->::reporting::CpuInfo::MergeFrom(from._internal_cpu_info());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_bus_device_info()->::reporting::BusDeviceInfo::MergeFrom(from._internal_bus_device_info());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_memory_info()->::reporting::MemoryInfo::MergeFrom(from._internal_memory_info());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_networks_info()->::reporting::NetworksInfo::MergeFrom(from._internal_networks_info());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_touch_screen_info()->::reporting::TouchScreenInfo::MergeFrom(from._internal_touch_screen_info());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_privacy_screen_info()->::reporting::PrivacyScreenInfo::MergeFrom(from._internal_privacy_screen_info());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_display_info()->::reporting::DisplayInfo::MergeFrom(from._internal_display_info());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InfoData::CopyFrom(const InfoData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.InfoData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool InfoData::IsInitialized() const
{
    return true;
}

void InfoData::InternalSwap(InfoData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(InfoData, _impl_.display_info_) + sizeof(InfoData::_impl_.display_info_)
        - PROTOBUF_FIELD_OFFSET(InfoData, _impl_.cpu_info_)>(reinterpret_cast<char*>(&_impl_.cpu_info_), reinterpret_cast<char*>(&other->_impl_.cpu_info_));
}

std::string InfoData::GetTypeName() const
{
    return "reporting.InfoData";
}

// ===================================================================

class AudioTelemetry::_Internal {
public:
    using HasBits = decltype(std::declval<AudioTelemetry>()._impl_._has_bits_);
    static void set_has_output_mute(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_input_mute(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_output_volume(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_output_device_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_input_gain(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_input_device_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

AudioTelemetry::AudioTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.AudioTelemetry)
}
AudioTelemetry::AudioTelemetry(const AudioTelemetry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AudioTelemetry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.output_device_name_) {}, decltype(_impl_.input_device_name_) {}, decltype(_impl_.output_mute_) {}, decltype(_impl_.input_mute_) {},
        decltype(_impl_.output_volume_) {}, decltype(_impl_.input_gain_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.output_device_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.output_device_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_output_device_name()) {
        _this->_impl_.output_device_name_.Set(from._internal_output_device_name(), _this->GetArenaForAllocation());
    }
    _impl_.input_device_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.input_device_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_input_device_name()) {
        _this->_impl_.input_device_name_.Set(from._internal_input_device_name(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.output_mute_, &from._impl_.output_mute_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.input_gain_) - reinterpret_cast<char*>(&_impl_.output_mute_)) + sizeof(_impl_.input_gain_));
    // @@protoc_insertion_point(copy_constructor:reporting.AudioTelemetry)
}

inline void AudioTelemetry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.output_device_name_) {},
        decltype(_impl_.input_device_name_) {}, decltype(_impl_.output_mute_) { false }, decltype(_impl_.input_mute_) { false },
        decltype(_impl_.output_volume_) { 0 }, decltype(_impl_.input_gain_) { 0 } };
    _impl_.output_device_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.output_device_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.input_device_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.input_device_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AudioTelemetry::~AudioTelemetry()
{
    // @@protoc_insertion_point(destructor:reporting.AudioTelemetry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AudioTelemetry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.output_device_name_.Destroy();
    _impl_.input_device_name_.Destroy();
}

void AudioTelemetry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AudioTelemetry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.AudioTelemetry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.output_device_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.input_device_name_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000003cu) {
        ::memset(&_impl_.output_mute_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.input_gain_) - reinterpret_cast<char*>(&_impl_.output_mute_)) + sizeof(_impl_.input_gain_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AudioTelemetry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bool output_mute = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_output_mute(&has_bits);
                _impl_.output_mute_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool input_mute = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_input_mute(&has_bits);
                _impl_.input_mute_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 output_volume = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_output_volume(&has_bits);
                _impl_.output_volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string output_device_name = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_output_device_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 input_gain = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_input_gain(&has_bits);
                _impl_.input_gain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string input_device_name = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_input_device_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AudioTelemetry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.AudioTelemetry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool output_mute = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_output_mute(), target);
    }

    // optional bool input_mute = 2;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_input_mute(), target);
    }

    // optional int32 output_volume = 3;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_output_volume(), target);
    }

    // optional string output_device_name = 4;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_output_device_name(), target);
    }

    // optional int32 input_gain = 5;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_input_gain(), target);
    }

    // optional string input_device_name = 6;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(6, this->_internal_input_device_name(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.AudioTelemetry)
    return target;
}

size_t AudioTelemetry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.AudioTelemetry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional string output_device_name = 4;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_output_device_name());
        }

        // optional string input_device_name = 6;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_input_device_name());
        }

        // optional bool output_mute = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }

        // optional bool input_mute = 2;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }

        // optional int32 output_volume = 3;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_output_volume());
        }

        // optional int32 input_gain = 5;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_input_gain());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AudioTelemetry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AudioTelemetry*>(&from));
}

void AudioTelemetry::MergeFrom(const AudioTelemetry& from)
{
    AudioTelemetry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.AudioTelemetry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_output_device_name(from._internal_output_device_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_input_device_name(from._internal_input_device_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.output_mute_ = from._impl_.output_mute_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.input_mute_ = from._impl_.input_mute_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.output_volume_ = from._impl_.output_volume_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.input_gain_ = from._impl_.input_gain_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AudioTelemetry::CopyFrom(const AudioTelemetry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.AudioTelemetry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AudioTelemetry::IsInitialized() const
{
    return true;
}

void AudioTelemetry::InternalSwap(AudioTelemetry* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.output_device_name_, lhs_arena, &other->_impl_.output_device_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.input_device_name_, lhs_arena, &other->_impl_.input_device_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AudioTelemetry, _impl_.input_gain_) + sizeof(AudioTelemetry::_impl_.input_gain_)
        - PROTOBUF_FIELD_OFFSET(AudioTelemetry, _impl_.output_mute_)>(
        reinterpret_cast<char*>(&_impl_.output_mute_), reinterpret_cast<char*>(&other->_impl_.output_mute_));
}

std::string AudioTelemetry::GetTypeName() const
{
    return "reporting.AudioTelemetry";
}

// ===================================================================

class BootPerformanceTelemetry::_Internal {
public:
    using HasBits = decltype(std::declval<BootPerformanceTelemetry>()._impl_._has_bits_);
    static void set_has_boot_up_seconds(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_boot_up_timestamp_seconds(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_shutdown_seconds(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_shutdown_timestamp_seconds(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_shutdown_reason(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

BootPerformanceTelemetry::BootPerformanceTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.BootPerformanceTelemetry)
}
BootPerformanceTelemetry::BootPerformanceTelemetry(const BootPerformanceTelemetry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    BootPerformanceTelemetry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.shutdown_reason_) {},
        decltype(_impl_.boot_up_seconds_) {}, decltype(_impl_.boot_up_timestamp_seconds_) {}, decltype(_impl_.shutdown_seconds_) {},
        decltype(_impl_.shutdown_timestamp_seconds_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.shutdown_reason_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shutdown_reason_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_shutdown_reason()) {
        _this->_impl_.shutdown_reason_.Set(from._internal_shutdown_reason(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.boot_up_seconds_, &from._impl_.boot_up_seconds_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.shutdown_timestamp_seconds_) - reinterpret_cast<char*>(&_impl_.boot_up_seconds_))
            + sizeof(_impl_.shutdown_timestamp_seconds_));
    // @@protoc_insertion_point(copy_constructor:reporting.BootPerformanceTelemetry)
}

inline void BootPerformanceTelemetry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.shutdown_reason_) {},
        decltype(_impl_.boot_up_seconds_) { int64_t { 0 } }, decltype(_impl_.boot_up_timestamp_seconds_) { int64_t { 0 } },
        decltype(_impl_.shutdown_seconds_) { int64_t { 0 } }, decltype(_impl_.shutdown_timestamp_seconds_) { int64_t { 0 } } };
    _impl_.shutdown_reason_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shutdown_reason_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BootPerformanceTelemetry::~BootPerformanceTelemetry()
{
    // @@protoc_insertion_point(destructor:reporting.BootPerformanceTelemetry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void BootPerformanceTelemetry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.shutdown_reason_.Destroy();
}

void BootPerformanceTelemetry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void BootPerformanceTelemetry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.BootPerformanceTelemetry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.shutdown_reason_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x0000001eu) {
        ::memset(&_impl_.boot_up_seconds_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.shutdown_timestamp_seconds_) - reinterpret_cast<char*>(&_impl_.boot_up_seconds_))
                + sizeof(_impl_.shutdown_timestamp_seconds_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* BootPerformanceTelemetry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 boot_up_seconds = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_boot_up_seconds(&has_bits);
                _impl_.boot_up_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 boot_up_timestamp_seconds = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_boot_up_timestamp_seconds(&has_bits);
                _impl_.boot_up_timestamp_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 shutdown_seconds = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_shutdown_seconds(&has_bits);
                _impl_.shutdown_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 shutdown_timestamp_seconds = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_shutdown_timestamp_seconds(&has_bits);
                _impl_.shutdown_timestamp_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string shutdown_reason = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_shutdown_reason();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* BootPerformanceTelemetry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.BootPerformanceTelemetry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 boot_up_seconds = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_boot_up_seconds(), target);
    }

    // optional int64 boot_up_timestamp_seconds = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_boot_up_timestamp_seconds(), target);
    }

    // optional int64 shutdown_seconds = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_shutdown_seconds(), target);
    }

    // optional int64 shutdown_timestamp_seconds = 4;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_shutdown_timestamp_seconds(), target);
    }

    // optional string shutdown_reason = 5;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_shutdown_reason(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.BootPerformanceTelemetry)
    return target;
}

size_t BootPerformanceTelemetry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.BootPerformanceTelemetry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string shutdown_reason = 5;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_shutdown_reason());
        }

        // optional int64 boot_up_seconds = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_boot_up_seconds());
        }

        // optional int64 boot_up_timestamp_seconds = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_boot_up_timestamp_seconds());
        }

        // optional int64 shutdown_seconds = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shutdown_seconds());
        }

        // optional int64 shutdown_timestamp_seconds = 4;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_shutdown_timestamp_seconds());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void BootPerformanceTelemetry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const BootPerformanceTelemetry*>(&from));
}

void BootPerformanceTelemetry::MergeFrom(const BootPerformanceTelemetry& from)
{
    BootPerformanceTelemetry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.BootPerformanceTelemetry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_shutdown_reason(from._internal_shutdown_reason());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.boot_up_seconds_ = from._impl_.boot_up_seconds_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.boot_up_timestamp_seconds_ = from._impl_.boot_up_timestamp_seconds_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.shutdown_seconds_ = from._impl_.shutdown_seconds_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.shutdown_timestamp_seconds_ = from._impl_.shutdown_timestamp_seconds_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BootPerformanceTelemetry::CopyFrom(const BootPerformanceTelemetry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.BootPerformanceTelemetry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool BootPerformanceTelemetry::IsInitialized() const
{
    return true;
}

void BootPerformanceTelemetry::InternalSwap(BootPerformanceTelemetry* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.shutdown_reason_, lhs_arena, &other->_impl_.shutdown_reason_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(BootPerformanceTelemetry, _impl_.shutdown_timestamp_seconds_)
        + sizeof(BootPerformanceTelemetry::_impl_.shutdown_timestamp_seconds_) - PROTOBUF_FIELD_OFFSET(BootPerformanceTelemetry, _impl_.boot_up_seconds_)>(
        reinterpret_cast<char*>(&_impl_.boot_up_seconds_), reinterpret_cast<char*>(&other->_impl_.boot_up_seconds_));
}

std::string BootPerformanceTelemetry::GetTypeName() const
{
    return "reporting.BootPerformanceTelemetry";
}

// ===================================================================

class UserStatusTelemetry::_Internal {
public:
    using HasBits = decltype(std::declval<UserStatusTelemetry>()._impl_._has_bits_);
    static void set_has_device_activity_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

UserStatusTelemetry::UserStatusTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.UserStatusTelemetry)
}
UserStatusTelemetry::UserStatusTelemetry(const UserStatusTelemetry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserStatusTelemetry* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.device_activity_state_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.device_activity_state_ = from._impl_.device_activity_state_;
    // @@protoc_insertion_point(copy_constructor:reporting.UserStatusTelemetry)
}

inline void UserStatusTelemetry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.device_activity_state_) { 0 } };
}

UserStatusTelemetry::~UserStatusTelemetry()
{
    // @@protoc_insertion_point(destructor:reporting.UserStatusTelemetry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserStatusTelemetry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserStatusTelemetry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserStatusTelemetry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.UserStatusTelemetry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.device_activity_state_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserStatusTelemetry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .reporting.UserStatusTelemetry.DeviceActivityState device_activity_state = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::reporting::UserStatusTelemetry_DeviceActivityState_IsValid(val))) {
                    _internal_set_device_activity_state(static_cast<::reporting::UserStatusTelemetry_DeviceActivityState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserStatusTelemetry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.UserStatusTelemetry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .reporting.UserStatusTelemetry.DeviceActivityState device_activity_state = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_device_activity_state(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.UserStatusTelemetry)
    return target;
}

size_t UserStatusTelemetry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.UserStatusTelemetry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .reporting.UserStatusTelemetry.DeviceActivityState device_activity_state = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_device_activity_state());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserStatusTelemetry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserStatusTelemetry*>(&from));
}

void UserStatusTelemetry::MergeFrom(const UserStatusTelemetry& from)
{
    UserStatusTelemetry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.UserStatusTelemetry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_device_activity_state()) {
        _this->_internal_set_device_activity_state(from._internal_device_activity_state());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserStatusTelemetry::CopyFrom(const UserStatusTelemetry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.UserStatusTelemetry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserStatusTelemetry::IsInitialized() const
{
    return true;
}

void UserStatusTelemetry::InternalSwap(UserStatusTelemetry* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.device_activity_state_, other->_impl_.device_activity_state_);
}

std::string UserStatusTelemetry::GetTypeName() const
{
    return "reporting.UserStatusTelemetry";
}

// ===================================================================

class DisplaysTelemetry::_Internal {
public:
};

DisplaysTelemetry::DisplaysTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.DisplaysTelemetry)
}
DisplaysTelemetry::DisplaysTelemetry(const DisplaysTelemetry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DisplaysTelemetry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.display_status_) { from._impl_.display_status_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:reporting.DisplaysTelemetry)
}

inline void DisplaysTelemetry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.display_status_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

DisplaysTelemetry::~DisplaysTelemetry()
{
    // @@protoc_insertion_point(destructor:reporting.DisplaysTelemetry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DisplaysTelemetry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.display_status_.~RepeatedPtrField();
}

void DisplaysTelemetry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DisplaysTelemetry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.DisplaysTelemetry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.display_status_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DisplaysTelemetry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .reporting.DisplayStatus display_status = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_display_status(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DisplaysTelemetry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.DisplaysTelemetry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .reporting.DisplayStatus display_status = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_display_status_size()); i < n; i++) {
        const auto& repfield = this->_internal_display_status(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.DisplaysTelemetry)
    return target;
}

size_t DisplaysTelemetry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.DisplaysTelemetry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .reporting.DisplayStatus display_status = 1;
    total_size += 1UL * this->_internal_display_status_size();
    for (const auto& msg : this->_impl_.display_status_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DisplaysTelemetry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DisplaysTelemetry*>(&from));
}

void DisplaysTelemetry::MergeFrom(const DisplaysTelemetry& from)
{
    DisplaysTelemetry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.DisplaysTelemetry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.display_status_.MergeFrom(from._impl_.display_status_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DisplaysTelemetry::CopyFrom(const DisplaysTelemetry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.DisplaysTelemetry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DisplaysTelemetry::IsInitialized() const
{
    return true;
}

void DisplaysTelemetry::InternalSwap(DisplaysTelemetry* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.display_status_.InternalSwap(&other->_impl_.display_status_);
}

std::string DisplaysTelemetry::GetTypeName() const
{
    return "reporting.DisplaysTelemetry";
}

// ===================================================================

class DisplayStatus::_Internal {
public:
    using HasBits = decltype(std::declval<DisplayStatus>()._impl_._has_bits_);
    static void set_has_display_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_resolution_horizontal(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_resolution_vertical(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_refresh_rate(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_is_internal(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

DisplayStatus::DisplayStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.DisplayStatus)
}
DisplayStatus::DisplayStatus(const DisplayStatus& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DisplayStatus* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.display_name_) {},
        decltype(_impl_.resolution_horizontal_) {}, decltype(_impl_.resolution_vertical_) {}, decltype(_impl_.refresh_rate_) {},
        decltype(_impl_.is_internal_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_display_name()) {
        _this->_impl_.display_name_.Set(from._internal_display_name(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.resolution_horizontal_, &from._impl_.resolution_horizontal_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_internal_) - reinterpret_cast<char*>(&_impl_.resolution_horizontal_))
            + sizeof(_impl_.is_internal_));
    // @@protoc_insertion_point(copy_constructor:reporting.DisplayStatus)
}

inline void DisplayStatus::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.display_name_) {},
        decltype(_impl_.resolution_horizontal_) { 0 }, decltype(_impl_.resolution_vertical_) { 0 }, decltype(_impl_.refresh_rate_) { int64_t { 0 } },
        decltype(_impl_.is_internal_) { false } };
    _impl_.display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DisplayStatus::~DisplayStatus()
{
    // @@protoc_insertion_point(destructor:reporting.DisplayStatus)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DisplayStatus::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.display_name_.Destroy();
}

void DisplayStatus::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DisplayStatus::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.DisplayStatus)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.display_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x0000001eu) {
        ::memset(&_impl_.resolution_horizontal_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_internal_) - reinterpret_cast<char*>(&_impl_.resolution_horizontal_))
                + sizeof(_impl_.is_internal_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DisplayStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string display_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_display_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 resolution_horizontal = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_resolution_horizontal(&has_bits);
                _impl_.resolution_horizontal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 resolution_vertical = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_resolution_vertical(&has_bits);
                _impl_.resolution_vertical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 refresh_rate = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_refresh_rate(&has_bits);
                _impl_.refresh_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_internal = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_is_internal(&has_bits);
                _impl_.is_internal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DisplayStatus::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.DisplayStatus)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string display_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_display_name(), target);
    }

    // optional int32 resolution_horizontal = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_resolution_horizontal(), target);
    }

    // optional int32 resolution_vertical = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_resolution_vertical(), target);
    }

    // optional int64 refresh_rate = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_refresh_rate(), target);
    }

    // optional bool is_internal = 5;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_internal(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.DisplayStatus)
    return target;
}

size_t DisplayStatus::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.DisplayStatus)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string display_name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_display_name());
        }

        // optional int32 resolution_horizontal = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_resolution_horizontal());
        }

        // optional int32 resolution_vertical = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_resolution_vertical());
        }

        // optional int64 refresh_rate = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_refresh_rate());
        }

        // optional bool is_internal = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DisplayStatus::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DisplayStatus*>(&from));
}

void DisplayStatus::MergeFrom(const DisplayStatus& from)
{
    DisplayStatus* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.DisplayStatus)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_display_name(from._internal_display_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.resolution_horizontal_ = from._impl_.resolution_horizontal_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.resolution_vertical_ = from._impl_.resolution_vertical_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.refresh_rate_ = from._impl_.refresh_rate_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.is_internal_ = from._impl_.is_internal_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DisplayStatus::CopyFrom(const DisplayStatus& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.DisplayStatus)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DisplayStatus::IsInitialized() const
{
    return true;
}

void DisplayStatus::InternalSwap(DisplayStatus* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.display_name_, lhs_arena, &other->_impl_.display_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(DisplayStatus, _impl_.is_internal_) + sizeof(DisplayStatus::_impl_.is_internal_)
        - PROTOBUF_FIELD_OFFSET(DisplayStatus, _impl_.resolution_horizontal_)>(
        reinterpret_cast<char*>(&_impl_.resolution_horizontal_), reinterpret_cast<char*>(&other->_impl_.resolution_horizontal_));
}

std::string DisplayStatus::GetTypeName() const
{
    return "reporting.DisplayStatus";
}

// ===================================================================

class KioskHeartbeatTelemetry::_Internal {
public:
};

KioskHeartbeatTelemetry::KioskHeartbeatTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.KioskHeartbeatTelemetry)
}
KioskHeartbeatTelemetry::KioskHeartbeatTelemetry(const KioskHeartbeatTelemetry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    KioskHeartbeatTelemetry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:reporting.KioskHeartbeatTelemetry)
}

inline void KioskHeartbeatTelemetry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

KioskHeartbeatTelemetry::~KioskHeartbeatTelemetry()
{
    // @@protoc_insertion_point(destructor:reporting.KioskHeartbeatTelemetry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void KioskHeartbeatTelemetry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KioskHeartbeatTelemetry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void KioskHeartbeatTelemetry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.KioskHeartbeatTelemetry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* KioskHeartbeatTelemetry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* KioskHeartbeatTelemetry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.KioskHeartbeatTelemetry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.KioskHeartbeatTelemetry)
    return target;
}

size_t KioskHeartbeatTelemetry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.KioskHeartbeatTelemetry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void KioskHeartbeatTelemetry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const KioskHeartbeatTelemetry*>(&from));
}

void KioskHeartbeatTelemetry::MergeFrom(const KioskHeartbeatTelemetry& from)
{
    KioskHeartbeatTelemetry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.KioskHeartbeatTelemetry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KioskHeartbeatTelemetry::CopyFrom(const KioskHeartbeatTelemetry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.KioskHeartbeatTelemetry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool KioskHeartbeatTelemetry::IsInitialized() const
{
    return true;
}

void KioskHeartbeatTelemetry::InternalSwap(KioskHeartbeatTelemetry* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string KioskHeartbeatTelemetry::GetTypeName() const
{
    return "reporting.KioskHeartbeatTelemetry";
}

// ===================================================================

class KioskVisionView::_Internal {
public:
    using HasBits = decltype(std::declval<KioskVisionView>()._impl_._has_bits_);
    static void set_has_start_time_sec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_end_time_sec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

KioskVisionView::KioskVisionView(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.KioskVisionView)
}
KioskVisionView::KioskVisionView(const KioskVisionView& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    KioskVisionView* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.start_time_sec_) {},
        decltype(_impl_.end_time_sec_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.start_time_sec_, &from._impl_.start_time_sec_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.end_time_sec_) - reinterpret_cast<char*>(&_impl_.start_time_sec_)) + sizeof(_impl_.end_time_sec_));
    // @@protoc_insertion_point(copy_constructor:reporting.KioskVisionView)
}

inline void KioskVisionView::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.start_time_sec_) { int64_t { 0 } },
        decltype(_impl_.end_time_sec_) { int64_t { 0 } } };
}

KioskVisionView::~KioskVisionView()
{
    // @@protoc_insertion_point(destructor:reporting.KioskVisionView)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void KioskVisionView::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KioskVisionView::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void KioskVisionView::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.KioskVisionView)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.start_time_sec_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.end_time_sec_) - reinterpret_cast<char*>(&_impl_.start_time_sec_))
                + sizeof(_impl_.end_time_sec_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* KioskVisionView::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 start_time_sec = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_start_time_sec(&has_bits);
                _impl_.start_time_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 end_time_sec = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_end_time_sec(&has_bits);
                _impl_.end_time_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* KioskVisionView::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.KioskVisionView)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 start_time_sec = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_start_time_sec(), target);
    }

    // optional int64 end_time_sec = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_end_time_sec(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.KioskVisionView)
    return target;
}

size_t KioskVisionView::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.KioskVisionView)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int64 start_time_sec = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_start_time_sec());
        }

        // optional int64 end_time_sec = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_end_time_sec());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void KioskVisionView::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const KioskVisionView*>(&from));
}

void KioskVisionView::MergeFrom(const KioskVisionView& from)
{
    KioskVisionView* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.KioskVisionView)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.start_time_sec_ = from._impl_.start_time_sec_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.end_time_sec_ = from._impl_.end_time_sec_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KioskVisionView::CopyFrom(const KioskVisionView& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.KioskVisionView)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool KioskVisionView::IsInitialized() const
{
    return true;
}

void KioskVisionView::InternalSwap(KioskVisionView* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(KioskVisionView, _impl_.end_time_sec_) + sizeof(KioskVisionView::_impl_.end_time_sec_)
        - PROTOBUF_FIELD_OFFSET(KioskVisionView, _impl_.start_time_sec_)>(
        reinterpret_cast<char*>(&_impl_.start_time_sec_), reinterpret_cast<char*>(&other->_impl_.start_time_sec_));
}

std::string KioskVisionView::GetTypeName() const
{
    return "reporting.KioskVisionView";
}

// ===================================================================

class KioskVisionAudience::_Internal {
public:
    using HasBits = decltype(std::declval<KioskVisionAudience>()._impl_._has_bits_);
    static void set_has_presence_start_date_sec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_presence_end_date_sec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

KioskVisionAudience::KioskVisionAudience(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.KioskVisionAudience)
}
KioskVisionAudience::KioskVisionAudience(const KioskVisionAudience& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    KioskVisionAudience* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.views_) { from._impl_.views_ }, decltype(_impl_.presence_start_date_sec_) {}, decltype(_impl_.presence_end_date_sec_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.presence_start_date_sec_, &from._impl_.presence_start_date_sec_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.presence_end_date_sec_) - reinterpret_cast<char*>(&_impl_.presence_start_date_sec_))
            + sizeof(_impl_.presence_end_date_sec_));
    // @@protoc_insertion_point(copy_constructor:reporting.KioskVisionAudience)
}

inline void KioskVisionAudience::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.views_) { arena },
        decltype(_impl_.presence_start_date_sec_) { int64_t { 0 } }, decltype(_impl_.presence_end_date_sec_) { int64_t { 0 } } };
}

KioskVisionAudience::~KioskVisionAudience()
{
    // @@protoc_insertion_point(destructor:reporting.KioskVisionAudience)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void KioskVisionAudience::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.views_.~RepeatedPtrField();
}

void KioskVisionAudience::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void KioskVisionAudience::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.KioskVisionAudience)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.views_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.presence_start_date_sec_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.presence_end_date_sec_) - reinterpret_cast<char*>(&_impl_.presence_start_date_sec_))
                + sizeof(_impl_.presence_end_date_sec_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* KioskVisionAudience::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 presence_start_date_sec = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_presence_start_date_sec(&has_bits);
                _impl_.presence_start_date_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 presence_end_date_sec = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_presence_end_date_sec(&has_bits);
                _impl_.presence_end_date_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .reporting.KioskVisionView views = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_views(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* KioskVisionAudience::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.KioskVisionAudience)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 presence_start_date_sec = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_presence_start_date_sec(), target);
    }

    // optional int64 presence_end_date_sec = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_presence_end_date_sec(), target);
    }

    // repeated .reporting.KioskVisionView views = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_views_size()); i < n; i++) {
        const auto& repfield = this->_internal_views(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.KioskVisionAudience)
    return target;
}

size_t KioskVisionAudience::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.KioskVisionAudience)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .reporting.KioskVisionView views = 3;
    total_size += 1UL * this->_internal_views_size();
    for (const auto& msg : this->_impl_.views_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int64 presence_start_date_sec = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_presence_start_date_sec());
        }

        // optional int64 presence_end_date_sec = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_presence_end_date_sec());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void KioskVisionAudience::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const KioskVisionAudience*>(&from));
}

void KioskVisionAudience::MergeFrom(const KioskVisionAudience& from)
{
    KioskVisionAudience* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.KioskVisionAudience)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.views_.MergeFrom(from._impl_.views_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.presence_start_date_sec_ = from._impl_.presence_start_date_sec_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.presence_end_date_sec_ = from._impl_.presence_end_date_sec_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KioskVisionAudience::CopyFrom(const KioskVisionAudience& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.KioskVisionAudience)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool KioskVisionAudience::IsInitialized() const
{
    return true;
}

void KioskVisionAudience::InternalSwap(KioskVisionAudience* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.views_.InternalSwap(&other->_impl_.views_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(KioskVisionAudience, _impl_.presence_end_date_sec_)
        + sizeof(KioskVisionAudience::_impl_.presence_end_date_sec_) - PROTOBUF_FIELD_OFFSET(KioskVisionAudience, _impl_.presence_start_date_sec_)>(
        reinterpret_cast<char*>(&_impl_.presence_start_date_sec_), reinterpret_cast<char*>(&other->_impl_.presence_start_date_sec_));
}

std::string KioskVisionAudience::GetTypeName() const
{
    return "reporting.KioskVisionAudience";
}

// ===================================================================

class KioskVisionTelemetry::_Internal {
public:
    using HasBits = decltype(std::declval<KioskVisionTelemetry>()._impl_._has_bits_);
    static void set_has_start_date_sec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_end_date_sec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_view_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_pass_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

KioskVisionTelemetry::KioskVisionTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.KioskVisionTelemetry)
}
KioskVisionTelemetry::KioskVisionTelemetry(const KioskVisionTelemetry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    KioskVisionTelemetry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.audience_) { from._impl_.audience_ }, decltype(_impl_.start_date_sec_) {}, decltype(_impl_.end_date_sec_) {},
        decltype(_impl_.view_count_) {}, decltype(_impl_.pass_count_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.start_date_sec_, &from._impl_.start_date_sec_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pass_count_) - reinterpret_cast<char*>(&_impl_.start_date_sec_)) + sizeof(_impl_.pass_count_));
    // @@protoc_insertion_point(copy_constructor:reporting.KioskVisionTelemetry)
}

inline void KioskVisionTelemetry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.audience_) { arena },
        decltype(_impl_.start_date_sec_) { int64_t { 0 } }, decltype(_impl_.end_date_sec_) { int64_t { 0 } }, decltype(_impl_.view_count_) { 0 },
        decltype(_impl_.pass_count_) { 0 } };
}

KioskVisionTelemetry::~KioskVisionTelemetry()
{
    // @@protoc_insertion_point(destructor:reporting.KioskVisionTelemetry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void KioskVisionTelemetry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.audience_.~RepeatedPtrField();
}

void KioskVisionTelemetry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void KioskVisionTelemetry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.KioskVisionTelemetry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.audience_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        ::memset(&_impl_.start_date_sec_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pass_count_) - reinterpret_cast<char*>(&_impl_.start_date_sec_)) + sizeof(_impl_.pass_count_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* KioskVisionTelemetry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 start_date_sec = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_start_date_sec(&has_bits);
                _impl_.start_date_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 end_date_sec = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_end_date_sec(&has_bits);
                _impl_.end_date_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 view_count = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_view_count(&has_bits);
                _impl_.view_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 pass_count = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_pass_count(&has_bits);
                _impl_.pass_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .reporting.KioskVisionAudience audience = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_audience(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* KioskVisionTelemetry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.KioskVisionTelemetry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 start_date_sec = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_start_date_sec(), target);
    }

    // optional int64 end_date_sec = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_end_date_sec(), target);
    }

    // optional int32 view_count = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_view_count(), target);
    }

    // optional int32 pass_count = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_pass_count(), target);
    }

    // repeated .reporting.KioskVisionAudience audience = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_audience_size()); i < n; i++) {
        const auto& repfield = this->_internal_audience(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.KioskVisionTelemetry)
    return target;
}

size_t KioskVisionTelemetry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.KioskVisionTelemetry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .reporting.KioskVisionAudience audience = 5;
    total_size += 1UL * this->_internal_audience_size();
    for (const auto& msg : this->_impl_.audience_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional int64 start_date_sec = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_start_date_sec());
        }

        // optional int64 end_date_sec = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_end_date_sec());
        }

        // optional int32 view_count = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_view_count());
        }

        // optional int32 pass_count = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pass_count());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void KioskVisionTelemetry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const KioskVisionTelemetry*>(&from));
}

void KioskVisionTelemetry::MergeFrom(const KioskVisionTelemetry& from)
{
    KioskVisionTelemetry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.KioskVisionTelemetry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.audience_.MergeFrom(from._impl_.audience_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.start_date_sec_ = from._impl_.start_date_sec_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.end_date_sec_ = from._impl_.end_date_sec_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.view_count_ = from._impl_.view_count_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.pass_count_ = from._impl_.pass_count_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KioskVisionTelemetry::CopyFrom(const KioskVisionTelemetry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.KioskVisionTelemetry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool KioskVisionTelemetry::IsInitialized() const
{
    return true;
}

void KioskVisionTelemetry::InternalSwap(KioskVisionTelemetry* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.audience_.InternalSwap(&other->_impl_.audience_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(KioskVisionTelemetry, _impl_.pass_count_)
        + sizeof(KioskVisionTelemetry::_impl_.pass_count_) - PROTOBUF_FIELD_OFFSET(KioskVisionTelemetry, _impl_.start_date_sec_)>(
        reinterpret_cast<char*>(&_impl_.start_date_sec_), reinterpret_cast<char*>(&other->_impl_.start_date_sec_));
}

std::string KioskVisionTelemetry::GetTypeName() const
{
    return "reporting.KioskVisionTelemetry";
}

// ===================================================================

class KioskVisionStatusReport::_Internal {
public:
    using HasBits = decltype(std::declval<KioskVisionStatusReport>()._impl_._has_bits_);
    static void set_has_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_time_stamp_sec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_state_change_time_stamp_sec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

KioskVisionStatusReport::KioskVisionStatusReport(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.KioskVisionStatusReport)
}
KioskVisionStatusReport::KioskVisionStatusReport(const KioskVisionStatusReport& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    KioskVisionStatusReport* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.time_stamp_sec_) {},
        decltype(_impl_.state_change_time_stamp_sec_) {}, decltype(_impl_.state_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.time_stamp_sec_, &from._impl_.time_stamp_sec_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.state_) - reinterpret_cast<char*>(&_impl_.time_stamp_sec_)) + sizeof(_impl_.state_));
    // @@protoc_insertion_point(copy_constructor:reporting.KioskVisionStatusReport)
}

inline void KioskVisionStatusReport::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.time_stamp_sec_) { int64_t { 0 } },
        decltype(_impl_.state_change_time_stamp_sec_) { int64_t { 0 } }, decltype(_impl_.state_) { 0 } };
}

KioskVisionStatusReport::~KioskVisionStatusReport()
{
    // @@protoc_insertion_point(destructor:reporting.KioskVisionStatusReport)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void KioskVisionStatusReport::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KioskVisionStatusReport::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void KioskVisionStatusReport::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.KioskVisionStatusReport)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        ::memset(&_impl_.time_stamp_sec_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.state_) - reinterpret_cast<char*>(&_impl_.time_stamp_sec_)) + sizeof(_impl_.state_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* KioskVisionStatusReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .reporting.KioskVisionStatusReport.KioskVisionState state = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::reporting::KioskVisionStatusReport_KioskVisionState_IsValid(val))) {
                    _internal_set_state(static_cast<::reporting::KioskVisionStatusReport_KioskVisionState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 time_stamp_sec = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_time_stamp_sec(&has_bits);
                _impl_.time_stamp_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 state_change_time_stamp_sec = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_state_change_time_stamp_sec(&has_bits);
                _impl_.state_change_time_stamp_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* KioskVisionStatusReport::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.KioskVisionStatusReport)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .reporting.KioskVisionStatusReport.KioskVisionState state = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_state(), target);
    }

    // optional int64 time_stamp_sec = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_time_stamp_sec(), target);
    }

    // optional int64 state_change_time_stamp_sec = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_state_change_time_stamp_sec(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.KioskVisionStatusReport)
    return target;
}

size_t KioskVisionStatusReport::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.KioskVisionStatusReport)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional int64 time_stamp_sec = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_time_stamp_sec());
        }

        // optional int64 state_change_time_stamp_sec = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_state_change_time_stamp_sec());
        }

        // optional .reporting.KioskVisionStatusReport.KioskVisionState state = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void KioskVisionStatusReport::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const KioskVisionStatusReport*>(&from));
}

void KioskVisionStatusReport::MergeFrom(const KioskVisionStatusReport& from)
{
    KioskVisionStatusReport* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.KioskVisionStatusReport)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.time_stamp_sec_ = from._impl_.time_stamp_sec_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.state_change_time_stamp_sec_ = from._impl_.state_change_time_stamp_sec_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.state_ = from._impl_.state_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void KioskVisionStatusReport::CopyFrom(const KioskVisionStatusReport& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.KioskVisionStatusReport)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool KioskVisionStatusReport::IsInitialized() const
{
    return true;
}

void KioskVisionStatusReport::InternalSwap(KioskVisionStatusReport* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(KioskVisionStatusReport, _impl_.state_) + sizeof(KioskVisionStatusReport::_impl_.state_)
        - PROTOBUF_FIELD_OFFSET(KioskVisionStatusReport, _impl_.time_stamp_sec_)>(
        reinterpret_cast<char*>(&_impl_.time_stamp_sec_), reinterpret_cast<char*>(&other->_impl_.time_stamp_sec_));
}

std::string KioskVisionStatusReport::GetTypeName() const
{
    return "reporting.KioskVisionStatusReport";
}

// ===================================================================

class TelemetryData::_Internal {
public:
    using HasBits = decltype(std::declval<TelemetryData>()._impl_._has_bits_);
    static void set_has_is_event_driven(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static const ::reporting::NetworksTelemetry& networks_telemetry(const TelemetryData* msg);
    static void set_has_networks_telemetry(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::reporting::AudioTelemetry& audio_telemetry(const TelemetryData* msg);
    static void set_has_audio_telemetry(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::reporting::PeripheralsTelemetry& peripherals_telemetry(const TelemetryData* msg);
    static void set_has_peripherals_telemetry(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::reporting::BootPerformanceTelemetry& boot_performance_telemetry(const TelemetryData* msg);
    static void set_has_boot_performance_telemetry(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::reporting::UserStatusTelemetry& user_status_telemetry(const TelemetryData* msg);
    static void set_has_user_status_telemetry(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::reporting::DisplaysTelemetry& displays_telemetry(const TelemetryData* msg);
    static void set_has_displays_telemetry(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::reporting::AppTelemetry& app_telemetry(const TelemetryData* msg);
    static void set_has_app_telemetry(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static const ::reporting::FatalCrashTelemetry& fatal_crash_telemetry(const TelemetryData* msg);
    static void set_has_fatal_crash_telemetry(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static const ::reporting::RuntimeCountersTelemetry& runtime_counters_telemetry(const TelemetryData* msg);
    static void set_has_runtime_counters_telemetry(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static const ::reporting::WebsiteTelemetry& website_telemetry(const TelemetryData* msg);
    static void set_has_website_telemetry(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static const ::reporting::KioskHeartbeatTelemetry& heartbeat_telemetry(const TelemetryData* msg);
    static void set_has_heartbeat_telemetry(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static const ::reporting::KioskVisionTelemetry& kiosk_vision_telemetry(const TelemetryData* msg);
    static void set_has_kiosk_vision_telemetry(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static const ::reporting::KioskVisionStatusReport& kiosk_vision_status(const TelemetryData* msg);
    static void set_has_kiosk_vision_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
};

const ::reporting::NetworksTelemetry& TelemetryData::_Internal::networks_telemetry(const TelemetryData* msg)
{
    return *msg->_impl_.networks_telemetry_;
}
const ::reporting::AudioTelemetry& TelemetryData::_Internal::audio_telemetry(const TelemetryData* msg)
{
    return *msg->_impl_.audio_telemetry_;
}
const ::reporting::PeripheralsTelemetry& TelemetryData::_Internal::peripherals_telemetry(const TelemetryData* msg)
{
    return *msg->_impl_.peripherals_telemetry_;
}
const ::reporting::BootPerformanceTelemetry& TelemetryData::_Internal::boot_performance_telemetry(const TelemetryData* msg)
{
    return *msg->_impl_.boot_performance_telemetry_;
}
const ::reporting::UserStatusTelemetry& TelemetryData::_Internal::user_status_telemetry(const TelemetryData* msg)
{
    return *msg->_impl_.user_status_telemetry_;
}
const ::reporting::DisplaysTelemetry& TelemetryData::_Internal::displays_telemetry(const TelemetryData* msg)
{
    return *msg->_impl_.displays_telemetry_;
}
const ::reporting::AppTelemetry& TelemetryData::_Internal::app_telemetry(const TelemetryData* msg)
{
    return *msg->_impl_.app_telemetry_;
}
const ::reporting::FatalCrashTelemetry& TelemetryData::_Internal::fatal_crash_telemetry(const TelemetryData* msg)
{
    return *msg->_impl_.fatal_crash_telemetry_;
}
const ::reporting::RuntimeCountersTelemetry& TelemetryData::_Internal::runtime_counters_telemetry(const TelemetryData* msg)
{
    return *msg->_impl_.runtime_counters_telemetry_;
}
const ::reporting::WebsiteTelemetry& TelemetryData::_Internal::website_telemetry(const TelemetryData* msg)
{
    return *msg->_impl_.website_telemetry_;
}
const ::reporting::KioskHeartbeatTelemetry& TelemetryData::_Internal::heartbeat_telemetry(const TelemetryData* msg)
{
    return *msg->_impl_.heartbeat_telemetry_;
}
const ::reporting::KioskVisionTelemetry& TelemetryData::_Internal::kiosk_vision_telemetry(const TelemetryData* msg)
{
    return *msg->_impl_.kiosk_vision_telemetry_;
}
const ::reporting::KioskVisionStatusReport& TelemetryData::_Internal::kiosk_vision_status(const TelemetryData* msg)
{
    return *msg->_impl_.kiosk_vision_status_;
}
TelemetryData::TelemetryData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.TelemetryData)
}
TelemetryData::TelemetryData(const TelemetryData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TelemetryData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.networks_telemetry_) { nullptr }, decltype(_impl_.audio_telemetry_) { nullptr }, decltype(_impl_.peripherals_telemetry_) { nullptr },
        decltype(_impl_.boot_performance_telemetry_) { nullptr }, decltype(_impl_.user_status_telemetry_) { nullptr },
        decltype(_impl_.displays_telemetry_) { nullptr }, decltype(_impl_.app_telemetry_) { nullptr }, decltype(_impl_.fatal_crash_telemetry_) { nullptr },
        decltype(_impl_.runtime_counters_telemetry_) { nullptr }, decltype(_impl_.website_telemetry_) { nullptr },
        decltype(_impl_.heartbeat_telemetry_) { nullptr }, decltype(_impl_.kiosk_vision_telemetry_) { nullptr },
        decltype(_impl_.kiosk_vision_status_) { nullptr }, decltype(_impl_.is_event_driven_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_networks_telemetry()) {
        _this->_impl_.networks_telemetry_ = new ::reporting::NetworksTelemetry(*from._impl_.networks_telemetry_);
    }
    if (from._internal_has_audio_telemetry()) {
        _this->_impl_.audio_telemetry_ = new ::reporting::AudioTelemetry(*from._impl_.audio_telemetry_);
    }
    if (from._internal_has_peripherals_telemetry()) {
        _this->_impl_.peripherals_telemetry_ = new ::reporting::PeripheralsTelemetry(*from._impl_.peripherals_telemetry_);
    }
    if (from._internal_has_boot_performance_telemetry()) {
        _this->_impl_.boot_performance_telemetry_ = new ::reporting::BootPerformanceTelemetry(*from._impl_.boot_performance_telemetry_);
    }
    if (from._internal_has_user_status_telemetry()) {
        _this->_impl_.user_status_telemetry_ = new ::reporting::UserStatusTelemetry(*from._impl_.user_status_telemetry_);
    }
    if (from._internal_has_displays_telemetry()) {
        _this->_impl_.displays_telemetry_ = new ::reporting::DisplaysTelemetry(*from._impl_.displays_telemetry_);
    }
    if (from._internal_has_app_telemetry()) {
        _this->_impl_.app_telemetry_ = new ::reporting::AppTelemetry(*from._impl_.app_telemetry_);
    }
    if (from._internal_has_fatal_crash_telemetry()) {
        _this->_impl_.fatal_crash_telemetry_ = new ::reporting::FatalCrashTelemetry(*from._impl_.fatal_crash_telemetry_);
    }
    if (from._internal_has_runtime_counters_telemetry()) {
        _this->_impl_.runtime_counters_telemetry_ = new ::reporting::RuntimeCountersTelemetry(*from._impl_.runtime_counters_telemetry_);
    }
    if (from._internal_has_website_telemetry()) {
        _this->_impl_.website_telemetry_ = new ::reporting::WebsiteTelemetry(*from._impl_.website_telemetry_);
    }
    if (from._internal_has_heartbeat_telemetry()) {
        _this->_impl_.heartbeat_telemetry_ = new ::reporting::KioskHeartbeatTelemetry(*from._impl_.heartbeat_telemetry_);
    }
    if (from._internal_has_kiosk_vision_telemetry()) {
        _this->_impl_.kiosk_vision_telemetry_ = new ::reporting::KioskVisionTelemetry(*from._impl_.kiosk_vision_telemetry_);
    }
    if (from._internal_has_kiosk_vision_status()) {
        _this->_impl_.kiosk_vision_status_ = new ::reporting::KioskVisionStatusReport(*from._impl_.kiosk_vision_status_);
    }
    _this->_impl_.is_event_driven_ = from._impl_.is_event_driven_;
    // @@protoc_insertion_point(copy_constructor:reporting.TelemetryData)
}

inline void TelemetryData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.networks_telemetry_) { nullptr },
        decltype(_impl_.audio_telemetry_) { nullptr }, decltype(_impl_.peripherals_telemetry_) { nullptr },
        decltype(_impl_.boot_performance_telemetry_) { nullptr }, decltype(_impl_.user_status_telemetry_) { nullptr },
        decltype(_impl_.displays_telemetry_) { nullptr }, decltype(_impl_.app_telemetry_) { nullptr }, decltype(_impl_.fatal_crash_telemetry_) { nullptr },
        decltype(_impl_.runtime_counters_telemetry_) { nullptr }, decltype(_impl_.website_telemetry_) { nullptr },
        decltype(_impl_.heartbeat_telemetry_) { nullptr }, decltype(_impl_.kiosk_vision_telemetry_) { nullptr },
        decltype(_impl_.kiosk_vision_status_) { nullptr }, decltype(_impl_.is_event_driven_) { false } };
}

TelemetryData::~TelemetryData()
{
    // @@protoc_insertion_point(destructor:reporting.TelemetryData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TelemetryData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.networks_telemetry_;
    if (this != internal_default_instance())
        delete _impl_.audio_telemetry_;
    if (this != internal_default_instance())
        delete _impl_.peripherals_telemetry_;
    if (this != internal_default_instance())
        delete _impl_.boot_performance_telemetry_;
    if (this != internal_default_instance())
        delete _impl_.user_status_telemetry_;
    if (this != internal_default_instance())
        delete _impl_.displays_telemetry_;
    if (this != internal_default_instance())
        delete _impl_.app_telemetry_;
    if (this != internal_default_instance())
        delete _impl_.fatal_crash_telemetry_;
    if (this != internal_default_instance())
        delete _impl_.runtime_counters_telemetry_;
    if (this != internal_default_instance())
        delete _impl_.website_telemetry_;
    if (this != internal_default_instance())
        delete _impl_.heartbeat_telemetry_;
    if (this != internal_default_instance())
        delete _impl_.kiosk_vision_telemetry_;
    if (this != internal_default_instance())
        delete _impl_.kiosk_vision_status_;
}

void TelemetryData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TelemetryData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.TelemetryData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.networks_telemetry_ != nullptr);
            _impl_.networks_telemetry_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.audio_telemetry_ != nullptr);
            _impl_.audio_telemetry_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.peripherals_telemetry_ != nullptr);
            _impl_.peripherals_telemetry_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.boot_performance_telemetry_ != nullptr);
            _impl_.boot_performance_telemetry_->Clear();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.user_status_telemetry_ != nullptr);
            _impl_.user_status_telemetry_->Clear();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.displays_telemetry_ != nullptr);
            _impl_.displays_telemetry_->Clear();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.app_telemetry_ != nullptr);
            _impl_.app_telemetry_->Clear();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.fatal_crash_telemetry_ != nullptr);
            _impl_.fatal_crash_telemetry_->Clear();
        }
    }
    if (cached_has_bits & 0x00001f00u) {
        if (cached_has_bits & 0x00000100u) {
            GOOGLE_DCHECK(_impl_.runtime_counters_telemetry_ != nullptr);
            _impl_.runtime_counters_telemetry_->Clear();
        }
        if (cached_has_bits & 0x00000200u) {
            GOOGLE_DCHECK(_impl_.website_telemetry_ != nullptr);
            _impl_.website_telemetry_->Clear();
        }
        if (cached_has_bits & 0x00000400u) {
            GOOGLE_DCHECK(_impl_.heartbeat_telemetry_ != nullptr);
            _impl_.heartbeat_telemetry_->Clear();
        }
        if (cached_has_bits & 0x00000800u) {
            GOOGLE_DCHECK(_impl_.kiosk_vision_telemetry_ != nullptr);
            _impl_.kiosk_vision_telemetry_->Clear();
        }
        if (cached_has_bits & 0x00001000u) {
            GOOGLE_DCHECK(_impl_.kiosk_vision_status_ != nullptr);
            _impl_.kiosk_vision_status_->Clear();
        }
    }
    _impl_.is_event_driven_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* TelemetryData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .reporting.NetworksTelemetry networks_telemetry = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_networks_telemetry(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.AudioTelemetry audio_telemetry = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_audio_telemetry(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.PeripheralsTelemetry peripherals_telemetry = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_peripherals_telemetry(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.BootPerformanceTelemetry boot_performance_telemetry = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_boot_performance_telemetry(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.UserStatusTelemetry user_status_telemetry = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_user_status_telemetry(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.DisplaysTelemetry displays_telemetry = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_displays_telemetry(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.AppTelemetry app_telemetry = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_app_telemetry(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_event_driven = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_is_event_driven(&has_bits);
                _impl_.is_event_driven_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.FatalCrashTelemetry fatal_crash_telemetry = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr = ctx->ParseMessage(_internal_mutable_fatal_crash_telemetry(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.RuntimeCountersTelemetry runtime_counters_telemetry = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr = ctx->ParseMessage(_internal_mutable_runtime_counters_telemetry(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.WebsiteTelemetry website_telemetry = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_website_telemetry(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.KioskHeartbeatTelemetry heartbeat_telemetry = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                ptr = ctx->ParseMessage(_internal_mutable_heartbeat_telemetry(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.KioskVisionTelemetry kiosk_vision_telemetry = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                ptr = ctx->ParseMessage(_internal_mutable_kiosk_vision_telemetry(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.KioskVisionStatusReport kiosk_vision_status = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                ptr = ctx->ParseMessage(_internal_mutable_kiosk_vision_status(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TelemetryData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.TelemetryData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .reporting.NetworksTelemetry networks_telemetry = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::networks_telemetry(this), _Internal::networks_telemetry(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.AudioTelemetry audio_telemetry = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::audio_telemetry(this), _Internal::audio_telemetry(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.PeripheralsTelemetry peripherals_telemetry = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::peripherals_telemetry(this), _Internal::peripherals_telemetry(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.BootPerformanceTelemetry boot_performance_telemetry = 4;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::boot_performance_telemetry(this), _Internal::boot_performance_telemetry(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.UserStatusTelemetry user_status_telemetry = 5;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::user_status_telemetry(this), _Internal::user_status_telemetry(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.DisplaysTelemetry displays_telemetry = 6;
    if (cached_has_bits & 0x00000020u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::displays_telemetry(this), _Internal::displays_telemetry(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.AppTelemetry app_telemetry = 7;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::app_telemetry(this), _Internal::app_telemetry(this).GetCachedSize(), target, stream);
    }

    // optional bool is_event_driven = 8;
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_is_event_driven(), target);
    }

    // optional .reporting.FatalCrashTelemetry fatal_crash_telemetry = 9;
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            9, _Internal::fatal_crash_telemetry(this), _Internal::fatal_crash_telemetry(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.RuntimeCountersTelemetry runtime_counters_telemetry = 10;
    if (cached_has_bits & 0x00000100u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            10, _Internal::runtime_counters_telemetry(this), _Internal::runtime_counters_telemetry(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.WebsiteTelemetry website_telemetry = 11;
    if (cached_has_bits & 0x00000200u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::website_telemetry(this), _Internal::website_telemetry(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.KioskHeartbeatTelemetry heartbeat_telemetry = 12;
    if (cached_has_bits & 0x00000400u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            12, _Internal::heartbeat_telemetry(this), _Internal::heartbeat_telemetry(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.KioskVisionTelemetry kiosk_vision_telemetry = 13;
    if (cached_has_bits & 0x00000800u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            13, _Internal::kiosk_vision_telemetry(this), _Internal::kiosk_vision_telemetry(this).GetCachedSize(), target, stream);
    }

    // optional .reporting.KioskVisionStatusReport kiosk_vision_status = 14;
    if (cached_has_bits & 0x00001000u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            14, _Internal::kiosk_vision_status(this), _Internal::kiosk_vision_status(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.TelemetryData)
    return target;
}

size_t TelemetryData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.TelemetryData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional .reporting.NetworksTelemetry networks_telemetry = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.networks_telemetry_);
        }

        // optional .reporting.AudioTelemetry audio_telemetry = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.audio_telemetry_);
        }

        // optional .reporting.PeripheralsTelemetry peripherals_telemetry = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.peripherals_telemetry_);
        }

        // optional .reporting.BootPerformanceTelemetry boot_performance_telemetry = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.boot_performance_telemetry_);
        }

        // optional .reporting.UserStatusTelemetry user_status_telemetry = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.user_status_telemetry_);
        }

        // optional .reporting.DisplaysTelemetry displays_telemetry = 6;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.displays_telemetry_);
        }

        // optional .reporting.AppTelemetry app_telemetry = 7;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.app_telemetry_);
        }

        // optional .reporting.FatalCrashTelemetry fatal_crash_telemetry = 9;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.fatal_crash_telemetry_);
        }
    }
    if (cached_has_bits & 0x00003f00u) {
        // optional .reporting.RuntimeCountersTelemetry runtime_counters_telemetry = 10;
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.runtime_counters_telemetry_);
        }

        // optional .reporting.WebsiteTelemetry website_telemetry = 11;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.website_telemetry_);
        }

        // optional .reporting.KioskHeartbeatTelemetry heartbeat_telemetry = 12;
        if (cached_has_bits & 0x00000400u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.heartbeat_telemetry_);
        }

        // optional .reporting.KioskVisionTelemetry kiosk_vision_telemetry = 13;
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.kiosk_vision_telemetry_);
        }

        // optional .reporting.KioskVisionStatusReport kiosk_vision_status = 14;
        if (cached_has_bits & 0x00001000u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.kiosk_vision_status_);
        }

        // optional bool is_event_driven = 8;
        if (cached_has_bits & 0x00002000u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TelemetryData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TelemetryData*>(&from));
}

void TelemetryData::MergeFrom(const TelemetryData& from)
{
    TelemetryData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.TelemetryData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_networks_telemetry()->::reporting::NetworksTelemetry::MergeFrom(from._internal_networks_telemetry());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_audio_telemetry()->::reporting::AudioTelemetry::MergeFrom(from._internal_audio_telemetry());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_peripherals_telemetry()->::reporting::PeripheralsTelemetry::MergeFrom(from._internal_peripherals_telemetry());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_boot_performance_telemetry()->::reporting::BootPerformanceTelemetry::MergeFrom(
                from._internal_boot_performance_telemetry());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_user_status_telemetry()->::reporting::UserStatusTelemetry::MergeFrom(from._internal_user_status_telemetry());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_displays_telemetry()->::reporting::DisplaysTelemetry::MergeFrom(from._internal_displays_telemetry());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_app_telemetry()->::reporting::AppTelemetry::MergeFrom(from._internal_app_telemetry());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_fatal_crash_telemetry()->::reporting::FatalCrashTelemetry::MergeFrom(from._internal_fatal_crash_telemetry());
        }
    }
    if (cached_has_bits & 0x00003f00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_mutable_runtime_counters_telemetry()->::reporting::RuntimeCountersTelemetry::MergeFrom(
                from._internal_runtime_counters_telemetry());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_internal_mutable_website_telemetry()->::reporting::WebsiteTelemetry::MergeFrom(from._internal_website_telemetry());
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_internal_mutable_heartbeat_telemetry()->::reporting::KioskHeartbeatTelemetry::MergeFrom(from._internal_heartbeat_telemetry());
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_internal_mutable_kiosk_vision_telemetry()->::reporting::KioskVisionTelemetry::MergeFrom(from._internal_kiosk_vision_telemetry());
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_internal_mutable_kiosk_vision_status()->::reporting::KioskVisionStatusReport::MergeFrom(from._internal_kiosk_vision_status());
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.is_event_driven_ = from._impl_.is_event_driven_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TelemetryData::CopyFrom(const TelemetryData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.TelemetryData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TelemetryData::IsInitialized() const
{
    return true;
}

void TelemetryData::InternalSwap(TelemetryData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(TelemetryData, _impl_.is_event_driven_) + sizeof(TelemetryData::_impl_.is_event_driven_)
        - PROTOBUF_FIELD_OFFSET(TelemetryData, _impl_.networks_telemetry_)>(
        reinterpret_cast<char*>(&_impl_.networks_telemetry_), reinterpret_cast<char*>(&other->_impl_.networks_telemetry_));
}

std::string TelemetryData::GetTypeName() const
{
    return "reporting.TelemetryData";
}

// ===================================================================

class AppTelemetry::_Internal {
public:
    static const ::reporting::AppInstallData& app_install_data(const AppTelemetry* msg);
    static const ::reporting::AppUninstallData& app_uninstall_data(const AppTelemetry* msg);
    static const ::reporting::AppLaunchData& app_launch_data(const AppTelemetry* msg);
    static const ::reporting::AppUsageData& app_usage_data(const AppTelemetry* msg);
};

const ::reporting::AppInstallData& AppTelemetry::_Internal::app_install_data(const AppTelemetry* msg)
{
    return *msg->_impl_.app_metric_data_.app_install_data_;
}
const ::reporting::AppUninstallData& AppTelemetry::_Internal::app_uninstall_data(const AppTelemetry* msg)
{
    return *msg->_impl_.app_metric_data_.app_uninstall_data_;
}
const ::reporting::AppLaunchData& AppTelemetry::_Internal::app_launch_data(const AppTelemetry* msg)
{
    return *msg->_impl_.app_metric_data_.app_launch_data_;
}
const ::reporting::AppUsageData& AppTelemetry::_Internal::app_usage_data(const AppTelemetry* msg)
{
    return *msg->_impl_.app_metric_data_.app_usage_data_;
}
void AppTelemetry::set_allocated_app_install_data(::reporting::AppInstallData* app_install_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_app_metric_data();
    if (app_install_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(app_install_data);
        if (message_arena != submessage_arena) {
            app_install_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, app_install_data, submessage_arena);
        }
        set_has_app_install_data();
        _impl_.app_metric_data_.app_install_data_ = app_install_data;
    }
    // @@protoc_insertion_point(field_set_allocated:reporting.AppTelemetry.app_install_data)
}
void AppTelemetry::set_allocated_app_uninstall_data(::reporting::AppUninstallData* app_uninstall_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_app_metric_data();
    if (app_uninstall_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(app_uninstall_data);
        if (message_arena != submessage_arena) {
            app_uninstall_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, app_uninstall_data, submessage_arena);
        }
        set_has_app_uninstall_data();
        _impl_.app_metric_data_.app_uninstall_data_ = app_uninstall_data;
    }
    // @@protoc_insertion_point(field_set_allocated:reporting.AppTelemetry.app_uninstall_data)
}
void AppTelemetry::set_allocated_app_launch_data(::reporting::AppLaunchData* app_launch_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_app_metric_data();
    if (app_launch_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(app_launch_data);
        if (message_arena != submessage_arena) {
            app_launch_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, app_launch_data, submessage_arena);
        }
        set_has_app_launch_data();
        _impl_.app_metric_data_.app_launch_data_ = app_launch_data;
    }
    // @@protoc_insertion_point(field_set_allocated:reporting.AppTelemetry.app_launch_data)
}
void AppTelemetry::set_allocated_app_usage_data(::reporting::AppUsageData* app_usage_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_app_metric_data();
    if (app_usage_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(app_usage_data);
        if (message_arena != submessage_arena) {
            app_usage_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, app_usage_data, submessage_arena);
        }
        set_has_app_usage_data();
        _impl_.app_metric_data_.app_usage_data_ = app_usage_data;
    }
    // @@protoc_insertion_point(field_set_allocated:reporting.AppTelemetry.app_usage_data)
}
AppTelemetry::AppTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.AppTelemetry)
}
AppTelemetry::AppTelemetry(const AppTelemetry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AppTelemetry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.app_metric_data_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_app_metric_data();
    switch (from.app_metric_data_case()) {
    case kAppInstallData: {
        _this->_internal_mutable_app_install_data()->::reporting::AppInstallData::MergeFrom(from._internal_app_install_data());
        break;
    }
    case kAppUninstallData: {
        _this->_internal_mutable_app_uninstall_data()->::reporting::AppUninstallData::MergeFrom(from._internal_app_uninstall_data());
        break;
    }
    case kAppLaunchData: {
        _this->_internal_mutable_app_launch_data()->::reporting::AppLaunchData::MergeFrom(from._internal_app_launch_data());
        break;
    }
    case kAppUsageData: {
        _this->_internal_mutable_app_usage_data()->::reporting::AppUsageData::MergeFrom(from._internal_app_usage_data());
        break;
    }
    case APP_METRIC_DATA_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:reporting.AppTelemetry)
}

inline void AppTelemetry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.app_metric_data_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_app_metric_data();
}

AppTelemetry::~AppTelemetry()
{
    // @@protoc_insertion_point(destructor:reporting.AppTelemetry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AppTelemetry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_app_metric_data()) {
        clear_app_metric_data();
    }
}

void AppTelemetry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AppTelemetry::clear_app_metric_data()
{
    // @@protoc_insertion_point(one_of_clear_start:reporting.AppTelemetry)
    switch (app_metric_data_case()) {
    case kAppInstallData: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.app_metric_data_.app_install_data_;
        }
        break;
    }
    case kAppUninstallData: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.app_metric_data_.app_uninstall_data_;
        }
        break;
    }
    case kAppLaunchData: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.app_metric_data_.app_launch_data_;
        }
        break;
    }
    case kAppUsageData: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.app_metric_data_.app_usage_data_;
        }
        break;
    }
    case APP_METRIC_DATA_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = APP_METRIC_DATA_NOT_SET;
}

void AppTelemetry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.AppTelemetry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_app_metric_data();
    _internal_metadata_.Clear<std::string>();
}

const char* AppTelemetry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .reporting.AppInstallData app_install_data = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_app_install_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .reporting.AppUninstallData app_uninstall_data = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_app_uninstall_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .reporting.AppLaunchData app_launch_data = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_app_launch_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .reporting.AppUsageData app_usage_data = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_app_usage_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AppTelemetry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.AppTelemetry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (app_metric_data_case()) {
    case kAppInstallData: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::app_install_data(this), _Internal::app_install_data(this).GetCachedSize(), target, stream);
        break;
    }
    case kAppUninstallData: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::app_uninstall_data(this), _Internal::app_uninstall_data(this).GetCachedSize(), target, stream);
        break;
    }
    case kAppLaunchData: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::app_launch_data(this), _Internal::app_launch_data(this).GetCachedSize(), target, stream);
        break;
    }
    case kAppUsageData: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::app_usage_data(this), _Internal::app_usage_data(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.AppTelemetry)
    return target;
}

size_t AppTelemetry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.AppTelemetry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (app_metric_data_case()) {
    // .reporting.AppInstallData app_install_data = 3;
    case kAppInstallData: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.app_metric_data_.app_install_data_);
        break;
    }
    // .reporting.AppUninstallData app_uninstall_data = 4;
    case kAppUninstallData: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.app_metric_data_.app_uninstall_data_);
        break;
    }
    // .reporting.AppLaunchData app_launch_data = 5;
    case kAppLaunchData: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.app_metric_data_.app_launch_data_);
        break;
    }
    // .reporting.AppUsageData app_usage_data = 6;
    case kAppUsageData: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.app_metric_data_.app_usage_data_);
        break;
    }
    case APP_METRIC_DATA_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AppTelemetry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AppTelemetry*>(&from));
}

void AppTelemetry::MergeFrom(const AppTelemetry& from)
{
    AppTelemetry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.AppTelemetry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.app_metric_data_case()) {
    case kAppInstallData: {
        _this->_internal_mutable_app_install_data()->::reporting::AppInstallData::MergeFrom(from._internal_app_install_data());
        break;
    }
    case kAppUninstallData: {
        _this->_internal_mutable_app_uninstall_data()->::reporting::AppUninstallData::MergeFrom(from._internal_app_uninstall_data());
        break;
    }
    case kAppLaunchData: {
        _this->_internal_mutable_app_launch_data()->::reporting::AppLaunchData::MergeFrom(from._internal_app_launch_data());
        break;
    }
    case kAppUsageData: {
        _this->_internal_mutable_app_usage_data()->::reporting::AppUsageData::MergeFrom(from._internal_app_usage_data());
        break;
    }
    case APP_METRIC_DATA_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppTelemetry::CopyFrom(const AppTelemetry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.AppTelemetry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AppTelemetry::IsInitialized() const
{
    return true;
}

void AppTelemetry::InternalSwap(AppTelemetry* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.app_metric_data_, other->_impl_.app_metric_data_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string AppTelemetry::GetTypeName() const
{
    return "reporting.AppTelemetry";
}

// ===================================================================

class AppInstallData::_Internal {
public:
    using HasBits = decltype(std::declval<AppInstallData>()._impl_._has_bits_);
    static void set_has_app_install_source(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_app_install_reason(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_app_install_time(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_app_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_app_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

AppInstallData::AppInstallData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.AppInstallData)
}
AppInstallData::AppInstallData(const AppInstallData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AppInstallData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.app_id_) {},
        decltype(_impl_.app_install_source_) {}, decltype(_impl_.app_install_reason_) {}, decltype(_impl_.app_install_time_) {},
        decltype(_impl_.app_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.app_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_app_id()) {
        _this->_impl_.app_id_.Set(from._internal_app_id(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.app_install_source_, &from._impl_.app_install_source_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.app_type_) - reinterpret_cast<char*>(&_impl_.app_install_source_)) + sizeof(_impl_.app_type_));
    // @@protoc_insertion_point(copy_constructor:reporting.AppInstallData)
}

inline void AppInstallData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.app_id_) {}, decltype(_impl_.app_install_source_) { 0 },
            decltype(_impl_.app_install_reason_) { 0 }, decltype(_impl_.app_install_time_) { 0 }, decltype(_impl_.app_type_) { 0 } };
    _impl_.app_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AppInstallData::~AppInstallData()
{
    // @@protoc_insertion_point(destructor:reporting.AppInstallData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AppInstallData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.app_id_.Destroy();
}

void AppInstallData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AppInstallData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.AppInstallData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.app_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x0000001eu) {
        ::memset(&_impl_.app_install_source_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.app_type_) - reinterpret_cast<char*>(&_impl_.app_install_source_)) + sizeof(_impl_.app_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AppInstallData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .apps.ApplicationInstallSource app_install_source = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::apps::ApplicationInstallSource_IsValid(val))) {
                    _internal_set_app_install_source(static_cast<::apps::ApplicationInstallSource>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .apps.ApplicationInstallReason app_install_reason = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::apps::ApplicationInstallReason_IsValid(val))) {
                    _internal_set_app_install_reason(static_cast<::apps::ApplicationInstallReason>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .apps.ApplicationInstallTime app_install_time = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::apps::ApplicationInstallTime_IsValid(val))) {
                    _internal_set_app_install_time(static_cast<::apps::ApplicationInstallTime>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string app_id = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_app_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .apps.ApplicationType app_type = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::apps::ApplicationType_IsValid(val))) {
                    _internal_set_app_type(static_cast<::apps::ApplicationType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AppInstallData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.AppInstallData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .apps.ApplicationInstallSource app_install_source = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_app_install_source(), target);
    }

    // optional .apps.ApplicationInstallReason app_install_reason = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_app_install_reason(), target);
    }

    // optional .apps.ApplicationInstallTime app_install_time = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_app_install_time(), target);
    }

    // optional string app_id = 4;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_app_id(), target);
    }

    // optional .apps.ApplicationType app_type = 5;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_app_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.AppInstallData)
    return target;
}

size_t AppInstallData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.AppInstallData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string app_id = 4;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_app_id());
        }

        // optional .apps.ApplicationInstallSource app_install_source = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_app_install_source());
        }

        // optional .apps.ApplicationInstallReason app_install_reason = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_app_install_reason());
        }

        // optional .apps.ApplicationInstallTime app_install_time = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_app_install_time());
        }

        // optional .apps.ApplicationType app_type = 5;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_app_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AppInstallData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AppInstallData*>(&from));
}

void AppInstallData::MergeFrom(const AppInstallData& from)
{
    AppInstallData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.AppInstallData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_app_id(from._internal_app_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.app_install_source_ = from._impl_.app_install_source_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.app_install_reason_ = from._impl_.app_install_reason_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.app_install_time_ = from._impl_.app_install_time_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.app_type_ = from._impl_.app_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppInstallData::CopyFrom(const AppInstallData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.AppInstallData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AppInstallData::IsInitialized() const
{
    return true;
}

void AppInstallData::InternalSwap(AppInstallData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.app_id_, lhs_arena, &other->_impl_.app_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AppInstallData, _impl_.app_type_) + sizeof(AppInstallData::_impl_.app_type_)
        - PROTOBUF_FIELD_OFFSET(AppInstallData, _impl_.app_install_source_)>(
        reinterpret_cast<char*>(&_impl_.app_install_source_), reinterpret_cast<char*>(&other->_impl_.app_install_source_));
}

std::string AppInstallData::GetTypeName() const
{
    return "reporting.AppInstallData";
}

// ===================================================================

class AppLaunchData::_Internal {
public:
    using HasBits = decltype(std::declval<AppLaunchData>()._impl_._has_bits_);
    static void set_has_app_launch_source(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_app_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_app_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

AppLaunchData::AppLaunchData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.AppLaunchData)
}
AppLaunchData::AppLaunchData(const AppLaunchData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AppLaunchData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.app_id_) {},
        decltype(_impl_.app_launch_source_) {}, decltype(_impl_.app_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.app_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_app_id()) {
        _this->_impl_.app_id_.Set(from._internal_app_id(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.app_launch_source_, &from._impl_.app_launch_source_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.app_type_) - reinterpret_cast<char*>(&_impl_.app_launch_source_)) + sizeof(_impl_.app_type_));
    // @@protoc_insertion_point(copy_constructor:reporting.AppLaunchData)
}

inline void AppLaunchData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.app_id_) {},
        decltype(_impl_.app_launch_source_) { 0 }, decltype(_impl_.app_type_) { 0 } };
    _impl_.app_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AppLaunchData::~AppLaunchData()
{
    // @@protoc_insertion_point(destructor:reporting.AppLaunchData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AppLaunchData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.app_id_.Destroy();
}

void AppLaunchData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AppLaunchData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.AppLaunchData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.app_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.app_launch_source_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.app_type_) - reinterpret_cast<char*>(&_impl_.app_launch_source_)) + sizeof(_impl_.app_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AppLaunchData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .apps.ApplicationLaunchSource app_launch_source = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::apps::ApplicationLaunchSource_IsValid(val))) {
                    _internal_set_app_launch_source(static_cast<::apps::ApplicationLaunchSource>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string app_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_app_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .apps.ApplicationType app_type = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::apps::ApplicationType_IsValid(val))) {
                    _internal_set_app_type(static_cast<::apps::ApplicationType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AppLaunchData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.AppLaunchData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .apps.ApplicationLaunchSource app_launch_source = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_app_launch_source(), target);
    }

    // optional string app_id = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_app_id(), target);
    }

    // optional .apps.ApplicationType app_type = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_app_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.AppLaunchData)
    return target;
}

size_t AppLaunchData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.AppLaunchData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string app_id = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_app_id());
        }

        // optional .apps.ApplicationLaunchSource app_launch_source = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_app_launch_source());
        }

        // optional .apps.ApplicationType app_type = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_app_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AppLaunchData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AppLaunchData*>(&from));
}

void AppLaunchData::MergeFrom(const AppLaunchData& from)
{
    AppLaunchData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.AppLaunchData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_app_id(from._internal_app_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.app_launch_source_ = from._impl_.app_launch_source_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.app_type_ = from._impl_.app_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppLaunchData::CopyFrom(const AppLaunchData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.AppLaunchData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AppLaunchData::IsInitialized() const
{
    return true;
}

void AppLaunchData::InternalSwap(AppLaunchData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.app_id_, lhs_arena, &other->_impl_.app_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AppLaunchData, _impl_.app_type_) + sizeof(AppLaunchData::_impl_.app_type_)
        - PROTOBUF_FIELD_OFFSET(AppLaunchData, _impl_.app_launch_source_)>(
        reinterpret_cast<char*>(&_impl_.app_launch_source_), reinterpret_cast<char*>(&other->_impl_.app_launch_source_));
}

std::string AppLaunchData::GetTypeName() const
{
    return "reporting.AppLaunchData";
}

// ===================================================================

class AppUsageData_AppUsage::_Internal {
public:
    using HasBits = decltype(std::declval<AppUsageData_AppUsage>()._impl_._has_bits_);
    static void set_has_running_time_ms(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_app_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_app_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_app_instance_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

AppUsageData_AppUsage::AppUsageData_AppUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.AppUsageData.AppUsage)
}
AppUsageData_AppUsage::AppUsageData_AppUsage(const AppUsageData_AppUsage& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AppUsageData_AppUsage* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.app_id_) {},
        decltype(_impl_.app_instance_id_) {}, decltype(_impl_.running_time_ms_) {}, decltype(_impl_.app_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.app_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_app_id()) {
        _this->_impl_.app_id_.Set(from._internal_app_id(), _this->GetArenaForAllocation());
    }
    _impl_.app_instance_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_instance_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_app_instance_id()) {
        _this->_impl_.app_instance_id_.Set(from._internal_app_instance_id(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.running_time_ms_, &from._impl_.running_time_ms_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.app_type_) - reinterpret_cast<char*>(&_impl_.running_time_ms_)) + sizeof(_impl_.app_type_));
    // @@protoc_insertion_point(copy_constructor:reporting.AppUsageData.AppUsage)
}

inline void AppUsageData_AppUsage::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.app_id_) {},
        decltype(_impl_.app_instance_id_) {}, decltype(_impl_.running_time_ms_) { int64_t { 0 } }, decltype(_impl_.app_type_) { 0 } };
    _impl_.app_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_instance_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_instance_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AppUsageData_AppUsage::~AppUsageData_AppUsage()
{
    // @@protoc_insertion_point(destructor:reporting.AppUsageData.AppUsage)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AppUsageData_AppUsage::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.app_id_.Destroy();
    _impl_.app_instance_id_.Destroy();
}

void AppUsageData_AppUsage::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AppUsageData_AppUsage::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.AppUsageData.AppUsage)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.app_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.app_instance_id_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000000cu) {
        ::memset(&_impl_.running_time_ms_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.app_type_) - reinterpret_cast<char*>(&_impl_.running_time_ms_)) + sizeof(_impl_.app_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AppUsageData_AppUsage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 running_time_ms = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_running_time_ms(&has_bits);
                _impl_.running_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string app_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_app_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .apps.ApplicationType app_type = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::apps::ApplicationType_IsValid(val))) {
                    _internal_set_app_type(static_cast<::apps::ApplicationType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string app_instance_id = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_app_instance_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AppUsageData_AppUsage::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.AppUsageData.AppUsage)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 running_time_ms = 1;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_running_time_ms(), target);
    }

    // optional string app_id = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_app_id(), target);
    }

    // optional .apps.ApplicationType app_type = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_app_type(), target);
    }

    // optional string app_instance_id = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_app_instance_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.AppUsageData.AppUsage)
    return target;
}

size_t AppUsageData_AppUsage::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.AppUsageData.AppUsage)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string app_id = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_app_id());
        }

        // optional string app_instance_id = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_app_instance_id());
        }

        // optional int64 running_time_ms = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_running_time_ms());
        }

        // optional .apps.ApplicationType app_type = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_app_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AppUsageData_AppUsage::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AppUsageData_AppUsage*>(&from));
}

void AppUsageData_AppUsage::MergeFrom(const AppUsageData_AppUsage& from)
{
    AppUsageData_AppUsage* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.AppUsageData.AppUsage)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_app_id(from._internal_app_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_app_instance_id(from._internal_app_instance_id());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.running_time_ms_ = from._impl_.running_time_ms_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.app_type_ = from._impl_.app_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppUsageData_AppUsage::CopyFrom(const AppUsageData_AppUsage& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.AppUsageData.AppUsage)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AppUsageData_AppUsage::IsInitialized() const
{
    return true;
}

void AppUsageData_AppUsage::InternalSwap(AppUsageData_AppUsage* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.app_id_, lhs_arena, &other->_impl_.app_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.app_instance_id_, lhs_arena, &other->_impl_.app_instance_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AppUsageData_AppUsage, _impl_.app_type_) + sizeof(AppUsageData_AppUsage::_impl_.app_type_)
        - PROTOBUF_FIELD_OFFSET(AppUsageData_AppUsage, _impl_.running_time_ms_)>(
        reinterpret_cast<char*>(&_impl_.running_time_ms_), reinterpret_cast<char*>(&other->_impl_.running_time_ms_));
}

std::string AppUsageData_AppUsage::GetTypeName() const
{
    return "reporting.AppUsageData.AppUsage";
}

// ===================================================================

class AppUsageData::_Internal {
public:
};

AppUsageData::AppUsageData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.AppUsageData)
}
AppUsageData::AppUsageData(const AppUsageData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AppUsageData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.app_usage_) { from._impl_.app_usage_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:reporting.AppUsageData)
}

inline void AppUsageData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.app_usage_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

AppUsageData::~AppUsageData()
{
    // @@protoc_insertion_point(destructor:reporting.AppUsageData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AppUsageData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.app_usage_.~RepeatedPtrField();
}

void AppUsageData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AppUsageData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.AppUsageData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.app_usage_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AppUsageData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .reporting.AppUsageData.AppUsage app_usage = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_app_usage(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AppUsageData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.AppUsageData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .reporting.AppUsageData.AppUsage app_usage = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_app_usage_size()); i < n; i++) {
        const auto& repfield = this->_internal_app_usage(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.AppUsageData)
    return target;
}

size_t AppUsageData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.AppUsageData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .reporting.AppUsageData.AppUsage app_usage = 2;
    total_size += 1UL * this->_internal_app_usage_size();
    for (const auto& msg : this->_impl_.app_usage_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AppUsageData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AppUsageData*>(&from));
}

void AppUsageData::MergeFrom(const AppUsageData& from)
{
    AppUsageData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.AppUsageData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.app_usage_.MergeFrom(from._impl_.app_usage_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppUsageData::CopyFrom(const AppUsageData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.AppUsageData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AppUsageData::IsInitialized() const
{
    return true;
}

void AppUsageData::InternalSwap(AppUsageData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.app_usage_.InternalSwap(&other->_impl_.app_usage_);
}

std::string AppUsageData::GetTypeName() const
{
    return "reporting.AppUsageData";
}

// ===================================================================

class AppUninstallData::_Internal {
public:
    using HasBits = decltype(std::declval<AppUninstallData>()._impl_._has_bits_);
    static void set_has_app_uninstall_source(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_app_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_app_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

AppUninstallData::AppUninstallData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.AppUninstallData)
}
AppUninstallData::AppUninstallData(const AppUninstallData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AppUninstallData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.app_id_) {},
        decltype(_impl_.app_uninstall_source_) {}, decltype(_impl_.app_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.app_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_app_id()) {
        _this->_impl_.app_id_.Set(from._internal_app_id(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.app_uninstall_source_, &from._impl_.app_uninstall_source_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.app_type_) - reinterpret_cast<char*>(&_impl_.app_uninstall_source_)) + sizeof(_impl_.app_type_));
    // @@protoc_insertion_point(copy_constructor:reporting.AppUninstallData)
}

inline void AppUninstallData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.app_id_) {},
        decltype(_impl_.app_uninstall_source_) { 0 }, decltype(_impl_.app_type_) { 0 } };
    _impl_.app_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.app_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AppUninstallData::~AppUninstallData()
{
    // @@protoc_insertion_point(destructor:reporting.AppUninstallData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AppUninstallData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.app_id_.Destroy();
}

void AppUninstallData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AppUninstallData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.AppUninstallData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.app_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.app_uninstall_source_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.app_type_) - reinterpret_cast<char*>(&_impl_.app_uninstall_source_))
                + sizeof(_impl_.app_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AppUninstallData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .apps.ApplicationUninstallSource app_uninstall_source = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::apps::ApplicationUninstallSource_IsValid(val))) {
                    _internal_set_app_uninstall_source(static_cast<::apps::ApplicationUninstallSource>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string app_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_app_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .apps.ApplicationType app_type = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::apps::ApplicationType_IsValid(val))) {
                    _internal_set_app_type(static_cast<::apps::ApplicationType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AppUninstallData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.AppUninstallData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .apps.ApplicationUninstallSource app_uninstall_source = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_app_uninstall_source(), target);
    }

    // optional string app_id = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_app_id(), target);
    }

    // optional .apps.ApplicationType app_type = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_app_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.AppUninstallData)
    return target;
}

size_t AppUninstallData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.AppUninstallData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string app_id = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_app_id());
        }

        // optional .apps.ApplicationUninstallSource app_uninstall_source = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_app_uninstall_source());
        }

        // optional .apps.ApplicationType app_type = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_app_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AppUninstallData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AppUninstallData*>(&from));
}

void AppUninstallData::MergeFrom(const AppUninstallData& from)
{
    AppUninstallData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.AppUninstallData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_app_id(from._internal_app_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.app_uninstall_source_ = from._impl_.app_uninstall_source_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.app_type_ = from._impl_.app_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AppUninstallData::CopyFrom(const AppUninstallData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.AppUninstallData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AppUninstallData::IsInitialized() const
{
    return true;
}

void AppUninstallData::InternalSwap(AppUninstallData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.app_id_, lhs_arena, &other->_impl_.app_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AppUninstallData, _impl_.app_type_) + sizeof(AppUninstallData::_impl_.app_type_)
        - PROTOBUF_FIELD_OFFSET(AppUninstallData, _impl_.app_uninstall_source_)>(
        reinterpret_cast<char*>(&_impl_.app_uninstall_source_), reinterpret_cast<char*>(&other->_impl_.app_uninstall_source_));
}

std::string AppUninstallData::GetTypeName() const
{
    return "reporting.AppUninstallData";
}

// ===================================================================

class WebsiteTelemetry::_Internal {
public:
    static const ::reporting::WebsiteOpenedData& website_opened_data(const WebsiteTelemetry* msg);
    static const ::reporting::WebsiteClosedData& website_closed_data(const WebsiteTelemetry* msg);
    static const ::reporting::WebsiteUsageData& website_usage_data(const WebsiteTelemetry* msg);
};

const ::reporting::WebsiteOpenedData& WebsiteTelemetry::_Internal::website_opened_data(const WebsiteTelemetry* msg)
{
    return *msg->_impl_.website_metric_data_.website_opened_data_;
}
const ::reporting::WebsiteClosedData& WebsiteTelemetry::_Internal::website_closed_data(const WebsiteTelemetry* msg)
{
    return *msg->_impl_.website_metric_data_.website_closed_data_;
}
const ::reporting::WebsiteUsageData& WebsiteTelemetry::_Internal::website_usage_data(const WebsiteTelemetry* msg)
{
    return *msg->_impl_.website_metric_data_.website_usage_data_;
}
void WebsiteTelemetry::set_allocated_website_opened_data(::reporting::WebsiteOpenedData* website_opened_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_website_metric_data();
    if (website_opened_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(website_opened_data);
        if (message_arena != submessage_arena) {
            website_opened_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, website_opened_data, submessage_arena);
        }
        set_has_website_opened_data();
        _impl_.website_metric_data_.website_opened_data_ = website_opened_data;
    }
    // @@protoc_insertion_point(field_set_allocated:reporting.WebsiteTelemetry.website_opened_data)
}
void WebsiteTelemetry::set_allocated_website_closed_data(::reporting::WebsiteClosedData* website_closed_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_website_metric_data();
    if (website_closed_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(website_closed_data);
        if (message_arena != submessage_arena) {
            website_closed_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, website_closed_data, submessage_arena);
        }
        set_has_website_closed_data();
        _impl_.website_metric_data_.website_closed_data_ = website_closed_data;
    }
    // @@protoc_insertion_point(field_set_allocated:reporting.WebsiteTelemetry.website_closed_data)
}
void WebsiteTelemetry::set_allocated_website_usage_data(::reporting::WebsiteUsageData* website_usage_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_website_metric_data();
    if (website_usage_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(website_usage_data);
        if (message_arena != submessage_arena) {
            website_usage_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, website_usage_data, submessage_arena);
        }
        set_has_website_usage_data();
        _impl_.website_metric_data_.website_usage_data_ = website_usage_data;
    }
    // @@protoc_insertion_point(field_set_allocated:reporting.WebsiteTelemetry.website_usage_data)
}
WebsiteTelemetry::WebsiteTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.WebsiteTelemetry)
}
WebsiteTelemetry::WebsiteTelemetry(const WebsiteTelemetry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WebsiteTelemetry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.website_metric_data_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_website_metric_data();
    switch (from.website_metric_data_case()) {
    case kWebsiteOpenedData: {
        _this->_internal_mutable_website_opened_data()->::reporting::WebsiteOpenedData::MergeFrom(from._internal_website_opened_data());
        break;
    }
    case kWebsiteClosedData: {
        _this->_internal_mutable_website_closed_data()->::reporting::WebsiteClosedData::MergeFrom(from._internal_website_closed_data());
        break;
    }
    case kWebsiteUsageData: {
        _this->_internal_mutable_website_usage_data()->::reporting::WebsiteUsageData::MergeFrom(from._internal_website_usage_data());
        break;
    }
    case WEBSITE_METRIC_DATA_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:reporting.WebsiteTelemetry)
}

inline void WebsiteTelemetry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.website_metric_data_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_website_metric_data();
}

WebsiteTelemetry::~WebsiteTelemetry()
{
    // @@protoc_insertion_point(destructor:reporting.WebsiteTelemetry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WebsiteTelemetry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_website_metric_data()) {
        clear_website_metric_data();
    }
}

void WebsiteTelemetry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WebsiteTelemetry::clear_website_metric_data()
{
    // @@protoc_insertion_point(one_of_clear_start:reporting.WebsiteTelemetry)
    switch (website_metric_data_case()) {
    case kWebsiteOpenedData: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.website_metric_data_.website_opened_data_;
        }
        break;
    }
    case kWebsiteClosedData: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.website_metric_data_.website_closed_data_;
        }
        break;
    }
    case kWebsiteUsageData: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.website_metric_data_.website_usage_data_;
        }
        break;
    }
    case WEBSITE_METRIC_DATA_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = WEBSITE_METRIC_DATA_NOT_SET;
}

void WebsiteTelemetry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.WebsiteTelemetry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_website_metric_data();
    _internal_metadata_.Clear<std::string>();
}

const char* WebsiteTelemetry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .reporting.WebsiteOpenedData website_opened_data = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_website_opened_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .reporting.WebsiteClosedData website_closed_data = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_website_closed_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .reporting.WebsiteUsageData website_usage_data = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_website_usage_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WebsiteTelemetry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.WebsiteTelemetry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (website_metric_data_case()) {
    case kWebsiteOpenedData: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::website_opened_data(this), _Internal::website_opened_data(this).GetCachedSize(), target, stream);
        break;
    }
    case kWebsiteClosedData: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::website_closed_data(this), _Internal::website_closed_data(this).GetCachedSize(), target, stream);
        break;
    }
    case kWebsiteUsageData: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::website_usage_data(this), _Internal::website_usage_data(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.WebsiteTelemetry)
    return target;
}

size_t WebsiteTelemetry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.WebsiteTelemetry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (website_metric_data_case()) {
    // .reporting.WebsiteOpenedData website_opened_data = 1;
    case kWebsiteOpenedData: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.website_metric_data_.website_opened_data_);
        break;
    }
    // .reporting.WebsiteClosedData website_closed_data = 2;
    case kWebsiteClosedData: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.website_metric_data_.website_closed_data_);
        break;
    }
    // .reporting.WebsiteUsageData website_usage_data = 3;
    case kWebsiteUsageData: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.website_metric_data_.website_usage_data_);
        break;
    }
    case WEBSITE_METRIC_DATA_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WebsiteTelemetry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WebsiteTelemetry*>(&from));
}

void WebsiteTelemetry::MergeFrom(const WebsiteTelemetry& from)
{
    WebsiteTelemetry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.WebsiteTelemetry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.website_metric_data_case()) {
    case kWebsiteOpenedData: {
        _this->_internal_mutable_website_opened_data()->::reporting::WebsiteOpenedData::MergeFrom(from._internal_website_opened_data());
        break;
    }
    case kWebsiteClosedData: {
        _this->_internal_mutable_website_closed_data()->::reporting::WebsiteClosedData::MergeFrom(from._internal_website_closed_data());
        break;
    }
    case kWebsiteUsageData: {
        _this->_internal_mutable_website_usage_data()->::reporting::WebsiteUsageData::MergeFrom(from._internal_website_usage_data());
        break;
    }
    case WEBSITE_METRIC_DATA_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WebsiteTelemetry::CopyFrom(const WebsiteTelemetry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.WebsiteTelemetry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WebsiteTelemetry::IsInitialized() const
{
    return true;
}

void WebsiteTelemetry::InternalSwap(WebsiteTelemetry* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.website_metric_data_, other->_impl_.website_metric_data_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string WebsiteTelemetry::GetTypeName() const
{
    return "reporting.WebsiteTelemetry";
}

// ===================================================================

class WebsiteOpenedData::_Internal {
public:
    using HasBits = decltype(std::declval<WebsiteOpenedData>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_render_process_host_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_render_frame_routing_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

WebsiteOpenedData::WebsiteOpenedData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.WebsiteOpenedData)
}
WebsiteOpenedData::WebsiteOpenedData(const WebsiteOpenedData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WebsiteOpenedData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {},
        decltype(_impl_.render_process_host_id_) {}, decltype(_impl_.render_frame_routing_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.render_process_host_id_, &from._impl_.render_process_host_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.render_frame_routing_id_) - reinterpret_cast<char*>(&_impl_.render_process_host_id_))
            + sizeof(_impl_.render_frame_routing_id_));
    // @@protoc_insertion_point(copy_constructor:reporting.WebsiteOpenedData)
}

inline void WebsiteOpenedData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {},
        decltype(_impl_.render_process_host_id_) { 0 }, decltype(_impl_.render_frame_routing_id_) { 0 } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WebsiteOpenedData::~WebsiteOpenedData()
{
    // @@protoc_insertion_point(destructor:reporting.WebsiteOpenedData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WebsiteOpenedData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
}

void WebsiteOpenedData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WebsiteOpenedData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.WebsiteOpenedData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.render_process_host_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.render_frame_routing_id_) - reinterpret_cast<char*>(&_impl_.render_process_host_id_))
                + sizeof(_impl_.render_frame_routing_id_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WebsiteOpenedData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 render_process_host_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_render_process_host_id(&has_bits);
                _impl_.render_process_host_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 render_frame_routing_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_render_frame_routing_id(&has_bits);
                _impl_.render_frame_routing_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WebsiteOpenedData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.WebsiteOpenedData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // optional int32 render_process_host_id = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_render_process_host_id(), target);
    }

    // optional int32 render_frame_routing_id = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_render_frame_routing_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.WebsiteOpenedData)
    return target;
}

size_t WebsiteOpenedData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.WebsiteOpenedData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional int32 render_process_host_id = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_render_process_host_id());
        }

        // optional int32 render_frame_routing_id = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_render_frame_routing_id());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WebsiteOpenedData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WebsiteOpenedData*>(&from));
}

void WebsiteOpenedData::MergeFrom(const WebsiteOpenedData& from)
{
    WebsiteOpenedData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.WebsiteOpenedData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.render_process_host_id_ = from._impl_.render_process_host_id_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.render_frame_routing_id_ = from._impl_.render_frame_routing_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WebsiteOpenedData::CopyFrom(const WebsiteOpenedData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.WebsiteOpenedData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WebsiteOpenedData::IsInitialized() const
{
    return true;
}

void WebsiteOpenedData::InternalSwap(WebsiteOpenedData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(WebsiteOpenedData, _impl_.render_frame_routing_id_)
        + sizeof(WebsiteOpenedData::_impl_.render_frame_routing_id_) - PROTOBUF_FIELD_OFFSET(WebsiteOpenedData, _impl_.render_process_host_id_)>(
        reinterpret_cast<char*>(&_impl_.render_process_host_id_), reinterpret_cast<char*>(&other->_impl_.render_process_host_id_));
}

std::string WebsiteOpenedData::GetTypeName() const
{
    return "reporting.WebsiteOpenedData";
}

// ===================================================================

class WebsiteClosedData::_Internal {
public:
    using HasBits = decltype(std::declval<WebsiteClosedData>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_render_process_host_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_render_frame_routing_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

WebsiteClosedData::WebsiteClosedData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.WebsiteClosedData)
}
WebsiteClosedData::WebsiteClosedData(const WebsiteClosedData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WebsiteClosedData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {},
        decltype(_impl_.render_process_host_id_) {}, decltype(_impl_.render_frame_routing_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.render_process_host_id_, &from._impl_.render_process_host_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.render_frame_routing_id_) - reinterpret_cast<char*>(&_impl_.render_process_host_id_))
            + sizeof(_impl_.render_frame_routing_id_));
    // @@protoc_insertion_point(copy_constructor:reporting.WebsiteClosedData)
}

inline void WebsiteClosedData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {},
        decltype(_impl_.render_process_host_id_) { 0 }, decltype(_impl_.render_frame_routing_id_) { 0 } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WebsiteClosedData::~WebsiteClosedData()
{
    // @@protoc_insertion_point(destructor:reporting.WebsiteClosedData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WebsiteClosedData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
}

void WebsiteClosedData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WebsiteClosedData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.WebsiteClosedData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.render_process_host_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.render_frame_routing_id_) - reinterpret_cast<char*>(&_impl_.render_process_host_id_))
                + sizeof(_impl_.render_frame_routing_id_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WebsiteClosedData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 render_process_host_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_render_process_host_id(&has_bits);
                _impl_.render_process_host_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 render_frame_routing_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_render_frame_routing_id(&has_bits);
                _impl_.render_frame_routing_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WebsiteClosedData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.WebsiteClosedData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // optional int32 render_process_host_id = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_render_process_host_id(), target);
    }

    // optional int32 render_frame_routing_id = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_render_frame_routing_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.WebsiteClosedData)
    return target;
}

size_t WebsiteClosedData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.WebsiteClosedData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional int32 render_process_host_id = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_render_process_host_id());
        }

        // optional int32 render_frame_routing_id = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_render_frame_routing_id());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WebsiteClosedData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WebsiteClosedData*>(&from));
}

void WebsiteClosedData::MergeFrom(const WebsiteClosedData& from)
{
    WebsiteClosedData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.WebsiteClosedData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.render_process_host_id_ = from._impl_.render_process_host_id_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.render_frame_routing_id_ = from._impl_.render_frame_routing_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WebsiteClosedData::CopyFrom(const WebsiteClosedData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.WebsiteClosedData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WebsiteClosedData::IsInitialized() const
{
    return true;
}

void WebsiteClosedData::InternalSwap(WebsiteClosedData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(WebsiteClosedData, _impl_.render_frame_routing_id_)
        + sizeof(WebsiteClosedData::_impl_.render_frame_routing_id_) - PROTOBUF_FIELD_OFFSET(WebsiteClosedData, _impl_.render_process_host_id_)>(
        reinterpret_cast<char*>(&_impl_.render_process_host_id_), reinterpret_cast<char*>(&other->_impl_.render_process_host_id_));
}

std::string WebsiteClosedData::GetTypeName() const
{
    return "reporting.WebsiteClosedData";
}

// ===================================================================

class WebsiteUsageData_WebsiteUsage::_Internal {
public:
    using HasBits = decltype(std::declval<WebsiteUsageData_WebsiteUsage>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_running_time_ms(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

WebsiteUsageData_WebsiteUsage::WebsiteUsageData_WebsiteUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.WebsiteUsageData.WebsiteUsage)
}
WebsiteUsageData_WebsiteUsage::WebsiteUsageData_WebsiteUsage(const WebsiteUsageData_WebsiteUsage& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WebsiteUsageData_WebsiteUsage* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {},
        decltype(_impl_.running_time_ms_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    _this->_impl_.running_time_ms_ = from._impl_.running_time_ms_;
    // @@protoc_insertion_point(copy_constructor:reporting.WebsiteUsageData.WebsiteUsage)
}

inline void WebsiteUsageData_WebsiteUsage::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {},
        decltype(_impl_.running_time_ms_) { int64_t { 0 } } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WebsiteUsageData_WebsiteUsage::~WebsiteUsageData_WebsiteUsage()
{
    // @@protoc_insertion_point(destructor:reporting.WebsiteUsageData.WebsiteUsage)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WebsiteUsageData_WebsiteUsage::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
}

void WebsiteUsageData_WebsiteUsage::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WebsiteUsageData_WebsiteUsage::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.WebsiteUsageData.WebsiteUsage)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.url_.ClearNonDefaultToEmpty();
    }
    _impl_.running_time_ms_ = int64_t { 0 };
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WebsiteUsageData_WebsiteUsage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 running_time_ms = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_running_time_ms(&has_bits);
                _impl_.running_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WebsiteUsageData_WebsiteUsage::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.WebsiteUsageData.WebsiteUsage)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // optional int64 running_time_ms = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_running_time_ms(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.WebsiteUsageData.WebsiteUsage)
    return target;
}

size_t WebsiteUsageData_WebsiteUsage::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.WebsiteUsageData.WebsiteUsage)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional int64 running_time_ms = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_running_time_ms());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WebsiteUsageData_WebsiteUsage::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WebsiteUsageData_WebsiteUsage*>(&from));
}

void WebsiteUsageData_WebsiteUsage::MergeFrom(const WebsiteUsageData_WebsiteUsage& from)
{
    WebsiteUsageData_WebsiteUsage* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.WebsiteUsageData.WebsiteUsage)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.running_time_ms_ = from._impl_.running_time_ms_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WebsiteUsageData_WebsiteUsage::CopyFrom(const WebsiteUsageData_WebsiteUsage& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.WebsiteUsageData.WebsiteUsage)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WebsiteUsageData_WebsiteUsage::IsInitialized() const
{
    return true;
}

void WebsiteUsageData_WebsiteUsage::InternalSwap(WebsiteUsageData_WebsiteUsage* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    swap(_impl_.running_time_ms_, other->_impl_.running_time_ms_);
}

std::string WebsiteUsageData_WebsiteUsage::GetTypeName() const
{
    return "reporting.WebsiteUsageData.WebsiteUsage";
}

// ===================================================================

class WebsiteUsageData::_Internal {
public:
};

WebsiteUsageData::WebsiteUsageData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.WebsiteUsageData)
}
WebsiteUsageData::WebsiteUsageData(const WebsiteUsageData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WebsiteUsageData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.website_usage_) { from._impl_.website_usage_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:reporting.WebsiteUsageData)
}

inline void WebsiteUsageData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.website_usage_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

WebsiteUsageData::~WebsiteUsageData()
{
    // @@protoc_insertion_point(destructor:reporting.WebsiteUsageData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WebsiteUsageData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.website_usage_.~RepeatedPtrField();
}

void WebsiteUsageData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WebsiteUsageData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.WebsiteUsageData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.website_usage_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WebsiteUsageData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .reporting.WebsiteUsageData.WebsiteUsage website_usage = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_website_usage(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WebsiteUsageData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.WebsiteUsageData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .reporting.WebsiteUsageData.WebsiteUsage website_usage = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_website_usage_size()); i < n; i++) {
        const auto& repfield = this->_internal_website_usage(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.WebsiteUsageData)
    return target;
}

size_t WebsiteUsageData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.WebsiteUsageData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .reporting.WebsiteUsageData.WebsiteUsage website_usage = 3;
    total_size += 1UL * this->_internal_website_usage_size();
    for (const auto& msg : this->_impl_.website_usage_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WebsiteUsageData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WebsiteUsageData*>(&from));
}

void WebsiteUsageData::MergeFrom(const WebsiteUsageData& from)
{
    WebsiteUsageData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.WebsiteUsageData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.website_usage_.MergeFrom(from._impl_.website_usage_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WebsiteUsageData::CopyFrom(const WebsiteUsageData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.WebsiteUsageData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WebsiteUsageData::IsInitialized() const
{
    return true;
}

void WebsiteUsageData::InternalSwap(WebsiteUsageData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.website_usage_.InternalSwap(&other->_impl_.website_usage_);
}

std::string WebsiteUsageData::GetTypeName() const
{
    return "reporting.WebsiteUsageData";
}

// ===================================================================

class PeripheralsTelemetry::_Internal {
public:
};

PeripheralsTelemetry::PeripheralsTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.PeripheralsTelemetry)
}
PeripheralsTelemetry::PeripheralsTelemetry(const PeripheralsTelemetry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PeripheralsTelemetry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.usb_telemetry_) { from._impl_.usb_telemetry_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:reporting.PeripheralsTelemetry)
}

inline void PeripheralsTelemetry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.usb_telemetry_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

PeripheralsTelemetry::~PeripheralsTelemetry()
{
    // @@protoc_insertion_point(destructor:reporting.PeripheralsTelemetry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PeripheralsTelemetry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.usb_telemetry_.~RepeatedPtrField();
}

void PeripheralsTelemetry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PeripheralsTelemetry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.PeripheralsTelemetry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.usb_telemetry_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PeripheralsTelemetry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .reporting.UsbTelemetry usb_telemetry = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_usb_telemetry(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PeripheralsTelemetry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.PeripheralsTelemetry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .reporting.UsbTelemetry usb_telemetry = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_usb_telemetry_size()); i < n; i++) {
        const auto& repfield = this->_internal_usb_telemetry(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.PeripheralsTelemetry)
    return target;
}

size_t PeripheralsTelemetry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.PeripheralsTelemetry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .reporting.UsbTelemetry usb_telemetry = 1;
    total_size += 1UL * this->_internal_usb_telemetry_size();
    for (const auto& msg : this->_impl_.usb_telemetry_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PeripheralsTelemetry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PeripheralsTelemetry*>(&from));
}

void PeripheralsTelemetry::MergeFrom(const PeripheralsTelemetry& from)
{
    PeripheralsTelemetry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.PeripheralsTelemetry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.usb_telemetry_.MergeFrom(from._impl_.usb_telemetry_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PeripheralsTelemetry::CopyFrom(const PeripheralsTelemetry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.PeripheralsTelemetry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PeripheralsTelemetry::IsInitialized() const
{
    return true;
}

void PeripheralsTelemetry::InternalSwap(PeripheralsTelemetry* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.usb_telemetry_.InternalSwap(&other->_impl_.usb_telemetry_);
}

std::string PeripheralsTelemetry::GetTypeName() const
{
    return "reporting.PeripheralsTelemetry";
}

// ===================================================================

class UsbTelemetry::_Internal {
public:
    using HasBits = decltype(std::declval<UsbTelemetry>()._impl_._has_bits_);
    static void set_has_vendor(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_vid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_pid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_class_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_subclass_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_firmware_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

UsbTelemetry::UsbTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.UsbTelemetry)
}
UsbTelemetry::UsbTelemetry(const UsbTelemetry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UsbTelemetry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.categories_) { from._impl_.categories_ }, decltype(_impl_.vendor_) {}, decltype(_impl_.name_) {}, decltype(_impl_.firmware_version_) {},
        decltype(_impl_.vid_) {}, decltype(_impl_.pid_) {}, decltype(_impl_.class_id_) {}, decltype(_impl_.subclass_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.vendor_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_vendor()) {
        _this->_impl_.vendor_.Set(from._internal_vendor(), _this->GetArenaForAllocation());
    }
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.firmware_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firmware_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_firmware_version()) {
        _this->_impl_.firmware_version_.Set(from._internal_firmware_version(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.vid_, &from._impl_.vid_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.subclass_id_) - reinterpret_cast<char*>(&_impl_.vid_)) + sizeof(_impl_.subclass_id_));
    // @@protoc_insertion_point(copy_constructor:reporting.UsbTelemetry)
}

inline void UsbTelemetry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.categories_) { arena },
        decltype(_impl_.vendor_) {}, decltype(_impl_.name_) {}, decltype(_impl_.firmware_version_) {}, decltype(_impl_.vid_) { 0 }, decltype(_impl_.pid_) { 0 },
        decltype(_impl_.class_id_) { 0 }, decltype(_impl_.subclass_id_) { 0 } };
    _impl_.vendor_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vendor_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firmware_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.firmware_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UsbTelemetry::~UsbTelemetry()
{
    // @@protoc_insertion_point(destructor:reporting.UsbTelemetry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UsbTelemetry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.categories_.~RepeatedPtrField();
    _impl_.vendor_.Destroy();
    _impl_.name_.Destroy();
    _impl_.firmware_version_.Destroy();
}

void UsbTelemetry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UsbTelemetry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.UsbTelemetry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.categories_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.vendor_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.firmware_version_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00000078u) {
        ::memset(&_impl_.vid_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.subclass_id_) - reinterpret_cast<char*>(&_impl_.vid_)) + sizeof(_impl_.subclass_id_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UsbTelemetry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string vendor = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_vendor();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 vid = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_vid(&has_bits);
                _impl_.vid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 pid = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_pid(&has_bits);
                _impl_.pid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string categories = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_categories();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional int32 class_id = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_class_id(&has_bits);
                _impl_.class_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 subclass_id = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_subclass_id(&has_bits);
                _impl_.subclass_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string firmware_version = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_firmware_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UsbTelemetry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.UsbTelemetry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string vendor = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_vendor(), target);
    }

    // optional string name = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_name(), target);
    }

    // optional int32 vid = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_vid(), target);
    }

    // optional int32 pid = 4;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_pid(), target);
    }

    // repeated string categories = 5;
    for (int i = 0, n = this->_internal_categories_size(); i < n; i++) {
        const auto& s = this->_internal_categories(i);
        target = stream->WriteString(5, s, target);
    }

    // optional int32 class_id = 6;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_class_id(), target);
    }

    // optional int32 subclass_id = 7;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_subclass_id(), target);
    }

    // optional string firmware_version = 8;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_firmware_version(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.UsbTelemetry)
    return target;
}

size_t UsbTelemetry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.UsbTelemetry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string categories = 5;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.categories_.size());
    for (int i = 0, n = _impl_.categories_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.categories_.Get(i));
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        // optional string vendor = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_vendor());
        }

        // optional string name = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string firmware_version = 8;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_firmware_version());
        }

        // optional int32 vid = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_vid());
        }

        // optional int32 pid = 4;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pid());
        }

        // optional int32 class_id = 6;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_class_id());
        }

        // optional int32 subclass_id = 7;
        if (cached_has_bits & 0x00000040u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_subclass_id());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UsbTelemetry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UsbTelemetry*>(&from));
}

void UsbTelemetry::MergeFrom(const UsbTelemetry& from)
{
    UsbTelemetry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.UsbTelemetry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.categories_.MergeFrom(from._impl_.categories_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_vendor(from._internal_vendor());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_firmware_version(from._internal_firmware_version());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.vid_ = from._impl_.vid_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.pid_ = from._impl_.pid_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.class_id_ = from._impl_.class_id_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.subclass_id_ = from._impl_.subclass_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UsbTelemetry::CopyFrom(const UsbTelemetry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.UsbTelemetry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UsbTelemetry::IsInitialized() const
{
    return true;
}

void UsbTelemetry::InternalSwap(UsbTelemetry* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.categories_.InternalSwap(&other->_impl_.categories_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.vendor_, lhs_arena, &other->_impl_.vendor_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.firmware_version_, lhs_arena, &other->_impl_.firmware_version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(UsbTelemetry, _impl_.subclass_id_) + sizeof(UsbTelemetry::_impl_.subclass_id_)
        - PROTOBUF_FIELD_OFFSET(UsbTelemetry, _impl_.vid_)>(reinterpret_cast<char*>(&_impl_.vid_), reinterpret_cast<char*>(&other->_impl_.vid_));
}

std::string UsbTelemetry::GetTypeName() const
{
    return "reporting.UsbTelemetry";
}

// ===================================================================

class FatalCrashTelemetry::_Internal {
public:
    using HasBits = decltype(std::declval<FatalCrashTelemetry>()._impl_._has_bits_);
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_session_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_timestamp_us(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static const ::reporting::SessionAffiliatedUser& affiliated_user(const FatalCrashTelemetry* msg);
    static void set_has_affiliated_user(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_crash_report_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_local_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_been_reported_without_crash_report_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_event_based_log_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::reporting::SessionAffiliatedUser& FatalCrashTelemetry::_Internal::affiliated_user(const FatalCrashTelemetry* msg)
{
    return *msg->_impl_.affiliated_user_;
}
void FatalCrashTelemetry::clear_affiliated_user()
{
    if (_impl_.affiliated_user_ != nullptr)
        _impl_.affiliated_user_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
FatalCrashTelemetry::FatalCrashTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.FatalCrashTelemetry)
}
FatalCrashTelemetry::FatalCrashTelemetry(const FatalCrashTelemetry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    FatalCrashTelemetry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.crash_report_id_) {},
        decltype(_impl_.local_id_) {}, decltype(_impl_.event_based_log_id_) {}, decltype(_impl_.affiliated_user_) { nullptr }, decltype(_impl_.type_) {},
        decltype(_impl_.session_type_) {}, decltype(_impl_.timestamp_us_) {}, decltype(_impl_.been_reported_without_crash_report_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.crash_report_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.crash_report_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_crash_report_id()) {
        _this->_impl_.crash_report_id_.Set(from._internal_crash_report_id(), _this->GetArenaForAllocation());
    }
    _impl_.local_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.local_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_local_id()) {
        _this->_impl_.local_id_.Set(from._internal_local_id(), _this->GetArenaForAllocation());
    }
    _impl_.event_based_log_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.event_based_log_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_event_based_log_id()) {
        _this->_impl_.event_based_log_id_.Set(from._internal_event_based_log_id(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_affiliated_user()) {
        _this->_impl_.affiliated_user_ = new ::reporting::SessionAffiliatedUser(*from._impl_.affiliated_user_);
    }
    ::memcpy(&_impl_.type_, &from._impl_.type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.been_reported_without_crash_report_id_) - reinterpret_cast<char*>(&_impl_.type_))
            + sizeof(_impl_.been_reported_without_crash_report_id_));
    // @@protoc_insertion_point(copy_constructor:reporting.FatalCrashTelemetry)
}

inline void FatalCrashTelemetry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.crash_report_id_) {},
        decltype(_impl_.local_id_) {}, decltype(_impl_.event_based_log_id_) {}, decltype(_impl_.affiliated_user_) { nullptr }, decltype(_impl_.type_) { 0 },
        decltype(_impl_.session_type_) { 0 }, decltype(_impl_.timestamp_us_) { int64_t { 0 } },
        decltype(_impl_.been_reported_without_crash_report_id_) { false } };
    _impl_.crash_report_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.crash_report_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.local_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.local_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.event_based_log_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.event_based_log_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FatalCrashTelemetry::~FatalCrashTelemetry()
{
    // @@protoc_insertion_point(destructor:reporting.FatalCrashTelemetry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void FatalCrashTelemetry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.crash_report_id_.Destroy();
    _impl_.local_id_.Destroy();
    _impl_.event_based_log_id_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.affiliated_user_;
}

void FatalCrashTelemetry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void FatalCrashTelemetry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.FatalCrashTelemetry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.crash_report_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.local_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.event_based_log_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.affiliated_user_ != nullptr);
            _impl_.affiliated_user_->Clear();
        }
    }
    if (cached_has_bits & 0x000000f0u) {
        ::memset(&_impl_.type_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.been_reported_without_crash_report_id_) - reinterpret_cast<char*>(&_impl_.type_))
                + sizeof(_impl_.been_reported_without_crash_report_id_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* FatalCrashTelemetry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .reporting.FatalCrashTelemetry.CrashType type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::reporting::FatalCrashTelemetry_CrashType_IsValid(val))) {
                    _internal_set_type(static_cast<::reporting::FatalCrashTelemetry_CrashType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.FatalCrashTelemetry.SessionType session_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::reporting::FatalCrashTelemetry_SessionType_IsValid(val))) {
                    _internal_set_session_type(static_cast<::reporting::FatalCrashTelemetry_SessionType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 timestamp_us = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_timestamp_us(&has_bits);
                _impl_.timestamp_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.SessionAffiliatedUser affiliated_user = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_affiliated_user(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string crash_report_id = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_crash_report_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string local_id = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_local_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool been_reported_without_crash_report_id = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_been_reported_without_crash_report_id(&has_bits);
                _impl_.been_reported_without_crash_report_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string event_based_log_id = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_event_based_log_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* FatalCrashTelemetry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.FatalCrashTelemetry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .reporting.FatalCrashTelemetry.CrashType type = 1;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_type(), target);
    }

    // optional .reporting.FatalCrashTelemetry.SessionType session_type = 2;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_session_type(), target);
    }

    // optional int64 timestamp_us = 3;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_timestamp_us(), target);
    }

    // optional .reporting.SessionAffiliatedUser affiliated_user = 4;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::affiliated_user(this), _Internal::affiliated_user(this).GetCachedSize(), target, stream);
    }

    // optional string crash_report_id = 5;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_crash_report_id(), target);
    }

    // optional string local_id = 6;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(6, this->_internal_local_id(), target);
    }

    // optional bool been_reported_without_crash_report_id = 7;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_been_reported_without_crash_report_id(), target);
    }

    // optional string event_based_log_id = 8;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_event_based_log_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.FatalCrashTelemetry)
    return target;
}

size_t FatalCrashTelemetry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.FatalCrashTelemetry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string crash_report_id = 5;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_crash_report_id());
        }

        // optional string local_id = 6;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_local_id());
        }

        // optional string event_based_log_id = 8;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_event_based_log_id());
        }

        // optional .reporting.SessionAffiliatedUser affiliated_user = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.affiliated_user_);
        }

        // optional .reporting.FatalCrashTelemetry.CrashType type = 1;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }

        // optional .reporting.FatalCrashTelemetry.SessionType session_type = 2;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_session_type());
        }

        // optional int64 timestamp_us = 3;
        if (cached_has_bits & 0x00000040u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_us());
        }

        // optional bool been_reported_without_crash_report_id = 7;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void FatalCrashTelemetry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const FatalCrashTelemetry*>(&from));
}

void FatalCrashTelemetry::MergeFrom(const FatalCrashTelemetry& from)
{
    FatalCrashTelemetry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.FatalCrashTelemetry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_crash_report_id(from._internal_crash_report_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_local_id(from._internal_local_id());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_event_based_log_id(from._internal_event_based_log_id());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_affiliated_user()->::reporting::SessionAffiliatedUser::MergeFrom(from._internal_affiliated_user());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.session_type_ = from._impl_.session_type_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.timestamp_us_ = from._impl_.timestamp_us_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.been_reported_without_crash_report_id_ = from._impl_.been_reported_without_crash_report_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FatalCrashTelemetry::CopyFrom(const FatalCrashTelemetry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.FatalCrashTelemetry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FatalCrashTelemetry::IsInitialized() const
{
    return true;
}

void FatalCrashTelemetry::InternalSwap(FatalCrashTelemetry* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.crash_report_id_, lhs_arena, &other->_impl_.crash_report_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.local_id_, lhs_arena, &other->_impl_.local_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.event_based_log_id_, lhs_arena, &other->_impl_.event_based_log_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(FatalCrashTelemetry, _impl_.been_reported_without_crash_report_id_)
        + sizeof(FatalCrashTelemetry::_impl_.been_reported_without_crash_report_id_) - PROTOBUF_FIELD_OFFSET(FatalCrashTelemetry, _impl_.affiliated_user_)>(
        reinterpret_cast<char*>(&_impl_.affiliated_user_), reinterpret_cast<char*>(&other->_impl_.affiliated_user_));
}

std::string FatalCrashTelemetry::GetTypeName() const
{
    return "reporting.FatalCrashTelemetry";
}

// ===================================================================

class RuntimeCountersTelemetry::_Internal {
public:
    using HasBits = decltype(std::declval<RuntimeCountersTelemetry>()._impl_._has_bits_);
    static void set_has_uptime_runtime_seconds(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_counter_enter_sleep(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_counter_enter_hibernation(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_counter_enter_poweroff(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

RuntimeCountersTelemetry::RuntimeCountersTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.RuntimeCountersTelemetry)
}
RuntimeCountersTelemetry::RuntimeCountersTelemetry(const RuntimeCountersTelemetry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    RuntimeCountersTelemetry* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.uptime_runtime_seconds_) {},
            decltype(_impl_.counter_enter_sleep_) {}, decltype(_impl_.counter_enter_hibernation_) {}, decltype(_impl_.counter_enter_poweroff_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.uptime_runtime_seconds_, &from._impl_.uptime_runtime_seconds_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.counter_enter_poweroff_) - reinterpret_cast<char*>(&_impl_.uptime_runtime_seconds_))
            + sizeof(_impl_.counter_enter_poweroff_));
    // @@protoc_insertion_point(copy_constructor:reporting.RuntimeCountersTelemetry)
}

inline void RuntimeCountersTelemetry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.uptime_runtime_seconds_) { int64_t { 0 } },
        decltype(_impl_.counter_enter_sleep_) { int64_t { 0 } }, decltype(_impl_.counter_enter_hibernation_) { int64_t { 0 } },
        decltype(_impl_.counter_enter_poweroff_) { int64_t { 0 } } };
}

RuntimeCountersTelemetry::~RuntimeCountersTelemetry()
{
    // @@protoc_insertion_point(destructor:reporting.RuntimeCountersTelemetry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void RuntimeCountersTelemetry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RuntimeCountersTelemetry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void RuntimeCountersTelemetry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.RuntimeCountersTelemetry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        ::memset(&_impl_.uptime_runtime_seconds_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.counter_enter_poweroff_) - reinterpret_cast<char*>(&_impl_.uptime_runtime_seconds_))
                + sizeof(_impl_.counter_enter_poweroff_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* RuntimeCountersTelemetry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 uptime_runtime_seconds = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_uptime_runtime_seconds(&has_bits);
                _impl_.uptime_runtime_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 counter_enter_sleep = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_counter_enter_sleep(&has_bits);
                _impl_.counter_enter_sleep_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 counter_enter_hibernation = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_counter_enter_hibernation(&has_bits);
                _impl_.counter_enter_hibernation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 counter_enter_poweroff = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_counter_enter_poweroff(&has_bits);
                _impl_.counter_enter_poweroff_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* RuntimeCountersTelemetry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.RuntimeCountersTelemetry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 uptime_runtime_seconds = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_uptime_runtime_seconds(), target);
    }

    // optional int64 counter_enter_sleep = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_counter_enter_sleep(), target);
    }

    // optional int64 counter_enter_hibernation = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_counter_enter_hibernation(), target);
    }

    // optional int64 counter_enter_poweroff = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_counter_enter_poweroff(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.RuntimeCountersTelemetry)
    return target;
}

size_t RuntimeCountersTelemetry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.RuntimeCountersTelemetry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional int64 uptime_runtime_seconds = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_uptime_runtime_seconds());
        }

        // optional int64 counter_enter_sleep = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_counter_enter_sleep());
        }

        // optional int64 counter_enter_hibernation = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_counter_enter_hibernation());
        }

        // optional int64 counter_enter_poweroff = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_counter_enter_poweroff());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void RuntimeCountersTelemetry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const RuntimeCountersTelemetry*>(&from));
}

void RuntimeCountersTelemetry::MergeFrom(const RuntimeCountersTelemetry& from)
{
    RuntimeCountersTelemetry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.RuntimeCountersTelemetry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.uptime_runtime_seconds_ = from._impl_.uptime_runtime_seconds_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.counter_enter_sleep_ = from._impl_.counter_enter_sleep_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.counter_enter_hibernation_ = from._impl_.counter_enter_hibernation_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.counter_enter_poweroff_ = from._impl_.counter_enter_poweroff_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RuntimeCountersTelemetry::CopyFrom(const RuntimeCountersTelemetry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.RuntimeCountersTelemetry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool RuntimeCountersTelemetry::IsInitialized() const
{
    return true;
}

void RuntimeCountersTelemetry::InternalSwap(RuntimeCountersTelemetry* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(RuntimeCountersTelemetry, _impl_.counter_enter_poweroff_)
        + sizeof(RuntimeCountersTelemetry::_impl_.counter_enter_poweroff_) - PROTOBUF_FIELD_OFFSET(RuntimeCountersTelemetry, _impl_.uptime_runtime_seconds_)>(
        reinterpret_cast<char*>(&_impl_.uptime_runtime_seconds_), reinterpret_cast<char*>(&other->_impl_.uptime_runtime_seconds_));
}

std::string RuntimeCountersTelemetry::GetTypeName() const
{
    return "reporting.RuntimeCountersTelemetry";
}

// ===================================================================

class EventData::_Internal {
public:
    using HasBits = decltype(std::declval<EventData>()._impl_._has_bits_);
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

EventData::EventData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.EventData)
}
EventData::EventData(const EventData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    EventData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.type_ = from._impl_.type_;
    // @@protoc_insertion_point(copy_constructor:reporting.EventData)
}

inline void EventData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.type_) { 0 } };
}

EventData::~EventData()
{
    // @@protoc_insertion_point(destructor:reporting.EventData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void EventData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EventData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void EventData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.EventData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* EventData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .reporting.MetricEventType type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::reporting::MetricEventType_IsValid(val))) {
                    _internal_set_type(static_cast<::reporting::MetricEventType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* EventData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.EventData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .reporting.MetricEventType type = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.EventData)
    return target;
}

size_t EventData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.EventData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .reporting.MetricEventType type = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void EventData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const EventData*>(&from));
}

void EventData::MergeFrom(const EventData& from)
{
    EventData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.EventData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_type()) {
        _this->_internal_set_type(from._internal_type());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EventData::CopyFrom(const EventData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.EventData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool EventData::IsInitialized() const
{
    return true;
}

void EventData::InternalSwap(EventData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.type_, other->_impl_.type_);
}

std::string EventData::GetTypeName() const
{
    return "reporting.EventData";
}

// ===================================================================

class MetricData::_Internal {
public:
    using HasBits = decltype(std::declval<MetricData>()._impl_._has_bits_);
    static void set_has_timestamp_ms(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::reporting::InfoData& info_data(const MetricData* msg);
    static const ::reporting::TelemetryData& telemetry_data(const MetricData* msg);
    static const ::reporting::EventData& event_data(const MetricData* msg);
    static void set_has_event_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::reporting::InfoData& MetricData::_Internal::info_data(const MetricData* msg)
{
    return *msg->_impl_.metric_type_.info_data_;
}
const ::reporting::TelemetryData& MetricData::_Internal::telemetry_data(const MetricData* msg)
{
    return *msg->_impl_.metric_type_.telemetry_data_;
}
const ::reporting::EventData& MetricData::_Internal::event_data(const MetricData* msg)
{
    return *msg->_impl_.event_data_;
}
void MetricData::set_allocated_info_data(::reporting::InfoData* info_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_metric_type();
    if (info_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(info_data);
        if (message_arena != submessage_arena) {
            info_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, info_data, submessage_arena);
        }
        set_has_info_data();
        _impl_.metric_type_.info_data_ = info_data;
    }
    // @@protoc_insertion_point(field_set_allocated:reporting.MetricData.info_data)
}
void MetricData::set_allocated_telemetry_data(::reporting::TelemetryData* telemetry_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_metric_type();
    if (telemetry_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(telemetry_data);
        if (message_arena != submessage_arena) {
            telemetry_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, telemetry_data, submessage_arena);
        }
        set_has_telemetry_data();
        _impl_.metric_type_.telemetry_data_ = telemetry_data;
    }
    // @@protoc_insertion_point(field_set_allocated:reporting.MetricData.telemetry_data)
}
MetricData::MetricData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:reporting.MetricData)
}
MetricData::MetricData(const MetricData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    MetricData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.event_data_) { nullptr }, decltype(_impl_.timestamp_ms_) {}, decltype(_impl_.metric_type_) {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_event_data()) {
        _this->_impl_.event_data_ = new ::reporting::EventData(*from._impl_.event_data_);
    }
    _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
    clear_has_metric_type();
    switch (from.metric_type_case()) {
    case kInfoData: {
        _this->_internal_mutable_info_data()->::reporting::InfoData::MergeFrom(from._internal_info_data());
        break;
    }
    case kTelemetryData: {
        _this->_internal_mutable_telemetry_data()->::reporting::TelemetryData::MergeFrom(from._internal_telemetry_data());
        break;
    }
    case METRIC_TYPE_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:reporting.MetricData)
}

inline void MetricData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.event_data_) { nullptr },
        decltype(_impl_.timestamp_ms_) { int64_t { 0 } }, decltype(_impl_.metric_type_) {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_metric_type();
}

MetricData::~MetricData()
{
    // @@protoc_insertion_point(destructor:reporting.MetricData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void MetricData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.event_data_;
    if (has_metric_type()) {
        clear_metric_type();
    }
}

void MetricData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void MetricData::clear_metric_type()
{
    // @@protoc_insertion_point(one_of_clear_start:reporting.MetricData)
    switch (metric_type_case()) {
    case kInfoData: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.metric_type_.info_data_;
        }
        break;
    }
    case kTelemetryData: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.metric_type_.telemetry_data_;
        }
        break;
    }
    case METRIC_TYPE_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = METRIC_TYPE_NOT_SET;
}

void MetricData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:reporting.MetricData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.event_data_ != nullptr);
        _impl_.event_data_->Clear();
    }
    _impl_.timestamp_ms_ = int64_t { 0 };
    clear_metric_type();
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* MetricData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 timestamp_ms = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_timestamp_ms(&has_bits);
                _impl_.timestamp_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .reporting.InfoData info_data = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_info_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .reporting.TelemetryData telemetry_data = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_telemetry_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .reporting.EventData event_data = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_event_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* MetricData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:reporting.MetricData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 timestamp_ms = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_ms(), target);
    }

    switch (metric_type_case()) {
    case kInfoData: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::info_data(this), _Internal::info_data(this).GetCachedSize(), target, stream);
        break;
    }
    case kTelemetryData: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::telemetry_data(this), _Internal::telemetry_data(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    // optional .reporting.EventData event_data = 4;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::event_data(this), _Internal::event_data(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:reporting.MetricData)
    return target;
}

size_t MetricData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:reporting.MetricData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional .reporting.EventData event_data = 4;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.event_data_);
        }

        // optional int64 timestamp_ms = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_ms());
        }
    }
    switch (metric_type_case()) {
    // .reporting.InfoData info_data = 2;
    case kInfoData: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.metric_type_.info_data_);
        break;
    }
    // .reporting.TelemetryData telemetry_data = 3;
    case kTelemetryData: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.metric_type_.telemetry_data_);
        break;
    }
    case METRIC_TYPE_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void MetricData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const MetricData*>(&from));
}

void MetricData::MergeFrom(const MetricData& from)
{
    MetricData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:reporting.MetricData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_event_data()->::reporting::EventData::MergeFrom(from._internal_event_data());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.timestamp_ms_ = from._impl_.timestamp_ms_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    switch (from.metric_type_case()) {
    case kInfoData: {
        _this->_internal_mutable_info_data()->::reporting::InfoData::MergeFrom(from._internal_info_data());
        break;
    }
    case kTelemetryData: {
        _this->_internal_mutable_telemetry_data()->::reporting::TelemetryData::MergeFrom(from._internal_telemetry_data());
        break;
    }
    case METRIC_TYPE_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MetricData::CopyFrom(const MetricData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:reporting.MetricData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool MetricData::IsInitialized() const
{
    return true;
}

void MetricData::InternalSwap(MetricData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(MetricData, _impl_.timestamp_ms_) + sizeof(MetricData::_impl_.timestamp_ms_)
        - PROTOBUF_FIELD_OFFSET(MetricData, _impl_.event_data_)>(
        reinterpret_cast<char*>(&_impl_.event_data_), reinterpret_cast<char*>(&other->_impl_.event_data_));
    swap(_impl_.metric_type_, other->_impl_.metric_type_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string MetricData::GetTypeName() const
{
    return "reporting.MetricData";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace reporting
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::reporting::HttpsLatencyRoutineData* Arena::CreateMaybeMessage<::reporting::HttpsLatencyRoutineData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::HttpsLatencyRoutineData>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::BandwidthData* Arena::CreateMaybeMessage<::reporting::BandwidthData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::BandwidthData>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::NetworkTelemetry* Arena::CreateMaybeMessage<::reporting::NetworkTelemetry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::NetworkTelemetry>(arena);
}
template <>
PROTOBUF_NOINLINE ::reporting::NetworkConnectionStateChangeEventData* Arena::CreateMaybeMessage<::reporting::NetworkConnectionStateChangeEventData>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::NetworkConnectionStateChangeEventData>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::SignalStrengthEventData* Arena::CreateMaybeMessage<::reporting::SignalStrengthEventData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::SignalStrengthEventData>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::NetworksTelemetry* Arena::CreateMaybeMessage<::reporting::NetworksTelemetry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::NetworksTelemetry>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::ThunderboltInfo* Arena::CreateMaybeMessage<::reporting::ThunderboltInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::ThunderboltInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::BusDeviceInfo* Arena::CreateMaybeMessage<::reporting::BusDeviceInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::BusDeviceInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::TotalMemoryEncryptionInfo* Arena::CreateMaybeMessage<::reporting::TotalMemoryEncryptionInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::TotalMemoryEncryptionInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::MemoryInfo* Arena::CreateMaybeMessage<::reporting::MemoryInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::MemoryInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::NetworkInterface* Arena::CreateMaybeMessage<::reporting::NetworkInterface>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::NetworkInterface>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::NetworksInfo* Arena::CreateMaybeMessage<::reporting::NetworksInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::NetworksInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::TouchScreenInfo* Arena::CreateMaybeMessage<::reporting::TouchScreenInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::TouchScreenInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::TouchScreenDevice* Arena::CreateMaybeMessage<::reporting::TouchScreenDevice>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::TouchScreenDevice>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::PrivacyScreenInfo* Arena::CreateMaybeMessage<::reporting::PrivacyScreenInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::PrivacyScreenInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::DisplayInfo* Arena::CreateMaybeMessage<::reporting::DisplayInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::DisplayInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::DisplayDevice* Arena::CreateMaybeMessage<::reporting::DisplayDevice>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::DisplayDevice>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::KeylockerInfo* Arena::CreateMaybeMessage<::reporting::KeylockerInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::KeylockerInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::CpuInfo* Arena::CreateMaybeMessage<::reporting::CpuInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::CpuInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::InfoData* Arena::CreateMaybeMessage<::reporting::InfoData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::InfoData>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::AudioTelemetry* Arena::CreateMaybeMessage<::reporting::AudioTelemetry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::AudioTelemetry>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::BootPerformanceTelemetry* Arena::CreateMaybeMessage<::reporting::BootPerformanceTelemetry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::BootPerformanceTelemetry>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::UserStatusTelemetry* Arena::CreateMaybeMessage<::reporting::UserStatusTelemetry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::UserStatusTelemetry>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::DisplaysTelemetry* Arena::CreateMaybeMessage<::reporting::DisplaysTelemetry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::DisplaysTelemetry>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::DisplayStatus* Arena::CreateMaybeMessage<::reporting::DisplayStatus>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::DisplayStatus>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::KioskHeartbeatTelemetry* Arena::CreateMaybeMessage<::reporting::KioskHeartbeatTelemetry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::KioskHeartbeatTelemetry>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::KioskVisionView* Arena::CreateMaybeMessage<::reporting::KioskVisionView>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::KioskVisionView>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::KioskVisionAudience* Arena::CreateMaybeMessage<::reporting::KioskVisionAudience>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::KioskVisionAudience>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::KioskVisionTelemetry* Arena::CreateMaybeMessage<::reporting::KioskVisionTelemetry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::KioskVisionTelemetry>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::KioskVisionStatusReport* Arena::CreateMaybeMessage<::reporting::KioskVisionStatusReport>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::KioskVisionStatusReport>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::TelemetryData* Arena::CreateMaybeMessage<::reporting::TelemetryData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::TelemetryData>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::AppTelemetry* Arena::CreateMaybeMessage<::reporting::AppTelemetry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::AppTelemetry>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::AppInstallData* Arena::CreateMaybeMessage<::reporting::AppInstallData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::AppInstallData>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::AppLaunchData* Arena::CreateMaybeMessage<::reporting::AppLaunchData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::AppLaunchData>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::AppUsageData_AppUsage* Arena::CreateMaybeMessage<::reporting::AppUsageData_AppUsage>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::AppUsageData_AppUsage>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::AppUsageData* Arena::CreateMaybeMessage<::reporting::AppUsageData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::AppUsageData>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::AppUninstallData* Arena::CreateMaybeMessage<::reporting::AppUninstallData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::AppUninstallData>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::WebsiteTelemetry* Arena::CreateMaybeMessage<::reporting::WebsiteTelemetry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::WebsiteTelemetry>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::WebsiteOpenedData* Arena::CreateMaybeMessage<::reporting::WebsiteOpenedData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::WebsiteOpenedData>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::WebsiteClosedData* Arena::CreateMaybeMessage<::reporting::WebsiteClosedData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::WebsiteClosedData>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::WebsiteUsageData_WebsiteUsage* Arena::CreateMaybeMessage<::reporting::WebsiteUsageData_WebsiteUsage>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::WebsiteUsageData_WebsiteUsage>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::WebsiteUsageData* Arena::CreateMaybeMessage<::reporting::WebsiteUsageData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::WebsiteUsageData>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::PeripheralsTelemetry* Arena::CreateMaybeMessage<::reporting::PeripheralsTelemetry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::PeripheralsTelemetry>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::UsbTelemetry* Arena::CreateMaybeMessage<::reporting::UsbTelemetry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::UsbTelemetry>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::FatalCrashTelemetry* Arena::CreateMaybeMessage<::reporting::FatalCrashTelemetry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::FatalCrashTelemetry>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::RuntimeCountersTelemetry* Arena::CreateMaybeMessage<::reporting::RuntimeCountersTelemetry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::RuntimeCountersTelemetry>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::EventData* Arena::CreateMaybeMessage<::reporting::EventData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::EventData>(arena);
}
template <> PROTOBUF_NOINLINE ::reporting::MetricData* Arena::CreateMaybeMessage<::reporting::MetricData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::reporting::MetricData>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
