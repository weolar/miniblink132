// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/reporting/proto/synced/metric_data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/reporting/proto/synced/session_affiliated_user.pb.h"
#include "components/services/app_service/public/protos/app_types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto {
    static const uint32_t offsets[];
};
namespace reporting {
class AppInstallData;
struct AppInstallDataDefaultTypeInternal;
extern AppInstallDataDefaultTypeInternal _AppInstallData_default_instance_;
class AppLaunchData;
struct AppLaunchDataDefaultTypeInternal;
extern AppLaunchDataDefaultTypeInternal _AppLaunchData_default_instance_;
class AppTelemetry;
struct AppTelemetryDefaultTypeInternal;
extern AppTelemetryDefaultTypeInternal _AppTelemetry_default_instance_;
class AppUninstallData;
struct AppUninstallDataDefaultTypeInternal;
extern AppUninstallDataDefaultTypeInternal _AppUninstallData_default_instance_;
class AppUsageData;
struct AppUsageDataDefaultTypeInternal;
extern AppUsageDataDefaultTypeInternal _AppUsageData_default_instance_;
class AppUsageData_AppUsage;
struct AppUsageData_AppUsageDefaultTypeInternal;
extern AppUsageData_AppUsageDefaultTypeInternal _AppUsageData_AppUsage_default_instance_;
class AudioTelemetry;
struct AudioTelemetryDefaultTypeInternal;
extern AudioTelemetryDefaultTypeInternal _AudioTelemetry_default_instance_;
class BandwidthData;
struct BandwidthDataDefaultTypeInternal;
extern BandwidthDataDefaultTypeInternal _BandwidthData_default_instance_;
class BootPerformanceTelemetry;
struct BootPerformanceTelemetryDefaultTypeInternal;
extern BootPerformanceTelemetryDefaultTypeInternal _BootPerformanceTelemetry_default_instance_;
class BusDeviceInfo;
struct BusDeviceInfoDefaultTypeInternal;
extern BusDeviceInfoDefaultTypeInternal _BusDeviceInfo_default_instance_;
class CpuInfo;
struct CpuInfoDefaultTypeInternal;
extern CpuInfoDefaultTypeInternal _CpuInfo_default_instance_;
class DisplayDevice;
struct DisplayDeviceDefaultTypeInternal;
extern DisplayDeviceDefaultTypeInternal _DisplayDevice_default_instance_;
class DisplayInfo;
struct DisplayInfoDefaultTypeInternal;
extern DisplayInfoDefaultTypeInternal _DisplayInfo_default_instance_;
class DisplayStatus;
struct DisplayStatusDefaultTypeInternal;
extern DisplayStatusDefaultTypeInternal _DisplayStatus_default_instance_;
class DisplaysTelemetry;
struct DisplaysTelemetryDefaultTypeInternal;
extern DisplaysTelemetryDefaultTypeInternal _DisplaysTelemetry_default_instance_;
class EventData;
struct EventDataDefaultTypeInternal;
extern EventDataDefaultTypeInternal _EventData_default_instance_;
class FatalCrashTelemetry;
struct FatalCrashTelemetryDefaultTypeInternal;
extern FatalCrashTelemetryDefaultTypeInternal _FatalCrashTelemetry_default_instance_;
class HttpsLatencyRoutineData;
struct HttpsLatencyRoutineDataDefaultTypeInternal;
extern HttpsLatencyRoutineDataDefaultTypeInternal _HttpsLatencyRoutineData_default_instance_;
class InfoData;
struct InfoDataDefaultTypeInternal;
extern InfoDataDefaultTypeInternal _InfoData_default_instance_;
class KeylockerInfo;
struct KeylockerInfoDefaultTypeInternal;
extern KeylockerInfoDefaultTypeInternal _KeylockerInfo_default_instance_;
class KioskHeartbeatTelemetry;
struct KioskHeartbeatTelemetryDefaultTypeInternal;
extern KioskHeartbeatTelemetryDefaultTypeInternal _KioskHeartbeatTelemetry_default_instance_;
class KioskVisionAudience;
struct KioskVisionAudienceDefaultTypeInternal;
extern KioskVisionAudienceDefaultTypeInternal _KioskVisionAudience_default_instance_;
class KioskVisionStatusReport;
struct KioskVisionStatusReportDefaultTypeInternal;
extern KioskVisionStatusReportDefaultTypeInternal _KioskVisionStatusReport_default_instance_;
class KioskVisionTelemetry;
struct KioskVisionTelemetryDefaultTypeInternal;
extern KioskVisionTelemetryDefaultTypeInternal _KioskVisionTelemetry_default_instance_;
class KioskVisionView;
struct KioskVisionViewDefaultTypeInternal;
extern KioskVisionViewDefaultTypeInternal _KioskVisionView_default_instance_;
class MemoryInfo;
struct MemoryInfoDefaultTypeInternal;
extern MemoryInfoDefaultTypeInternal _MemoryInfo_default_instance_;
class MetricData;
struct MetricDataDefaultTypeInternal;
extern MetricDataDefaultTypeInternal _MetricData_default_instance_;
class NetworkConnectionStateChangeEventData;
struct NetworkConnectionStateChangeEventDataDefaultTypeInternal;
extern NetworkConnectionStateChangeEventDataDefaultTypeInternal _NetworkConnectionStateChangeEventData_default_instance_;
class NetworkInterface;
struct NetworkInterfaceDefaultTypeInternal;
extern NetworkInterfaceDefaultTypeInternal _NetworkInterface_default_instance_;
class NetworkTelemetry;
struct NetworkTelemetryDefaultTypeInternal;
extern NetworkTelemetryDefaultTypeInternal _NetworkTelemetry_default_instance_;
class NetworksInfo;
struct NetworksInfoDefaultTypeInternal;
extern NetworksInfoDefaultTypeInternal _NetworksInfo_default_instance_;
class NetworksTelemetry;
struct NetworksTelemetryDefaultTypeInternal;
extern NetworksTelemetryDefaultTypeInternal _NetworksTelemetry_default_instance_;
class PeripheralsTelemetry;
struct PeripheralsTelemetryDefaultTypeInternal;
extern PeripheralsTelemetryDefaultTypeInternal _PeripheralsTelemetry_default_instance_;
class PrivacyScreenInfo;
struct PrivacyScreenInfoDefaultTypeInternal;
extern PrivacyScreenInfoDefaultTypeInternal _PrivacyScreenInfo_default_instance_;
class RuntimeCountersTelemetry;
struct RuntimeCountersTelemetryDefaultTypeInternal;
extern RuntimeCountersTelemetryDefaultTypeInternal _RuntimeCountersTelemetry_default_instance_;
class SignalStrengthEventData;
struct SignalStrengthEventDataDefaultTypeInternal;
extern SignalStrengthEventDataDefaultTypeInternal _SignalStrengthEventData_default_instance_;
class TelemetryData;
struct TelemetryDataDefaultTypeInternal;
extern TelemetryDataDefaultTypeInternal _TelemetryData_default_instance_;
class ThunderboltInfo;
struct ThunderboltInfoDefaultTypeInternal;
extern ThunderboltInfoDefaultTypeInternal _ThunderboltInfo_default_instance_;
class TotalMemoryEncryptionInfo;
struct TotalMemoryEncryptionInfoDefaultTypeInternal;
extern TotalMemoryEncryptionInfoDefaultTypeInternal _TotalMemoryEncryptionInfo_default_instance_;
class TouchScreenDevice;
struct TouchScreenDeviceDefaultTypeInternal;
extern TouchScreenDeviceDefaultTypeInternal _TouchScreenDevice_default_instance_;
class TouchScreenInfo;
struct TouchScreenInfoDefaultTypeInternal;
extern TouchScreenInfoDefaultTypeInternal _TouchScreenInfo_default_instance_;
class UsbTelemetry;
struct UsbTelemetryDefaultTypeInternal;
extern UsbTelemetryDefaultTypeInternal _UsbTelemetry_default_instance_;
class UserStatusTelemetry;
struct UserStatusTelemetryDefaultTypeInternal;
extern UserStatusTelemetryDefaultTypeInternal _UserStatusTelemetry_default_instance_;
class WebsiteClosedData;
struct WebsiteClosedDataDefaultTypeInternal;
extern WebsiteClosedDataDefaultTypeInternal _WebsiteClosedData_default_instance_;
class WebsiteOpenedData;
struct WebsiteOpenedDataDefaultTypeInternal;
extern WebsiteOpenedDataDefaultTypeInternal _WebsiteOpenedData_default_instance_;
class WebsiteTelemetry;
struct WebsiteTelemetryDefaultTypeInternal;
extern WebsiteTelemetryDefaultTypeInternal _WebsiteTelemetry_default_instance_;
class WebsiteUsageData;
struct WebsiteUsageDataDefaultTypeInternal;
extern WebsiteUsageDataDefaultTypeInternal _WebsiteUsageData_default_instance_;
class WebsiteUsageData_WebsiteUsage;
struct WebsiteUsageData_WebsiteUsageDefaultTypeInternal;
extern WebsiteUsageData_WebsiteUsageDefaultTypeInternal _WebsiteUsageData_WebsiteUsage_default_instance_;
} // namespace reporting
PROTOBUF_NAMESPACE_OPEN
template <>::reporting::AppInstallData* Arena::CreateMaybeMessage<::reporting::AppInstallData>(Arena*);
template <>::reporting::AppLaunchData* Arena::CreateMaybeMessage<::reporting::AppLaunchData>(Arena*);
template <>::reporting::AppTelemetry* Arena::CreateMaybeMessage<::reporting::AppTelemetry>(Arena*);
template <>::reporting::AppUninstallData* Arena::CreateMaybeMessage<::reporting::AppUninstallData>(Arena*);
template <>::reporting::AppUsageData* Arena::CreateMaybeMessage<::reporting::AppUsageData>(Arena*);
template <>::reporting::AppUsageData_AppUsage* Arena::CreateMaybeMessage<::reporting::AppUsageData_AppUsage>(Arena*);
template <>::reporting::AudioTelemetry* Arena::CreateMaybeMessage<::reporting::AudioTelemetry>(Arena*);
template <>::reporting::BandwidthData* Arena::CreateMaybeMessage<::reporting::BandwidthData>(Arena*);
template <>::reporting::BootPerformanceTelemetry* Arena::CreateMaybeMessage<::reporting::BootPerformanceTelemetry>(Arena*);
template <>::reporting::BusDeviceInfo* Arena::CreateMaybeMessage<::reporting::BusDeviceInfo>(Arena*);
template <>::reporting::CpuInfo* Arena::CreateMaybeMessage<::reporting::CpuInfo>(Arena*);
template <>::reporting::DisplayDevice* Arena::CreateMaybeMessage<::reporting::DisplayDevice>(Arena*);
template <>::reporting::DisplayInfo* Arena::CreateMaybeMessage<::reporting::DisplayInfo>(Arena*);
template <>::reporting::DisplayStatus* Arena::CreateMaybeMessage<::reporting::DisplayStatus>(Arena*);
template <>::reporting::DisplaysTelemetry* Arena::CreateMaybeMessage<::reporting::DisplaysTelemetry>(Arena*);
template <>::reporting::EventData* Arena::CreateMaybeMessage<::reporting::EventData>(Arena*);
template <>::reporting::FatalCrashTelemetry* Arena::CreateMaybeMessage<::reporting::FatalCrashTelemetry>(Arena*);
template <>::reporting::HttpsLatencyRoutineData* Arena::CreateMaybeMessage<::reporting::HttpsLatencyRoutineData>(Arena*);
template <>::reporting::InfoData* Arena::CreateMaybeMessage<::reporting::InfoData>(Arena*);
template <>::reporting::KeylockerInfo* Arena::CreateMaybeMessage<::reporting::KeylockerInfo>(Arena*);
template <>::reporting::KioskHeartbeatTelemetry* Arena::CreateMaybeMessage<::reporting::KioskHeartbeatTelemetry>(Arena*);
template <>::reporting::KioskVisionAudience* Arena::CreateMaybeMessage<::reporting::KioskVisionAudience>(Arena*);
template <>::reporting::KioskVisionStatusReport* Arena::CreateMaybeMessage<::reporting::KioskVisionStatusReport>(Arena*);
template <>::reporting::KioskVisionTelemetry* Arena::CreateMaybeMessage<::reporting::KioskVisionTelemetry>(Arena*);
template <>::reporting::KioskVisionView* Arena::CreateMaybeMessage<::reporting::KioskVisionView>(Arena*);
template <>::reporting::MemoryInfo* Arena::CreateMaybeMessage<::reporting::MemoryInfo>(Arena*);
template <>::reporting::MetricData* Arena::CreateMaybeMessage<::reporting::MetricData>(Arena*);
template <>::reporting::NetworkConnectionStateChangeEventData* Arena::CreateMaybeMessage<::reporting::NetworkConnectionStateChangeEventData>(Arena*);
template <>::reporting::NetworkInterface* Arena::CreateMaybeMessage<::reporting::NetworkInterface>(Arena*);
template <>::reporting::NetworkTelemetry* Arena::CreateMaybeMessage<::reporting::NetworkTelemetry>(Arena*);
template <>::reporting::NetworksInfo* Arena::CreateMaybeMessage<::reporting::NetworksInfo>(Arena*);
template <>::reporting::NetworksTelemetry* Arena::CreateMaybeMessage<::reporting::NetworksTelemetry>(Arena*);
template <>::reporting::PeripheralsTelemetry* Arena::CreateMaybeMessage<::reporting::PeripheralsTelemetry>(Arena*);
template <>::reporting::PrivacyScreenInfo* Arena::CreateMaybeMessage<::reporting::PrivacyScreenInfo>(Arena*);
template <>::reporting::RuntimeCountersTelemetry* Arena::CreateMaybeMessage<::reporting::RuntimeCountersTelemetry>(Arena*);
template <>::reporting::SignalStrengthEventData* Arena::CreateMaybeMessage<::reporting::SignalStrengthEventData>(Arena*);
template <>::reporting::TelemetryData* Arena::CreateMaybeMessage<::reporting::TelemetryData>(Arena*);
template <>::reporting::ThunderboltInfo* Arena::CreateMaybeMessage<::reporting::ThunderboltInfo>(Arena*);
template <>::reporting::TotalMemoryEncryptionInfo* Arena::CreateMaybeMessage<::reporting::TotalMemoryEncryptionInfo>(Arena*);
template <>::reporting::TouchScreenDevice* Arena::CreateMaybeMessage<::reporting::TouchScreenDevice>(Arena*);
template <>::reporting::TouchScreenInfo* Arena::CreateMaybeMessage<::reporting::TouchScreenInfo>(Arena*);
template <>::reporting::UsbTelemetry* Arena::CreateMaybeMessage<::reporting::UsbTelemetry>(Arena*);
template <>::reporting::UserStatusTelemetry* Arena::CreateMaybeMessage<::reporting::UserStatusTelemetry>(Arena*);
template <>::reporting::WebsiteClosedData* Arena::CreateMaybeMessage<::reporting::WebsiteClosedData>(Arena*);
template <>::reporting::WebsiteOpenedData* Arena::CreateMaybeMessage<::reporting::WebsiteOpenedData>(Arena*);
template <>::reporting::WebsiteTelemetry* Arena::CreateMaybeMessage<::reporting::WebsiteTelemetry>(Arena*);
template <>::reporting::WebsiteUsageData* Arena::CreateMaybeMessage<::reporting::WebsiteUsageData>(Arena*);
template <>::reporting::WebsiteUsageData_WebsiteUsage* Arena::CreateMaybeMessage<::reporting::WebsiteUsageData_WebsiteUsage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace reporting {

enum UserStatusTelemetry_DeviceActivityState : int {
    UserStatusTelemetry_DeviceActivityState_DEVICE_ACTIVITY_STATE_UNKNOWN = 0,
    UserStatusTelemetry_DeviceActivityState_ACTIVE = 1,
    UserStatusTelemetry_DeviceActivityState_IDLE = 2,
    UserStatusTelemetry_DeviceActivityState_LOCKED = 3
};
bool UserStatusTelemetry_DeviceActivityState_IsValid(int value);
constexpr UserStatusTelemetry_DeviceActivityState UserStatusTelemetry_DeviceActivityState_DeviceActivityState_MIN
    = UserStatusTelemetry_DeviceActivityState_DEVICE_ACTIVITY_STATE_UNKNOWN;
constexpr UserStatusTelemetry_DeviceActivityState UserStatusTelemetry_DeviceActivityState_DeviceActivityState_MAX
    = UserStatusTelemetry_DeviceActivityState_LOCKED;
constexpr int UserStatusTelemetry_DeviceActivityState_DeviceActivityState_ARRAYSIZE = UserStatusTelemetry_DeviceActivityState_DeviceActivityState_MAX + 1;

const std::string& UserStatusTelemetry_DeviceActivityState_Name(UserStatusTelemetry_DeviceActivityState value);
template <typename T> inline const std::string& UserStatusTelemetry_DeviceActivityState_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, UserStatusTelemetry_DeviceActivityState>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function UserStatusTelemetry_DeviceActivityState_Name.");
    return UserStatusTelemetry_DeviceActivityState_Name(static_cast<UserStatusTelemetry_DeviceActivityState>(enum_t_value));
}
bool UserStatusTelemetry_DeviceActivityState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserStatusTelemetry_DeviceActivityState* value);
enum KioskVisionStatusReport_KioskVisionState : int {
    KioskVisionStatusReport_KioskVisionState_KIOSK_VISION_STATE_ACTIVE = 0,
    KioskVisionStatusReport_KioskVisionState_KIOSK_VISION_STATE_UNKNOWN_ERROR = 1,
    KioskVisionStatusReport_KioskVisionState_KIOSK_VISION_STATE_CAMERA_NOT_FOUND = 2
};
bool KioskVisionStatusReport_KioskVisionState_IsValid(int value);
constexpr KioskVisionStatusReport_KioskVisionState KioskVisionStatusReport_KioskVisionState_KioskVisionState_MIN
    = KioskVisionStatusReport_KioskVisionState_KIOSK_VISION_STATE_ACTIVE;
constexpr KioskVisionStatusReport_KioskVisionState KioskVisionStatusReport_KioskVisionState_KioskVisionState_MAX
    = KioskVisionStatusReport_KioskVisionState_KIOSK_VISION_STATE_CAMERA_NOT_FOUND;
constexpr int KioskVisionStatusReport_KioskVisionState_KioskVisionState_ARRAYSIZE = KioskVisionStatusReport_KioskVisionState_KioskVisionState_MAX + 1;

const std::string& KioskVisionStatusReport_KioskVisionState_Name(KioskVisionStatusReport_KioskVisionState value);
template <typename T> inline const std::string& KioskVisionStatusReport_KioskVisionState_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, KioskVisionStatusReport_KioskVisionState>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function KioskVisionStatusReport_KioskVisionState_Name.");
    return KioskVisionStatusReport_KioskVisionState_Name(static_cast<KioskVisionStatusReport_KioskVisionState>(enum_t_value));
}
bool KioskVisionStatusReport_KioskVisionState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KioskVisionStatusReport_KioskVisionState* value);
enum FatalCrashTelemetry_CrashType : int {
    FatalCrashTelemetry_CrashType_CRASH_TYPE_UNSPECIFIED = 0,
    FatalCrashTelemetry_CrashType_CRASH_TYPE_KERNEL = 1,
    FatalCrashTelemetry_CrashType_CRASH_TYPE_EMBEDDED_CONTROLLER = 2,
    FatalCrashTelemetry_CrashType_CRASH_TYPE_CHROME = 3
};
bool FatalCrashTelemetry_CrashType_IsValid(int value);
constexpr FatalCrashTelemetry_CrashType FatalCrashTelemetry_CrashType_CrashType_MIN = FatalCrashTelemetry_CrashType_CRASH_TYPE_UNSPECIFIED;
constexpr FatalCrashTelemetry_CrashType FatalCrashTelemetry_CrashType_CrashType_MAX = FatalCrashTelemetry_CrashType_CRASH_TYPE_CHROME;
constexpr int FatalCrashTelemetry_CrashType_CrashType_ARRAYSIZE = FatalCrashTelemetry_CrashType_CrashType_MAX + 1;

const std::string& FatalCrashTelemetry_CrashType_Name(FatalCrashTelemetry_CrashType value);
template <typename T> inline const std::string& FatalCrashTelemetry_CrashType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, FatalCrashTelemetry_CrashType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function FatalCrashTelemetry_CrashType_Name.");
    return FatalCrashTelemetry_CrashType_Name(static_cast<FatalCrashTelemetry_CrashType>(enum_t_value));
}
bool FatalCrashTelemetry_CrashType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FatalCrashTelemetry_CrashType* value);
enum FatalCrashTelemetry_SessionType : int {
    FatalCrashTelemetry_SessionType_SESSION_TYPE_UNSPECIFIED = 0,
    FatalCrashTelemetry_SessionType_SESSION_TYPE_REGULAR = 1,
    FatalCrashTelemetry_SessionType_SESSION_TYPE_CHILD = 2,
    FatalCrashTelemetry_SessionType_SESSION_TYPE_KIOSK_APP = 3,
    FatalCrashTelemetry_SessionType_SESSION_TYPE_ARC_KIOSK_APP = 4,
    FatalCrashTelemetry_SessionType_SESSION_TYPE_WEB_KIOSK_APP = 5,
    FatalCrashTelemetry_SessionType_SESSION_TYPE_GUEST = 6,
    FatalCrashTelemetry_SessionType_SESSION_TYPE_PUBLIC_ACCOUNT = 7,
    FatalCrashTelemetry_SessionType_SESSION_TYPE_ACTIVE_DIRECTORY = 8
};
bool FatalCrashTelemetry_SessionType_IsValid(int value);
constexpr FatalCrashTelemetry_SessionType FatalCrashTelemetry_SessionType_SessionType_MIN = FatalCrashTelemetry_SessionType_SESSION_TYPE_UNSPECIFIED;
constexpr FatalCrashTelemetry_SessionType FatalCrashTelemetry_SessionType_SessionType_MAX = FatalCrashTelemetry_SessionType_SESSION_TYPE_ACTIVE_DIRECTORY;
constexpr int FatalCrashTelemetry_SessionType_SessionType_ARRAYSIZE = FatalCrashTelemetry_SessionType_SessionType_MAX + 1;

const std::string& FatalCrashTelemetry_SessionType_Name(FatalCrashTelemetry_SessionType value);
template <typename T> inline const std::string& FatalCrashTelemetry_SessionType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, FatalCrashTelemetry_SessionType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function FatalCrashTelemetry_SessionType_Name.");
    return FatalCrashTelemetry_SessionType_Name(static_cast<FatalCrashTelemetry_SessionType>(enum_t_value));
}
bool FatalCrashTelemetry_SessionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FatalCrashTelemetry_SessionType* value);
enum RoutineVerdict : int { ROUTINE_VERDICT_UNSPECIFIED = 0, NO_PROBLEM = 1, PROBLEM = 2, NOT_RUN = 3 };
bool RoutineVerdict_IsValid(int value);
constexpr RoutineVerdict RoutineVerdict_MIN = ROUTINE_VERDICT_UNSPECIFIED;
constexpr RoutineVerdict RoutineVerdict_MAX = NOT_RUN;
constexpr int RoutineVerdict_ARRAYSIZE = RoutineVerdict_MAX + 1;

const std::string& RoutineVerdict_Name(RoutineVerdict value);
template <typename T> inline const std::string& RoutineVerdict_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, RoutineVerdict>::value || ::std::is_integral<T>::value, "Incorrect type passed to function RoutineVerdict_Name.");
    return RoutineVerdict_Name(static_cast<RoutineVerdict>(enum_t_value));
}
bool RoutineVerdict_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RoutineVerdict* value);
enum HttpsLatencyProblem : int {
    HTTPS_LATENCY_PROBLEM_UNSPECIFIED = 0,
    FAILED_DNS_RESOLUTIONS = 1,
    FAILED_HTTPS_REQUESTS = 2,
    HIGH_LATENCY = 3,
    VERY_HIGH_LATENCY = 4
};
bool HttpsLatencyProblem_IsValid(int value);
constexpr HttpsLatencyProblem HttpsLatencyProblem_MIN = HTTPS_LATENCY_PROBLEM_UNSPECIFIED;
constexpr HttpsLatencyProblem HttpsLatencyProblem_MAX = VERY_HIGH_LATENCY;
constexpr int HttpsLatencyProblem_ARRAYSIZE = HttpsLatencyProblem_MAX + 1;

const std::string& HttpsLatencyProblem_Name(HttpsLatencyProblem value);
template <typename T> inline const std::string& HttpsLatencyProblem_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, HttpsLatencyProblem>::value || ::std::is_integral<T>::value, "Incorrect type passed to function HttpsLatencyProblem_Name.");
    return HttpsLatencyProblem_Name(static_cast<HttpsLatencyProblem>(enum_t_value));
}
bool HttpsLatencyProblem_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HttpsLatencyProblem* value);
enum NetworkConnectionState : int { NETWORK_CONNECTION_STATE_UNSPECIFIED = 0, ONLINE = 1, CONNECTED = 2, PORTAL = 3, CONNECTING = 4, NOT_CONNECTED = 5 };
bool NetworkConnectionState_IsValid(int value);
constexpr NetworkConnectionState NetworkConnectionState_MIN = NETWORK_CONNECTION_STATE_UNSPECIFIED;
constexpr NetworkConnectionState NetworkConnectionState_MAX = NOT_CONNECTED;
constexpr int NetworkConnectionState_ARRAYSIZE = NetworkConnectionState_MAX + 1;

const std::string& NetworkConnectionState_Name(NetworkConnectionState value);
template <typename T> inline const std::string& NetworkConnectionState_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, NetworkConnectionState>::value || ::std::is_integral<T>::value, "Incorrect type passed to function NetworkConnectionState_Name.");
    return NetworkConnectionState_Name(static_cast<NetworkConnectionState>(enum_t_value));
}
bool NetworkConnectionState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkConnectionState* value);
enum NetworkType : int { NETWORK_TYPE_UNSPECIFIED = 0, CELLULAR = 1, ETHERNET = 2, TETHER = 3, VPN = 4, WIFI = 5 };
bool NetworkType_IsValid(int value);
constexpr NetworkType NetworkType_MIN = NETWORK_TYPE_UNSPECIFIED;
constexpr NetworkType NetworkType_MAX = WIFI;
constexpr int NetworkType_ARRAYSIZE = NetworkType_MAX + 1;

const std::string& NetworkType_Name(NetworkType value);
template <typename T> inline const std::string& NetworkType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, NetworkType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function NetworkType_Name.");
    return NetworkType_Name(static_cast<NetworkType>(enum_t_value));
}
bool NetworkType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkType* value);
enum ThunderboltSecurityLevel : int {
    UNSPECIFIED_THUNDERBOLT_SECURITY_LEVEL = 0,
    THUNDERBOLT_SECURITY_NONE_LEVEL = 1,
    THUNDERBOLT_SECURITY_USER_LEVEL = 2,
    THUNDERBOLT_SECURITY_SECURE_LEVEL = 3,
    THUNDERBOLT_SECURITY_DP_ONLY_LEVEL = 4,
    THUNDERBOLT_SECURITY_USB_ONLY_LEVEL = 5,
    THUNDERBOLT_SECURITY_NO_PCIE_LEVEL = 6
};
bool ThunderboltSecurityLevel_IsValid(int value);
constexpr ThunderboltSecurityLevel ThunderboltSecurityLevel_MIN = UNSPECIFIED_THUNDERBOLT_SECURITY_LEVEL;
constexpr ThunderboltSecurityLevel ThunderboltSecurityLevel_MAX = THUNDERBOLT_SECURITY_NO_PCIE_LEVEL;
constexpr int ThunderboltSecurityLevel_ARRAYSIZE = ThunderboltSecurityLevel_MAX + 1;

const std::string& ThunderboltSecurityLevel_Name(ThunderboltSecurityLevel value);
template <typename T> inline const std::string& ThunderboltSecurityLevel_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, ThunderboltSecurityLevel>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ThunderboltSecurityLevel_Name.");
    return ThunderboltSecurityLevel_Name(static_cast<ThunderboltSecurityLevel>(enum_t_value));
}
bool ThunderboltSecurityLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThunderboltSecurityLevel* value);
enum MemoryEncryptionState : int {
    UNSPECIFIED_MEMORY_ENCRYPTION_STATE = 0,
    MEMORY_ENCRYPTION_STATE_UNKNOWN = 1,
    MEMORY_ENCRYPTION_STATE_DISABLED = 2,
    MEMORY_ENCRYPTION_STATE_TME = 3,
    MEMORY_ENCRYPTION_STATE_MKTME = 4
};
bool MemoryEncryptionState_IsValid(int value);
constexpr MemoryEncryptionState MemoryEncryptionState_MIN = UNSPECIFIED_MEMORY_ENCRYPTION_STATE;
constexpr MemoryEncryptionState MemoryEncryptionState_MAX = MEMORY_ENCRYPTION_STATE_MKTME;
constexpr int MemoryEncryptionState_ARRAYSIZE = MemoryEncryptionState_MAX + 1;

const std::string& MemoryEncryptionState_Name(MemoryEncryptionState value);
template <typename T> inline const std::string& MemoryEncryptionState_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, MemoryEncryptionState>::value || ::std::is_integral<T>::value, "Incorrect type passed to function MemoryEncryptionState_Name.");
    return MemoryEncryptionState_Name(static_cast<MemoryEncryptionState>(enum_t_value));
}
bool MemoryEncryptionState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MemoryEncryptionState* value);
enum MemoryEncryptionAlgorithm : int {
    UNSPECIFIED_MEMORY_ENCRYPTION_ALGORITHM = 0,
    MEMORY_ENCRYPTION_ALGORITHM_UNKNOWN = 1,
    MEMORY_ENCRYPTION_ALGORITHM_AES_XTS_128 = 2,
    MEMORY_ENCRYPTION_ALGORITHM_AES_XTS_256 = 3
};
bool MemoryEncryptionAlgorithm_IsValid(int value);
constexpr MemoryEncryptionAlgorithm MemoryEncryptionAlgorithm_MIN = UNSPECIFIED_MEMORY_ENCRYPTION_ALGORITHM;
constexpr MemoryEncryptionAlgorithm MemoryEncryptionAlgorithm_MAX = MEMORY_ENCRYPTION_ALGORITHM_AES_XTS_256;
constexpr int MemoryEncryptionAlgorithm_ARRAYSIZE = MemoryEncryptionAlgorithm_MAX + 1;

const std::string& MemoryEncryptionAlgorithm_Name(MemoryEncryptionAlgorithm value);
template <typename T> inline const std::string& MemoryEncryptionAlgorithm_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, MemoryEncryptionAlgorithm>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function MemoryEncryptionAlgorithm_Name.");
    return MemoryEncryptionAlgorithm_Name(static_cast<MemoryEncryptionAlgorithm>(enum_t_value));
}
bool MemoryEncryptionAlgorithm_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MemoryEncryptionAlgorithm* value);
enum NetworkDeviceType : int { NETWORK_DEVICE_TYPE_UNSPECIFIED = 0, CELLULAR_DEVICE = 1, ETHERNET_DEVICE = 2, WIFI_DEVICE = 5 };
bool NetworkDeviceType_IsValid(int value);
constexpr NetworkDeviceType NetworkDeviceType_MIN = NETWORK_DEVICE_TYPE_UNSPECIFIED;
constexpr NetworkDeviceType NetworkDeviceType_MAX = WIFI_DEVICE;
constexpr int NetworkDeviceType_ARRAYSIZE = NetworkDeviceType_MAX + 1;

const std::string& NetworkDeviceType_Name(NetworkDeviceType value);
template <typename T> inline const std::string& NetworkDeviceType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, NetworkDeviceType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function NetworkDeviceType_Name.");
    return NetworkDeviceType_Name(static_cast<NetworkDeviceType>(enum_t_value));
}
bool NetworkDeviceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkDeviceType* value);
enum MetricEventType : int {
    EVENT_TYPE_UNSPECIFIED = 0,
    NETWORK_HTTPS_LATENCY_CHANGE = 1,
    AUDIO_SEVERE_UNDERRUN = 4,
    USB_ADDED = 5,
    USB_REMOVED = 6,
    APP_INSTALLED = 7,
    APP_UNINSTALLED = 8,
    APP_LAUNCHED = 9,
    WIFI_SIGNAL_STRENGTH_LOW = 13,
    WIFI_SIGNAL_STRENGTH_RECOVERED = 14,
    NETWORK_STATE_CHANGE = 15,
    VPN_CONNECTION_STATE_CHANGE = 16,
    FATAL_CRASH = 17,
    URL_OPENED = 18,
    URL_CLOSED = 19,
    KIOSK_HEARTBEAT = 20
};
bool MetricEventType_IsValid(int value);
constexpr MetricEventType MetricEventType_MIN = EVENT_TYPE_UNSPECIFIED;
constexpr MetricEventType MetricEventType_MAX = KIOSK_HEARTBEAT;
constexpr int MetricEventType_ARRAYSIZE = MetricEventType_MAX + 1;

const std::string& MetricEventType_Name(MetricEventType value);
template <typename T> inline const std::string& MetricEventType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, MetricEventType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function MetricEventType_Name.");
    return MetricEventType_Name(static_cast<MetricEventType>(enum_t_value));
}
bool MetricEventType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MetricEventType* value);
// ===================================================================

class HttpsLatencyRoutineData final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.HttpsLatencyRoutineData) */ {
public:
    inline HttpsLatencyRoutineData()
        : HttpsLatencyRoutineData(nullptr)
    {
    }
    ~HttpsLatencyRoutineData() override;
    explicit PROTOBUF_CONSTEXPR HttpsLatencyRoutineData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    HttpsLatencyRoutineData(const HttpsLatencyRoutineData& from);
    HttpsLatencyRoutineData(HttpsLatencyRoutineData&& from) noexcept
        : HttpsLatencyRoutineData()
    {
        *this = ::std::move(from);
    }

    inline HttpsLatencyRoutineData& operator=(const HttpsLatencyRoutineData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline HttpsLatencyRoutineData& operator=(HttpsLatencyRoutineData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const HttpsLatencyRoutineData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const HttpsLatencyRoutineData* internal_default_instance()
    {
        return reinterpret_cast<const HttpsLatencyRoutineData*>(&_HttpsLatencyRoutineData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(HttpsLatencyRoutineData& a, HttpsLatencyRoutineData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(HttpsLatencyRoutineData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(HttpsLatencyRoutineData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    HttpsLatencyRoutineData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<HttpsLatencyRoutineData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const HttpsLatencyRoutineData& from);
    void MergeFrom(const HttpsLatencyRoutineData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(HttpsLatencyRoutineData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.HttpsLatencyRoutineData";
    }

protected:
    explicit HttpsLatencyRoutineData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kVerdictFieldNumber = 1,
        kProblemFieldNumber = 2,
        kLatencyMsFieldNumber = 3,
    };
    // optional .reporting.RoutineVerdict verdict = 1;
    bool has_verdict() const;

private:
    bool _internal_has_verdict() const;

public:
    void clear_verdict();
    ::reporting::RoutineVerdict verdict() const;
    void set_verdict(::reporting::RoutineVerdict value);

private:
    ::reporting::RoutineVerdict _internal_verdict() const;
    void _internal_set_verdict(::reporting::RoutineVerdict value);

public:
    // optional .reporting.HttpsLatencyProblem problem = 2;
    bool has_problem() const;

private:
    bool _internal_has_problem() const;

public:
    void clear_problem();
    ::reporting::HttpsLatencyProblem problem() const;
    void set_problem(::reporting::HttpsLatencyProblem value);

private:
    ::reporting::HttpsLatencyProblem _internal_problem() const;
    void _internal_set_problem(::reporting::HttpsLatencyProblem value);

public:
    // optional int64 latency_ms = 3;
    bool has_latency_ms() const;

private:
    bool _internal_has_latency_ms() const;

public:
    void clear_latency_ms();
    int64_t latency_ms() const;
    void set_latency_ms(int64_t value);

private:
    int64_t _internal_latency_ms() const;
    void _internal_set_latency_ms(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.HttpsLatencyRoutineData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int verdict_;
        int problem_;
        int64_t latency_ms_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class BandwidthData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.BandwidthData) */ {
public:
    inline BandwidthData()
        : BandwidthData(nullptr)
    {
    }
    ~BandwidthData() override;
    explicit PROTOBUF_CONSTEXPR BandwidthData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    BandwidthData(const BandwidthData& from);
    BandwidthData(BandwidthData&& from) noexcept
        : BandwidthData()
    {
        *this = ::std::move(from);
    }

    inline BandwidthData& operator=(const BandwidthData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline BandwidthData& operator=(BandwidthData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const BandwidthData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const BandwidthData* internal_default_instance()
    {
        return reinterpret_cast<const BandwidthData*>(&_BandwidthData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(BandwidthData& a, BandwidthData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(BandwidthData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(BandwidthData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    BandwidthData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<BandwidthData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const BandwidthData& from);
    void MergeFrom(const BandwidthData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(BandwidthData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.BandwidthData";
    }

protected:
    explicit BandwidthData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDownloadSpeedKbpsFieldNumber = 1,
        kUploadSpeedKbpsFieldNumber = 2,
    };
    // optional int64 download_speed_kbps = 1;
    bool has_download_speed_kbps() const;

private:
    bool _internal_has_download_speed_kbps() const;

public:
    void clear_download_speed_kbps();
    int64_t download_speed_kbps() const;
    void set_download_speed_kbps(int64_t value);

private:
    int64_t _internal_download_speed_kbps() const;
    void _internal_set_download_speed_kbps(int64_t value);

public:
    // optional int64 upload_speed_kbps = 2;
    bool has_upload_speed_kbps() const;

private:
    bool _internal_has_upload_speed_kbps() const;

public:
    void clear_upload_speed_kbps();
    int64_t upload_speed_kbps() const;
    void set_upload_speed_kbps(int64_t value);

private:
    int64_t _internal_upload_speed_kbps() const;
    void _internal_set_upload_speed_kbps(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.BandwidthData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int64_t download_speed_kbps_;
        int64_t upload_speed_kbps_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class NetworkTelemetry final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.NetworkTelemetry) */ {
public:
    inline NetworkTelemetry()
        : NetworkTelemetry(nullptr)
    {
    }
    ~NetworkTelemetry() override;
    explicit PROTOBUF_CONSTEXPR NetworkTelemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    NetworkTelemetry(const NetworkTelemetry& from);
    NetworkTelemetry(NetworkTelemetry&& from) noexcept
        : NetworkTelemetry()
    {
        *this = ::std::move(from);
    }

    inline NetworkTelemetry& operator=(const NetworkTelemetry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline NetworkTelemetry& operator=(NetworkTelemetry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const NetworkTelemetry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const NetworkTelemetry* internal_default_instance()
    {
        return reinterpret_cast<const NetworkTelemetry*>(&_NetworkTelemetry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(NetworkTelemetry& a, NetworkTelemetry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(NetworkTelemetry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(NetworkTelemetry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    NetworkTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<NetworkTelemetry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const NetworkTelemetry& from);
    void MergeFrom(const NetworkTelemetry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(NetworkTelemetry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.NetworkTelemetry";
    }

protected:
    explicit NetworkTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kGuidFieldNumber = 1,
        kDevicePathFieldNumber = 4,
        kIpAddressFieldNumber = 5,
        kGatewayFieldNumber = 6,
        kConnectionStateFieldNumber = 2,
        kSignalStrengthFieldNumber = 3,
        kTxBitRateMbpsFieldNumber = 9,
        kTypeFieldNumber = 7,
        kTxPowerDbmFieldNumber = 11,
        kRxBitRateMbpsFieldNumber = 10,
        kLinkQualityFieldNumber = 13,
        kEncryptionOnFieldNumber = 12,
        kPowerManagementEnabledFieldNumber = 14,
        kSignalStrengthDbmFieldNumber = 15,
    };
    // optional string guid = 1;
    bool has_guid() const;

private:
    bool _internal_has_guid() const;

public:
    void clear_guid();
    const std::string& guid() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_guid(ArgT0&& arg0, ArgT... args);
    std::string* mutable_guid();
    PROTOBUF_NODISCARD std::string* release_guid();
    void set_allocated_guid(std::string* guid);

private:
    const std::string& _internal_guid() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_guid(const std::string& value);
    std::string* _internal_mutable_guid();

public:
    // optional string device_path = 4;
    bool has_device_path() const;

private:
    bool _internal_has_device_path() const;

public:
    void clear_device_path();
    const std::string& device_path() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_device_path(ArgT0&& arg0, ArgT... args);
    std::string* mutable_device_path();
    PROTOBUF_NODISCARD std::string* release_device_path();
    void set_allocated_device_path(std::string* device_path);

private:
    const std::string& _internal_device_path() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_path(const std::string& value);
    std::string* _internal_mutable_device_path();

public:
    // optional string ip_address = 5;
    bool has_ip_address() const;

private:
    bool _internal_has_ip_address() const;

public:
    void clear_ip_address();
    const std::string& ip_address() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_ip_address(ArgT0&& arg0, ArgT... args);
    std::string* mutable_ip_address();
    PROTOBUF_NODISCARD std::string* release_ip_address();
    void set_allocated_ip_address(std::string* ip_address);

private:
    const std::string& _internal_ip_address() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
    std::string* _internal_mutable_ip_address();

public:
    // optional string gateway = 6;
    bool has_gateway() const;

private:
    bool _internal_has_gateway() const;

public:
    void clear_gateway();
    const std::string& gateway() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_gateway(ArgT0&& arg0, ArgT... args);
    std::string* mutable_gateway();
    PROTOBUF_NODISCARD std::string* release_gateway();
    void set_allocated_gateway(std::string* gateway);

private:
    const std::string& _internal_gateway() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(const std::string& value);
    std::string* _internal_mutable_gateway();

public:
    // optional .reporting.NetworkConnectionState connection_state = 2;
    bool has_connection_state() const;

private:
    bool _internal_has_connection_state() const;

public:
    void clear_connection_state();
    ::reporting::NetworkConnectionState connection_state() const;
    void set_connection_state(::reporting::NetworkConnectionState value);

private:
    ::reporting::NetworkConnectionState _internal_connection_state() const;
    void _internal_set_connection_state(::reporting::NetworkConnectionState value);

public:
    // optional int32 signal_strength = 3;
    bool has_signal_strength() const;

private:
    bool _internal_has_signal_strength() const;

public:
    void clear_signal_strength();
    int32_t signal_strength() const;
    void set_signal_strength(int32_t value);

private:
    int32_t _internal_signal_strength() const;
    void _internal_set_signal_strength(int32_t value);

public:
    // optional int64 tx_bit_rate_mbps = 9;
    bool has_tx_bit_rate_mbps() const;

private:
    bool _internal_has_tx_bit_rate_mbps() const;

public:
    void clear_tx_bit_rate_mbps();
    int64_t tx_bit_rate_mbps() const;
    void set_tx_bit_rate_mbps(int64_t value);

private:
    int64_t _internal_tx_bit_rate_mbps() const;
    void _internal_set_tx_bit_rate_mbps(int64_t value);

public:
    // optional .reporting.NetworkType type = 7;
    bool has_type() const;

private:
    bool _internal_has_type() const;

public:
    void clear_type();
    ::reporting::NetworkType type() const;
    void set_type(::reporting::NetworkType value);

private:
    ::reporting::NetworkType _internal_type() const;
    void _internal_set_type(::reporting::NetworkType value);

public:
    // optional int32 tx_power_dbm = 11;
    bool has_tx_power_dbm() const;

private:
    bool _internal_has_tx_power_dbm() const;

public:
    void clear_tx_power_dbm();
    int32_t tx_power_dbm() const;
    void set_tx_power_dbm(int32_t value);

private:
    int32_t _internal_tx_power_dbm() const;
    void _internal_set_tx_power_dbm(int32_t value);

public:
    // optional int64 rx_bit_rate_mbps = 10;
    bool has_rx_bit_rate_mbps() const;

private:
    bool _internal_has_rx_bit_rate_mbps() const;

public:
    void clear_rx_bit_rate_mbps();
    int64_t rx_bit_rate_mbps() const;
    void set_rx_bit_rate_mbps(int64_t value);

private:
    int64_t _internal_rx_bit_rate_mbps() const;
    void _internal_set_rx_bit_rate_mbps(int64_t value);

public:
    // optional int64 link_quality = 13;
    bool has_link_quality() const;

private:
    bool _internal_has_link_quality() const;

public:
    void clear_link_quality();
    int64_t link_quality() const;
    void set_link_quality(int64_t value);

private:
    int64_t _internal_link_quality() const;
    void _internal_set_link_quality(int64_t value);

public:
    // optional bool encryption_on = 12;
    bool has_encryption_on() const;

private:
    bool _internal_has_encryption_on() const;

public:
    void clear_encryption_on();
    bool encryption_on() const;
    void set_encryption_on(bool value);

private:
    bool _internal_encryption_on() const;
    void _internal_set_encryption_on(bool value);

public:
    // optional bool power_management_enabled = 14;
    bool has_power_management_enabled() const;

private:
    bool _internal_has_power_management_enabled() const;

public:
    void clear_power_management_enabled();
    bool power_management_enabled() const;
    void set_power_management_enabled(bool value);

private:
    bool _internal_power_management_enabled() const;
    void _internal_set_power_management_enabled(bool value);

public:
    // optional int32 signal_strength_dbm = 15;
    bool has_signal_strength_dbm() const;

private:
    bool _internal_has_signal_strength_dbm() const;

public:
    void clear_signal_strength_dbm();
    int32_t signal_strength_dbm() const;
    void set_signal_strength_dbm(int32_t value);

private:
    int32_t _internal_signal_strength_dbm() const;
    void _internal_set_signal_strength_dbm(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.NetworkTelemetry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_path_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_;
        int connection_state_;
        int32_t signal_strength_;
        int64_t tx_bit_rate_mbps_;
        int type_;
        int32_t tx_power_dbm_;
        int64_t rx_bit_rate_mbps_;
        int64_t link_quality_;
        bool encryption_on_;
        bool power_management_enabled_;
        int32_t signal_strength_dbm_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class NetworkConnectionStateChangeEventData final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.NetworkConnectionStateChangeEventData) */ {
public:
    inline NetworkConnectionStateChangeEventData()
        : NetworkConnectionStateChangeEventData(nullptr)
    {
    }
    ~NetworkConnectionStateChangeEventData() override;
    explicit PROTOBUF_CONSTEXPR NetworkConnectionStateChangeEventData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    NetworkConnectionStateChangeEventData(const NetworkConnectionStateChangeEventData& from);
    NetworkConnectionStateChangeEventData(NetworkConnectionStateChangeEventData&& from) noexcept
        : NetworkConnectionStateChangeEventData()
    {
        *this = ::std::move(from);
    }

    inline NetworkConnectionStateChangeEventData& operator=(const NetworkConnectionStateChangeEventData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline NetworkConnectionStateChangeEventData& operator=(NetworkConnectionStateChangeEventData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const NetworkConnectionStateChangeEventData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const NetworkConnectionStateChangeEventData* internal_default_instance()
    {
        return reinterpret_cast<const NetworkConnectionStateChangeEventData*>(&_NetworkConnectionStateChangeEventData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(NetworkConnectionStateChangeEventData& a, NetworkConnectionStateChangeEventData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(NetworkConnectionStateChangeEventData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(NetworkConnectionStateChangeEventData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    NetworkConnectionStateChangeEventData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<NetworkConnectionStateChangeEventData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const NetworkConnectionStateChangeEventData& from);
    void MergeFrom(const NetworkConnectionStateChangeEventData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(NetworkConnectionStateChangeEventData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.NetworkConnectionStateChangeEventData";
    }

protected:
    explicit NetworkConnectionStateChangeEventData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kGuidFieldNumber = 1,
        kConnectionStateFieldNumber = 2,
    };
    // optional string guid = 1;
    bool has_guid() const;

private:
    bool _internal_has_guid() const;

public:
    void clear_guid();
    const std::string& guid() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_guid(ArgT0&& arg0, ArgT... args);
    std::string* mutable_guid();
    PROTOBUF_NODISCARD std::string* release_guid();
    void set_allocated_guid(std::string* guid);

private:
    const std::string& _internal_guid() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_guid(const std::string& value);
    std::string* _internal_mutable_guid();

public:
    // optional .reporting.NetworkConnectionState connection_state = 2;
    bool has_connection_state() const;

private:
    bool _internal_has_connection_state() const;

public:
    void clear_connection_state();
    ::reporting::NetworkConnectionState connection_state() const;
    void set_connection_state(::reporting::NetworkConnectionState value);

private:
    ::reporting::NetworkConnectionState _internal_connection_state() const;
    void _internal_set_connection_state(::reporting::NetworkConnectionState value);

public:
    // @@protoc_insertion_point(class_scope:reporting.NetworkConnectionStateChangeEventData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
        int connection_state_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class SignalStrengthEventData final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.SignalStrengthEventData) */ {
public:
    inline SignalStrengthEventData()
        : SignalStrengthEventData(nullptr)
    {
    }
    ~SignalStrengthEventData() override;
    explicit PROTOBUF_CONSTEXPR SignalStrengthEventData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SignalStrengthEventData(const SignalStrengthEventData& from);
    SignalStrengthEventData(SignalStrengthEventData&& from) noexcept
        : SignalStrengthEventData()
    {
        *this = ::std::move(from);
    }

    inline SignalStrengthEventData& operator=(const SignalStrengthEventData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SignalStrengthEventData& operator=(SignalStrengthEventData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SignalStrengthEventData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SignalStrengthEventData* internal_default_instance()
    {
        return reinterpret_cast<const SignalStrengthEventData*>(&_SignalStrengthEventData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(SignalStrengthEventData& a, SignalStrengthEventData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SignalStrengthEventData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SignalStrengthEventData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SignalStrengthEventData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SignalStrengthEventData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SignalStrengthEventData& from);
    void MergeFrom(const SignalStrengthEventData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SignalStrengthEventData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.SignalStrengthEventData";
    }

protected:
    explicit SignalStrengthEventData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kGuidFieldNumber = 1,
        kSignalStrengthDbmFieldNumber = 2,
    };
    // optional string guid = 1;
    bool has_guid() const;

private:
    bool _internal_has_guid() const;

public:
    void clear_guid();
    const std::string& guid() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_guid(ArgT0&& arg0, ArgT... args);
    std::string* mutable_guid();
    PROTOBUF_NODISCARD std::string* release_guid();
    void set_allocated_guid(std::string* guid);

private:
    const std::string& _internal_guid() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_guid(const std::string& value);
    std::string* _internal_mutable_guid();

public:
    // optional int32 signal_strength_dbm = 2;
    bool has_signal_strength_dbm() const;

private:
    bool _internal_has_signal_strength_dbm() const;

public:
    void clear_signal_strength_dbm();
    int32_t signal_strength_dbm() const;
    void set_signal_strength_dbm(int32_t value);

private:
    int32_t _internal_signal_strength_dbm() const;
    void _internal_set_signal_strength_dbm(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.SignalStrengthEventData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
        int32_t signal_strength_dbm_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class NetworksTelemetry final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.NetworksTelemetry) */ {
public:
    inline NetworksTelemetry()
        : NetworksTelemetry(nullptr)
    {
    }
    ~NetworksTelemetry() override;
    explicit PROTOBUF_CONSTEXPR NetworksTelemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    NetworksTelemetry(const NetworksTelemetry& from);
    NetworksTelemetry(NetworksTelemetry&& from) noexcept
        : NetworksTelemetry()
    {
        *this = ::std::move(from);
    }

    inline NetworksTelemetry& operator=(const NetworksTelemetry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline NetworksTelemetry& operator=(NetworksTelemetry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const NetworksTelemetry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const NetworksTelemetry* internal_default_instance()
    {
        return reinterpret_cast<const NetworksTelemetry*>(&_NetworksTelemetry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(NetworksTelemetry& a, NetworksTelemetry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(NetworksTelemetry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(NetworksTelemetry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    NetworksTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<NetworksTelemetry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const NetworksTelemetry& from);
    void MergeFrom(const NetworksTelemetry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(NetworksTelemetry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.NetworksTelemetry";
    }

protected:
    explicit NetworksTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kNetworkTelemetryFieldNumber = 1,
        kHttpsLatencyDataFieldNumber = 2,
        kBandwidthDataFieldNumber = 3,
        kNetworkConnectionChangeEventDataFieldNumber = 4,
        kSignalStrengthEventDataFieldNumber = 5,
    };
    // repeated .reporting.NetworkTelemetry network_telemetry = 1;
    int network_telemetry_size() const;

private:
    int _internal_network_telemetry_size() const;

public:
    void clear_network_telemetry();
    ::reporting::NetworkTelemetry* mutable_network_telemetry(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::NetworkTelemetry>* mutable_network_telemetry();

private:
    const ::reporting::NetworkTelemetry& _internal_network_telemetry(int index) const;
    ::reporting::NetworkTelemetry* _internal_add_network_telemetry();

public:
    const ::reporting::NetworkTelemetry& network_telemetry(int index) const;
    ::reporting::NetworkTelemetry* add_network_telemetry();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::NetworkTelemetry>& network_telemetry() const;

    // optional .reporting.HttpsLatencyRoutineData https_latency_data = 2;
    bool has_https_latency_data() const;

private:
    bool _internal_has_https_latency_data() const;

public:
    void clear_https_latency_data();
    const ::reporting::HttpsLatencyRoutineData& https_latency_data() const;
    PROTOBUF_NODISCARD ::reporting::HttpsLatencyRoutineData* release_https_latency_data();
    ::reporting::HttpsLatencyRoutineData* mutable_https_latency_data();
    void set_allocated_https_latency_data(::reporting::HttpsLatencyRoutineData* https_latency_data);

private:
    const ::reporting::HttpsLatencyRoutineData& _internal_https_latency_data() const;
    ::reporting::HttpsLatencyRoutineData* _internal_mutable_https_latency_data();

public:
    void unsafe_arena_set_allocated_https_latency_data(::reporting::HttpsLatencyRoutineData* https_latency_data);
    ::reporting::HttpsLatencyRoutineData* unsafe_arena_release_https_latency_data();

    // optional .reporting.BandwidthData bandwidth_data = 3;
    bool has_bandwidth_data() const;

private:
    bool _internal_has_bandwidth_data() const;

public:
    void clear_bandwidth_data();
    const ::reporting::BandwidthData& bandwidth_data() const;
    PROTOBUF_NODISCARD ::reporting::BandwidthData* release_bandwidth_data();
    ::reporting::BandwidthData* mutable_bandwidth_data();
    void set_allocated_bandwidth_data(::reporting::BandwidthData* bandwidth_data);

private:
    const ::reporting::BandwidthData& _internal_bandwidth_data() const;
    ::reporting::BandwidthData* _internal_mutable_bandwidth_data();

public:
    void unsafe_arena_set_allocated_bandwidth_data(::reporting::BandwidthData* bandwidth_data);
    ::reporting::BandwidthData* unsafe_arena_release_bandwidth_data();

    // optional .reporting.NetworkConnectionStateChangeEventData network_connection_change_event_data = 4;
    bool has_network_connection_change_event_data() const;

private:
    bool _internal_has_network_connection_change_event_data() const;

public:
    void clear_network_connection_change_event_data();
    const ::reporting::NetworkConnectionStateChangeEventData& network_connection_change_event_data() const;
    PROTOBUF_NODISCARD ::reporting::NetworkConnectionStateChangeEventData* release_network_connection_change_event_data();
    ::reporting::NetworkConnectionStateChangeEventData* mutable_network_connection_change_event_data();
    void set_allocated_network_connection_change_event_data(::reporting::NetworkConnectionStateChangeEventData* network_connection_change_event_data);

private:
    const ::reporting::NetworkConnectionStateChangeEventData& _internal_network_connection_change_event_data() const;
    ::reporting::NetworkConnectionStateChangeEventData* _internal_mutable_network_connection_change_event_data();

public:
    void unsafe_arena_set_allocated_network_connection_change_event_data(
        ::reporting::NetworkConnectionStateChangeEventData* network_connection_change_event_data);
    ::reporting::NetworkConnectionStateChangeEventData* unsafe_arena_release_network_connection_change_event_data();

    // optional .reporting.SignalStrengthEventData signal_strength_event_data = 5;
    bool has_signal_strength_event_data() const;

private:
    bool _internal_has_signal_strength_event_data() const;

public:
    void clear_signal_strength_event_data();
    const ::reporting::SignalStrengthEventData& signal_strength_event_data() const;
    PROTOBUF_NODISCARD ::reporting::SignalStrengthEventData* release_signal_strength_event_data();
    ::reporting::SignalStrengthEventData* mutable_signal_strength_event_data();
    void set_allocated_signal_strength_event_data(::reporting::SignalStrengthEventData* signal_strength_event_data);

private:
    const ::reporting::SignalStrengthEventData& _internal_signal_strength_event_data() const;
    ::reporting::SignalStrengthEventData* _internal_mutable_signal_strength_event_data();

public:
    void unsafe_arena_set_allocated_signal_strength_event_data(::reporting::SignalStrengthEventData* signal_strength_event_data);
    ::reporting::SignalStrengthEventData* unsafe_arena_release_signal_strength_event_data();

    // @@protoc_insertion_point(class_scope:reporting.NetworksTelemetry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::NetworkTelemetry> network_telemetry_;
        ::reporting::HttpsLatencyRoutineData* https_latency_data_;
        ::reporting::BandwidthData* bandwidth_data_;
        ::reporting::NetworkConnectionStateChangeEventData* network_connection_change_event_data_;
        ::reporting::SignalStrengthEventData* signal_strength_event_data_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ThunderboltInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.ThunderboltInfo) */ {
public:
    inline ThunderboltInfo()
        : ThunderboltInfo(nullptr)
    {
    }
    ~ThunderboltInfo() override;
    explicit PROTOBUF_CONSTEXPR ThunderboltInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ThunderboltInfo(const ThunderboltInfo& from);
    ThunderboltInfo(ThunderboltInfo&& from) noexcept
        : ThunderboltInfo()
    {
        *this = ::std::move(from);
    }

    inline ThunderboltInfo& operator=(const ThunderboltInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ThunderboltInfo& operator=(ThunderboltInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ThunderboltInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ThunderboltInfo* internal_default_instance()
    {
        return reinterpret_cast<const ThunderboltInfo*>(&_ThunderboltInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(ThunderboltInfo& a, ThunderboltInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ThunderboltInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ThunderboltInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ThunderboltInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ThunderboltInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ThunderboltInfo& from);
    void MergeFrom(const ThunderboltInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ThunderboltInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.ThunderboltInfo";
    }

protected:
    explicit ThunderboltInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSecurityLevelFieldNumber = 1,
    };
    // optional .reporting.ThunderboltSecurityLevel security_level = 1;
    bool has_security_level() const;

private:
    bool _internal_has_security_level() const;

public:
    void clear_security_level();
    ::reporting::ThunderboltSecurityLevel security_level() const;
    void set_security_level(::reporting::ThunderboltSecurityLevel value);

private:
    ::reporting::ThunderboltSecurityLevel _internal_security_level() const;
    void _internal_set_security_level(::reporting::ThunderboltSecurityLevel value);

public:
    // @@protoc_insertion_point(class_scope:reporting.ThunderboltInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int security_level_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class BusDeviceInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.BusDeviceInfo) */ {
public:
    inline BusDeviceInfo()
        : BusDeviceInfo(nullptr)
    {
    }
    ~BusDeviceInfo() override;
    explicit PROTOBUF_CONSTEXPR BusDeviceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    BusDeviceInfo(const BusDeviceInfo& from);
    BusDeviceInfo(BusDeviceInfo&& from) noexcept
        : BusDeviceInfo()
    {
        *this = ::std::move(from);
    }

    inline BusDeviceInfo& operator=(const BusDeviceInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline BusDeviceInfo& operator=(BusDeviceInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const BusDeviceInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const BusDeviceInfo* internal_default_instance()
    {
        return reinterpret_cast<const BusDeviceInfo*>(&_BusDeviceInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(BusDeviceInfo& a, BusDeviceInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(BusDeviceInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(BusDeviceInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    BusDeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<BusDeviceInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const BusDeviceInfo& from);
    void MergeFrom(const BusDeviceInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(BusDeviceInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.BusDeviceInfo";
    }

protected:
    explicit BusDeviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kThunderboltInfoFieldNumber = 1,
    };
    // repeated .reporting.ThunderboltInfo thunderbolt_info = 1;
    int thunderbolt_info_size() const;

private:
    int _internal_thunderbolt_info_size() const;

public:
    void clear_thunderbolt_info();
    ::reporting::ThunderboltInfo* mutable_thunderbolt_info(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::ThunderboltInfo>* mutable_thunderbolt_info();

private:
    const ::reporting::ThunderboltInfo& _internal_thunderbolt_info(int index) const;
    ::reporting::ThunderboltInfo* _internal_add_thunderbolt_info();

public:
    const ::reporting::ThunderboltInfo& thunderbolt_info(int index) const;
    ::reporting::ThunderboltInfo* add_thunderbolt_info();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::ThunderboltInfo>& thunderbolt_info() const;

    // @@protoc_insertion_point(class_scope:reporting.BusDeviceInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::ThunderboltInfo> thunderbolt_info_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class TotalMemoryEncryptionInfo final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.TotalMemoryEncryptionInfo) */ {
public:
    inline TotalMemoryEncryptionInfo()
        : TotalMemoryEncryptionInfo(nullptr)
    {
    }
    ~TotalMemoryEncryptionInfo() override;
    explicit PROTOBUF_CONSTEXPR TotalMemoryEncryptionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TotalMemoryEncryptionInfo(const TotalMemoryEncryptionInfo& from);
    TotalMemoryEncryptionInfo(TotalMemoryEncryptionInfo&& from) noexcept
        : TotalMemoryEncryptionInfo()
    {
        *this = ::std::move(from);
    }

    inline TotalMemoryEncryptionInfo& operator=(const TotalMemoryEncryptionInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TotalMemoryEncryptionInfo& operator=(TotalMemoryEncryptionInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const TotalMemoryEncryptionInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const TotalMemoryEncryptionInfo* internal_default_instance()
    {
        return reinterpret_cast<const TotalMemoryEncryptionInfo*>(&_TotalMemoryEncryptionInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(TotalMemoryEncryptionInfo& a, TotalMemoryEncryptionInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TotalMemoryEncryptionInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TotalMemoryEncryptionInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TotalMemoryEncryptionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TotalMemoryEncryptionInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TotalMemoryEncryptionInfo& from);
    void MergeFrom(const TotalMemoryEncryptionInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TotalMemoryEncryptionInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.TotalMemoryEncryptionInfo";
    }

protected:
    explicit TotalMemoryEncryptionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kMaxKeysFieldNumber = 2,
        kEncryptionStateFieldNumber = 1,
        kEncryptionAlgorithmFieldNumber = 4,
        kKeyLengthFieldNumber = 3,
    };
    // optional int64 max_keys = 2;
    bool has_max_keys() const;

private:
    bool _internal_has_max_keys() const;

public:
    void clear_max_keys();
    int64_t max_keys() const;
    void set_max_keys(int64_t value);

private:
    int64_t _internal_max_keys() const;
    void _internal_set_max_keys(int64_t value);

public:
    // optional .reporting.MemoryEncryptionState encryption_state = 1;
    bool has_encryption_state() const;

private:
    bool _internal_has_encryption_state() const;

public:
    void clear_encryption_state();
    ::reporting::MemoryEncryptionState encryption_state() const;
    void set_encryption_state(::reporting::MemoryEncryptionState value);

private:
    ::reporting::MemoryEncryptionState _internal_encryption_state() const;
    void _internal_set_encryption_state(::reporting::MemoryEncryptionState value);

public:
    // optional .reporting.MemoryEncryptionAlgorithm encryption_algorithm = 4;
    bool has_encryption_algorithm() const;

private:
    bool _internal_has_encryption_algorithm() const;

public:
    void clear_encryption_algorithm();
    ::reporting::MemoryEncryptionAlgorithm encryption_algorithm() const;
    void set_encryption_algorithm(::reporting::MemoryEncryptionAlgorithm value);

private:
    ::reporting::MemoryEncryptionAlgorithm _internal_encryption_algorithm() const;
    void _internal_set_encryption_algorithm(::reporting::MemoryEncryptionAlgorithm value);

public:
    // optional int64 key_length = 3;
    bool has_key_length() const;

private:
    bool _internal_has_key_length() const;

public:
    void clear_key_length();
    int64_t key_length() const;
    void set_key_length(int64_t value);

private:
    int64_t _internal_key_length() const;
    void _internal_set_key_length(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.TotalMemoryEncryptionInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int64_t max_keys_;
        int encryption_state_;
        int encryption_algorithm_;
        int64_t key_length_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class MemoryInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.MemoryInfo) */ {
public:
    inline MemoryInfo()
        : MemoryInfo(nullptr)
    {
    }
    ~MemoryInfo() override;
    explicit PROTOBUF_CONSTEXPR MemoryInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    MemoryInfo(const MemoryInfo& from);
    MemoryInfo(MemoryInfo&& from) noexcept
        : MemoryInfo()
    {
        *this = ::std::move(from);
    }

    inline MemoryInfo& operator=(const MemoryInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline MemoryInfo& operator=(MemoryInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const MemoryInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const MemoryInfo* internal_default_instance()
    {
        return reinterpret_cast<const MemoryInfo*>(&_MemoryInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(MemoryInfo& a, MemoryInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(MemoryInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(MemoryInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    MemoryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<MemoryInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const MemoryInfo& from);
    void MergeFrom(const MemoryInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(MemoryInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.MemoryInfo";
    }

protected:
    explicit MemoryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTmeInfoFieldNumber = 1,
    };
    // optional .reporting.TotalMemoryEncryptionInfo tme_info = 1;
    bool has_tme_info() const;

private:
    bool _internal_has_tme_info() const;

public:
    void clear_tme_info();
    const ::reporting::TotalMemoryEncryptionInfo& tme_info() const;
    PROTOBUF_NODISCARD ::reporting::TotalMemoryEncryptionInfo* release_tme_info();
    ::reporting::TotalMemoryEncryptionInfo* mutable_tme_info();
    void set_allocated_tme_info(::reporting::TotalMemoryEncryptionInfo* tme_info);

private:
    const ::reporting::TotalMemoryEncryptionInfo& _internal_tme_info() const;
    ::reporting::TotalMemoryEncryptionInfo* _internal_mutable_tme_info();

public:
    void unsafe_arena_set_allocated_tme_info(::reporting::TotalMemoryEncryptionInfo* tme_info);
    ::reporting::TotalMemoryEncryptionInfo* unsafe_arena_release_tme_info();

    // @@protoc_insertion_point(class_scope:reporting.MemoryInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::reporting::TotalMemoryEncryptionInfo* tme_info_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class NetworkInterface final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.NetworkInterface) */ {
public:
    inline NetworkInterface()
        : NetworkInterface(nullptr)
    {
    }
    ~NetworkInterface() override;
    explicit PROTOBUF_CONSTEXPR NetworkInterface(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    NetworkInterface(const NetworkInterface& from);
    NetworkInterface(NetworkInterface&& from) noexcept
        : NetworkInterface()
    {
        *this = ::std::move(from);
    }

    inline NetworkInterface& operator=(const NetworkInterface& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline NetworkInterface& operator=(NetworkInterface&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const NetworkInterface& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const NetworkInterface* internal_default_instance()
    {
        return reinterpret_cast<const NetworkInterface*>(&_NetworkInterface_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 10;

    friend void swap(NetworkInterface& a, NetworkInterface& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(NetworkInterface* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(NetworkInterface* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    NetworkInterface* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<NetworkInterface>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const NetworkInterface& from);
    void MergeFrom(const NetworkInterface& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(NetworkInterface* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.NetworkInterface";
    }

protected:
    explicit NetworkInterface(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kEidsFieldNumber = 8,
        kMacAddressFieldNumber = 2,
        kMeidFieldNumber = 3,
        kImeiFieldNumber = 4,
        kDevicePathFieldNumber = 5,
        kIccidFieldNumber = 6,
        kMdnFieldNumber = 7,
        kTypeFieldNumber = 1,
    };
    // repeated string eids = 8;
    int eids_size() const;

private:
    int _internal_eids_size() const;

public:
    void clear_eids();
    const std::string& eids(int index) const;
    std::string* mutable_eids(int index);
    void set_eids(int index, const std::string& value);
    void set_eids(int index, std::string&& value);
    void set_eids(int index, const char* value);
    void set_eids(int index, const char* value, size_t size);
    std::string* add_eids();
    void add_eids(const std::string& value);
    void add_eids(std::string&& value);
    void add_eids(const char* value);
    void add_eids(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& eids() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_eids();

private:
    const std::string& _internal_eids(int index) const;
    std::string* _internal_add_eids();

public:
    // optional string mac_address = 2;
    bool has_mac_address() const;

private:
    bool _internal_has_mac_address() const;

public:
    void clear_mac_address();
    const std::string& mac_address() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_mac_address(ArgT0&& arg0, ArgT... args);
    std::string* mutable_mac_address();
    PROTOBUF_NODISCARD std::string* release_mac_address();
    void set_allocated_mac_address(std::string* mac_address);

private:
    const std::string& _internal_mac_address() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
    std::string* _internal_mutable_mac_address();

public:
    // optional string meid = 3;
    bool has_meid() const;

private:
    bool _internal_has_meid() const;

public:
    void clear_meid();
    const std::string& meid() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_meid(ArgT0&& arg0, ArgT... args);
    std::string* mutable_meid();
    PROTOBUF_NODISCARD std::string* release_meid();
    void set_allocated_meid(std::string* meid);

private:
    const std::string& _internal_meid() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_meid(const std::string& value);
    std::string* _internal_mutable_meid();

public:
    // optional string imei = 4;
    bool has_imei() const;

private:
    bool _internal_has_imei() const;

public:
    void clear_imei();
    const std::string& imei() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_imei(ArgT0&& arg0, ArgT... args);
    std::string* mutable_imei();
    PROTOBUF_NODISCARD std::string* release_imei();
    void set_allocated_imei(std::string* imei);

private:
    const std::string& _internal_imei() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_imei(const std::string& value);
    std::string* _internal_mutable_imei();

public:
    // optional string device_path = 5;
    bool has_device_path() const;

private:
    bool _internal_has_device_path() const;

public:
    void clear_device_path();
    const std::string& device_path() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_device_path(ArgT0&& arg0, ArgT... args);
    std::string* mutable_device_path();
    PROTOBUF_NODISCARD std::string* release_device_path();
    void set_allocated_device_path(std::string* device_path);

private:
    const std::string& _internal_device_path() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_path(const std::string& value);
    std::string* _internal_mutable_device_path();

public:
    // optional string iccid = 6;
    bool has_iccid() const;

private:
    bool _internal_has_iccid() const;

public:
    void clear_iccid();
    const std::string& iccid() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_iccid(ArgT0&& arg0, ArgT... args);
    std::string* mutable_iccid();
    PROTOBUF_NODISCARD std::string* release_iccid();
    void set_allocated_iccid(std::string* iccid);

private:
    const std::string& _internal_iccid() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_iccid(const std::string& value);
    std::string* _internal_mutable_iccid();

public:
    // optional string mdn = 7;
    bool has_mdn() const;

private:
    bool _internal_has_mdn() const;

public:
    void clear_mdn();
    const std::string& mdn() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_mdn(ArgT0&& arg0, ArgT... args);
    std::string* mutable_mdn();
    PROTOBUF_NODISCARD std::string* release_mdn();
    void set_allocated_mdn(std::string* mdn);

private:
    const std::string& _internal_mdn() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_mdn(const std::string& value);
    std::string* _internal_mutable_mdn();

public:
    // optional .reporting.NetworkDeviceType type = 1;
    bool has_type() const;

private:
    bool _internal_has_type() const;

public:
    void clear_type();
    ::reporting::NetworkDeviceType type() const;
    void set_type(::reporting::NetworkDeviceType value);

private:
    ::reporting::NetworkDeviceType _internal_type() const;
    void _internal_set_type(::reporting::NetworkDeviceType value);

public:
    // @@protoc_insertion_point(class_scope:reporting.NetworkInterface)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> eids_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meid_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imei_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_path_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iccid_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mdn_;
        int type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class NetworksInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.NetworksInfo) */ {
public:
    inline NetworksInfo()
        : NetworksInfo(nullptr)
    {
    }
    ~NetworksInfo() override;
    explicit PROTOBUF_CONSTEXPR NetworksInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    NetworksInfo(const NetworksInfo& from);
    NetworksInfo(NetworksInfo&& from) noexcept
        : NetworksInfo()
    {
        *this = ::std::move(from);
    }

    inline NetworksInfo& operator=(const NetworksInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline NetworksInfo& operator=(NetworksInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const NetworksInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const NetworksInfo* internal_default_instance()
    {
        return reinterpret_cast<const NetworksInfo*>(&_NetworksInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 11;

    friend void swap(NetworksInfo& a, NetworksInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(NetworksInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(NetworksInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    NetworksInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<NetworksInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const NetworksInfo& from);
    void MergeFrom(const NetworksInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(NetworksInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.NetworksInfo";
    }

protected:
    explicit NetworksInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kNetworkInterfacesFieldNumber = 1,
    };
    // repeated .reporting.NetworkInterface network_interfaces = 1;
    int network_interfaces_size() const;

private:
    int _internal_network_interfaces_size() const;

public:
    void clear_network_interfaces();
    ::reporting::NetworkInterface* mutable_network_interfaces(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::NetworkInterface>* mutable_network_interfaces();

private:
    const ::reporting::NetworkInterface& _internal_network_interfaces(int index) const;
    ::reporting::NetworkInterface* _internal_add_network_interfaces();

public:
    const ::reporting::NetworkInterface& network_interfaces(int index) const;
    ::reporting::NetworkInterface* add_network_interfaces();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::NetworkInterface>& network_interfaces() const;

    // @@protoc_insertion_point(class_scope:reporting.NetworksInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::NetworkInterface> network_interfaces_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class TouchScreenInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.TouchScreenInfo) */ {
public:
    inline TouchScreenInfo()
        : TouchScreenInfo(nullptr)
    {
    }
    ~TouchScreenInfo() override;
    explicit PROTOBUF_CONSTEXPR TouchScreenInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TouchScreenInfo(const TouchScreenInfo& from);
    TouchScreenInfo(TouchScreenInfo&& from) noexcept
        : TouchScreenInfo()
    {
        *this = ::std::move(from);
    }

    inline TouchScreenInfo& operator=(const TouchScreenInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TouchScreenInfo& operator=(TouchScreenInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const TouchScreenInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const TouchScreenInfo* internal_default_instance()
    {
        return reinterpret_cast<const TouchScreenInfo*>(&_TouchScreenInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 12;

    friend void swap(TouchScreenInfo& a, TouchScreenInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TouchScreenInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TouchScreenInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TouchScreenInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TouchScreenInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TouchScreenInfo& from);
    void MergeFrom(const TouchScreenInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TouchScreenInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.TouchScreenInfo";
    }

protected:
    explicit TouchScreenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTouchScreenDevicesFieldNumber = 2,
        kLibraryNameFieldNumber = 1,
    };
    // repeated .reporting.TouchScreenDevice touch_screen_devices = 2;
    int touch_screen_devices_size() const;

private:
    int _internal_touch_screen_devices_size() const;

public:
    void clear_touch_screen_devices();
    ::reporting::TouchScreenDevice* mutable_touch_screen_devices(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::TouchScreenDevice>* mutable_touch_screen_devices();

private:
    const ::reporting::TouchScreenDevice& _internal_touch_screen_devices(int index) const;
    ::reporting::TouchScreenDevice* _internal_add_touch_screen_devices();

public:
    const ::reporting::TouchScreenDevice& touch_screen_devices(int index) const;
    ::reporting::TouchScreenDevice* add_touch_screen_devices();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::TouchScreenDevice>& touch_screen_devices() const;

    // optional string library_name = 1;
    bool has_library_name() const;

private:
    bool _internal_has_library_name() const;

public:
    void clear_library_name();
    const std::string& library_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_library_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_library_name();
    PROTOBUF_NODISCARD std::string* release_library_name();
    void set_allocated_library_name(std::string* library_name);

private:
    const std::string& _internal_library_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_library_name(const std::string& value);
    std::string* _internal_mutable_library_name();

public:
    // @@protoc_insertion_point(class_scope:reporting.TouchScreenInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::TouchScreenDevice> touch_screen_devices_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr library_name_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class TouchScreenDevice final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.TouchScreenDevice) */ {
public:
    inline TouchScreenDevice()
        : TouchScreenDevice(nullptr)
    {
    }
    ~TouchScreenDevice() override;
    explicit PROTOBUF_CONSTEXPR TouchScreenDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TouchScreenDevice(const TouchScreenDevice& from);
    TouchScreenDevice(TouchScreenDevice&& from) noexcept
        : TouchScreenDevice()
    {
        *this = ::std::move(from);
    }

    inline TouchScreenDevice& operator=(const TouchScreenDevice& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TouchScreenDevice& operator=(TouchScreenDevice&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const TouchScreenDevice& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const TouchScreenDevice* internal_default_instance()
    {
        return reinterpret_cast<const TouchScreenDevice*>(&_TouchScreenDevice_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 13;

    friend void swap(TouchScreenDevice& a, TouchScreenDevice& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TouchScreenDevice* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TouchScreenDevice* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TouchScreenDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TouchScreenDevice>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TouchScreenDevice& from);
    void MergeFrom(const TouchScreenDevice& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TouchScreenDevice* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.TouchScreenDevice";
    }

protected:
    explicit TouchScreenDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDisplayNameFieldNumber = 1,
        kTouchPointsFieldNumber = 2,
        kHasStylusFieldNumber = 3,
    };
    // optional string display_name = 1;
    bool has_display_name() const;

private:
    bool _internal_has_display_name() const;

public:
    void clear_display_name();
    const std::string& display_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_display_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_display_name();
    PROTOBUF_NODISCARD std::string* release_display_name();
    void set_allocated_display_name(std::string* display_name);

private:
    const std::string& _internal_display_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
    std::string* _internal_mutable_display_name();

public:
    // optional int32 touch_points = 2;
    bool has_touch_points() const;

private:
    bool _internal_has_touch_points() const;

public:
    void clear_touch_points();
    int32_t touch_points() const;
    void set_touch_points(int32_t value);

private:
    int32_t _internal_touch_points() const;
    void _internal_set_touch_points(int32_t value);

public:
    // optional bool has_stylus = 3;
    bool has_has_stylus() const;

private:
    bool _internal_has_has_stylus() const;

public:
    void clear_has_stylus();
    bool has_stylus() const;
    void set_has_stylus(bool value);

private:
    bool _internal_has_stylus() const;
    void _internal_set_has_stylus(bool value);

public:
    // @@protoc_insertion_point(class_scope:reporting.TouchScreenDevice)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
        int32_t touch_points_;
        bool has_stylus_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PrivacyScreenInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.PrivacyScreenInfo) */ {
public:
    inline PrivacyScreenInfo()
        : PrivacyScreenInfo(nullptr)
    {
    }
    ~PrivacyScreenInfo() override;
    explicit PROTOBUF_CONSTEXPR PrivacyScreenInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PrivacyScreenInfo(const PrivacyScreenInfo& from);
    PrivacyScreenInfo(PrivacyScreenInfo&& from) noexcept
        : PrivacyScreenInfo()
    {
        *this = ::std::move(from);
    }

    inline PrivacyScreenInfo& operator=(const PrivacyScreenInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline PrivacyScreenInfo& operator=(PrivacyScreenInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const PrivacyScreenInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const PrivacyScreenInfo* internal_default_instance()
    {
        return reinterpret_cast<const PrivacyScreenInfo*>(&_PrivacyScreenInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 14;

    friend void swap(PrivacyScreenInfo& a, PrivacyScreenInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(PrivacyScreenInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PrivacyScreenInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PrivacyScreenInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<PrivacyScreenInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const PrivacyScreenInfo& from);
    void MergeFrom(const PrivacyScreenInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PrivacyScreenInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.PrivacyScreenInfo";
    }

protected:
    explicit PrivacyScreenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSupportedFieldNumber = 1,
    };
    // optional bool supported = 1;
    bool has_supported() const;

private:
    bool _internal_has_supported() const;

public:
    void clear_supported();
    bool supported() const;
    void set_supported(bool value);

private:
    bool _internal_supported() const;
    void _internal_set_supported(bool value);

public:
    // @@protoc_insertion_point(class_scope:reporting.PrivacyScreenInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        bool supported_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class DisplayInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.DisplayInfo) */ {
public:
    inline DisplayInfo()
        : DisplayInfo(nullptr)
    {
    }
    ~DisplayInfo() override;
    explicit PROTOBUF_CONSTEXPR DisplayInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    DisplayInfo(const DisplayInfo& from);
    DisplayInfo(DisplayInfo&& from) noexcept
        : DisplayInfo()
    {
        *this = ::std::move(from);
    }

    inline DisplayInfo& operator=(const DisplayInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DisplayInfo& operator=(DisplayInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const DisplayInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DisplayInfo* internal_default_instance()
    {
        return reinterpret_cast<const DisplayInfo*>(&_DisplayInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 15;

    friend void swap(DisplayInfo& a, DisplayInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(DisplayInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DisplayInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DisplayInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<DisplayInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const DisplayInfo& from);
    void MergeFrom(const DisplayInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DisplayInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.DisplayInfo";
    }

protected:
    explicit DisplayInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDisplayDeviceFieldNumber = 1,
    };
    // repeated .reporting.DisplayDevice display_device = 1;
    int display_device_size() const;

private:
    int _internal_display_device_size() const;

public:
    void clear_display_device();
    ::reporting::DisplayDevice* mutable_display_device(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::DisplayDevice>* mutable_display_device();

private:
    const ::reporting::DisplayDevice& _internal_display_device(int index) const;
    ::reporting::DisplayDevice* _internal_add_display_device();

public:
    const ::reporting::DisplayDevice& display_device(int index) const;
    ::reporting::DisplayDevice* add_display_device();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::DisplayDevice>& display_device() const;

    // @@protoc_insertion_point(class_scope:reporting.DisplayInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::DisplayDevice> display_device_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class DisplayDevice final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.DisplayDevice) */ {
public:
    inline DisplayDevice()
        : DisplayDevice(nullptr)
    {
    }
    ~DisplayDevice() override;
    explicit PROTOBUF_CONSTEXPR DisplayDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    DisplayDevice(const DisplayDevice& from);
    DisplayDevice(DisplayDevice&& from) noexcept
        : DisplayDevice()
    {
        *this = ::std::move(from);
    }

    inline DisplayDevice& operator=(const DisplayDevice& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DisplayDevice& operator=(DisplayDevice&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const DisplayDevice& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DisplayDevice* internal_default_instance()
    {
        return reinterpret_cast<const DisplayDevice*>(&_DisplayDevice_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 16;

    friend void swap(DisplayDevice& a, DisplayDevice& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(DisplayDevice* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DisplayDevice* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DisplayDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<DisplayDevice>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const DisplayDevice& from);
    void MergeFrom(const DisplayDevice& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DisplayDevice* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.DisplayDevice";
    }

protected:
    explicit DisplayDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDisplayNameFieldNumber = 1,
        kManufacturerFieldNumber = 5,
        kDisplayWidthFieldNumber = 2,
        kDisplayHeightFieldNumber = 3,
        kIsInternalFieldNumber = 4,
        kModelIdFieldNumber = 6,
        kManufactureYearFieldNumber = 7,
    };
    // optional string display_name = 1;
    bool has_display_name() const;

private:
    bool _internal_has_display_name() const;

public:
    void clear_display_name();
    const std::string& display_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_display_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_display_name();
    PROTOBUF_NODISCARD std::string* release_display_name();
    void set_allocated_display_name(std::string* display_name);

private:
    const std::string& _internal_display_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
    std::string* _internal_mutable_display_name();

public:
    // optional string manufacturer = 5;
    bool has_manufacturer() const;

private:
    bool _internal_has_manufacturer() const;

public:
    void clear_manufacturer();
    const std::string& manufacturer() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_manufacturer(ArgT0&& arg0, ArgT... args);
    std::string* mutable_manufacturer();
    PROTOBUF_NODISCARD std::string* release_manufacturer();
    void set_allocated_manufacturer(std::string* manufacturer);

private:
    const std::string& _internal_manufacturer() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacturer(const std::string& value);
    std::string* _internal_mutable_manufacturer();

public:
    // optional int32 display_width = 2;
    bool has_display_width() const;

private:
    bool _internal_has_display_width() const;

public:
    void clear_display_width();
    int32_t display_width() const;
    void set_display_width(int32_t value);

private:
    int32_t _internal_display_width() const;
    void _internal_set_display_width(int32_t value);

public:
    // optional int32 display_height = 3;
    bool has_display_height() const;

private:
    bool _internal_has_display_height() const;

public:
    void clear_display_height();
    int32_t display_height() const;
    void set_display_height(int32_t value);

private:
    int32_t _internal_display_height() const;
    void _internal_set_display_height(int32_t value);

public:
    // optional bool is_internal = 4;
    bool has_is_internal() const;

private:
    bool _internal_has_is_internal() const;

public:
    void clear_is_internal();
    bool is_internal() const;
    void set_is_internal(bool value);

private:
    bool _internal_is_internal() const;
    void _internal_set_is_internal(bool value);

public:
    // optional int32 model_id = 6;
    bool has_model_id() const;

private:
    bool _internal_has_model_id() const;

public:
    void clear_model_id();
    int32_t model_id() const;
    void set_model_id(int32_t value);

private:
    int32_t _internal_model_id() const;
    void _internal_set_model_id(int32_t value);

public:
    // optional int32 manufacture_year = 7;
    bool has_manufacture_year() const;

private:
    bool _internal_has_manufacture_year() const;

public:
    void clear_manufacture_year();
    int32_t manufacture_year() const;
    void set_manufacture_year(int32_t value);

private:
    int32_t _internal_manufacture_year() const;
    void _internal_set_manufacture_year(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.DisplayDevice)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
        int32_t display_width_;
        int32_t display_height_;
        bool is_internal_;
        int32_t model_id_;
        int32_t manufacture_year_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class KeylockerInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.KeylockerInfo) */ {
public:
    inline KeylockerInfo()
        : KeylockerInfo(nullptr)
    {
    }
    ~KeylockerInfo() override;
    explicit PROTOBUF_CONSTEXPR KeylockerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    KeylockerInfo(const KeylockerInfo& from);
    KeylockerInfo(KeylockerInfo&& from) noexcept
        : KeylockerInfo()
    {
        *this = ::std::move(from);
    }

    inline KeylockerInfo& operator=(const KeylockerInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline KeylockerInfo& operator=(KeylockerInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const KeylockerInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const KeylockerInfo* internal_default_instance()
    {
        return reinterpret_cast<const KeylockerInfo*>(&_KeylockerInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 17;

    friend void swap(KeylockerInfo& a, KeylockerInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(KeylockerInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(KeylockerInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    KeylockerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<KeylockerInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const KeylockerInfo& from);
    void MergeFrom(const KeylockerInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(KeylockerInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.KeylockerInfo";
    }

protected:
    explicit KeylockerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSupportedFieldNumber = 1,
        kConfiguredFieldNumber = 2,
    };
    // optional bool supported = 1;
    bool has_supported() const;

private:
    bool _internal_has_supported() const;

public:
    void clear_supported();
    bool supported() const;
    void set_supported(bool value);

private:
    bool _internal_supported() const;
    void _internal_set_supported(bool value);

public:
    // optional bool configured = 2;
    bool has_configured() const;

private:
    bool _internal_has_configured() const;

public:
    void clear_configured();
    bool configured() const;
    void set_configured(bool value);

private:
    bool _internal_configured() const;
    void _internal_set_configured(bool value);

public:
    // @@protoc_insertion_point(class_scope:reporting.KeylockerInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        bool supported_;
        bool configured_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class CpuInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.CpuInfo) */ {
public:
    inline CpuInfo()
        : CpuInfo(nullptr)
    {
    }
    ~CpuInfo() override;
    explicit PROTOBUF_CONSTEXPR CpuInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CpuInfo(const CpuInfo& from);
    CpuInfo(CpuInfo&& from) noexcept
        : CpuInfo()
    {
        *this = ::std::move(from);
    }

    inline CpuInfo& operator=(const CpuInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CpuInfo& operator=(CpuInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const CpuInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CpuInfo* internal_default_instance()
    {
        return reinterpret_cast<const CpuInfo*>(&_CpuInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 18;

    friend void swap(CpuInfo& a, CpuInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CpuInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CpuInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CpuInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CpuInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CpuInfo& from);
    void MergeFrom(const CpuInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CpuInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.CpuInfo";
    }

protected:
    explicit CpuInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kKeylockerInfoFieldNumber = 1,
    };
    // optional .reporting.KeylockerInfo keylocker_info = 1;
    bool has_keylocker_info() const;

private:
    bool _internal_has_keylocker_info() const;

public:
    void clear_keylocker_info();
    const ::reporting::KeylockerInfo& keylocker_info() const;
    PROTOBUF_NODISCARD ::reporting::KeylockerInfo* release_keylocker_info();
    ::reporting::KeylockerInfo* mutable_keylocker_info();
    void set_allocated_keylocker_info(::reporting::KeylockerInfo* keylocker_info);

private:
    const ::reporting::KeylockerInfo& _internal_keylocker_info() const;
    ::reporting::KeylockerInfo* _internal_mutable_keylocker_info();

public:
    void unsafe_arena_set_allocated_keylocker_info(::reporting::KeylockerInfo* keylocker_info);
    ::reporting::KeylockerInfo* unsafe_arena_release_keylocker_info();

    // @@protoc_insertion_point(class_scope:reporting.CpuInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::reporting::KeylockerInfo* keylocker_info_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class InfoData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.InfoData) */ {
public:
    inline InfoData()
        : InfoData(nullptr)
    {
    }
    ~InfoData() override;
    explicit PROTOBUF_CONSTEXPR InfoData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    InfoData(const InfoData& from);
    InfoData(InfoData&& from) noexcept
        : InfoData()
    {
        *this = ::std::move(from);
    }

    inline InfoData& operator=(const InfoData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline InfoData& operator=(InfoData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const InfoData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const InfoData* internal_default_instance()
    {
        return reinterpret_cast<const InfoData*>(&_InfoData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 19;

    friend void swap(InfoData& a, InfoData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(InfoData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(InfoData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    InfoData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<InfoData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const InfoData& from);
    void MergeFrom(const InfoData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(InfoData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.InfoData";
    }

protected:
    explicit InfoData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCpuInfoFieldNumber = 1,
        kBusDeviceInfoFieldNumber = 2,
        kMemoryInfoFieldNumber = 3,
        kNetworksInfoFieldNumber = 4,
        kTouchScreenInfoFieldNumber = 5,
        kPrivacyScreenInfoFieldNumber = 6,
        kDisplayInfoFieldNumber = 7,
    };
    // optional .reporting.CpuInfo cpu_info = 1;
    bool has_cpu_info() const;

private:
    bool _internal_has_cpu_info() const;

public:
    void clear_cpu_info();
    const ::reporting::CpuInfo& cpu_info() const;
    PROTOBUF_NODISCARD ::reporting::CpuInfo* release_cpu_info();
    ::reporting::CpuInfo* mutable_cpu_info();
    void set_allocated_cpu_info(::reporting::CpuInfo* cpu_info);

private:
    const ::reporting::CpuInfo& _internal_cpu_info() const;
    ::reporting::CpuInfo* _internal_mutable_cpu_info();

public:
    void unsafe_arena_set_allocated_cpu_info(::reporting::CpuInfo* cpu_info);
    ::reporting::CpuInfo* unsafe_arena_release_cpu_info();

    // optional .reporting.BusDeviceInfo bus_device_info = 2;
    bool has_bus_device_info() const;

private:
    bool _internal_has_bus_device_info() const;

public:
    void clear_bus_device_info();
    const ::reporting::BusDeviceInfo& bus_device_info() const;
    PROTOBUF_NODISCARD ::reporting::BusDeviceInfo* release_bus_device_info();
    ::reporting::BusDeviceInfo* mutable_bus_device_info();
    void set_allocated_bus_device_info(::reporting::BusDeviceInfo* bus_device_info);

private:
    const ::reporting::BusDeviceInfo& _internal_bus_device_info() const;
    ::reporting::BusDeviceInfo* _internal_mutable_bus_device_info();

public:
    void unsafe_arena_set_allocated_bus_device_info(::reporting::BusDeviceInfo* bus_device_info);
    ::reporting::BusDeviceInfo* unsafe_arena_release_bus_device_info();

    // optional .reporting.MemoryInfo memory_info = 3;
    bool has_memory_info() const;

private:
    bool _internal_has_memory_info() const;

public:
    void clear_memory_info();
    const ::reporting::MemoryInfo& memory_info() const;
    PROTOBUF_NODISCARD ::reporting::MemoryInfo* release_memory_info();
    ::reporting::MemoryInfo* mutable_memory_info();
    void set_allocated_memory_info(::reporting::MemoryInfo* memory_info);

private:
    const ::reporting::MemoryInfo& _internal_memory_info() const;
    ::reporting::MemoryInfo* _internal_mutable_memory_info();

public:
    void unsafe_arena_set_allocated_memory_info(::reporting::MemoryInfo* memory_info);
    ::reporting::MemoryInfo* unsafe_arena_release_memory_info();

    // optional .reporting.NetworksInfo networks_info = 4;
    bool has_networks_info() const;

private:
    bool _internal_has_networks_info() const;

public:
    void clear_networks_info();
    const ::reporting::NetworksInfo& networks_info() const;
    PROTOBUF_NODISCARD ::reporting::NetworksInfo* release_networks_info();
    ::reporting::NetworksInfo* mutable_networks_info();
    void set_allocated_networks_info(::reporting::NetworksInfo* networks_info);

private:
    const ::reporting::NetworksInfo& _internal_networks_info() const;
    ::reporting::NetworksInfo* _internal_mutable_networks_info();

public:
    void unsafe_arena_set_allocated_networks_info(::reporting::NetworksInfo* networks_info);
    ::reporting::NetworksInfo* unsafe_arena_release_networks_info();

    // optional .reporting.TouchScreenInfo touch_screen_info = 5;
    bool has_touch_screen_info() const;

private:
    bool _internal_has_touch_screen_info() const;

public:
    void clear_touch_screen_info();
    const ::reporting::TouchScreenInfo& touch_screen_info() const;
    PROTOBUF_NODISCARD ::reporting::TouchScreenInfo* release_touch_screen_info();
    ::reporting::TouchScreenInfo* mutable_touch_screen_info();
    void set_allocated_touch_screen_info(::reporting::TouchScreenInfo* touch_screen_info);

private:
    const ::reporting::TouchScreenInfo& _internal_touch_screen_info() const;
    ::reporting::TouchScreenInfo* _internal_mutable_touch_screen_info();

public:
    void unsafe_arena_set_allocated_touch_screen_info(::reporting::TouchScreenInfo* touch_screen_info);
    ::reporting::TouchScreenInfo* unsafe_arena_release_touch_screen_info();

    // optional .reporting.PrivacyScreenInfo privacy_screen_info = 6;
    bool has_privacy_screen_info() const;

private:
    bool _internal_has_privacy_screen_info() const;

public:
    void clear_privacy_screen_info();
    const ::reporting::PrivacyScreenInfo& privacy_screen_info() const;
    PROTOBUF_NODISCARD ::reporting::PrivacyScreenInfo* release_privacy_screen_info();
    ::reporting::PrivacyScreenInfo* mutable_privacy_screen_info();
    void set_allocated_privacy_screen_info(::reporting::PrivacyScreenInfo* privacy_screen_info);

private:
    const ::reporting::PrivacyScreenInfo& _internal_privacy_screen_info() const;
    ::reporting::PrivacyScreenInfo* _internal_mutable_privacy_screen_info();

public:
    void unsafe_arena_set_allocated_privacy_screen_info(::reporting::PrivacyScreenInfo* privacy_screen_info);
    ::reporting::PrivacyScreenInfo* unsafe_arena_release_privacy_screen_info();

    // optional .reporting.DisplayInfo display_info = 7;
    bool has_display_info() const;

private:
    bool _internal_has_display_info() const;

public:
    void clear_display_info();
    const ::reporting::DisplayInfo& display_info() const;
    PROTOBUF_NODISCARD ::reporting::DisplayInfo* release_display_info();
    ::reporting::DisplayInfo* mutable_display_info();
    void set_allocated_display_info(::reporting::DisplayInfo* display_info);

private:
    const ::reporting::DisplayInfo& _internal_display_info() const;
    ::reporting::DisplayInfo* _internal_mutable_display_info();

public:
    void unsafe_arena_set_allocated_display_info(::reporting::DisplayInfo* display_info);
    ::reporting::DisplayInfo* unsafe_arena_release_display_info();

    // @@protoc_insertion_point(class_scope:reporting.InfoData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::reporting::CpuInfo* cpu_info_;
        ::reporting::BusDeviceInfo* bus_device_info_;
        ::reporting::MemoryInfo* memory_info_;
        ::reporting::NetworksInfo* networks_info_;
        ::reporting::TouchScreenInfo* touch_screen_info_;
        ::reporting::PrivacyScreenInfo* privacy_screen_info_;
        ::reporting::DisplayInfo* display_info_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AudioTelemetry final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.AudioTelemetry) */ {
public:
    inline AudioTelemetry()
        : AudioTelemetry(nullptr)
    {
    }
    ~AudioTelemetry() override;
    explicit PROTOBUF_CONSTEXPR AudioTelemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AudioTelemetry(const AudioTelemetry& from);
    AudioTelemetry(AudioTelemetry&& from) noexcept
        : AudioTelemetry()
    {
        *this = ::std::move(from);
    }

    inline AudioTelemetry& operator=(const AudioTelemetry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AudioTelemetry& operator=(AudioTelemetry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AudioTelemetry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AudioTelemetry* internal_default_instance()
    {
        return reinterpret_cast<const AudioTelemetry*>(&_AudioTelemetry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 20;

    friend void swap(AudioTelemetry& a, AudioTelemetry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AudioTelemetry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AudioTelemetry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AudioTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AudioTelemetry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AudioTelemetry& from);
    void MergeFrom(const AudioTelemetry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AudioTelemetry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.AudioTelemetry";
    }

protected:
    explicit AudioTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kOutputDeviceNameFieldNumber = 4,
        kInputDeviceNameFieldNumber = 6,
        kOutputMuteFieldNumber = 1,
        kInputMuteFieldNumber = 2,
        kOutputVolumeFieldNumber = 3,
        kInputGainFieldNumber = 5,
    };
    // optional string output_device_name = 4;
    bool has_output_device_name() const;

private:
    bool _internal_has_output_device_name() const;

public:
    void clear_output_device_name();
    const std::string& output_device_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_output_device_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_output_device_name();
    PROTOBUF_NODISCARD std::string* release_output_device_name();
    void set_allocated_output_device_name(std::string* output_device_name);

private:
    const std::string& _internal_output_device_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_output_device_name(const std::string& value);
    std::string* _internal_mutable_output_device_name();

public:
    // optional string input_device_name = 6;
    bool has_input_device_name() const;

private:
    bool _internal_has_input_device_name() const;

public:
    void clear_input_device_name();
    const std::string& input_device_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_input_device_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_input_device_name();
    PROTOBUF_NODISCARD std::string* release_input_device_name();
    void set_allocated_input_device_name(std::string* input_device_name);

private:
    const std::string& _internal_input_device_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_input_device_name(const std::string& value);
    std::string* _internal_mutable_input_device_name();

public:
    // optional bool output_mute = 1;
    bool has_output_mute() const;

private:
    bool _internal_has_output_mute() const;

public:
    void clear_output_mute();
    bool output_mute() const;
    void set_output_mute(bool value);

private:
    bool _internal_output_mute() const;
    void _internal_set_output_mute(bool value);

public:
    // optional bool input_mute = 2;
    bool has_input_mute() const;

private:
    bool _internal_has_input_mute() const;

public:
    void clear_input_mute();
    bool input_mute() const;
    void set_input_mute(bool value);

private:
    bool _internal_input_mute() const;
    void _internal_set_input_mute(bool value);

public:
    // optional int32 output_volume = 3;
    bool has_output_volume() const;

private:
    bool _internal_has_output_volume() const;

public:
    void clear_output_volume();
    int32_t output_volume() const;
    void set_output_volume(int32_t value);

private:
    int32_t _internal_output_volume() const;
    void _internal_set_output_volume(int32_t value);

public:
    // optional int32 input_gain = 5;
    bool has_input_gain() const;

private:
    bool _internal_has_input_gain() const;

public:
    void clear_input_gain();
    int32_t input_gain() const;
    void set_input_gain(int32_t value);

private:
    int32_t _internal_input_gain() const;
    void _internal_set_input_gain(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.AudioTelemetry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr output_device_name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr input_device_name_;
        bool output_mute_;
        bool input_mute_;
        int32_t output_volume_;
        int32_t input_gain_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class BootPerformanceTelemetry final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.BootPerformanceTelemetry) */ {
public:
    inline BootPerformanceTelemetry()
        : BootPerformanceTelemetry(nullptr)
    {
    }
    ~BootPerformanceTelemetry() override;
    explicit PROTOBUF_CONSTEXPR BootPerformanceTelemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    BootPerformanceTelemetry(const BootPerformanceTelemetry& from);
    BootPerformanceTelemetry(BootPerformanceTelemetry&& from) noexcept
        : BootPerformanceTelemetry()
    {
        *this = ::std::move(from);
    }

    inline BootPerformanceTelemetry& operator=(const BootPerformanceTelemetry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline BootPerformanceTelemetry& operator=(BootPerformanceTelemetry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const BootPerformanceTelemetry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const BootPerformanceTelemetry* internal_default_instance()
    {
        return reinterpret_cast<const BootPerformanceTelemetry*>(&_BootPerformanceTelemetry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 21;

    friend void swap(BootPerformanceTelemetry& a, BootPerformanceTelemetry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(BootPerformanceTelemetry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(BootPerformanceTelemetry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    BootPerformanceTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<BootPerformanceTelemetry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const BootPerformanceTelemetry& from);
    void MergeFrom(const BootPerformanceTelemetry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(BootPerformanceTelemetry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.BootPerformanceTelemetry";
    }

protected:
    explicit BootPerformanceTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kShutdownReasonFieldNumber = 5,
        kBootUpSecondsFieldNumber = 1,
        kBootUpTimestampSecondsFieldNumber = 2,
        kShutdownSecondsFieldNumber = 3,
        kShutdownTimestampSecondsFieldNumber = 4,
    };
    // optional string shutdown_reason = 5;
    bool has_shutdown_reason() const;

private:
    bool _internal_has_shutdown_reason() const;

public:
    void clear_shutdown_reason();
    const std::string& shutdown_reason() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_shutdown_reason(ArgT0&& arg0, ArgT... args);
    std::string* mutable_shutdown_reason();
    PROTOBUF_NODISCARD std::string* release_shutdown_reason();
    void set_allocated_shutdown_reason(std::string* shutdown_reason);

private:
    const std::string& _internal_shutdown_reason() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_shutdown_reason(const std::string& value);
    std::string* _internal_mutable_shutdown_reason();

public:
    // optional int64 boot_up_seconds = 1;
    bool has_boot_up_seconds() const;

private:
    bool _internal_has_boot_up_seconds() const;

public:
    void clear_boot_up_seconds();
    int64_t boot_up_seconds() const;
    void set_boot_up_seconds(int64_t value);

private:
    int64_t _internal_boot_up_seconds() const;
    void _internal_set_boot_up_seconds(int64_t value);

public:
    // optional int64 boot_up_timestamp_seconds = 2;
    bool has_boot_up_timestamp_seconds() const;

private:
    bool _internal_has_boot_up_timestamp_seconds() const;

public:
    void clear_boot_up_timestamp_seconds();
    int64_t boot_up_timestamp_seconds() const;
    void set_boot_up_timestamp_seconds(int64_t value);

private:
    int64_t _internal_boot_up_timestamp_seconds() const;
    void _internal_set_boot_up_timestamp_seconds(int64_t value);

public:
    // optional int64 shutdown_seconds = 3;
    bool has_shutdown_seconds() const;

private:
    bool _internal_has_shutdown_seconds() const;

public:
    void clear_shutdown_seconds();
    int64_t shutdown_seconds() const;
    void set_shutdown_seconds(int64_t value);

private:
    int64_t _internal_shutdown_seconds() const;
    void _internal_set_shutdown_seconds(int64_t value);

public:
    // optional int64 shutdown_timestamp_seconds = 4;
    bool has_shutdown_timestamp_seconds() const;

private:
    bool _internal_has_shutdown_timestamp_seconds() const;

public:
    void clear_shutdown_timestamp_seconds();
    int64_t shutdown_timestamp_seconds() const;
    void set_shutdown_timestamp_seconds(int64_t value);

private:
    int64_t _internal_shutdown_timestamp_seconds() const;
    void _internal_set_shutdown_timestamp_seconds(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.BootPerformanceTelemetry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shutdown_reason_;
        int64_t boot_up_seconds_;
        int64_t boot_up_timestamp_seconds_;
        int64_t shutdown_seconds_;
        int64_t shutdown_timestamp_seconds_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class UserStatusTelemetry final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.UserStatusTelemetry) */ {
public:
    inline UserStatusTelemetry()
        : UserStatusTelemetry(nullptr)
    {
    }
    ~UserStatusTelemetry() override;
    explicit PROTOBUF_CONSTEXPR UserStatusTelemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    UserStatusTelemetry(const UserStatusTelemetry& from);
    UserStatusTelemetry(UserStatusTelemetry&& from) noexcept
        : UserStatusTelemetry()
    {
        *this = ::std::move(from);
    }

    inline UserStatusTelemetry& operator=(const UserStatusTelemetry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UserStatusTelemetry& operator=(UserStatusTelemetry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const UserStatusTelemetry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const UserStatusTelemetry* internal_default_instance()
    {
        return reinterpret_cast<const UserStatusTelemetry*>(&_UserStatusTelemetry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 22;

    friend void swap(UserStatusTelemetry& a, UserStatusTelemetry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(UserStatusTelemetry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UserStatusTelemetry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UserStatusTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<UserStatusTelemetry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const UserStatusTelemetry& from);
    void MergeFrom(const UserStatusTelemetry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(UserStatusTelemetry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.UserStatusTelemetry";
    }

protected:
    explicit UserStatusTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef UserStatusTelemetry_DeviceActivityState DeviceActivityState;
    static constexpr DeviceActivityState DEVICE_ACTIVITY_STATE_UNKNOWN = UserStatusTelemetry_DeviceActivityState_DEVICE_ACTIVITY_STATE_UNKNOWN;
    static constexpr DeviceActivityState ACTIVE = UserStatusTelemetry_DeviceActivityState_ACTIVE;
    static constexpr DeviceActivityState IDLE = UserStatusTelemetry_DeviceActivityState_IDLE;
    static constexpr DeviceActivityState LOCKED = UserStatusTelemetry_DeviceActivityState_LOCKED;
    static inline bool DeviceActivityState_IsValid(int value)
    {
        return UserStatusTelemetry_DeviceActivityState_IsValid(value);
    }
    static constexpr DeviceActivityState DeviceActivityState_MIN = UserStatusTelemetry_DeviceActivityState_DeviceActivityState_MIN;
    static constexpr DeviceActivityState DeviceActivityState_MAX = UserStatusTelemetry_DeviceActivityState_DeviceActivityState_MAX;
    static constexpr int DeviceActivityState_ARRAYSIZE = UserStatusTelemetry_DeviceActivityState_DeviceActivityState_ARRAYSIZE;
    template <typename T> static inline const std::string& DeviceActivityState_Name(T enum_t_value)
    {
        static_assert(
            ::std::is_same<T, DeviceActivityState>::value || ::std::is_integral<T>::value, "Incorrect type passed to function DeviceActivityState_Name.");
        return UserStatusTelemetry_DeviceActivityState_Name(enum_t_value);
    }
    static inline bool DeviceActivityState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DeviceActivityState* value)
    {
        return UserStatusTelemetry_DeviceActivityState_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kDeviceActivityStateFieldNumber = 1,
    };
    // optional .reporting.UserStatusTelemetry.DeviceActivityState device_activity_state = 1;
    bool has_device_activity_state() const;

private:
    bool _internal_has_device_activity_state() const;

public:
    void clear_device_activity_state();
    ::reporting::UserStatusTelemetry_DeviceActivityState device_activity_state() const;
    void set_device_activity_state(::reporting::UserStatusTelemetry_DeviceActivityState value);

private:
    ::reporting::UserStatusTelemetry_DeviceActivityState _internal_device_activity_state() const;
    void _internal_set_device_activity_state(::reporting::UserStatusTelemetry_DeviceActivityState value);

public:
    // @@protoc_insertion_point(class_scope:reporting.UserStatusTelemetry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int device_activity_state_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class DisplaysTelemetry final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.DisplaysTelemetry) */ {
public:
    inline DisplaysTelemetry()
        : DisplaysTelemetry(nullptr)
    {
    }
    ~DisplaysTelemetry() override;
    explicit PROTOBUF_CONSTEXPR DisplaysTelemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    DisplaysTelemetry(const DisplaysTelemetry& from);
    DisplaysTelemetry(DisplaysTelemetry&& from) noexcept
        : DisplaysTelemetry()
    {
        *this = ::std::move(from);
    }

    inline DisplaysTelemetry& operator=(const DisplaysTelemetry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DisplaysTelemetry& operator=(DisplaysTelemetry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const DisplaysTelemetry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DisplaysTelemetry* internal_default_instance()
    {
        return reinterpret_cast<const DisplaysTelemetry*>(&_DisplaysTelemetry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 23;

    friend void swap(DisplaysTelemetry& a, DisplaysTelemetry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(DisplaysTelemetry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DisplaysTelemetry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DisplaysTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<DisplaysTelemetry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const DisplaysTelemetry& from);
    void MergeFrom(const DisplaysTelemetry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DisplaysTelemetry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.DisplaysTelemetry";
    }

protected:
    explicit DisplaysTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDisplayStatusFieldNumber = 1,
    };
    // repeated .reporting.DisplayStatus display_status = 1;
    int display_status_size() const;

private:
    int _internal_display_status_size() const;

public:
    void clear_display_status();
    ::reporting::DisplayStatus* mutable_display_status(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::DisplayStatus>* mutable_display_status();

private:
    const ::reporting::DisplayStatus& _internal_display_status(int index) const;
    ::reporting::DisplayStatus* _internal_add_display_status();

public:
    const ::reporting::DisplayStatus& display_status(int index) const;
    ::reporting::DisplayStatus* add_display_status();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::DisplayStatus>& display_status() const;

    // @@protoc_insertion_point(class_scope:reporting.DisplaysTelemetry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::DisplayStatus> display_status_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class DisplayStatus final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.DisplayStatus) */ {
public:
    inline DisplayStatus()
        : DisplayStatus(nullptr)
    {
    }
    ~DisplayStatus() override;
    explicit PROTOBUF_CONSTEXPR DisplayStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    DisplayStatus(const DisplayStatus& from);
    DisplayStatus(DisplayStatus&& from) noexcept
        : DisplayStatus()
    {
        *this = ::std::move(from);
    }

    inline DisplayStatus& operator=(const DisplayStatus& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DisplayStatus& operator=(DisplayStatus&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const DisplayStatus& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DisplayStatus* internal_default_instance()
    {
        return reinterpret_cast<const DisplayStatus*>(&_DisplayStatus_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 24;

    friend void swap(DisplayStatus& a, DisplayStatus& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(DisplayStatus* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DisplayStatus* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DisplayStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<DisplayStatus>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const DisplayStatus& from);
    void MergeFrom(const DisplayStatus& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DisplayStatus* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.DisplayStatus";
    }

protected:
    explicit DisplayStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDisplayNameFieldNumber = 1,
        kResolutionHorizontalFieldNumber = 2,
        kResolutionVerticalFieldNumber = 3,
        kRefreshRateFieldNumber = 4,
        kIsInternalFieldNumber = 5,
    };
    // optional string display_name = 1;
    bool has_display_name() const;

private:
    bool _internal_has_display_name() const;

public:
    void clear_display_name();
    const std::string& display_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_display_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_display_name();
    PROTOBUF_NODISCARD std::string* release_display_name();
    void set_allocated_display_name(std::string* display_name);

private:
    const std::string& _internal_display_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
    std::string* _internal_mutable_display_name();

public:
    // optional int32 resolution_horizontal = 2;
    bool has_resolution_horizontal() const;

private:
    bool _internal_has_resolution_horizontal() const;

public:
    void clear_resolution_horizontal();
    int32_t resolution_horizontal() const;
    void set_resolution_horizontal(int32_t value);

private:
    int32_t _internal_resolution_horizontal() const;
    void _internal_set_resolution_horizontal(int32_t value);

public:
    // optional int32 resolution_vertical = 3;
    bool has_resolution_vertical() const;

private:
    bool _internal_has_resolution_vertical() const;

public:
    void clear_resolution_vertical();
    int32_t resolution_vertical() const;
    void set_resolution_vertical(int32_t value);

private:
    int32_t _internal_resolution_vertical() const;
    void _internal_set_resolution_vertical(int32_t value);

public:
    // optional int64 refresh_rate = 4;
    bool has_refresh_rate() const;

private:
    bool _internal_has_refresh_rate() const;

public:
    void clear_refresh_rate();
    int64_t refresh_rate() const;
    void set_refresh_rate(int64_t value);

private:
    int64_t _internal_refresh_rate() const;
    void _internal_set_refresh_rate(int64_t value);

public:
    // optional bool is_internal = 5;
    bool has_is_internal() const;

private:
    bool _internal_has_is_internal() const;

public:
    void clear_is_internal();
    bool is_internal() const;
    void set_is_internal(bool value);

private:
    bool _internal_is_internal() const;
    void _internal_set_is_internal(bool value);

public:
    // @@protoc_insertion_point(class_scope:reporting.DisplayStatus)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
        int32_t resolution_horizontal_;
        int32_t resolution_vertical_;
        int64_t refresh_rate_;
        bool is_internal_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class KioskHeartbeatTelemetry final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.KioskHeartbeatTelemetry) */ {
public:
    inline KioskHeartbeatTelemetry()
        : KioskHeartbeatTelemetry(nullptr)
    {
    }
    ~KioskHeartbeatTelemetry() override;
    explicit PROTOBUF_CONSTEXPR KioskHeartbeatTelemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    KioskHeartbeatTelemetry(const KioskHeartbeatTelemetry& from);
    KioskHeartbeatTelemetry(KioskHeartbeatTelemetry&& from) noexcept
        : KioskHeartbeatTelemetry()
    {
        *this = ::std::move(from);
    }

    inline KioskHeartbeatTelemetry& operator=(const KioskHeartbeatTelemetry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline KioskHeartbeatTelemetry& operator=(KioskHeartbeatTelemetry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const KioskHeartbeatTelemetry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const KioskHeartbeatTelemetry* internal_default_instance()
    {
        return reinterpret_cast<const KioskHeartbeatTelemetry*>(&_KioskHeartbeatTelemetry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 25;

    friend void swap(KioskHeartbeatTelemetry& a, KioskHeartbeatTelemetry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(KioskHeartbeatTelemetry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(KioskHeartbeatTelemetry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    KioskHeartbeatTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<KioskHeartbeatTelemetry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const KioskHeartbeatTelemetry& from);
    void MergeFrom(const KioskHeartbeatTelemetry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(KioskHeartbeatTelemetry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.KioskHeartbeatTelemetry";
    }

protected:
    explicit KioskHeartbeatTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:reporting.KioskHeartbeatTelemetry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class KioskVisionView final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.KioskVisionView) */ {
public:
    inline KioskVisionView()
        : KioskVisionView(nullptr)
    {
    }
    ~KioskVisionView() override;
    explicit PROTOBUF_CONSTEXPR KioskVisionView(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    KioskVisionView(const KioskVisionView& from);
    KioskVisionView(KioskVisionView&& from) noexcept
        : KioskVisionView()
    {
        *this = ::std::move(from);
    }

    inline KioskVisionView& operator=(const KioskVisionView& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline KioskVisionView& operator=(KioskVisionView&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const KioskVisionView& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const KioskVisionView* internal_default_instance()
    {
        return reinterpret_cast<const KioskVisionView*>(&_KioskVisionView_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 26;

    friend void swap(KioskVisionView& a, KioskVisionView& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(KioskVisionView* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(KioskVisionView* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    KioskVisionView* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<KioskVisionView>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const KioskVisionView& from);
    void MergeFrom(const KioskVisionView& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(KioskVisionView* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.KioskVisionView";
    }

protected:
    explicit KioskVisionView(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStartTimeSecFieldNumber = 1,
        kEndTimeSecFieldNumber = 2,
    };
    // optional int64 start_time_sec = 1;
    bool has_start_time_sec() const;

private:
    bool _internal_has_start_time_sec() const;

public:
    void clear_start_time_sec();
    int64_t start_time_sec() const;
    void set_start_time_sec(int64_t value);

private:
    int64_t _internal_start_time_sec() const;
    void _internal_set_start_time_sec(int64_t value);

public:
    // optional int64 end_time_sec = 2;
    bool has_end_time_sec() const;

private:
    bool _internal_has_end_time_sec() const;

public:
    void clear_end_time_sec();
    int64_t end_time_sec() const;
    void set_end_time_sec(int64_t value);

private:
    int64_t _internal_end_time_sec() const;
    void _internal_set_end_time_sec(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.KioskVisionView)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int64_t start_time_sec_;
        int64_t end_time_sec_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class KioskVisionAudience final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.KioskVisionAudience) */ {
public:
    inline KioskVisionAudience()
        : KioskVisionAudience(nullptr)
    {
    }
    ~KioskVisionAudience() override;
    explicit PROTOBUF_CONSTEXPR KioskVisionAudience(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    KioskVisionAudience(const KioskVisionAudience& from);
    KioskVisionAudience(KioskVisionAudience&& from) noexcept
        : KioskVisionAudience()
    {
        *this = ::std::move(from);
    }

    inline KioskVisionAudience& operator=(const KioskVisionAudience& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline KioskVisionAudience& operator=(KioskVisionAudience&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const KioskVisionAudience& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const KioskVisionAudience* internal_default_instance()
    {
        return reinterpret_cast<const KioskVisionAudience*>(&_KioskVisionAudience_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 27;

    friend void swap(KioskVisionAudience& a, KioskVisionAudience& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(KioskVisionAudience* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(KioskVisionAudience* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    KioskVisionAudience* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<KioskVisionAudience>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const KioskVisionAudience& from);
    void MergeFrom(const KioskVisionAudience& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(KioskVisionAudience* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.KioskVisionAudience";
    }

protected:
    explicit KioskVisionAudience(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kViewsFieldNumber = 3,
        kPresenceStartDateSecFieldNumber = 1,
        kPresenceEndDateSecFieldNumber = 2,
    };
    // repeated .reporting.KioskVisionView views = 3;
    int views_size() const;

private:
    int _internal_views_size() const;

public:
    void clear_views();
    ::reporting::KioskVisionView* mutable_views(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::KioskVisionView>* mutable_views();

private:
    const ::reporting::KioskVisionView& _internal_views(int index) const;
    ::reporting::KioskVisionView* _internal_add_views();

public:
    const ::reporting::KioskVisionView& views(int index) const;
    ::reporting::KioskVisionView* add_views();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::KioskVisionView>& views() const;

    // optional int64 presence_start_date_sec = 1;
    bool has_presence_start_date_sec() const;

private:
    bool _internal_has_presence_start_date_sec() const;

public:
    void clear_presence_start_date_sec();
    int64_t presence_start_date_sec() const;
    void set_presence_start_date_sec(int64_t value);

private:
    int64_t _internal_presence_start_date_sec() const;
    void _internal_set_presence_start_date_sec(int64_t value);

public:
    // optional int64 presence_end_date_sec = 2;
    bool has_presence_end_date_sec() const;

private:
    bool _internal_has_presence_end_date_sec() const;

public:
    void clear_presence_end_date_sec();
    int64_t presence_end_date_sec() const;
    void set_presence_end_date_sec(int64_t value);

private:
    int64_t _internal_presence_end_date_sec() const;
    void _internal_set_presence_end_date_sec(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.KioskVisionAudience)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::KioskVisionView> views_;
        int64_t presence_start_date_sec_;
        int64_t presence_end_date_sec_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class KioskVisionTelemetry final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.KioskVisionTelemetry) */ {
public:
    inline KioskVisionTelemetry()
        : KioskVisionTelemetry(nullptr)
    {
    }
    ~KioskVisionTelemetry() override;
    explicit PROTOBUF_CONSTEXPR KioskVisionTelemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    KioskVisionTelemetry(const KioskVisionTelemetry& from);
    KioskVisionTelemetry(KioskVisionTelemetry&& from) noexcept
        : KioskVisionTelemetry()
    {
        *this = ::std::move(from);
    }

    inline KioskVisionTelemetry& operator=(const KioskVisionTelemetry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline KioskVisionTelemetry& operator=(KioskVisionTelemetry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const KioskVisionTelemetry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const KioskVisionTelemetry* internal_default_instance()
    {
        return reinterpret_cast<const KioskVisionTelemetry*>(&_KioskVisionTelemetry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 28;

    friend void swap(KioskVisionTelemetry& a, KioskVisionTelemetry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(KioskVisionTelemetry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(KioskVisionTelemetry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    KioskVisionTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<KioskVisionTelemetry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const KioskVisionTelemetry& from);
    void MergeFrom(const KioskVisionTelemetry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(KioskVisionTelemetry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.KioskVisionTelemetry";
    }

protected:
    explicit KioskVisionTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kAudienceFieldNumber = 5,
        kStartDateSecFieldNumber = 1,
        kEndDateSecFieldNumber = 2,
        kViewCountFieldNumber = 3,
        kPassCountFieldNumber = 4,
    };
    // repeated .reporting.KioskVisionAudience audience = 5;
    int audience_size() const;

private:
    int _internal_audience_size() const;

public:
    void clear_audience();
    ::reporting::KioskVisionAudience* mutable_audience(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::KioskVisionAudience>* mutable_audience();

private:
    const ::reporting::KioskVisionAudience& _internal_audience(int index) const;
    ::reporting::KioskVisionAudience* _internal_add_audience();

public:
    const ::reporting::KioskVisionAudience& audience(int index) const;
    ::reporting::KioskVisionAudience* add_audience();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::KioskVisionAudience>& audience() const;

    // optional int64 start_date_sec = 1;
    bool has_start_date_sec() const;

private:
    bool _internal_has_start_date_sec() const;

public:
    void clear_start_date_sec();
    int64_t start_date_sec() const;
    void set_start_date_sec(int64_t value);

private:
    int64_t _internal_start_date_sec() const;
    void _internal_set_start_date_sec(int64_t value);

public:
    // optional int64 end_date_sec = 2;
    bool has_end_date_sec() const;

private:
    bool _internal_has_end_date_sec() const;

public:
    void clear_end_date_sec();
    int64_t end_date_sec() const;
    void set_end_date_sec(int64_t value);

private:
    int64_t _internal_end_date_sec() const;
    void _internal_set_end_date_sec(int64_t value);

public:
    // optional int32 view_count = 3;
    bool has_view_count() const;

private:
    bool _internal_has_view_count() const;

public:
    void clear_view_count();
    int32_t view_count() const;
    void set_view_count(int32_t value);

private:
    int32_t _internal_view_count() const;
    void _internal_set_view_count(int32_t value);

public:
    // optional int32 pass_count = 4;
    bool has_pass_count() const;

private:
    bool _internal_has_pass_count() const;

public:
    void clear_pass_count();
    int32_t pass_count() const;
    void set_pass_count(int32_t value);

private:
    int32_t _internal_pass_count() const;
    void _internal_set_pass_count(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.KioskVisionTelemetry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::KioskVisionAudience> audience_;
        int64_t start_date_sec_;
        int64_t end_date_sec_;
        int32_t view_count_;
        int32_t pass_count_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class KioskVisionStatusReport final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.KioskVisionStatusReport) */ {
public:
    inline KioskVisionStatusReport()
        : KioskVisionStatusReport(nullptr)
    {
    }
    ~KioskVisionStatusReport() override;
    explicit PROTOBUF_CONSTEXPR KioskVisionStatusReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    KioskVisionStatusReport(const KioskVisionStatusReport& from);
    KioskVisionStatusReport(KioskVisionStatusReport&& from) noexcept
        : KioskVisionStatusReport()
    {
        *this = ::std::move(from);
    }

    inline KioskVisionStatusReport& operator=(const KioskVisionStatusReport& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline KioskVisionStatusReport& operator=(KioskVisionStatusReport&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const KioskVisionStatusReport& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const KioskVisionStatusReport* internal_default_instance()
    {
        return reinterpret_cast<const KioskVisionStatusReport*>(&_KioskVisionStatusReport_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 29;

    friend void swap(KioskVisionStatusReport& a, KioskVisionStatusReport& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(KioskVisionStatusReport* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(KioskVisionStatusReport* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    KioskVisionStatusReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<KioskVisionStatusReport>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const KioskVisionStatusReport& from);
    void MergeFrom(const KioskVisionStatusReport& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(KioskVisionStatusReport* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.KioskVisionStatusReport";
    }

protected:
    explicit KioskVisionStatusReport(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef KioskVisionStatusReport_KioskVisionState KioskVisionState;
    static constexpr KioskVisionState KIOSK_VISION_STATE_ACTIVE = KioskVisionStatusReport_KioskVisionState_KIOSK_VISION_STATE_ACTIVE;
    static constexpr KioskVisionState KIOSK_VISION_STATE_UNKNOWN_ERROR = KioskVisionStatusReport_KioskVisionState_KIOSK_VISION_STATE_UNKNOWN_ERROR;
    static constexpr KioskVisionState KIOSK_VISION_STATE_CAMERA_NOT_FOUND = KioskVisionStatusReport_KioskVisionState_KIOSK_VISION_STATE_CAMERA_NOT_FOUND;
    static inline bool KioskVisionState_IsValid(int value)
    {
        return KioskVisionStatusReport_KioskVisionState_IsValid(value);
    }
    static constexpr KioskVisionState KioskVisionState_MIN = KioskVisionStatusReport_KioskVisionState_KioskVisionState_MIN;
    static constexpr KioskVisionState KioskVisionState_MAX = KioskVisionStatusReport_KioskVisionState_KioskVisionState_MAX;
    static constexpr int KioskVisionState_ARRAYSIZE = KioskVisionStatusReport_KioskVisionState_KioskVisionState_ARRAYSIZE;
    template <typename T> static inline const std::string& KioskVisionState_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, KioskVisionState>::value || ::std::is_integral<T>::value, "Incorrect type passed to function KioskVisionState_Name.");
        return KioskVisionStatusReport_KioskVisionState_Name(enum_t_value);
    }
    static inline bool KioskVisionState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KioskVisionState* value)
    {
        return KioskVisionStatusReport_KioskVisionState_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kTimeStampSecFieldNumber = 2,
        kStateChangeTimeStampSecFieldNumber = 3,
        kStateFieldNumber = 1,
    };
    // optional int64 time_stamp_sec = 2;
    bool has_time_stamp_sec() const;

private:
    bool _internal_has_time_stamp_sec() const;

public:
    void clear_time_stamp_sec();
    int64_t time_stamp_sec() const;
    void set_time_stamp_sec(int64_t value);

private:
    int64_t _internal_time_stamp_sec() const;
    void _internal_set_time_stamp_sec(int64_t value);

public:
    // optional int64 state_change_time_stamp_sec = 3;
    bool has_state_change_time_stamp_sec() const;

private:
    bool _internal_has_state_change_time_stamp_sec() const;

public:
    void clear_state_change_time_stamp_sec();
    int64_t state_change_time_stamp_sec() const;
    void set_state_change_time_stamp_sec(int64_t value);

private:
    int64_t _internal_state_change_time_stamp_sec() const;
    void _internal_set_state_change_time_stamp_sec(int64_t value);

public:
    // optional .reporting.KioskVisionStatusReport.KioskVisionState state = 1;
    bool has_state() const;

private:
    bool _internal_has_state() const;

public:
    void clear_state();
    ::reporting::KioskVisionStatusReport_KioskVisionState state() const;
    void set_state(::reporting::KioskVisionStatusReport_KioskVisionState value);

private:
    ::reporting::KioskVisionStatusReport_KioskVisionState _internal_state() const;
    void _internal_set_state(::reporting::KioskVisionStatusReport_KioskVisionState value);

public:
    // @@protoc_insertion_point(class_scope:reporting.KioskVisionStatusReport)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int64_t time_stamp_sec_;
        int64_t state_change_time_stamp_sec_;
        int state_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class TelemetryData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.TelemetryData) */ {
public:
    inline TelemetryData()
        : TelemetryData(nullptr)
    {
    }
    ~TelemetryData() override;
    explicit PROTOBUF_CONSTEXPR TelemetryData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TelemetryData(const TelemetryData& from);
    TelemetryData(TelemetryData&& from) noexcept
        : TelemetryData()
    {
        *this = ::std::move(from);
    }

    inline TelemetryData& operator=(const TelemetryData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TelemetryData& operator=(TelemetryData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const TelemetryData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const TelemetryData* internal_default_instance()
    {
        return reinterpret_cast<const TelemetryData*>(&_TelemetryData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 30;

    friend void swap(TelemetryData& a, TelemetryData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TelemetryData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TelemetryData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TelemetryData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TelemetryData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TelemetryData& from);
    void MergeFrom(const TelemetryData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TelemetryData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.TelemetryData";
    }

protected:
    explicit TelemetryData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kNetworksTelemetryFieldNumber = 1,
        kAudioTelemetryFieldNumber = 2,
        kPeripheralsTelemetryFieldNumber = 3,
        kBootPerformanceTelemetryFieldNumber = 4,
        kUserStatusTelemetryFieldNumber = 5,
        kDisplaysTelemetryFieldNumber = 6,
        kAppTelemetryFieldNumber = 7,
        kFatalCrashTelemetryFieldNumber = 9,
        kRuntimeCountersTelemetryFieldNumber = 10,
        kWebsiteTelemetryFieldNumber = 11,
        kHeartbeatTelemetryFieldNumber = 12,
        kKioskVisionTelemetryFieldNumber = 13,
        kKioskVisionStatusFieldNumber = 14,
        kIsEventDrivenFieldNumber = 8,
    };
    // optional .reporting.NetworksTelemetry networks_telemetry = 1;
    bool has_networks_telemetry() const;

private:
    bool _internal_has_networks_telemetry() const;

public:
    void clear_networks_telemetry();
    const ::reporting::NetworksTelemetry& networks_telemetry() const;
    PROTOBUF_NODISCARD ::reporting::NetworksTelemetry* release_networks_telemetry();
    ::reporting::NetworksTelemetry* mutable_networks_telemetry();
    void set_allocated_networks_telemetry(::reporting::NetworksTelemetry* networks_telemetry);

private:
    const ::reporting::NetworksTelemetry& _internal_networks_telemetry() const;
    ::reporting::NetworksTelemetry* _internal_mutable_networks_telemetry();

public:
    void unsafe_arena_set_allocated_networks_telemetry(::reporting::NetworksTelemetry* networks_telemetry);
    ::reporting::NetworksTelemetry* unsafe_arena_release_networks_telemetry();

    // optional .reporting.AudioTelemetry audio_telemetry = 2;
    bool has_audio_telemetry() const;

private:
    bool _internal_has_audio_telemetry() const;

public:
    void clear_audio_telemetry();
    const ::reporting::AudioTelemetry& audio_telemetry() const;
    PROTOBUF_NODISCARD ::reporting::AudioTelemetry* release_audio_telemetry();
    ::reporting::AudioTelemetry* mutable_audio_telemetry();
    void set_allocated_audio_telemetry(::reporting::AudioTelemetry* audio_telemetry);

private:
    const ::reporting::AudioTelemetry& _internal_audio_telemetry() const;
    ::reporting::AudioTelemetry* _internal_mutable_audio_telemetry();

public:
    void unsafe_arena_set_allocated_audio_telemetry(::reporting::AudioTelemetry* audio_telemetry);
    ::reporting::AudioTelemetry* unsafe_arena_release_audio_telemetry();

    // optional .reporting.PeripheralsTelemetry peripherals_telemetry = 3;
    bool has_peripherals_telemetry() const;

private:
    bool _internal_has_peripherals_telemetry() const;

public:
    void clear_peripherals_telemetry();
    const ::reporting::PeripheralsTelemetry& peripherals_telemetry() const;
    PROTOBUF_NODISCARD ::reporting::PeripheralsTelemetry* release_peripherals_telemetry();
    ::reporting::PeripheralsTelemetry* mutable_peripherals_telemetry();
    void set_allocated_peripherals_telemetry(::reporting::PeripheralsTelemetry* peripherals_telemetry);

private:
    const ::reporting::PeripheralsTelemetry& _internal_peripherals_telemetry() const;
    ::reporting::PeripheralsTelemetry* _internal_mutable_peripherals_telemetry();

public:
    void unsafe_arena_set_allocated_peripherals_telemetry(::reporting::PeripheralsTelemetry* peripherals_telemetry);
    ::reporting::PeripheralsTelemetry* unsafe_arena_release_peripherals_telemetry();

    // optional .reporting.BootPerformanceTelemetry boot_performance_telemetry = 4;
    bool has_boot_performance_telemetry() const;

private:
    bool _internal_has_boot_performance_telemetry() const;

public:
    void clear_boot_performance_telemetry();
    const ::reporting::BootPerformanceTelemetry& boot_performance_telemetry() const;
    PROTOBUF_NODISCARD ::reporting::BootPerformanceTelemetry* release_boot_performance_telemetry();
    ::reporting::BootPerformanceTelemetry* mutable_boot_performance_telemetry();
    void set_allocated_boot_performance_telemetry(::reporting::BootPerformanceTelemetry* boot_performance_telemetry);

private:
    const ::reporting::BootPerformanceTelemetry& _internal_boot_performance_telemetry() const;
    ::reporting::BootPerformanceTelemetry* _internal_mutable_boot_performance_telemetry();

public:
    void unsafe_arena_set_allocated_boot_performance_telemetry(::reporting::BootPerformanceTelemetry* boot_performance_telemetry);
    ::reporting::BootPerformanceTelemetry* unsafe_arena_release_boot_performance_telemetry();

    // optional .reporting.UserStatusTelemetry user_status_telemetry = 5;
    bool has_user_status_telemetry() const;

private:
    bool _internal_has_user_status_telemetry() const;

public:
    void clear_user_status_telemetry();
    const ::reporting::UserStatusTelemetry& user_status_telemetry() const;
    PROTOBUF_NODISCARD ::reporting::UserStatusTelemetry* release_user_status_telemetry();
    ::reporting::UserStatusTelemetry* mutable_user_status_telemetry();
    void set_allocated_user_status_telemetry(::reporting::UserStatusTelemetry* user_status_telemetry);

private:
    const ::reporting::UserStatusTelemetry& _internal_user_status_telemetry() const;
    ::reporting::UserStatusTelemetry* _internal_mutable_user_status_telemetry();

public:
    void unsafe_arena_set_allocated_user_status_telemetry(::reporting::UserStatusTelemetry* user_status_telemetry);
    ::reporting::UserStatusTelemetry* unsafe_arena_release_user_status_telemetry();

    // optional .reporting.DisplaysTelemetry displays_telemetry = 6;
    bool has_displays_telemetry() const;

private:
    bool _internal_has_displays_telemetry() const;

public:
    void clear_displays_telemetry();
    const ::reporting::DisplaysTelemetry& displays_telemetry() const;
    PROTOBUF_NODISCARD ::reporting::DisplaysTelemetry* release_displays_telemetry();
    ::reporting::DisplaysTelemetry* mutable_displays_telemetry();
    void set_allocated_displays_telemetry(::reporting::DisplaysTelemetry* displays_telemetry);

private:
    const ::reporting::DisplaysTelemetry& _internal_displays_telemetry() const;
    ::reporting::DisplaysTelemetry* _internal_mutable_displays_telemetry();

public:
    void unsafe_arena_set_allocated_displays_telemetry(::reporting::DisplaysTelemetry* displays_telemetry);
    ::reporting::DisplaysTelemetry* unsafe_arena_release_displays_telemetry();

    // optional .reporting.AppTelemetry app_telemetry = 7;
    bool has_app_telemetry() const;

private:
    bool _internal_has_app_telemetry() const;

public:
    void clear_app_telemetry();
    const ::reporting::AppTelemetry& app_telemetry() const;
    PROTOBUF_NODISCARD ::reporting::AppTelemetry* release_app_telemetry();
    ::reporting::AppTelemetry* mutable_app_telemetry();
    void set_allocated_app_telemetry(::reporting::AppTelemetry* app_telemetry);

private:
    const ::reporting::AppTelemetry& _internal_app_telemetry() const;
    ::reporting::AppTelemetry* _internal_mutable_app_telemetry();

public:
    void unsafe_arena_set_allocated_app_telemetry(::reporting::AppTelemetry* app_telemetry);
    ::reporting::AppTelemetry* unsafe_arena_release_app_telemetry();

    // optional .reporting.FatalCrashTelemetry fatal_crash_telemetry = 9;
    bool has_fatal_crash_telemetry() const;

private:
    bool _internal_has_fatal_crash_telemetry() const;

public:
    void clear_fatal_crash_telemetry();
    const ::reporting::FatalCrashTelemetry& fatal_crash_telemetry() const;
    PROTOBUF_NODISCARD ::reporting::FatalCrashTelemetry* release_fatal_crash_telemetry();
    ::reporting::FatalCrashTelemetry* mutable_fatal_crash_telemetry();
    void set_allocated_fatal_crash_telemetry(::reporting::FatalCrashTelemetry* fatal_crash_telemetry);

private:
    const ::reporting::FatalCrashTelemetry& _internal_fatal_crash_telemetry() const;
    ::reporting::FatalCrashTelemetry* _internal_mutable_fatal_crash_telemetry();

public:
    void unsafe_arena_set_allocated_fatal_crash_telemetry(::reporting::FatalCrashTelemetry* fatal_crash_telemetry);
    ::reporting::FatalCrashTelemetry* unsafe_arena_release_fatal_crash_telemetry();

    // optional .reporting.RuntimeCountersTelemetry runtime_counters_telemetry = 10;
    bool has_runtime_counters_telemetry() const;

private:
    bool _internal_has_runtime_counters_telemetry() const;

public:
    void clear_runtime_counters_telemetry();
    const ::reporting::RuntimeCountersTelemetry& runtime_counters_telemetry() const;
    PROTOBUF_NODISCARD ::reporting::RuntimeCountersTelemetry* release_runtime_counters_telemetry();
    ::reporting::RuntimeCountersTelemetry* mutable_runtime_counters_telemetry();
    void set_allocated_runtime_counters_telemetry(::reporting::RuntimeCountersTelemetry* runtime_counters_telemetry);

private:
    const ::reporting::RuntimeCountersTelemetry& _internal_runtime_counters_telemetry() const;
    ::reporting::RuntimeCountersTelemetry* _internal_mutable_runtime_counters_telemetry();

public:
    void unsafe_arena_set_allocated_runtime_counters_telemetry(::reporting::RuntimeCountersTelemetry* runtime_counters_telemetry);
    ::reporting::RuntimeCountersTelemetry* unsafe_arena_release_runtime_counters_telemetry();

    // optional .reporting.WebsiteTelemetry website_telemetry = 11;
    bool has_website_telemetry() const;

private:
    bool _internal_has_website_telemetry() const;

public:
    void clear_website_telemetry();
    const ::reporting::WebsiteTelemetry& website_telemetry() const;
    PROTOBUF_NODISCARD ::reporting::WebsiteTelemetry* release_website_telemetry();
    ::reporting::WebsiteTelemetry* mutable_website_telemetry();
    void set_allocated_website_telemetry(::reporting::WebsiteTelemetry* website_telemetry);

private:
    const ::reporting::WebsiteTelemetry& _internal_website_telemetry() const;
    ::reporting::WebsiteTelemetry* _internal_mutable_website_telemetry();

public:
    void unsafe_arena_set_allocated_website_telemetry(::reporting::WebsiteTelemetry* website_telemetry);
    ::reporting::WebsiteTelemetry* unsafe_arena_release_website_telemetry();

    // optional .reporting.KioskHeartbeatTelemetry heartbeat_telemetry = 12;
    bool has_heartbeat_telemetry() const;

private:
    bool _internal_has_heartbeat_telemetry() const;

public:
    void clear_heartbeat_telemetry();
    const ::reporting::KioskHeartbeatTelemetry& heartbeat_telemetry() const;
    PROTOBUF_NODISCARD ::reporting::KioskHeartbeatTelemetry* release_heartbeat_telemetry();
    ::reporting::KioskHeartbeatTelemetry* mutable_heartbeat_telemetry();
    void set_allocated_heartbeat_telemetry(::reporting::KioskHeartbeatTelemetry* heartbeat_telemetry);

private:
    const ::reporting::KioskHeartbeatTelemetry& _internal_heartbeat_telemetry() const;
    ::reporting::KioskHeartbeatTelemetry* _internal_mutable_heartbeat_telemetry();

public:
    void unsafe_arena_set_allocated_heartbeat_telemetry(::reporting::KioskHeartbeatTelemetry* heartbeat_telemetry);
    ::reporting::KioskHeartbeatTelemetry* unsafe_arena_release_heartbeat_telemetry();

    // optional .reporting.KioskVisionTelemetry kiosk_vision_telemetry = 13;
    bool has_kiosk_vision_telemetry() const;

private:
    bool _internal_has_kiosk_vision_telemetry() const;

public:
    void clear_kiosk_vision_telemetry();
    const ::reporting::KioskVisionTelemetry& kiosk_vision_telemetry() const;
    PROTOBUF_NODISCARD ::reporting::KioskVisionTelemetry* release_kiosk_vision_telemetry();
    ::reporting::KioskVisionTelemetry* mutable_kiosk_vision_telemetry();
    void set_allocated_kiosk_vision_telemetry(::reporting::KioskVisionTelemetry* kiosk_vision_telemetry);

private:
    const ::reporting::KioskVisionTelemetry& _internal_kiosk_vision_telemetry() const;
    ::reporting::KioskVisionTelemetry* _internal_mutable_kiosk_vision_telemetry();

public:
    void unsafe_arena_set_allocated_kiosk_vision_telemetry(::reporting::KioskVisionTelemetry* kiosk_vision_telemetry);
    ::reporting::KioskVisionTelemetry* unsafe_arena_release_kiosk_vision_telemetry();

    // optional .reporting.KioskVisionStatusReport kiosk_vision_status = 14;
    bool has_kiosk_vision_status() const;

private:
    bool _internal_has_kiosk_vision_status() const;

public:
    void clear_kiosk_vision_status();
    const ::reporting::KioskVisionStatusReport& kiosk_vision_status() const;
    PROTOBUF_NODISCARD ::reporting::KioskVisionStatusReport* release_kiosk_vision_status();
    ::reporting::KioskVisionStatusReport* mutable_kiosk_vision_status();
    void set_allocated_kiosk_vision_status(::reporting::KioskVisionStatusReport* kiosk_vision_status);

private:
    const ::reporting::KioskVisionStatusReport& _internal_kiosk_vision_status() const;
    ::reporting::KioskVisionStatusReport* _internal_mutable_kiosk_vision_status();

public:
    void unsafe_arena_set_allocated_kiosk_vision_status(::reporting::KioskVisionStatusReport* kiosk_vision_status);
    ::reporting::KioskVisionStatusReport* unsafe_arena_release_kiosk_vision_status();

    // optional bool is_event_driven = 8;
    bool has_is_event_driven() const;

private:
    bool _internal_has_is_event_driven() const;

public:
    void clear_is_event_driven();
    bool is_event_driven() const;
    void set_is_event_driven(bool value);

private:
    bool _internal_is_event_driven() const;
    void _internal_set_is_event_driven(bool value);

public:
    // @@protoc_insertion_point(class_scope:reporting.TelemetryData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::reporting::NetworksTelemetry* networks_telemetry_;
        ::reporting::AudioTelemetry* audio_telemetry_;
        ::reporting::PeripheralsTelemetry* peripherals_telemetry_;
        ::reporting::BootPerformanceTelemetry* boot_performance_telemetry_;
        ::reporting::UserStatusTelemetry* user_status_telemetry_;
        ::reporting::DisplaysTelemetry* displays_telemetry_;
        ::reporting::AppTelemetry* app_telemetry_;
        ::reporting::FatalCrashTelemetry* fatal_crash_telemetry_;
        ::reporting::RuntimeCountersTelemetry* runtime_counters_telemetry_;
        ::reporting::WebsiteTelemetry* website_telemetry_;
        ::reporting::KioskHeartbeatTelemetry* heartbeat_telemetry_;
        ::reporting::KioskVisionTelemetry* kiosk_vision_telemetry_;
        ::reporting::KioskVisionStatusReport* kiosk_vision_status_;
        bool is_event_driven_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AppTelemetry final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.AppTelemetry) */ {
public:
    inline AppTelemetry()
        : AppTelemetry(nullptr)
    {
    }
    ~AppTelemetry() override;
    explicit PROTOBUF_CONSTEXPR AppTelemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AppTelemetry(const AppTelemetry& from);
    AppTelemetry(AppTelemetry&& from) noexcept
        : AppTelemetry()
    {
        *this = ::std::move(from);
    }

    inline AppTelemetry& operator=(const AppTelemetry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AppTelemetry& operator=(AppTelemetry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AppTelemetry& default_instance()
    {
        return *internal_default_instance();
    }
    enum AppMetricDataCase {
        kAppInstallData = 3,
        kAppUninstallData = 4,
        kAppLaunchData = 5,
        kAppUsageData = 6,
        APP_METRIC_DATA_NOT_SET = 0,
    };

    static inline const AppTelemetry* internal_default_instance()
    {
        return reinterpret_cast<const AppTelemetry*>(&_AppTelemetry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 31;

    friend void swap(AppTelemetry& a, AppTelemetry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AppTelemetry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AppTelemetry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AppTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AppTelemetry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AppTelemetry& from);
    void MergeFrom(const AppTelemetry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AppTelemetry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.AppTelemetry";
    }

protected:
    explicit AppTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kAppInstallDataFieldNumber = 3,
        kAppUninstallDataFieldNumber = 4,
        kAppLaunchDataFieldNumber = 5,
        kAppUsageDataFieldNumber = 6,
    };
    // .reporting.AppInstallData app_install_data = 3;
    bool has_app_install_data() const;

private:
    bool _internal_has_app_install_data() const;

public:
    void clear_app_install_data();
    const ::reporting::AppInstallData& app_install_data() const;
    PROTOBUF_NODISCARD ::reporting::AppInstallData* release_app_install_data();
    ::reporting::AppInstallData* mutable_app_install_data();
    void set_allocated_app_install_data(::reporting::AppInstallData* app_install_data);

private:
    const ::reporting::AppInstallData& _internal_app_install_data() const;
    ::reporting::AppInstallData* _internal_mutable_app_install_data();

public:
    void unsafe_arena_set_allocated_app_install_data(::reporting::AppInstallData* app_install_data);
    ::reporting::AppInstallData* unsafe_arena_release_app_install_data();

    // .reporting.AppUninstallData app_uninstall_data = 4;
    bool has_app_uninstall_data() const;

private:
    bool _internal_has_app_uninstall_data() const;

public:
    void clear_app_uninstall_data();
    const ::reporting::AppUninstallData& app_uninstall_data() const;
    PROTOBUF_NODISCARD ::reporting::AppUninstallData* release_app_uninstall_data();
    ::reporting::AppUninstallData* mutable_app_uninstall_data();
    void set_allocated_app_uninstall_data(::reporting::AppUninstallData* app_uninstall_data);

private:
    const ::reporting::AppUninstallData& _internal_app_uninstall_data() const;
    ::reporting::AppUninstallData* _internal_mutable_app_uninstall_data();

public:
    void unsafe_arena_set_allocated_app_uninstall_data(::reporting::AppUninstallData* app_uninstall_data);
    ::reporting::AppUninstallData* unsafe_arena_release_app_uninstall_data();

    // .reporting.AppLaunchData app_launch_data = 5;
    bool has_app_launch_data() const;

private:
    bool _internal_has_app_launch_data() const;

public:
    void clear_app_launch_data();
    const ::reporting::AppLaunchData& app_launch_data() const;
    PROTOBUF_NODISCARD ::reporting::AppLaunchData* release_app_launch_data();
    ::reporting::AppLaunchData* mutable_app_launch_data();
    void set_allocated_app_launch_data(::reporting::AppLaunchData* app_launch_data);

private:
    const ::reporting::AppLaunchData& _internal_app_launch_data() const;
    ::reporting::AppLaunchData* _internal_mutable_app_launch_data();

public:
    void unsafe_arena_set_allocated_app_launch_data(::reporting::AppLaunchData* app_launch_data);
    ::reporting::AppLaunchData* unsafe_arena_release_app_launch_data();

    // .reporting.AppUsageData app_usage_data = 6;
    bool has_app_usage_data() const;

private:
    bool _internal_has_app_usage_data() const;

public:
    void clear_app_usage_data();
    const ::reporting::AppUsageData& app_usage_data() const;
    PROTOBUF_NODISCARD ::reporting::AppUsageData* release_app_usage_data();
    ::reporting::AppUsageData* mutable_app_usage_data();
    void set_allocated_app_usage_data(::reporting::AppUsageData* app_usage_data);

private:
    const ::reporting::AppUsageData& _internal_app_usage_data() const;
    ::reporting::AppUsageData* _internal_mutable_app_usage_data();

public:
    void unsafe_arena_set_allocated_app_usage_data(::reporting::AppUsageData* app_usage_data);
    ::reporting::AppUsageData* unsafe_arena_release_app_usage_data();

    void clear_app_metric_data();
    AppMetricDataCase app_metric_data_case() const;
    // @@protoc_insertion_point(class_scope:reporting.AppTelemetry)
private:
    class _Internal;
    void set_has_app_install_data();
    void set_has_app_uninstall_data();
    void set_has_app_launch_data();
    void set_has_app_usage_data();

    inline bool has_app_metric_data() const;
    inline void clear_has_app_metric_data();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        union AppMetricDataUnion {
            constexpr AppMetricDataUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::reporting::AppInstallData* app_install_data_;
            ::reporting::AppUninstallData* app_uninstall_data_;
            ::reporting::AppLaunchData* app_launch_data_;
            ::reporting::AppUsageData* app_usage_data_;
        } app_metric_data_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AppInstallData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.AppInstallData) */ {
public:
    inline AppInstallData()
        : AppInstallData(nullptr)
    {
    }
    ~AppInstallData() override;
    explicit PROTOBUF_CONSTEXPR AppInstallData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AppInstallData(const AppInstallData& from);
    AppInstallData(AppInstallData&& from) noexcept
        : AppInstallData()
    {
        *this = ::std::move(from);
    }

    inline AppInstallData& operator=(const AppInstallData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AppInstallData& operator=(AppInstallData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AppInstallData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AppInstallData* internal_default_instance()
    {
        return reinterpret_cast<const AppInstallData*>(&_AppInstallData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 32;

    friend void swap(AppInstallData& a, AppInstallData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AppInstallData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AppInstallData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AppInstallData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AppInstallData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AppInstallData& from);
    void MergeFrom(const AppInstallData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AppInstallData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.AppInstallData";
    }

protected:
    explicit AppInstallData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kAppIdFieldNumber = 4,
        kAppInstallSourceFieldNumber = 1,
        kAppInstallReasonFieldNumber = 2,
        kAppInstallTimeFieldNumber = 3,
        kAppTypeFieldNumber = 5,
    };
    // optional string app_id = 4;
    bool has_app_id() const;

private:
    bool _internal_has_app_id() const;

public:
    void clear_app_id();
    const std::string& app_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_app_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_app_id();
    PROTOBUF_NODISCARD std::string* release_app_id();
    void set_allocated_app_id(std::string* app_id);

private:
    const std::string& _internal_app_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
    std::string* _internal_mutable_app_id();

public:
    // optional .apps.ApplicationInstallSource app_install_source = 1;
    bool has_app_install_source() const;

private:
    bool _internal_has_app_install_source() const;

public:
    void clear_app_install_source();
    ::apps::ApplicationInstallSource app_install_source() const;
    void set_app_install_source(::apps::ApplicationInstallSource value);

private:
    ::apps::ApplicationInstallSource _internal_app_install_source() const;
    void _internal_set_app_install_source(::apps::ApplicationInstallSource value);

public:
    // optional .apps.ApplicationInstallReason app_install_reason = 2;
    bool has_app_install_reason() const;

private:
    bool _internal_has_app_install_reason() const;

public:
    void clear_app_install_reason();
    ::apps::ApplicationInstallReason app_install_reason() const;
    void set_app_install_reason(::apps::ApplicationInstallReason value);

private:
    ::apps::ApplicationInstallReason _internal_app_install_reason() const;
    void _internal_set_app_install_reason(::apps::ApplicationInstallReason value);

public:
    // optional .apps.ApplicationInstallTime app_install_time = 3;
    bool has_app_install_time() const;

private:
    bool _internal_has_app_install_time() const;

public:
    void clear_app_install_time();
    ::apps::ApplicationInstallTime app_install_time() const;
    void set_app_install_time(::apps::ApplicationInstallTime value);

private:
    ::apps::ApplicationInstallTime _internal_app_install_time() const;
    void _internal_set_app_install_time(::apps::ApplicationInstallTime value);

public:
    // optional .apps.ApplicationType app_type = 5;
    bool has_app_type() const;

private:
    bool _internal_has_app_type() const;

public:
    void clear_app_type();
    ::apps::ApplicationType app_type() const;
    void set_app_type(::apps::ApplicationType value);

private:
    ::apps::ApplicationType _internal_app_type() const;
    void _internal_set_app_type(::apps::ApplicationType value);

public:
    // @@protoc_insertion_point(class_scope:reporting.AppInstallData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
        int app_install_source_;
        int app_install_reason_;
        int app_install_time_;
        int app_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AppLaunchData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.AppLaunchData) */ {
public:
    inline AppLaunchData()
        : AppLaunchData(nullptr)
    {
    }
    ~AppLaunchData() override;
    explicit PROTOBUF_CONSTEXPR AppLaunchData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AppLaunchData(const AppLaunchData& from);
    AppLaunchData(AppLaunchData&& from) noexcept
        : AppLaunchData()
    {
        *this = ::std::move(from);
    }

    inline AppLaunchData& operator=(const AppLaunchData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AppLaunchData& operator=(AppLaunchData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AppLaunchData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AppLaunchData* internal_default_instance()
    {
        return reinterpret_cast<const AppLaunchData*>(&_AppLaunchData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 33;

    friend void swap(AppLaunchData& a, AppLaunchData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AppLaunchData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AppLaunchData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AppLaunchData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AppLaunchData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AppLaunchData& from);
    void MergeFrom(const AppLaunchData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AppLaunchData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.AppLaunchData";
    }

protected:
    explicit AppLaunchData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kAppIdFieldNumber = 2,
        kAppLaunchSourceFieldNumber = 1,
        kAppTypeFieldNumber = 3,
    };
    // optional string app_id = 2;
    bool has_app_id() const;

private:
    bool _internal_has_app_id() const;

public:
    void clear_app_id();
    const std::string& app_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_app_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_app_id();
    PROTOBUF_NODISCARD std::string* release_app_id();
    void set_allocated_app_id(std::string* app_id);

private:
    const std::string& _internal_app_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
    std::string* _internal_mutable_app_id();

public:
    // optional .apps.ApplicationLaunchSource app_launch_source = 1;
    bool has_app_launch_source() const;

private:
    bool _internal_has_app_launch_source() const;

public:
    void clear_app_launch_source();
    ::apps::ApplicationLaunchSource app_launch_source() const;
    void set_app_launch_source(::apps::ApplicationLaunchSource value);

private:
    ::apps::ApplicationLaunchSource _internal_app_launch_source() const;
    void _internal_set_app_launch_source(::apps::ApplicationLaunchSource value);

public:
    // optional .apps.ApplicationType app_type = 3;
    bool has_app_type() const;

private:
    bool _internal_has_app_type() const;

public:
    void clear_app_type();
    ::apps::ApplicationType app_type() const;
    void set_app_type(::apps::ApplicationType value);

private:
    ::apps::ApplicationType _internal_app_type() const;
    void _internal_set_app_type(::apps::ApplicationType value);

public:
    // @@protoc_insertion_point(class_scope:reporting.AppLaunchData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
        int app_launch_source_;
        int app_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AppUsageData_AppUsage final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.AppUsageData.AppUsage) */ {
public:
    inline AppUsageData_AppUsage()
        : AppUsageData_AppUsage(nullptr)
    {
    }
    ~AppUsageData_AppUsage() override;
    explicit PROTOBUF_CONSTEXPR AppUsageData_AppUsage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AppUsageData_AppUsage(const AppUsageData_AppUsage& from);
    AppUsageData_AppUsage(AppUsageData_AppUsage&& from) noexcept
        : AppUsageData_AppUsage()
    {
        *this = ::std::move(from);
    }

    inline AppUsageData_AppUsage& operator=(const AppUsageData_AppUsage& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AppUsageData_AppUsage& operator=(AppUsageData_AppUsage&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AppUsageData_AppUsage& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AppUsageData_AppUsage* internal_default_instance()
    {
        return reinterpret_cast<const AppUsageData_AppUsage*>(&_AppUsageData_AppUsage_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 34;

    friend void swap(AppUsageData_AppUsage& a, AppUsageData_AppUsage& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AppUsageData_AppUsage* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AppUsageData_AppUsage* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AppUsageData_AppUsage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AppUsageData_AppUsage>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AppUsageData_AppUsage& from);
    void MergeFrom(const AppUsageData_AppUsage& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AppUsageData_AppUsage* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.AppUsageData.AppUsage";
    }

protected:
    explicit AppUsageData_AppUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kAppIdFieldNumber = 2,
        kAppInstanceIdFieldNumber = 4,
        kRunningTimeMsFieldNumber = 1,
        kAppTypeFieldNumber = 3,
    };
    // optional string app_id = 2;
    bool has_app_id() const;

private:
    bool _internal_has_app_id() const;

public:
    void clear_app_id();
    const std::string& app_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_app_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_app_id();
    PROTOBUF_NODISCARD std::string* release_app_id();
    void set_allocated_app_id(std::string* app_id);

private:
    const std::string& _internal_app_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
    std::string* _internal_mutable_app_id();

public:
    // optional string app_instance_id = 4;
    bool has_app_instance_id() const;

private:
    bool _internal_has_app_instance_id() const;

public:
    void clear_app_instance_id();
    const std::string& app_instance_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_app_instance_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_app_instance_id();
    PROTOBUF_NODISCARD std::string* release_app_instance_id();
    void set_allocated_app_instance_id(std::string* app_instance_id);

private:
    const std::string& _internal_app_instance_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_instance_id(const std::string& value);
    std::string* _internal_mutable_app_instance_id();

public:
    // optional int64 running_time_ms = 1;
    bool has_running_time_ms() const;

private:
    bool _internal_has_running_time_ms() const;

public:
    void clear_running_time_ms();
    int64_t running_time_ms() const;
    void set_running_time_ms(int64_t value);

private:
    int64_t _internal_running_time_ms() const;
    void _internal_set_running_time_ms(int64_t value);

public:
    // optional .apps.ApplicationType app_type = 3;
    bool has_app_type() const;

private:
    bool _internal_has_app_type() const;

public:
    void clear_app_type();
    ::apps::ApplicationType app_type() const;
    void set_app_type(::apps::ApplicationType value);

private:
    ::apps::ApplicationType _internal_app_type() const;
    void _internal_set_app_type(::apps::ApplicationType value);

public:
    // @@protoc_insertion_point(class_scope:reporting.AppUsageData.AppUsage)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_instance_id_;
        int64_t running_time_ms_;
        int app_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AppUsageData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.AppUsageData) */ {
public:
    inline AppUsageData()
        : AppUsageData(nullptr)
    {
    }
    ~AppUsageData() override;
    explicit PROTOBUF_CONSTEXPR AppUsageData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AppUsageData(const AppUsageData& from);
    AppUsageData(AppUsageData&& from) noexcept
        : AppUsageData()
    {
        *this = ::std::move(from);
    }

    inline AppUsageData& operator=(const AppUsageData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AppUsageData& operator=(AppUsageData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AppUsageData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AppUsageData* internal_default_instance()
    {
        return reinterpret_cast<const AppUsageData*>(&_AppUsageData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 35;

    friend void swap(AppUsageData& a, AppUsageData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AppUsageData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AppUsageData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AppUsageData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AppUsageData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AppUsageData& from);
    void MergeFrom(const AppUsageData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AppUsageData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.AppUsageData";
    }

protected:
    explicit AppUsageData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef AppUsageData_AppUsage AppUsage;

    // accessors -------------------------------------------------------

    enum : int {
        kAppUsageFieldNumber = 2,
    };
    // repeated .reporting.AppUsageData.AppUsage app_usage = 2;
    int app_usage_size() const;

private:
    int _internal_app_usage_size() const;

public:
    void clear_app_usage();
    ::reporting::AppUsageData_AppUsage* mutable_app_usage(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::AppUsageData_AppUsage>* mutable_app_usage();

private:
    const ::reporting::AppUsageData_AppUsage& _internal_app_usage(int index) const;
    ::reporting::AppUsageData_AppUsage* _internal_add_app_usage();

public:
    const ::reporting::AppUsageData_AppUsage& app_usage(int index) const;
    ::reporting::AppUsageData_AppUsage* add_app_usage();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::AppUsageData_AppUsage>& app_usage() const;

    // @@protoc_insertion_point(class_scope:reporting.AppUsageData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::AppUsageData_AppUsage> app_usage_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class AppUninstallData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.AppUninstallData) */ {
public:
    inline AppUninstallData()
        : AppUninstallData(nullptr)
    {
    }
    ~AppUninstallData() override;
    explicit PROTOBUF_CONSTEXPR AppUninstallData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    AppUninstallData(const AppUninstallData& from);
    AppUninstallData(AppUninstallData&& from) noexcept
        : AppUninstallData()
    {
        *this = ::std::move(from);
    }

    inline AppUninstallData& operator=(const AppUninstallData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline AppUninstallData& operator=(AppUninstallData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const AppUninstallData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const AppUninstallData* internal_default_instance()
    {
        return reinterpret_cast<const AppUninstallData*>(&_AppUninstallData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 36;

    friend void swap(AppUninstallData& a, AppUninstallData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(AppUninstallData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(AppUninstallData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    AppUninstallData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<AppUninstallData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const AppUninstallData& from);
    void MergeFrom(const AppUninstallData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(AppUninstallData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.AppUninstallData";
    }

protected:
    explicit AppUninstallData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kAppIdFieldNumber = 2,
        kAppUninstallSourceFieldNumber = 1,
        kAppTypeFieldNumber = 3,
    };
    // optional string app_id = 2;
    bool has_app_id() const;

private:
    bool _internal_has_app_id() const;

public:
    void clear_app_id();
    const std::string& app_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_app_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_app_id();
    PROTOBUF_NODISCARD std::string* release_app_id();
    void set_allocated_app_id(std::string* app_id);

private:
    const std::string& _internal_app_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(const std::string& value);
    std::string* _internal_mutable_app_id();

public:
    // optional .apps.ApplicationUninstallSource app_uninstall_source = 1;
    bool has_app_uninstall_source() const;

private:
    bool _internal_has_app_uninstall_source() const;

public:
    void clear_app_uninstall_source();
    ::apps::ApplicationUninstallSource app_uninstall_source() const;
    void set_app_uninstall_source(::apps::ApplicationUninstallSource value);

private:
    ::apps::ApplicationUninstallSource _internal_app_uninstall_source() const;
    void _internal_set_app_uninstall_source(::apps::ApplicationUninstallSource value);

public:
    // optional .apps.ApplicationType app_type = 3;
    bool has_app_type() const;

private:
    bool _internal_has_app_type() const;

public:
    void clear_app_type();
    ::apps::ApplicationType app_type() const;
    void set_app_type(::apps::ApplicationType value);

private:
    ::apps::ApplicationType _internal_app_type() const;
    void _internal_set_app_type(::apps::ApplicationType value);

public:
    // @@protoc_insertion_point(class_scope:reporting.AppUninstallData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_id_;
        int app_uninstall_source_;
        int app_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class WebsiteTelemetry final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.WebsiteTelemetry) */ {
public:
    inline WebsiteTelemetry()
        : WebsiteTelemetry(nullptr)
    {
    }
    ~WebsiteTelemetry() override;
    explicit PROTOBUF_CONSTEXPR WebsiteTelemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    WebsiteTelemetry(const WebsiteTelemetry& from);
    WebsiteTelemetry(WebsiteTelemetry&& from) noexcept
        : WebsiteTelemetry()
    {
        *this = ::std::move(from);
    }

    inline WebsiteTelemetry& operator=(const WebsiteTelemetry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline WebsiteTelemetry& operator=(WebsiteTelemetry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const WebsiteTelemetry& default_instance()
    {
        return *internal_default_instance();
    }
    enum WebsiteMetricDataCase {
        kWebsiteOpenedData = 1,
        kWebsiteClosedData = 2,
        kWebsiteUsageData = 3,
        WEBSITE_METRIC_DATA_NOT_SET = 0,
    };

    static inline const WebsiteTelemetry* internal_default_instance()
    {
        return reinterpret_cast<const WebsiteTelemetry*>(&_WebsiteTelemetry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 37;

    friend void swap(WebsiteTelemetry& a, WebsiteTelemetry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(WebsiteTelemetry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(WebsiteTelemetry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    WebsiteTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<WebsiteTelemetry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const WebsiteTelemetry& from);
    void MergeFrom(const WebsiteTelemetry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(WebsiteTelemetry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.WebsiteTelemetry";
    }

protected:
    explicit WebsiteTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kWebsiteOpenedDataFieldNumber = 1,
        kWebsiteClosedDataFieldNumber = 2,
        kWebsiteUsageDataFieldNumber = 3,
    };
    // .reporting.WebsiteOpenedData website_opened_data = 1;
    bool has_website_opened_data() const;

private:
    bool _internal_has_website_opened_data() const;

public:
    void clear_website_opened_data();
    const ::reporting::WebsiteOpenedData& website_opened_data() const;
    PROTOBUF_NODISCARD ::reporting::WebsiteOpenedData* release_website_opened_data();
    ::reporting::WebsiteOpenedData* mutable_website_opened_data();
    void set_allocated_website_opened_data(::reporting::WebsiteOpenedData* website_opened_data);

private:
    const ::reporting::WebsiteOpenedData& _internal_website_opened_data() const;
    ::reporting::WebsiteOpenedData* _internal_mutable_website_opened_data();

public:
    void unsafe_arena_set_allocated_website_opened_data(::reporting::WebsiteOpenedData* website_opened_data);
    ::reporting::WebsiteOpenedData* unsafe_arena_release_website_opened_data();

    // .reporting.WebsiteClosedData website_closed_data = 2;
    bool has_website_closed_data() const;

private:
    bool _internal_has_website_closed_data() const;

public:
    void clear_website_closed_data();
    const ::reporting::WebsiteClosedData& website_closed_data() const;
    PROTOBUF_NODISCARD ::reporting::WebsiteClosedData* release_website_closed_data();
    ::reporting::WebsiteClosedData* mutable_website_closed_data();
    void set_allocated_website_closed_data(::reporting::WebsiteClosedData* website_closed_data);

private:
    const ::reporting::WebsiteClosedData& _internal_website_closed_data() const;
    ::reporting::WebsiteClosedData* _internal_mutable_website_closed_data();

public:
    void unsafe_arena_set_allocated_website_closed_data(::reporting::WebsiteClosedData* website_closed_data);
    ::reporting::WebsiteClosedData* unsafe_arena_release_website_closed_data();

    // .reporting.WebsiteUsageData website_usage_data = 3;
    bool has_website_usage_data() const;

private:
    bool _internal_has_website_usage_data() const;

public:
    void clear_website_usage_data();
    const ::reporting::WebsiteUsageData& website_usage_data() const;
    PROTOBUF_NODISCARD ::reporting::WebsiteUsageData* release_website_usage_data();
    ::reporting::WebsiteUsageData* mutable_website_usage_data();
    void set_allocated_website_usage_data(::reporting::WebsiteUsageData* website_usage_data);

private:
    const ::reporting::WebsiteUsageData& _internal_website_usage_data() const;
    ::reporting::WebsiteUsageData* _internal_mutable_website_usage_data();

public:
    void unsafe_arena_set_allocated_website_usage_data(::reporting::WebsiteUsageData* website_usage_data);
    ::reporting::WebsiteUsageData* unsafe_arena_release_website_usage_data();

    void clear_website_metric_data();
    WebsiteMetricDataCase website_metric_data_case() const;
    // @@protoc_insertion_point(class_scope:reporting.WebsiteTelemetry)
private:
    class _Internal;
    void set_has_website_opened_data();
    void set_has_website_closed_data();
    void set_has_website_usage_data();

    inline bool has_website_metric_data() const;
    inline void clear_has_website_metric_data();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        union WebsiteMetricDataUnion {
            constexpr WebsiteMetricDataUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::reporting::WebsiteOpenedData* website_opened_data_;
            ::reporting::WebsiteClosedData* website_closed_data_;
            ::reporting::WebsiteUsageData* website_usage_data_;
        } website_metric_data_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class WebsiteOpenedData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.WebsiteOpenedData) */ {
public:
    inline WebsiteOpenedData()
        : WebsiteOpenedData(nullptr)
    {
    }
    ~WebsiteOpenedData() override;
    explicit PROTOBUF_CONSTEXPR WebsiteOpenedData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    WebsiteOpenedData(const WebsiteOpenedData& from);
    WebsiteOpenedData(WebsiteOpenedData&& from) noexcept
        : WebsiteOpenedData()
    {
        *this = ::std::move(from);
    }

    inline WebsiteOpenedData& operator=(const WebsiteOpenedData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline WebsiteOpenedData& operator=(WebsiteOpenedData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const WebsiteOpenedData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const WebsiteOpenedData* internal_default_instance()
    {
        return reinterpret_cast<const WebsiteOpenedData*>(&_WebsiteOpenedData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 38;

    friend void swap(WebsiteOpenedData& a, WebsiteOpenedData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(WebsiteOpenedData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(WebsiteOpenedData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    WebsiteOpenedData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<WebsiteOpenedData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const WebsiteOpenedData& from);
    void MergeFrom(const WebsiteOpenedData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(WebsiteOpenedData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.WebsiteOpenedData";
    }

protected:
    explicit WebsiteOpenedData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUrlFieldNumber = 1,
        kRenderProcessHostIdFieldNumber = 2,
        kRenderFrameRoutingIdFieldNumber = 3,
    };
    // optional string url = 1;
    bool has_url() const;

private:
    bool _internal_has_url() const;

public:
    void clear_url();
    const std::string& url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url();
    PROTOBUF_NODISCARD std::string* release_url();
    void set_allocated_url(std::string* url);

private:
    const std::string& _internal_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
    std::string* _internal_mutable_url();

public:
    // optional int32 render_process_host_id = 2;
    bool has_render_process_host_id() const;

private:
    bool _internal_has_render_process_host_id() const;

public:
    void clear_render_process_host_id();
    int32_t render_process_host_id() const;
    void set_render_process_host_id(int32_t value);

private:
    int32_t _internal_render_process_host_id() const;
    void _internal_set_render_process_host_id(int32_t value);

public:
    // optional int32 render_frame_routing_id = 3;
    bool has_render_frame_routing_id() const;

private:
    bool _internal_has_render_frame_routing_id() const;

public:
    void clear_render_frame_routing_id();
    int32_t render_frame_routing_id() const;
    void set_render_frame_routing_id(int32_t value);

private:
    int32_t _internal_render_frame_routing_id() const;
    void _internal_set_render_frame_routing_id(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.WebsiteOpenedData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
        int32_t render_process_host_id_;
        int32_t render_frame_routing_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class WebsiteClosedData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.WebsiteClosedData) */ {
public:
    inline WebsiteClosedData()
        : WebsiteClosedData(nullptr)
    {
    }
    ~WebsiteClosedData() override;
    explicit PROTOBUF_CONSTEXPR WebsiteClosedData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    WebsiteClosedData(const WebsiteClosedData& from);
    WebsiteClosedData(WebsiteClosedData&& from) noexcept
        : WebsiteClosedData()
    {
        *this = ::std::move(from);
    }

    inline WebsiteClosedData& operator=(const WebsiteClosedData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline WebsiteClosedData& operator=(WebsiteClosedData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const WebsiteClosedData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const WebsiteClosedData* internal_default_instance()
    {
        return reinterpret_cast<const WebsiteClosedData*>(&_WebsiteClosedData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 39;

    friend void swap(WebsiteClosedData& a, WebsiteClosedData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(WebsiteClosedData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(WebsiteClosedData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    WebsiteClosedData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<WebsiteClosedData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const WebsiteClosedData& from);
    void MergeFrom(const WebsiteClosedData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(WebsiteClosedData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.WebsiteClosedData";
    }

protected:
    explicit WebsiteClosedData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUrlFieldNumber = 1,
        kRenderProcessHostIdFieldNumber = 2,
        kRenderFrameRoutingIdFieldNumber = 3,
    };
    // optional string url = 1;
    bool has_url() const;

private:
    bool _internal_has_url() const;

public:
    void clear_url();
    const std::string& url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url();
    PROTOBUF_NODISCARD std::string* release_url();
    void set_allocated_url(std::string* url);

private:
    const std::string& _internal_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
    std::string* _internal_mutable_url();

public:
    // optional int32 render_process_host_id = 2;
    bool has_render_process_host_id() const;

private:
    bool _internal_has_render_process_host_id() const;

public:
    void clear_render_process_host_id();
    int32_t render_process_host_id() const;
    void set_render_process_host_id(int32_t value);

private:
    int32_t _internal_render_process_host_id() const;
    void _internal_set_render_process_host_id(int32_t value);

public:
    // optional int32 render_frame_routing_id = 3;
    bool has_render_frame_routing_id() const;

private:
    bool _internal_has_render_frame_routing_id() const;

public:
    void clear_render_frame_routing_id();
    int32_t render_frame_routing_id() const;
    void set_render_frame_routing_id(int32_t value);

private:
    int32_t _internal_render_frame_routing_id() const;
    void _internal_set_render_frame_routing_id(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.WebsiteClosedData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
        int32_t render_process_host_id_;
        int32_t render_frame_routing_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class WebsiteUsageData_WebsiteUsage final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.WebsiteUsageData.WebsiteUsage) */ {
public:
    inline WebsiteUsageData_WebsiteUsage()
        : WebsiteUsageData_WebsiteUsage(nullptr)
    {
    }
    ~WebsiteUsageData_WebsiteUsage() override;
    explicit PROTOBUF_CONSTEXPR WebsiteUsageData_WebsiteUsage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    WebsiteUsageData_WebsiteUsage(const WebsiteUsageData_WebsiteUsage& from);
    WebsiteUsageData_WebsiteUsage(WebsiteUsageData_WebsiteUsage&& from) noexcept
        : WebsiteUsageData_WebsiteUsage()
    {
        *this = ::std::move(from);
    }

    inline WebsiteUsageData_WebsiteUsage& operator=(const WebsiteUsageData_WebsiteUsage& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline WebsiteUsageData_WebsiteUsage& operator=(WebsiteUsageData_WebsiteUsage&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const WebsiteUsageData_WebsiteUsage& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const WebsiteUsageData_WebsiteUsage* internal_default_instance()
    {
        return reinterpret_cast<const WebsiteUsageData_WebsiteUsage*>(&_WebsiteUsageData_WebsiteUsage_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 40;

    friend void swap(WebsiteUsageData_WebsiteUsage& a, WebsiteUsageData_WebsiteUsage& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(WebsiteUsageData_WebsiteUsage* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(WebsiteUsageData_WebsiteUsage* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    WebsiteUsageData_WebsiteUsage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<WebsiteUsageData_WebsiteUsage>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const WebsiteUsageData_WebsiteUsage& from);
    void MergeFrom(const WebsiteUsageData_WebsiteUsage& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(WebsiteUsageData_WebsiteUsage* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.WebsiteUsageData.WebsiteUsage";
    }

protected:
    explicit WebsiteUsageData_WebsiteUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUrlFieldNumber = 1,
        kRunningTimeMsFieldNumber = 2,
    };
    // optional string url = 1;
    bool has_url() const;

private:
    bool _internal_has_url() const;

public:
    void clear_url();
    const std::string& url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url();
    PROTOBUF_NODISCARD std::string* release_url();
    void set_allocated_url(std::string* url);

private:
    const std::string& _internal_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
    std::string* _internal_mutable_url();

public:
    // optional int64 running_time_ms = 2;
    bool has_running_time_ms() const;

private:
    bool _internal_has_running_time_ms() const;

public:
    void clear_running_time_ms();
    int64_t running_time_ms() const;
    void set_running_time_ms(int64_t value);

private:
    int64_t _internal_running_time_ms() const;
    void _internal_set_running_time_ms(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.WebsiteUsageData.WebsiteUsage)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
        int64_t running_time_ms_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class WebsiteUsageData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.WebsiteUsageData) */ {
public:
    inline WebsiteUsageData()
        : WebsiteUsageData(nullptr)
    {
    }
    ~WebsiteUsageData() override;
    explicit PROTOBUF_CONSTEXPR WebsiteUsageData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    WebsiteUsageData(const WebsiteUsageData& from);
    WebsiteUsageData(WebsiteUsageData&& from) noexcept
        : WebsiteUsageData()
    {
        *this = ::std::move(from);
    }

    inline WebsiteUsageData& operator=(const WebsiteUsageData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline WebsiteUsageData& operator=(WebsiteUsageData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const WebsiteUsageData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const WebsiteUsageData* internal_default_instance()
    {
        return reinterpret_cast<const WebsiteUsageData*>(&_WebsiteUsageData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 41;

    friend void swap(WebsiteUsageData& a, WebsiteUsageData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(WebsiteUsageData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(WebsiteUsageData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    WebsiteUsageData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<WebsiteUsageData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const WebsiteUsageData& from);
    void MergeFrom(const WebsiteUsageData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(WebsiteUsageData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.WebsiteUsageData";
    }

protected:
    explicit WebsiteUsageData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef WebsiteUsageData_WebsiteUsage WebsiteUsage;

    // accessors -------------------------------------------------------

    enum : int {
        kWebsiteUsageFieldNumber = 3,
    };
    // repeated .reporting.WebsiteUsageData.WebsiteUsage website_usage = 3;
    int website_usage_size() const;

private:
    int _internal_website_usage_size() const;

public:
    void clear_website_usage();
    ::reporting::WebsiteUsageData_WebsiteUsage* mutable_website_usage(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::WebsiteUsageData_WebsiteUsage>* mutable_website_usage();

private:
    const ::reporting::WebsiteUsageData_WebsiteUsage& _internal_website_usage(int index) const;
    ::reporting::WebsiteUsageData_WebsiteUsage* _internal_add_website_usage();

public:
    const ::reporting::WebsiteUsageData_WebsiteUsage& website_usage(int index) const;
    ::reporting::WebsiteUsageData_WebsiteUsage* add_website_usage();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::WebsiteUsageData_WebsiteUsage>& website_usage() const;

    // @@protoc_insertion_point(class_scope:reporting.WebsiteUsageData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::WebsiteUsageData_WebsiteUsage> website_usage_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PeripheralsTelemetry final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.PeripheralsTelemetry) */ {
public:
    inline PeripheralsTelemetry()
        : PeripheralsTelemetry(nullptr)
    {
    }
    ~PeripheralsTelemetry() override;
    explicit PROTOBUF_CONSTEXPR PeripheralsTelemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PeripheralsTelemetry(const PeripheralsTelemetry& from);
    PeripheralsTelemetry(PeripheralsTelemetry&& from) noexcept
        : PeripheralsTelemetry()
    {
        *this = ::std::move(from);
    }

    inline PeripheralsTelemetry& operator=(const PeripheralsTelemetry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline PeripheralsTelemetry& operator=(PeripheralsTelemetry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const PeripheralsTelemetry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const PeripheralsTelemetry* internal_default_instance()
    {
        return reinterpret_cast<const PeripheralsTelemetry*>(&_PeripheralsTelemetry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 42;

    friend void swap(PeripheralsTelemetry& a, PeripheralsTelemetry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(PeripheralsTelemetry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PeripheralsTelemetry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PeripheralsTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<PeripheralsTelemetry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const PeripheralsTelemetry& from);
    void MergeFrom(const PeripheralsTelemetry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PeripheralsTelemetry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.PeripheralsTelemetry";
    }

protected:
    explicit PeripheralsTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUsbTelemetryFieldNumber = 1,
    };
    // repeated .reporting.UsbTelemetry usb_telemetry = 1;
    int usb_telemetry_size() const;

private:
    int _internal_usb_telemetry_size() const;

public:
    void clear_usb_telemetry();
    ::reporting::UsbTelemetry* mutable_usb_telemetry(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::UsbTelemetry>* mutable_usb_telemetry();

private:
    const ::reporting::UsbTelemetry& _internal_usb_telemetry(int index) const;
    ::reporting::UsbTelemetry* _internal_add_usb_telemetry();

public:
    const ::reporting::UsbTelemetry& usb_telemetry(int index) const;
    ::reporting::UsbTelemetry* add_usb_telemetry();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::UsbTelemetry>& usb_telemetry() const;

    // @@protoc_insertion_point(class_scope:reporting.PeripheralsTelemetry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::UsbTelemetry> usb_telemetry_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class UsbTelemetry final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.UsbTelemetry) */ {
public:
    inline UsbTelemetry()
        : UsbTelemetry(nullptr)
    {
    }
    ~UsbTelemetry() override;
    explicit PROTOBUF_CONSTEXPR UsbTelemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    UsbTelemetry(const UsbTelemetry& from);
    UsbTelemetry(UsbTelemetry&& from) noexcept
        : UsbTelemetry()
    {
        *this = ::std::move(from);
    }

    inline UsbTelemetry& operator=(const UsbTelemetry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UsbTelemetry& operator=(UsbTelemetry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const UsbTelemetry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const UsbTelemetry* internal_default_instance()
    {
        return reinterpret_cast<const UsbTelemetry*>(&_UsbTelemetry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 43;

    friend void swap(UsbTelemetry& a, UsbTelemetry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(UsbTelemetry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UsbTelemetry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UsbTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<UsbTelemetry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const UsbTelemetry& from);
    void MergeFrom(const UsbTelemetry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(UsbTelemetry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.UsbTelemetry";
    }

protected:
    explicit UsbTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCategoriesFieldNumber = 5,
        kVendorFieldNumber = 1,
        kNameFieldNumber = 2,
        kFirmwareVersionFieldNumber = 8,
        kVidFieldNumber = 3,
        kPidFieldNumber = 4,
        kClassIdFieldNumber = 6,
        kSubclassIdFieldNumber = 7,
    };
    // repeated string categories = 5;
    int categories_size() const;

private:
    int _internal_categories_size() const;

public:
    void clear_categories();
    const std::string& categories(int index) const;
    std::string* mutable_categories(int index);
    void set_categories(int index, const std::string& value);
    void set_categories(int index, std::string&& value);
    void set_categories(int index, const char* value);
    void set_categories(int index, const char* value, size_t size);
    std::string* add_categories();
    void add_categories(const std::string& value);
    void add_categories(std::string&& value);
    void add_categories(const char* value);
    void add_categories(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& categories() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_categories();

private:
    const std::string& _internal_categories(int index) const;
    std::string* _internal_add_categories();

public:
    // optional string vendor = 1;
    bool has_vendor() const;

private:
    bool _internal_has_vendor() const;

public:
    void clear_vendor();
    const std::string& vendor() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_vendor(ArgT0&& arg0, ArgT... args);
    std::string* mutable_vendor();
    PROTOBUF_NODISCARD std::string* release_vendor();
    void set_allocated_vendor(std::string* vendor);

private:
    const std::string& _internal_vendor() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_vendor(const std::string& value);
    std::string* _internal_mutable_vendor();

public:
    // optional string name = 2;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // optional string firmware_version = 8;
    bool has_firmware_version() const;

private:
    bool _internal_has_firmware_version() const;

public:
    void clear_firmware_version();
    const std::string& firmware_version() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_firmware_version(ArgT0&& arg0, ArgT... args);
    std::string* mutable_firmware_version();
    PROTOBUF_NODISCARD std::string* release_firmware_version();
    void set_allocated_firmware_version(std::string* firmware_version);

private:
    const std::string& _internal_firmware_version() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_firmware_version(const std::string& value);
    std::string* _internal_mutable_firmware_version();

public:
    // optional int32 vid = 3;
    bool has_vid() const;

private:
    bool _internal_has_vid() const;

public:
    void clear_vid();
    int32_t vid() const;
    void set_vid(int32_t value);

private:
    int32_t _internal_vid() const;
    void _internal_set_vid(int32_t value);

public:
    // optional int32 pid = 4;
    bool has_pid() const;

private:
    bool _internal_has_pid() const;

public:
    void clear_pid();
    int32_t pid() const;
    void set_pid(int32_t value);

private:
    int32_t _internal_pid() const;
    void _internal_set_pid(int32_t value);

public:
    // optional int32 class_id = 6;
    bool has_class_id() const;

private:
    bool _internal_has_class_id() const;

public:
    void clear_class_id();
    int32_t class_id() const;
    void set_class_id(int32_t value);

private:
    int32_t _internal_class_id() const;
    void _internal_set_class_id(int32_t value);

public:
    // optional int32 subclass_id = 7;
    bool has_subclass_id() const;

private:
    bool _internal_has_subclass_id() const;

public:
    void clear_subclass_id();
    int32_t subclass_id() const;
    void set_subclass_id(int32_t value);

private:
    int32_t _internal_subclass_id() const;
    void _internal_set_subclass_id(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.UsbTelemetry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> categories_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr firmware_version_;
        int32_t vid_;
        int32_t pid_;
        int32_t class_id_;
        int32_t subclass_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class FatalCrashTelemetry final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.FatalCrashTelemetry) */ {
public:
    inline FatalCrashTelemetry()
        : FatalCrashTelemetry(nullptr)
    {
    }
    ~FatalCrashTelemetry() override;
    explicit PROTOBUF_CONSTEXPR FatalCrashTelemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FatalCrashTelemetry(const FatalCrashTelemetry& from);
    FatalCrashTelemetry(FatalCrashTelemetry&& from) noexcept
        : FatalCrashTelemetry()
    {
        *this = ::std::move(from);
    }

    inline FatalCrashTelemetry& operator=(const FatalCrashTelemetry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FatalCrashTelemetry& operator=(FatalCrashTelemetry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const FatalCrashTelemetry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FatalCrashTelemetry* internal_default_instance()
    {
        return reinterpret_cast<const FatalCrashTelemetry*>(&_FatalCrashTelemetry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 44;

    friend void swap(FatalCrashTelemetry& a, FatalCrashTelemetry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FatalCrashTelemetry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FatalCrashTelemetry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FatalCrashTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FatalCrashTelemetry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FatalCrashTelemetry& from);
    void MergeFrom(const FatalCrashTelemetry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FatalCrashTelemetry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.FatalCrashTelemetry";
    }

protected:
    explicit FatalCrashTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef FatalCrashTelemetry_CrashType CrashType;
    static constexpr CrashType CRASH_TYPE_UNSPECIFIED = FatalCrashTelemetry_CrashType_CRASH_TYPE_UNSPECIFIED;
    static constexpr CrashType CRASH_TYPE_KERNEL = FatalCrashTelemetry_CrashType_CRASH_TYPE_KERNEL;
    static constexpr CrashType CRASH_TYPE_EMBEDDED_CONTROLLER = FatalCrashTelemetry_CrashType_CRASH_TYPE_EMBEDDED_CONTROLLER;
    static constexpr CrashType CRASH_TYPE_CHROME = FatalCrashTelemetry_CrashType_CRASH_TYPE_CHROME;
    static inline bool CrashType_IsValid(int value)
    {
        return FatalCrashTelemetry_CrashType_IsValid(value);
    }
    static constexpr CrashType CrashType_MIN = FatalCrashTelemetry_CrashType_CrashType_MIN;
    static constexpr CrashType CrashType_MAX = FatalCrashTelemetry_CrashType_CrashType_MAX;
    static constexpr int CrashType_ARRAYSIZE = FatalCrashTelemetry_CrashType_CrashType_ARRAYSIZE;
    template <typename T> static inline const std::string& CrashType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, CrashType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function CrashType_Name.");
        return FatalCrashTelemetry_CrashType_Name(enum_t_value);
    }
    static inline bool CrashType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CrashType* value)
    {
        return FatalCrashTelemetry_CrashType_Parse(name, value);
    }

    typedef FatalCrashTelemetry_SessionType SessionType;
    static constexpr SessionType SESSION_TYPE_UNSPECIFIED = FatalCrashTelemetry_SessionType_SESSION_TYPE_UNSPECIFIED;
    static constexpr SessionType SESSION_TYPE_REGULAR = FatalCrashTelemetry_SessionType_SESSION_TYPE_REGULAR;
    static constexpr SessionType SESSION_TYPE_CHILD = FatalCrashTelemetry_SessionType_SESSION_TYPE_CHILD;
    static constexpr SessionType SESSION_TYPE_KIOSK_APP = FatalCrashTelemetry_SessionType_SESSION_TYPE_KIOSK_APP;
    static constexpr SessionType SESSION_TYPE_ARC_KIOSK_APP = FatalCrashTelemetry_SessionType_SESSION_TYPE_ARC_KIOSK_APP;
    static constexpr SessionType SESSION_TYPE_WEB_KIOSK_APP = FatalCrashTelemetry_SessionType_SESSION_TYPE_WEB_KIOSK_APP;
    static constexpr SessionType SESSION_TYPE_GUEST = FatalCrashTelemetry_SessionType_SESSION_TYPE_GUEST;
    static constexpr SessionType SESSION_TYPE_PUBLIC_ACCOUNT = FatalCrashTelemetry_SessionType_SESSION_TYPE_PUBLIC_ACCOUNT;
    static constexpr SessionType SESSION_TYPE_ACTIVE_DIRECTORY = FatalCrashTelemetry_SessionType_SESSION_TYPE_ACTIVE_DIRECTORY;
    static inline bool SessionType_IsValid(int value)
    {
        return FatalCrashTelemetry_SessionType_IsValid(value);
    }
    static constexpr SessionType SessionType_MIN = FatalCrashTelemetry_SessionType_SessionType_MIN;
    static constexpr SessionType SessionType_MAX = FatalCrashTelemetry_SessionType_SessionType_MAX;
    static constexpr int SessionType_ARRAYSIZE = FatalCrashTelemetry_SessionType_SessionType_ARRAYSIZE;
    template <typename T> static inline const std::string& SessionType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, SessionType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function SessionType_Name.");
        return FatalCrashTelemetry_SessionType_Name(enum_t_value);
    }
    static inline bool SessionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionType* value)
    {
        return FatalCrashTelemetry_SessionType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kCrashReportIdFieldNumber = 5,
        kLocalIdFieldNumber = 6,
        kEventBasedLogIdFieldNumber = 8,
        kAffiliatedUserFieldNumber = 4,
        kTypeFieldNumber = 1,
        kSessionTypeFieldNumber = 2,
        kTimestampUsFieldNumber = 3,
        kBeenReportedWithoutCrashReportIdFieldNumber = 7,
    };
    // optional string crash_report_id = 5;
    bool has_crash_report_id() const;

private:
    bool _internal_has_crash_report_id() const;

public:
    void clear_crash_report_id();
    const std::string& crash_report_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_crash_report_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_crash_report_id();
    PROTOBUF_NODISCARD std::string* release_crash_report_id();
    void set_allocated_crash_report_id(std::string* crash_report_id);

private:
    const std::string& _internal_crash_report_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_crash_report_id(const std::string& value);
    std::string* _internal_mutable_crash_report_id();

public:
    // optional string local_id = 6;
    bool has_local_id() const;

private:
    bool _internal_has_local_id() const;

public:
    void clear_local_id();
    const std::string& local_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_local_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_local_id();
    PROTOBUF_NODISCARD std::string* release_local_id();
    void set_allocated_local_id(std::string* local_id);

private:
    const std::string& _internal_local_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_id(const std::string& value);
    std::string* _internal_mutable_local_id();

public:
    // optional string event_based_log_id = 8;
    bool has_event_based_log_id() const;

private:
    bool _internal_has_event_based_log_id() const;

public:
    void clear_event_based_log_id();
    const std::string& event_based_log_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_event_based_log_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_event_based_log_id();
    PROTOBUF_NODISCARD std::string* release_event_based_log_id();
    void set_allocated_event_based_log_id(std::string* event_based_log_id);

private:
    const std::string& _internal_event_based_log_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_based_log_id(const std::string& value);
    std::string* _internal_mutable_event_based_log_id();

public:
    // optional .reporting.SessionAffiliatedUser affiliated_user = 4;
    bool has_affiliated_user() const;

private:
    bool _internal_has_affiliated_user() const;

public:
    void clear_affiliated_user();
    const ::reporting::SessionAffiliatedUser& affiliated_user() const;
    PROTOBUF_NODISCARD ::reporting::SessionAffiliatedUser* release_affiliated_user();
    ::reporting::SessionAffiliatedUser* mutable_affiliated_user();
    void set_allocated_affiliated_user(::reporting::SessionAffiliatedUser* affiliated_user);

private:
    const ::reporting::SessionAffiliatedUser& _internal_affiliated_user() const;
    ::reporting::SessionAffiliatedUser* _internal_mutable_affiliated_user();

public:
    void unsafe_arena_set_allocated_affiliated_user(::reporting::SessionAffiliatedUser* affiliated_user);
    ::reporting::SessionAffiliatedUser* unsafe_arena_release_affiliated_user();

    // optional .reporting.FatalCrashTelemetry.CrashType type = 1;
    bool has_type() const;

private:
    bool _internal_has_type() const;

public:
    void clear_type();
    ::reporting::FatalCrashTelemetry_CrashType type() const;
    void set_type(::reporting::FatalCrashTelemetry_CrashType value);

private:
    ::reporting::FatalCrashTelemetry_CrashType _internal_type() const;
    void _internal_set_type(::reporting::FatalCrashTelemetry_CrashType value);

public:
    // optional .reporting.FatalCrashTelemetry.SessionType session_type = 2;
    bool has_session_type() const;

private:
    bool _internal_has_session_type() const;

public:
    void clear_session_type();
    ::reporting::FatalCrashTelemetry_SessionType session_type() const;
    void set_session_type(::reporting::FatalCrashTelemetry_SessionType value);

private:
    ::reporting::FatalCrashTelemetry_SessionType _internal_session_type() const;
    void _internal_set_session_type(::reporting::FatalCrashTelemetry_SessionType value);

public:
    // optional int64 timestamp_us = 3;
    bool has_timestamp_us() const;

private:
    bool _internal_has_timestamp_us() const;

public:
    void clear_timestamp_us();
    int64_t timestamp_us() const;
    void set_timestamp_us(int64_t value);

private:
    int64_t _internal_timestamp_us() const;
    void _internal_set_timestamp_us(int64_t value);

public:
    // optional bool been_reported_without_crash_report_id = 7;
    bool has_been_reported_without_crash_report_id() const;

private:
    bool _internal_has_been_reported_without_crash_report_id() const;

public:
    void clear_been_reported_without_crash_report_id();
    bool been_reported_without_crash_report_id() const;
    void set_been_reported_without_crash_report_id(bool value);

private:
    bool _internal_been_reported_without_crash_report_id() const;
    void _internal_set_been_reported_without_crash_report_id(bool value);

public:
    // @@protoc_insertion_point(class_scope:reporting.FatalCrashTelemetry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr crash_report_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_based_log_id_;
        ::reporting::SessionAffiliatedUser* affiliated_user_;
        int type_;
        int session_type_;
        int64_t timestamp_us_;
        bool been_reported_without_crash_report_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class RuntimeCountersTelemetry final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.RuntimeCountersTelemetry) */ {
public:
    inline RuntimeCountersTelemetry()
        : RuntimeCountersTelemetry(nullptr)
    {
    }
    ~RuntimeCountersTelemetry() override;
    explicit PROTOBUF_CONSTEXPR RuntimeCountersTelemetry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    RuntimeCountersTelemetry(const RuntimeCountersTelemetry& from);
    RuntimeCountersTelemetry(RuntimeCountersTelemetry&& from) noexcept
        : RuntimeCountersTelemetry()
    {
        *this = ::std::move(from);
    }

    inline RuntimeCountersTelemetry& operator=(const RuntimeCountersTelemetry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline RuntimeCountersTelemetry& operator=(RuntimeCountersTelemetry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const RuntimeCountersTelemetry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const RuntimeCountersTelemetry* internal_default_instance()
    {
        return reinterpret_cast<const RuntimeCountersTelemetry*>(&_RuntimeCountersTelemetry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 45;

    friend void swap(RuntimeCountersTelemetry& a, RuntimeCountersTelemetry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(RuntimeCountersTelemetry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(RuntimeCountersTelemetry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    RuntimeCountersTelemetry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<RuntimeCountersTelemetry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const RuntimeCountersTelemetry& from);
    void MergeFrom(const RuntimeCountersTelemetry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RuntimeCountersTelemetry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.RuntimeCountersTelemetry";
    }

protected:
    explicit RuntimeCountersTelemetry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUptimeRuntimeSecondsFieldNumber = 1,
        kCounterEnterSleepFieldNumber = 2,
        kCounterEnterHibernationFieldNumber = 3,
        kCounterEnterPoweroffFieldNumber = 4,
    };
    // optional int64 uptime_runtime_seconds = 1;
    bool has_uptime_runtime_seconds() const;

private:
    bool _internal_has_uptime_runtime_seconds() const;

public:
    void clear_uptime_runtime_seconds();
    int64_t uptime_runtime_seconds() const;
    void set_uptime_runtime_seconds(int64_t value);

private:
    int64_t _internal_uptime_runtime_seconds() const;
    void _internal_set_uptime_runtime_seconds(int64_t value);

public:
    // optional int64 counter_enter_sleep = 2;
    bool has_counter_enter_sleep() const;

private:
    bool _internal_has_counter_enter_sleep() const;

public:
    void clear_counter_enter_sleep();
    int64_t counter_enter_sleep() const;
    void set_counter_enter_sleep(int64_t value);

private:
    int64_t _internal_counter_enter_sleep() const;
    void _internal_set_counter_enter_sleep(int64_t value);

public:
    // optional int64 counter_enter_hibernation = 3;
    bool has_counter_enter_hibernation() const;

private:
    bool _internal_has_counter_enter_hibernation() const;

public:
    void clear_counter_enter_hibernation();
    int64_t counter_enter_hibernation() const;
    void set_counter_enter_hibernation(int64_t value);

private:
    int64_t _internal_counter_enter_hibernation() const;
    void _internal_set_counter_enter_hibernation(int64_t value);

public:
    // optional int64 counter_enter_poweroff = 4;
    bool has_counter_enter_poweroff() const;

private:
    bool _internal_has_counter_enter_poweroff() const;

public:
    void clear_counter_enter_poweroff();
    int64_t counter_enter_poweroff() const;
    void set_counter_enter_poweroff(int64_t value);

private:
    int64_t _internal_counter_enter_poweroff() const;
    void _internal_set_counter_enter_poweroff(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:reporting.RuntimeCountersTelemetry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int64_t uptime_runtime_seconds_;
        int64_t counter_enter_sleep_;
        int64_t counter_enter_hibernation_;
        int64_t counter_enter_poweroff_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class EventData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.EventData) */ {
public:
    inline EventData()
        : EventData(nullptr)
    {
    }
    ~EventData() override;
    explicit PROTOBUF_CONSTEXPR EventData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    EventData(const EventData& from);
    EventData(EventData&& from) noexcept
        : EventData()
    {
        *this = ::std::move(from);
    }

    inline EventData& operator=(const EventData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline EventData& operator=(EventData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const EventData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const EventData* internal_default_instance()
    {
        return reinterpret_cast<const EventData*>(&_EventData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 46;

    friend void swap(EventData& a, EventData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(EventData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(EventData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    EventData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<EventData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const EventData& from);
    void MergeFrom(const EventData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(EventData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.EventData";
    }

protected:
    explicit EventData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTypeFieldNumber = 1,
    };
    // optional .reporting.MetricEventType type = 1;
    bool has_type() const;

private:
    bool _internal_has_type() const;

public:
    void clear_type();
    ::reporting::MetricEventType type() const;
    void set_type(::reporting::MetricEventType value);

private:
    ::reporting::MetricEventType _internal_type() const;
    void _internal_set_type(::reporting::MetricEventType value);

public:
    // @@protoc_insertion_point(class_scope:reporting.EventData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// -------------------------------------------------------------------

class MetricData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:reporting.MetricData) */ {
public:
    inline MetricData()
        : MetricData(nullptr)
    {
    }
    ~MetricData() override;
    explicit PROTOBUF_CONSTEXPR MetricData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    MetricData(const MetricData& from);
    MetricData(MetricData&& from) noexcept
        : MetricData()
    {
        *this = ::std::move(from);
    }

    inline MetricData& operator=(const MetricData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline MetricData& operator=(MetricData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const MetricData& default_instance()
    {
        return *internal_default_instance();
    }
    enum MetricTypeCase {
        kInfoData = 2,
        kTelemetryData = 3,
        METRIC_TYPE_NOT_SET = 0,
    };

    static inline const MetricData* internal_default_instance()
    {
        return reinterpret_cast<const MetricData*>(&_MetricData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 47;

    friend void swap(MetricData& a, MetricData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(MetricData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(MetricData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    MetricData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<MetricData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const MetricData& from);
    void MergeFrom(const MetricData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(MetricData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "reporting.MetricData";
    }

protected:
    explicit MetricData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kEventDataFieldNumber = 4,
        kTimestampMsFieldNumber = 1,
        kInfoDataFieldNumber = 2,
        kTelemetryDataFieldNumber = 3,
    };
    // optional .reporting.EventData event_data = 4;
    bool has_event_data() const;

private:
    bool _internal_has_event_data() const;

public:
    void clear_event_data();
    const ::reporting::EventData& event_data() const;
    PROTOBUF_NODISCARD ::reporting::EventData* release_event_data();
    ::reporting::EventData* mutable_event_data();
    void set_allocated_event_data(::reporting::EventData* event_data);

private:
    const ::reporting::EventData& _internal_event_data() const;
    ::reporting::EventData* _internal_mutable_event_data();

public:
    void unsafe_arena_set_allocated_event_data(::reporting::EventData* event_data);
    ::reporting::EventData* unsafe_arena_release_event_data();

    // optional int64 timestamp_ms = 1;
    bool has_timestamp_ms() const;

private:
    bool _internal_has_timestamp_ms() const;

public:
    void clear_timestamp_ms();
    int64_t timestamp_ms() const;
    void set_timestamp_ms(int64_t value);

private:
    int64_t _internal_timestamp_ms() const;
    void _internal_set_timestamp_ms(int64_t value);

public:
    // .reporting.InfoData info_data = 2;
    bool has_info_data() const;

private:
    bool _internal_has_info_data() const;

public:
    void clear_info_data();
    const ::reporting::InfoData& info_data() const;
    PROTOBUF_NODISCARD ::reporting::InfoData* release_info_data();
    ::reporting::InfoData* mutable_info_data();
    void set_allocated_info_data(::reporting::InfoData* info_data);

private:
    const ::reporting::InfoData& _internal_info_data() const;
    ::reporting::InfoData* _internal_mutable_info_data();

public:
    void unsafe_arena_set_allocated_info_data(::reporting::InfoData* info_data);
    ::reporting::InfoData* unsafe_arena_release_info_data();

    // .reporting.TelemetryData telemetry_data = 3;
    bool has_telemetry_data() const;

private:
    bool _internal_has_telemetry_data() const;

public:
    void clear_telemetry_data();
    const ::reporting::TelemetryData& telemetry_data() const;
    PROTOBUF_NODISCARD ::reporting::TelemetryData* release_telemetry_data();
    ::reporting::TelemetryData* mutable_telemetry_data();
    void set_allocated_telemetry_data(::reporting::TelemetryData* telemetry_data);

private:
    const ::reporting::TelemetryData& _internal_telemetry_data() const;
    ::reporting::TelemetryData* _internal_mutable_telemetry_data();

public:
    void unsafe_arena_set_allocated_telemetry_data(::reporting::TelemetryData* telemetry_data);
    ::reporting::TelemetryData* unsafe_arena_release_telemetry_data();

    void clear_metric_type();
    MetricTypeCase metric_type_case() const;
    // @@protoc_insertion_point(class_scope:reporting.MetricData)
private:
    class _Internal;
    void set_has_info_data();
    void set_has_telemetry_data();

    inline bool has_metric_type() const;
    inline void clear_has_metric_type();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::reporting::EventData* event_data_;
        int64_t timestamp_ms_;
        union MetricTypeUnion {
            constexpr MetricTypeUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::reporting::InfoData* info_data_;
            ::reporting::TelemetryData* telemetry_data_;
        } metric_type_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// HttpsLatencyRoutineData

// optional .reporting.RoutineVerdict verdict = 1;
inline bool HttpsLatencyRoutineData::_internal_has_verdict() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool HttpsLatencyRoutineData::has_verdict() const
{
    return _internal_has_verdict();
}
inline void HttpsLatencyRoutineData::clear_verdict()
{
    _impl_.verdict_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::reporting::RoutineVerdict HttpsLatencyRoutineData::_internal_verdict() const
{
    return static_cast<::reporting::RoutineVerdict>(_impl_.verdict_);
}
inline ::reporting::RoutineVerdict HttpsLatencyRoutineData::verdict() const
{
    // @@protoc_insertion_point(field_get:reporting.HttpsLatencyRoutineData.verdict)
    return _internal_verdict();
}
inline void HttpsLatencyRoutineData::_internal_set_verdict(::reporting::RoutineVerdict value)
{
    assert(::reporting::RoutineVerdict_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.verdict_ = value;
}
inline void HttpsLatencyRoutineData::set_verdict(::reporting::RoutineVerdict value)
{
    _internal_set_verdict(value);
    // @@protoc_insertion_point(field_set:reporting.HttpsLatencyRoutineData.verdict)
}

// optional .reporting.HttpsLatencyProblem problem = 2;
inline bool HttpsLatencyRoutineData::_internal_has_problem() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool HttpsLatencyRoutineData::has_problem() const
{
    return _internal_has_problem();
}
inline void HttpsLatencyRoutineData::clear_problem()
{
    _impl_.problem_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::reporting::HttpsLatencyProblem HttpsLatencyRoutineData::_internal_problem() const
{
    return static_cast<::reporting::HttpsLatencyProblem>(_impl_.problem_);
}
inline ::reporting::HttpsLatencyProblem HttpsLatencyRoutineData::problem() const
{
    // @@protoc_insertion_point(field_get:reporting.HttpsLatencyRoutineData.problem)
    return _internal_problem();
}
inline void HttpsLatencyRoutineData::_internal_set_problem(::reporting::HttpsLatencyProblem value)
{
    assert(::reporting::HttpsLatencyProblem_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.problem_ = value;
}
inline void HttpsLatencyRoutineData::set_problem(::reporting::HttpsLatencyProblem value)
{
    _internal_set_problem(value);
    // @@protoc_insertion_point(field_set:reporting.HttpsLatencyRoutineData.problem)
}

// optional int64 latency_ms = 3;
inline bool HttpsLatencyRoutineData::_internal_has_latency_ms() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool HttpsLatencyRoutineData::has_latency_ms() const
{
    return _internal_has_latency_ms();
}
inline void HttpsLatencyRoutineData::clear_latency_ms()
{
    _impl_.latency_ms_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t HttpsLatencyRoutineData::_internal_latency_ms() const
{
    return _impl_.latency_ms_;
}
inline int64_t HttpsLatencyRoutineData::latency_ms() const
{
    // @@protoc_insertion_point(field_get:reporting.HttpsLatencyRoutineData.latency_ms)
    return _internal_latency_ms();
}
inline void HttpsLatencyRoutineData::_internal_set_latency_ms(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.latency_ms_ = value;
}
inline void HttpsLatencyRoutineData::set_latency_ms(int64_t value)
{
    _internal_set_latency_ms(value);
    // @@protoc_insertion_point(field_set:reporting.HttpsLatencyRoutineData.latency_ms)
}

// -------------------------------------------------------------------

// BandwidthData

// optional int64 download_speed_kbps = 1;
inline bool BandwidthData::_internal_has_download_speed_kbps() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool BandwidthData::has_download_speed_kbps() const
{
    return _internal_has_download_speed_kbps();
}
inline void BandwidthData::clear_download_speed_kbps()
{
    _impl_.download_speed_kbps_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t BandwidthData::_internal_download_speed_kbps() const
{
    return _impl_.download_speed_kbps_;
}
inline int64_t BandwidthData::download_speed_kbps() const
{
    // @@protoc_insertion_point(field_get:reporting.BandwidthData.download_speed_kbps)
    return _internal_download_speed_kbps();
}
inline void BandwidthData::_internal_set_download_speed_kbps(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.download_speed_kbps_ = value;
}
inline void BandwidthData::set_download_speed_kbps(int64_t value)
{
    _internal_set_download_speed_kbps(value);
    // @@protoc_insertion_point(field_set:reporting.BandwidthData.download_speed_kbps)
}

// optional int64 upload_speed_kbps = 2;
inline bool BandwidthData::_internal_has_upload_speed_kbps() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool BandwidthData::has_upload_speed_kbps() const
{
    return _internal_has_upload_speed_kbps();
}
inline void BandwidthData::clear_upload_speed_kbps()
{
    _impl_.upload_speed_kbps_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t BandwidthData::_internal_upload_speed_kbps() const
{
    return _impl_.upload_speed_kbps_;
}
inline int64_t BandwidthData::upload_speed_kbps() const
{
    // @@protoc_insertion_point(field_get:reporting.BandwidthData.upload_speed_kbps)
    return _internal_upload_speed_kbps();
}
inline void BandwidthData::_internal_set_upload_speed_kbps(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.upload_speed_kbps_ = value;
}
inline void BandwidthData::set_upload_speed_kbps(int64_t value)
{
    _internal_set_upload_speed_kbps(value);
    // @@protoc_insertion_point(field_set:reporting.BandwidthData.upload_speed_kbps)
}

// -------------------------------------------------------------------

// NetworkTelemetry

// optional string guid = 1;
inline bool NetworkTelemetry::_internal_has_guid() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool NetworkTelemetry::has_guid() const
{
    return _internal_has_guid();
}
inline void NetworkTelemetry::clear_guid()
{
    _impl_.guid_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkTelemetry::guid() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkTelemetry.guid)
    return _internal_guid();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NetworkTelemetry::set_guid(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.guid_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.NetworkTelemetry.guid)
}
inline std::string* NetworkTelemetry::mutable_guid()
{
    std::string* _s = _internal_mutable_guid();
    // @@protoc_insertion_point(field_mutable:reporting.NetworkTelemetry.guid)
    return _s;
}
inline const std::string& NetworkTelemetry::_internal_guid() const
{
    return _impl_.guid_.Get();
}
inline void NetworkTelemetry::_internal_set_guid(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.guid_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkTelemetry::_internal_mutable_guid()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.guid_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkTelemetry::release_guid()
{
    // @@protoc_insertion_point(field_release:reporting.NetworkTelemetry.guid)
    if (!_internal_has_guid()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.guid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.guid_.IsDefault()) {
        _impl_.guid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NetworkTelemetry::set_allocated_guid(std::string* guid)
{
    if (guid != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.guid_.SetAllocated(guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.guid_.IsDefault()) {
        _impl_.guid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworkTelemetry.guid)
}

// optional .reporting.NetworkConnectionState connection_state = 2;
inline bool NetworkTelemetry::_internal_has_connection_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool NetworkTelemetry::has_connection_state() const
{
    return _internal_has_connection_state();
}
inline void NetworkTelemetry::clear_connection_state()
{
    _impl_.connection_state_ = 0;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::reporting::NetworkConnectionState NetworkTelemetry::_internal_connection_state() const
{
    return static_cast<::reporting::NetworkConnectionState>(_impl_.connection_state_);
}
inline ::reporting::NetworkConnectionState NetworkTelemetry::connection_state() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkTelemetry.connection_state)
    return _internal_connection_state();
}
inline void NetworkTelemetry::_internal_set_connection_state(::reporting::NetworkConnectionState value)
{
    assert(::reporting::NetworkConnectionState_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.connection_state_ = value;
}
inline void NetworkTelemetry::set_connection_state(::reporting::NetworkConnectionState value)
{
    _internal_set_connection_state(value);
    // @@protoc_insertion_point(field_set:reporting.NetworkTelemetry.connection_state)
}

// optional int32 signal_strength = 3;
inline bool NetworkTelemetry::_internal_has_signal_strength() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool NetworkTelemetry::has_signal_strength() const
{
    return _internal_has_signal_strength();
}
inline void NetworkTelemetry::clear_signal_strength()
{
    _impl_.signal_strength_ = 0;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t NetworkTelemetry::_internal_signal_strength() const
{
    return _impl_.signal_strength_;
}
inline int32_t NetworkTelemetry::signal_strength() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkTelemetry.signal_strength)
    return _internal_signal_strength();
}
inline void NetworkTelemetry::_internal_set_signal_strength(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.signal_strength_ = value;
}
inline void NetworkTelemetry::set_signal_strength(int32_t value)
{
    _internal_set_signal_strength(value);
    // @@protoc_insertion_point(field_set:reporting.NetworkTelemetry.signal_strength)
}

// optional string device_path = 4;
inline bool NetworkTelemetry::_internal_has_device_path() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool NetworkTelemetry::has_device_path() const
{
    return _internal_has_device_path();
}
inline void NetworkTelemetry::clear_device_path()
{
    _impl_.device_path_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NetworkTelemetry::device_path() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkTelemetry.device_path)
    return _internal_device_path();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NetworkTelemetry::set_device_path(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.device_path_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.NetworkTelemetry.device_path)
}
inline std::string* NetworkTelemetry::mutable_device_path()
{
    std::string* _s = _internal_mutable_device_path();
    // @@protoc_insertion_point(field_mutable:reporting.NetworkTelemetry.device_path)
    return _s;
}
inline const std::string& NetworkTelemetry::_internal_device_path() const
{
    return _impl_.device_path_.Get();
}
inline void NetworkTelemetry::_internal_set_device_path(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.device_path_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkTelemetry::_internal_mutable_device_path()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.device_path_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkTelemetry::release_device_path()
{
    // @@protoc_insertion_point(field_release:reporting.NetworkTelemetry.device_path)
    if (!_internal_has_device_path()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.device_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.device_path_.IsDefault()) {
        _impl_.device_path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NetworkTelemetry::set_allocated_device_path(std::string* device_path)
{
    if (device_path != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.device_path_.SetAllocated(device_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.device_path_.IsDefault()) {
        _impl_.device_path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworkTelemetry.device_path)
}

// optional string ip_address = 5;
inline bool NetworkTelemetry::_internal_has_ip_address() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool NetworkTelemetry::has_ip_address() const
{
    return _internal_has_ip_address();
}
inline void NetworkTelemetry::clear_ip_address()
{
    _impl_.ip_address_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NetworkTelemetry::ip_address() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkTelemetry.ip_address)
    return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NetworkTelemetry::set_ip_address(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.ip_address_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.NetworkTelemetry.ip_address)
}
inline std::string* NetworkTelemetry::mutable_ip_address()
{
    std::string* _s = _internal_mutable_ip_address();
    // @@protoc_insertion_point(field_mutable:reporting.NetworkTelemetry.ip_address)
    return _s;
}
inline const std::string& NetworkTelemetry::_internal_ip_address() const
{
    return _impl_.ip_address_.Get();
}
inline void NetworkTelemetry::_internal_set_ip_address(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.ip_address_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkTelemetry::_internal_mutable_ip_address()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.ip_address_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkTelemetry::release_ip_address()
{
    // @@protoc_insertion_point(field_release:reporting.NetworkTelemetry.ip_address)
    if (!_internal_has_ip_address()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.ip_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.ip_address_.IsDefault()) {
        _impl_.ip_address_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NetworkTelemetry::set_allocated_ip_address(std::string* ip_address)
{
    if (ip_address != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.ip_address_.SetAllocated(ip_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.ip_address_.IsDefault()) {
        _impl_.ip_address_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworkTelemetry.ip_address)
}

// optional string gateway = 6;
inline bool NetworkTelemetry::_internal_has_gateway() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool NetworkTelemetry::has_gateway() const
{
    return _internal_has_gateway();
}
inline void NetworkTelemetry::clear_gateway()
{
    _impl_.gateway_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& NetworkTelemetry::gateway() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkTelemetry.gateway)
    return _internal_gateway();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NetworkTelemetry::set_gateway(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.gateway_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.NetworkTelemetry.gateway)
}
inline std::string* NetworkTelemetry::mutable_gateway()
{
    std::string* _s = _internal_mutable_gateway();
    // @@protoc_insertion_point(field_mutable:reporting.NetworkTelemetry.gateway)
    return _s;
}
inline const std::string& NetworkTelemetry::_internal_gateway() const
{
    return _impl_.gateway_.Get();
}
inline void NetworkTelemetry::_internal_set_gateway(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.gateway_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkTelemetry::_internal_mutable_gateway()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.gateway_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkTelemetry::release_gateway()
{
    // @@protoc_insertion_point(field_release:reporting.NetworkTelemetry.gateway)
    if (!_internal_has_gateway()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.gateway_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.gateway_.IsDefault()) {
        _impl_.gateway_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NetworkTelemetry::set_allocated_gateway(std::string* gateway)
{
    if (gateway != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.gateway_.SetAllocated(gateway, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.gateway_.IsDefault()) {
        _impl_.gateway_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworkTelemetry.gateway)
}

// optional .reporting.NetworkType type = 7;
inline bool NetworkTelemetry::_internal_has_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool NetworkTelemetry::has_type() const
{
    return _internal_has_type();
}
inline void NetworkTelemetry::clear_type()
{
    _impl_.type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::reporting::NetworkType NetworkTelemetry::_internal_type() const
{
    return static_cast<::reporting::NetworkType>(_impl_.type_);
}
inline ::reporting::NetworkType NetworkTelemetry::type() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkTelemetry.type)
    return _internal_type();
}
inline void NetworkTelemetry::_internal_set_type(::reporting::NetworkType value)
{
    assert(::reporting::NetworkType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.type_ = value;
}
inline void NetworkTelemetry::set_type(::reporting::NetworkType value)
{
    _internal_set_type(value);
    // @@protoc_insertion_point(field_set:reporting.NetworkTelemetry.type)
}

// optional int64 tx_bit_rate_mbps = 9;
inline bool NetworkTelemetry::_internal_has_tx_bit_rate_mbps() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool NetworkTelemetry::has_tx_bit_rate_mbps() const
{
    return _internal_has_tx_bit_rate_mbps();
}
inline void NetworkTelemetry::clear_tx_bit_rate_mbps()
{
    _impl_.tx_bit_rate_mbps_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t NetworkTelemetry::_internal_tx_bit_rate_mbps() const
{
    return _impl_.tx_bit_rate_mbps_;
}
inline int64_t NetworkTelemetry::tx_bit_rate_mbps() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkTelemetry.tx_bit_rate_mbps)
    return _internal_tx_bit_rate_mbps();
}
inline void NetworkTelemetry::_internal_set_tx_bit_rate_mbps(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.tx_bit_rate_mbps_ = value;
}
inline void NetworkTelemetry::set_tx_bit_rate_mbps(int64_t value)
{
    _internal_set_tx_bit_rate_mbps(value);
    // @@protoc_insertion_point(field_set:reporting.NetworkTelemetry.tx_bit_rate_mbps)
}

// optional int64 rx_bit_rate_mbps = 10;
inline bool NetworkTelemetry::_internal_has_rx_bit_rate_mbps() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool NetworkTelemetry::has_rx_bit_rate_mbps() const
{
    return _internal_has_rx_bit_rate_mbps();
}
inline void NetworkTelemetry::clear_rx_bit_rate_mbps()
{
    _impl_.rx_bit_rate_mbps_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t NetworkTelemetry::_internal_rx_bit_rate_mbps() const
{
    return _impl_.rx_bit_rate_mbps_;
}
inline int64_t NetworkTelemetry::rx_bit_rate_mbps() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkTelemetry.rx_bit_rate_mbps)
    return _internal_rx_bit_rate_mbps();
}
inline void NetworkTelemetry::_internal_set_rx_bit_rate_mbps(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.rx_bit_rate_mbps_ = value;
}
inline void NetworkTelemetry::set_rx_bit_rate_mbps(int64_t value)
{
    _internal_set_rx_bit_rate_mbps(value);
    // @@protoc_insertion_point(field_set:reporting.NetworkTelemetry.rx_bit_rate_mbps)
}

// optional int32 tx_power_dbm = 11;
inline bool NetworkTelemetry::_internal_has_tx_power_dbm() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool NetworkTelemetry::has_tx_power_dbm() const
{
    return _internal_has_tx_power_dbm();
}
inline void NetworkTelemetry::clear_tx_power_dbm()
{
    _impl_.tx_power_dbm_ = 0;
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t NetworkTelemetry::_internal_tx_power_dbm() const
{
    return _impl_.tx_power_dbm_;
}
inline int32_t NetworkTelemetry::tx_power_dbm() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkTelemetry.tx_power_dbm)
    return _internal_tx_power_dbm();
}
inline void NetworkTelemetry::_internal_set_tx_power_dbm(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.tx_power_dbm_ = value;
}
inline void NetworkTelemetry::set_tx_power_dbm(int32_t value)
{
    _internal_set_tx_power_dbm(value);
    // @@protoc_insertion_point(field_set:reporting.NetworkTelemetry.tx_power_dbm)
}

// optional bool encryption_on = 12;
inline bool NetworkTelemetry::_internal_has_encryption_on() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    return value;
}
inline bool NetworkTelemetry::has_encryption_on() const
{
    return _internal_has_encryption_on();
}
inline void NetworkTelemetry::clear_encryption_on()
{
    _impl_.encryption_on_ = false;
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool NetworkTelemetry::_internal_encryption_on() const
{
    return _impl_.encryption_on_;
}
inline bool NetworkTelemetry::encryption_on() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkTelemetry.encryption_on)
    return _internal_encryption_on();
}
inline void NetworkTelemetry::_internal_set_encryption_on(bool value)
{
    _impl_._has_bits_[0] |= 0x00000800u;
    _impl_.encryption_on_ = value;
}
inline void NetworkTelemetry::set_encryption_on(bool value)
{
    _internal_set_encryption_on(value);
    // @@protoc_insertion_point(field_set:reporting.NetworkTelemetry.encryption_on)
}

// optional int64 link_quality = 13;
inline bool NetworkTelemetry::_internal_has_link_quality() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    return value;
}
inline bool NetworkTelemetry::has_link_quality() const
{
    return _internal_has_link_quality();
}
inline void NetworkTelemetry::clear_link_quality()
{
    _impl_.link_quality_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t NetworkTelemetry::_internal_link_quality() const
{
    return _impl_.link_quality_;
}
inline int64_t NetworkTelemetry::link_quality() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkTelemetry.link_quality)
    return _internal_link_quality();
}
inline void NetworkTelemetry::_internal_set_link_quality(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000400u;
    _impl_.link_quality_ = value;
}
inline void NetworkTelemetry::set_link_quality(int64_t value)
{
    _internal_set_link_quality(value);
    // @@protoc_insertion_point(field_set:reporting.NetworkTelemetry.link_quality)
}

// optional bool power_management_enabled = 14;
inline bool NetworkTelemetry::_internal_has_power_management_enabled() const
{
    bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
    return value;
}
inline bool NetworkTelemetry::has_power_management_enabled() const
{
    return _internal_has_power_management_enabled();
}
inline void NetworkTelemetry::clear_power_management_enabled()
{
    _impl_.power_management_enabled_ = false;
    _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool NetworkTelemetry::_internal_power_management_enabled() const
{
    return _impl_.power_management_enabled_;
}
inline bool NetworkTelemetry::power_management_enabled() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkTelemetry.power_management_enabled)
    return _internal_power_management_enabled();
}
inline void NetworkTelemetry::_internal_set_power_management_enabled(bool value)
{
    _impl_._has_bits_[0] |= 0x00001000u;
    _impl_.power_management_enabled_ = value;
}
inline void NetworkTelemetry::set_power_management_enabled(bool value)
{
    _internal_set_power_management_enabled(value);
    // @@protoc_insertion_point(field_set:reporting.NetworkTelemetry.power_management_enabled)
}

// optional int32 signal_strength_dbm = 15;
inline bool NetworkTelemetry::_internal_has_signal_strength_dbm() const
{
    bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
    return value;
}
inline bool NetworkTelemetry::has_signal_strength_dbm() const
{
    return _internal_has_signal_strength_dbm();
}
inline void NetworkTelemetry::clear_signal_strength_dbm()
{
    _impl_.signal_strength_dbm_ = 0;
    _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int32_t NetworkTelemetry::_internal_signal_strength_dbm() const
{
    return _impl_.signal_strength_dbm_;
}
inline int32_t NetworkTelemetry::signal_strength_dbm() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkTelemetry.signal_strength_dbm)
    return _internal_signal_strength_dbm();
}
inline void NetworkTelemetry::_internal_set_signal_strength_dbm(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00002000u;
    _impl_.signal_strength_dbm_ = value;
}
inline void NetworkTelemetry::set_signal_strength_dbm(int32_t value)
{
    _internal_set_signal_strength_dbm(value);
    // @@protoc_insertion_point(field_set:reporting.NetworkTelemetry.signal_strength_dbm)
}

// -------------------------------------------------------------------

// NetworkConnectionStateChangeEventData

// optional string guid = 1;
inline bool NetworkConnectionStateChangeEventData::_internal_has_guid() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool NetworkConnectionStateChangeEventData::has_guid() const
{
    return _internal_has_guid();
}
inline void NetworkConnectionStateChangeEventData::clear_guid()
{
    _impl_.guid_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkConnectionStateChangeEventData::guid() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkConnectionStateChangeEventData.guid)
    return _internal_guid();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NetworkConnectionStateChangeEventData::set_guid(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.guid_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.NetworkConnectionStateChangeEventData.guid)
}
inline std::string* NetworkConnectionStateChangeEventData::mutable_guid()
{
    std::string* _s = _internal_mutable_guid();
    // @@protoc_insertion_point(field_mutable:reporting.NetworkConnectionStateChangeEventData.guid)
    return _s;
}
inline const std::string& NetworkConnectionStateChangeEventData::_internal_guid() const
{
    return _impl_.guid_.Get();
}
inline void NetworkConnectionStateChangeEventData::_internal_set_guid(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.guid_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkConnectionStateChangeEventData::_internal_mutable_guid()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.guid_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkConnectionStateChangeEventData::release_guid()
{
    // @@protoc_insertion_point(field_release:reporting.NetworkConnectionStateChangeEventData.guid)
    if (!_internal_has_guid()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.guid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.guid_.IsDefault()) {
        _impl_.guid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NetworkConnectionStateChangeEventData::set_allocated_guid(std::string* guid)
{
    if (guid != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.guid_.SetAllocated(guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.guid_.IsDefault()) {
        _impl_.guid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworkConnectionStateChangeEventData.guid)
}

// optional .reporting.NetworkConnectionState connection_state = 2;
inline bool NetworkConnectionStateChangeEventData::_internal_has_connection_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool NetworkConnectionStateChangeEventData::has_connection_state() const
{
    return _internal_has_connection_state();
}
inline void NetworkConnectionStateChangeEventData::clear_connection_state()
{
    _impl_.connection_state_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::reporting::NetworkConnectionState NetworkConnectionStateChangeEventData::_internal_connection_state() const
{
    return static_cast<::reporting::NetworkConnectionState>(_impl_.connection_state_);
}
inline ::reporting::NetworkConnectionState NetworkConnectionStateChangeEventData::connection_state() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkConnectionStateChangeEventData.connection_state)
    return _internal_connection_state();
}
inline void NetworkConnectionStateChangeEventData::_internal_set_connection_state(::reporting::NetworkConnectionState value)
{
    assert(::reporting::NetworkConnectionState_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.connection_state_ = value;
}
inline void NetworkConnectionStateChangeEventData::set_connection_state(::reporting::NetworkConnectionState value)
{
    _internal_set_connection_state(value);
    // @@protoc_insertion_point(field_set:reporting.NetworkConnectionStateChangeEventData.connection_state)
}

// -------------------------------------------------------------------

// SignalStrengthEventData

// optional string guid = 1;
inline bool SignalStrengthEventData::_internal_has_guid() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SignalStrengthEventData::has_guid() const
{
    return _internal_has_guid();
}
inline void SignalStrengthEventData::clear_guid()
{
    _impl_.guid_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SignalStrengthEventData::guid() const
{
    // @@protoc_insertion_point(field_get:reporting.SignalStrengthEventData.guid)
    return _internal_guid();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SignalStrengthEventData::set_guid(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.guid_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.SignalStrengthEventData.guid)
}
inline std::string* SignalStrengthEventData::mutable_guid()
{
    std::string* _s = _internal_mutable_guid();
    // @@protoc_insertion_point(field_mutable:reporting.SignalStrengthEventData.guid)
    return _s;
}
inline const std::string& SignalStrengthEventData::_internal_guid() const
{
    return _impl_.guid_.Get();
}
inline void SignalStrengthEventData::_internal_set_guid(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.guid_.Set(value, GetArenaForAllocation());
}
inline std::string* SignalStrengthEventData::_internal_mutable_guid()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.guid_.Mutable(GetArenaForAllocation());
}
inline std::string* SignalStrengthEventData::release_guid()
{
    // @@protoc_insertion_point(field_release:reporting.SignalStrengthEventData.guid)
    if (!_internal_has_guid()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.guid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.guid_.IsDefault()) {
        _impl_.guid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SignalStrengthEventData::set_allocated_guid(std::string* guid)
{
    if (guid != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.guid_.SetAllocated(guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.guid_.IsDefault()) {
        _impl_.guid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.SignalStrengthEventData.guid)
}

// optional int32 signal_strength_dbm = 2;
inline bool SignalStrengthEventData::_internal_has_signal_strength_dbm() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool SignalStrengthEventData::has_signal_strength_dbm() const
{
    return _internal_has_signal_strength_dbm();
}
inline void SignalStrengthEventData::clear_signal_strength_dbm()
{
    _impl_.signal_strength_dbm_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SignalStrengthEventData::_internal_signal_strength_dbm() const
{
    return _impl_.signal_strength_dbm_;
}
inline int32_t SignalStrengthEventData::signal_strength_dbm() const
{
    // @@protoc_insertion_point(field_get:reporting.SignalStrengthEventData.signal_strength_dbm)
    return _internal_signal_strength_dbm();
}
inline void SignalStrengthEventData::_internal_set_signal_strength_dbm(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.signal_strength_dbm_ = value;
}
inline void SignalStrengthEventData::set_signal_strength_dbm(int32_t value)
{
    _internal_set_signal_strength_dbm(value);
    // @@protoc_insertion_point(field_set:reporting.SignalStrengthEventData.signal_strength_dbm)
}

// -------------------------------------------------------------------

// NetworksTelemetry

// repeated .reporting.NetworkTelemetry network_telemetry = 1;
inline int NetworksTelemetry::_internal_network_telemetry_size() const
{
    return _impl_.network_telemetry_.size();
}
inline int NetworksTelemetry::network_telemetry_size() const
{
    return _internal_network_telemetry_size();
}
inline void NetworksTelemetry::clear_network_telemetry()
{
    _impl_.network_telemetry_.Clear();
}
inline ::reporting::NetworkTelemetry* NetworksTelemetry::mutable_network_telemetry(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.NetworksTelemetry.network_telemetry)
    return _impl_.network_telemetry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::NetworkTelemetry>* NetworksTelemetry::mutable_network_telemetry()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.NetworksTelemetry.network_telemetry)
    return &_impl_.network_telemetry_;
}
inline const ::reporting::NetworkTelemetry& NetworksTelemetry::_internal_network_telemetry(int index) const
{
    return _impl_.network_telemetry_.Get(index);
}
inline const ::reporting::NetworkTelemetry& NetworksTelemetry::network_telemetry(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.NetworksTelemetry.network_telemetry)
    return _internal_network_telemetry(index);
}
inline ::reporting::NetworkTelemetry* NetworksTelemetry::_internal_add_network_telemetry()
{
    return _impl_.network_telemetry_.Add();
}
inline ::reporting::NetworkTelemetry* NetworksTelemetry::add_network_telemetry()
{
    ::reporting::NetworkTelemetry* _add = _internal_add_network_telemetry();
    // @@protoc_insertion_point(field_add:reporting.NetworksTelemetry.network_telemetry)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::NetworkTelemetry>& NetworksTelemetry::network_telemetry() const
{
    // @@protoc_insertion_point(field_list:reporting.NetworksTelemetry.network_telemetry)
    return _impl_.network_telemetry_;
}

// optional .reporting.HttpsLatencyRoutineData https_latency_data = 2;
inline bool NetworksTelemetry::_internal_has_https_latency_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.https_latency_data_ != nullptr);
    return value;
}
inline bool NetworksTelemetry::has_https_latency_data() const
{
    return _internal_has_https_latency_data();
}
inline void NetworksTelemetry::clear_https_latency_data()
{
    if (_impl_.https_latency_data_ != nullptr)
        _impl_.https_latency_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::reporting::HttpsLatencyRoutineData& NetworksTelemetry::_internal_https_latency_data() const
{
    const ::reporting::HttpsLatencyRoutineData* p = _impl_.https_latency_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::HttpsLatencyRoutineData&>(::reporting::_HttpsLatencyRoutineData_default_instance_);
}
inline const ::reporting::HttpsLatencyRoutineData& NetworksTelemetry::https_latency_data() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworksTelemetry.https_latency_data)
    return _internal_https_latency_data();
}
inline void NetworksTelemetry::unsafe_arena_set_allocated_https_latency_data(::reporting::HttpsLatencyRoutineData* https_latency_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.https_latency_data_);
    }
    _impl_.https_latency_data_ = https_latency_data;
    if (https_latency_data) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.NetworksTelemetry.https_latency_data)
}
inline ::reporting::HttpsLatencyRoutineData* NetworksTelemetry::release_https_latency_data()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::HttpsLatencyRoutineData* temp = _impl_.https_latency_data_;
    _impl_.https_latency_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::HttpsLatencyRoutineData* NetworksTelemetry::unsafe_arena_release_https_latency_data()
{
    // @@protoc_insertion_point(field_release:reporting.NetworksTelemetry.https_latency_data)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::HttpsLatencyRoutineData* temp = _impl_.https_latency_data_;
    _impl_.https_latency_data_ = nullptr;
    return temp;
}
inline ::reporting::HttpsLatencyRoutineData* NetworksTelemetry::_internal_mutable_https_latency_data()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.https_latency_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::HttpsLatencyRoutineData>(GetArenaForAllocation());
        _impl_.https_latency_data_ = p;
    }
    return _impl_.https_latency_data_;
}
inline ::reporting::HttpsLatencyRoutineData* NetworksTelemetry::mutable_https_latency_data()
{
    ::reporting::HttpsLatencyRoutineData* _msg = _internal_mutable_https_latency_data();
    // @@protoc_insertion_point(field_mutable:reporting.NetworksTelemetry.https_latency_data)
    return _msg;
}
inline void NetworksTelemetry::set_allocated_https_latency_data(::reporting::HttpsLatencyRoutineData* https_latency_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.https_latency_data_;
    }
    if (https_latency_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(https_latency_data);
        if (message_arena != submessage_arena) {
            https_latency_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, https_latency_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.https_latency_data_ = https_latency_data;
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworksTelemetry.https_latency_data)
}

// optional .reporting.BandwidthData bandwidth_data = 3;
inline bool NetworksTelemetry::_internal_has_bandwidth_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.bandwidth_data_ != nullptr);
    return value;
}
inline bool NetworksTelemetry::has_bandwidth_data() const
{
    return _internal_has_bandwidth_data();
}
inline void NetworksTelemetry::clear_bandwidth_data()
{
    if (_impl_.bandwidth_data_ != nullptr)
        _impl_.bandwidth_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::reporting::BandwidthData& NetworksTelemetry::_internal_bandwidth_data() const
{
    const ::reporting::BandwidthData* p = _impl_.bandwidth_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::BandwidthData&>(::reporting::_BandwidthData_default_instance_);
}
inline const ::reporting::BandwidthData& NetworksTelemetry::bandwidth_data() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworksTelemetry.bandwidth_data)
    return _internal_bandwidth_data();
}
inline void NetworksTelemetry::unsafe_arena_set_allocated_bandwidth_data(::reporting::BandwidthData* bandwidth_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bandwidth_data_);
    }
    _impl_.bandwidth_data_ = bandwidth_data;
    if (bandwidth_data) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.NetworksTelemetry.bandwidth_data)
}
inline ::reporting::BandwidthData* NetworksTelemetry::release_bandwidth_data()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::reporting::BandwidthData* temp = _impl_.bandwidth_data_;
    _impl_.bandwidth_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::BandwidthData* NetworksTelemetry::unsafe_arena_release_bandwidth_data()
{
    // @@protoc_insertion_point(field_release:reporting.NetworksTelemetry.bandwidth_data)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::reporting::BandwidthData* temp = _impl_.bandwidth_data_;
    _impl_.bandwidth_data_ = nullptr;
    return temp;
}
inline ::reporting::BandwidthData* NetworksTelemetry::_internal_mutable_bandwidth_data()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.bandwidth_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::BandwidthData>(GetArenaForAllocation());
        _impl_.bandwidth_data_ = p;
    }
    return _impl_.bandwidth_data_;
}
inline ::reporting::BandwidthData* NetworksTelemetry::mutable_bandwidth_data()
{
    ::reporting::BandwidthData* _msg = _internal_mutable_bandwidth_data();
    // @@protoc_insertion_point(field_mutable:reporting.NetworksTelemetry.bandwidth_data)
    return _msg;
}
inline void NetworksTelemetry::set_allocated_bandwidth_data(::reporting::BandwidthData* bandwidth_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.bandwidth_data_;
    }
    if (bandwidth_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bandwidth_data);
        if (message_arena != submessage_arena) {
            bandwidth_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, bandwidth_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.bandwidth_data_ = bandwidth_data;
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworksTelemetry.bandwidth_data)
}

// optional .reporting.NetworkConnectionStateChangeEventData network_connection_change_event_data = 4;
inline bool NetworksTelemetry::_internal_has_network_connection_change_event_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.network_connection_change_event_data_ != nullptr);
    return value;
}
inline bool NetworksTelemetry::has_network_connection_change_event_data() const
{
    return _internal_has_network_connection_change_event_data();
}
inline void NetworksTelemetry::clear_network_connection_change_event_data()
{
    if (_impl_.network_connection_change_event_data_ != nullptr)
        _impl_.network_connection_change_event_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::reporting::NetworkConnectionStateChangeEventData& NetworksTelemetry::_internal_network_connection_change_event_data() const
{
    const ::reporting::NetworkConnectionStateChangeEventData* p = _impl_.network_connection_change_event_data_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::reporting::NetworkConnectionStateChangeEventData&>(::reporting::_NetworkConnectionStateChangeEventData_default_instance_);
}
inline const ::reporting::NetworkConnectionStateChangeEventData& NetworksTelemetry::network_connection_change_event_data() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworksTelemetry.network_connection_change_event_data)
    return _internal_network_connection_change_event_data();
}
inline void NetworksTelemetry::unsafe_arena_set_allocated_network_connection_change_event_data(
    ::reporting::NetworkConnectionStateChangeEventData* network_connection_change_event_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.network_connection_change_event_data_);
    }
    _impl_.network_connection_change_event_data_ = network_connection_change_event_data;
    if (network_connection_change_event_data) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.NetworksTelemetry.network_connection_change_event_data)
}
inline ::reporting::NetworkConnectionStateChangeEventData* NetworksTelemetry::release_network_connection_change_event_data()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::reporting::NetworkConnectionStateChangeEventData* temp = _impl_.network_connection_change_event_data_;
    _impl_.network_connection_change_event_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::NetworkConnectionStateChangeEventData* NetworksTelemetry::unsafe_arena_release_network_connection_change_event_data()
{
    // @@protoc_insertion_point(field_release:reporting.NetworksTelemetry.network_connection_change_event_data)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::reporting::NetworkConnectionStateChangeEventData* temp = _impl_.network_connection_change_event_data_;
    _impl_.network_connection_change_event_data_ = nullptr;
    return temp;
}
inline ::reporting::NetworkConnectionStateChangeEventData* NetworksTelemetry::_internal_mutable_network_connection_change_event_data()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.network_connection_change_event_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::NetworkConnectionStateChangeEventData>(GetArenaForAllocation());
        _impl_.network_connection_change_event_data_ = p;
    }
    return _impl_.network_connection_change_event_data_;
}
inline ::reporting::NetworkConnectionStateChangeEventData* NetworksTelemetry::mutable_network_connection_change_event_data()
{
    ::reporting::NetworkConnectionStateChangeEventData* _msg = _internal_mutable_network_connection_change_event_data();
    // @@protoc_insertion_point(field_mutable:reporting.NetworksTelemetry.network_connection_change_event_data)
    return _msg;
}
inline void NetworksTelemetry::set_allocated_network_connection_change_event_data(
    ::reporting::NetworkConnectionStateChangeEventData* network_connection_change_event_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.network_connection_change_event_data_;
    }
    if (network_connection_change_event_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(network_connection_change_event_data);
        if (message_arena != submessage_arena) {
            network_connection_change_event_data
                = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, network_connection_change_event_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.network_connection_change_event_data_ = network_connection_change_event_data;
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworksTelemetry.network_connection_change_event_data)
}

// optional .reporting.SignalStrengthEventData signal_strength_event_data = 5;
inline bool NetworksTelemetry::_internal_has_signal_strength_event_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.signal_strength_event_data_ != nullptr);
    return value;
}
inline bool NetworksTelemetry::has_signal_strength_event_data() const
{
    return _internal_has_signal_strength_event_data();
}
inline void NetworksTelemetry::clear_signal_strength_event_data()
{
    if (_impl_.signal_strength_event_data_ != nullptr)
        _impl_.signal_strength_event_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::reporting::SignalStrengthEventData& NetworksTelemetry::_internal_signal_strength_event_data() const
{
    const ::reporting::SignalStrengthEventData* p = _impl_.signal_strength_event_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::SignalStrengthEventData&>(::reporting::_SignalStrengthEventData_default_instance_);
}
inline const ::reporting::SignalStrengthEventData& NetworksTelemetry::signal_strength_event_data() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworksTelemetry.signal_strength_event_data)
    return _internal_signal_strength_event_data();
}
inline void NetworksTelemetry::unsafe_arena_set_allocated_signal_strength_event_data(::reporting::SignalStrengthEventData* signal_strength_event_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.signal_strength_event_data_);
    }
    _impl_.signal_strength_event_data_ = signal_strength_event_data;
    if (signal_strength_event_data) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.NetworksTelemetry.signal_strength_event_data)
}
inline ::reporting::SignalStrengthEventData* NetworksTelemetry::release_signal_strength_event_data()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::reporting::SignalStrengthEventData* temp = _impl_.signal_strength_event_data_;
    _impl_.signal_strength_event_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::SignalStrengthEventData* NetworksTelemetry::unsafe_arena_release_signal_strength_event_data()
{
    // @@protoc_insertion_point(field_release:reporting.NetworksTelemetry.signal_strength_event_data)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::reporting::SignalStrengthEventData* temp = _impl_.signal_strength_event_data_;
    _impl_.signal_strength_event_data_ = nullptr;
    return temp;
}
inline ::reporting::SignalStrengthEventData* NetworksTelemetry::_internal_mutable_signal_strength_event_data()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.signal_strength_event_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::SignalStrengthEventData>(GetArenaForAllocation());
        _impl_.signal_strength_event_data_ = p;
    }
    return _impl_.signal_strength_event_data_;
}
inline ::reporting::SignalStrengthEventData* NetworksTelemetry::mutable_signal_strength_event_data()
{
    ::reporting::SignalStrengthEventData* _msg = _internal_mutable_signal_strength_event_data();
    // @@protoc_insertion_point(field_mutable:reporting.NetworksTelemetry.signal_strength_event_data)
    return _msg;
}
inline void NetworksTelemetry::set_allocated_signal_strength_event_data(::reporting::SignalStrengthEventData* signal_strength_event_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.signal_strength_event_data_;
    }
    if (signal_strength_event_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(signal_strength_event_data);
        if (message_arena != submessage_arena) {
            signal_strength_event_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, signal_strength_event_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.signal_strength_event_data_ = signal_strength_event_data;
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworksTelemetry.signal_strength_event_data)
}

// -------------------------------------------------------------------

// ThunderboltInfo

// optional .reporting.ThunderboltSecurityLevel security_level = 1;
inline bool ThunderboltInfo::_internal_has_security_level() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ThunderboltInfo::has_security_level() const
{
    return _internal_has_security_level();
}
inline void ThunderboltInfo::clear_security_level()
{
    _impl_.security_level_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::reporting::ThunderboltSecurityLevel ThunderboltInfo::_internal_security_level() const
{
    return static_cast<::reporting::ThunderboltSecurityLevel>(_impl_.security_level_);
}
inline ::reporting::ThunderboltSecurityLevel ThunderboltInfo::security_level() const
{
    // @@protoc_insertion_point(field_get:reporting.ThunderboltInfo.security_level)
    return _internal_security_level();
}
inline void ThunderboltInfo::_internal_set_security_level(::reporting::ThunderboltSecurityLevel value)
{
    assert(::reporting::ThunderboltSecurityLevel_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.security_level_ = value;
}
inline void ThunderboltInfo::set_security_level(::reporting::ThunderboltSecurityLevel value)
{
    _internal_set_security_level(value);
    // @@protoc_insertion_point(field_set:reporting.ThunderboltInfo.security_level)
}

// -------------------------------------------------------------------

// BusDeviceInfo

// repeated .reporting.ThunderboltInfo thunderbolt_info = 1;
inline int BusDeviceInfo::_internal_thunderbolt_info_size() const
{
    return _impl_.thunderbolt_info_.size();
}
inline int BusDeviceInfo::thunderbolt_info_size() const
{
    return _internal_thunderbolt_info_size();
}
inline void BusDeviceInfo::clear_thunderbolt_info()
{
    _impl_.thunderbolt_info_.Clear();
}
inline ::reporting::ThunderboltInfo* BusDeviceInfo::mutable_thunderbolt_info(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.BusDeviceInfo.thunderbolt_info)
    return _impl_.thunderbolt_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::ThunderboltInfo>* BusDeviceInfo::mutable_thunderbolt_info()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.BusDeviceInfo.thunderbolt_info)
    return &_impl_.thunderbolt_info_;
}
inline const ::reporting::ThunderboltInfo& BusDeviceInfo::_internal_thunderbolt_info(int index) const
{
    return _impl_.thunderbolt_info_.Get(index);
}
inline const ::reporting::ThunderboltInfo& BusDeviceInfo::thunderbolt_info(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.BusDeviceInfo.thunderbolt_info)
    return _internal_thunderbolt_info(index);
}
inline ::reporting::ThunderboltInfo* BusDeviceInfo::_internal_add_thunderbolt_info()
{
    return _impl_.thunderbolt_info_.Add();
}
inline ::reporting::ThunderboltInfo* BusDeviceInfo::add_thunderbolt_info()
{
    ::reporting::ThunderboltInfo* _add = _internal_add_thunderbolt_info();
    // @@protoc_insertion_point(field_add:reporting.BusDeviceInfo.thunderbolt_info)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::ThunderboltInfo>& BusDeviceInfo::thunderbolt_info() const
{
    // @@protoc_insertion_point(field_list:reporting.BusDeviceInfo.thunderbolt_info)
    return _impl_.thunderbolt_info_;
}

// -------------------------------------------------------------------

// TotalMemoryEncryptionInfo

// optional .reporting.MemoryEncryptionState encryption_state = 1;
inline bool TotalMemoryEncryptionInfo::_internal_has_encryption_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool TotalMemoryEncryptionInfo::has_encryption_state() const
{
    return _internal_has_encryption_state();
}
inline void TotalMemoryEncryptionInfo::clear_encryption_state()
{
    _impl_.encryption_state_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::reporting::MemoryEncryptionState TotalMemoryEncryptionInfo::_internal_encryption_state() const
{
    return static_cast<::reporting::MemoryEncryptionState>(_impl_.encryption_state_);
}
inline ::reporting::MemoryEncryptionState TotalMemoryEncryptionInfo::encryption_state() const
{
    // @@protoc_insertion_point(field_get:reporting.TotalMemoryEncryptionInfo.encryption_state)
    return _internal_encryption_state();
}
inline void TotalMemoryEncryptionInfo::_internal_set_encryption_state(::reporting::MemoryEncryptionState value)
{
    assert(::reporting::MemoryEncryptionState_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.encryption_state_ = value;
}
inline void TotalMemoryEncryptionInfo::set_encryption_state(::reporting::MemoryEncryptionState value)
{
    _internal_set_encryption_state(value);
    // @@protoc_insertion_point(field_set:reporting.TotalMemoryEncryptionInfo.encryption_state)
}

// optional int64 max_keys = 2;
inline bool TotalMemoryEncryptionInfo::_internal_has_max_keys() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool TotalMemoryEncryptionInfo::has_max_keys() const
{
    return _internal_has_max_keys();
}
inline void TotalMemoryEncryptionInfo::clear_max_keys()
{
    _impl_.max_keys_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t TotalMemoryEncryptionInfo::_internal_max_keys() const
{
    return _impl_.max_keys_;
}
inline int64_t TotalMemoryEncryptionInfo::max_keys() const
{
    // @@protoc_insertion_point(field_get:reporting.TotalMemoryEncryptionInfo.max_keys)
    return _internal_max_keys();
}
inline void TotalMemoryEncryptionInfo::_internal_set_max_keys(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.max_keys_ = value;
}
inline void TotalMemoryEncryptionInfo::set_max_keys(int64_t value)
{
    _internal_set_max_keys(value);
    // @@protoc_insertion_point(field_set:reporting.TotalMemoryEncryptionInfo.max_keys)
}

// optional int64 key_length = 3;
inline bool TotalMemoryEncryptionInfo::_internal_has_key_length() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool TotalMemoryEncryptionInfo::has_key_length() const
{
    return _internal_has_key_length();
}
inline void TotalMemoryEncryptionInfo::clear_key_length()
{
    _impl_.key_length_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t TotalMemoryEncryptionInfo::_internal_key_length() const
{
    return _impl_.key_length_;
}
inline int64_t TotalMemoryEncryptionInfo::key_length() const
{
    // @@protoc_insertion_point(field_get:reporting.TotalMemoryEncryptionInfo.key_length)
    return _internal_key_length();
}
inline void TotalMemoryEncryptionInfo::_internal_set_key_length(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.key_length_ = value;
}
inline void TotalMemoryEncryptionInfo::set_key_length(int64_t value)
{
    _internal_set_key_length(value);
    // @@protoc_insertion_point(field_set:reporting.TotalMemoryEncryptionInfo.key_length)
}

// optional .reporting.MemoryEncryptionAlgorithm encryption_algorithm = 4;
inline bool TotalMemoryEncryptionInfo::_internal_has_encryption_algorithm() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool TotalMemoryEncryptionInfo::has_encryption_algorithm() const
{
    return _internal_has_encryption_algorithm();
}
inline void TotalMemoryEncryptionInfo::clear_encryption_algorithm()
{
    _impl_.encryption_algorithm_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::reporting::MemoryEncryptionAlgorithm TotalMemoryEncryptionInfo::_internal_encryption_algorithm() const
{
    return static_cast<::reporting::MemoryEncryptionAlgorithm>(_impl_.encryption_algorithm_);
}
inline ::reporting::MemoryEncryptionAlgorithm TotalMemoryEncryptionInfo::encryption_algorithm() const
{
    // @@protoc_insertion_point(field_get:reporting.TotalMemoryEncryptionInfo.encryption_algorithm)
    return _internal_encryption_algorithm();
}
inline void TotalMemoryEncryptionInfo::_internal_set_encryption_algorithm(::reporting::MemoryEncryptionAlgorithm value)
{
    assert(::reporting::MemoryEncryptionAlgorithm_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.encryption_algorithm_ = value;
}
inline void TotalMemoryEncryptionInfo::set_encryption_algorithm(::reporting::MemoryEncryptionAlgorithm value)
{
    _internal_set_encryption_algorithm(value);
    // @@protoc_insertion_point(field_set:reporting.TotalMemoryEncryptionInfo.encryption_algorithm)
}

// -------------------------------------------------------------------

// MemoryInfo

// optional .reporting.TotalMemoryEncryptionInfo tme_info = 1;
inline bool MemoryInfo::_internal_has_tme_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.tme_info_ != nullptr);
    return value;
}
inline bool MemoryInfo::has_tme_info() const
{
    return _internal_has_tme_info();
}
inline void MemoryInfo::clear_tme_info()
{
    if (_impl_.tme_info_ != nullptr)
        _impl_.tme_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::reporting::TotalMemoryEncryptionInfo& MemoryInfo::_internal_tme_info() const
{
    const ::reporting::TotalMemoryEncryptionInfo* p = _impl_.tme_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::TotalMemoryEncryptionInfo&>(::reporting::_TotalMemoryEncryptionInfo_default_instance_);
}
inline const ::reporting::TotalMemoryEncryptionInfo& MemoryInfo::tme_info() const
{
    // @@protoc_insertion_point(field_get:reporting.MemoryInfo.tme_info)
    return _internal_tme_info();
}
inline void MemoryInfo::unsafe_arena_set_allocated_tme_info(::reporting::TotalMemoryEncryptionInfo* tme_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tme_info_);
    }
    _impl_.tme_info_ = tme_info;
    if (tme_info) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.MemoryInfo.tme_info)
}
inline ::reporting::TotalMemoryEncryptionInfo* MemoryInfo::release_tme_info()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::TotalMemoryEncryptionInfo* temp = _impl_.tme_info_;
    _impl_.tme_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::TotalMemoryEncryptionInfo* MemoryInfo::unsafe_arena_release_tme_info()
{
    // @@protoc_insertion_point(field_release:reporting.MemoryInfo.tme_info)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::TotalMemoryEncryptionInfo* temp = _impl_.tme_info_;
    _impl_.tme_info_ = nullptr;
    return temp;
}
inline ::reporting::TotalMemoryEncryptionInfo* MemoryInfo::_internal_mutable_tme_info()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.tme_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::TotalMemoryEncryptionInfo>(GetArenaForAllocation());
        _impl_.tme_info_ = p;
    }
    return _impl_.tme_info_;
}
inline ::reporting::TotalMemoryEncryptionInfo* MemoryInfo::mutable_tme_info()
{
    ::reporting::TotalMemoryEncryptionInfo* _msg = _internal_mutable_tme_info();
    // @@protoc_insertion_point(field_mutable:reporting.MemoryInfo.tme_info)
    return _msg;
}
inline void MemoryInfo::set_allocated_tme_info(::reporting::TotalMemoryEncryptionInfo* tme_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.tme_info_;
    }
    if (tme_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tme_info);
        if (message_arena != submessage_arena) {
            tme_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, tme_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.tme_info_ = tme_info;
    // @@protoc_insertion_point(field_set_allocated:reporting.MemoryInfo.tme_info)
}

// -------------------------------------------------------------------

// NetworkInterface

// optional .reporting.NetworkDeviceType type = 1;
inline bool NetworkInterface::_internal_has_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool NetworkInterface::has_type() const
{
    return _internal_has_type();
}
inline void NetworkInterface::clear_type()
{
    _impl_.type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::reporting::NetworkDeviceType NetworkInterface::_internal_type() const
{
    return static_cast<::reporting::NetworkDeviceType>(_impl_.type_);
}
inline ::reporting::NetworkDeviceType NetworkInterface::type() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkInterface.type)
    return _internal_type();
}
inline void NetworkInterface::_internal_set_type(::reporting::NetworkDeviceType value)
{
    assert(::reporting::NetworkDeviceType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.type_ = value;
}
inline void NetworkInterface::set_type(::reporting::NetworkDeviceType value)
{
    _internal_set_type(value);
    // @@protoc_insertion_point(field_set:reporting.NetworkInterface.type)
}

// optional string mac_address = 2;
inline bool NetworkInterface::_internal_has_mac_address() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool NetworkInterface::has_mac_address() const
{
    return _internal_has_mac_address();
}
inline void NetworkInterface::clear_mac_address()
{
    _impl_.mac_address_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetworkInterface::mac_address() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkInterface.mac_address)
    return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NetworkInterface::set_mac_address(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.mac_address_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.NetworkInterface.mac_address)
}
inline std::string* NetworkInterface::mutable_mac_address()
{
    std::string* _s = _internal_mutable_mac_address();
    // @@protoc_insertion_point(field_mutable:reporting.NetworkInterface.mac_address)
    return _s;
}
inline const std::string& NetworkInterface::_internal_mac_address() const
{
    return _impl_.mac_address_.Get();
}
inline void NetworkInterface::_internal_set_mac_address(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.mac_address_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_mac_address()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.mac_address_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_mac_address()
{
    // @@protoc_insertion_point(field_release:reporting.NetworkInterface.mac_address)
    if (!_internal_has_mac_address()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.mac_address_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.mac_address_.IsDefault()) {
        _impl_.mac_address_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NetworkInterface::set_allocated_mac_address(std::string* mac_address)
{
    if (mac_address != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.mac_address_.SetAllocated(mac_address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.mac_address_.IsDefault()) {
        _impl_.mac_address_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworkInterface.mac_address)
}

// optional string meid = 3;
inline bool NetworkInterface::_internal_has_meid() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool NetworkInterface::has_meid() const
{
    return _internal_has_meid();
}
inline void NetworkInterface::clear_meid()
{
    _impl_.meid_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NetworkInterface::meid() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkInterface.meid)
    return _internal_meid();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NetworkInterface::set_meid(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.meid_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.NetworkInterface.meid)
}
inline std::string* NetworkInterface::mutable_meid()
{
    std::string* _s = _internal_mutable_meid();
    // @@protoc_insertion_point(field_mutable:reporting.NetworkInterface.meid)
    return _s;
}
inline const std::string& NetworkInterface::_internal_meid() const
{
    return _impl_.meid_.Get();
}
inline void NetworkInterface::_internal_set_meid(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.meid_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_meid()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.meid_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_meid()
{
    // @@protoc_insertion_point(field_release:reporting.NetworkInterface.meid)
    if (!_internal_has_meid()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.meid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.meid_.IsDefault()) {
        _impl_.meid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NetworkInterface::set_allocated_meid(std::string* meid)
{
    if (meid != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.meid_.SetAllocated(meid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.meid_.IsDefault()) {
        _impl_.meid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworkInterface.meid)
}

// optional string imei = 4;
inline bool NetworkInterface::_internal_has_imei() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool NetworkInterface::has_imei() const
{
    return _internal_has_imei();
}
inline void NetworkInterface::clear_imei()
{
    _impl_.imei_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NetworkInterface::imei() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkInterface.imei)
    return _internal_imei();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NetworkInterface::set_imei(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.imei_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.NetworkInterface.imei)
}
inline std::string* NetworkInterface::mutable_imei()
{
    std::string* _s = _internal_mutable_imei();
    // @@protoc_insertion_point(field_mutable:reporting.NetworkInterface.imei)
    return _s;
}
inline const std::string& NetworkInterface::_internal_imei() const
{
    return _impl_.imei_.Get();
}
inline void NetworkInterface::_internal_set_imei(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.imei_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_imei()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.imei_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_imei()
{
    // @@protoc_insertion_point(field_release:reporting.NetworkInterface.imei)
    if (!_internal_has_imei()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.imei_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.imei_.IsDefault()) {
        _impl_.imei_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NetworkInterface::set_allocated_imei(std::string* imei)
{
    if (imei != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.imei_.SetAllocated(imei, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.imei_.IsDefault()) {
        _impl_.imei_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworkInterface.imei)
}

// optional string device_path = 5;
inline bool NetworkInterface::_internal_has_device_path() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool NetworkInterface::has_device_path() const
{
    return _internal_has_device_path();
}
inline void NetworkInterface::clear_device_path()
{
    _impl_.device_path_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& NetworkInterface::device_path() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkInterface.device_path)
    return _internal_device_path();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NetworkInterface::set_device_path(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.device_path_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.NetworkInterface.device_path)
}
inline std::string* NetworkInterface::mutable_device_path()
{
    std::string* _s = _internal_mutable_device_path();
    // @@protoc_insertion_point(field_mutable:reporting.NetworkInterface.device_path)
    return _s;
}
inline const std::string& NetworkInterface::_internal_device_path() const
{
    return _impl_.device_path_.Get();
}
inline void NetworkInterface::_internal_set_device_path(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.device_path_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_device_path()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.device_path_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_device_path()
{
    // @@protoc_insertion_point(field_release:reporting.NetworkInterface.device_path)
    if (!_internal_has_device_path()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.device_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.device_path_.IsDefault()) {
        _impl_.device_path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NetworkInterface::set_allocated_device_path(std::string* device_path)
{
    if (device_path != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.device_path_.SetAllocated(device_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.device_path_.IsDefault()) {
        _impl_.device_path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworkInterface.device_path)
}

// optional string iccid = 6;
inline bool NetworkInterface::_internal_has_iccid() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool NetworkInterface::has_iccid() const
{
    return _internal_has_iccid();
}
inline void NetworkInterface::clear_iccid()
{
    _impl_.iccid_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& NetworkInterface::iccid() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkInterface.iccid)
    return _internal_iccid();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NetworkInterface::set_iccid(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.iccid_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.NetworkInterface.iccid)
}
inline std::string* NetworkInterface::mutable_iccid()
{
    std::string* _s = _internal_mutable_iccid();
    // @@protoc_insertion_point(field_mutable:reporting.NetworkInterface.iccid)
    return _s;
}
inline const std::string& NetworkInterface::_internal_iccid() const
{
    return _impl_.iccid_.Get();
}
inline void NetworkInterface::_internal_set_iccid(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.iccid_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_iccid()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    return _impl_.iccid_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_iccid()
{
    // @@protoc_insertion_point(field_release:reporting.NetworkInterface.iccid)
    if (!_internal_has_iccid()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000010u;
    auto* p = _impl_.iccid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.iccid_.IsDefault()) {
        _impl_.iccid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NetworkInterface::set_allocated_iccid(std::string* iccid)
{
    if (iccid != nullptr) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.iccid_.SetAllocated(iccid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.iccid_.IsDefault()) {
        _impl_.iccid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworkInterface.iccid)
}

// optional string mdn = 7;
inline bool NetworkInterface::_internal_has_mdn() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool NetworkInterface::has_mdn() const
{
    return _internal_has_mdn();
}
inline void NetworkInterface::clear_mdn()
{
    _impl_.mdn_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& NetworkInterface::mdn() const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkInterface.mdn)
    return _internal_mdn();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NetworkInterface::set_mdn(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.mdn_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.NetworkInterface.mdn)
}
inline std::string* NetworkInterface::mutable_mdn()
{
    std::string* _s = _internal_mutable_mdn();
    // @@protoc_insertion_point(field_mutable:reporting.NetworkInterface.mdn)
    return _s;
}
inline const std::string& NetworkInterface::_internal_mdn() const
{
    return _impl_.mdn_.Get();
}
inline void NetworkInterface::_internal_set_mdn(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.mdn_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkInterface::_internal_mutable_mdn()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    return _impl_.mdn_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkInterface::release_mdn()
{
    // @@protoc_insertion_point(field_release:reporting.NetworkInterface.mdn)
    if (!_internal_has_mdn()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000020u;
    auto* p = _impl_.mdn_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.mdn_.IsDefault()) {
        _impl_.mdn_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NetworkInterface::set_allocated_mdn(std::string* mdn)
{
    if (mdn != nullptr) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.mdn_.SetAllocated(mdn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.mdn_.IsDefault()) {
        _impl_.mdn_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.NetworkInterface.mdn)
}

// repeated string eids = 8;
inline int NetworkInterface::_internal_eids_size() const
{
    return _impl_.eids_.size();
}
inline int NetworkInterface::eids_size() const
{
    return _internal_eids_size();
}
inline void NetworkInterface::clear_eids()
{
    _impl_.eids_.Clear();
}
inline std::string* NetworkInterface::add_eids()
{
    std::string* _s = _internal_add_eids();
    // @@protoc_insertion_point(field_add_mutable:reporting.NetworkInterface.eids)
    return _s;
}
inline const std::string& NetworkInterface::_internal_eids(int index) const
{
    return _impl_.eids_.Get(index);
}
inline const std::string& NetworkInterface::eids(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.NetworkInterface.eids)
    return _internal_eids(index);
}
inline std::string* NetworkInterface::mutable_eids(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.NetworkInterface.eids)
    return _impl_.eids_.Mutable(index);
}
inline void NetworkInterface::set_eids(int index, const std::string& value)
{
    _impl_.eids_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:reporting.NetworkInterface.eids)
}
inline void NetworkInterface::set_eids(int index, std::string&& value)
{
    _impl_.eids_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:reporting.NetworkInterface.eids)
}
inline void NetworkInterface::set_eids(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.eids_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:reporting.NetworkInterface.eids)
}
inline void NetworkInterface::set_eids(int index, const char* value, size_t size)
{
    _impl_.eids_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:reporting.NetworkInterface.eids)
}
inline std::string* NetworkInterface::_internal_add_eids()
{
    return _impl_.eids_.Add();
}
inline void NetworkInterface::add_eids(const std::string& value)
{
    _impl_.eids_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:reporting.NetworkInterface.eids)
}
inline void NetworkInterface::add_eids(std::string&& value)
{
    _impl_.eids_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:reporting.NetworkInterface.eids)
}
inline void NetworkInterface::add_eids(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.eids_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:reporting.NetworkInterface.eids)
}
inline void NetworkInterface::add_eids(const char* value, size_t size)
{
    _impl_.eids_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:reporting.NetworkInterface.eids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& NetworkInterface::eids() const
{
    // @@protoc_insertion_point(field_list:reporting.NetworkInterface.eids)
    return _impl_.eids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* NetworkInterface::mutable_eids()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.NetworkInterface.eids)
    return &_impl_.eids_;
}

// -------------------------------------------------------------------

// NetworksInfo

// repeated .reporting.NetworkInterface network_interfaces = 1;
inline int NetworksInfo::_internal_network_interfaces_size() const
{
    return _impl_.network_interfaces_.size();
}
inline int NetworksInfo::network_interfaces_size() const
{
    return _internal_network_interfaces_size();
}
inline void NetworksInfo::clear_network_interfaces()
{
    _impl_.network_interfaces_.Clear();
}
inline ::reporting::NetworkInterface* NetworksInfo::mutable_network_interfaces(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.NetworksInfo.network_interfaces)
    return _impl_.network_interfaces_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::NetworkInterface>* NetworksInfo::mutable_network_interfaces()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.NetworksInfo.network_interfaces)
    return &_impl_.network_interfaces_;
}
inline const ::reporting::NetworkInterface& NetworksInfo::_internal_network_interfaces(int index) const
{
    return _impl_.network_interfaces_.Get(index);
}
inline const ::reporting::NetworkInterface& NetworksInfo::network_interfaces(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.NetworksInfo.network_interfaces)
    return _internal_network_interfaces(index);
}
inline ::reporting::NetworkInterface* NetworksInfo::_internal_add_network_interfaces()
{
    return _impl_.network_interfaces_.Add();
}
inline ::reporting::NetworkInterface* NetworksInfo::add_network_interfaces()
{
    ::reporting::NetworkInterface* _add = _internal_add_network_interfaces();
    // @@protoc_insertion_point(field_add:reporting.NetworksInfo.network_interfaces)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::NetworkInterface>& NetworksInfo::network_interfaces() const
{
    // @@protoc_insertion_point(field_list:reporting.NetworksInfo.network_interfaces)
    return _impl_.network_interfaces_;
}

// -------------------------------------------------------------------

// TouchScreenInfo

// optional string library_name = 1;
inline bool TouchScreenInfo::_internal_has_library_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool TouchScreenInfo::has_library_name() const
{
    return _internal_has_library_name();
}
inline void TouchScreenInfo::clear_library_name()
{
    _impl_.library_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TouchScreenInfo::library_name() const
{
    // @@protoc_insertion_point(field_get:reporting.TouchScreenInfo.library_name)
    return _internal_library_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void TouchScreenInfo::set_library_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.library_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.TouchScreenInfo.library_name)
}
inline std::string* TouchScreenInfo::mutable_library_name()
{
    std::string* _s = _internal_mutable_library_name();
    // @@protoc_insertion_point(field_mutable:reporting.TouchScreenInfo.library_name)
    return _s;
}
inline const std::string& TouchScreenInfo::_internal_library_name() const
{
    return _impl_.library_name_.Get();
}
inline void TouchScreenInfo::_internal_set_library_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.library_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TouchScreenInfo::_internal_mutable_library_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.library_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TouchScreenInfo::release_library_name()
{
    // @@protoc_insertion_point(field_release:reporting.TouchScreenInfo.library_name)
    if (!_internal_has_library_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.library_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.library_name_.IsDefault()) {
        _impl_.library_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void TouchScreenInfo::set_allocated_library_name(std::string* library_name)
{
    if (library_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.library_name_.SetAllocated(library_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.library_name_.IsDefault()) {
        _impl_.library_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.TouchScreenInfo.library_name)
}

// repeated .reporting.TouchScreenDevice touch_screen_devices = 2;
inline int TouchScreenInfo::_internal_touch_screen_devices_size() const
{
    return _impl_.touch_screen_devices_.size();
}
inline int TouchScreenInfo::touch_screen_devices_size() const
{
    return _internal_touch_screen_devices_size();
}
inline void TouchScreenInfo::clear_touch_screen_devices()
{
    _impl_.touch_screen_devices_.Clear();
}
inline ::reporting::TouchScreenDevice* TouchScreenInfo::mutable_touch_screen_devices(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.TouchScreenInfo.touch_screen_devices)
    return _impl_.touch_screen_devices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::TouchScreenDevice>* TouchScreenInfo::mutable_touch_screen_devices()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.TouchScreenInfo.touch_screen_devices)
    return &_impl_.touch_screen_devices_;
}
inline const ::reporting::TouchScreenDevice& TouchScreenInfo::_internal_touch_screen_devices(int index) const
{
    return _impl_.touch_screen_devices_.Get(index);
}
inline const ::reporting::TouchScreenDevice& TouchScreenInfo::touch_screen_devices(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.TouchScreenInfo.touch_screen_devices)
    return _internal_touch_screen_devices(index);
}
inline ::reporting::TouchScreenDevice* TouchScreenInfo::_internal_add_touch_screen_devices()
{
    return _impl_.touch_screen_devices_.Add();
}
inline ::reporting::TouchScreenDevice* TouchScreenInfo::add_touch_screen_devices()
{
    ::reporting::TouchScreenDevice* _add = _internal_add_touch_screen_devices();
    // @@protoc_insertion_point(field_add:reporting.TouchScreenInfo.touch_screen_devices)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::TouchScreenDevice>& TouchScreenInfo::touch_screen_devices() const
{
    // @@protoc_insertion_point(field_list:reporting.TouchScreenInfo.touch_screen_devices)
    return _impl_.touch_screen_devices_;
}

// -------------------------------------------------------------------

// TouchScreenDevice

// optional string display_name = 1;
inline bool TouchScreenDevice::_internal_has_display_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool TouchScreenDevice::has_display_name() const
{
    return _internal_has_display_name();
}
inline void TouchScreenDevice::clear_display_name()
{
    _impl_.display_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TouchScreenDevice::display_name() const
{
    // @@protoc_insertion_point(field_get:reporting.TouchScreenDevice.display_name)
    return _internal_display_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void TouchScreenDevice::set_display_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.display_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.TouchScreenDevice.display_name)
}
inline std::string* TouchScreenDevice::mutable_display_name()
{
    std::string* _s = _internal_mutable_display_name();
    // @@protoc_insertion_point(field_mutable:reporting.TouchScreenDevice.display_name)
    return _s;
}
inline const std::string& TouchScreenDevice::_internal_display_name() const
{
    return _impl_.display_name_.Get();
}
inline void TouchScreenDevice::_internal_set_display_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TouchScreenDevice::_internal_mutable_display_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* TouchScreenDevice::release_display_name()
{
    // @@protoc_insertion_point(field_release:reporting.TouchScreenDevice.display_name)
    if (!_internal_has_display_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.display_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.display_name_.IsDefault()) {
        _impl_.display_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void TouchScreenDevice::set_allocated_display_name(std::string* display_name)
{
    if (display_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.display_name_.IsDefault()) {
        _impl_.display_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.TouchScreenDevice.display_name)
}

// optional int32 touch_points = 2;
inline bool TouchScreenDevice::_internal_has_touch_points() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool TouchScreenDevice::has_touch_points() const
{
    return _internal_has_touch_points();
}
inline void TouchScreenDevice::clear_touch_points()
{
    _impl_.touch_points_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TouchScreenDevice::_internal_touch_points() const
{
    return _impl_.touch_points_;
}
inline int32_t TouchScreenDevice::touch_points() const
{
    // @@protoc_insertion_point(field_get:reporting.TouchScreenDevice.touch_points)
    return _internal_touch_points();
}
inline void TouchScreenDevice::_internal_set_touch_points(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.touch_points_ = value;
}
inline void TouchScreenDevice::set_touch_points(int32_t value)
{
    _internal_set_touch_points(value);
    // @@protoc_insertion_point(field_set:reporting.TouchScreenDevice.touch_points)
}

// optional bool has_stylus = 3;
inline bool TouchScreenDevice::_internal_has_has_stylus() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool TouchScreenDevice::has_has_stylus() const
{
    return _internal_has_has_stylus();
}
inline void TouchScreenDevice::clear_has_stylus()
{
    _impl_.has_stylus_ = false;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool TouchScreenDevice::_internal_has_stylus() const
{
    return _impl_.has_stylus_;
}
inline bool TouchScreenDevice::has_stylus() const
{
    // @@protoc_insertion_point(field_get:reporting.TouchScreenDevice.has_stylus)
    return _internal_has_stylus();
}
inline void TouchScreenDevice::_internal_set_has_stylus(bool value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.has_stylus_ = value;
}
inline void TouchScreenDevice::set_has_stylus(bool value)
{
    _internal_set_has_stylus(value);
    // @@protoc_insertion_point(field_set:reporting.TouchScreenDevice.has_stylus)
}

// -------------------------------------------------------------------

// PrivacyScreenInfo

// optional bool supported = 1;
inline bool PrivacyScreenInfo::_internal_has_supported() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool PrivacyScreenInfo::has_supported() const
{
    return _internal_has_supported();
}
inline void PrivacyScreenInfo::clear_supported()
{
    _impl_.supported_ = false;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool PrivacyScreenInfo::_internal_supported() const
{
    return _impl_.supported_;
}
inline bool PrivacyScreenInfo::supported() const
{
    // @@protoc_insertion_point(field_get:reporting.PrivacyScreenInfo.supported)
    return _internal_supported();
}
inline void PrivacyScreenInfo::_internal_set_supported(bool value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.supported_ = value;
}
inline void PrivacyScreenInfo::set_supported(bool value)
{
    _internal_set_supported(value);
    // @@protoc_insertion_point(field_set:reporting.PrivacyScreenInfo.supported)
}

// -------------------------------------------------------------------

// DisplayInfo

// repeated .reporting.DisplayDevice display_device = 1;
inline int DisplayInfo::_internal_display_device_size() const
{
    return _impl_.display_device_.size();
}
inline int DisplayInfo::display_device_size() const
{
    return _internal_display_device_size();
}
inline void DisplayInfo::clear_display_device()
{
    _impl_.display_device_.Clear();
}
inline ::reporting::DisplayDevice* DisplayInfo::mutable_display_device(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.DisplayInfo.display_device)
    return _impl_.display_device_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::DisplayDevice>* DisplayInfo::mutable_display_device()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.DisplayInfo.display_device)
    return &_impl_.display_device_;
}
inline const ::reporting::DisplayDevice& DisplayInfo::_internal_display_device(int index) const
{
    return _impl_.display_device_.Get(index);
}
inline const ::reporting::DisplayDevice& DisplayInfo::display_device(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.DisplayInfo.display_device)
    return _internal_display_device(index);
}
inline ::reporting::DisplayDevice* DisplayInfo::_internal_add_display_device()
{
    return _impl_.display_device_.Add();
}
inline ::reporting::DisplayDevice* DisplayInfo::add_display_device()
{
    ::reporting::DisplayDevice* _add = _internal_add_display_device();
    // @@protoc_insertion_point(field_add:reporting.DisplayInfo.display_device)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::DisplayDevice>& DisplayInfo::display_device() const
{
    // @@protoc_insertion_point(field_list:reporting.DisplayInfo.display_device)
    return _impl_.display_device_;
}

// -------------------------------------------------------------------

// DisplayDevice

// optional string display_name = 1;
inline bool DisplayDevice::_internal_has_display_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool DisplayDevice::has_display_name() const
{
    return _internal_has_display_name();
}
inline void DisplayDevice::clear_display_name()
{
    _impl_.display_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DisplayDevice::display_name() const
{
    // @@protoc_insertion_point(field_get:reporting.DisplayDevice.display_name)
    return _internal_display_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DisplayDevice::set_display_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.display_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.DisplayDevice.display_name)
}
inline std::string* DisplayDevice::mutable_display_name()
{
    std::string* _s = _internal_mutable_display_name();
    // @@protoc_insertion_point(field_mutable:reporting.DisplayDevice.display_name)
    return _s;
}
inline const std::string& DisplayDevice::_internal_display_name() const
{
    return _impl_.display_name_.Get();
}
inline void DisplayDevice::_internal_set_display_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DisplayDevice::_internal_mutable_display_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DisplayDevice::release_display_name()
{
    // @@protoc_insertion_point(field_release:reporting.DisplayDevice.display_name)
    if (!_internal_has_display_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.display_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.display_name_.IsDefault()) {
        _impl_.display_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DisplayDevice::set_allocated_display_name(std::string* display_name)
{
    if (display_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.display_name_.IsDefault()) {
        _impl_.display_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.DisplayDevice.display_name)
}

// optional int32 display_width = 2;
inline bool DisplayDevice::_internal_has_display_width() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool DisplayDevice::has_display_width() const
{
    return _internal_has_display_width();
}
inline void DisplayDevice::clear_display_width()
{
    _impl_.display_width_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t DisplayDevice::_internal_display_width() const
{
    return _impl_.display_width_;
}
inline int32_t DisplayDevice::display_width() const
{
    // @@protoc_insertion_point(field_get:reporting.DisplayDevice.display_width)
    return _internal_display_width();
}
inline void DisplayDevice::_internal_set_display_width(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.display_width_ = value;
}
inline void DisplayDevice::set_display_width(int32_t value)
{
    _internal_set_display_width(value);
    // @@protoc_insertion_point(field_set:reporting.DisplayDevice.display_width)
}

// optional int32 display_height = 3;
inline bool DisplayDevice::_internal_has_display_height() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool DisplayDevice::has_display_height() const
{
    return _internal_has_display_height();
}
inline void DisplayDevice::clear_display_height()
{
    _impl_.display_height_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t DisplayDevice::_internal_display_height() const
{
    return _impl_.display_height_;
}
inline int32_t DisplayDevice::display_height() const
{
    // @@protoc_insertion_point(field_get:reporting.DisplayDevice.display_height)
    return _internal_display_height();
}
inline void DisplayDevice::_internal_set_display_height(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.display_height_ = value;
}
inline void DisplayDevice::set_display_height(int32_t value)
{
    _internal_set_display_height(value);
    // @@protoc_insertion_point(field_set:reporting.DisplayDevice.display_height)
}

// optional bool is_internal = 4;
inline bool DisplayDevice::_internal_has_is_internal() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool DisplayDevice::has_is_internal() const
{
    return _internal_has_is_internal();
}
inline void DisplayDevice::clear_is_internal()
{
    _impl_.is_internal_ = false;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool DisplayDevice::_internal_is_internal() const
{
    return _impl_.is_internal_;
}
inline bool DisplayDevice::is_internal() const
{
    // @@protoc_insertion_point(field_get:reporting.DisplayDevice.is_internal)
    return _internal_is_internal();
}
inline void DisplayDevice::_internal_set_is_internal(bool value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.is_internal_ = value;
}
inline void DisplayDevice::set_is_internal(bool value)
{
    _internal_set_is_internal(value);
    // @@protoc_insertion_point(field_set:reporting.DisplayDevice.is_internal)
}

// optional string manufacturer = 5;
inline bool DisplayDevice::_internal_has_manufacturer() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool DisplayDevice::has_manufacturer() const
{
    return _internal_has_manufacturer();
}
inline void DisplayDevice::clear_manufacturer()
{
    _impl_.manufacturer_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DisplayDevice::manufacturer() const
{
    // @@protoc_insertion_point(field_get:reporting.DisplayDevice.manufacturer)
    return _internal_manufacturer();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DisplayDevice::set_manufacturer(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.manufacturer_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.DisplayDevice.manufacturer)
}
inline std::string* DisplayDevice::mutable_manufacturer()
{
    std::string* _s = _internal_mutable_manufacturer();
    // @@protoc_insertion_point(field_mutable:reporting.DisplayDevice.manufacturer)
    return _s;
}
inline const std::string& DisplayDevice::_internal_manufacturer() const
{
    return _impl_.manufacturer_.Get();
}
inline void DisplayDevice::_internal_set_manufacturer(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.manufacturer_.Set(value, GetArenaForAllocation());
}
inline std::string* DisplayDevice::_internal_mutable_manufacturer()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.manufacturer_.Mutable(GetArenaForAllocation());
}
inline std::string* DisplayDevice::release_manufacturer()
{
    // @@protoc_insertion_point(field_release:reporting.DisplayDevice.manufacturer)
    if (!_internal_has_manufacturer()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.manufacturer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.manufacturer_.IsDefault()) {
        _impl_.manufacturer_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DisplayDevice::set_allocated_manufacturer(std::string* manufacturer)
{
    if (manufacturer != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.manufacturer_.SetAllocated(manufacturer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.manufacturer_.IsDefault()) {
        _impl_.manufacturer_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.DisplayDevice.manufacturer)
}

// optional int32 model_id = 6;
inline bool DisplayDevice::_internal_has_model_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool DisplayDevice::has_model_id() const
{
    return _internal_has_model_id();
}
inline void DisplayDevice::clear_model_id()
{
    _impl_.model_id_ = 0;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t DisplayDevice::_internal_model_id() const
{
    return _impl_.model_id_;
}
inline int32_t DisplayDevice::model_id() const
{
    // @@protoc_insertion_point(field_get:reporting.DisplayDevice.model_id)
    return _internal_model_id();
}
inline void DisplayDevice::_internal_set_model_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.model_id_ = value;
}
inline void DisplayDevice::set_model_id(int32_t value)
{
    _internal_set_model_id(value);
    // @@protoc_insertion_point(field_set:reporting.DisplayDevice.model_id)
}

// optional int32 manufacture_year = 7;
inline bool DisplayDevice::_internal_has_manufacture_year() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool DisplayDevice::has_manufacture_year() const
{
    return _internal_has_manufacture_year();
}
inline void DisplayDevice::clear_manufacture_year()
{
    _impl_.manufacture_year_ = 0;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t DisplayDevice::_internal_manufacture_year() const
{
    return _impl_.manufacture_year_;
}
inline int32_t DisplayDevice::manufacture_year() const
{
    // @@protoc_insertion_point(field_get:reporting.DisplayDevice.manufacture_year)
    return _internal_manufacture_year();
}
inline void DisplayDevice::_internal_set_manufacture_year(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.manufacture_year_ = value;
}
inline void DisplayDevice::set_manufacture_year(int32_t value)
{
    _internal_set_manufacture_year(value);
    // @@protoc_insertion_point(field_set:reporting.DisplayDevice.manufacture_year)
}

// -------------------------------------------------------------------

// KeylockerInfo

// optional bool supported = 1;
inline bool KeylockerInfo::_internal_has_supported() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool KeylockerInfo::has_supported() const
{
    return _internal_has_supported();
}
inline void KeylockerInfo::clear_supported()
{
    _impl_.supported_ = false;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool KeylockerInfo::_internal_supported() const
{
    return _impl_.supported_;
}
inline bool KeylockerInfo::supported() const
{
    // @@protoc_insertion_point(field_get:reporting.KeylockerInfo.supported)
    return _internal_supported();
}
inline void KeylockerInfo::_internal_set_supported(bool value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.supported_ = value;
}
inline void KeylockerInfo::set_supported(bool value)
{
    _internal_set_supported(value);
    // @@protoc_insertion_point(field_set:reporting.KeylockerInfo.supported)
}

// optional bool configured = 2;
inline bool KeylockerInfo::_internal_has_configured() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool KeylockerInfo::has_configured() const
{
    return _internal_has_configured();
}
inline void KeylockerInfo::clear_configured()
{
    _impl_.configured_ = false;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool KeylockerInfo::_internal_configured() const
{
    return _impl_.configured_;
}
inline bool KeylockerInfo::configured() const
{
    // @@protoc_insertion_point(field_get:reporting.KeylockerInfo.configured)
    return _internal_configured();
}
inline void KeylockerInfo::_internal_set_configured(bool value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.configured_ = value;
}
inline void KeylockerInfo::set_configured(bool value)
{
    _internal_set_configured(value);
    // @@protoc_insertion_point(field_set:reporting.KeylockerInfo.configured)
}

// -------------------------------------------------------------------

// CpuInfo

// optional .reporting.KeylockerInfo keylocker_info = 1;
inline bool CpuInfo::_internal_has_keylocker_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.keylocker_info_ != nullptr);
    return value;
}
inline bool CpuInfo::has_keylocker_info() const
{
    return _internal_has_keylocker_info();
}
inline void CpuInfo::clear_keylocker_info()
{
    if (_impl_.keylocker_info_ != nullptr)
        _impl_.keylocker_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::reporting::KeylockerInfo& CpuInfo::_internal_keylocker_info() const
{
    const ::reporting::KeylockerInfo* p = _impl_.keylocker_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::KeylockerInfo&>(::reporting::_KeylockerInfo_default_instance_);
}
inline const ::reporting::KeylockerInfo& CpuInfo::keylocker_info() const
{
    // @@protoc_insertion_point(field_get:reporting.CpuInfo.keylocker_info)
    return _internal_keylocker_info();
}
inline void CpuInfo::unsafe_arena_set_allocated_keylocker_info(::reporting::KeylockerInfo* keylocker_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.keylocker_info_);
    }
    _impl_.keylocker_info_ = keylocker_info;
    if (keylocker_info) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.CpuInfo.keylocker_info)
}
inline ::reporting::KeylockerInfo* CpuInfo::release_keylocker_info()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::KeylockerInfo* temp = _impl_.keylocker_info_;
    _impl_.keylocker_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::KeylockerInfo* CpuInfo::unsafe_arena_release_keylocker_info()
{
    // @@protoc_insertion_point(field_release:reporting.CpuInfo.keylocker_info)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::KeylockerInfo* temp = _impl_.keylocker_info_;
    _impl_.keylocker_info_ = nullptr;
    return temp;
}
inline ::reporting::KeylockerInfo* CpuInfo::_internal_mutable_keylocker_info()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.keylocker_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::KeylockerInfo>(GetArenaForAllocation());
        _impl_.keylocker_info_ = p;
    }
    return _impl_.keylocker_info_;
}
inline ::reporting::KeylockerInfo* CpuInfo::mutable_keylocker_info()
{
    ::reporting::KeylockerInfo* _msg = _internal_mutable_keylocker_info();
    // @@protoc_insertion_point(field_mutable:reporting.CpuInfo.keylocker_info)
    return _msg;
}
inline void CpuInfo::set_allocated_keylocker_info(::reporting::KeylockerInfo* keylocker_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.keylocker_info_;
    }
    if (keylocker_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(keylocker_info);
        if (message_arena != submessage_arena) {
            keylocker_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, keylocker_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.keylocker_info_ = keylocker_info;
    // @@protoc_insertion_point(field_set_allocated:reporting.CpuInfo.keylocker_info)
}

// -------------------------------------------------------------------

// InfoData

// optional .reporting.CpuInfo cpu_info = 1;
inline bool InfoData::_internal_has_cpu_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.cpu_info_ != nullptr);
    return value;
}
inline bool InfoData::has_cpu_info() const
{
    return _internal_has_cpu_info();
}
inline void InfoData::clear_cpu_info()
{
    if (_impl_.cpu_info_ != nullptr)
        _impl_.cpu_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::reporting::CpuInfo& InfoData::_internal_cpu_info() const
{
    const ::reporting::CpuInfo* p = _impl_.cpu_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::CpuInfo&>(::reporting::_CpuInfo_default_instance_);
}
inline const ::reporting::CpuInfo& InfoData::cpu_info() const
{
    // @@protoc_insertion_point(field_get:reporting.InfoData.cpu_info)
    return _internal_cpu_info();
}
inline void InfoData::unsafe_arena_set_allocated_cpu_info(::reporting::CpuInfo* cpu_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cpu_info_);
    }
    _impl_.cpu_info_ = cpu_info;
    if (cpu_info) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.InfoData.cpu_info)
}
inline ::reporting::CpuInfo* InfoData::release_cpu_info()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::CpuInfo* temp = _impl_.cpu_info_;
    _impl_.cpu_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::CpuInfo* InfoData::unsafe_arena_release_cpu_info()
{
    // @@protoc_insertion_point(field_release:reporting.InfoData.cpu_info)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::CpuInfo* temp = _impl_.cpu_info_;
    _impl_.cpu_info_ = nullptr;
    return temp;
}
inline ::reporting::CpuInfo* InfoData::_internal_mutable_cpu_info()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.cpu_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::CpuInfo>(GetArenaForAllocation());
        _impl_.cpu_info_ = p;
    }
    return _impl_.cpu_info_;
}
inline ::reporting::CpuInfo* InfoData::mutable_cpu_info()
{
    ::reporting::CpuInfo* _msg = _internal_mutable_cpu_info();
    // @@protoc_insertion_point(field_mutable:reporting.InfoData.cpu_info)
    return _msg;
}
inline void InfoData::set_allocated_cpu_info(::reporting::CpuInfo* cpu_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.cpu_info_;
    }
    if (cpu_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cpu_info);
        if (message_arena != submessage_arena) {
            cpu_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, cpu_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.cpu_info_ = cpu_info;
    // @@protoc_insertion_point(field_set_allocated:reporting.InfoData.cpu_info)
}

// optional .reporting.BusDeviceInfo bus_device_info = 2;
inline bool InfoData::_internal_has_bus_device_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.bus_device_info_ != nullptr);
    return value;
}
inline bool InfoData::has_bus_device_info() const
{
    return _internal_has_bus_device_info();
}
inline void InfoData::clear_bus_device_info()
{
    if (_impl_.bus_device_info_ != nullptr)
        _impl_.bus_device_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::reporting::BusDeviceInfo& InfoData::_internal_bus_device_info() const
{
    const ::reporting::BusDeviceInfo* p = _impl_.bus_device_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::BusDeviceInfo&>(::reporting::_BusDeviceInfo_default_instance_);
}
inline const ::reporting::BusDeviceInfo& InfoData::bus_device_info() const
{
    // @@protoc_insertion_point(field_get:reporting.InfoData.bus_device_info)
    return _internal_bus_device_info();
}
inline void InfoData::unsafe_arena_set_allocated_bus_device_info(::reporting::BusDeviceInfo* bus_device_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bus_device_info_);
    }
    _impl_.bus_device_info_ = bus_device_info;
    if (bus_device_info) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.InfoData.bus_device_info)
}
inline ::reporting::BusDeviceInfo* InfoData::release_bus_device_info()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::reporting::BusDeviceInfo* temp = _impl_.bus_device_info_;
    _impl_.bus_device_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::BusDeviceInfo* InfoData::unsafe_arena_release_bus_device_info()
{
    // @@protoc_insertion_point(field_release:reporting.InfoData.bus_device_info)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::reporting::BusDeviceInfo* temp = _impl_.bus_device_info_;
    _impl_.bus_device_info_ = nullptr;
    return temp;
}
inline ::reporting::BusDeviceInfo* InfoData::_internal_mutable_bus_device_info()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.bus_device_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::BusDeviceInfo>(GetArenaForAllocation());
        _impl_.bus_device_info_ = p;
    }
    return _impl_.bus_device_info_;
}
inline ::reporting::BusDeviceInfo* InfoData::mutable_bus_device_info()
{
    ::reporting::BusDeviceInfo* _msg = _internal_mutable_bus_device_info();
    // @@protoc_insertion_point(field_mutable:reporting.InfoData.bus_device_info)
    return _msg;
}
inline void InfoData::set_allocated_bus_device_info(::reporting::BusDeviceInfo* bus_device_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.bus_device_info_;
    }
    if (bus_device_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bus_device_info);
        if (message_arena != submessage_arena) {
            bus_device_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, bus_device_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.bus_device_info_ = bus_device_info;
    // @@protoc_insertion_point(field_set_allocated:reporting.InfoData.bus_device_info)
}

// optional .reporting.MemoryInfo memory_info = 3;
inline bool InfoData::_internal_has_memory_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.memory_info_ != nullptr);
    return value;
}
inline bool InfoData::has_memory_info() const
{
    return _internal_has_memory_info();
}
inline void InfoData::clear_memory_info()
{
    if (_impl_.memory_info_ != nullptr)
        _impl_.memory_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::reporting::MemoryInfo& InfoData::_internal_memory_info() const
{
    const ::reporting::MemoryInfo* p = _impl_.memory_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::MemoryInfo&>(::reporting::_MemoryInfo_default_instance_);
}
inline const ::reporting::MemoryInfo& InfoData::memory_info() const
{
    // @@protoc_insertion_point(field_get:reporting.InfoData.memory_info)
    return _internal_memory_info();
}
inline void InfoData::unsafe_arena_set_allocated_memory_info(::reporting::MemoryInfo* memory_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.memory_info_);
    }
    _impl_.memory_info_ = memory_info;
    if (memory_info) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.InfoData.memory_info)
}
inline ::reporting::MemoryInfo* InfoData::release_memory_info()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::reporting::MemoryInfo* temp = _impl_.memory_info_;
    _impl_.memory_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::MemoryInfo* InfoData::unsafe_arena_release_memory_info()
{
    // @@protoc_insertion_point(field_release:reporting.InfoData.memory_info)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::reporting::MemoryInfo* temp = _impl_.memory_info_;
    _impl_.memory_info_ = nullptr;
    return temp;
}
inline ::reporting::MemoryInfo* InfoData::_internal_mutable_memory_info()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.memory_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::MemoryInfo>(GetArenaForAllocation());
        _impl_.memory_info_ = p;
    }
    return _impl_.memory_info_;
}
inline ::reporting::MemoryInfo* InfoData::mutable_memory_info()
{
    ::reporting::MemoryInfo* _msg = _internal_mutable_memory_info();
    // @@protoc_insertion_point(field_mutable:reporting.InfoData.memory_info)
    return _msg;
}
inline void InfoData::set_allocated_memory_info(::reporting::MemoryInfo* memory_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.memory_info_;
    }
    if (memory_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(memory_info);
        if (message_arena != submessage_arena) {
            memory_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, memory_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.memory_info_ = memory_info;
    // @@protoc_insertion_point(field_set_allocated:reporting.InfoData.memory_info)
}

// optional .reporting.NetworksInfo networks_info = 4;
inline bool InfoData::_internal_has_networks_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.networks_info_ != nullptr);
    return value;
}
inline bool InfoData::has_networks_info() const
{
    return _internal_has_networks_info();
}
inline void InfoData::clear_networks_info()
{
    if (_impl_.networks_info_ != nullptr)
        _impl_.networks_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::reporting::NetworksInfo& InfoData::_internal_networks_info() const
{
    const ::reporting::NetworksInfo* p = _impl_.networks_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::NetworksInfo&>(::reporting::_NetworksInfo_default_instance_);
}
inline const ::reporting::NetworksInfo& InfoData::networks_info() const
{
    // @@protoc_insertion_point(field_get:reporting.InfoData.networks_info)
    return _internal_networks_info();
}
inline void InfoData::unsafe_arena_set_allocated_networks_info(::reporting::NetworksInfo* networks_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.networks_info_);
    }
    _impl_.networks_info_ = networks_info;
    if (networks_info) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.InfoData.networks_info)
}
inline ::reporting::NetworksInfo* InfoData::release_networks_info()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::reporting::NetworksInfo* temp = _impl_.networks_info_;
    _impl_.networks_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::NetworksInfo* InfoData::unsafe_arena_release_networks_info()
{
    // @@protoc_insertion_point(field_release:reporting.InfoData.networks_info)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::reporting::NetworksInfo* temp = _impl_.networks_info_;
    _impl_.networks_info_ = nullptr;
    return temp;
}
inline ::reporting::NetworksInfo* InfoData::_internal_mutable_networks_info()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.networks_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::NetworksInfo>(GetArenaForAllocation());
        _impl_.networks_info_ = p;
    }
    return _impl_.networks_info_;
}
inline ::reporting::NetworksInfo* InfoData::mutable_networks_info()
{
    ::reporting::NetworksInfo* _msg = _internal_mutable_networks_info();
    // @@protoc_insertion_point(field_mutable:reporting.InfoData.networks_info)
    return _msg;
}
inline void InfoData::set_allocated_networks_info(::reporting::NetworksInfo* networks_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.networks_info_;
    }
    if (networks_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(networks_info);
        if (message_arena != submessage_arena) {
            networks_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, networks_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.networks_info_ = networks_info;
    // @@protoc_insertion_point(field_set_allocated:reporting.InfoData.networks_info)
}

// optional .reporting.TouchScreenInfo touch_screen_info = 5;
inline bool InfoData::_internal_has_touch_screen_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.touch_screen_info_ != nullptr);
    return value;
}
inline bool InfoData::has_touch_screen_info() const
{
    return _internal_has_touch_screen_info();
}
inline void InfoData::clear_touch_screen_info()
{
    if (_impl_.touch_screen_info_ != nullptr)
        _impl_.touch_screen_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::reporting::TouchScreenInfo& InfoData::_internal_touch_screen_info() const
{
    const ::reporting::TouchScreenInfo* p = _impl_.touch_screen_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::TouchScreenInfo&>(::reporting::_TouchScreenInfo_default_instance_);
}
inline const ::reporting::TouchScreenInfo& InfoData::touch_screen_info() const
{
    // @@protoc_insertion_point(field_get:reporting.InfoData.touch_screen_info)
    return _internal_touch_screen_info();
}
inline void InfoData::unsafe_arena_set_allocated_touch_screen_info(::reporting::TouchScreenInfo* touch_screen_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.touch_screen_info_);
    }
    _impl_.touch_screen_info_ = touch_screen_info;
    if (touch_screen_info) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.InfoData.touch_screen_info)
}
inline ::reporting::TouchScreenInfo* InfoData::release_touch_screen_info()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::reporting::TouchScreenInfo* temp = _impl_.touch_screen_info_;
    _impl_.touch_screen_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::TouchScreenInfo* InfoData::unsafe_arena_release_touch_screen_info()
{
    // @@protoc_insertion_point(field_release:reporting.InfoData.touch_screen_info)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::reporting::TouchScreenInfo* temp = _impl_.touch_screen_info_;
    _impl_.touch_screen_info_ = nullptr;
    return temp;
}
inline ::reporting::TouchScreenInfo* InfoData::_internal_mutable_touch_screen_info()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.touch_screen_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::TouchScreenInfo>(GetArenaForAllocation());
        _impl_.touch_screen_info_ = p;
    }
    return _impl_.touch_screen_info_;
}
inline ::reporting::TouchScreenInfo* InfoData::mutable_touch_screen_info()
{
    ::reporting::TouchScreenInfo* _msg = _internal_mutable_touch_screen_info();
    // @@protoc_insertion_point(field_mutable:reporting.InfoData.touch_screen_info)
    return _msg;
}
inline void InfoData::set_allocated_touch_screen_info(::reporting::TouchScreenInfo* touch_screen_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.touch_screen_info_;
    }
    if (touch_screen_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(touch_screen_info);
        if (message_arena != submessage_arena) {
            touch_screen_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, touch_screen_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.touch_screen_info_ = touch_screen_info;
    // @@protoc_insertion_point(field_set_allocated:reporting.InfoData.touch_screen_info)
}

// optional .reporting.PrivacyScreenInfo privacy_screen_info = 6;
inline bool InfoData::_internal_has_privacy_screen_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.privacy_screen_info_ != nullptr);
    return value;
}
inline bool InfoData::has_privacy_screen_info() const
{
    return _internal_has_privacy_screen_info();
}
inline void InfoData::clear_privacy_screen_info()
{
    if (_impl_.privacy_screen_info_ != nullptr)
        _impl_.privacy_screen_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::reporting::PrivacyScreenInfo& InfoData::_internal_privacy_screen_info() const
{
    const ::reporting::PrivacyScreenInfo* p = _impl_.privacy_screen_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::PrivacyScreenInfo&>(::reporting::_PrivacyScreenInfo_default_instance_);
}
inline const ::reporting::PrivacyScreenInfo& InfoData::privacy_screen_info() const
{
    // @@protoc_insertion_point(field_get:reporting.InfoData.privacy_screen_info)
    return _internal_privacy_screen_info();
}
inline void InfoData::unsafe_arena_set_allocated_privacy_screen_info(::reporting::PrivacyScreenInfo* privacy_screen_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.privacy_screen_info_);
    }
    _impl_.privacy_screen_info_ = privacy_screen_info;
    if (privacy_screen_info) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.InfoData.privacy_screen_info)
}
inline ::reporting::PrivacyScreenInfo* InfoData::release_privacy_screen_info()
{
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::reporting::PrivacyScreenInfo* temp = _impl_.privacy_screen_info_;
    _impl_.privacy_screen_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::PrivacyScreenInfo* InfoData::unsafe_arena_release_privacy_screen_info()
{
    // @@protoc_insertion_point(field_release:reporting.InfoData.privacy_screen_info)
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::reporting::PrivacyScreenInfo* temp = _impl_.privacy_screen_info_;
    _impl_.privacy_screen_info_ = nullptr;
    return temp;
}
inline ::reporting::PrivacyScreenInfo* InfoData::_internal_mutable_privacy_screen_info()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    if (_impl_.privacy_screen_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::PrivacyScreenInfo>(GetArenaForAllocation());
        _impl_.privacy_screen_info_ = p;
    }
    return _impl_.privacy_screen_info_;
}
inline ::reporting::PrivacyScreenInfo* InfoData::mutable_privacy_screen_info()
{
    ::reporting::PrivacyScreenInfo* _msg = _internal_mutable_privacy_screen_info();
    // @@protoc_insertion_point(field_mutable:reporting.InfoData.privacy_screen_info)
    return _msg;
}
inline void InfoData::set_allocated_privacy_screen_info(::reporting::PrivacyScreenInfo* privacy_screen_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.privacy_screen_info_;
    }
    if (privacy_screen_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(privacy_screen_info);
        if (message_arena != submessage_arena) {
            privacy_screen_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, privacy_screen_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.privacy_screen_info_ = privacy_screen_info;
    // @@protoc_insertion_point(field_set_allocated:reporting.InfoData.privacy_screen_info)
}

// optional .reporting.DisplayInfo display_info = 7;
inline bool InfoData::_internal_has_display_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.display_info_ != nullptr);
    return value;
}
inline bool InfoData::has_display_info() const
{
    return _internal_has_display_info();
}
inline void InfoData::clear_display_info()
{
    if (_impl_.display_info_ != nullptr)
        _impl_.display_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::reporting::DisplayInfo& InfoData::_internal_display_info() const
{
    const ::reporting::DisplayInfo* p = _impl_.display_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::DisplayInfo&>(::reporting::_DisplayInfo_default_instance_);
}
inline const ::reporting::DisplayInfo& InfoData::display_info() const
{
    // @@protoc_insertion_point(field_get:reporting.InfoData.display_info)
    return _internal_display_info();
}
inline void InfoData::unsafe_arena_set_allocated_display_info(::reporting::DisplayInfo* display_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.display_info_);
    }
    _impl_.display_info_ = display_info;
    if (display_info) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.InfoData.display_info)
}
inline ::reporting::DisplayInfo* InfoData::release_display_info()
{
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::reporting::DisplayInfo* temp = _impl_.display_info_;
    _impl_.display_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::DisplayInfo* InfoData::unsafe_arena_release_display_info()
{
    // @@protoc_insertion_point(field_release:reporting.InfoData.display_info)
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::reporting::DisplayInfo* temp = _impl_.display_info_;
    _impl_.display_info_ = nullptr;
    return temp;
}
inline ::reporting::DisplayInfo* InfoData::_internal_mutable_display_info()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    if (_impl_.display_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::DisplayInfo>(GetArenaForAllocation());
        _impl_.display_info_ = p;
    }
    return _impl_.display_info_;
}
inline ::reporting::DisplayInfo* InfoData::mutable_display_info()
{
    ::reporting::DisplayInfo* _msg = _internal_mutable_display_info();
    // @@protoc_insertion_point(field_mutable:reporting.InfoData.display_info)
    return _msg;
}
inline void InfoData::set_allocated_display_info(::reporting::DisplayInfo* display_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.display_info_;
    }
    if (display_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(display_info);
        if (message_arena != submessage_arena) {
            display_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, display_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.display_info_ = display_info;
    // @@protoc_insertion_point(field_set_allocated:reporting.InfoData.display_info)
}

// -------------------------------------------------------------------

// AudioTelemetry

// optional bool output_mute = 1;
inline bool AudioTelemetry::_internal_has_output_mute() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool AudioTelemetry::has_output_mute() const
{
    return _internal_has_output_mute();
}
inline void AudioTelemetry::clear_output_mute()
{
    _impl_.output_mute_ = false;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool AudioTelemetry::_internal_output_mute() const
{
    return _impl_.output_mute_;
}
inline bool AudioTelemetry::output_mute() const
{
    // @@protoc_insertion_point(field_get:reporting.AudioTelemetry.output_mute)
    return _internal_output_mute();
}
inline void AudioTelemetry::_internal_set_output_mute(bool value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.output_mute_ = value;
}
inline void AudioTelemetry::set_output_mute(bool value)
{
    _internal_set_output_mute(value);
    // @@protoc_insertion_point(field_set:reporting.AudioTelemetry.output_mute)
}

// optional bool input_mute = 2;
inline bool AudioTelemetry::_internal_has_input_mute() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool AudioTelemetry::has_input_mute() const
{
    return _internal_has_input_mute();
}
inline void AudioTelemetry::clear_input_mute()
{
    _impl_.input_mute_ = false;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool AudioTelemetry::_internal_input_mute() const
{
    return _impl_.input_mute_;
}
inline bool AudioTelemetry::input_mute() const
{
    // @@protoc_insertion_point(field_get:reporting.AudioTelemetry.input_mute)
    return _internal_input_mute();
}
inline void AudioTelemetry::_internal_set_input_mute(bool value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.input_mute_ = value;
}
inline void AudioTelemetry::set_input_mute(bool value)
{
    _internal_set_input_mute(value);
    // @@protoc_insertion_point(field_set:reporting.AudioTelemetry.input_mute)
}

// optional int32 output_volume = 3;
inline bool AudioTelemetry::_internal_has_output_volume() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool AudioTelemetry::has_output_volume() const
{
    return _internal_has_output_volume();
}
inline void AudioTelemetry::clear_output_volume()
{
    _impl_.output_volume_ = 0;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t AudioTelemetry::_internal_output_volume() const
{
    return _impl_.output_volume_;
}
inline int32_t AudioTelemetry::output_volume() const
{
    // @@protoc_insertion_point(field_get:reporting.AudioTelemetry.output_volume)
    return _internal_output_volume();
}
inline void AudioTelemetry::_internal_set_output_volume(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.output_volume_ = value;
}
inline void AudioTelemetry::set_output_volume(int32_t value)
{
    _internal_set_output_volume(value);
    // @@protoc_insertion_point(field_set:reporting.AudioTelemetry.output_volume)
}

// optional string output_device_name = 4;
inline bool AudioTelemetry::_internal_has_output_device_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool AudioTelemetry::has_output_device_name() const
{
    return _internal_has_output_device_name();
}
inline void AudioTelemetry::clear_output_device_name()
{
    _impl_.output_device_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AudioTelemetry::output_device_name() const
{
    // @@protoc_insertion_point(field_get:reporting.AudioTelemetry.output_device_name)
    return _internal_output_device_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AudioTelemetry::set_output_device_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.output_device_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.AudioTelemetry.output_device_name)
}
inline std::string* AudioTelemetry::mutable_output_device_name()
{
    std::string* _s = _internal_mutable_output_device_name();
    // @@protoc_insertion_point(field_mutable:reporting.AudioTelemetry.output_device_name)
    return _s;
}
inline const std::string& AudioTelemetry::_internal_output_device_name() const
{
    return _impl_.output_device_name_.Get();
}
inline void AudioTelemetry::_internal_set_output_device_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.output_device_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioTelemetry::_internal_mutable_output_device_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.output_device_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioTelemetry::release_output_device_name()
{
    // @@protoc_insertion_point(field_release:reporting.AudioTelemetry.output_device_name)
    if (!_internal_has_output_device_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.output_device_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.output_device_name_.IsDefault()) {
        _impl_.output_device_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AudioTelemetry::set_allocated_output_device_name(std::string* output_device_name)
{
    if (output_device_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.output_device_name_.SetAllocated(output_device_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.output_device_name_.IsDefault()) {
        _impl_.output_device_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.AudioTelemetry.output_device_name)
}

// optional int32 input_gain = 5;
inline bool AudioTelemetry::_internal_has_input_gain() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool AudioTelemetry::has_input_gain() const
{
    return _internal_has_input_gain();
}
inline void AudioTelemetry::clear_input_gain()
{
    _impl_.input_gain_ = 0;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t AudioTelemetry::_internal_input_gain() const
{
    return _impl_.input_gain_;
}
inline int32_t AudioTelemetry::input_gain() const
{
    // @@protoc_insertion_point(field_get:reporting.AudioTelemetry.input_gain)
    return _internal_input_gain();
}
inline void AudioTelemetry::_internal_set_input_gain(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.input_gain_ = value;
}
inline void AudioTelemetry::set_input_gain(int32_t value)
{
    _internal_set_input_gain(value);
    // @@protoc_insertion_point(field_set:reporting.AudioTelemetry.input_gain)
}

// optional string input_device_name = 6;
inline bool AudioTelemetry::_internal_has_input_device_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool AudioTelemetry::has_input_device_name() const
{
    return _internal_has_input_device_name();
}
inline void AudioTelemetry::clear_input_device_name()
{
    _impl_.input_device_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AudioTelemetry::input_device_name() const
{
    // @@protoc_insertion_point(field_get:reporting.AudioTelemetry.input_device_name)
    return _internal_input_device_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AudioTelemetry::set_input_device_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.input_device_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.AudioTelemetry.input_device_name)
}
inline std::string* AudioTelemetry::mutable_input_device_name()
{
    std::string* _s = _internal_mutable_input_device_name();
    // @@protoc_insertion_point(field_mutable:reporting.AudioTelemetry.input_device_name)
    return _s;
}
inline const std::string& AudioTelemetry::_internal_input_device_name() const
{
    return _impl_.input_device_name_.Get();
}
inline void AudioTelemetry::_internal_set_input_device_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.input_device_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioTelemetry::_internal_mutable_input_device_name()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.input_device_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioTelemetry::release_input_device_name()
{
    // @@protoc_insertion_point(field_release:reporting.AudioTelemetry.input_device_name)
    if (!_internal_has_input_device_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.input_device_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.input_device_name_.IsDefault()) {
        _impl_.input_device_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AudioTelemetry::set_allocated_input_device_name(std::string* input_device_name)
{
    if (input_device_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.input_device_name_.SetAllocated(input_device_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.input_device_name_.IsDefault()) {
        _impl_.input_device_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.AudioTelemetry.input_device_name)
}

// -------------------------------------------------------------------

// BootPerformanceTelemetry

// optional int64 boot_up_seconds = 1;
inline bool BootPerformanceTelemetry::_internal_has_boot_up_seconds() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool BootPerformanceTelemetry::has_boot_up_seconds() const
{
    return _internal_has_boot_up_seconds();
}
inline void BootPerformanceTelemetry::clear_boot_up_seconds()
{
    _impl_.boot_up_seconds_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t BootPerformanceTelemetry::_internal_boot_up_seconds() const
{
    return _impl_.boot_up_seconds_;
}
inline int64_t BootPerformanceTelemetry::boot_up_seconds() const
{
    // @@protoc_insertion_point(field_get:reporting.BootPerformanceTelemetry.boot_up_seconds)
    return _internal_boot_up_seconds();
}
inline void BootPerformanceTelemetry::_internal_set_boot_up_seconds(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.boot_up_seconds_ = value;
}
inline void BootPerformanceTelemetry::set_boot_up_seconds(int64_t value)
{
    _internal_set_boot_up_seconds(value);
    // @@protoc_insertion_point(field_set:reporting.BootPerformanceTelemetry.boot_up_seconds)
}

// optional int64 boot_up_timestamp_seconds = 2;
inline bool BootPerformanceTelemetry::_internal_has_boot_up_timestamp_seconds() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool BootPerformanceTelemetry::has_boot_up_timestamp_seconds() const
{
    return _internal_has_boot_up_timestamp_seconds();
}
inline void BootPerformanceTelemetry::clear_boot_up_timestamp_seconds()
{
    _impl_.boot_up_timestamp_seconds_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t BootPerformanceTelemetry::_internal_boot_up_timestamp_seconds() const
{
    return _impl_.boot_up_timestamp_seconds_;
}
inline int64_t BootPerformanceTelemetry::boot_up_timestamp_seconds() const
{
    // @@protoc_insertion_point(field_get:reporting.BootPerformanceTelemetry.boot_up_timestamp_seconds)
    return _internal_boot_up_timestamp_seconds();
}
inline void BootPerformanceTelemetry::_internal_set_boot_up_timestamp_seconds(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.boot_up_timestamp_seconds_ = value;
}
inline void BootPerformanceTelemetry::set_boot_up_timestamp_seconds(int64_t value)
{
    _internal_set_boot_up_timestamp_seconds(value);
    // @@protoc_insertion_point(field_set:reporting.BootPerformanceTelemetry.boot_up_timestamp_seconds)
}

// optional int64 shutdown_seconds = 3;
inline bool BootPerformanceTelemetry::_internal_has_shutdown_seconds() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool BootPerformanceTelemetry::has_shutdown_seconds() const
{
    return _internal_has_shutdown_seconds();
}
inline void BootPerformanceTelemetry::clear_shutdown_seconds()
{
    _impl_.shutdown_seconds_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t BootPerformanceTelemetry::_internal_shutdown_seconds() const
{
    return _impl_.shutdown_seconds_;
}
inline int64_t BootPerformanceTelemetry::shutdown_seconds() const
{
    // @@protoc_insertion_point(field_get:reporting.BootPerformanceTelemetry.shutdown_seconds)
    return _internal_shutdown_seconds();
}
inline void BootPerformanceTelemetry::_internal_set_shutdown_seconds(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.shutdown_seconds_ = value;
}
inline void BootPerformanceTelemetry::set_shutdown_seconds(int64_t value)
{
    _internal_set_shutdown_seconds(value);
    // @@protoc_insertion_point(field_set:reporting.BootPerformanceTelemetry.shutdown_seconds)
}

// optional int64 shutdown_timestamp_seconds = 4;
inline bool BootPerformanceTelemetry::_internal_has_shutdown_timestamp_seconds() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool BootPerformanceTelemetry::has_shutdown_timestamp_seconds() const
{
    return _internal_has_shutdown_timestamp_seconds();
}
inline void BootPerformanceTelemetry::clear_shutdown_timestamp_seconds()
{
    _impl_.shutdown_timestamp_seconds_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t BootPerformanceTelemetry::_internal_shutdown_timestamp_seconds() const
{
    return _impl_.shutdown_timestamp_seconds_;
}
inline int64_t BootPerformanceTelemetry::shutdown_timestamp_seconds() const
{
    // @@protoc_insertion_point(field_get:reporting.BootPerformanceTelemetry.shutdown_timestamp_seconds)
    return _internal_shutdown_timestamp_seconds();
}
inline void BootPerformanceTelemetry::_internal_set_shutdown_timestamp_seconds(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.shutdown_timestamp_seconds_ = value;
}
inline void BootPerformanceTelemetry::set_shutdown_timestamp_seconds(int64_t value)
{
    _internal_set_shutdown_timestamp_seconds(value);
    // @@protoc_insertion_point(field_set:reporting.BootPerformanceTelemetry.shutdown_timestamp_seconds)
}

// optional string shutdown_reason = 5;
inline bool BootPerformanceTelemetry::_internal_has_shutdown_reason() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool BootPerformanceTelemetry::has_shutdown_reason() const
{
    return _internal_has_shutdown_reason();
}
inline void BootPerformanceTelemetry::clear_shutdown_reason()
{
    _impl_.shutdown_reason_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BootPerformanceTelemetry::shutdown_reason() const
{
    // @@protoc_insertion_point(field_get:reporting.BootPerformanceTelemetry.shutdown_reason)
    return _internal_shutdown_reason();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void BootPerformanceTelemetry::set_shutdown_reason(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.shutdown_reason_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.BootPerformanceTelemetry.shutdown_reason)
}
inline std::string* BootPerformanceTelemetry::mutable_shutdown_reason()
{
    std::string* _s = _internal_mutable_shutdown_reason();
    // @@protoc_insertion_point(field_mutable:reporting.BootPerformanceTelemetry.shutdown_reason)
    return _s;
}
inline const std::string& BootPerformanceTelemetry::_internal_shutdown_reason() const
{
    return _impl_.shutdown_reason_.Get();
}
inline void BootPerformanceTelemetry::_internal_set_shutdown_reason(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.shutdown_reason_.Set(value, GetArenaForAllocation());
}
inline std::string* BootPerformanceTelemetry::_internal_mutable_shutdown_reason()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.shutdown_reason_.Mutable(GetArenaForAllocation());
}
inline std::string* BootPerformanceTelemetry::release_shutdown_reason()
{
    // @@protoc_insertion_point(field_release:reporting.BootPerformanceTelemetry.shutdown_reason)
    if (!_internal_has_shutdown_reason()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.shutdown_reason_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.shutdown_reason_.IsDefault()) {
        _impl_.shutdown_reason_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void BootPerformanceTelemetry::set_allocated_shutdown_reason(std::string* shutdown_reason)
{
    if (shutdown_reason != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.shutdown_reason_.SetAllocated(shutdown_reason, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.shutdown_reason_.IsDefault()) {
        _impl_.shutdown_reason_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.BootPerformanceTelemetry.shutdown_reason)
}

// -------------------------------------------------------------------

// UserStatusTelemetry

// optional .reporting.UserStatusTelemetry.DeviceActivityState device_activity_state = 1;
inline bool UserStatusTelemetry::_internal_has_device_activity_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool UserStatusTelemetry::has_device_activity_state() const
{
    return _internal_has_device_activity_state();
}
inline void UserStatusTelemetry::clear_device_activity_state()
{
    _impl_.device_activity_state_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::reporting::UserStatusTelemetry_DeviceActivityState UserStatusTelemetry::_internal_device_activity_state() const
{
    return static_cast<::reporting::UserStatusTelemetry_DeviceActivityState>(_impl_.device_activity_state_);
}
inline ::reporting::UserStatusTelemetry_DeviceActivityState UserStatusTelemetry::device_activity_state() const
{
    // @@protoc_insertion_point(field_get:reporting.UserStatusTelemetry.device_activity_state)
    return _internal_device_activity_state();
}
inline void UserStatusTelemetry::_internal_set_device_activity_state(::reporting::UserStatusTelemetry_DeviceActivityState value)
{
    assert(::reporting::UserStatusTelemetry_DeviceActivityState_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.device_activity_state_ = value;
}
inline void UserStatusTelemetry::set_device_activity_state(::reporting::UserStatusTelemetry_DeviceActivityState value)
{
    _internal_set_device_activity_state(value);
    // @@protoc_insertion_point(field_set:reporting.UserStatusTelemetry.device_activity_state)
}

// -------------------------------------------------------------------

// DisplaysTelemetry

// repeated .reporting.DisplayStatus display_status = 1;
inline int DisplaysTelemetry::_internal_display_status_size() const
{
    return _impl_.display_status_.size();
}
inline int DisplaysTelemetry::display_status_size() const
{
    return _internal_display_status_size();
}
inline void DisplaysTelemetry::clear_display_status()
{
    _impl_.display_status_.Clear();
}
inline ::reporting::DisplayStatus* DisplaysTelemetry::mutable_display_status(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.DisplaysTelemetry.display_status)
    return _impl_.display_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::DisplayStatus>* DisplaysTelemetry::mutable_display_status()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.DisplaysTelemetry.display_status)
    return &_impl_.display_status_;
}
inline const ::reporting::DisplayStatus& DisplaysTelemetry::_internal_display_status(int index) const
{
    return _impl_.display_status_.Get(index);
}
inline const ::reporting::DisplayStatus& DisplaysTelemetry::display_status(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.DisplaysTelemetry.display_status)
    return _internal_display_status(index);
}
inline ::reporting::DisplayStatus* DisplaysTelemetry::_internal_add_display_status()
{
    return _impl_.display_status_.Add();
}
inline ::reporting::DisplayStatus* DisplaysTelemetry::add_display_status()
{
    ::reporting::DisplayStatus* _add = _internal_add_display_status();
    // @@protoc_insertion_point(field_add:reporting.DisplaysTelemetry.display_status)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::DisplayStatus>& DisplaysTelemetry::display_status() const
{
    // @@protoc_insertion_point(field_list:reporting.DisplaysTelemetry.display_status)
    return _impl_.display_status_;
}

// -------------------------------------------------------------------

// DisplayStatus

// optional string display_name = 1;
inline bool DisplayStatus::_internal_has_display_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool DisplayStatus::has_display_name() const
{
    return _internal_has_display_name();
}
inline void DisplayStatus::clear_display_name()
{
    _impl_.display_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DisplayStatus::display_name() const
{
    // @@protoc_insertion_point(field_get:reporting.DisplayStatus.display_name)
    return _internal_display_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DisplayStatus::set_display_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.display_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.DisplayStatus.display_name)
}
inline std::string* DisplayStatus::mutable_display_name()
{
    std::string* _s = _internal_mutable_display_name();
    // @@protoc_insertion_point(field_mutable:reporting.DisplayStatus.display_name)
    return _s;
}
inline const std::string& DisplayStatus::_internal_display_name() const
{
    return _impl_.display_name_.Get();
}
inline void DisplayStatus::_internal_set_display_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DisplayStatus::_internal_mutable_display_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DisplayStatus::release_display_name()
{
    // @@protoc_insertion_point(field_release:reporting.DisplayStatus.display_name)
    if (!_internal_has_display_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.display_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.display_name_.IsDefault()) {
        _impl_.display_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DisplayStatus::set_allocated_display_name(std::string* display_name)
{
    if (display_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.display_name_.IsDefault()) {
        _impl_.display_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.DisplayStatus.display_name)
}

// optional int32 resolution_horizontal = 2;
inline bool DisplayStatus::_internal_has_resolution_horizontal() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool DisplayStatus::has_resolution_horizontal() const
{
    return _internal_has_resolution_horizontal();
}
inline void DisplayStatus::clear_resolution_horizontal()
{
    _impl_.resolution_horizontal_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t DisplayStatus::_internal_resolution_horizontal() const
{
    return _impl_.resolution_horizontal_;
}
inline int32_t DisplayStatus::resolution_horizontal() const
{
    // @@protoc_insertion_point(field_get:reporting.DisplayStatus.resolution_horizontal)
    return _internal_resolution_horizontal();
}
inline void DisplayStatus::_internal_set_resolution_horizontal(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.resolution_horizontal_ = value;
}
inline void DisplayStatus::set_resolution_horizontal(int32_t value)
{
    _internal_set_resolution_horizontal(value);
    // @@protoc_insertion_point(field_set:reporting.DisplayStatus.resolution_horizontal)
}

// optional int32 resolution_vertical = 3;
inline bool DisplayStatus::_internal_has_resolution_vertical() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool DisplayStatus::has_resolution_vertical() const
{
    return _internal_has_resolution_vertical();
}
inline void DisplayStatus::clear_resolution_vertical()
{
    _impl_.resolution_vertical_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t DisplayStatus::_internal_resolution_vertical() const
{
    return _impl_.resolution_vertical_;
}
inline int32_t DisplayStatus::resolution_vertical() const
{
    // @@protoc_insertion_point(field_get:reporting.DisplayStatus.resolution_vertical)
    return _internal_resolution_vertical();
}
inline void DisplayStatus::_internal_set_resolution_vertical(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.resolution_vertical_ = value;
}
inline void DisplayStatus::set_resolution_vertical(int32_t value)
{
    _internal_set_resolution_vertical(value);
    // @@protoc_insertion_point(field_set:reporting.DisplayStatus.resolution_vertical)
}

// optional int64 refresh_rate = 4;
inline bool DisplayStatus::_internal_has_refresh_rate() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool DisplayStatus::has_refresh_rate() const
{
    return _internal_has_refresh_rate();
}
inline void DisplayStatus::clear_refresh_rate()
{
    _impl_.refresh_rate_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t DisplayStatus::_internal_refresh_rate() const
{
    return _impl_.refresh_rate_;
}
inline int64_t DisplayStatus::refresh_rate() const
{
    // @@protoc_insertion_point(field_get:reporting.DisplayStatus.refresh_rate)
    return _internal_refresh_rate();
}
inline void DisplayStatus::_internal_set_refresh_rate(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.refresh_rate_ = value;
}
inline void DisplayStatus::set_refresh_rate(int64_t value)
{
    _internal_set_refresh_rate(value);
    // @@protoc_insertion_point(field_set:reporting.DisplayStatus.refresh_rate)
}

// optional bool is_internal = 5;
inline bool DisplayStatus::_internal_has_is_internal() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool DisplayStatus::has_is_internal() const
{
    return _internal_has_is_internal();
}
inline void DisplayStatus::clear_is_internal()
{
    _impl_.is_internal_ = false;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool DisplayStatus::_internal_is_internal() const
{
    return _impl_.is_internal_;
}
inline bool DisplayStatus::is_internal() const
{
    // @@protoc_insertion_point(field_get:reporting.DisplayStatus.is_internal)
    return _internal_is_internal();
}
inline void DisplayStatus::_internal_set_is_internal(bool value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.is_internal_ = value;
}
inline void DisplayStatus::set_is_internal(bool value)
{
    _internal_set_is_internal(value);
    // @@protoc_insertion_point(field_set:reporting.DisplayStatus.is_internal)
}

// -------------------------------------------------------------------

// KioskHeartbeatTelemetry

// -------------------------------------------------------------------

// KioskVisionView

// optional int64 start_time_sec = 1;
inline bool KioskVisionView::_internal_has_start_time_sec() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool KioskVisionView::has_start_time_sec() const
{
    return _internal_has_start_time_sec();
}
inline void KioskVisionView::clear_start_time_sec()
{
    _impl_.start_time_sec_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t KioskVisionView::_internal_start_time_sec() const
{
    return _impl_.start_time_sec_;
}
inline int64_t KioskVisionView::start_time_sec() const
{
    // @@protoc_insertion_point(field_get:reporting.KioskVisionView.start_time_sec)
    return _internal_start_time_sec();
}
inline void KioskVisionView::_internal_set_start_time_sec(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.start_time_sec_ = value;
}
inline void KioskVisionView::set_start_time_sec(int64_t value)
{
    _internal_set_start_time_sec(value);
    // @@protoc_insertion_point(field_set:reporting.KioskVisionView.start_time_sec)
}

// optional int64 end_time_sec = 2;
inline bool KioskVisionView::_internal_has_end_time_sec() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool KioskVisionView::has_end_time_sec() const
{
    return _internal_has_end_time_sec();
}
inline void KioskVisionView::clear_end_time_sec()
{
    _impl_.end_time_sec_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t KioskVisionView::_internal_end_time_sec() const
{
    return _impl_.end_time_sec_;
}
inline int64_t KioskVisionView::end_time_sec() const
{
    // @@protoc_insertion_point(field_get:reporting.KioskVisionView.end_time_sec)
    return _internal_end_time_sec();
}
inline void KioskVisionView::_internal_set_end_time_sec(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.end_time_sec_ = value;
}
inline void KioskVisionView::set_end_time_sec(int64_t value)
{
    _internal_set_end_time_sec(value);
    // @@protoc_insertion_point(field_set:reporting.KioskVisionView.end_time_sec)
}

// -------------------------------------------------------------------

// KioskVisionAudience

// optional int64 presence_start_date_sec = 1;
inline bool KioskVisionAudience::_internal_has_presence_start_date_sec() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool KioskVisionAudience::has_presence_start_date_sec() const
{
    return _internal_has_presence_start_date_sec();
}
inline void KioskVisionAudience::clear_presence_start_date_sec()
{
    _impl_.presence_start_date_sec_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t KioskVisionAudience::_internal_presence_start_date_sec() const
{
    return _impl_.presence_start_date_sec_;
}
inline int64_t KioskVisionAudience::presence_start_date_sec() const
{
    // @@protoc_insertion_point(field_get:reporting.KioskVisionAudience.presence_start_date_sec)
    return _internal_presence_start_date_sec();
}
inline void KioskVisionAudience::_internal_set_presence_start_date_sec(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.presence_start_date_sec_ = value;
}
inline void KioskVisionAudience::set_presence_start_date_sec(int64_t value)
{
    _internal_set_presence_start_date_sec(value);
    // @@protoc_insertion_point(field_set:reporting.KioskVisionAudience.presence_start_date_sec)
}

// optional int64 presence_end_date_sec = 2;
inline bool KioskVisionAudience::_internal_has_presence_end_date_sec() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool KioskVisionAudience::has_presence_end_date_sec() const
{
    return _internal_has_presence_end_date_sec();
}
inline void KioskVisionAudience::clear_presence_end_date_sec()
{
    _impl_.presence_end_date_sec_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t KioskVisionAudience::_internal_presence_end_date_sec() const
{
    return _impl_.presence_end_date_sec_;
}
inline int64_t KioskVisionAudience::presence_end_date_sec() const
{
    // @@protoc_insertion_point(field_get:reporting.KioskVisionAudience.presence_end_date_sec)
    return _internal_presence_end_date_sec();
}
inline void KioskVisionAudience::_internal_set_presence_end_date_sec(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.presence_end_date_sec_ = value;
}
inline void KioskVisionAudience::set_presence_end_date_sec(int64_t value)
{
    _internal_set_presence_end_date_sec(value);
    // @@protoc_insertion_point(field_set:reporting.KioskVisionAudience.presence_end_date_sec)
}

// repeated .reporting.KioskVisionView views = 3;
inline int KioskVisionAudience::_internal_views_size() const
{
    return _impl_.views_.size();
}
inline int KioskVisionAudience::views_size() const
{
    return _internal_views_size();
}
inline void KioskVisionAudience::clear_views()
{
    _impl_.views_.Clear();
}
inline ::reporting::KioskVisionView* KioskVisionAudience::mutable_views(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.KioskVisionAudience.views)
    return _impl_.views_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::KioskVisionView>* KioskVisionAudience::mutable_views()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.KioskVisionAudience.views)
    return &_impl_.views_;
}
inline const ::reporting::KioskVisionView& KioskVisionAudience::_internal_views(int index) const
{
    return _impl_.views_.Get(index);
}
inline const ::reporting::KioskVisionView& KioskVisionAudience::views(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.KioskVisionAudience.views)
    return _internal_views(index);
}
inline ::reporting::KioskVisionView* KioskVisionAudience::_internal_add_views()
{
    return _impl_.views_.Add();
}
inline ::reporting::KioskVisionView* KioskVisionAudience::add_views()
{
    ::reporting::KioskVisionView* _add = _internal_add_views();
    // @@protoc_insertion_point(field_add:reporting.KioskVisionAudience.views)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::KioskVisionView>& KioskVisionAudience::views() const
{
    // @@protoc_insertion_point(field_list:reporting.KioskVisionAudience.views)
    return _impl_.views_;
}

// -------------------------------------------------------------------

// KioskVisionTelemetry

// optional int64 start_date_sec = 1;
inline bool KioskVisionTelemetry::_internal_has_start_date_sec() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool KioskVisionTelemetry::has_start_date_sec() const
{
    return _internal_has_start_date_sec();
}
inline void KioskVisionTelemetry::clear_start_date_sec()
{
    _impl_.start_date_sec_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t KioskVisionTelemetry::_internal_start_date_sec() const
{
    return _impl_.start_date_sec_;
}
inline int64_t KioskVisionTelemetry::start_date_sec() const
{
    // @@protoc_insertion_point(field_get:reporting.KioskVisionTelemetry.start_date_sec)
    return _internal_start_date_sec();
}
inline void KioskVisionTelemetry::_internal_set_start_date_sec(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.start_date_sec_ = value;
}
inline void KioskVisionTelemetry::set_start_date_sec(int64_t value)
{
    _internal_set_start_date_sec(value);
    // @@protoc_insertion_point(field_set:reporting.KioskVisionTelemetry.start_date_sec)
}

// optional int64 end_date_sec = 2;
inline bool KioskVisionTelemetry::_internal_has_end_date_sec() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool KioskVisionTelemetry::has_end_date_sec() const
{
    return _internal_has_end_date_sec();
}
inline void KioskVisionTelemetry::clear_end_date_sec()
{
    _impl_.end_date_sec_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t KioskVisionTelemetry::_internal_end_date_sec() const
{
    return _impl_.end_date_sec_;
}
inline int64_t KioskVisionTelemetry::end_date_sec() const
{
    // @@protoc_insertion_point(field_get:reporting.KioskVisionTelemetry.end_date_sec)
    return _internal_end_date_sec();
}
inline void KioskVisionTelemetry::_internal_set_end_date_sec(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.end_date_sec_ = value;
}
inline void KioskVisionTelemetry::set_end_date_sec(int64_t value)
{
    _internal_set_end_date_sec(value);
    // @@protoc_insertion_point(field_set:reporting.KioskVisionTelemetry.end_date_sec)
}

// optional int32 view_count = 3;
inline bool KioskVisionTelemetry::_internal_has_view_count() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool KioskVisionTelemetry::has_view_count() const
{
    return _internal_has_view_count();
}
inline void KioskVisionTelemetry::clear_view_count()
{
    _impl_.view_count_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t KioskVisionTelemetry::_internal_view_count() const
{
    return _impl_.view_count_;
}
inline int32_t KioskVisionTelemetry::view_count() const
{
    // @@protoc_insertion_point(field_get:reporting.KioskVisionTelemetry.view_count)
    return _internal_view_count();
}
inline void KioskVisionTelemetry::_internal_set_view_count(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.view_count_ = value;
}
inline void KioskVisionTelemetry::set_view_count(int32_t value)
{
    _internal_set_view_count(value);
    // @@protoc_insertion_point(field_set:reporting.KioskVisionTelemetry.view_count)
}

// optional int32 pass_count = 4;
inline bool KioskVisionTelemetry::_internal_has_pass_count() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool KioskVisionTelemetry::has_pass_count() const
{
    return _internal_has_pass_count();
}
inline void KioskVisionTelemetry::clear_pass_count()
{
    _impl_.pass_count_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t KioskVisionTelemetry::_internal_pass_count() const
{
    return _impl_.pass_count_;
}
inline int32_t KioskVisionTelemetry::pass_count() const
{
    // @@protoc_insertion_point(field_get:reporting.KioskVisionTelemetry.pass_count)
    return _internal_pass_count();
}
inline void KioskVisionTelemetry::_internal_set_pass_count(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.pass_count_ = value;
}
inline void KioskVisionTelemetry::set_pass_count(int32_t value)
{
    _internal_set_pass_count(value);
    // @@protoc_insertion_point(field_set:reporting.KioskVisionTelemetry.pass_count)
}

// repeated .reporting.KioskVisionAudience audience = 5;
inline int KioskVisionTelemetry::_internal_audience_size() const
{
    return _impl_.audience_.size();
}
inline int KioskVisionTelemetry::audience_size() const
{
    return _internal_audience_size();
}
inline void KioskVisionTelemetry::clear_audience()
{
    _impl_.audience_.Clear();
}
inline ::reporting::KioskVisionAudience* KioskVisionTelemetry::mutable_audience(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.KioskVisionTelemetry.audience)
    return _impl_.audience_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::KioskVisionAudience>* KioskVisionTelemetry::mutable_audience()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.KioskVisionTelemetry.audience)
    return &_impl_.audience_;
}
inline const ::reporting::KioskVisionAudience& KioskVisionTelemetry::_internal_audience(int index) const
{
    return _impl_.audience_.Get(index);
}
inline const ::reporting::KioskVisionAudience& KioskVisionTelemetry::audience(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.KioskVisionTelemetry.audience)
    return _internal_audience(index);
}
inline ::reporting::KioskVisionAudience* KioskVisionTelemetry::_internal_add_audience()
{
    return _impl_.audience_.Add();
}
inline ::reporting::KioskVisionAudience* KioskVisionTelemetry::add_audience()
{
    ::reporting::KioskVisionAudience* _add = _internal_add_audience();
    // @@protoc_insertion_point(field_add:reporting.KioskVisionTelemetry.audience)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::KioskVisionAudience>& KioskVisionTelemetry::audience() const
{
    // @@protoc_insertion_point(field_list:reporting.KioskVisionTelemetry.audience)
    return _impl_.audience_;
}

// -------------------------------------------------------------------

// KioskVisionStatusReport

// optional .reporting.KioskVisionStatusReport.KioskVisionState state = 1;
inline bool KioskVisionStatusReport::_internal_has_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool KioskVisionStatusReport::has_state() const
{
    return _internal_has_state();
}
inline void KioskVisionStatusReport::clear_state()
{
    _impl_.state_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::reporting::KioskVisionStatusReport_KioskVisionState KioskVisionStatusReport::_internal_state() const
{
    return static_cast<::reporting::KioskVisionStatusReport_KioskVisionState>(_impl_.state_);
}
inline ::reporting::KioskVisionStatusReport_KioskVisionState KioskVisionStatusReport::state() const
{
    // @@protoc_insertion_point(field_get:reporting.KioskVisionStatusReport.state)
    return _internal_state();
}
inline void KioskVisionStatusReport::_internal_set_state(::reporting::KioskVisionStatusReport_KioskVisionState value)
{
    assert(::reporting::KioskVisionStatusReport_KioskVisionState_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.state_ = value;
}
inline void KioskVisionStatusReport::set_state(::reporting::KioskVisionStatusReport_KioskVisionState value)
{
    _internal_set_state(value);
    // @@protoc_insertion_point(field_set:reporting.KioskVisionStatusReport.state)
}

// optional int64 time_stamp_sec = 2;
inline bool KioskVisionStatusReport::_internal_has_time_stamp_sec() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool KioskVisionStatusReport::has_time_stamp_sec() const
{
    return _internal_has_time_stamp_sec();
}
inline void KioskVisionStatusReport::clear_time_stamp_sec()
{
    _impl_.time_stamp_sec_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t KioskVisionStatusReport::_internal_time_stamp_sec() const
{
    return _impl_.time_stamp_sec_;
}
inline int64_t KioskVisionStatusReport::time_stamp_sec() const
{
    // @@protoc_insertion_point(field_get:reporting.KioskVisionStatusReport.time_stamp_sec)
    return _internal_time_stamp_sec();
}
inline void KioskVisionStatusReport::_internal_set_time_stamp_sec(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.time_stamp_sec_ = value;
}
inline void KioskVisionStatusReport::set_time_stamp_sec(int64_t value)
{
    _internal_set_time_stamp_sec(value);
    // @@protoc_insertion_point(field_set:reporting.KioskVisionStatusReport.time_stamp_sec)
}

// optional int64 state_change_time_stamp_sec = 3;
inline bool KioskVisionStatusReport::_internal_has_state_change_time_stamp_sec() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool KioskVisionStatusReport::has_state_change_time_stamp_sec() const
{
    return _internal_has_state_change_time_stamp_sec();
}
inline void KioskVisionStatusReport::clear_state_change_time_stamp_sec()
{
    _impl_.state_change_time_stamp_sec_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t KioskVisionStatusReport::_internal_state_change_time_stamp_sec() const
{
    return _impl_.state_change_time_stamp_sec_;
}
inline int64_t KioskVisionStatusReport::state_change_time_stamp_sec() const
{
    // @@protoc_insertion_point(field_get:reporting.KioskVisionStatusReport.state_change_time_stamp_sec)
    return _internal_state_change_time_stamp_sec();
}
inline void KioskVisionStatusReport::_internal_set_state_change_time_stamp_sec(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.state_change_time_stamp_sec_ = value;
}
inline void KioskVisionStatusReport::set_state_change_time_stamp_sec(int64_t value)
{
    _internal_set_state_change_time_stamp_sec(value);
    // @@protoc_insertion_point(field_set:reporting.KioskVisionStatusReport.state_change_time_stamp_sec)
}

// -------------------------------------------------------------------

// TelemetryData

// optional bool is_event_driven = 8;
inline bool TelemetryData::_internal_has_is_event_driven() const
{
    bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
    return value;
}
inline bool TelemetryData::has_is_event_driven() const
{
    return _internal_has_is_event_driven();
}
inline void TelemetryData::clear_is_event_driven()
{
    _impl_.is_event_driven_ = false;
    _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool TelemetryData::_internal_is_event_driven() const
{
    return _impl_.is_event_driven_;
}
inline bool TelemetryData::is_event_driven() const
{
    // @@protoc_insertion_point(field_get:reporting.TelemetryData.is_event_driven)
    return _internal_is_event_driven();
}
inline void TelemetryData::_internal_set_is_event_driven(bool value)
{
    _impl_._has_bits_[0] |= 0x00002000u;
    _impl_.is_event_driven_ = value;
}
inline void TelemetryData::set_is_event_driven(bool value)
{
    _internal_set_is_event_driven(value);
    // @@protoc_insertion_point(field_set:reporting.TelemetryData.is_event_driven)
}

// optional .reporting.NetworksTelemetry networks_telemetry = 1;
inline bool TelemetryData::_internal_has_networks_telemetry() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.networks_telemetry_ != nullptr);
    return value;
}
inline bool TelemetryData::has_networks_telemetry() const
{
    return _internal_has_networks_telemetry();
}
inline void TelemetryData::clear_networks_telemetry()
{
    if (_impl_.networks_telemetry_ != nullptr)
        _impl_.networks_telemetry_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::reporting::NetworksTelemetry& TelemetryData::_internal_networks_telemetry() const
{
    const ::reporting::NetworksTelemetry* p = _impl_.networks_telemetry_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::NetworksTelemetry&>(::reporting::_NetworksTelemetry_default_instance_);
}
inline const ::reporting::NetworksTelemetry& TelemetryData::networks_telemetry() const
{
    // @@protoc_insertion_point(field_get:reporting.TelemetryData.networks_telemetry)
    return _internal_networks_telemetry();
}
inline void TelemetryData::unsafe_arena_set_allocated_networks_telemetry(::reporting::NetworksTelemetry* networks_telemetry)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.networks_telemetry_);
    }
    _impl_.networks_telemetry_ = networks_telemetry;
    if (networks_telemetry) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.TelemetryData.networks_telemetry)
}
inline ::reporting::NetworksTelemetry* TelemetryData::release_networks_telemetry()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::NetworksTelemetry* temp = _impl_.networks_telemetry_;
    _impl_.networks_telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::NetworksTelemetry* TelemetryData::unsafe_arena_release_networks_telemetry()
{
    // @@protoc_insertion_point(field_release:reporting.TelemetryData.networks_telemetry)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::NetworksTelemetry* temp = _impl_.networks_telemetry_;
    _impl_.networks_telemetry_ = nullptr;
    return temp;
}
inline ::reporting::NetworksTelemetry* TelemetryData::_internal_mutable_networks_telemetry()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.networks_telemetry_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::NetworksTelemetry>(GetArenaForAllocation());
        _impl_.networks_telemetry_ = p;
    }
    return _impl_.networks_telemetry_;
}
inline ::reporting::NetworksTelemetry* TelemetryData::mutable_networks_telemetry()
{
    ::reporting::NetworksTelemetry* _msg = _internal_mutable_networks_telemetry();
    // @@protoc_insertion_point(field_mutable:reporting.TelemetryData.networks_telemetry)
    return _msg;
}
inline void TelemetryData::set_allocated_networks_telemetry(::reporting::NetworksTelemetry* networks_telemetry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.networks_telemetry_;
    }
    if (networks_telemetry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(networks_telemetry);
        if (message_arena != submessage_arena) {
            networks_telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, networks_telemetry, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.networks_telemetry_ = networks_telemetry;
    // @@protoc_insertion_point(field_set_allocated:reporting.TelemetryData.networks_telemetry)
}

// optional .reporting.AudioTelemetry audio_telemetry = 2;
inline bool TelemetryData::_internal_has_audio_telemetry() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.audio_telemetry_ != nullptr);
    return value;
}
inline bool TelemetryData::has_audio_telemetry() const
{
    return _internal_has_audio_telemetry();
}
inline void TelemetryData::clear_audio_telemetry()
{
    if (_impl_.audio_telemetry_ != nullptr)
        _impl_.audio_telemetry_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::reporting::AudioTelemetry& TelemetryData::_internal_audio_telemetry() const
{
    const ::reporting::AudioTelemetry* p = _impl_.audio_telemetry_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::AudioTelemetry&>(::reporting::_AudioTelemetry_default_instance_);
}
inline const ::reporting::AudioTelemetry& TelemetryData::audio_telemetry() const
{
    // @@protoc_insertion_point(field_get:reporting.TelemetryData.audio_telemetry)
    return _internal_audio_telemetry();
}
inline void TelemetryData::unsafe_arena_set_allocated_audio_telemetry(::reporting::AudioTelemetry* audio_telemetry)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.audio_telemetry_);
    }
    _impl_.audio_telemetry_ = audio_telemetry;
    if (audio_telemetry) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.TelemetryData.audio_telemetry)
}
inline ::reporting::AudioTelemetry* TelemetryData::release_audio_telemetry()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::reporting::AudioTelemetry* temp = _impl_.audio_telemetry_;
    _impl_.audio_telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::AudioTelemetry* TelemetryData::unsafe_arena_release_audio_telemetry()
{
    // @@protoc_insertion_point(field_release:reporting.TelemetryData.audio_telemetry)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::reporting::AudioTelemetry* temp = _impl_.audio_telemetry_;
    _impl_.audio_telemetry_ = nullptr;
    return temp;
}
inline ::reporting::AudioTelemetry* TelemetryData::_internal_mutable_audio_telemetry()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.audio_telemetry_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::AudioTelemetry>(GetArenaForAllocation());
        _impl_.audio_telemetry_ = p;
    }
    return _impl_.audio_telemetry_;
}
inline ::reporting::AudioTelemetry* TelemetryData::mutable_audio_telemetry()
{
    ::reporting::AudioTelemetry* _msg = _internal_mutable_audio_telemetry();
    // @@protoc_insertion_point(field_mutable:reporting.TelemetryData.audio_telemetry)
    return _msg;
}
inline void TelemetryData::set_allocated_audio_telemetry(::reporting::AudioTelemetry* audio_telemetry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.audio_telemetry_;
    }
    if (audio_telemetry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_telemetry);
        if (message_arena != submessage_arena) {
            audio_telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, audio_telemetry, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.audio_telemetry_ = audio_telemetry;
    // @@protoc_insertion_point(field_set_allocated:reporting.TelemetryData.audio_telemetry)
}

// optional .reporting.PeripheralsTelemetry peripherals_telemetry = 3;
inline bool TelemetryData::_internal_has_peripherals_telemetry() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.peripherals_telemetry_ != nullptr);
    return value;
}
inline bool TelemetryData::has_peripherals_telemetry() const
{
    return _internal_has_peripherals_telemetry();
}
inline void TelemetryData::clear_peripherals_telemetry()
{
    if (_impl_.peripherals_telemetry_ != nullptr)
        _impl_.peripherals_telemetry_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::reporting::PeripheralsTelemetry& TelemetryData::_internal_peripherals_telemetry() const
{
    const ::reporting::PeripheralsTelemetry* p = _impl_.peripherals_telemetry_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::PeripheralsTelemetry&>(::reporting::_PeripheralsTelemetry_default_instance_);
}
inline const ::reporting::PeripheralsTelemetry& TelemetryData::peripherals_telemetry() const
{
    // @@protoc_insertion_point(field_get:reporting.TelemetryData.peripherals_telemetry)
    return _internal_peripherals_telemetry();
}
inline void TelemetryData::unsafe_arena_set_allocated_peripherals_telemetry(::reporting::PeripheralsTelemetry* peripherals_telemetry)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.peripherals_telemetry_);
    }
    _impl_.peripherals_telemetry_ = peripherals_telemetry;
    if (peripherals_telemetry) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.TelemetryData.peripherals_telemetry)
}
inline ::reporting::PeripheralsTelemetry* TelemetryData::release_peripherals_telemetry()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::reporting::PeripheralsTelemetry* temp = _impl_.peripherals_telemetry_;
    _impl_.peripherals_telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::PeripheralsTelemetry* TelemetryData::unsafe_arena_release_peripherals_telemetry()
{
    // @@protoc_insertion_point(field_release:reporting.TelemetryData.peripherals_telemetry)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::reporting::PeripheralsTelemetry* temp = _impl_.peripherals_telemetry_;
    _impl_.peripherals_telemetry_ = nullptr;
    return temp;
}
inline ::reporting::PeripheralsTelemetry* TelemetryData::_internal_mutable_peripherals_telemetry()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.peripherals_telemetry_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::PeripheralsTelemetry>(GetArenaForAllocation());
        _impl_.peripherals_telemetry_ = p;
    }
    return _impl_.peripherals_telemetry_;
}
inline ::reporting::PeripheralsTelemetry* TelemetryData::mutable_peripherals_telemetry()
{
    ::reporting::PeripheralsTelemetry* _msg = _internal_mutable_peripherals_telemetry();
    // @@protoc_insertion_point(field_mutable:reporting.TelemetryData.peripherals_telemetry)
    return _msg;
}
inline void TelemetryData::set_allocated_peripherals_telemetry(::reporting::PeripheralsTelemetry* peripherals_telemetry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.peripherals_telemetry_;
    }
    if (peripherals_telemetry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(peripherals_telemetry);
        if (message_arena != submessage_arena) {
            peripherals_telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, peripherals_telemetry, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.peripherals_telemetry_ = peripherals_telemetry;
    // @@protoc_insertion_point(field_set_allocated:reporting.TelemetryData.peripherals_telemetry)
}

// optional .reporting.BootPerformanceTelemetry boot_performance_telemetry = 4;
inline bool TelemetryData::_internal_has_boot_performance_telemetry() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.boot_performance_telemetry_ != nullptr);
    return value;
}
inline bool TelemetryData::has_boot_performance_telemetry() const
{
    return _internal_has_boot_performance_telemetry();
}
inline void TelemetryData::clear_boot_performance_telemetry()
{
    if (_impl_.boot_performance_telemetry_ != nullptr)
        _impl_.boot_performance_telemetry_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::reporting::BootPerformanceTelemetry& TelemetryData::_internal_boot_performance_telemetry() const
{
    const ::reporting::BootPerformanceTelemetry* p = _impl_.boot_performance_telemetry_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::BootPerformanceTelemetry&>(::reporting::_BootPerformanceTelemetry_default_instance_);
}
inline const ::reporting::BootPerformanceTelemetry& TelemetryData::boot_performance_telemetry() const
{
    // @@protoc_insertion_point(field_get:reporting.TelemetryData.boot_performance_telemetry)
    return _internal_boot_performance_telemetry();
}
inline void TelemetryData::unsafe_arena_set_allocated_boot_performance_telemetry(::reporting::BootPerformanceTelemetry* boot_performance_telemetry)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.boot_performance_telemetry_);
    }
    _impl_.boot_performance_telemetry_ = boot_performance_telemetry;
    if (boot_performance_telemetry) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.TelemetryData.boot_performance_telemetry)
}
inline ::reporting::BootPerformanceTelemetry* TelemetryData::release_boot_performance_telemetry()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::reporting::BootPerformanceTelemetry* temp = _impl_.boot_performance_telemetry_;
    _impl_.boot_performance_telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::BootPerformanceTelemetry* TelemetryData::unsafe_arena_release_boot_performance_telemetry()
{
    // @@protoc_insertion_point(field_release:reporting.TelemetryData.boot_performance_telemetry)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::reporting::BootPerformanceTelemetry* temp = _impl_.boot_performance_telemetry_;
    _impl_.boot_performance_telemetry_ = nullptr;
    return temp;
}
inline ::reporting::BootPerformanceTelemetry* TelemetryData::_internal_mutable_boot_performance_telemetry()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.boot_performance_telemetry_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::BootPerformanceTelemetry>(GetArenaForAllocation());
        _impl_.boot_performance_telemetry_ = p;
    }
    return _impl_.boot_performance_telemetry_;
}
inline ::reporting::BootPerformanceTelemetry* TelemetryData::mutable_boot_performance_telemetry()
{
    ::reporting::BootPerformanceTelemetry* _msg = _internal_mutable_boot_performance_telemetry();
    // @@protoc_insertion_point(field_mutable:reporting.TelemetryData.boot_performance_telemetry)
    return _msg;
}
inline void TelemetryData::set_allocated_boot_performance_telemetry(::reporting::BootPerformanceTelemetry* boot_performance_telemetry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.boot_performance_telemetry_;
    }
    if (boot_performance_telemetry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(boot_performance_telemetry);
        if (message_arena != submessage_arena) {
            boot_performance_telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, boot_performance_telemetry, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.boot_performance_telemetry_ = boot_performance_telemetry;
    // @@protoc_insertion_point(field_set_allocated:reporting.TelemetryData.boot_performance_telemetry)
}

// optional .reporting.UserStatusTelemetry user_status_telemetry = 5;
inline bool TelemetryData::_internal_has_user_status_telemetry() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.user_status_telemetry_ != nullptr);
    return value;
}
inline bool TelemetryData::has_user_status_telemetry() const
{
    return _internal_has_user_status_telemetry();
}
inline void TelemetryData::clear_user_status_telemetry()
{
    if (_impl_.user_status_telemetry_ != nullptr)
        _impl_.user_status_telemetry_->Clear();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::reporting::UserStatusTelemetry& TelemetryData::_internal_user_status_telemetry() const
{
    const ::reporting::UserStatusTelemetry* p = _impl_.user_status_telemetry_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::UserStatusTelemetry&>(::reporting::_UserStatusTelemetry_default_instance_);
}
inline const ::reporting::UserStatusTelemetry& TelemetryData::user_status_telemetry() const
{
    // @@protoc_insertion_point(field_get:reporting.TelemetryData.user_status_telemetry)
    return _internal_user_status_telemetry();
}
inline void TelemetryData::unsafe_arena_set_allocated_user_status_telemetry(::reporting::UserStatusTelemetry* user_status_telemetry)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_status_telemetry_);
    }
    _impl_.user_status_telemetry_ = user_status_telemetry;
    if (user_status_telemetry) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.TelemetryData.user_status_telemetry)
}
inline ::reporting::UserStatusTelemetry* TelemetryData::release_user_status_telemetry()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::reporting::UserStatusTelemetry* temp = _impl_.user_status_telemetry_;
    _impl_.user_status_telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::UserStatusTelemetry* TelemetryData::unsafe_arena_release_user_status_telemetry()
{
    // @@protoc_insertion_point(field_release:reporting.TelemetryData.user_status_telemetry)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::reporting::UserStatusTelemetry* temp = _impl_.user_status_telemetry_;
    _impl_.user_status_telemetry_ = nullptr;
    return temp;
}
inline ::reporting::UserStatusTelemetry* TelemetryData::_internal_mutable_user_status_telemetry()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.user_status_telemetry_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::UserStatusTelemetry>(GetArenaForAllocation());
        _impl_.user_status_telemetry_ = p;
    }
    return _impl_.user_status_telemetry_;
}
inline ::reporting::UserStatusTelemetry* TelemetryData::mutable_user_status_telemetry()
{
    ::reporting::UserStatusTelemetry* _msg = _internal_mutable_user_status_telemetry();
    // @@protoc_insertion_point(field_mutable:reporting.TelemetryData.user_status_telemetry)
    return _msg;
}
inline void TelemetryData::set_allocated_user_status_telemetry(::reporting::UserStatusTelemetry* user_status_telemetry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.user_status_telemetry_;
    }
    if (user_status_telemetry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_status_telemetry);
        if (message_arena != submessage_arena) {
            user_status_telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, user_status_telemetry, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.user_status_telemetry_ = user_status_telemetry;
    // @@protoc_insertion_point(field_set_allocated:reporting.TelemetryData.user_status_telemetry)
}

// optional .reporting.DisplaysTelemetry displays_telemetry = 6;
inline bool TelemetryData::_internal_has_displays_telemetry() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.displays_telemetry_ != nullptr);
    return value;
}
inline bool TelemetryData::has_displays_telemetry() const
{
    return _internal_has_displays_telemetry();
}
inline void TelemetryData::clear_displays_telemetry()
{
    if (_impl_.displays_telemetry_ != nullptr)
        _impl_.displays_telemetry_->Clear();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::reporting::DisplaysTelemetry& TelemetryData::_internal_displays_telemetry() const
{
    const ::reporting::DisplaysTelemetry* p = _impl_.displays_telemetry_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::DisplaysTelemetry&>(::reporting::_DisplaysTelemetry_default_instance_);
}
inline const ::reporting::DisplaysTelemetry& TelemetryData::displays_telemetry() const
{
    // @@protoc_insertion_point(field_get:reporting.TelemetryData.displays_telemetry)
    return _internal_displays_telemetry();
}
inline void TelemetryData::unsafe_arena_set_allocated_displays_telemetry(::reporting::DisplaysTelemetry* displays_telemetry)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.displays_telemetry_);
    }
    _impl_.displays_telemetry_ = displays_telemetry;
    if (displays_telemetry) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.TelemetryData.displays_telemetry)
}
inline ::reporting::DisplaysTelemetry* TelemetryData::release_displays_telemetry()
{
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::reporting::DisplaysTelemetry* temp = _impl_.displays_telemetry_;
    _impl_.displays_telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::DisplaysTelemetry* TelemetryData::unsafe_arena_release_displays_telemetry()
{
    // @@protoc_insertion_point(field_release:reporting.TelemetryData.displays_telemetry)
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::reporting::DisplaysTelemetry* temp = _impl_.displays_telemetry_;
    _impl_.displays_telemetry_ = nullptr;
    return temp;
}
inline ::reporting::DisplaysTelemetry* TelemetryData::_internal_mutable_displays_telemetry()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    if (_impl_.displays_telemetry_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::DisplaysTelemetry>(GetArenaForAllocation());
        _impl_.displays_telemetry_ = p;
    }
    return _impl_.displays_telemetry_;
}
inline ::reporting::DisplaysTelemetry* TelemetryData::mutable_displays_telemetry()
{
    ::reporting::DisplaysTelemetry* _msg = _internal_mutable_displays_telemetry();
    // @@protoc_insertion_point(field_mutable:reporting.TelemetryData.displays_telemetry)
    return _msg;
}
inline void TelemetryData::set_allocated_displays_telemetry(::reporting::DisplaysTelemetry* displays_telemetry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.displays_telemetry_;
    }
    if (displays_telemetry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(displays_telemetry);
        if (message_arena != submessage_arena) {
            displays_telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, displays_telemetry, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.displays_telemetry_ = displays_telemetry;
    // @@protoc_insertion_point(field_set_allocated:reporting.TelemetryData.displays_telemetry)
}

// optional .reporting.AppTelemetry app_telemetry = 7;
inline bool TelemetryData::_internal_has_app_telemetry() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.app_telemetry_ != nullptr);
    return value;
}
inline bool TelemetryData::has_app_telemetry() const
{
    return _internal_has_app_telemetry();
}
inline void TelemetryData::clear_app_telemetry()
{
    if (_impl_.app_telemetry_ != nullptr)
        _impl_.app_telemetry_->Clear();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::reporting::AppTelemetry& TelemetryData::_internal_app_telemetry() const
{
    const ::reporting::AppTelemetry* p = _impl_.app_telemetry_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::AppTelemetry&>(::reporting::_AppTelemetry_default_instance_);
}
inline const ::reporting::AppTelemetry& TelemetryData::app_telemetry() const
{
    // @@protoc_insertion_point(field_get:reporting.TelemetryData.app_telemetry)
    return _internal_app_telemetry();
}
inline void TelemetryData::unsafe_arena_set_allocated_app_telemetry(::reporting::AppTelemetry* app_telemetry)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.app_telemetry_);
    }
    _impl_.app_telemetry_ = app_telemetry;
    if (app_telemetry) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.TelemetryData.app_telemetry)
}
inline ::reporting::AppTelemetry* TelemetryData::release_app_telemetry()
{
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::reporting::AppTelemetry* temp = _impl_.app_telemetry_;
    _impl_.app_telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::AppTelemetry* TelemetryData::unsafe_arena_release_app_telemetry()
{
    // @@protoc_insertion_point(field_release:reporting.TelemetryData.app_telemetry)
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::reporting::AppTelemetry* temp = _impl_.app_telemetry_;
    _impl_.app_telemetry_ = nullptr;
    return temp;
}
inline ::reporting::AppTelemetry* TelemetryData::_internal_mutable_app_telemetry()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    if (_impl_.app_telemetry_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::AppTelemetry>(GetArenaForAllocation());
        _impl_.app_telemetry_ = p;
    }
    return _impl_.app_telemetry_;
}
inline ::reporting::AppTelemetry* TelemetryData::mutable_app_telemetry()
{
    ::reporting::AppTelemetry* _msg = _internal_mutable_app_telemetry();
    // @@protoc_insertion_point(field_mutable:reporting.TelemetryData.app_telemetry)
    return _msg;
}
inline void TelemetryData::set_allocated_app_telemetry(::reporting::AppTelemetry* app_telemetry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.app_telemetry_;
    }
    if (app_telemetry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(app_telemetry);
        if (message_arena != submessage_arena) {
            app_telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, app_telemetry, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.app_telemetry_ = app_telemetry;
    // @@protoc_insertion_point(field_set_allocated:reporting.TelemetryData.app_telemetry)
}

// optional .reporting.FatalCrashTelemetry fatal_crash_telemetry = 9;
inline bool TelemetryData::_internal_has_fatal_crash_telemetry() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.fatal_crash_telemetry_ != nullptr);
    return value;
}
inline bool TelemetryData::has_fatal_crash_telemetry() const
{
    return _internal_has_fatal_crash_telemetry();
}
inline void TelemetryData::clear_fatal_crash_telemetry()
{
    if (_impl_.fatal_crash_telemetry_ != nullptr)
        _impl_.fatal_crash_telemetry_->Clear();
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::reporting::FatalCrashTelemetry& TelemetryData::_internal_fatal_crash_telemetry() const
{
    const ::reporting::FatalCrashTelemetry* p = _impl_.fatal_crash_telemetry_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::FatalCrashTelemetry&>(::reporting::_FatalCrashTelemetry_default_instance_);
}
inline const ::reporting::FatalCrashTelemetry& TelemetryData::fatal_crash_telemetry() const
{
    // @@protoc_insertion_point(field_get:reporting.TelemetryData.fatal_crash_telemetry)
    return _internal_fatal_crash_telemetry();
}
inline void TelemetryData::unsafe_arena_set_allocated_fatal_crash_telemetry(::reporting::FatalCrashTelemetry* fatal_crash_telemetry)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fatal_crash_telemetry_);
    }
    _impl_.fatal_crash_telemetry_ = fatal_crash_telemetry;
    if (fatal_crash_telemetry) {
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.TelemetryData.fatal_crash_telemetry)
}
inline ::reporting::FatalCrashTelemetry* TelemetryData::release_fatal_crash_telemetry()
{
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::reporting::FatalCrashTelemetry* temp = _impl_.fatal_crash_telemetry_;
    _impl_.fatal_crash_telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::FatalCrashTelemetry* TelemetryData::unsafe_arena_release_fatal_crash_telemetry()
{
    // @@protoc_insertion_point(field_release:reporting.TelemetryData.fatal_crash_telemetry)
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::reporting::FatalCrashTelemetry* temp = _impl_.fatal_crash_telemetry_;
    _impl_.fatal_crash_telemetry_ = nullptr;
    return temp;
}
inline ::reporting::FatalCrashTelemetry* TelemetryData::_internal_mutable_fatal_crash_telemetry()
{
    _impl_._has_bits_[0] |= 0x00000080u;
    if (_impl_.fatal_crash_telemetry_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::FatalCrashTelemetry>(GetArenaForAllocation());
        _impl_.fatal_crash_telemetry_ = p;
    }
    return _impl_.fatal_crash_telemetry_;
}
inline ::reporting::FatalCrashTelemetry* TelemetryData::mutable_fatal_crash_telemetry()
{
    ::reporting::FatalCrashTelemetry* _msg = _internal_mutable_fatal_crash_telemetry();
    // @@protoc_insertion_point(field_mutable:reporting.TelemetryData.fatal_crash_telemetry)
    return _msg;
}
inline void TelemetryData::set_allocated_fatal_crash_telemetry(::reporting::FatalCrashTelemetry* fatal_crash_telemetry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.fatal_crash_telemetry_;
    }
    if (fatal_crash_telemetry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fatal_crash_telemetry);
        if (message_arena != submessage_arena) {
            fatal_crash_telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, fatal_crash_telemetry, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    _impl_.fatal_crash_telemetry_ = fatal_crash_telemetry;
    // @@protoc_insertion_point(field_set_allocated:reporting.TelemetryData.fatal_crash_telemetry)
}

// optional .reporting.RuntimeCountersTelemetry runtime_counters_telemetry = 10;
inline bool TelemetryData::_internal_has_runtime_counters_telemetry() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.runtime_counters_telemetry_ != nullptr);
    return value;
}
inline bool TelemetryData::has_runtime_counters_telemetry() const
{
    return _internal_has_runtime_counters_telemetry();
}
inline void TelemetryData::clear_runtime_counters_telemetry()
{
    if (_impl_.runtime_counters_telemetry_ != nullptr)
        _impl_.runtime_counters_telemetry_->Clear();
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::reporting::RuntimeCountersTelemetry& TelemetryData::_internal_runtime_counters_telemetry() const
{
    const ::reporting::RuntimeCountersTelemetry* p = _impl_.runtime_counters_telemetry_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::RuntimeCountersTelemetry&>(::reporting::_RuntimeCountersTelemetry_default_instance_);
}
inline const ::reporting::RuntimeCountersTelemetry& TelemetryData::runtime_counters_telemetry() const
{
    // @@protoc_insertion_point(field_get:reporting.TelemetryData.runtime_counters_telemetry)
    return _internal_runtime_counters_telemetry();
}
inline void TelemetryData::unsafe_arena_set_allocated_runtime_counters_telemetry(::reporting::RuntimeCountersTelemetry* runtime_counters_telemetry)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.runtime_counters_telemetry_);
    }
    _impl_.runtime_counters_telemetry_ = runtime_counters_telemetry;
    if (runtime_counters_telemetry) {
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.TelemetryData.runtime_counters_telemetry)
}
inline ::reporting::RuntimeCountersTelemetry* TelemetryData::release_runtime_counters_telemetry()
{
    _impl_._has_bits_[0] &= ~0x00000100u;
    ::reporting::RuntimeCountersTelemetry* temp = _impl_.runtime_counters_telemetry_;
    _impl_.runtime_counters_telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::RuntimeCountersTelemetry* TelemetryData::unsafe_arena_release_runtime_counters_telemetry()
{
    // @@protoc_insertion_point(field_release:reporting.TelemetryData.runtime_counters_telemetry)
    _impl_._has_bits_[0] &= ~0x00000100u;
    ::reporting::RuntimeCountersTelemetry* temp = _impl_.runtime_counters_telemetry_;
    _impl_.runtime_counters_telemetry_ = nullptr;
    return temp;
}
inline ::reporting::RuntimeCountersTelemetry* TelemetryData::_internal_mutable_runtime_counters_telemetry()
{
    _impl_._has_bits_[0] |= 0x00000100u;
    if (_impl_.runtime_counters_telemetry_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::RuntimeCountersTelemetry>(GetArenaForAllocation());
        _impl_.runtime_counters_telemetry_ = p;
    }
    return _impl_.runtime_counters_telemetry_;
}
inline ::reporting::RuntimeCountersTelemetry* TelemetryData::mutable_runtime_counters_telemetry()
{
    ::reporting::RuntimeCountersTelemetry* _msg = _internal_mutable_runtime_counters_telemetry();
    // @@protoc_insertion_point(field_mutable:reporting.TelemetryData.runtime_counters_telemetry)
    return _msg;
}
inline void TelemetryData::set_allocated_runtime_counters_telemetry(::reporting::RuntimeCountersTelemetry* runtime_counters_telemetry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.runtime_counters_telemetry_;
    }
    if (runtime_counters_telemetry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(runtime_counters_telemetry);
        if (message_arena != submessage_arena) {
            runtime_counters_telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, runtime_counters_telemetry, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    _impl_.runtime_counters_telemetry_ = runtime_counters_telemetry;
    // @@protoc_insertion_point(field_set_allocated:reporting.TelemetryData.runtime_counters_telemetry)
}

// optional .reporting.WebsiteTelemetry website_telemetry = 11;
inline bool TelemetryData::_internal_has_website_telemetry() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.website_telemetry_ != nullptr);
    return value;
}
inline bool TelemetryData::has_website_telemetry() const
{
    return _internal_has_website_telemetry();
}
inline void TelemetryData::clear_website_telemetry()
{
    if (_impl_.website_telemetry_ != nullptr)
        _impl_.website_telemetry_->Clear();
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::reporting::WebsiteTelemetry& TelemetryData::_internal_website_telemetry() const
{
    const ::reporting::WebsiteTelemetry* p = _impl_.website_telemetry_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::WebsiteTelemetry&>(::reporting::_WebsiteTelemetry_default_instance_);
}
inline const ::reporting::WebsiteTelemetry& TelemetryData::website_telemetry() const
{
    // @@protoc_insertion_point(field_get:reporting.TelemetryData.website_telemetry)
    return _internal_website_telemetry();
}
inline void TelemetryData::unsafe_arena_set_allocated_website_telemetry(::reporting::WebsiteTelemetry* website_telemetry)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.website_telemetry_);
    }
    _impl_.website_telemetry_ = website_telemetry;
    if (website_telemetry) {
        _impl_._has_bits_[0] |= 0x00000200u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000200u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.TelemetryData.website_telemetry)
}
inline ::reporting::WebsiteTelemetry* TelemetryData::release_website_telemetry()
{
    _impl_._has_bits_[0] &= ~0x00000200u;
    ::reporting::WebsiteTelemetry* temp = _impl_.website_telemetry_;
    _impl_.website_telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::WebsiteTelemetry* TelemetryData::unsafe_arena_release_website_telemetry()
{
    // @@protoc_insertion_point(field_release:reporting.TelemetryData.website_telemetry)
    _impl_._has_bits_[0] &= ~0x00000200u;
    ::reporting::WebsiteTelemetry* temp = _impl_.website_telemetry_;
    _impl_.website_telemetry_ = nullptr;
    return temp;
}
inline ::reporting::WebsiteTelemetry* TelemetryData::_internal_mutable_website_telemetry()
{
    _impl_._has_bits_[0] |= 0x00000200u;
    if (_impl_.website_telemetry_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::WebsiteTelemetry>(GetArenaForAllocation());
        _impl_.website_telemetry_ = p;
    }
    return _impl_.website_telemetry_;
}
inline ::reporting::WebsiteTelemetry* TelemetryData::mutable_website_telemetry()
{
    ::reporting::WebsiteTelemetry* _msg = _internal_mutable_website_telemetry();
    // @@protoc_insertion_point(field_mutable:reporting.TelemetryData.website_telemetry)
    return _msg;
}
inline void TelemetryData::set_allocated_website_telemetry(::reporting::WebsiteTelemetry* website_telemetry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.website_telemetry_;
    }
    if (website_telemetry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(website_telemetry);
        if (message_arena != submessage_arena) {
            website_telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, website_telemetry, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000200u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000200u;
    }
    _impl_.website_telemetry_ = website_telemetry;
    // @@protoc_insertion_point(field_set_allocated:reporting.TelemetryData.website_telemetry)
}

// optional .reporting.KioskHeartbeatTelemetry heartbeat_telemetry = 12;
inline bool TelemetryData::_internal_has_heartbeat_telemetry() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.heartbeat_telemetry_ != nullptr);
    return value;
}
inline bool TelemetryData::has_heartbeat_telemetry() const
{
    return _internal_has_heartbeat_telemetry();
}
inline void TelemetryData::clear_heartbeat_telemetry()
{
    if (_impl_.heartbeat_telemetry_ != nullptr)
        _impl_.heartbeat_telemetry_->Clear();
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::reporting::KioskHeartbeatTelemetry& TelemetryData::_internal_heartbeat_telemetry() const
{
    const ::reporting::KioskHeartbeatTelemetry* p = _impl_.heartbeat_telemetry_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::KioskHeartbeatTelemetry&>(::reporting::_KioskHeartbeatTelemetry_default_instance_);
}
inline const ::reporting::KioskHeartbeatTelemetry& TelemetryData::heartbeat_telemetry() const
{
    // @@protoc_insertion_point(field_get:reporting.TelemetryData.heartbeat_telemetry)
    return _internal_heartbeat_telemetry();
}
inline void TelemetryData::unsafe_arena_set_allocated_heartbeat_telemetry(::reporting::KioskHeartbeatTelemetry* heartbeat_telemetry)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.heartbeat_telemetry_);
    }
    _impl_.heartbeat_telemetry_ = heartbeat_telemetry;
    if (heartbeat_telemetry) {
        _impl_._has_bits_[0] |= 0x00000400u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000400u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.TelemetryData.heartbeat_telemetry)
}
inline ::reporting::KioskHeartbeatTelemetry* TelemetryData::release_heartbeat_telemetry()
{
    _impl_._has_bits_[0] &= ~0x00000400u;
    ::reporting::KioskHeartbeatTelemetry* temp = _impl_.heartbeat_telemetry_;
    _impl_.heartbeat_telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::KioskHeartbeatTelemetry* TelemetryData::unsafe_arena_release_heartbeat_telemetry()
{
    // @@protoc_insertion_point(field_release:reporting.TelemetryData.heartbeat_telemetry)
    _impl_._has_bits_[0] &= ~0x00000400u;
    ::reporting::KioskHeartbeatTelemetry* temp = _impl_.heartbeat_telemetry_;
    _impl_.heartbeat_telemetry_ = nullptr;
    return temp;
}
inline ::reporting::KioskHeartbeatTelemetry* TelemetryData::_internal_mutable_heartbeat_telemetry()
{
    _impl_._has_bits_[0] |= 0x00000400u;
    if (_impl_.heartbeat_telemetry_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::KioskHeartbeatTelemetry>(GetArenaForAllocation());
        _impl_.heartbeat_telemetry_ = p;
    }
    return _impl_.heartbeat_telemetry_;
}
inline ::reporting::KioskHeartbeatTelemetry* TelemetryData::mutable_heartbeat_telemetry()
{
    ::reporting::KioskHeartbeatTelemetry* _msg = _internal_mutable_heartbeat_telemetry();
    // @@protoc_insertion_point(field_mutable:reporting.TelemetryData.heartbeat_telemetry)
    return _msg;
}
inline void TelemetryData::set_allocated_heartbeat_telemetry(::reporting::KioskHeartbeatTelemetry* heartbeat_telemetry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.heartbeat_telemetry_;
    }
    if (heartbeat_telemetry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heartbeat_telemetry);
        if (message_arena != submessage_arena) {
            heartbeat_telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, heartbeat_telemetry, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000400u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000400u;
    }
    _impl_.heartbeat_telemetry_ = heartbeat_telemetry;
    // @@protoc_insertion_point(field_set_allocated:reporting.TelemetryData.heartbeat_telemetry)
}

// optional .reporting.KioskVisionTelemetry kiosk_vision_telemetry = 13;
inline bool TelemetryData::_internal_has_kiosk_vision_telemetry() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.kiosk_vision_telemetry_ != nullptr);
    return value;
}
inline bool TelemetryData::has_kiosk_vision_telemetry() const
{
    return _internal_has_kiosk_vision_telemetry();
}
inline void TelemetryData::clear_kiosk_vision_telemetry()
{
    if (_impl_.kiosk_vision_telemetry_ != nullptr)
        _impl_.kiosk_vision_telemetry_->Clear();
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::reporting::KioskVisionTelemetry& TelemetryData::_internal_kiosk_vision_telemetry() const
{
    const ::reporting::KioskVisionTelemetry* p = _impl_.kiosk_vision_telemetry_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::KioskVisionTelemetry&>(::reporting::_KioskVisionTelemetry_default_instance_);
}
inline const ::reporting::KioskVisionTelemetry& TelemetryData::kiosk_vision_telemetry() const
{
    // @@protoc_insertion_point(field_get:reporting.TelemetryData.kiosk_vision_telemetry)
    return _internal_kiosk_vision_telemetry();
}
inline void TelemetryData::unsafe_arena_set_allocated_kiosk_vision_telemetry(::reporting::KioskVisionTelemetry* kiosk_vision_telemetry)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.kiosk_vision_telemetry_);
    }
    _impl_.kiosk_vision_telemetry_ = kiosk_vision_telemetry;
    if (kiosk_vision_telemetry) {
        _impl_._has_bits_[0] |= 0x00000800u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000800u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.TelemetryData.kiosk_vision_telemetry)
}
inline ::reporting::KioskVisionTelemetry* TelemetryData::release_kiosk_vision_telemetry()
{
    _impl_._has_bits_[0] &= ~0x00000800u;
    ::reporting::KioskVisionTelemetry* temp = _impl_.kiosk_vision_telemetry_;
    _impl_.kiosk_vision_telemetry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::KioskVisionTelemetry* TelemetryData::unsafe_arena_release_kiosk_vision_telemetry()
{
    // @@protoc_insertion_point(field_release:reporting.TelemetryData.kiosk_vision_telemetry)
    _impl_._has_bits_[0] &= ~0x00000800u;
    ::reporting::KioskVisionTelemetry* temp = _impl_.kiosk_vision_telemetry_;
    _impl_.kiosk_vision_telemetry_ = nullptr;
    return temp;
}
inline ::reporting::KioskVisionTelemetry* TelemetryData::_internal_mutable_kiosk_vision_telemetry()
{
    _impl_._has_bits_[0] |= 0x00000800u;
    if (_impl_.kiosk_vision_telemetry_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::KioskVisionTelemetry>(GetArenaForAllocation());
        _impl_.kiosk_vision_telemetry_ = p;
    }
    return _impl_.kiosk_vision_telemetry_;
}
inline ::reporting::KioskVisionTelemetry* TelemetryData::mutable_kiosk_vision_telemetry()
{
    ::reporting::KioskVisionTelemetry* _msg = _internal_mutable_kiosk_vision_telemetry();
    // @@protoc_insertion_point(field_mutable:reporting.TelemetryData.kiosk_vision_telemetry)
    return _msg;
}
inline void TelemetryData::set_allocated_kiosk_vision_telemetry(::reporting::KioskVisionTelemetry* kiosk_vision_telemetry)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.kiosk_vision_telemetry_;
    }
    if (kiosk_vision_telemetry) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(kiosk_vision_telemetry);
        if (message_arena != submessage_arena) {
            kiosk_vision_telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, kiosk_vision_telemetry, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000800u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000800u;
    }
    _impl_.kiosk_vision_telemetry_ = kiosk_vision_telemetry;
    // @@protoc_insertion_point(field_set_allocated:reporting.TelemetryData.kiosk_vision_telemetry)
}

// optional .reporting.KioskVisionStatusReport kiosk_vision_status = 14;
inline bool TelemetryData::_internal_has_kiosk_vision_status() const
{
    bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.kiosk_vision_status_ != nullptr);
    return value;
}
inline bool TelemetryData::has_kiosk_vision_status() const
{
    return _internal_has_kiosk_vision_status();
}
inline void TelemetryData::clear_kiosk_vision_status()
{
    if (_impl_.kiosk_vision_status_ != nullptr)
        _impl_.kiosk_vision_status_->Clear();
    _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::reporting::KioskVisionStatusReport& TelemetryData::_internal_kiosk_vision_status() const
{
    const ::reporting::KioskVisionStatusReport* p = _impl_.kiosk_vision_status_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::KioskVisionStatusReport&>(::reporting::_KioskVisionStatusReport_default_instance_);
}
inline const ::reporting::KioskVisionStatusReport& TelemetryData::kiosk_vision_status() const
{
    // @@protoc_insertion_point(field_get:reporting.TelemetryData.kiosk_vision_status)
    return _internal_kiosk_vision_status();
}
inline void TelemetryData::unsafe_arena_set_allocated_kiosk_vision_status(::reporting::KioskVisionStatusReport* kiosk_vision_status)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.kiosk_vision_status_);
    }
    _impl_.kiosk_vision_status_ = kiosk_vision_status;
    if (kiosk_vision_status) {
        _impl_._has_bits_[0] |= 0x00001000u;
    } else {
        _impl_._has_bits_[0] &= ~0x00001000u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.TelemetryData.kiosk_vision_status)
}
inline ::reporting::KioskVisionStatusReport* TelemetryData::release_kiosk_vision_status()
{
    _impl_._has_bits_[0] &= ~0x00001000u;
    ::reporting::KioskVisionStatusReport* temp = _impl_.kiosk_vision_status_;
    _impl_.kiosk_vision_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::KioskVisionStatusReport* TelemetryData::unsafe_arena_release_kiosk_vision_status()
{
    // @@protoc_insertion_point(field_release:reporting.TelemetryData.kiosk_vision_status)
    _impl_._has_bits_[0] &= ~0x00001000u;
    ::reporting::KioskVisionStatusReport* temp = _impl_.kiosk_vision_status_;
    _impl_.kiosk_vision_status_ = nullptr;
    return temp;
}
inline ::reporting::KioskVisionStatusReport* TelemetryData::_internal_mutable_kiosk_vision_status()
{
    _impl_._has_bits_[0] |= 0x00001000u;
    if (_impl_.kiosk_vision_status_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::KioskVisionStatusReport>(GetArenaForAllocation());
        _impl_.kiosk_vision_status_ = p;
    }
    return _impl_.kiosk_vision_status_;
}
inline ::reporting::KioskVisionStatusReport* TelemetryData::mutable_kiosk_vision_status()
{
    ::reporting::KioskVisionStatusReport* _msg = _internal_mutable_kiosk_vision_status();
    // @@protoc_insertion_point(field_mutable:reporting.TelemetryData.kiosk_vision_status)
    return _msg;
}
inline void TelemetryData::set_allocated_kiosk_vision_status(::reporting::KioskVisionStatusReport* kiosk_vision_status)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.kiosk_vision_status_;
    }
    if (kiosk_vision_status) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(kiosk_vision_status);
        if (message_arena != submessage_arena) {
            kiosk_vision_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, kiosk_vision_status, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00001000u;
    } else {
        _impl_._has_bits_[0] &= ~0x00001000u;
    }
    _impl_.kiosk_vision_status_ = kiosk_vision_status;
    // @@protoc_insertion_point(field_set_allocated:reporting.TelemetryData.kiosk_vision_status)
}

// -------------------------------------------------------------------

// AppTelemetry

// .reporting.AppInstallData app_install_data = 3;
inline bool AppTelemetry::_internal_has_app_install_data() const
{
    return app_metric_data_case() == kAppInstallData;
}
inline bool AppTelemetry::has_app_install_data() const
{
    return _internal_has_app_install_data();
}
inline void AppTelemetry::set_has_app_install_data()
{
    _impl_._oneof_case_[0] = kAppInstallData;
}
inline void AppTelemetry::clear_app_install_data()
{
    if (_internal_has_app_install_data()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.app_metric_data_.app_install_data_;
        }
        clear_has_app_metric_data();
    }
}
inline ::reporting::AppInstallData* AppTelemetry::release_app_install_data()
{
    // @@protoc_insertion_point(field_release:reporting.AppTelemetry.app_install_data)
    if (_internal_has_app_install_data()) {
        clear_has_app_metric_data();
        ::reporting::AppInstallData* temp = _impl_.app_metric_data_.app_install_data_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.app_metric_data_.app_install_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::AppInstallData& AppTelemetry::_internal_app_install_data() const
{
    return _internal_has_app_install_data() ? *_impl_.app_metric_data_.app_install_data_
                                            : reinterpret_cast<::reporting::AppInstallData&>(::reporting::_AppInstallData_default_instance_);
}
inline const ::reporting::AppInstallData& AppTelemetry::app_install_data() const
{
    // @@protoc_insertion_point(field_get:reporting.AppTelemetry.app_install_data)
    return _internal_app_install_data();
}
inline ::reporting::AppInstallData* AppTelemetry::unsafe_arena_release_app_install_data()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.AppTelemetry.app_install_data)
    if (_internal_has_app_install_data()) {
        clear_has_app_metric_data();
        ::reporting::AppInstallData* temp = _impl_.app_metric_data_.app_install_data_;
        _impl_.app_metric_data_.app_install_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void AppTelemetry::unsafe_arena_set_allocated_app_install_data(::reporting::AppInstallData* app_install_data)
{
    clear_app_metric_data();
    if (app_install_data) {
        set_has_app_install_data();
        _impl_.app_metric_data_.app_install_data_ = app_install_data;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.AppTelemetry.app_install_data)
}
inline ::reporting::AppInstallData* AppTelemetry::_internal_mutable_app_install_data()
{
    if (!_internal_has_app_install_data()) {
        clear_app_metric_data();
        set_has_app_install_data();
        _impl_.app_metric_data_.app_install_data_ = CreateMaybeMessage<::reporting::AppInstallData>(GetArenaForAllocation());
    }
    return _impl_.app_metric_data_.app_install_data_;
}
inline ::reporting::AppInstallData* AppTelemetry::mutable_app_install_data()
{
    ::reporting::AppInstallData* _msg = _internal_mutable_app_install_data();
    // @@protoc_insertion_point(field_mutable:reporting.AppTelemetry.app_install_data)
    return _msg;
}

// .reporting.AppUninstallData app_uninstall_data = 4;
inline bool AppTelemetry::_internal_has_app_uninstall_data() const
{
    return app_metric_data_case() == kAppUninstallData;
}
inline bool AppTelemetry::has_app_uninstall_data() const
{
    return _internal_has_app_uninstall_data();
}
inline void AppTelemetry::set_has_app_uninstall_data()
{
    _impl_._oneof_case_[0] = kAppUninstallData;
}
inline void AppTelemetry::clear_app_uninstall_data()
{
    if (_internal_has_app_uninstall_data()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.app_metric_data_.app_uninstall_data_;
        }
        clear_has_app_metric_data();
    }
}
inline ::reporting::AppUninstallData* AppTelemetry::release_app_uninstall_data()
{
    // @@protoc_insertion_point(field_release:reporting.AppTelemetry.app_uninstall_data)
    if (_internal_has_app_uninstall_data()) {
        clear_has_app_metric_data();
        ::reporting::AppUninstallData* temp = _impl_.app_metric_data_.app_uninstall_data_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.app_metric_data_.app_uninstall_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::AppUninstallData& AppTelemetry::_internal_app_uninstall_data() const
{
    return _internal_has_app_uninstall_data() ? *_impl_.app_metric_data_.app_uninstall_data_
                                              : reinterpret_cast<::reporting::AppUninstallData&>(::reporting::_AppUninstallData_default_instance_);
}
inline const ::reporting::AppUninstallData& AppTelemetry::app_uninstall_data() const
{
    // @@protoc_insertion_point(field_get:reporting.AppTelemetry.app_uninstall_data)
    return _internal_app_uninstall_data();
}
inline ::reporting::AppUninstallData* AppTelemetry::unsafe_arena_release_app_uninstall_data()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.AppTelemetry.app_uninstall_data)
    if (_internal_has_app_uninstall_data()) {
        clear_has_app_metric_data();
        ::reporting::AppUninstallData* temp = _impl_.app_metric_data_.app_uninstall_data_;
        _impl_.app_metric_data_.app_uninstall_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void AppTelemetry::unsafe_arena_set_allocated_app_uninstall_data(::reporting::AppUninstallData* app_uninstall_data)
{
    clear_app_metric_data();
    if (app_uninstall_data) {
        set_has_app_uninstall_data();
        _impl_.app_metric_data_.app_uninstall_data_ = app_uninstall_data;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.AppTelemetry.app_uninstall_data)
}
inline ::reporting::AppUninstallData* AppTelemetry::_internal_mutable_app_uninstall_data()
{
    if (!_internal_has_app_uninstall_data()) {
        clear_app_metric_data();
        set_has_app_uninstall_data();
        _impl_.app_metric_data_.app_uninstall_data_ = CreateMaybeMessage<::reporting::AppUninstallData>(GetArenaForAllocation());
    }
    return _impl_.app_metric_data_.app_uninstall_data_;
}
inline ::reporting::AppUninstallData* AppTelemetry::mutable_app_uninstall_data()
{
    ::reporting::AppUninstallData* _msg = _internal_mutable_app_uninstall_data();
    // @@protoc_insertion_point(field_mutable:reporting.AppTelemetry.app_uninstall_data)
    return _msg;
}

// .reporting.AppLaunchData app_launch_data = 5;
inline bool AppTelemetry::_internal_has_app_launch_data() const
{
    return app_metric_data_case() == kAppLaunchData;
}
inline bool AppTelemetry::has_app_launch_data() const
{
    return _internal_has_app_launch_data();
}
inline void AppTelemetry::set_has_app_launch_data()
{
    _impl_._oneof_case_[0] = kAppLaunchData;
}
inline void AppTelemetry::clear_app_launch_data()
{
    if (_internal_has_app_launch_data()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.app_metric_data_.app_launch_data_;
        }
        clear_has_app_metric_data();
    }
}
inline ::reporting::AppLaunchData* AppTelemetry::release_app_launch_data()
{
    // @@protoc_insertion_point(field_release:reporting.AppTelemetry.app_launch_data)
    if (_internal_has_app_launch_data()) {
        clear_has_app_metric_data();
        ::reporting::AppLaunchData* temp = _impl_.app_metric_data_.app_launch_data_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.app_metric_data_.app_launch_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::AppLaunchData& AppTelemetry::_internal_app_launch_data() const
{
    return _internal_has_app_launch_data() ? *_impl_.app_metric_data_.app_launch_data_
                                           : reinterpret_cast<::reporting::AppLaunchData&>(::reporting::_AppLaunchData_default_instance_);
}
inline const ::reporting::AppLaunchData& AppTelemetry::app_launch_data() const
{
    // @@protoc_insertion_point(field_get:reporting.AppTelemetry.app_launch_data)
    return _internal_app_launch_data();
}
inline ::reporting::AppLaunchData* AppTelemetry::unsafe_arena_release_app_launch_data()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.AppTelemetry.app_launch_data)
    if (_internal_has_app_launch_data()) {
        clear_has_app_metric_data();
        ::reporting::AppLaunchData* temp = _impl_.app_metric_data_.app_launch_data_;
        _impl_.app_metric_data_.app_launch_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void AppTelemetry::unsafe_arena_set_allocated_app_launch_data(::reporting::AppLaunchData* app_launch_data)
{
    clear_app_metric_data();
    if (app_launch_data) {
        set_has_app_launch_data();
        _impl_.app_metric_data_.app_launch_data_ = app_launch_data;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.AppTelemetry.app_launch_data)
}
inline ::reporting::AppLaunchData* AppTelemetry::_internal_mutable_app_launch_data()
{
    if (!_internal_has_app_launch_data()) {
        clear_app_metric_data();
        set_has_app_launch_data();
        _impl_.app_metric_data_.app_launch_data_ = CreateMaybeMessage<::reporting::AppLaunchData>(GetArenaForAllocation());
    }
    return _impl_.app_metric_data_.app_launch_data_;
}
inline ::reporting::AppLaunchData* AppTelemetry::mutable_app_launch_data()
{
    ::reporting::AppLaunchData* _msg = _internal_mutable_app_launch_data();
    // @@protoc_insertion_point(field_mutable:reporting.AppTelemetry.app_launch_data)
    return _msg;
}

// .reporting.AppUsageData app_usage_data = 6;
inline bool AppTelemetry::_internal_has_app_usage_data() const
{
    return app_metric_data_case() == kAppUsageData;
}
inline bool AppTelemetry::has_app_usage_data() const
{
    return _internal_has_app_usage_data();
}
inline void AppTelemetry::set_has_app_usage_data()
{
    _impl_._oneof_case_[0] = kAppUsageData;
}
inline void AppTelemetry::clear_app_usage_data()
{
    if (_internal_has_app_usage_data()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.app_metric_data_.app_usage_data_;
        }
        clear_has_app_metric_data();
    }
}
inline ::reporting::AppUsageData* AppTelemetry::release_app_usage_data()
{
    // @@protoc_insertion_point(field_release:reporting.AppTelemetry.app_usage_data)
    if (_internal_has_app_usage_data()) {
        clear_has_app_metric_data();
        ::reporting::AppUsageData* temp = _impl_.app_metric_data_.app_usage_data_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.app_metric_data_.app_usage_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::AppUsageData& AppTelemetry::_internal_app_usage_data() const
{
    return _internal_has_app_usage_data() ? *_impl_.app_metric_data_.app_usage_data_
                                          : reinterpret_cast<::reporting::AppUsageData&>(::reporting::_AppUsageData_default_instance_);
}
inline const ::reporting::AppUsageData& AppTelemetry::app_usage_data() const
{
    // @@protoc_insertion_point(field_get:reporting.AppTelemetry.app_usage_data)
    return _internal_app_usage_data();
}
inline ::reporting::AppUsageData* AppTelemetry::unsafe_arena_release_app_usage_data()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.AppTelemetry.app_usage_data)
    if (_internal_has_app_usage_data()) {
        clear_has_app_metric_data();
        ::reporting::AppUsageData* temp = _impl_.app_metric_data_.app_usage_data_;
        _impl_.app_metric_data_.app_usage_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void AppTelemetry::unsafe_arena_set_allocated_app_usage_data(::reporting::AppUsageData* app_usage_data)
{
    clear_app_metric_data();
    if (app_usage_data) {
        set_has_app_usage_data();
        _impl_.app_metric_data_.app_usage_data_ = app_usage_data;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.AppTelemetry.app_usage_data)
}
inline ::reporting::AppUsageData* AppTelemetry::_internal_mutable_app_usage_data()
{
    if (!_internal_has_app_usage_data()) {
        clear_app_metric_data();
        set_has_app_usage_data();
        _impl_.app_metric_data_.app_usage_data_ = CreateMaybeMessage<::reporting::AppUsageData>(GetArenaForAllocation());
    }
    return _impl_.app_metric_data_.app_usage_data_;
}
inline ::reporting::AppUsageData* AppTelemetry::mutable_app_usage_data()
{
    ::reporting::AppUsageData* _msg = _internal_mutable_app_usage_data();
    // @@protoc_insertion_point(field_mutable:reporting.AppTelemetry.app_usage_data)
    return _msg;
}

inline bool AppTelemetry::has_app_metric_data() const
{
    return app_metric_data_case() != APP_METRIC_DATA_NOT_SET;
}
inline void AppTelemetry::clear_has_app_metric_data()
{
    _impl_._oneof_case_[0] = APP_METRIC_DATA_NOT_SET;
}
inline AppTelemetry::AppMetricDataCase AppTelemetry::app_metric_data_case() const
{
    return AppTelemetry::AppMetricDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AppInstallData

// optional .apps.ApplicationInstallSource app_install_source = 1;
inline bool AppInstallData::_internal_has_app_install_source() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool AppInstallData::has_app_install_source() const
{
    return _internal_has_app_install_source();
}
inline void AppInstallData::clear_app_install_source()
{
    _impl_.app_install_source_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::apps::ApplicationInstallSource AppInstallData::_internal_app_install_source() const
{
    return static_cast<::apps::ApplicationInstallSource>(_impl_.app_install_source_);
}
inline ::apps::ApplicationInstallSource AppInstallData::app_install_source() const
{
    // @@protoc_insertion_point(field_get:reporting.AppInstallData.app_install_source)
    return _internal_app_install_source();
}
inline void AppInstallData::_internal_set_app_install_source(::apps::ApplicationInstallSource value)
{
    assert(::apps::ApplicationInstallSource_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.app_install_source_ = value;
}
inline void AppInstallData::set_app_install_source(::apps::ApplicationInstallSource value)
{
    _internal_set_app_install_source(value);
    // @@protoc_insertion_point(field_set:reporting.AppInstallData.app_install_source)
}

// optional .apps.ApplicationInstallReason app_install_reason = 2;
inline bool AppInstallData::_internal_has_app_install_reason() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool AppInstallData::has_app_install_reason() const
{
    return _internal_has_app_install_reason();
}
inline void AppInstallData::clear_app_install_reason()
{
    _impl_.app_install_reason_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::apps::ApplicationInstallReason AppInstallData::_internal_app_install_reason() const
{
    return static_cast<::apps::ApplicationInstallReason>(_impl_.app_install_reason_);
}
inline ::apps::ApplicationInstallReason AppInstallData::app_install_reason() const
{
    // @@protoc_insertion_point(field_get:reporting.AppInstallData.app_install_reason)
    return _internal_app_install_reason();
}
inline void AppInstallData::_internal_set_app_install_reason(::apps::ApplicationInstallReason value)
{
    assert(::apps::ApplicationInstallReason_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.app_install_reason_ = value;
}
inline void AppInstallData::set_app_install_reason(::apps::ApplicationInstallReason value)
{
    _internal_set_app_install_reason(value);
    // @@protoc_insertion_point(field_set:reporting.AppInstallData.app_install_reason)
}

// optional .apps.ApplicationInstallTime app_install_time = 3;
inline bool AppInstallData::_internal_has_app_install_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool AppInstallData::has_app_install_time() const
{
    return _internal_has_app_install_time();
}
inline void AppInstallData::clear_app_install_time()
{
    _impl_.app_install_time_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::apps::ApplicationInstallTime AppInstallData::_internal_app_install_time() const
{
    return static_cast<::apps::ApplicationInstallTime>(_impl_.app_install_time_);
}
inline ::apps::ApplicationInstallTime AppInstallData::app_install_time() const
{
    // @@protoc_insertion_point(field_get:reporting.AppInstallData.app_install_time)
    return _internal_app_install_time();
}
inline void AppInstallData::_internal_set_app_install_time(::apps::ApplicationInstallTime value)
{
    assert(::apps::ApplicationInstallTime_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.app_install_time_ = value;
}
inline void AppInstallData::set_app_install_time(::apps::ApplicationInstallTime value)
{
    _internal_set_app_install_time(value);
    // @@protoc_insertion_point(field_set:reporting.AppInstallData.app_install_time)
}

// optional string app_id = 4;
inline bool AppInstallData::_internal_has_app_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool AppInstallData::has_app_id() const
{
    return _internal_has_app_id();
}
inline void AppInstallData::clear_app_id()
{
    _impl_.app_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppInstallData::app_id() const
{
    // @@protoc_insertion_point(field_get:reporting.AppInstallData.app_id)
    return _internal_app_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AppInstallData::set_app_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.app_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.AppInstallData.app_id)
}
inline std::string* AppInstallData::mutable_app_id()
{
    std::string* _s = _internal_mutable_app_id();
    // @@protoc_insertion_point(field_mutable:reporting.AppInstallData.app_id)
    return _s;
}
inline const std::string& AppInstallData::_internal_app_id() const
{
    return _impl_.app_id_.Get();
}
inline void AppInstallData::_internal_set_app_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AppInstallData::_internal_mutable_app_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AppInstallData::release_app_id()
{
    // @@protoc_insertion_point(field_release:reporting.AppInstallData.app_id)
    if (!_internal_has_app_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.app_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.app_id_.IsDefault()) {
        _impl_.app_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AppInstallData::set_allocated_app_id(std::string* app_id)
{
    if (app_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.app_id_.IsDefault()) {
        _impl_.app_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.AppInstallData.app_id)
}

// optional .apps.ApplicationType app_type = 5;
inline bool AppInstallData::_internal_has_app_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool AppInstallData::has_app_type() const
{
    return _internal_has_app_type();
}
inline void AppInstallData::clear_app_type()
{
    _impl_.app_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::apps::ApplicationType AppInstallData::_internal_app_type() const
{
    return static_cast<::apps::ApplicationType>(_impl_.app_type_);
}
inline ::apps::ApplicationType AppInstallData::app_type() const
{
    // @@protoc_insertion_point(field_get:reporting.AppInstallData.app_type)
    return _internal_app_type();
}
inline void AppInstallData::_internal_set_app_type(::apps::ApplicationType value)
{
    assert(::apps::ApplicationType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.app_type_ = value;
}
inline void AppInstallData::set_app_type(::apps::ApplicationType value)
{
    _internal_set_app_type(value);
    // @@protoc_insertion_point(field_set:reporting.AppInstallData.app_type)
}

// -------------------------------------------------------------------

// AppLaunchData

// optional .apps.ApplicationLaunchSource app_launch_source = 1;
inline bool AppLaunchData::_internal_has_app_launch_source() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool AppLaunchData::has_app_launch_source() const
{
    return _internal_has_app_launch_source();
}
inline void AppLaunchData::clear_app_launch_source()
{
    _impl_.app_launch_source_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::apps::ApplicationLaunchSource AppLaunchData::_internal_app_launch_source() const
{
    return static_cast<::apps::ApplicationLaunchSource>(_impl_.app_launch_source_);
}
inline ::apps::ApplicationLaunchSource AppLaunchData::app_launch_source() const
{
    // @@protoc_insertion_point(field_get:reporting.AppLaunchData.app_launch_source)
    return _internal_app_launch_source();
}
inline void AppLaunchData::_internal_set_app_launch_source(::apps::ApplicationLaunchSource value)
{
    assert(::apps::ApplicationLaunchSource_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.app_launch_source_ = value;
}
inline void AppLaunchData::set_app_launch_source(::apps::ApplicationLaunchSource value)
{
    _internal_set_app_launch_source(value);
    // @@protoc_insertion_point(field_set:reporting.AppLaunchData.app_launch_source)
}

// optional string app_id = 2;
inline bool AppLaunchData::_internal_has_app_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool AppLaunchData::has_app_id() const
{
    return _internal_has_app_id();
}
inline void AppLaunchData::clear_app_id()
{
    _impl_.app_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppLaunchData::app_id() const
{
    // @@protoc_insertion_point(field_get:reporting.AppLaunchData.app_id)
    return _internal_app_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AppLaunchData::set_app_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.app_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.AppLaunchData.app_id)
}
inline std::string* AppLaunchData::mutable_app_id()
{
    std::string* _s = _internal_mutable_app_id();
    // @@protoc_insertion_point(field_mutable:reporting.AppLaunchData.app_id)
    return _s;
}
inline const std::string& AppLaunchData::_internal_app_id() const
{
    return _impl_.app_id_.Get();
}
inline void AppLaunchData::_internal_set_app_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AppLaunchData::_internal_mutable_app_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AppLaunchData::release_app_id()
{
    // @@protoc_insertion_point(field_release:reporting.AppLaunchData.app_id)
    if (!_internal_has_app_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.app_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.app_id_.IsDefault()) {
        _impl_.app_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AppLaunchData::set_allocated_app_id(std::string* app_id)
{
    if (app_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.app_id_.IsDefault()) {
        _impl_.app_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.AppLaunchData.app_id)
}

// optional .apps.ApplicationType app_type = 3;
inline bool AppLaunchData::_internal_has_app_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool AppLaunchData::has_app_type() const
{
    return _internal_has_app_type();
}
inline void AppLaunchData::clear_app_type()
{
    _impl_.app_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::apps::ApplicationType AppLaunchData::_internal_app_type() const
{
    return static_cast<::apps::ApplicationType>(_impl_.app_type_);
}
inline ::apps::ApplicationType AppLaunchData::app_type() const
{
    // @@protoc_insertion_point(field_get:reporting.AppLaunchData.app_type)
    return _internal_app_type();
}
inline void AppLaunchData::_internal_set_app_type(::apps::ApplicationType value)
{
    assert(::apps::ApplicationType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.app_type_ = value;
}
inline void AppLaunchData::set_app_type(::apps::ApplicationType value)
{
    _internal_set_app_type(value);
    // @@protoc_insertion_point(field_set:reporting.AppLaunchData.app_type)
}

// -------------------------------------------------------------------

// AppUsageData_AppUsage

// optional int64 running_time_ms = 1;
inline bool AppUsageData_AppUsage::_internal_has_running_time_ms() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool AppUsageData_AppUsage::has_running_time_ms() const
{
    return _internal_has_running_time_ms();
}
inline void AppUsageData_AppUsage::clear_running_time_ms()
{
    _impl_.running_time_ms_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t AppUsageData_AppUsage::_internal_running_time_ms() const
{
    return _impl_.running_time_ms_;
}
inline int64_t AppUsageData_AppUsage::running_time_ms() const
{
    // @@protoc_insertion_point(field_get:reporting.AppUsageData.AppUsage.running_time_ms)
    return _internal_running_time_ms();
}
inline void AppUsageData_AppUsage::_internal_set_running_time_ms(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.running_time_ms_ = value;
}
inline void AppUsageData_AppUsage::set_running_time_ms(int64_t value)
{
    _internal_set_running_time_ms(value);
    // @@protoc_insertion_point(field_set:reporting.AppUsageData.AppUsage.running_time_ms)
}

// optional string app_id = 2;
inline bool AppUsageData_AppUsage::_internal_has_app_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool AppUsageData_AppUsage::has_app_id() const
{
    return _internal_has_app_id();
}
inline void AppUsageData_AppUsage::clear_app_id()
{
    _impl_.app_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppUsageData_AppUsage::app_id() const
{
    // @@protoc_insertion_point(field_get:reporting.AppUsageData.AppUsage.app_id)
    return _internal_app_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AppUsageData_AppUsage::set_app_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.app_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.AppUsageData.AppUsage.app_id)
}
inline std::string* AppUsageData_AppUsage::mutable_app_id()
{
    std::string* _s = _internal_mutable_app_id();
    // @@protoc_insertion_point(field_mutable:reporting.AppUsageData.AppUsage.app_id)
    return _s;
}
inline const std::string& AppUsageData_AppUsage::_internal_app_id() const
{
    return _impl_.app_id_.Get();
}
inline void AppUsageData_AppUsage::_internal_set_app_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AppUsageData_AppUsage::_internal_mutable_app_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AppUsageData_AppUsage::release_app_id()
{
    // @@protoc_insertion_point(field_release:reporting.AppUsageData.AppUsage.app_id)
    if (!_internal_has_app_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.app_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.app_id_.IsDefault()) {
        _impl_.app_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AppUsageData_AppUsage::set_allocated_app_id(std::string* app_id)
{
    if (app_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.app_id_.IsDefault()) {
        _impl_.app_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.AppUsageData.AppUsage.app_id)
}

// optional .apps.ApplicationType app_type = 3;
inline bool AppUsageData_AppUsage::_internal_has_app_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool AppUsageData_AppUsage::has_app_type() const
{
    return _internal_has_app_type();
}
inline void AppUsageData_AppUsage::clear_app_type()
{
    _impl_.app_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::apps::ApplicationType AppUsageData_AppUsage::_internal_app_type() const
{
    return static_cast<::apps::ApplicationType>(_impl_.app_type_);
}
inline ::apps::ApplicationType AppUsageData_AppUsage::app_type() const
{
    // @@protoc_insertion_point(field_get:reporting.AppUsageData.AppUsage.app_type)
    return _internal_app_type();
}
inline void AppUsageData_AppUsage::_internal_set_app_type(::apps::ApplicationType value)
{
    assert(::apps::ApplicationType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.app_type_ = value;
}
inline void AppUsageData_AppUsage::set_app_type(::apps::ApplicationType value)
{
    _internal_set_app_type(value);
    // @@protoc_insertion_point(field_set:reporting.AppUsageData.AppUsage.app_type)
}

// optional string app_instance_id = 4;
inline bool AppUsageData_AppUsage::_internal_has_app_instance_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool AppUsageData_AppUsage::has_app_instance_id() const
{
    return _internal_has_app_instance_id();
}
inline void AppUsageData_AppUsage::clear_app_instance_id()
{
    _impl_.app_instance_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppUsageData_AppUsage::app_instance_id() const
{
    // @@protoc_insertion_point(field_get:reporting.AppUsageData.AppUsage.app_instance_id)
    return _internal_app_instance_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AppUsageData_AppUsage::set_app_instance_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.app_instance_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.AppUsageData.AppUsage.app_instance_id)
}
inline std::string* AppUsageData_AppUsage::mutable_app_instance_id()
{
    std::string* _s = _internal_mutable_app_instance_id();
    // @@protoc_insertion_point(field_mutable:reporting.AppUsageData.AppUsage.app_instance_id)
    return _s;
}
inline const std::string& AppUsageData_AppUsage::_internal_app_instance_id() const
{
    return _impl_.app_instance_id_.Get();
}
inline void AppUsageData_AppUsage::_internal_set_app_instance_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.app_instance_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AppUsageData_AppUsage::_internal_mutable_app_instance_id()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.app_instance_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AppUsageData_AppUsage::release_app_instance_id()
{
    // @@protoc_insertion_point(field_release:reporting.AppUsageData.AppUsage.app_instance_id)
    if (!_internal_has_app_instance_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.app_instance_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.app_instance_id_.IsDefault()) {
        _impl_.app_instance_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AppUsageData_AppUsage::set_allocated_app_instance_id(std::string* app_instance_id)
{
    if (app_instance_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.app_instance_id_.SetAllocated(app_instance_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.app_instance_id_.IsDefault()) {
        _impl_.app_instance_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.AppUsageData.AppUsage.app_instance_id)
}

// -------------------------------------------------------------------

// AppUsageData

// repeated .reporting.AppUsageData.AppUsage app_usage = 2;
inline int AppUsageData::_internal_app_usage_size() const
{
    return _impl_.app_usage_.size();
}
inline int AppUsageData::app_usage_size() const
{
    return _internal_app_usage_size();
}
inline void AppUsageData::clear_app_usage()
{
    _impl_.app_usage_.Clear();
}
inline ::reporting::AppUsageData_AppUsage* AppUsageData::mutable_app_usage(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.AppUsageData.app_usage)
    return _impl_.app_usage_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::AppUsageData_AppUsage>* AppUsageData::mutable_app_usage()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.AppUsageData.app_usage)
    return &_impl_.app_usage_;
}
inline const ::reporting::AppUsageData_AppUsage& AppUsageData::_internal_app_usage(int index) const
{
    return _impl_.app_usage_.Get(index);
}
inline const ::reporting::AppUsageData_AppUsage& AppUsageData::app_usage(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.AppUsageData.app_usage)
    return _internal_app_usage(index);
}
inline ::reporting::AppUsageData_AppUsage* AppUsageData::_internal_add_app_usage()
{
    return _impl_.app_usage_.Add();
}
inline ::reporting::AppUsageData_AppUsage* AppUsageData::add_app_usage()
{
    ::reporting::AppUsageData_AppUsage* _add = _internal_add_app_usage();
    // @@protoc_insertion_point(field_add:reporting.AppUsageData.app_usage)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::AppUsageData_AppUsage>& AppUsageData::app_usage() const
{
    // @@protoc_insertion_point(field_list:reporting.AppUsageData.app_usage)
    return _impl_.app_usage_;
}

// -------------------------------------------------------------------

// AppUninstallData

// optional .apps.ApplicationUninstallSource app_uninstall_source = 1;
inline bool AppUninstallData::_internal_has_app_uninstall_source() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool AppUninstallData::has_app_uninstall_source() const
{
    return _internal_has_app_uninstall_source();
}
inline void AppUninstallData::clear_app_uninstall_source()
{
    _impl_.app_uninstall_source_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::apps::ApplicationUninstallSource AppUninstallData::_internal_app_uninstall_source() const
{
    return static_cast<::apps::ApplicationUninstallSource>(_impl_.app_uninstall_source_);
}
inline ::apps::ApplicationUninstallSource AppUninstallData::app_uninstall_source() const
{
    // @@protoc_insertion_point(field_get:reporting.AppUninstallData.app_uninstall_source)
    return _internal_app_uninstall_source();
}
inline void AppUninstallData::_internal_set_app_uninstall_source(::apps::ApplicationUninstallSource value)
{
    assert(::apps::ApplicationUninstallSource_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.app_uninstall_source_ = value;
}
inline void AppUninstallData::set_app_uninstall_source(::apps::ApplicationUninstallSource value)
{
    _internal_set_app_uninstall_source(value);
    // @@protoc_insertion_point(field_set:reporting.AppUninstallData.app_uninstall_source)
}

// optional string app_id = 2;
inline bool AppUninstallData::_internal_has_app_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool AppUninstallData::has_app_id() const
{
    return _internal_has_app_id();
}
inline void AppUninstallData::clear_app_id()
{
    _impl_.app_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppUninstallData::app_id() const
{
    // @@protoc_insertion_point(field_get:reporting.AppUninstallData.app_id)
    return _internal_app_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void AppUninstallData::set_app_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.app_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.AppUninstallData.app_id)
}
inline std::string* AppUninstallData::mutable_app_id()
{
    std::string* _s = _internal_mutable_app_id();
    // @@protoc_insertion_point(field_mutable:reporting.AppUninstallData.app_id)
    return _s;
}
inline const std::string& AppUninstallData::_internal_app_id() const
{
    return _impl_.app_id_.Get();
}
inline void AppUninstallData::_internal_set_app_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* AppUninstallData::_internal_mutable_app_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* AppUninstallData::release_app_id()
{
    // @@protoc_insertion_point(field_release:reporting.AppUninstallData.app_id)
    if (!_internal_has_app_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.app_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.app_id_.IsDefault()) {
        _impl_.app_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void AppUninstallData::set_allocated_app_id(std::string* app_id)
{
    if (app_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.app_id_.SetAllocated(app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.app_id_.IsDefault()) {
        _impl_.app_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.AppUninstallData.app_id)
}

// optional .apps.ApplicationType app_type = 3;
inline bool AppUninstallData::_internal_has_app_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool AppUninstallData::has_app_type() const
{
    return _internal_has_app_type();
}
inline void AppUninstallData::clear_app_type()
{
    _impl_.app_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::apps::ApplicationType AppUninstallData::_internal_app_type() const
{
    return static_cast<::apps::ApplicationType>(_impl_.app_type_);
}
inline ::apps::ApplicationType AppUninstallData::app_type() const
{
    // @@protoc_insertion_point(field_get:reporting.AppUninstallData.app_type)
    return _internal_app_type();
}
inline void AppUninstallData::_internal_set_app_type(::apps::ApplicationType value)
{
    assert(::apps::ApplicationType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.app_type_ = value;
}
inline void AppUninstallData::set_app_type(::apps::ApplicationType value)
{
    _internal_set_app_type(value);
    // @@protoc_insertion_point(field_set:reporting.AppUninstallData.app_type)
}

// -------------------------------------------------------------------

// WebsiteTelemetry

// .reporting.WebsiteOpenedData website_opened_data = 1;
inline bool WebsiteTelemetry::_internal_has_website_opened_data() const
{
    return website_metric_data_case() == kWebsiteOpenedData;
}
inline bool WebsiteTelemetry::has_website_opened_data() const
{
    return _internal_has_website_opened_data();
}
inline void WebsiteTelemetry::set_has_website_opened_data()
{
    _impl_._oneof_case_[0] = kWebsiteOpenedData;
}
inline void WebsiteTelemetry::clear_website_opened_data()
{
    if (_internal_has_website_opened_data()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.website_metric_data_.website_opened_data_;
        }
        clear_has_website_metric_data();
    }
}
inline ::reporting::WebsiteOpenedData* WebsiteTelemetry::release_website_opened_data()
{
    // @@protoc_insertion_point(field_release:reporting.WebsiteTelemetry.website_opened_data)
    if (_internal_has_website_opened_data()) {
        clear_has_website_metric_data();
        ::reporting::WebsiteOpenedData* temp = _impl_.website_metric_data_.website_opened_data_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.website_metric_data_.website_opened_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::WebsiteOpenedData& WebsiteTelemetry::_internal_website_opened_data() const
{
    return _internal_has_website_opened_data() ? *_impl_.website_metric_data_.website_opened_data_
                                               : reinterpret_cast<::reporting::WebsiteOpenedData&>(::reporting::_WebsiteOpenedData_default_instance_);
}
inline const ::reporting::WebsiteOpenedData& WebsiteTelemetry::website_opened_data() const
{
    // @@protoc_insertion_point(field_get:reporting.WebsiteTelemetry.website_opened_data)
    return _internal_website_opened_data();
}
inline ::reporting::WebsiteOpenedData* WebsiteTelemetry::unsafe_arena_release_website_opened_data()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.WebsiteTelemetry.website_opened_data)
    if (_internal_has_website_opened_data()) {
        clear_has_website_metric_data();
        ::reporting::WebsiteOpenedData* temp = _impl_.website_metric_data_.website_opened_data_;
        _impl_.website_metric_data_.website_opened_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void WebsiteTelemetry::unsafe_arena_set_allocated_website_opened_data(::reporting::WebsiteOpenedData* website_opened_data)
{
    clear_website_metric_data();
    if (website_opened_data) {
        set_has_website_opened_data();
        _impl_.website_metric_data_.website_opened_data_ = website_opened_data;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.WebsiteTelemetry.website_opened_data)
}
inline ::reporting::WebsiteOpenedData* WebsiteTelemetry::_internal_mutable_website_opened_data()
{
    if (!_internal_has_website_opened_data()) {
        clear_website_metric_data();
        set_has_website_opened_data();
        _impl_.website_metric_data_.website_opened_data_ = CreateMaybeMessage<::reporting::WebsiteOpenedData>(GetArenaForAllocation());
    }
    return _impl_.website_metric_data_.website_opened_data_;
}
inline ::reporting::WebsiteOpenedData* WebsiteTelemetry::mutable_website_opened_data()
{
    ::reporting::WebsiteOpenedData* _msg = _internal_mutable_website_opened_data();
    // @@protoc_insertion_point(field_mutable:reporting.WebsiteTelemetry.website_opened_data)
    return _msg;
}

// .reporting.WebsiteClosedData website_closed_data = 2;
inline bool WebsiteTelemetry::_internal_has_website_closed_data() const
{
    return website_metric_data_case() == kWebsiteClosedData;
}
inline bool WebsiteTelemetry::has_website_closed_data() const
{
    return _internal_has_website_closed_data();
}
inline void WebsiteTelemetry::set_has_website_closed_data()
{
    _impl_._oneof_case_[0] = kWebsiteClosedData;
}
inline void WebsiteTelemetry::clear_website_closed_data()
{
    if (_internal_has_website_closed_data()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.website_metric_data_.website_closed_data_;
        }
        clear_has_website_metric_data();
    }
}
inline ::reporting::WebsiteClosedData* WebsiteTelemetry::release_website_closed_data()
{
    // @@protoc_insertion_point(field_release:reporting.WebsiteTelemetry.website_closed_data)
    if (_internal_has_website_closed_data()) {
        clear_has_website_metric_data();
        ::reporting::WebsiteClosedData* temp = _impl_.website_metric_data_.website_closed_data_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.website_metric_data_.website_closed_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::WebsiteClosedData& WebsiteTelemetry::_internal_website_closed_data() const
{
    return _internal_has_website_closed_data() ? *_impl_.website_metric_data_.website_closed_data_
                                               : reinterpret_cast<::reporting::WebsiteClosedData&>(::reporting::_WebsiteClosedData_default_instance_);
}
inline const ::reporting::WebsiteClosedData& WebsiteTelemetry::website_closed_data() const
{
    // @@protoc_insertion_point(field_get:reporting.WebsiteTelemetry.website_closed_data)
    return _internal_website_closed_data();
}
inline ::reporting::WebsiteClosedData* WebsiteTelemetry::unsafe_arena_release_website_closed_data()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.WebsiteTelemetry.website_closed_data)
    if (_internal_has_website_closed_data()) {
        clear_has_website_metric_data();
        ::reporting::WebsiteClosedData* temp = _impl_.website_metric_data_.website_closed_data_;
        _impl_.website_metric_data_.website_closed_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void WebsiteTelemetry::unsafe_arena_set_allocated_website_closed_data(::reporting::WebsiteClosedData* website_closed_data)
{
    clear_website_metric_data();
    if (website_closed_data) {
        set_has_website_closed_data();
        _impl_.website_metric_data_.website_closed_data_ = website_closed_data;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.WebsiteTelemetry.website_closed_data)
}
inline ::reporting::WebsiteClosedData* WebsiteTelemetry::_internal_mutable_website_closed_data()
{
    if (!_internal_has_website_closed_data()) {
        clear_website_metric_data();
        set_has_website_closed_data();
        _impl_.website_metric_data_.website_closed_data_ = CreateMaybeMessage<::reporting::WebsiteClosedData>(GetArenaForAllocation());
    }
    return _impl_.website_metric_data_.website_closed_data_;
}
inline ::reporting::WebsiteClosedData* WebsiteTelemetry::mutable_website_closed_data()
{
    ::reporting::WebsiteClosedData* _msg = _internal_mutable_website_closed_data();
    // @@protoc_insertion_point(field_mutable:reporting.WebsiteTelemetry.website_closed_data)
    return _msg;
}

// .reporting.WebsiteUsageData website_usage_data = 3;
inline bool WebsiteTelemetry::_internal_has_website_usage_data() const
{
    return website_metric_data_case() == kWebsiteUsageData;
}
inline bool WebsiteTelemetry::has_website_usage_data() const
{
    return _internal_has_website_usage_data();
}
inline void WebsiteTelemetry::set_has_website_usage_data()
{
    _impl_._oneof_case_[0] = kWebsiteUsageData;
}
inline void WebsiteTelemetry::clear_website_usage_data()
{
    if (_internal_has_website_usage_data()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.website_metric_data_.website_usage_data_;
        }
        clear_has_website_metric_data();
    }
}
inline ::reporting::WebsiteUsageData* WebsiteTelemetry::release_website_usage_data()
{
    // @@protoc_insertion_point(field_release:reporting.WebsiteTelemetry.website_usage_data)
    if (_internal_has_website_usage_data()) {
        clear_has_website_metric_data();
        ::reporting::WebsiteUsageData* temp = _impl_.website_metric_data_.website_usage_data_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.website_metric_data_.website_usage_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::WebsiteUsageData& WebsiteTelemetry::_internal_website_usage_data() const
{
    return _internal_has_website_usage_data() ? *_impl_.website_metric_data_.website_usage_data_
                                              : reinterpret_cast<::reporting::WebsiteUsageData&>(::reporting::_WebsiteUsageData_default_instance_);
}
inline const ::reporting::WebsiteUsageData& WebsiteTelemetry::website_usage_data() const
{
    // @@protoc_insertion_point(field_get:reporting.WebsiteTelemetry.website_usage_data)
    return _internal_website_usage_data();
}
inline ::reporting::WebsiteUsageData* WebsiteTelemetry::unsafe_arena_release_website_usage_data()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.WebsiteTelemetry.website_usage_data)
    if (_internal_has_website_usage_data()) {
        clear_has_website_metric_data();
        ::reporting::WebsiteUsageData* temp = _impl_.website_metric_data_.website_usage_data_;
        _impl_.website_metric_data_.website_usage_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void WebsiteTelemetry::unsafe_arena_set_allocated_website_usage_data(::reporting::WebsiteUsageData* website_usage_data)
{
    clear_website_metric_data();
    if (website_usage_data) {
        set_has_website_usage_data();
        _impl_.website_metric_data_.website_usage_data_ = website_usage_data;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.WebsiteTelemetry.website_usage_data)
}
inline ::reporting::WebsiteUsageData* WebsiteTelemetry::_internal_mutable_website_usage_data()
{
    if (!_internal_has_website_usage_data()) {
        clear_website_metric_data();
        set_has_website_usage_data();
        _impl_.website_metric_data_.website_usage_data_ = CreateMaybeMessage<::reporting::WebsiteUsageData>(GetArenaForAllocation());
    }
    return _impl_.website_metric_data_.website_usage_data_;
}
inline ::reporting::WebsiteUsageData* WebsiteTelemetry::mutable_website_usage_data()
{
    ::reporting::WebsiteUsageData* _msg = _internal_mutable_website_usage_data();
    // @@protoc_insertion_point(field_mutable:reporting.WebsiteTelemetry.website_usage_data)
    return _msg;
}

inline bool WebsiteTelemetry::has_website_metric_data() const
{
    return website_metric_data_case() != WEBSITE_METRIC_DATA_NOT_SET;
}
inline void WebsiteTelemetry::clear_has_website_metric_data()
{
    _impl_._oneof_case_[0] = WEBSITE_METRIC_DATA_NOT_SET;
}
inline WebsiteTelemetry::WebsiteMetricDataCase WebsiteTelemetry::website_metric_data_case() const
{
    return WebsiteTelemetry::WebsiteMetricDataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WebsiteOpenedData

// optional string url = 1;
inline bool WebsiteOpenedData::_internal_has_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool WebsiteOpenedData::has_url() const
{
    return _internal_has_url();
}
inline void WebsiteOpenedData::clear_url()
{
    _impl_.url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WebsiteOpenedData::url() const
{
    // @@protoc_insertion_point(field_get:reporting.WebsiteOpenedData.url)
    return _internal_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WebsiteOpenedData::set_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.WebsiteOpenedData.url)
}
inline std::string* WebsiteOpenedData::mutable_url()
{
    std::string* _s = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:reporting.WebsiteOpenedData.url)
    return _s;
}
inline const std::string& WebsiteOpenedData::_internal_url() const
{
    return _impl_.url_.Get();
}
inline void WebsiteOpenedData::_internal_set_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* WebsiteOpenedData::_internal_mutable_url()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* WebsiteOpenedData::release_url()
{
    // @@protoc_insertion_point(field_release:reporting.WebsiteOpenedData.url)
    if (!_internal_has_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void WebsiteOpenedData::set_allocated_url(std::string* url)
{
    if (url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.WebsiteOpenedData.url)
}

// optional int32 render_process_host_id = 2;
inline bool WebsiteOpenedData::_internal_has_render_process_host_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool WebsiteOpenedData::has_render_process_host_id() const
{
    return _internal_has_render_process_host_id();
}
inline void WebsiteOpenedData::clear_render_process_host_id()
{
    _impl_.render_process_host_id_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t WebsiteOpenedData::_internal_render_process_host_id() const
{
    return _impl_.render_process_host_id_;
}
inline int32_t WebsiteOpenedData::render_process_host_id() const
{
    // @@protoc_insertion_point(field_get:reporting.WebsiteOpenedData.render_process_host_id)
    return _internal_render_process_host_id();
}
inline void WebsiteOpenedData::_internal_set_render_process_host_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.render_process_host_id_ = value;
}
inline void WebsiteOpenedData::set_render_process_host_id(int32_t value)
{
    _internal_set_render_process_host_id(value);
    // @@protoc_insertion_point(field_set:reporting.WebsiteOpenedData.render_process_host_id)
}

// optional int32 render_frame_routing_id = 3;
inline bool WebsiteOpenedData::_internal_has_render_frame_routing_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool WebsiteOpenedData::has_render_frame_routing_id() const
{
    return _internal_has_render_frame_routing_id();
}
inline void WebsiteOpenedData::clear_render_frame_routing_id()
{
    _impl_.render_frame_routing_id_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t WebsiteOpenedData::_internal_render_frame_routing_id() const
{
    return _impl_.render_frame_routing_id_;
}
inline int32_t WebsiteOpenedData::render_frame_routing_id() const
{
    // @@protoc_insertion_point(field_get:reporting.WebsiteOpenedData.render_frame_routing_id)
    return _internal_render_frame_routing_id();
}
inline void WebsiteOpenedData::_internal_set_render_frame_routing_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.render_frame_routing_id_ = value;
}
inline void WebsiteOpenedData::set_render_frame_routing_id(int32_t value)
{
    _internal_set_render_frame_routing_id(value);
    // @@protoc_insertion_point(field_set:reporting.WebsiteOpenedData.render_frame_routing_id)
}

// -------------------------------------------------------------------

// WebsiteClosedData

// optional string url = 1;
inline bool WebsiteClosedData::_internal_has_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool WebsiteClosedData::has_url() const
{
    return _internal_has_url();
}
inline void WebsiteClosedData::clear_url()
{
    _impl_.url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WebsiteClosedData::url() const
{
    // @@protoc_insertion_point(field_get:reporting.WebsiteClosedData.url)
    return _internal_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WebsiteClosedData::set_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.WebsiteClosedData.url)
}
inline std::string* WebsiteClosedData::mutable_url()
{
    std::string* _s = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:reporting.WebsiteClosedData.url)
    return _s;
}
inline const std::string& WebsiteClosedData::_internal_url() const
{
    return _impl_.url_.Get();
}
inline void WebsiteClosedData::_internal_set_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* WebsiteClosedData::_internal_mutable_url()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* WebsiteClosedData::release_url()
{
    // @@protoc_insertion_point(field_release:reporting.WebsiteClosedData.url)
    if (!_internal_has_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void WebsiteClosedData::set_allocated_url(std::string* url)
{
    if (url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.WebsiteClosedData.url)
}

// optional int32 render_process_host_id = 2;
inline bool WebsiteClosedData::_internal_has_render_process_host_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool WebsiteClosedData::has_render_process_host_id() const
{
    return _internal_has_render_process_host_id();
}
inline void WebsiteClosedData::clear_render_process_host_id()
{
    _impl_.render_process_host_id_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t WebsiteClosedData::_internal_render_process_host_id() const
{
    return _impl_.render_process_host_id_;
}
inline int32_t WebsiteClosedData::render_process_host_id() const
{
    // @@protoc_insertion_point(field_get:reporting.WebsiteClosedData.render_process_host_id)
    return _internal_render_process_host_id();
}
inline void WebsiteClosedData::_internal_set_render_process_host_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.render_process_host_id_ = value;
}
inline void WebsiteClosedData::set_render_process_host_id(int32_t value)
{
    _internal_set_render_process_host_id(value);
    // @@protoc_insertion_point(field_set:reporting.WebsiteClosedData.render_process_host_id)
}

// optional int32 render_frame_routing_id = 3;
inline bool WebsiteClosedData::_internal_has_render_frame_routing_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool WebsiteClosedData::has_render_frame_routing_id() const
{
    return _internal_has_render_frame_routing_id();
}
inline void WebsiteClosedData::clear_render_frame_routing_id()
{
    _impl_.render_frame_routing_id_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t WebsiteClosedData::_internal_render_frame_routing_id() const
{
    return _impl_.render_frame_routing_id_;
}
inline int32_t WebsiteClosedData::render_frame_routing_id() const
{
    // @@protoc_insertion_point(field_get:reporting.WebsiteClosedData.render_frame_routing_id)
    return _internal_render_frame_routing_id();
}
inline void WebsiteClosedData::_internal_set_render_frame_routing_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.render_frame_routing_id_ = value;
}
inline void WebsiteClosedData::set_render_frame_routing_id(int32_t value)
{
    _internal_set_render_frame_routing_id(value);
    // @@protoc_insertion_point(field_set:reporting.WebsiteClosedData.render_frame_routing_id)
}

// -------------------------------------------------------------------

// WebsiteUsageData_WebsiteUsage

// optional string url = 1;
inline bool WebsiteUsageData_WebsiteUsage::_internal_has_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool WebsiteUsageData_WebsiteUsage::has_url() const
{
    return _internal_has_url();
}
inline void WebsiteUsageData_WebsiteUsage::clear_url()
{
    _impl_.url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WebsiteUsageData_WebsiteUsage::url() const
{
    // @@protoc_insertion_point(field_get:reporting.WebsiteUsageData.WebsiteUsage.url)
    return _internal_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WebsiteUsageData_WebsiteUsage::set_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.WebsiteUsageData.WebsiteUsage.url)
}
inline std::string* WebsiteUsageData_WebsiteUsage::mutable_url()
{
    std::string* _s = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:reporting.WebsiteUsageData.WebsiteUsage.url)
    return _s;
}
inline const std::string& WebsiteUsageData_WebsiteUsage::_internal_url() const
{
    return _impl_.url_.Get();
}
inline void WebsiteUsageData_WebsiteUsage::_internal_set_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* WebsiteUsageData_WebsiteUsage::_internal_mutable_url()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* WebsiteUsageData_WebsiteUsage::release_url()
{
    // @@protoc_insertion_point(field_release:reporting.WebsiteUsageData.WebsiteUsage.url)
    if (!_internal_has_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void WebsiteUsageData_WebsiteUsage::set_allocated_url(std::string* url)
{
    if (url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.WebsiteUsageData.WebsiteUsage.url)
}

// optional int64 running_time_ms = 2;
inline bool WebsiteUsageData_WebsiteUsage::_internal_has_running_time_ms() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool WebsiteUsageData_WebsiteUsage::has_running_time_ms() const
{
    return _internal_has_running_time_ms();
}
inline void WebsiteUsageData_WebsiteUsage::clear_running_time_ms()
{
    _impl_.running_time_ms_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t WebsiteUsageData_WebsiteUsage::_internal_running_time_ms() const
{
    return _impl_.running_time_ms_;
}
inline int64_t WebsiteUsageData_WebsiteUsage::running_time_ms() const
{
    // @@protoc_insertion_point(field_get:reporting.WebsiteUsageData.WebsiteUsage.running_time_ms)
    return _internal_running_time_ms();
}
inline void WebsiteUsageData_WebsiteUsage::_internal_set_running_time_ms(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.running_time_ms_ = value;
}
inline void WebsiteUsageData_WebsiteUsage::set_running_time_ms(int64_t value)
{
    _internal_set_running_time_ms(value);
    // @@protoc_insertion_point(field_set:reporting.WebsiteUsageData.WebsiteUsage.running_time_ms)
}

// -------------------------------------------------------------------

// WebsiteUsageData

// repeated .reporting.WebsiteUsageData.WebsiteUsage website_usage = 3;
inline int WebsiteUsageData::_internal_website_usage_size() const
{
    return _impl_.website_usage_.size();
}
inline int WebsiteUsageData::website_usage_size() const
{
    return _internal_website_usage_size();
}
inline void WebsiteUsageData::clear_website_usage()
{
    _impl_.website_usage_.Clear();
}
inline ::reporting::WebsiteUsageData_WebsiteUsage* WebsiteUsageData::mutable_website_usage(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.WebsiteUsageData.website_usage)
    return _impl_.website_usage_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::WebsiteUsageData_WebsiteUsage>* WebsiteUsageData::mutable_website_usage()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.WebsiteUsageData.website_usage)
    return &_impl_.website_usage_;
}
inline const ::reporting::WebsiteUsageData_WebsiteUsage& WebsiteUsageData::_internal_website_usage(int index) const
{
    return _impl_.website_usage_.Get(index);
}
inline const ::reporting::WebsiteUsageData_WebsiteUsage& WebsiteUsageData::website_usage(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.WebsiteUsageData.website_usage)
    return _internal_website_usage(index);
}
inline ::reporting::WebsiteUsageData_WebsiteUsage* WebsiteUsageData::_internal_add_website_usage()
{
    return _impl_.website_usage_.Add();
}
inline ::reporting::WebsiteUsageData_WebsiteUsage* WebsiteUsageData::add_website_usage()
{
    ::reporting::WebsiteUsageData_WebsiteUsage* _add = _internal_add_website_usage();
    // @@protoc_insertion_point(field_add:reporting.WebsiteUsageData.website_usage)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::WebsiteUsageData_WebsiteUsage>& WebsiteUsageData::website_usage() const
{
    // @@protoc_insertion_point(field_list:reporting.WebsiteUsageData.website_usage)
    return _impl_.website_usage_;
}

// -------------------------------------------------------------------

// PeripheralsTelemetry

// repeated .reporting.UsbTelemetry usb_telemetry = 1;
inline int PeripheralsTelemetry::_internal_usb_telemetry_size() const
{
    return _impl_.usb_telemetry_.size();
}
inline int PeripheralsTelemetry::usb_telemetry_size() const
{
    return _internal_usb_telemetry_size();
}
inline void PeripheralsTelemetry::clear_usb_telemetry()
{
    _impl_.usb_telemetry_.Clear();
}
inline ::reporting::UsbTelemetry* PeripheralsTelemetry::mutable_usb_telemetry(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.PeripheralsTelemetry.usb_telemetry)
    return _impl_.usb_telemetry_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::UsbTelemetry>* PeripheralsTelemetry::mutable_usb_telemetry()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.PeripheralsTelemetry.usb_telemetry)
    return &_impl_.usb_telemetry_;
}
inline const ::reporting::UsbTelemetry& PeripheralsTelemetry::_internal_usb_telemetry(int index) const
{
    return _impl_.usb_telemetry_.Get(index);
}
inline const ::reporting::UsbTelemetry& PeripheralsTelemetry::usb_telemetry(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.PeripheralsTelemetry.usb_telemetry)
    return _internal_usb_telemetry(index);
}
inline ::reporting::UsbTelemetry* PeripheralsTelemetry::_internal_add_usb_telemetry()
{
    return _impl_.usb_telemetry_.Add();
}
inline ::reporting::UsbTelemetry* PeripheralsTelemetry::add_usb_telemetry()
{
    ::reporting::UsbTelemetry* _add = _internal_add_usb_telemetry();
    // @@protoc_insertion_point(field_add:reporting.PeripheralsTelemetry.usb_telemetry)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::reporting::UsbTelemetry>& PeripheralsTelemetry::usb_telemetry() const
{
    // @@protoc_insertion_point(field_list:reporting.PeripheralsTelemetry.usb_telemetry)
    return _impl_.usb_telemetry_;
}

// -------------------------------------------------------------------

// UsbTelemetry

// optional string vendor = 1;
inline bool UsbTelemetry::_internal_has_vendor() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool UsbTelemetry::has_vendor() const
{
    return _internal_has_vendor();
}
inline void UsbTelemetry::clear_vendor()
{
    _impl_.vendor_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsbTelemetry::vendor() const
{
    // @@protoc_insertion_point(field_get:reporting.UsbTelemetry.vendor)
    return _internal_vendor();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void UsbTelemetry::set_vendor(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.vendor_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.UsbTelemetry.vendor)
}
inline std::string* UsbTelemetry::mutable_vendor()
{
    std::string* _s = _internal_mutable_vendor();
    // @@protoc_insertion_point(field_mutable:reporting.UsbTelemetry.vendor)
    return _s;
}
inline const std::string& UsbTelemetry::_internal_vendor() const
{
    return _impl_.vendor_.Get();
}
inline void UsbTelemetry::_internal_set_vendor(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.vendor_.Set(value, GetArenaForAllocation());
}
inline std::string* UsbTelemetry::_internal_mutable_vendor()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.vendor_.Mutable(GetArenaForAllocation());
}
inline std::string* UsbTelemetry::release_vendor()
{
    // @@protoc_insertion_point(field_release:reporting.UsbTelemetry.vendor)
    if (!_internal_has_vendor()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.vendor_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.vendor_.IsDefault()) {
        _impl_.vendor_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void UsbTelemetry::set_allocated_vendor(std::string* vendor)
{
    if (vendor != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.vendor_.SetAllocated(vendor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.vendor_.IsDefault()) {
        _impl_.vendor_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.UsbTelemetry.vendor)
}

// optional string name = 2;
inline bool UsbTelemetry::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool UsbTelemetry::has_name() const
{
    return _internal_has_name();
}
inline void UsbTelemetry::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UsbTelemetry::name() const
{
    // @@protoc_insertion_point(field_get:reporting.UsbTelemetry.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void UsbTelemetry::set_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.UsbTelemetry.name)
}
inline std::string* UsbTelemetry::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:reporting.UsbTelemetry.name)
    return _s;
}
inline const std::string& UsbTelemetry::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void UsbTelemetry::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* UsbTelemetry::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* UsbTelemetry::release_name()
{
    // @@protoc_insertion_point(field_release:reporting.UsbTelemetry.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void UsbTelemetry::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.UsbTelemetry.name)
}

// optional int32 vid = 3;
inline bool UsbTelemetry::_internal_has_vid() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool UsbTelemetry::has_vid() const
{
    return _internal_has_vid();
}
inline void UsbTelemetry::clear_vid()
{
    _impl_.vid_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t UsbTelemetry::_internal_vid() const
{
    return _impl_.vid_;
}
inline int32_t UsbTelemetry::vid() const
{
    // @@protoc_insertion_point(field_get:reporting.UsbTelemetry.vid)
    return _internal_vid();
}
inline void UsbTelemetry::_internal_set_vid(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.vid_ = value;
}
inline void UsbTelemetry::set_vid(int32_t value)
{
    _internal_set_vid(value);
    // @@protoc_insertion_point(field_set:reporting.UsbTelemetry.vid)
}

// optional int32 pid = 4;
inline bool UsbTelemetry::_internal_has_pid() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool UsbTelemetry::has_pid() const
{
    return _internal_has_pid();
}
inline void UsbTelemetry::clear_pid()
{
    _impl_.pid_ = 0;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t UsbTelemetry::_internal_pid() const
{
    return _impl_.pid_;
}
inline int32_t UsbTelemetry::pid() const
{
    // @@protoc_insertion_point(field_get:reporting.UsbTelemetry.pid)
    return _internal_pid();
}
inline void UsbTelemetry::_internal_set_pid(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.pid_ = value;
}
inline void UsbTelemetry::set_pid(int32_t value)
{
    _internal_set_pid(value);
    // @@protoc_insertion_point(field_set:reporting.UsbTelemetry.pid)
}

// repeated string categories = 5;
inline int UsbTelemetry::_internal_categories_size() const
{
    return _impl_.categories_.size();
}
inline int UsbTelemetry::categories_size() const
{
    return _internal_categories_size();
}
inline void UsbTelemetry::clear_categories()
{
    _impl_.categories_.Clear();
}
inline std::string* UsbTelemetry::add_categories()
{
    std::string* _s = _internal_add_categories();
    // @@protoc_insertion_point(field_add_mutable:reporting.UsbTelemetry.categories)
    return _s;
}
inline const std::string& UsbTelemetry::_internal_categories(int index) const
{
    return _impl_.categories_.Get(index);
}
inline const std::string& UsbTelemetry::categories(int index) const
{
    // @@protoc_insertion_point(field_get:reporting.UsbTelemetry.categories)
    return _internal_categories(index);
}
inline std::string* UsbTelemetry::mutable_categories(int index)
{
    // @@protoc_insertion_point(field_mutable:reporting.UsbTelemetry.categories)
    return _impl_.categories_.Mutable(index);
}
inline void UsbTelemetry::set_categories(int index, const std::string& value)
{
    _impl_.categories_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:reporting.UsbTelemetry.categories)
}
inline void UsbTelemetry::set_categories(int index, std::string&& value)
{
    _impl_.categories_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:reporting.UsbTelemetry.categories)
}
inline void UsbTelemetry::set_categories(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.categories_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:reporting.UsbTelemetry.categories)
}
inline void UsbTelemetry::set_categories(int index, const char* value, size_t size)
{
    _impl_.categories_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:reporting.UsbTelemetry.categories)
}
inline std::string* UsbTelemetry::_internal_add_categories()
{
    return _impl_.categories_.Add();
}
inline void UsbTelemetry::add_categories(const std::string& value)
{
    _impl_.categories_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:reporting.UsbTelemetry.categories)
}
inline void UsbTelemetry::add_categories(std::string&& value)
{
    _impl_.categories_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:reporting.UsbTelemetry.categories)
}
inline void UsbTelemetry::add_categories(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.categories_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:reporting.UsbTelemetry.categories)
}
inline void UsbTelemetry::add_categories(const char* value, size_t size)
{
    _impl_.categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:reporting.UsbTelemetry.categories)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& UsbTelemetry::categories() const
{
    // @@protoc_insertion_point(field_list:reporting.UsbTelemetry.categories)
    return _impl_.categories_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* UsbTelemetry::mutable_categories()
{
    // @@protoc_insertion_point(field_mutable_list:reporting.UsbTelemetry.categories)
    return &_impl_.categories_;
}

// optional int32 class_id = 6;
inline bool UsbTelemetry::_internal_has_class_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool UsbTelemetry::has_class_id() const
{
    return _internal_has_class_id();
}
inline void UsbTelemetry::clear_class_id()
{
    _impl_.class_id_ = 0;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t UsbTelemetry::_internal_class_id() const
{
    return _impl_.class_id_;
}
inline int32_t UsbTelemetry::class_id() const
{
    // @@protoc_insertion_point(field_get:reporting.UsbTelemetry.class_id)
    return _internal_class_id();
}
inline void UsbTelemetry::_internal_set_class_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.class_id_ = value;
}
inline void UsbTelemetry::set_class_id(int32_t value)
{
    _internal_set_class_id(value);
    // @@protoc_insertion_point(field_set:reporting.UsbTelemetry.class_id)
}

// optional int32 subclass_id = 7;
inline bool UsbTelemetry::_internal_has_subclass_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool UsbTelemetry::has_subclass_id() const
{
    return _internal_has_subclass_id();
}
inline void UsbTelemetry::clear_subclass_id()
{
    _impl_.subclass_id_ = 0;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t UsbTelemetry::_internal_subclass_id() const
{
    return _impl_.subclass_id_;
}
inline int32_t UsbTelemetry::subclass_id() const
{
    // @@protoc_insertion_point(field_get:reporting.UsbTelemetry.subclass_id)
    return _internal_subclass_id();
}
inline void UsbTelemetry::_internal_set_subclass_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.subclass_id_ = value;
}
inline void UsbTelemetry::set_subclass_id(int32_t value)
{
    _internal_set_subclass_id(value);
    // @@protoc_insertion_point(field_set:reporting.UsbTelemetry.subclass_id)
}

// optional string firmware_version = 8;
inline bool UsbTelemetry::_internal_has_firmware_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool UsbTelemetry::has_firmware_version() const
{
    return _internal_has_firmware_version();
}
inline void UsbTelemetry::clear_firmware_version()
{
    _impl_.firmware_version_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UsbTelemetry::firmware_version() const
{
    // @@protoc_insertion_point(field_get:reporting.UsbTelemetry.firmware_version)
    return _internal_firmware_version();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void UsbTelemetry::set_firmware_version(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.firmware_version_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.UsbTelemetry.firmware_version)
}
inline std::string* UsbTelemetry::mutable_firmware_version()
{
    std::string* _s = _internal_mutable_firmware_version();
    // @@protoc_insertion_point(field_mutable:reporting.UsbTelemetry.firmware_version)
    return _s;
}
inline const std::string& UsbTelemetry::_internal_firmware_version() const
{
    return _impl_.firmware_version_.Get();
}
inline void UsbTelemetry::_internal_set_firmware_version(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.firmware_version_.Set(value, GetArenaForAllocation());
}
inline std::string* UsbTelemetry::_internal_mutable_firmware_version()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.firmware_version_.Mutable(GetArenaForAllocation());
}
inline std::string* UsbTelemetry::release_firmware_version()
{
    // @@protoc_insertion_point(field_release:reporting.UsbTelemetry.firmware_version)
    if (!_internal_has_firmware_version()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.firmware_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.firmware_version_.IsDefault()) {
        _impl_.firmware_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void UsbTelemetry::set_allocated_firmware_version(std::string* firmware_version)
{
    if (firmware_version != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.firmware_version_.SetAllocated(firmware_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.firmware_version_.IsDefault()) {
        _impl_.firmware_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.UsbTelemetry.firmware_version)
}

// -------------------------------------------------------------------

// FatalCrashTelemetry

// optional .reporting.FatalCrashTelemetry.CrashType type = 1;
inline bool FatalCrashTelemetry::_internal_has_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool FatalCrashTelemetry::has_type() const
{
    return _internal_has_type();
}
inline void FatalCrashTelemetry::clear_type()
{
    _impl_.type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::reporting::FatalCrashTelemetry_CrashType FatalCrashTelemetry::_internal_type() const
{
    return static_cast<::reporting::FatalCrashTelemetry_CrashType>(_impl_.type_);
}
inline ::reporting::FatalCrashTelemetry_CrashType FatalCrashTelemetry::type() const
{
    // @@protoc_insertion_point(field_get:reporting.FatalCrashTelemetry.type)
    return _internal_type();
}
inline void FatalCrashTelemetry::_internal_set_type(::reporting::FatalCrashTelemetry_CrashType value)
{
    assert(::reporting::FatalCrashTelemetry_CrashType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.type_ = value;
}
inline void FatalCrashTelemetry::set_type(::reporting::FatalCrashTelemetry_CrashType value)
{
    _internal_set_type(value);
    // @@protoc_insertion_point(field_set:reporting.FatalCrashTelemetry.type)
}

// optional .reporting.FatalCrashTelemetry.SessionType session_type = 2;
inline bool FatalCrashTelemetry::_internal_has_session_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool FatalCrashTelemetry::has_session_type() const
{
    return _internal_has_session_type();
}
inline void FatalCrashTelemetry::clear_session_type()
{
    _impl_.session_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::reporting::FatalCrashTelemetry_SessionType FatalCrashTelemetry::_internal_session_type() const
{
    return static_cast<::reporting::FatalCrashTelemetry_SessionType>(_impl_.session_type_);
}
inline ::reporting::FatalCrashTelemetry_SessionType FatalCrashTelemetry::session_type() const
{
    // @@protoc_insertion_point(field_get:reporting.FatalCrashTelemetry.session_type)
    return _internal_session_type();
}
inline void FatalCrashTelemetry::_internal_set_session_type(::reporting::FatalCrashTelemetry_SessionType value)
{
    assert(::reporting::FatalCrashTelemetry_SessionType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.session_type_ = value;
}
inline void FatalCrashTelemetry::set_session_type(::reporting::FatalCrashTelemetry_SessionType value)
{
    _internal_set_session_type(value);
    // @@protoc_insertion_point(field_set:reporting.FatalCrashTelemetry.session_type)
}

// optional int64 timestamp_us = 3;
inline bool FatalCrashTelemetry::_internal_has_timestamp_us() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool FatalCrashTelemetry::has_timestamp_us() const
{
    return _internal_has_timestamp_us();
}
inline void FatalCrashTelemetry::clear_timestamp_us()
{
    _impl_.timestamp_us_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int64_t FatalCrashTelemetry::_internal_timestamp_us() const
{
    return _impl_.timestamp_us_;
}
inline int64_t FatalCrashTelemetry::timestamp_us() const
{
    // @@protoc_insertion_point(field_get:reporting.FatalCrashTelemetry.timestamp_us)
    return _internal_timestamp_us();
}
inline void FatalCrashTelemetry::_internal_set_timestamp_us(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.timestamp_us_ = value;
}
inline void FatalCrashTelemetry::set_timestamp_us(int64_t value)
{
    _internal_set_timestamp_us(value);
    // @@protoc_insertion_point(field_set:reporting.FatalCrashTelemetry.timestamp_us)
}

// optional .reporting.SessionAffiliatedUser affiliated_user = 4;
inline bool FatalCrashTelemetry::_internal_has_affiliated_user() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.affiliated_user_ != nullptr);
    return value;
}
inline bool FatalCrashTelemetry::has_affiliated_user() const
{
    return _internal_has_affiliated_user();
}
inline const ::reporting::SessionAffiliatedUser& FatalCrashTelemetry::_internal_affiliated_user() const
{
    const ::reporting::SessionAffiliatedUser* p = _impl_.affiliated_user_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::SessionAffiliatedUser&>(::reporting::_SessionAffiliatedUser_default_instance_);
}
inline const ::reporting::SessionAffiliatedUser& FatalCrashTelemetry::affiliated_user() const
{
    // @@protoc_insertion_point(field_get:reporting.FatalCrashTelemetry.affiliated_user)
    return _internal_affiliated_user();
}
inline void FatalCrashTelemetry::unsafe_arena_set_allocated_affiliated_user(::reporting::SessionAffiliatedUser* affiliated_user)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.affiliated_user_);
    }
    _impl_.affiliated_user_ = affiliated_user;
    if (affiliated_user) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.FatalCrashTelemetry.affiliated_user)
}
inline ::reporting::SessionAffiliatedUser* FatalCrashTelemetry::release_affiliated_user()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::reporting::SessionAffiliatedUser* temp = _impl_.affiliated_user_;
    _impl_.affiliated_user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::SessionAffiliatedUser* FatalCrashTelemetry::unsafe_arena_release_affiliated_user()
{
    // @@protoc_insertion_point(field_release:reporting.FatalCrashTelemetry.affiliated_user)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::reporting::SessionAffiliatedUser* temp = _impl_.affiliated_user_;
    _impl_.affiliated_user_ = nullptr;
    return temp;
}
inline ::reporting::SessionAffiliatedUser* FatalCrashTelemetry::_internal_mutable_affiliated_user()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.affiliated_user_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::SessionAffiliatedUser>(GetArenaForAllocation());
        _impl_.affiliated_user_ = p;
    }
    return _impl_.affiliated_user_;
}
inline ::reporting::SessionAffiliatedUser* FatalCrashTelemetry::mutable_affiliated_user()
{
    ::reporting::SessionAffiliatedUser* _msg = _internal_mutable_affiliated_user();
    // @@protoc_insertion_point(field_mutable:reporting.FatalCrashTelemetry.affiliated_user)
    return _msg;
}
inline void FatalCrashTelemetry::set_allocated_affiliated_user(::reporting::SessionAffiliatedUser* affiliated_user)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.affiliated_user_);
    }
    if (affiliated_user) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(affiliated_user));
        if (message_arena != submessage_arena) {
            affiliated_user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, affiliated_user, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.affiliated_user_ = affiliated_user;
    // @@protoc_insertion_point(field_set_allocated:reporting.FatalCrashTelemetry.affiliated_user)
}

// optional string crash_report_id = 5;
inline bool FatalCrashTelemetry::_internal_has_crash_report_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool FatalCrashTelemetry::has_crash_report_id() const
{
    return _internal_has_crash_report_id();
}
inline void FatalCrashTelemetry::clear_crash_report_id()
{
    _impl_.crash_report_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FatalCrashTelemetry::crash_report_id() const
{
    // @@protoc_insertion_point(field_get:reporting.FatalCrashTelemetry.crash_report_id)
    return _internal_crash_report_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FatalCrashTelemetry::set_crash_report_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.crash_report_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.FatalCrashTelemetry.crash_report_id)
}
inline std::string* FatalCrashTelemetry::mutable_crash_report_id()
{
    std::string* _s = _internal_mutable_crash_report_id();
    // @@protoc_insertion_point(field_mutable:reporting.FatalCrashTelemetry.crash_report_id)
    return _s;
}
inline const std::string& FatalCrashTelemetry::_internal_crash_report_id() const
{
    return _impl_.crash_report_id_.Get();
}
inline void FatalCrashTelemetry::_internal_set_crash_report_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.crash_report_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FatalCrashTelemetry::_internal_mutable_crash_report_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.crash_report_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FatalCrashTelemetry::release_crash_report_id()
{
    // @@protoc_insertion_point(field_release:reporting.FatalCrashTelemetry.crash_report_id)
    if (!_internal_has_crash_report_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.crash_report_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.crash_report_id_.IsDefault()) {
        _impl_.crash_report_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void FatalCrashTelemetry::set_allocated_crash_report_id(std::string* crash_report_id)
{
    if (crash_report_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.crash_report_id_.SetAllocated(crash_report_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.crash_report_id_.IsDefault()) {
        _impl_.crash_report_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.FatalCrashTelemetry.crash_report_id)
}

// optional string local_id = 6;
inline bool FatalCrashTelemetry::_internal_has_local_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool FatalCrashTelemetry::has_local_id() const
{
    return _internal_has_local_id();
}
inline void FatalCrashTelemetry::clear_local_id()
{
    _impl_.local_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FatalCrashTelemetry::local_id() const
{
    // @@protoc_insertion_point(field_get:reporting.FatalCrashTelemetry.local_id)
    return _internal_local_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FatalCrashTelemetry::set_local_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.local_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.FatalCrashTelemetry.local_id)
}
inline std::string* FatalCrashTelemetry::mutable_local_id()
{
    std::string* _s = _internal_mutable_local_id();
    // @@protoc_insertion_point(field_mutable:reporting.FatalCrashTelemetry.local_id)
    return _s;
}
inline const std::string& FatalCrashTelemetry::_internal_local_id() const
{
    return _impl_.local_id_.Get();
}
inline void FatalCrashTelemetry::_internal_set_local_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.local_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FatalCrashTelemetry::_internal_mutable_local_id()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.local_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FatalCrashTelemetry::release_local_id()
{
    // @@protoc_insertion_point(field_release:reporting.FatalCrashTelemetry.local_id)
    if (!_internal_has_local_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.local_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.local_id_.IsDefault()) {
        _impl_.local_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void FatalCrashTelemetry::set_allocated_local_id(std::string* local_id)
{
    if (local_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.local_id_.SetAllocated(local_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.local_id_.IsDefault()) {
        _impl_.local_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.FatalCrashTelemetry.local_id)
}

// optional bool been_reported_without_crash_report_id = 7;
inline bool FatalCrashTelemetry::_internal_has_been_reported_without_crash_report_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool FatalCrashTelemetry::has_been_reported_without_crash_report_id() const
{
    return _internal_has_been_reported_without_crash_report_id();
}
inline void FatalCrashTelemetry::clear_been_reported_without_crash_report_id()
{
    _impl_.been_reported_without_crash_report_id_ = false;
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool FatalCrashTelemetry::_internal_been_reported_without_crash_report_id() const
{
    return _impl_.been_reported_without_crash_report_id_;
}
inline bool FatalCrashTelemetry::been_reported_without_crash_report_id() const
{
    // @@protoc_insertion_point(field_get:reporting.FatalCrashTelemetry.been_reported_without_crash_report_id)
    return _internal_been_reported_without_crash_report_id();
}
inline void FatalCrashTelemetry::_internal_set_been_reported_without_crash_report_id(bool value)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.been_reported_without_crash_report_id_ = value;
}
inline void FatalCrashTelemetry::set_been_reported_without_crash_report_id(bool value)
{
    _internal_set_been_reported_without_crash_report_id(value);
    // @@protoc_insertion_point(field_set:reporting.FatalCrashTelemetry.been_reported_without_crash_report_id)
}

// optional string event_based_log_id = 8;
inline bool FatalCrashTelemetry::_internal_has_event_based_log_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool FatalCrashTelemetry::has_event_based_log_id() const
{
    return _internal_has_event_based_log_id();
}
inline void FatalCrashTelemetry::clear_event_based_log_id()
{
    _impl_.event_based_log_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FatalCrashTelemetry::event_based_log_id() const
{
    // @@protoc_insertion_point(field_get:reporting.FatalCrashTelemetry.event_based_log_id)
    return _internal_event_based_log_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FatalCrashTelemetry::set_event_based_log_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.event_based_log_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:reporting.FatalCrashTelemetry.event_based_log_id)
}
inline std::string* FatalCrashTelemetry::mutable_event_based_log_id()
{
    std::string* _s = _internal_mutable_event_based_log_id();
    // @@protoc_insertion_point(field_mutable:reporting.FatalCrashTelemetry.event_based_log_id)
    return _s;
}
inline const std::string& FatalCrashTelemetry::_internal_event_based_log_id() const
{
    return _impl_.event_based_log_id_.Get();
}
inline void FatalCrashTelemetry::_internal_set_event_based_log_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.event_based_log_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FatalCrashTelemetry::_internal_mutable_event_based_log_id()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.event_based_log_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FatalCrashTelemetry::release_event_based_log_id()
{
    // @@protoc_insertion_point(field_release:reporting.FatalCrashTelemetry.event_based_log_id)
    if (!_internal_has_event_based_log_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.event_based_log_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.event_based_log_id_.IsDefault()) {
        _impl_.event_based_log_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void FatalCrashTelemetry::set_allocated_event_based_log_id(std::string* event_based_log_id)
{
    if (event_based_log_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.event_based_log_id_.SetAllocated(event_based_log_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.event_based_log_id_.IsDefault()) {
        _impl_.event_based_log_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:reporting.FatalCrashTelemetry.event_based_log_id)
}

// -------------------------------------------------------------------

// RuntimeCountersTelemetry

// optional int64 uptime_runtime_seconds = 1;
inline bool RuntimeCountersTelemetry::_internal_has_uptime_runtime_seconds() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool RuntimeCountersTelemetry::has_uptime_runtime_seconds() const
{
    return _internal_has_uptime_runtime_seconds();
}
inline void RuntimeCountersTelemetry::clear_uptime_runtime_seconds()
{
    _impl_.uptime_runtime_seconds_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t RuntimeCountersTelemetry::_internal_uptime_runtime_seconds() const
{
    return _impl_.uptime_runtime_seconds_;
}
inline int64_t RuntimeCountersTelemetry::uptime_runtime_seconds() const
{
    // @@protoc_insertion_point(field_get:reporting.RuntimeCountersTelemetry.uptime_runtime_seconds)
    return _internal_uptime_runtime_seconds();
}
inline void RuntimeCountersTelemetry::_internal_set_uptime_runtime_seconds(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.uptime_runtime_seconds_ = value;
}
inline void RuntimeCountersTelemetry::set_uptime_runtime_seconds(int64_t value)
{
    _internal_set_uptime_runtime_seconds(value);
    // @@protoc_insertion_point(field_set:reporting.RuntimeCountersTelemetry.uptime_runtime_seconds)
}

// optional int64 counter_enter_sleep = 2;
inline bool RuntimeCountersTelemetry::_internal_has_counter_enter_sleep() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool RuntimeCountersTelemetry::has_counter_enter_sleep() const
{
    return _internal_has_counter_enter_sleep();
}
inline void RuntimeCountersTelemetry::clear_counter_enter_sleep()
{
    _impl_.counter_enter_sleep_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t RuntimeCountersTelemetry::_internal_counter_enter_sleep() const
{
    return _impl_.counter_enter_sleep_;
}
inline int64_t RuntimeCountersTelemetry::counter_enter_sleep() const
{
    // @@protoc_insertion_point(field_get:reporting.RuntimeCountersTelemetry.counter_enter_sleep)
    return _internal_counter_enter_sleep();
}
inline void RuntimeCountersTelemetry::_internal_set_counter_enter_sleep(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.counter_enter_sleep_ = value;
}
inline void RuntimeCountersTelemetry::set_counter_enter_sleep(int64_t value)
{
    _internal_set_counter_enter_sleep(value);
    // @@protoc_insertion_point(field_set:reporting.RuntimeCountersTelemetry.counter_enter_sleep)
}

// optional int64 counter_enter_hibernation = 3;
inline bool RuntimeCountersTelemetry::_internal_has_counter_enter_hibernation() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool RuntimeCountersTelemetry::has_counter_enter_hibernation() const
{
    return _internal_has_counter_enter_hibernation();
}
inline void RuntimeCountersTelemetry::clear_counter_enter_hibernation()
{
    _impl_.counter_enter_hibernation_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t RuntimeCountersTelemetry::_internal_counter_enter_hibernation() const
{
    return _impl_.counter_enter_hibernation_;
}
inline int64_t RuntimeCountersTelemetry::counter_enter_hibernation() const
{
    // @@protoc_insertion_point(field_get:reporting.RuntimeCountersTelemetry.counter_enter_hibernation)
    return _internal_counter_enter_hibernation();
}
inline void RuntimeCountersTelemetry::_internal_set_counter_enter_hibernation(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.counter_enter_hibernation_ = value;
}
inline void RuntimeCountersTelemetry::set_counter_enter_hibernation(int64_t value)
{
    _internal_set_counter_enter_hibernation(value);
    // @@protoc_insertion_point(field_set:reporting.RuntimeCountersTelemetry.counter_enter_hibernation)
}

// optional int64 counter_enter_poweroff = 4;
inline bool RuntimeCountersTelemetry::_internal_has_counter_enter_poweroff() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool RuntimeCountersTelemetry::has_counter_enter_poweroff() const
{
    return _internal_has_counter_enter_poweroff();
}
inline void RuntimeCountersTelemetry::clear_counter_enter_poweroff()
{
    _impl_.counter_enter_poweroff_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t RuntimeCountersTelemetry::_internal_counter_enter_poweroff() const
{
    return _impl_.counter_enter_poweroff_;
}
inline int64_t RuntimeCountersTelemetry::counter_enter_poweroff() const
{
    // @@protoc_insertion_point(field_get:reporting.RuntimeCountersTelemetry.counter_enter_poweroff)
    return _internal_counter_enter_poweroff();
}
inline void RuntimeCountersTelemetry::_internal_set_counter_enter_poweroff(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.counter_enter_poweroff_ = value;
}
inline void RuntimeCountersTelemetry::set_counter_enter_poweroff(int64_t value)
{
    _internal_set_counter_enter_poweroff(value);
    // @@protoc_insertion_point(field_set:reporting.RuntimeCountersTelemetry.counter_enter_poweroff)
}

// -------------------------------------------------------------------

// EventData

// optional .reporting.MetricEventType type = 1;
inline bool EventData::_internal_has_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool EventData::has_type() const
{
    return _internal_has_type();
}
inline void EventData::clear_type()
{
    _impl_.type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::reporting::MetricEventType EventData::_internal_type() const
{
    return static_cast<::reporting::MetricEventType>(_impl_.type_);
}
inline ::reporting::MetricEventType EventData::type() const
{
    // @@protoc_insertion_point(field_get:reporting.EventData.type)
    return _internal_type();
}
inline void EventData::_internal_set_type(::reporting::MetricEventType value)
{
    assert(::reporting::MetricEventType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.type_ = value;
}
inline void EventData::set_type(::reporting::MetricEventType value)
{
    _internal_set_type(value);
    // @@protoc_insertion_point(field_set:reporting.EventData.type)
}

// -------------------------------------------------------------------

// MetricData

// optional int64 timestamp_ms = 1;
inline bool MetricData::_internal_has_timestamp_ms() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool MetricData::has_timestamp_ms() const
{
    return _internal_has_timestamp_ms();
}
inline void MetricData::clear_timestamp_ms()
{
    _impl_.timestamp_ms_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t MetricData::_internal_timestamp_ms() const
{
    return _impl_.timestamp_ms_;
}
inline int64_t MetricData::timestamp_ms() const
{
    // @@protoc_insertion_point(field_get:reporting.MetricData.timestamp_ms)
    return _internal_timestamp_ms();
}
inline void MetricData::_internal_set_timestamp_ms(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.timestamp_ms_ = value;
}
inline void MetricData::set_timestamp_ms(int64_t value)
{
    _internal_set_timestamp_ms(value);
    // @@protoc_insertion_point(field_set:reporting.MetricData.timestamp_ms)
}

// .reporting.InfoData info_data = 2;
inline bool MetricData::_internal_has_info_data() const
{
    return metric_type_case() == kInfoData;
}
inline bool MetricData::has_info_data() const
{
    return _internal_has_info_data();
}
inline void MetricData::set_has_info_data()
{
    _impl_._oneof_case_[0] = kInfoData;
}
inline void MetricData::clear_info_data()
{
    if (_internal_has_info_data()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.metric_type_.info_data_;
        }
        clear_has_metric_type();
    }
}
inline ::reporting::InfoData* MetricData::release_info_data()
{
    // @@protoc_insertion_point(field_release:reporting.MetricData.info_data)
    if (_internal_has_info_data()) {
        clear_has_metric_type();
        ::reporting::InfoData* temp = _impl_.metric_type_.info_data_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.metric_type_.info_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::InfoData& MetricData::_internal_info_data() const
{
    return _internal_has_info_data() ? *_impl_.metric_type_.info_data_ : reinterpret_cast<::reporting::InfoData&>(::reporting::_InfoData_default_instance_);
}
inline const ::reporting::InfoData& MetricData::info_data() const
{
    // @@protoc_insertion_point(field_get:reporting.MetricData.info_data)
    return _internal_info_data();
}
inline ::reporting::InfoData* MetricData::unsafe_arena_release_info_data()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.MetricData.info_data)
    if (_internal_has_info_data()) {
        clear_has_metric_type();
        ::reporting::InfoData* temp = _impl_.metric_type_.info_data_;
        _impl_.metric_type_.info_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void MetricData::unsafe_arena_set_allocated_info_data(::reporting::InfoData* info_data)
{
    clear_metric_type();
    if (info_data) {
        set_has_info_data();
        _impl_.metric_type_.info_data_ = info_data;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.MetricData.info_data)
}
inline ::reporting::InfoData* MetricData::_internal_mutable_info_data()
{
    if (!_internal_has_info_data()) {
        clear_metric_type();
        set_has_info_data();
        _impl_.metric_type_.info_data_ = CreateMaybeMessage<::reporting::InfoData>(GetArenaForAllocation());
    }
    return _impl_.metric_type_.info_data_;
}
inline ::reporting::InfoData* MetricData::mutable_info_data()
{
    ::reporting::InfoData* _msg = _internal_mutable_info_data();
    // @@protoc_insertion_point(field_mutable:reporting.MetricData.info_data)
    return _msg;
}

// .reporting.TelemetryData telemetry_data = 3;
inline bool MetricData::_internal_has_telemetry_data() const
{
    return metric_type_case() == kTelemetryData;
}
inline bool MetricData::has_telemetry_data() const
{
    return _internal_has_telemetry_data();
}
inline void MetricData::set_has_telemetry_data()
{
    _impl_._oneof_case_[0] = kTelemetryData;
}
inline void MetricData::clear_telemetry_data()
{
    if (_internal_has_telemetry_data()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.metric_type_.telemetry_data_;
        }
        clear_has_metric_type();
    }
}
inline ::reporting::TelemetryData* MetricData::release_telemetry_data()
{
    // @@protoc_insertion_point(field_release:reporting.MetricData.telemetry_data)
    if (_internal_has_telemetry_data()) {
        clear_has_metric_type();
        ::reporting::TelemetryData* temp = _impl_.metric_type_.telemetry_data_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.metric_type_.telemetry_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::reporting::TelemetryData& MetricData::_internal_telemetry_data() const
{
    return _internal_has_telemetry_data() ? *_impl_.metric_type_.telemetry_data_
                                          : reinterpret_cast<::reporting::TelemetryData&>(::reporting::_TelemetryData_default_instance_);
}
inline const ::reporting::TelemetryData& MetricData::telemetry_data() const
{
    // @@protoc_insertion_point(field_get:reporting.MetricData.telemetry_data)
    return _internal_telemetry_data();
}
inline ::reporting::TelemetryData* MetricData::unsafe_arena_release_telemetry_data()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:reporting.MetricData.telemetry_data)
    if (_internal_has_telemetry_data()) {
        clear_has_metric_type();
        ::reporting::TelemetryData* temp = _impl_.metric_type_.telemetry_data_;
        _impl_.metric_type_.telemetry_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void MetricData::unsafe_arena_set_allocated_telemetry_data(::reporting::TelemetryData* telemetry_data)
{
    clear_metric_type();
    if (telemetry_data) {
        set_has_telemetry_data();
        _impl_.metric_type_.telemetry_data_ = telemetry_data;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.MetricData.telemetry_data)
}
inline ::reporting::TelemetryData* MetricData::_internal_mutable_telemetry_data()
{
    if (!_internal_has_telemetry_data()) {
        clear_metric_type();
        set_has_telemetry_data();
        _impl_.metric_type_.telemetry_data_ = CreateMaybeMessage<::reporting::TelemetryData>(GetArenaForAllocation());
    }
    return _impl_.metric_type_.telemetry_data_;
}
inline ::reporting::TelemetryData* MetricData::mutable_telemetry_data()
{
    ::reporting::TelemetryData* _msg = _internal_mutable_telemetry_data();
    // @@protoc_insertion_point(field_mutable:reporting.MetricData.telemetry_data)
    return _msg;
}

// optional .reporting.EventData event_data = 4;
inline bool MetricData::_internal_has_event_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.event_data_ != nullptr);
    return value;
}
inline bool MetricData::has_event_data() const
{
    return _internal_has_event_data();
}
inline void MetricData::clear_event_data()
{
    if (_impl_.event_data_ != nullptr)
        _impl_.event_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::reporting::EventData& MetricData::_internal_event_data() const
{
    const ::reporting::EventData* p = _impl_.event_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::reporting::EventData&>(::reporting::_EventData_default_instance_);
}
inline const ::reporting::EventData& MetricData::event_data() const
{
    // @@protoc_insertion_point(field_get:reporting.MetricData.event_data)
    return _internal_event_data();
}
inline void MetricData::unsafe_arena_set_allocated_event_data(::reporting::EventData* event_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.event_data_);
    }
    _impl_.event_data_ = event_data;
    if (event_data) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:reporting.MetricData.event_data)
}
inline ::reporting::EventData* MetricData::release_event_data()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::EventData* temp = _impl_.event_data_;
    _impl_.event_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::reporting::EventData* MetricData::unsafe_arena_release_event_data()
{
    // @@protoc_insertion_point(field_release:reporting.MetricData.event_data)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::reporting::EventData* temp = _impl_.event_data_;
    _impl_.event_data_ = nullptr;
    return temp;
}
inline ::reporting::EventData* MetricData::_internal_mutable_event_data()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.event_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::reporting::EventData>(GetArenaForAllocation());
        _impl_.event_data_ = p;
    }
    return _impl_.event_data_;
}
inline ::reporting::EventData* MetricData::mutable_event_data()
{
    ::reporting::EventData* _msg = _internal_mutable_event_data();
    // @@protoc_insertion_point(field_mutable:reporting.MetricData.event_data)
    return _msg;
}
inline void MetricData::set_allocated_event_data(::reporting::EventData* event_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.event_data_;
    }
    if (event_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(event_data);
        if (message_arena != submessage_arena) {
            event_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, event_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.event_data_ = event_data;
    // @@protoc_insertion_point(field_set_allocated:reporting.MetricData.event_data)
}

inline bool MetricData::has_metric_type() const
{
    return metric_type_case() != METRIC_TYPE_NOT_SET;
}
inline void MetricData::clear_has_metric_type()
{
    _impl_._oneof_case_[0] = METRIC_TYPE_NOT_SET;
}
inline MetricData::MetricTypeCase MetricData::metric_type_case() const
{
    return MetricData::MetricTypeCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace reporting

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::reporting::UserStatusTelemetry_DeviceActivityState> : ::std::true_type { };
template <> struct is_proto_enum<::reporting::KioskVisionStatusReport_KioskVisionState> : ::std::true_type { };
template <> struct is_proto_enum<::reporting::FatalCrashTelemetry_CrashType> : ::std::true_type { };
template <> struct is_proto_enum<::reporting::FatalCrashTelemetry_SessionType> : ::std::true_type { };
template <> struct is_proto_enum<::reporting::RoutineVerdict> : ::std::true_type { };
template <> struct is_proto_enum<::reporting::HttpsLatencyProblem> : ::std::true_type { };
template <> struct is_proto_enum<::reporting::NetworkConnectionState> : ::std::true_type { };
template <> struct is_proto_enum<::reporting::NetworkType> : ::std::true_type { };
template <> struct is_proto_enum<::reporting::ThunderboltSecurityLevel> : ::std::true_type { };
template <> struct is_proto_enum<::reporting::MemoryEncryptionState> : ::std::true_type { };
template <> struct is_proto_enum<::reporting::MemoryEncryptionAlgorithm> : ::std::true_type { };
template <> struct is_proto_enum<::reporting::NetworkDeviceType> : ::std::true_type { };
template <> struct is_proto_enum<::reporting::MetricEventType> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2freporting_2fproto_2fsynced_2fmetric_5fdata_2eproto
