// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: translate_ranker_model.proto

#include "translate_ranker_model.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace assist_ranker {
PROTOBUF_CONSTEXPR TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse::
    TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse(::_pbi::ConstantInitialized)
{
}
struct TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUseDefaultTypeInternal()
    {
    }
    union {
        TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUseDefaultTypeInternal
        _TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse::
    TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse(::_pbi::ConstantInitialized)
{
}
struct TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUseDefaultTypeInternal()
    {
    }
    union {
        TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUseDefaultTypeInternal
        _TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse::
    TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse(::_pbi::ConstantInitialized)
{
}
struct TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUseDefaultTypeInternal()
    {
    }
    union {
        TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUseDefaultTypeInternal
        _TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse::
    TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse(::_pbi::ConstantInitialized)
{
}
struct TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUseDefaultTypeInternal()
    {
    }
    union {
        TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
    TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUseDefaultTypeInternal
        _TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR TranslateRankerModel_TranslateLogisticRegressionModel::TranslateRankerModel_TranslateLogisticRegressionModel(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.source_language_weight_)*/ {},
        /*decltype(_impl_.target_language_weight_)*/ {}, /*decltype(_impl_.country_weight_)*/ {}, /*decltype(_impl_.locale_weight_)*/ {},
        /*decltype(_impl_.bias_)*/ 0, /*decltype(_impl_.accept_ratio_weight_)*/ 0, /*decltype(_impl_.decline_ratio_weight_)*/ 0,
        /*decltype(_impl_.ignore_ratio_weight_)*/ 0, /*decltype(_impl_.accept_count_weight_)*/ 0, /*decltype(_impl_.decline_count_weight_)*/ 0,
        /*decltype(_impl_.ignore_count_weight_)*/ 0, /*decltype(_impl_.threshold_)*/ 0 }
{
}
struct TranslateRankerModel_TranslateLogisticRegressionModelDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TranslateRankerModel_TranslateLogisticRegressionModelDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TranslateRankerModel_TranslateLogisticRegressionModelDefaultTypeInternal()
    {
    }
    union {
        TranslateRankerModel_TranslateLogisticRegressionModel _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TranslateRankerModel_TranslateLogisticRegressionModelDefaultTypeInternal
    _TranslateRankerModel_TranslateLogisticRegressionModel_default_instance_;
PROTOBUF_CONSTEXPR TranslateRankerModel::TranslateRankerModel(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.version_)*/ 0u,
        /*decltype(_impl_.model_revision_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct TranslateRankerModelDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TranslateRankerModelDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TranslateRankerModelDefaultTypeInternal()
    {
    }
    union {
        TranslateRankerModel _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TranslateRankerModelDefaultTypeInternal
    _TranslateRankerModel_default_instance_;
} // namespace assist_ranker
namespace assist_ranker {

// ===================================================================

TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse::
    TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse()
{
}
TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse::
    TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena)
{
}
void TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse::MergeFrom(
    const TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse& other)
{
    MergeFromInternal(other);
}

// ===================================================================

TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse::
    TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse()
{
}
TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse::
    TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena)
{
}
void TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse::MergeFrom(
    const TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse& other)
{
    MergeFromInternal(other);
}

// ===================================================================

TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse::
    TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse()
{
}
TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse::
    TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena)
{
}
void TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse::MergeFrom(
    const TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse& other)
{
    MergeFromInternal(other);
}

// ===================================================================

TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse::
    TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse()
{
}
TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse::
    TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena)
{
}
void TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse::MergeFrom(
    const TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse& other)
{
    MergeFromInternal(other);
}

// ===================================================================

class TranslateRankerModel_TranslateLogisticRegressionModel::_Internal {
public:
    using HasBits = decltype(std::declval<TranslateRankerModel_TranslateLogisticRegressionModel>()._impl_._has_bits_);
    static void set_has_threshold(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_bias(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_accept_ratio_weight(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_decline_ratio_weight(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_ignore_ratio_weight(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_accept_count_weight(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_decline_count_weight(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_ignore_count_weight(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
};

TranslateRankerModel_TranslateLogisticRegressionModel::TranslateRankerModel_TranslateLogisticRegressionModel(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:assist_ranker.TranslateRankerModel.TranslateLogisticRegressionModel)
}
TranslateRankerModel_TranslateLogisticRegressionModel::TranslateRankerModel_TranslateLogisticRegressionModel(
    const TranslateRankerModel_TranslateLogisticRegressionModel& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TranslateRankerModel_TranslateLogisticRegressionModel* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.source_language_weight_)*/ {}, /*decltype(_impl_.target_language_weight_)*/ {}, /*decltype(_impl_.country_weight_)*/ {},
        /*decltype(_impl_.locale_weight_)*/ {}, decltype(_impl_.bias_) {}, decltype(_impl_.accept_ratio_weight_) {}, decltype(_impl_.decline_ratio_weight_) {},
        decltype(_impl_.ignore_ratio_weight_) {}, decltype(_impl_.accept_count_weight_) {}, decltype(_impl_.decline_count_weight_) {},
        decltype(_impl_.ignore_count_weight_) {}, decltype(_impl_.threshold_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.source_language_weight_.MergeFrom(from._impl_.source_language_weight_);
    _this->_impl_.target_language_weight_.MergeFrom(from._impl_.target_language_weight_);
    _this->_impl_.country_weight_.MergeFrom(from._impl_.country_weight_);
    _this->_impl_.locale_weight_.MergeFrom(from._impl_.locale_weight_);
    ::memcpy(&_impl_.bias_, &from._impl_.bias_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.threshold_) - reinterpret_cast<char*>(&_impl_.bias_)) + sizeof(_impl_.threshold_));
    // @@protoc_insertion_point(copy_constructor:assist_ranker.TranslateRankerModel.TranslateLogisticRegressionModel)
}

inline void TranslateRankerModel_TranslateLogisticRegressionModel::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.source_language_weight_)*/ { ::_pbi::ArenaInitialized(), arena },
        /*decltype(_impl_.target_language_weight_)*/ { ::_pbi::ArenaInitialized(), arena },
        /*decltype(_impl_.country_weight_)*/ { ::_pbi::ArenaInitialized(), arena }, /*decltype(_impl_.locale_weight_)*/ { ::_pbi::ArenaInitialized(), arena },
        decltype(_impl_.bias_) { 0 }, decltype(_impl_.accept_ratio_weight_) { 0 }, decltype(_impl_.decline_ratio_weight_) { 0 },
        decltype(_impl_.ignore_ratio_weight_) { 0 }, decltype(_impl_.accept_count_weight_) { 0 }, decltype(_impl_.decline_count_weight_) { 0 },
        decltype(_impl_.ignore_count_weight_) { 0 }, decltype(_impl_.threshold_) { 0 } };
}

TranslateRankerModel_TranslateLogisticRegressionModel::~TranslateRankerModel_TranslateLogisticRegressionModel()
{
    // @@protoc_insertion_point(destructor:assist_ranker.TranslateRankerModel.TranslateLogisticRegressionModel)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TranslateRankerModel_TranslateLogisticRegressionModel::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.source_language_weight_.Destruct();
    _impl_.source_language_weight_.~MapFieldLite();
    _impl_.target_language_weight_.Destruct();
    _impl_.target_language_weight_.~MapFieldLite();
    _impl_.country_weight_.Destruct();
    _impl_.country_weight_.~MapFieldLite();
    _impl_.locale_weight_.Destruct();
    _impl_.locale_weight_.~MapFieldLite();
}

void TranslateRankerModel_TranslateLogisticRegressionModel::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TranslateRankerModel_TranslateLogisticRegressionModel::Clear()
{
    // @@protoc_insertion_point(message_clear_start:assist_ranker.TranslateRankerModel.TranslateLogisticRegressionModel)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.source_language_weight_.Clear();
    _impl_.target_language_weight_.Clear();
    _impl_.country_weight_.Clear();
    _impl_.locale_weight_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        ::memset(&_impl_.bias_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.threshold_) - reinterpret_cast<char*>(&_impl_.bias_)) + sizeof(_impl_.threshold_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* TranslateRankerModel_TranslateLogisticRegressionModel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional float bias = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
                _Internal::set_has_bias(&has_bits);
                _impl_.bias_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float accept_ratio_weight = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
                _Internal::set_has_accept_ratio_weight(&has_bits);
                _impl_.accept_ratio_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float decline_ratio_weight = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
                _Internal::set_has_decline_ratio_weight(&has_bits);
                _impl_.decline_ratio_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float ignore_ratio_weight = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
                _Internal::set_has_ignore_ratio_weight(&has_bits);
                _impl_.ignore_ratio_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // map<string, float> source_language_weight = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(&_impl_.source_language_weight_, ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // map<string, float> target_language_weight = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(&_impl_.target_language_weight_, ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
            } else
                goto handle_unusual;
            continue;
        // map<string, float> country_weight = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(&_impl_.country_weight_, ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
            } else
                goto handle_unusual;
            continue;
        // map<string, float> locale_weight = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(&_impl_.locale_weight_, ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional float accept_count_weight = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
                _Internal::set_has_accept_count_weight(&has_bits);
                _impl_.accept_count_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float decline_count_weight = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
                _Internal::set_has_decline_count_weight(&has_bits);
                _impl_.decline_count_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float ignore_count_weight = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
                _Internal::set_has_ignore_count_weight(&has_bits);
                _impl_.ignore_count_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float threshold = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
                _Internal::set_has_threshold(&has_bits);
                _impl_.threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TranslateRankerModel_TranslateLogisticRegressionModel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:assist_ranker.TranslateRankerModel.TranslateLogisticRegressionModel)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional float bias = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_bias(), target);
    }

    // optional float accept_ratio_weight = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_accept_ratio_weight(), target);
    }

    // optional float decline_ratio_weight = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_decline_ratio_weight(), target);
    }

    // optional float ignore_ratio_weight = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_ignore_ratio_weight(), target);
    }

    // map<string, float> source_language_weight = 5;
    if (!this->_internal_source_language_weight().empty()) {
        using MapType = ::_pb::Map<std::string, float>;
        using WireHelper = TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse::Funcs;
        const auto& map_field = this->_internal_source_language_weight();
        auto check_utf8 = [](const MapType::value_type& entry) { (void)entry; };

        if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
            for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
                target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        } else {
            for (const auto& entry : map_field) {
                target = WireHelper::InternalSerialize(5, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        }
    }

    // map<string, float> target_language_weight = 6;
    if (!this->_internal_target_language_weight().empty()) {
        using MapType = ::_pb::Map<std::string, float>;
        using WireHelper = TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse::Funcs;
        const auto& map_field = this->_internal_target_language_weight();
        auto check_utf8 = [](const MapType::value_type& entry) { (void)entry; };

        if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
            for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
                target = WireHelper::InternalSerialize(6, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        } else {
            for (const auto& entry : map_field) {
                target = WireHelper::InternalSerialize(6, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        }
    }

    // map<string, float> country_weight = 7;
    if (!this->_internal_country_weight().empty()) {
        using MapType = ::_pb::Map<std::string, float>;
        using WireHelper = TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse::Funcs;
        const auto& map_field = this->_internal_country_weight();
        auto check_utf8 = [](const MapType::value_type& entry) { (void)entry; };

        if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
            for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
                target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        } else {
            for (const auto& entry : map_field) {
                target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        }
    }

    // map<string, float> locale_weight = 8;
    if (!this->_internal_locale_weight().empty()) {
        using MapType = ::_pb::Map<std::string, float>;
        using WireHelper = TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse::Funcs;
        const auto& map_field = this->_internal_locale_weight();
        auto check_utf8 = [](const MapType::value_type& entry) { (void)entry; };

        if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
            for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
                target = WireHelper::InternalSerialize(8, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        } else {
            for (const auto& entry : map_field) {
                target = WireHelper::InternalSerialize(8, entry.first, entry.second, target, stream);
                check_utf8(entry);
            }
        }
    }

    // optional float accept_count_weight = 9;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_accept_count_weight(), target);
    }

    // optional float decline_count_weight = 10;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_decline_count_weight(), target);
    }

    // optional float ignore_count_weight = 11;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_ignore_count_weight(), target);
    }

    // optional float threshold = 12;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_threshold(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:assist_ranker.TranslateRankerModel.TranslateLogisticRegressionModel)
    return target;
}

size_t TranslateRankerModel_TranslateLogisticRegressionModel::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:assist_ranker.TranslateRankerModel.TranslateLogisticRegressionModel)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // map<string, float> source_language_weight = 5;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_source_language_weight_size());
    for (::PROTOBUF_NAMESPACE_ID::Map<std::string, float>::const_iterator it = this->_internal_source_language_weight().begin();
         it != this->_internal_source_language_weight().end(); ++it) {
        total_size += TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
    }

    // map<string, float> target_language_weight = 6;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_target_language_weight_size());
    for (::PROTOBUF_NAMESPACE_ID::Map<std::string, float>::const_iterator it = this->_internal_target_language_weight().begin();
         it != this->_internal_target_language_weight().end(); ++it) {
        total_size += TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
    }

    // map<string, float> country_weight = 7;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_country_weight_size());
    for (::PROTOBUF_NAMESPACE_ID::Map<std::string, float>::const_iterator it = this->_internal_country_weight().begin();
         it != this->_internal_country_weight().end(); ++it) {
        total_size += TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
    }

    // map<string, float> locale_weight = 8;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_locale_weight_size());
    for (::PROTOBUF_NAMESPACE_ID::Map<std::string, float>::const_iterator it = this->_internal_locale_weight().begin();
         it != this->_internal_locale_weight().end(); ++it) {
        total_size += TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional float bias = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 4;
        }

        // optional float accept_ratio_weight = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 4;
        }

        // optional float decline_ratio_weight = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 4;
        }

        // optional float ignore_ratio_weight = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 4;
        }

        // optional float accept_count_weight = 9;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 4;
        }

        // optional float decline_count_weight = 10;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 4;
        }

        // optional float ignore_count_weight = 11;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + 4;
        }

        // optional float threshold = 12;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + 4;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TranslateRankerModel_TranslateLogisticRegressionModel::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TranslateRankerModel_TranslateLogisticRegressionModel*>(&from));
}

void TranslateRankerModel_TranslateLogisticRegressionModel::MergeFrom(const TranslateRankerModel_TranslateLogisticRegressionModel& from)
{
    TranslateRankerModel_TranslateLogisticRegressionModel* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:assist_ranker.TranslateRankerModel.TranslateLogisticRegressionModel)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.source_language_weight_.MergeFrom(from._impl_.source_language_weight_);
    _this->_impl_.target_language_weight_.MergeFrom(from._impl_.target_language_weight_);
    _this->_impl_.country_weight_.MergeFrom(from._impl_.country_weight_);
    _this->_impl_.locale_weight_.MergeFrom(from._impl_.locale_weight_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.bias_ = from._impl_.bias_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.accept_ratio_weight_ = from._impl_.accept_ratio_weight_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.decline_ratio_weight_ = from._impl_.decline_ratio_weight_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.ignore_ratio_weight_ = from._impl_.ignore_ratio_weight_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.accept_count_weight_ = from._impl_.accept_count_weight_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.decline_count_weight_ = from._impl_.decline_count_weight_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.ignore_count_weight_ = from._impl_.ignore_count_weight_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.threshold_ = from._impl_.threshold_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TranslateRankerModel_TranslateLogisticRegressionModel::CopyFrom(const TranslateRankerModel_TranslateLogisticRegressionModel& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:assist_ranker.TranslateRankerModel.TranslateLogisticRegressionModel)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TranslateRankerModel_TranslateLogisticRegressionModel::IsInitialized() const
{
    return true;
}

void TranslateRankerModel_TranslateLogisticRegressionModel::InternalSwap(TranslateRankerModel_TranslateLogisticRegressionModel* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.source_language_weight_.InternalSwap(&other->_impl_.source_language_weight_);
    _impl_.target_language_weight_.InternalSwap(&other->_impl_.target_language_weight_);
    _impl_.country_weight_.InternalSwap(&other->_impl_.country_weight_);
    _impl_.locale_weight_.InternalSwap(&other->_impl_.locale_weight_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(TranslateRankerModel_TranslateLogisticRegressionModel, _impl_.threshold_)
        + sizeof(TranslateRankerModel_TranslateLogisticRegressionModel::_impl_.threshold_)
        - PROTOBUF_FIELD_OFFSET(TranslateRankerModel_TranslateLogisticRegressionModel, _impl_.bias_)>(
        reinterpret_cast<char*>(&_impl_.bias_), reinterpret_cast<char*>(&other->_impl_.bias_));
}

std::string TranslateRankerModel_TranslateLogisticRegressionModel::GetTypeName() const
{
    return "assist_ranker.TranslateRankerModel.TranslateLogisticRegressionModel";
}

// ===================================================================

class TranslateRankerModel::_Internal {
public:
    using HasBits = decltype(std::declval<TranslateRankerModel>()._impl_._has_bits_);
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel& translate_logistic_regression_model(const TranslateRankerModel* msg);
};

const ::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel& TranslateRankerModel::_Internal::translate_logistic_regression_model(
    const TranslateRankerModel* msg)
{
    return *msg->_impl_.model_revision_.translate_logistic_regression_model_;
}
void TranslateRankerModel::set_allocated_translate_logistic_regression_model(
    ::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel* translate_logistic_regression_model)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_model_revision();
    if (translate_logistic_regression_model) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(translate_logistic_regression_model);
        if (message_arena != submessage_arena) {
            translate_logistic_regression_model
                = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, translate_logistic_regression_model, submessage_arena);
        }
        set_has_translate_logistic_regression_model();
        _impl_.model_revision_.translate_logistic_regression_model_ = translate_logistic_regression_model;
    }
    // @@protoc_insertion_point(field_set_allocated:assist_ranker.TranslateRankerModel.translate_logistic_regression_model)
}
TranslateRankerModel::TranslateRankerModel(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:assist_ranker.TranslateRankerModel)
}
TranslateRankerModel::TranslateRankerModel(const TranslateRankerModel& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TranslateRankerModel* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.version_) {},
        decltype(_impl_.model_revision_) {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.version_ = from._impl_.version_;
    clear_has_model_revision();
    switch (from.model_revision_case()) {
    case kTranslateLogisticRegressionModel: {
        _this->_internal_mutable_translate_logistic_regression_model()->::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel::MergeFrom(
            from._internal_translate_logistic_regression_model());
        break;
    }
    case MODEL_REVISION_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:assist_ranker.TranslateRankerModel)
}

inline void TranslateRankerModel::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.version_) { 0u },
        decltype(_impl_.model_revision_) {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_model_revision();
}

TranslateRankerModel::~TranslateRankerModel()
{
    // @@protoc_insertion_point(destructor:assist_ranker.TranslateRankerModel)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TranslateRankerModel::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_model_revision()) {
        clear_model_revision();
    }
}

void TranslateRankerModel::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TranslateRankerModel::clear_model_revision()
{
    // @@protoc_insertion_point(one_of_clear_start:assist_ranker.TranslateRankerModel)
    switch (model_revision_case()) {
    case kTranslateLogisticRegressionModel: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.model_revision_.translate_logistic_regression_model_;
        }
        break;
    }
    case MODEL_REVISION_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = MODEL_REVISION_NOT_SET;
}

void TranslateRankerModel::Clear()
{
    // @@protoc_insertion_point(message_clear_start:assist_ranker.TranslateRankerModel)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.version_ = 0u;
    clear_model_revision();
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* TranslateRankerModel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint32 version = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_version(&has_bits);
                _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .assist_ranker.TranslateRankerModel.TranslateLogisticRegressionModel translate_logistic_regression_model = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_translate_logistic_regression_model(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TranslateRankerModel::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:assist_ranker.TranslateRankerModel)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 version = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
    }

    // .assist_ranker.TranslateRankerModel.TranslateLogisticRegressionModel translate_logistic_regression_model = 2;
    if (_internal_has_translate_logistic_regression_model()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::translate_logistic_regression_model(this), _Internal::translate_logistic_regression_model(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:assist_ranker.TranslateRankerModel)
    return target;
}

size_t TranslateRankerModel::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:assist_ranker.TranslateRankerModel)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional uint32 version = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    switch (model_revision_case()) {
    // .assist_ranker.TranslateRankerModel.TranslateLogisticRegressionModel translate_logistic_regression_model = 2;
    case kTranslateLogisticRegressionModel: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.model_revision_.translate_logistic_regression_model_);
        break;
    }
    case MODEL_REVISION_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TranslateRankerModel::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TranslateRankerModel*>(&from));
}

void TranslateRankerModel::MergeFrom(const TranslateRankerModel& from)
{
    TranslateRankerModel* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:assist_ranker.TranslateRankerModel)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_version()) {
        _this->_internal_set_version(from._internal_version());
    }
    switch (from.model_revision_case()) {
    case kTranslateLogisticRegressionModel: {
        _this->_internal_mutable_translate_logistic_regression_model()->::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel::MergeFrom(
            from._internal_translate_logistic_regression_model());
        break;
    }
    case MODEL_REVISION_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TranslateRankerModel::CopyFrom(const TranslateRankerModel& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:assist_ranker.TranslateRankerModel)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TranslateRankerModel::IsInitialized() const
{
    return true;
}

void TranslateRankerModel::InternalSwap(TranslateRankerModel* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.version_, other->_impl_.version_);
    swap(_impl_.model_revision_, other->_impl_.model_revision_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string TranslateRankerModel::GetTypeName() const
{
    return "assist_ranker.TranslateRankerModel";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace assist_ranker
PROTOBUF_NAMESPACE_OPEN
template <>
PROTOBUF_NOINLINE ::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse*
Arena::CreateMaybeMessage<::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel_SourceLanguageWeightEntry_DoNotUse>(arena);
}
template <>
PROTOBUF_NOINLINE ::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse*
Arena::CreateMaybeMessage<::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel_TargetLanguageWeightEntry_DoNotUse>(arena);
}
template <>
PROTOBUF_NOINLINE ::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse*
Arena::CreateMaybeMessage<::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel_CountryWeightEntry_DoNotUse>(arena);
}
template <>
PROTOBUF_NOINLINE ::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse*
Arena::CreateMaybeMessage<::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel_LocaleWeightEntry_DoNotUse>(arena);
}
template <>
PROTOBUF_NOINLINE ::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel*
Arena::CreateMaybeMessage<::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel>(Arena* arena)
{
    return Arena::CreateMessageInternal<::assist_ranker::TranslateRankerModel_TranslateLogisticRegressionModel>(arena);
}
template <> PROTOBUF_NOINLINE ::assist_ranker::TranslateRankerModel* Arena::CreateMaybeMessage<::assist_ranker::TranslateRankerModel>(Arena* arena)
{
    return Arena::CreateMessageInternal<::assist_ranker::TranslateRankerModel>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
