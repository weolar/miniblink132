// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rules.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_rules_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_rules_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_rules_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_rules_2eproto {
    static const uint32_t offsets[];
};
namespace url_pattern_index {
namespace proto {
class Comment;
struct CommentDefaultTypeInternal;
extern CommentDefaultTypeInternal _Comment_default_instance_;
class CssRule;
struct CssRuleDefaultTypeInternal;
extern CssRuleDefaultTypeInternal _CssRule_default_instance_;
class DomainListItem;
struct DomainListItemDefaultTypeInternal;
extern DomainListItemDefaultTypeInternal _DomainListItem_default_instance_;
class FilteringRules;
struct FilteringRulesDefaultTypeInternal;
extern FilteringRulesDefaultTypeInternal _FilteringRules_default_instance_;
class UrlRule;
struct UrlRuleDefaultTypeInternal;
extern UrlRuleDefaultTypeInternal _UrlRule_default_instance_;
} // namespace proto
} // namespace url_pattern_index
PROTOBUF_NAMESPACE_OPEN
template <>::url_pattern_index::proto::Comment* Arena::CreateMaybeMessage<::url_pattern_index::proto::Comment>(Arena*);
template <>::url_pattern_index::proto::CssRule* Arena::CreateMaybeMessage<::url_pattern_index::proto::CssRule>(Arena*);
template <>::url_pattern_index::proto::DomainListItem* Arena::CreateMaybeMessage<::url_pattern_index::proto::DomainListItem>(Arena*);
template <>::url_pattern_index::proto::FilteringRules* Arena::CreateMaybeMessage<::url_pattern_index::proto::FilteringRules>(Arena*);
template <>::url_pattern_index::proto::UrlRule* Arena::CreateMaybeMessage<::url_pattern_index::proto::UrlRule>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace url_pattern_index {
namespace proto {

enum RuleType : int { RULE_TYPE_UNSPECIFIED = 0, RULE_TYPE_COMMENT = 1, RULE_TYPE_URL = 2, RULE_TYPE_CSS = 3 };
bool RuleType_IsValid(int value);
constexpr RuleType RuleType_MIN = RULE_TYPE_UNSPECIFIED;
constexpr RuleType RuleType_MAX = RULE_TYPE_CSS;
constexpr int RuleType_ARRAYSIZE = RuleType_MAX + 1;

const std::string& RuleType_Name(RuleType value);
template <typename T> inline const std::string& RuleType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, RuleType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function RuleType_Name.");
    return RuleType_Name(static_cast<RuleType>(enum_t_value));
}
bool RuleType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RuleType* value);
enum UrlPatternType : int { URL_PATTERN_TYPE_UNSPECIFIED = 0, URL_PATTERN_TYPE_SUBSTRING = 1, URL_PATTERN_TYPE_WILDCARDED = 2, URL_PATTERN_TYPE_REGEXP = 3 };
bool UrlPatternType_IsValid(int value);
constexpr UrlPatternType UrlPatternType_MIN = URL_PATTERN_TYPE_UNSPECIFIED;
constexpr UrlPatternType UrlPatternType_MAX = URL_PATTERN_TYPE_REGEXP;
constexpr int UrlPatternType_ARRAYSIZE = UrlPatternType_MAX + 1;

const std::string& UrlPatternType_Name(UrlPatternType value);
template <typename T> inline const std::string& UrlPatternType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, UrlPatternType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function UrlPatternType_Name.");
    return UrlPatternType_Name(static_cast<UrlPatternType>(enum_t_value));
}
bool UrlPatternType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UrlPatternType* value);
enum AnchorType : int { ANCHOR_TYPE_UNSPECIFIED = 0, ANCHOR_TYPE_NONE = 1, ANCHOR_TYPE_BOUNDARY = 2, ANCHOR_TYPE_SUBDOMAIN = 3 };
bool AnchorType_IsValid(int value);
constexpr AnchorType AnchorType_MIN = ANCHOR_TYPE_UNSPECIFIED;
constexpr AnchorType AnchorType_MAX = ANCHOR_TYPE_SUBDOMAIN;
constexpr int AnchorType_ARRAYSIZE = AnchorType_MAX + 1;

const std::string& AnchorType_Name(AnchorType value);
template <typename T> inline const std::string& AnchorType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, AnchorType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function AnchorType_Name.");
    return AnchorType_Name(static_cast<AnchorType>(enum_t_value));
}
bool AnchorType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AnchorType* value);
enum ElementType : int {
    ELEMENT_TYPE_UNSPECIFIED = 0,
    ELEMENT_TYPE_OTHER = 1,
    ELEMENT_TYPE_SCRIPT = 2,
    ELEMENT_TYPE_IMAGE = 4,
    ELEMENT_TYPE_STYLESHEET = 8,
    ELEMENT_TYPE_OBJECT = 16,
    ELEMENT_TYPE_XMLHTTPREQUEST = 32,
    ELEMENT_TYPE_OBJECT_SUBREQUEST = 64,
    ELEMENT_TYPE_SUBDOCUMENT = 128,
    ELEMENT_TYPE_PING = 256,
    ELEMENT_TYPE_MEDIA = 512,
    ELEMENT_TYPE_FONT = 1024,
    ELEMENT_TYPE_POPUP = 2048,
    ELEMENT_TYPE_WEBSOCKET = 4096,
    ELEMENT_TYPE_WEBTRANSPORT = 8192,
    ELEMENT_TYPE_WEBBUNDLE = 16384,
    ELEMENT_TYPE_MAX = 16384,
    ELEMENT_TYPE_ALL = 32767
};
bool ElementType_IsValid(int value);
constexpr ElementType ElementType_MIN = ELEMENT_TYPE_UNSPECIFIED;
constexpr ElementType ElementType_MAX = ELEMENT_TYPE_ALL;
constexpr int ElementType_ARRAYSIZE = ElementType_MAX + 1;

const std::string& ElementType_Name(ElementType value);
template <typename T> inline const std::string& ElementType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ElementType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ElementType_Name.");
    return ElementType_Name(static_cast<ElementType>(enum_t_value));
}
bool ElementType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ElementType* value);
enum ActivationType : int {
    ACTIVATION_TYPE_UNSPECIFIED = 0,
    ACTIVATION_TYPE_DOCUMENT = 1,
    ACTIVATION_TYPE_ELEMHIDE = 2,
    ACTIVATION_TYPE_GENERICHIDE = 4,
    ACTIVATION_TYPE_GENERICBLOCK = 8,
    ACTIVATION_TYPE_MAX = 8,
    ACTIVATION_TYPE_ALL = 15
};
bool ActivationType_IsValid(int value);
constexpr ActivationType ActivationType_MIN = ACTIVATION_TYPE_UNSPECIFIED;
constexpr ActivationType ActivationType_MAX = ACTIVATION_TYPE_ALL;
constexpr int ActivationType_ARRAYSIZE = ActivationType_MAX + 1;

const std::string& ActivationType_Name(ActivationType value);
template <typename T> inline const std::string& ActivationType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ActivationType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ActivationType_Name.");
    return ActivationType_Name(static_cast<ActivationType>(enum_t_value));
}
bool ActivationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActivationType* value);
enum RuleSemantics : int { RULE_SEMANTICS_UNSPECIFIED = 0, RULE_SEMANTICS_BLOCKLIST = 1, RULE_SEMANTICS_ALLOWLIST = 2 };
bool RuleSemantics_IsValid(int value);
constexpr RuleSemantics RuleSemantics_MIN = RULE_SEMANTICS_UNSPECIFIED;
constexpr RuleSemantics RuleSemantics_MAX = RULE_SEMANTICS_ALLOWLIST;
constexpr int RuleSemantics_ARRAYSIZE = RuleSemantics_MAX + 1;

const std::string& RuleSemantics_Name(RuleSemantics value);
template <typename T> inline const std::string& RuleSemantics_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, RuleSemantics>::value || ::std::is_integral<T>::value, "Incorrect type passed to function RuleSemantics_Name.");
    return RuleSemantics_Name(static_cast<RuleSemantics>(enum_t_value));
}
bool RuleSemantics_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RuleSemantics* value);
enum SourceType : int { SOURCE_TYPE_UNSPECIFIED = 0, SOURCE_TYPE_ANY = 1, SOURCE_TYPE_THIRD_PARTY = 2, SOURCE_TYPE_FIRST_PARTY = 3 };
bool SourceType_IsValid(int value);
constexpr SourceType SourceType_MIN = SOURCE_TYPE_UNSPECIFIED;
constexpr SourceType SourceType_MAX = SOURCE_TYPE_FIRST_PARTY;
constexpr int SourceType_ARRAYSIZE = SourceType_MAX + 1;

const std::string& SourceType_Name(SourceType value);
template <typename T> inline const std::string& SourceType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, SourceType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function SourceType_Name.");
    return SourceType_Name(static_cast<SourceType>(enum_t_value));
}
bool SourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SourceType* value);
// ===================================================================

class DomainListItem final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:url_pattern_index.proto.DomainListItem) */ {
public:
    inline DomainListItem()
        : DomainListItem(nullptr)
    {
    }
    ~DomainListItem() override;
    explicit PROTOBUF_CONSTEXPR DomainListItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    DomainListItem(const DomainListItem& from);
    DomainListItem(DomainListItem&& from) noexcept
        : DomainListItem()
    {
        *this = ::std::move(from);
    }

    inline DomainListItem& operator=(const DomainListItem& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DomainListItem& operator=(DomainListItem&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const DomainListItem& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DomainListItem* internal_default_instance()
    {
        return reinterpret_cast<const DomainListItem*>(&_DomainListItem_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(DomainListItem& a, DomainListItem& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(DomainListItem* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DomainListItem* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DomainListItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<DomainListItem>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const DomainListItem& from);
    void MergeFrom(const DomainListItem& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DomainListItem* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "url_pattern_index.proto.DomainListItem";
    }

protected:
    explicit DomainListItem(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDomainFieldNumber = 1,
        kExcludeFieldNumber = 2,
    };
    // optional string domain = 1;
    bool has_domain() const;

private:
    bool _internal_has_domain() const;

public:
    void clear_domain();
    const std::string& domain() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_domain(ArgT0&& arg0, ArgT... args);
    std::string* mutable_domain();
    PROTOBUF_NODISCARD std::string* release_domain();
    void set_allocated_domain(std::string* domain);

private:
    const std::string& _internal_domain() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
    std::string* _internal_mutable_domain();

public:
    // optional bool exclude = 2;
    bool has_exclude() const;

private:
    bool _internal_has_exclude() const;

public:
    void clear_exclude();
    bool exclude() const;
    void set_exclude(bool value);

private:
    bool _internal_exclude() const;
    void _internal_set_exclude(bool value);

public:
    // @@protoc_insertion_point(class_scope:url_pattern_index.proto.DomainListItem)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
        bool exclude_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_rules_2eproto;
};
// -------------------------------------------------------------------

class UrlRule final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:url_pattern_index.proto.UrlRule) */ {
public:
    inline UrlRule()
        : UrlRule(nullptr)
    {
    }
    ~UrlRule() override;
    explicit PROTOBUF_CONSTEXPR UrlRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    UrlRule(const UrlRule& from);
    UrlRule(UrlRule&& from) noexcept
        : UrlRule()
    {
        *this = ::std::move(from);
    }

    inline UrlRule& operator=(const UrlRule& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UrlRule& operator=(UrlRule&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const UrlRule& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const UrlRule* internal_default_instance()
    {
        return reinterpret_cast<const UrlRule*>(&_UrlRule_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(UrlRule& a, UrlRule& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(UrlRule* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UrlRule* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UrlRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<UrlRule>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const UrlRule& from);
    void MergeFrom(const UrlRule& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(UrlRule* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "url_pattern_index.proto.UrlRule";
    }

protected:
    explicit UrlRule(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kInitiatorDomainsFieldNumber = 5,
        kRequestDomainsFieldNumber = 11,
        kUrlPatternFieldNumber = 10,
        kSemanticsFieldNumber = 1,
        kSourceTypeFieldNumber = 2,
        kElementTypesFieldNumber = 3,
        kActivationTypesFieldNumber = 4,
        kUrlPatternTypeFieldNumber = 6,
        kAnchorLeftFieldNumber = 7,
        kAnchorRightFieldNumber = 8,
        kMatchCaseFieldNumber = 9,
    };
    // repeated .url_pattern_index.proto.DomainListItem initiator_domains = 5;
    int initiator_domains_size() const;

private:
    int _internal_initiator_domains_size() const;

public:
    void clear_initiator_domains();
    ::url_pattern_index::proto::DomainListItem* mutable_initiator_domains(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem>* mutable_initiator_domains();

private:
    const ::url_pattern_index::proto::DomainListItem& _internal_initiator_domains(int index) const;
    ::url_pattern_index::proto::DomainListItem* _internal_add_initiator_domains();

public:
    const ::url_pattern_index::proto::DomainListItem& initiator_domains(int index) const;
    ::url_pattern_index::proto::DomainListItem* add_initiator_domains();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem>& initiator_domains() const;

    // repeated .url_pattern_index.proto.DomainListItem request_domains = 11;
    int request_domains_size() const;

private:
    int _internal_request_domains_size() const;

public:
    void clear_request_domains();
    ::url_pattern_index::proto::DomainListItem* mutable_request_domains(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem>* mutable_request_domains();

private:
    const ::url_pattern_index::proto::DomainListItem& _internal_request_domains(int index) const;
    ::url_pattern_index::proto::DomainListItem* _internal_add_request_domains();

public:
    const ::url_pattern_index::proto::DomainListItem& request_domains(int index) const;
    ::url_pattern_index::proto::DomainListItem* add_request_domains();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem>& request_domains() const;

    // optional string url_pattern = 10;
    bool has_url_pattern() const;

private:
    bool _internal_has_url_pattern() const;

public:
    void clear_url_pattern();
    const std::string& url_pattern() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url_pattern(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url_pattern();
    PROTOBUF_NODISCARD std::string* release_url_pattern();
    void set_allocated_url_pattern(std::string* url_pattern);

private:
    const std::string& _internal_url_pattern() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url_pattern(const std::string& value);
    std::string* _internal_mutable_url_pattern();

public:
    // optional .url_pattern_index.proto.RuleSemantics semantics = 1;
    bool has_semantics() const;

private:
    bool _internal_has_semantics() const;

public:
    void clear_semantics();
    ::url_pattern_index::proto::RuleSemantics semantics() const;
    void set_semantics(::url_pattern_index::proto::RuleSemantics value);

private:
    ::url_pattern_index::proto::RuleSemantics _internal_semantics() const;
    void _internal_set_semantics(::url_pattern_index::proto::RuleSemantics value);

public:
    // optional .url_pattern_index.proto.SourceType source_type = 2;
    bool has_source_type() const;

private:
    bool _internal_has_source_type() const;

public:
    void clear_source_type();
    ::url_pattern_index::proto::SourceType source_type() const;
    void set_source_type(::url_pattern_index::proto::SourceType value);

private:
    ::url_pattern_index::proto::SourceType _internal_source_type() const;
    void _internal_set_source_type(::url_pattern_index::proto::SourceType value);

public:
    // optional int32 element_types = 3;
    bool has_element_types() const;

private:
    bool _internal_has_element_types() const;

public:
    void clear_element_types();
    int32_t element_types() const;
    void set_element_types(int32_t value);

private:
    int32_t _internal_element_types() const;
    void _internal_set_element_types(int32_t value);

public:
    // optional int32 activation_types = 4;
    bool has_activation_types() const;

private:
    bool _internal_has_activation_types() const;

public:
    void clear_activation_types();
    int32_t activation_types() const;
    void set_activation_types(int32_t value);

private:
    int32_t _internal_activation_types() const;
    void _internal_set_activation_types(int32_t value);

public:
    // optional .url_pattern_index.proto.UrlPatternType url_pattern_type = 6;
    bool has_url_pattern_type() const;

private:
    bool _internal_has_url_pattern_type() const;

public:
    void clear_url_pattern_type();
    ::url_pattern_index::proto::UrlPatternType url_pattern_type() const;
    void set_url_pattern_type(::url_pattern_index::proto::UrlPatternType value);

private:
    ::url_pattern_index::proto::UrlPatternType _internal_url_pattern_type() const;
    void _internal_set_url_pattern_type(::url_pattern_index::proto::UrlPatternType value);

public:
    // optional .url_pattern_index.proto.AnchorType anchor_left = 7;
    bool has_anchor_left() const;

private:
    bool _internal_has_anchor_left() const;

public:
    void clear_anchor_left();
    ::url_pattern_index::proto::AnchorType anchor_left() const;
    void set_anchor_left(::url_pattern_index::proto::AnchorType value);

private:
    ::url_pattern_index::proto::AnchorType _internal_anchor_left() const;
    void _internal_set_anchor_left(::url_pattern_index::proto::AnchorType value);

public:
    // optional .url_pattern_index.proto.AnchorType anchor_right = 8;
    bool has_anchor_right() const;

private:
    bool _internal_has_anchor_right() const;

public:
    void clear_anchor_right();
    ::url_pattern_index::proto::AnchorType anchor_right() const;
    void set_anchor_right(::url_pattern_index::proto::AnchorType value);

private:
    ::url_pattern_index::proto::AnchorType _internal_anchor_right() const;
    void _internal_set_anchor_right(::url_pattern_index::proto::AnchorType value);

public:
    // optional bool match_case = 9 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_match_case() const;

private:
    bool _internal_has_match_case() const;

public:
    PROTOBUF_DEPRECATED void clear_match_case();
    PROTOBUF_DEPRECATED bool match_case() const;
    PROTOBUF_DEPRECATED void set_match_case(bool value);

private:
    bool _internal_match_case() const;
    void _internal_set_match_case(bool value);

public:
    // @@protoc_insertion_point(class_scope:url_pattern_index.proto.UrlRule)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem> initiator_domains_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem> request_domains_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_pattern_;
        int semantics_;
        int source_type_;
        int32_t element_types_;
        int32_t activation_types_;
        int url_pattern_type_;
        int anchor_left_;
        int anchor_right_;
        bool match_case_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_rules_2eproto;
};
// -------------------------------------------------------------------

class CssRule final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:url_pattern_index.proto.CssRule) */ {
public:
    inline CssRule()
        : CssRule(nullptr)
    {
    }
    ~CssRule() override;
    explicit PROTOBUF_CONSTEXPR CssRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CssRule(const CssRule& from);
    CssRule(CssRule&& from) noexcept
        : CssRule()
    {
        *this = ::std::move(from);
    }

    inline CssRule& operator=(const CssRule& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CssRule& operator=(CssRule&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const CssRule& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CssRule* internal_default_instance()
    {
        return reinterpret_cast<const CssRule*>(&_CssRule_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(CssRule& a, CssRule& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CssRule* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CssRule* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CssRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CssRule>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CssRule& from);
    void MergeFrom(const CssRule& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CssRule* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "url_pattern_index.proto.CssRule";
    }

protected:
    explicit CssRule(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDomainsFieldNumber = 2,
        kCssSelectorFieldNumber = 3,
        kSemanticsFieldNumber = 1,
    };
    // repeated .url_pattern_index.proto.DomainListItem domains = 2;
    int domains_size() const;

private:
    int _internal_domains_size() const;

public:
    void clear_domains();
    ::url_pattern_index::proto::DomainListItem* mutable_domains(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem>* mutable_domains();

private:
    const ::url_pattern_index::proto::DomainListItem& _internal_domains(int index) const;
    ::url_pattern_index::proto::DomainListItem* _internal_add_domains();

public:
    const ::url_pattern_index::proto::DomainListItem& domains(int index) const;
    ::url_pattern_index::proto::DomainListItem* add_domains();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem>& domains() const;

    // optional string css_selector = 3;
    bool has_css_selector() const;

private:
    bool _internal_has_css_selector() const;

public:
    void clear_css_selector();
    const std::string& css_selector() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_css_selector(ArgT0&& arg0, ArgT... args);
    std::string* mutable_css_selector();
    PROTOBUF_NODISCARD std::string* release_css_selector();
    void set_allocated_css_selector(std::string* css_selector);

private:
    const std::string& _internal_css_selector() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_css_selector(const std::string& value);
    std::string* _internal_mutable_css_selector();

public:
    // optional .url_pattern_index.proto.RuleSemantics semantics = 1;
    bool has_semantics() const;

private:
    bool _internal_has_semantics() const;

public:
    void clear_semantics();
    ::url_pattern_index::proto::RuleSemantics semantics() const;
    void set_semantics(::url_pattern_index::proto::RuleSemantics value);

private:
    ::url_pattern_index::proto::RuleSemantics _internal_semantics() const;
    void _internal_set_semantics(::url_pattern_index::proto::RuleSemantics value);

public:
    // @@protoc_insertion_point(class_scope:url_pattern_index.proto.CssRule)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem> domains_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr css_selector_;
        int semantics_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_rules_2eproto;
};
// -------------------------------------------------------------------

class Comment final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:url_pattern_index.proto.Comment) */ {
public:
    inline Comment()
        : Comment(nullptr)
    {
    }
    ~Comment() override;
    explicit PROTOBUF_CONSTEXPR Comment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Comment(const Comment& from);
    Comment(Comment&& from) noexcept
        : Comment()
    {
        *this = ::std::move(from);
    }

    inline Comment& operator=(const Comment& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Comment& operator=(Comment&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Comment& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Comment* internal_default_instance()
    {
        return reinterpret_cast<const Comment*>(&_Comment_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(Comment& a, Comment& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Comment* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Comment* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Comment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Comment>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Comment& from);
    void MergeFrom(const Comment& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Comment* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "url_pattern_index.proto.Comment";
    }

protected:
    explicit Comment(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTextFieldNumber = 1,
        kKeyFieldNumber = 2,
        kValueFieldNumber = 3,
    };
    // optional string text = 1;
    bool has_text() const;

private:
    bool _internal_has_text() const;

public:
    void clear_text();
    const std::string& text() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_text(ArgT0&& arg0, ArgT... args);
    std::string* mutable_text();
    PROTOBUF_NODISCARD std::string* release_text();
    void set_allocated_text(std::string* text);

private:
    const std::string& _internal_text() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
    std::string* _internal_mutable_text();

public:
    // optional string key = 2;
    bool has_key() const;

private:
    bool _internal_has_key() const;

public:
    void clear_key();
    const std::string& key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_key();
    PROTOBUF_NODISCARD std::string* release_key();
    void set_allocated_key(std::string* key);

private:
    const std::string& _internal_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
    std::string* _internal_mutable_key();

public:
    // optional string value = 3;
    bool has_value() const;

private:
    bool _internal_has_value() const;

public:
    void clear_value();
    const std::string& value() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_value(ArgT0&& arg0, ArgT... args);
    std::string* mutable_value();
    PROTOBUF_NODISCARD std::string* release_value();
    void set_allocated_value(std::string* value);

private:
    const std::string& _internal_value() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
    std::string* _internal_mutable_value();

public:
    // @@protoc_insertion_point(class_scope:url_pattern_index.proto.Comment)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_rules_2eproto;
};
// -------------------------------------------------------------------

class FilteringRules final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:url_pattern_index.proto.FilteringRules) */ {
public:
    inline FilteringRules()
        : FilteringRules(nullptr)
    {
    }
    ~FilteringRules() override;
    explicit PROTOBUF_CONSTEXPR FilteringRules(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FilteringRules(const FilteringRules& from);
    FilteringRules(FilteringRules&& from) noexcept
        : FilteringRules()
    {
        *this = ::std::move(from);
    }

    inline FilteringRules& operator=(const FilteringRules& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FilteringRules& operator=(FilteringRules&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const FilteringRules& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FilteringRules* internal_default_instance()
    {
        return reinterpret_cast<const FilteringRules*>(&_FilteringRules_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(FilteringRules& a, FilteringRules& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FilteringRules* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FilteringRules* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FilteringRules* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FilteringRules>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FilteringRules& from);
    void MergeFrom(const FilteringRules& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FilteringRules* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "url_pattern_index.proto.FilteringRules";
    }

protected:
    explicit FilteringRules(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUrlRulesFieldNumber = 1,
        kCssRulesFieldNumber = 2,
    };
    // repeated .url_pattern_index.proto.UrlRule url_rules = 1;
    int url_rules_size() const;

private:
    int _internal_url_rules_size() const;

public:
    void clear_url_rules();
    ::url_pattern_index::proto::UrlRule* mutable_url_rules(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::UrlRule>* mutable_url_rules();

private:
    const ::url_pattern_index::proto::UrlRule& _internal_url_rules(int index) const;
    ::url_pattern_index::proto::UrlRule* _internal_add_url_rules();

public:
    const ::url_pattern_index::proto::UrlRule& url_rules(int index) const;
    ::url_pattern_index::proto::UrlRule* add_url_rules();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::UrlRule>& url_rules() const;

    // repeated .url_pattern_index.proto.CssRule css_rules = 2;
    int css_rules_size() const;

private:
    int _internal_css_rules_size() const;

public:
    void clear_css_rules();
    ::url_pattern_index::proto::CssRule* mutable_css_rules(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::CssRule>* mutable_css_rules();

private:
    const ::url_pattern_index::proto::CssRule& _internal_css_rules(int index) const;
    ::url_pattern_index::proto::CssRule* _internal_add_css_rules();

public:
    const ::url_pattern_index::proto::CssRule& css_rules(int index) const;
    ::url_pattern_index::proto::CssRule* add_css_rules();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::CssRule>& css_rules() const;

    // @@protoc_insertion_point(class_scope:url_pattern_index.proto.FilteringRules)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::UrlRule> url_rules_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::CssRule> css_rules_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_rules_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// DomainListItem

// optional string domain = 1;
inline bool DomainListItem::_internal_has_domain() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool DomainListItem::has_domain() const
{
    return _internal_has_domain();
}
inline void DomainListItem::clear_domain()
{
    _impl_.domain_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DomainListItem::domain() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.DomainListItem.domain)
    return _internal_domain();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DomainListItem::set_domain(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.domain_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.DomainListItem.domain)
}
inline std::string* DomainListItem::mutable_domain()
{
    std::string* _s = _internal_mutable_domain();
    // @@protoc_insertion_point(field_mutable:url_pattern_index.proto.DomainListItem.domain)
    return _s;
}
inline const std::string& DomainListItem::_internal_domain() const
{
    return _impl_.domain_.Get();
}
inline void DomainListItem::_internal_set_domain(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.domain_.Set(value, GetArenaForAllocation());
}
inline std::string* DomainListItem::_internal_mutable_domain()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.domain_.Mutable(GetArenaForAllocation());
}
inline std::string* DomainListItem::release_domain()
{
    // @@protoc_insertion_point(field_release:url_pattern_index.proto.DomainListItem.domain)
    if (!_internal_has_domain()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.domain_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.domain_.IsDefault()) {
        _impl_.domain_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DomainListItem::set_allocated_domain(std::string* domain)
{
    if (domain != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.domain_.SetAllocated(domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.domain_.IsDefault()) {
        _impl_.domain_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:url_pattern_index.proto.DomainListItem.domain)
}

// optional bool exclude = 2;
inline bool DomainListItem::_internal_has_exclude() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool DomainListItem::has_exclude() const
{
    return _internal_has_exclude();
}
inline void DomainListItem::clear_exclude()
{
    _impl_.exclude_ = false;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DomainListItem::_internal_exclude() const
{
    return _impl_.exclude_;
}
inline bool DomainListItem::exclude() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.DomainListItem.exclude)
    return _internal_exclude();
}
inline void DomainListItem::_internal_set_exclude(bool value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.exclude_ = value;
}
inline void DomainListItem::set_exclude(bool value)
{
    _internal_set_exclude(value);
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.DomainListItem.exclude)
}

// -------------------------------------------------------------------

// UrlRule

// optional .url_pattern_index.proto.RuleSemantics semantics = 1;
inline bool UrlRule::_internal_has_semantics() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool UrlRule::has_semantics() const
{
    return _internal_has_semantics();
}
inline void UrlRule::clear_semantics()
{
    _impl_.semantics_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::url_pattern_index::proto::RuleSemantics UrlRule::_internal_semantics() const
{
    return static_cast<::url_pattern_index::proto::RuleSemantics>(_impl_.semantics_);
}
inline ::url_pattern_index::proto::RuleSemantics UrlRule::semantics() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.UrlRule.semantics)
    return _internal_semantics();
}
inline void UrlRule::_internal_set_semantics(::url_pattern_index::proto::RuleSemantics value)
{
    assert(::url_pattern_index::proto::RuleSemantics_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.semantics_ = value;
}
inline void UrlRule::set_semantics(::url_pattern_index::proto::RuleSemantics value)
{
    _internal_set_semantics(value);
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.UrlRule.semantics)
}

// optional .url_pattern_index.proto.SourceType source_type = 2;
inline bool UrlRule::_internal_has_source_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool UrlRule::has_source_type() const
{
    return _internal_has_source_type();
}
inline void UrlRule::clear_source_type()
{
    _impl_.source_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::url_pattern_index::proto::SourceType UrlRule::_internal_source_type() const
{
    return static_cast<::url_pattern_index::proto::SourceType>(_impl_.source_type_);
}
inline ::url_pattern_index::proto::SourceType UrlRule::source_type() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.UrlRule.source_type)
    return _internal_source_type();
}
inline void UrlRule::_internal_set_source_type(::url_pattern_index::proto::SourceType value)
{
    assert(::url_pattern_index::proto::SourceType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.source_type_ = value;
}
inline void UrlRule::set_source_type(::url_pattern_index::proto::SourceType value)
{
    _internal_set_source_type(value);
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.UrlRule.source_type)
}

// optional int32 element_types = 3;
inline bool UrlRule::_internal_has_element_types() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool UrlRule::has_element_types() const
{
    return _internal_has_element_types();
}
inline void UrlRule::clear_element_types()
{
    _impl_.element_types_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t UrlRule::_internal_element_types() const
{
    return _impl_.element_types_;
}
inline int32_t UrlRule::element_types() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.UrlRule.element_types)
    return _internal_element_types();
}
inline void UrlRule::_internal_set_element_types(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.element_types_ = value;
}
inline void UrlRule::set_element_types(int32_t value)
{
    _internal_set_element_types(value);
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.UrlRule.element_types)
}

// optional int32 activation_types = 4;
inline bool UrlRule::_internal_has_activation_types() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool UrlRule::has_activation_types() const
{
    return _internal_has_activation_types();
}
inline void UrlRule::clear_activation_types()
{
    _impl_.activation_types_ = 0;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t UrlRule::_internal_activation_types() const
{
    return _impl_.activation_types_;
}
inline int32_t UrlRule::activation_types() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.UrlRule.activation_types)
    return _internal_activation_types();
}
inline void UrlRule::_internal_set_activation_types(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.activation_types_ = value;
}
inline void UrlRule::set_activation_types(int32_t value)
{
    _internal_set_activation_types(value);
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.UrlRule.activation_types)
}

// repeated .url_pattern_index.proto.DomainListItem initiator_domains = 5;
inline int UrlRule::_internal_initiator_domains_size() const
{
    return _impl_.initiator_domains_.size();
}
inline int UrlRule::initiator_domains_size() const
{
    return _internal_initiator_domains_size();
}
inline void UrlRule::clear_initiator_domains()
{
    _impl_.initiator_domains_.Clear();
}
inline ::url_pattern_index::proto::DomainListItem* UrlRule::mutable_initiator_domains(int index)
{
    // @@protoc_insertion_point(field_mutable:url_pattern_index.proto.UrlRule.initiator_domains)
    return _impl_.initiator_domains_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem>* UrlRule::mutable_initiator_domains()
{
    // @@protoc_insertion_point(field_mutable_list:url_pattern_index.proto.UrlRule.initiator_domains)
    return &_impl_.initiator_domains_;
}
inline const ::url_pattern_index::proto::DomainListItem& UrlRule::_internal_initiator_domains(int index) const
{
    return _impl_.initiator_domains_.Get(index);
}
inline const ::url_pattern_index::proto::DomainListItem& UrlRule::initiator_domains(int index) const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.UrlRule.initiator_domains)
    return _internal_initiator_domains(index);
}
inline ::url_pattern_index::proto::DomainListItem* UrlRule::_internal_add_initiator_domains()
{
    return _impl_.initiator_domains_.Add();
}
inline ::url_pattern_index::proto::DomainListItem* UrlRule::add_initiator_domains()
{
    ::url_pattern_index::proto::DomainListItem* _add = _internal_add_initiator_domains();
    // @@protoc_insertion_point(field_add:url_pattern_index.proto.UrlRule.initiator_domains)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem>& UrlRule::initiator_domains() const
{
    // @@protoc_insertion_point(field_list:url_pattern_index.proto.UrlRule.initiator_domains)
    return _impl_.initiator_domains_;
}

// optional .url_pattern_index.proto.UrlPatternType url_pattern_type = 6;
inline bool UrlRule::_internal_has_url_pattern_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool UrlRule::has_url_pattern_type() const
{
    return _internal_has_url_pattern_type();
}
inline void UrlRule::clear_url_pattern_type()
{
    _impl_.url_pattern_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::url_pattern_index::proto::UrlPatternType UrlRule::_internal_url_pattern_type() const
{
    return static_cast<::url_pattern_index::proto::UrlPatternType>(_impl_.url_pattern_type_);
}
inline ::url_pattern_index::proto::UrlPatternType UrlRule::url_pattern_type() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.UrlRule.url_pattern_type)
    return _internal_url_pattern_type();
}
inline void UrlRule::_internal_set_url_pattern_type(::url_pattern_index::proto::UrlPatternType value)
{
    assert(::url_pattern_index::proto::UrlPatternType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.url_pattern_type_ = value;
}
inline void UrlRule::set_url_pattern_type(::url_pattern_index::proto::UrlPatternType value)
{
    _internal_set_url_pattern_type(value);
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.UrlRule.url_pattern_type)
}

// optional .url_pattern_index.proto.AnchorType anchor_left = 7;
inline bool UrlRule::_internal_has_anchor_left() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool UrlRule::has_anchor_left() const
{
    return _internal_has_anchor_left();
}
inline void UrlRule::clear_anchor_left()
{
    _impl_.anchor_left_ = 0;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::url_pattern_index::proto::AnchorType UrlRule::_internal_anchor_left() const
{
    return static_cast<::url_pattern_index::proto::AnchorType>(_impl_.anchor_left_);
}
inline ::url_pattern_index::proto::AnchorType UrlRule::anchor_left() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.UrlRule.anchor_left)
    return _internal_anchor_left();
}
inline void UrlRule::_internal_set_anchor_left(::url_pattern_index::proto::AnchorType value)
{
    assert(::url_pattern_index::proto::AnchorType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.anchor_left_ = value;
}
inline void UrlRule::set_anchor_left(::url_pattern_index::proto::AnchorType value)
{
    _internal_set_anchor_left(value);
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.UrlRule.anchor_left)
}

// optional .url_pattern_index.proto.AnchorType anchor_right = 8;
inline bool UrlRule::_internal_has_anchor_right() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool UrlRule::has_anchor_right() const
{
    return _internal_has_anchor_right();
}
inline void UrlRule::clear_anchor_right()
{
    _impl_.anchor_right_ = 0;
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::url_pattern_index::proto::AnchorType UrlRule::_internal_anchor_right() const
{
    return static_cast<::url_pattern_index::proto::AnchorType>(_impl_.anchor_right_);
}
inline ::url_pattern_index::proto::AnchorType UrlRule::anchor_right() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.UrlRule.anchor_right)
    return _internal_anchor_right();
}
inline void UrlRule::_internal_set_anchor_right(::url_pattern_index::proto::AnchorType value)
{
    assert(::url_pattern_index::proto::AnchorType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.anchor_right_ = value;
}
inline void UrlRule::set_anchor_right(::url_pattern_index::proto::AnchorType value)
{
    _internal_set_anchor_right(value);
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.UrlRule.anchor_right)
}

// optional bool match_case = 9 [deprecated = true];
inline bool UrlRule::_internal_has_match_case() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool UrlRule::has_match_case() const
{
    return _internal_has_match_case();
}
inline void UrlRule::clear_match_case()
{
    _impl_.match_case_ = false;
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool UrlRule::_internal_match_case() const
{
    return _impl_.match_case_;
}
inline bool UrlRule::match_case() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.UrlRule.match_case)
    return _internal_match_case();
}
inline void UrlRule::_internal_set_match_case(bool value)
{
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.match_case_ = value;
}
inline void UrlRule::set_match_case(bool value)
{
    _internal_set_match_case(value);
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.UrlRule.match_case)
}

// optional string url_pattern = 10;
inline bool UrlRule::_internal_has_url_pattern() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool UrlRule::has_url_pattern() const
{
    return _internal_has_url_pattern();
}
inline void UrlRule::clear_url_pattern()
{
    _impl_.url_pattern_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UrlRule::url_pattern() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.UrlRule.url_pattern)
    return _internal_url_pattern();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void UrlRule::set_url_pattern(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_pattern_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.UrlRule.url_pattern)
}
inline std::string* UrlRule::mutable_url_pattern()
{
    std::string* _s = _internal_mutable_url_pattern();
    // @@protoc_insertion_point(field_mutable:url_pattern_index.proto.UrlRule.url_pattern)
    return _s;
}
inline const std::string& UrlRule::_internal_url_pattern() const
{
    return _impl_.url_pattern_.Get();
}
inline void UrlRule::_internal_set_url_pattern(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* UrlRule::_internal_mutable_url_pattern()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.url_pattern_.Mutable(GetArenaForAllocation());
}
inline std::string* UrlRule::release_url_pattern()
{
    // @@protoc_insertion_point(field_release:url_pattern_index.proto.UrlRule.url_pattern)
    if (!_internal_has_url_pattern()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.url_pattern_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_pattern_.IsDefault()) {
        _impl_.url_pattern_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void UrlRule::set_allocated_url_pattern(std::string* url_pattern)
{
    if (url_pattern != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.url_pattern_.SetAllocated(url_pattern, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_pattern_.IsDefault()) {
        _impl_.url_pattern_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:url_pattern_index.proto.UrlRule.url_pattern)
}

// repeated .url_pattern_index.proto.DomainListItem request_domains = 11;
inline int UrlRule::_internal_request_domains_size() const
{
    return _impl_.request_domains_.size();
}
inline int UrlRule::request_domains_size() const
{
    return _internal_request_domains_size();
}
inline void UrlRule::clear_request_domains()
{
    _impl_.request_domains_.Clear();
}
inline ::url_pattern_index::proto::DomainListItem* UrlRule::mutable_request_domains(int index)
{
    // @@protoc_insertion_point(field_mutable:url_pattern_index.proto.UrlRule.request_domains)
    return _impl_.request_domains_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem>* UrlRule::mutable_request_domains()
{
    // @@protoc_insertion_point(field_mutable_list:url_pattern_index.proto.UrlRule.request_domains)
    return &_impl_.request_domains_;
}
inline const ::url_pattern_index::proto::DomainListItem& UrlRule::_internal_request_domains(int index) const
{
    return _impl_.request_domains_.Get(index);
}
inline const ::url_pattern_index::proto::DomainListItem& UrlRule::request_domains(int index) const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.UrlRule.request_domains)
    return _internal_request_domains(index);
}
inline ::url_pattern_index::proto::DomainListItem* UrlRule::_internal_add_request_domains()
{
    return _impl_.request_domains_.Add();
}
inline ::url_pattern_index::proto::DomainListItem* UrlRule::add_request_domains()
{
    ::url_pattern_index::proto::DomainListItem* _add = _internal_add_request_domains();
    // @@protoc_insertion_point(field_add:url_pattern_index.proto.UrlRule.request_domains)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem>& UrlRule::request_domains() const
{
    // @@protoc_insertion_point(field_list:url_pattern_index.proto.UrlRule.request_domains)
    return _impl_.request_domains_;
}

// -------------------------------------------------------------------

// CssRule

// optional .url_pattern_index.proto.RuleSemantics semantics = 1;
inline bool CssRule::_internal_has_semantics() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool CssRule::has_semantics() const
{
    return _internal_has_semantics();
}
inline void CssRule::clear_semantics()
{
    _impl_.semantics_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::url_pattern_index::proto::RuleSemantics CssRule::_internal_semantics() const
{
    return static_cast<::url_pattern_index::proto::RuleSemantics>(_impl_.semantics_);
}
inline ::url_pattern_index::proto::RuleSemantics CssRule::semantics() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.CssRule.semantics)
    return _internal_semantics();
}
inline void CssRule::_internal_set_semantics(::url_pattern_index::proto::RuleSemantics value)
{
    assert(::url_pattern_index::proto::RuleSemantics_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.semantics_ = value;
}
inline void CssRule::set_semantics(::url_pattern_index::proto::RuleSemantics value)
{
    _internal_set_semantics(value);
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.CssRule.semantics)
}

// repeated .url_pattern_index.proto.DomainListItem domains = 2;
inline int CssRule::_internal_domains_size() const
{
    return _impl_.domains_.size();
}
inline int CssRule::domains_size() const
{
    return _internal_domains_size();
}
inline void CssRule::clear_domains()
{
    _impl_.domains_.Clear();
}
inline ::url_pattern_index::proto::DomainListItem* CssRule::mutable_domains(int index)
{
    // @@protoc_insertion_point(field_mutable:url_pattern_index.proto.CssRule.domains)
    return _impl_.domains_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem>* CssRule::mutable_domains()
{
    // @@protoc_insertion_point(field_mutable_list:url_pattern_index.proto.CssRule.domains)
    return &_impl_.domains_;
}
inline const ::url_pattern_index::proto::DomainListItem& CssRule::_internal_domains(int index) const
{
    return _impl_.domains_.Get(index);
}
inline const ::url_pattern_index::proto::DomainListItem& CssRule::domains(int index) const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.CssRule.domains)
    return _internal_domains(index);
}
inline ::url_pattern_index::proto::DomainListItem* CssRule::_internal_add_domains()
{
    return _impl_.domains_.Add();
}
inline ::url_pattern_index::proto::DomainListItem* CssRule::add_domains()
{
    ::url_pattern_index::proto::DomainListItem* _add = _internal_add_domains();
    // @@protoc_insertion_point(field_add:url_pattern_index.proto.CssRule.domains)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::DomainListItem>& CssRule::domains() const
{
    // @@protoc_insertion_point(field_list:url_pattern_index.proto.CssRule.domains)
    return _impl_.domains_;
}

// optional string css_selector = 3;
inline bool CssRule::_internal_has_css_selector() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool CssRule::has_css_selector() const
{
    return _internal_has_css_selector();
}
inline void CssRule::clear_css_selector()
{
    _impl_.css_selector_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CssRule::css_selector() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.CssRule.css_selector)
    return _internal_css_selector();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CssRule::set_css_selector(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.css_selector_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.CssRule.css_selector)
}
inline std::string* CssRule::mutable_css_selector()
{
    std::string* _s = _internal_mutable_css_selector();
    // @@protoc_insertion_point(field_mutable:url_pattern_index.proto.CssRule.css_selector)
    return _s;
}
inline const std::string& CssRule::_internal_css_selector() const
{
    return _impl_.css_selector_.Get();
}
inline void CssRule::_internal_set_css_selector(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.css_selector_.Set(value, GetArenaForAllocation());
}
inline std::string* CssRule::_internal_mutable_css_selector()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.css_selector_.Mutable(GetArenaForAllocation());
}
inline std::string* CssRule::release_css_selector()
{
    // @@protoc_insertion_point(field_release:url_pattern_index.proto.CssRule.css_selector)
    if (!_internal_has_css_selector()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.css_selector_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.css_selector_.IsDefault()) {
        _impl_.css_selector_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void CssRule::set_allocated_css_selector(std::string* css_selector)
{
    if (css_selector != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.css_selector_.SetAllocated(css_selector, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.css_selector_.IsDefault()) {
        _impl_.css_selector_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:url_pattern_index.proto.CssRule.css_selector)
}

// -------------------------------------------------------------------

// Comment

// optional string text = 1;
inline bool Comment::_internal_has_text() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Comment::has_text() const
{
    return _internal_has_text();
}
inline void Comment::clear_text()
{
    _impl_.text_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Comment::text() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.Comment.text)
    return _internal_text();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Comment::set_text(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.text_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.Comment.text)
}
inline std::string* Comment::mutable_text()
{
    std::string* _s = _internal_mutable_text();
    // @@protoc_insertion_point(field_mutable:url_pattern_index.proto.Comment.text)
    return _s;
}
inline const std::string& Comment::_internal_text() const
{
    return _impl_.text_.Get();
}
inline void Comment::_internal_set_text(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* Comment::_internal_mutable_text()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.text_.Mutable(GetArenaForAllocation());
}
inline std::string* Comment::release_text()
{
    // @@protoc_insertion_point(field_release:url_pattern_index.proto.Comment.text)
    if (!_internal_has_text()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.text_.IsDefault()) {
        _impl_.text_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Comment::set_allocated_text(std::string* text)
{
    if (text != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.text_.IsDefault()) {
        _impl_.text_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:url_pattern_index.proto.Comment.text)
}

// optional string key = 2;
inline bool Comment::_internal_has_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Comment::has_key() const
{
    return _internal_has_key();
}
inline void Comment::clear_key()
{
    _impl_.key_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Comment::key() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.Comment.key)
    return _internal_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Comment::set_key(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.key_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.Comment.key)
}
inline std::string* Comment::mutable_key()
{
    std::string* _s = _internal_mutable_key();
    // @@protoc_insertion_point(field_mutable:url_pattern_index.proto.Comment.key)
    return _s;
}
inline const std::string& Comment::_internal_key() const
{
    return _impl_.key_.Get();
}
inline void Comment::_internal_set_key(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* Comment::_internal_mutable_key()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* Comment::release_key()
{
    // @@protoc_insertion_point(field_release:url_pattern_index.proto.Comment.key)
    if (!_internal_has_key()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.key_.IsDefault()) {
        _impl_.key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Comment::set_allocated_key(std::string* key)
{
    if (key != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.key_.IsDefault()) {
        _impl_.key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:url_pattern_index.proto.Comment.key)
}

// optional string value = 3;
inline bool Comment::_internal_has_value() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool Comment::has_value() const
{
    return _internal_has_value();
}
inline void Comment::clear_value()
{
    _impl_.value_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Comment::value() const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.Comment.value)
    return _internal_value();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Comment::set_value(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.value_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:url_pattern_index.proto.Comment.value)
}
inline std::string* Comment::mutable_value()
{
    std::string* _s = _internal_mutable_value();
    // @@protoc_insertion_point(field_mutable:url_pattern_index.proto.Comment.value)
    return _s;
}
inline const std::string& Comment::_internal_value() const
{
    return _impl_.value_.Get();
}
inline void Comment::_internal_set_value(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Comment::_internal_mutable_value()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* Comment::release_value()
{
    // @@protoc_insertion_point(field_release:url_pattern_index.proto.Comment.value)
    if (!_internal_has_value()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Comment::set_allocated_value(std::string* value)
{
    if (value != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.value_.IsDefault()) {
        _impl_.value_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:url_pattern_index.proto.Comment.value)
}

// -------------------------------------------------------------------

// FilteringRules

// repeated .url_pattern_index.proto.UrlRule url_rules = 1;
inline int FilteringRules::_internal_url_rules_size() const
{
    return _impl_.url_rules_.size();
}
inline int FilteringRules::url_rules_size() const
{
    return _internal_url_rules_size();
}
inline void FilteringRules::clear_url_rules()
{
    _impl_.url_rules_.Clear();
}
inline ::url_pattern_index::proto::UrlRule* FilteringRules::mutable_url_rules(int index)
{
    // @@protoc_insertion_point(field_mutable:url_pattern_index.proto.FilteringRules.url_rules)
    return _impl_.url_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::UrlRule>* FilteringRules::mutable_url_rules()
{
    // @@protoc_insertion_point(field_mutable_list:url_pattern_index.proto.FilteringRules.url_rules)
    return &_impl_.url_rules_;
}
inline const ::url_pattern_index::proto::UrlRule& FilteringRules::_internal_url_rules(int index) const
{
    return _impl_.url_rules_.Get(index);
}
inline const ::url_pattern_index::proto::UrlRule& FilteringRules::url_rules(int index) const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.FilteringRules.url_rules)
    return _internal_url_rules(index);
}
inline ::url_pattern_index::proto::UrlRule* FilteringRules::_internal_add_url_rules()
{
    return _impl_.url_rules_.Add();
}
inline ::url_pattern_index::proto::UrlRule* FilteringRules::add_url_rules()
{
    ::url_pattern_index::proto::UrlRule* _add = _internal_add_url_rules();
    // @@protoc_insertion_point(field_add:url_pattern_index.proto.FilteringRules.url_rules)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::UrlRule>& FilteringRules::url_rules() const
{
    // @@protoc_insertion_point(field_list:url_pattern_index.proto.FilteringRules.url_rules)
    return _impl_.url_rules_;
}

// repeated .url_pattern_index.proto.CssRule css_rules = 2;
inline int FilteringRules::_internal_css_rules_size() const
{
    return _impl_.css_rules_.size();
}
inline int FilteringRules::css_rules_size() const
{
    return _internal_css_rules_size();
}
inline void FilteringRules::clear_css_rules()
{
    _impl_.css_rules_.Clear();
}
inline ::url_pattern_index::proto::CssRule* FilteringRules::mutable_css_rules(int index)
{
    // @@protoc_insertion_point(field_mutable:url_pattern_index.proto.FilteringRules.css_rules)
    return _impl_.css_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::CssRule>* FilteringRules::mutable_css_rules()
{
    // @@protoc_insertion_point(field_mutable_list:url_pattern_index.proto.FilteringRules.css_rules)
    return &_impl_.css_rules_;
}
inline const ::url_pattern_index::proto::CssRule& FilteringRules::_internal_css_rules(int index) const
{
    return _impl_.css_rules_.Get(index);
}
inline const ::url_pattern_index::proto::CssRule& FilteringRules::css_rules(int index) const
{
    // @@protoc_insertion_point(field_get:url_pattern_index.proto.FilteringRules.css_rules)
    return _internal_css_rules(index);
}
inline ::url_pattern_index::proto::CssRule* FilteringRules::_internal_add_css_rules()
{
    return _impl_.css_rules_.Add();
}
inline ::url_pattern_index::proto::CssRule* FilteringRules::add_css_rules()
{
    ::url_pattern_index::proto::CssRule* _add = _internal_add_css_rules();
    // @@protoc_insertion_point(field_add:url_pattern_index.proto.FilteringRules.css_rules)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::url_pattern_index::proto::CssRule>& FilteringRules::css_rules() const
{
    // @@protoc_insertion_point(field_list:url_pattern_index.proto.FilteringRules.css_rules)
    return _impl_.css_rules_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace proto
} // namespace url_pattern_index

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::url_pattern_index::proto::RuleType> : ::std::true_type { };
template <> struct is_proto_enum<::url_pattern_index::proto::UrlPatternType> : ::std::true_type { };
template <> struct is_proto_enum<::url_pattern_index::proto::AnchorType> : ::std::true_type { };
template <> struct is_proto_enum<::url_pattern_index::proto::ElementType> : ::std::true_type { };
template <> struct is_proto_enum<::url_pattern_index::proto::ActivationType> : ::std::true_type { };
template <> struct is_proto_enum<::url_pattern_index::proto::RuleSemantics> : ::std::true_type { };
template <> struct is_proto_enum<::url_pattern_index::proto::SourceType> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_rules_2eproto
