// components/page_load_metrics/common/page_load_metrics.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_PAGE_LOAD_METRICS_COMMON_PAGE_LOAD_METRICS_MOJOM_SHARED_H_
#define COMPONENTS_PAGE_LOAD_METRICS_COMMON_PAGE_LOAD_METRICS_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "components/page_load_metrics/common/page_load_metrics.mojom-shared-internal.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "mojo/public/mojom/base/shared_memory.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "third_party/blink/public/mojom/loader/javascript_framework_detection.mojom-shared.h"
#include "services/network/public/mojom/request_priority.mojom-shared.h"
#include "third_party/blink/public/mojom/use_counter/use_counter_feature.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"
#include "mojo/public/cpp/system/data_pipe.h"

namespace page_load_metrics::mojom {
class DocumentTimingDataView;

class LcpResourceLoadTimingsDataView;

class LargestContentfulPaintTimingDataView;

class PaintTimingDataView;

class ParseTimingDataView;

class InteractiveTimingDataView;

class CustomUserTimingMarkDataView;

class DomainLookupTimingDataView;

class PageLoadTimingDataView;

class FrameMetadataDataView;

class SubresourceLoadMetricsDataView;

class ServiceWorkerSubresourceLoadMetricsDataView;

class ResourceDataUpdateDataView;

class LayoutShiftDataView;

class FrameRenderDataUpdateDataView;

class CpuTimingDataView;

class InputTimingDataView;

class UserInteractionLatencyDataView;

class BackForwardCacheTimingDataView;

class SoftNavigationMetricsDataView;

class UserInteractionLatenciesDataView;

} // page_load_metrics::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::page_load_metrics::mojom::DocumentTimingDataView> {
    using Data = ::page_load_metrics::mojom::internal::DocumentTiming_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::LcpResourceLoadTimingsDataView> {
    using Data = ::page_load_metrics::mojom::internal::LcpResourceLoadTimings_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView> {
    using Data = ::page_load_metrics::mojom::internal::LargestContentfulPaintTiming_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::PaintTimingDataView> {
    using Data = ::page_load_metrics::mojom::internal::PaintTiming_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::ParseTimingDataView> {
    using Data = ::page_load_metrics::mojom::internal::ParseTiming_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::InteractiveTimingDataView> {
    using Data = ::page_load_metrics::mojom::internal::InteractiveTiming_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::CustomUserTimingMarkDataView> {
    using Data = ::page_load_metrics::mojom::internal::CustomUserTimingMark_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::DomainLookupTimingDataView> {
    using Data = ::page_load_metrics::mojom::internal::DomainLookupTiming_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::PageLoadTimingDataView> {
    using Data = ::page_load_metrics::mojom::internal::PageLoadTiming_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::FrameMetadataDataView> {
    using Data = ::page_load_metrics::mojom::internal::FrameMetadata_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::SubresourceLoadMetricsDataView> {
    using Data = ::page_load_metrics::mojom::internal::SubresourceLoadMetrics_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::ServiceWorkerSubresourceLoadMetricsDataView> {
    using Data = ::page_load_metrics::mojom::internal::ServiceWorkerSubresourceLoadMetrics_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::ResourceDataUpdateDataView> {
    using Data = ::page_load_metrics::mojom::internal::ResourceDataUpdate_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::LayoutShiftDataView> {
    using Data = ::page_load_metrics::mojom::internal::LayoutShift_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::FrameRenderDataUpdateDataView> {
    using Data = ::page_load_metrics::mojom::internal::FrameRenderDataUpdate_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::CpuTimingDataView> {
    using Data = ::page_load_metrics::mojom::internal::CpuTiming_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::InputTimingDataView> {
    using Data = ::page_load_metrics::mojom::internal::InputTiming_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::UserInteractionLatencyDataView> {
    using Data = ::page_load_metrics::mojom::internal::UserInteractionLatency_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::BackForwardCacheTimingDataView> {
    using Data = ::page_load_metrics::mojom::internal::BackForwardCacheTiming_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::SoftNavigationMetricsDataView> {
    using Data = ::page_load_metrics::mojom::internal::SoftNavigationMetrics_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::page_load_metrics::mojom::UserInteractionLatenciesDataView> {
    using Data = ::page_load_metrics::mojom::internal::UserInteractionLatencies_Data;
    using DataAsArrayElement = Data;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

} // namespace internal
} // namespace mojo

namespace page_load_metrics::mojom {

enum class CacheType : int32_t {

    kNotCached = 0,

    kHttp = 1,

    kMemory = 2,
    kMinValue = 0,
    kMaxValue = 2,
};

std::ostream& operator<<(std::ostream& os, CacheType value);
inline bool IsKnownEnumValue(CacheType value)
{
    return internal::CacheType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class UserInteractionType : int32_t {

    kKeyboard = 0,

    kTapOrClick = 1,

    kDrag = 2,
    kMinValue = 0,
    kMaxValue = 2,
};

std::ostream& operator<<(std::ostream& os, UserInteractionType value);
inline bool IsKnownEnumValue(UserInteractionType value)
{
    return internal::UserInteractionType_Data::IsKnownValue(static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class PageLoadMetricsInterfaceBase { };

using PageLoadMetricsPtrDataView = mojo::InterfacePtrDataView<PageLoadMetricsInterfaceBase>;
using PageLoadMetricsRequestDataView = mojo::InterfaceRequestDataView<PageLoadMetricsInterfaceBase>;
using PageLoadMetricsAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<PageLoadMetricsInterfaceBase>;
using PageLoadMetricsAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<PageLoadMetricsInterfaceBase>;

class DocumentTimingDataView {
public:
    DocumentTimingDataView() = default;

    DocumentTimingDataView(internal::DocumentTiming_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetDomContentLoadedEventStartDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadDomContentLoadedEventStart(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `dom_content_loaded_event_start` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadDomContentLoadedEventStart` instead "
            "of `ReadDomContentLoadedEventStart if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->dom_content_loaded_event_start.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetLoadEventStartDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLoadEventStart(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `load_event_start` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadLoadEventStart` instead "
            "of `ReadLoadEventStart if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->load_event_start.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::DocumentTiming_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class LcpResourceLoadTimingsDataView {
public:
    LcpResourceLoadTimingsDataView() = default;

    LcpResourceLoadTimingsDataView(internal::LcpResourceLoadTimings_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetDiscoveryTimeDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadDiscoveryTime(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `discovery_time` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadDiscoveryTime` instead "
            "of `ReadDiscoveryTime if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->discovery_time.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetLoadStartDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLoadStart(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `load_start` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadLoadStart` instead "
            "of `ReadLoadStart if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->load_start.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetLoadEndDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLoadEnd(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `load_end` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadLoadEnd` instead "
            "of `ReadLoadEnd if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->load_end.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::LcpResourceLoadTimings_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class LargestContentfulPaintTimingDataView {
public:
    LargestContentfulPaintTimingDataView() = default;

    LargestContentfulPaintTimingDataView(internal::LargestContentfulPaintTiming_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetLargestImagePaintDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLargestImagePaint(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `largest_image_paint` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadLargestImagePaint` instead "
            "of `ReadLargestImagePaint if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->largest_image_paint.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    uint64_t largest_image_paint_size() const
    {
        return data_->largest_image_paint_size;
    }
    inline void GetLargestTextPaintDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLargestTextPaint(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `largest_text_paint` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadLargestTextPaint` instead "
            "of `ReadLargestTextPaint if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->largest_text_paint.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    uint64_t largest_text_paint_size() const
    {
        return data_->largest_text_paint_size;
    }
    inline void GetResourceLoadTimingsDataView(LcpResourceLoadTimingsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadResourceLoadTimings(UserType* output)
    {

        auto* pointer = data_->resource_load_timings.Get();
        return mojo::internal::Deserialize<::page_load_metrics::mojom::LcpResourceLoadTimingsDataView>(pointer, output, message_);
    }
    uint64_t type() const
    {
        return data_->type;
    }
    double image_bpp() const
    {
        return data_->image_bpp;
    }
    bool image_request_priority_valid() const
    {
        return data_->image_request_priority_valid;
    }
    template <typename UserType> [[nodiscard]] bool ReadImageRequestPriorityValue(UserType* output) const
    {
        auto data_value = data_->image_request_priority_value;
        return mojo::internal::Deserialize<::network::mojom::RequestPriority>(data_value, output);
    }
    ::network::mojom::RequestPriority image_request_priority_value() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::RequestPriority>(data_->image_request_priority_value));
    }

private:
    internal::LargestContentfulPaintTiming_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class PaintTimingDataView {
public:
    PaintTimingDataView() = default;

    PaintTimingDataView(internal::PaintTiming_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetFirstPaintDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFirstPaint(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `first_paint` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFirstPaint` instead "
            "of `ReadFirstPaint if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->first_paint.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetFirstImagePaintDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFirstImagePaint(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `first_image_paint` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFirstImagePaint` instead "
            "of `ReadFirstImagePaint if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->first_image_paint.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetFirstContentfulPaintDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFirstContentfulPaint(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `first_contentful_paint` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFirstContentfulPaint` instead "
            "of `ReadFirstContentfulPaint if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->first_contentful_paint.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetFirstMeaningfulPaintDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFirstMeaningfulPaint(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `first_meaningful_paint` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFirstMeaningfulPaint` instead "
            "of `ReadFirstMeaningfulPaint if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->first_meaningful_paint.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetLargestContentfulPaintDataView(LargestContentfulPaintTimingDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLargestContentfulPaint(UserType* output)
    {

        auto* pointer = data_->largest_contentful_paint.Get();
        return mojo::internal::Deserialize<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView>(pointer, output, message_);
    }
    inline void GetExperimentalLargestContentfulPaintDataView(LargestContentfulPaintTimingDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadExperimentalLargestContentfulPaint(UserType* output)
    {

        auto* pointer = data_->experimental_largest_contentful_paint.Get();
        return mojo::internal::Deserialize<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView>(pointer, output, message_);
    }
    inline void GetFirstEligibleToPaintDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFirstEligibleToPaint(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `first_eligible_to_paint` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFirstEligibleToPaint` instead "
            "of `ReadFirstEligibleToPaint if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->first_eligible_to_paint.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetFirstInputOrScrollNotifiedTimestampDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFirstInputOrScrollNotifiedTimestamp(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `first_input_or_scroll_notified_timestamp` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFirstInputOrScrollNotifiedTimestamp` instead "
            "of `ReadFirstInputOrScrollNotifiedTimestamp if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->first_input_or_scroll_notified_timestamp.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::PaintTiming_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class ParseTimingDataView {
public:
    ParseTimingDataView() = default;

    ParseTimingDataView(internal::ParseTiming_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetParseStartDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadParseStart(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `parse_start` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadParseStart` instead "
            "of `ReadParseStart if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->parse_start.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetParseStopDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadParseStop(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `parse_stop` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadParseStop` instead "
            "of `ReadParseStop if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->parse_stop.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetParseBlockedOnScriptLoadDurationDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadParseBlockedOnScriptLoadDuration(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `parse_blocked_on_script_load_duration` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadParseBlockedOnScriptLoadDuration` instead "
            "of `ReadParseBlockedOnScriptLoadDuration if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->parse_blocked_on_script_load_duration.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetParseBlockedOnScriptLoadFromDocumentWriteDurationDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadParseBlockedOnScriptLoadFromDocumentWriteDuration(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `parse_blocked_on_script_load_from_document_write_duration` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadParseBlockedOnScriptLoadFromDocumentWriteDuration` instead "
            "of `ReadParseBlockedOnScriptLoadFromDocumentWriteDuration if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->parse_blocked_on_script_load_from_document_write_duration.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetParseBlockedOnScriptExecutionDurationDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadParseBlockedOnScriptExecutionDuration(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `parse_blocked_on_script_execution_duration` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadParseBlockedOnScriptExecutionDuration` instead "
            "of `ReadParseBlockedOnScriptExecutionDuration if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->parse_blocked_on_script_execution_duration.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetParseBlockedOnScriptExecutionFromDocumentWriteDurationDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadParseBlockedOnScriptExecutionFromDocumentWriteDuration(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `parse_blocked_on_script_execution_from_document_write_duration` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadParseBlockedOnScriptExecutionFromDocumentWriteDuration` instead "
            "of `ReadParseBlockedOnScriptExecutionFromDocumentWriteDuration if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->parse_blocked_on_script_execution_from_document_write_duration.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::ParseTiming_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class InteractiveTimingDataView {
public:
    InteractiveTimingDataView() = default;

    InteractiveTimingDataView(internal::InteractiveTiming_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetFirstInputDelayDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFirstInputDelay(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `first_input_delay` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFirstInputDelay` instead "
            "of `ReadFirstInputDelay if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->first_input_delay.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetFirstInputTimestampDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFirstInputTimestamp(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `first_input_timestamp` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFirstInputTimestamp` instead "
            "of `ReadFirstInputTimestamp if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->first_input_timestamp.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetFirstScrollDelayDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFirstScrollDelay(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `first_scroll_delay` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFirstScrollDelay` instead "
            "of `ReadFirstScrollDelay if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->first_scroll_delay.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetFirstScrollTimestampDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFirstScrollTimestamp(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `first_scroll_timestamp` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFirstScrollTimestamp` instead "
            "of `ReadFirstScrollTimestamp if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->first_scroll_timestamp.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::InteractiveTiming_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class CustomUserTimingMarkDataView {
public:
    CustomUserTimingMarkDataView() = default;

    CustomUserTimingMarkDataView(internal::CustomUserTimingMark_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetMarkNameDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadMarkName(UserType* output)
    {

        auto* pointer = data_->mark_name.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetStartTimeDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadStartTime(UserType* output)
    {

        auto* pointer = data_->start_time.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::CustomUserTimingMark_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class DomainLookupTimingDataView {
public:
    DomainLookupTimingDataView() = default;

    DomainLookupTimingDataView(internal::DomainLookupTiming_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetDomainLookupStartDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadDomainLookupStart(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `domain_lookup_start` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadDomainLookupStart` instead "
            "of `ReadDomainLookupStart if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->domain_lookup_start.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetDomainLookupEndDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadDomainLookupEnd(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `domain_lookup_end` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadDomainLookupEnd` instead "
            "of `ReadDomainLookupEnd if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->domain_lookup_end.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::DomainLookupTiming_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class PageLoadTimingDataView {
public:
    PageLoadTimingDataView() = default;

    PageLoadTimingDataView(internal::PageLoadTiming_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetNavigationStartDataView(::mojo_base::mojom::TimeDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadNavigationStart(UserType* output)
    {

        auto* pointer = data_->navigation_start.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDataView>(pointer, output, message_);
    }
    inline void GetConnectStartDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadConnectStart(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `connect_start` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadConnectStart` instead "
            "of `ReadConnectStart if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->connect_start.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetConnectEndDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadConnectEnd(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `connect_end` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadConnectEnd` instead "
            "of `ReadConnectEnd if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->connect_end.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetResponseStartDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadResponseStart(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `response_start` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadResponseStart` instead "
            "of `ReadResponseStart if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->response_start.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetDocumentTimingDataView(DocumentTimingDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadDocumentTiming(UserType* output)
    {

        auto* pointer = data_->document_timing.Get();
        return mojo::internal::Deserialize<::page_load_metrics::mojom::DocumentTimingDataView>(pointer, output, message_);
    }
    inline void GetInteractiveTimingDataView(InteractiveTimingDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadInteractiveTiming(UserType* output)
    {

        auto* pointer = data_->interactive_timing.Get();
        return mojo::internal::Deserialize<::page_load_metrics::mojom::InteractiveTimingDataView>(pointer, output, message_);
    }
    inline void GetPaintTimingDataView(PaintTimingDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadPaintTiming(UserType* output)
    {

        auto* pointer = data_->paint_timing.Get();
        return mojo::internal::Deserialize<::page_load_metrics::mojom::PaintTimingDataView>(pointer, output, message_);
    }
    inline void GetParseTimingDataView(ParseTimingDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadParseTiming(UserType* output)
    {

        auto* pointer = data_->parse_timing.Get();
        return mojo::internal::Deserialize<::page_load_metrics::mojom::ParseTimingDataView>(pointer, output, message_);
    }
    inline void GetDomainLookupTimingDataView(DomainLookupTimingDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadDomainLookupTiming(UserType* output)
    {

        auto* pointer = data_->domain_lookup_timing.Get();
        return mojo::internal::Deserialize<::page_load_metrics::mojom::DomainLookupTimingDataView>(pointer, output, message_);
    }
    inline void GetBackForwardCacheTimingsDataView(mojo::ArrayDataView<BackForwardCacheTimingDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadBackForwardCacheTimings(UserType* output)
    {

        auto* pointer = data_->back_forward_cache_timings.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::page_load_metrics::mojom::BackForwardCacheTimingDataView>>(pointer, output, message_);
    }
    inline void GetActivationStartDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadActivationStart(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `activation_start` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadActivationStart` instead "
            "of `ReadActivationStart if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->activation_start.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetInputToNavigationStartDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadInputToNavigationStart(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `input_to_navigation_start` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadInputToNavigationStart` instead "
            "of `ReadInputToNavigationStart if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->input_to_navigation_start.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetUserTimingMarkFullyLoadedDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadUserTimingMarkFullyLoaded(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `user_timing_mark_fully_loaded` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadUserTimingMarkFullyLoaded` instead "
            "of `ReadUserTimingMarkFullyLoaded if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->user_timing_mark_fully_loaded.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetUserTimingMarkFullyVisibleDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadUserTimingMarkFullyVisible(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `user_timing_mark_fully_visible` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadUserTimingMarkFullyVisible` instead "
            "of `ReadUserTimingMarkFullyVisible if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->user_timing_mark_fully_visible.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetUserTimingMarkInteractiveDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadUserTimingMarkInteractive(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `user_timing_mark_interactive` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadUserTimingMarkInteractive` instead "
            "of `ReadUserTimingMarkInteractive if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->user_timing_mark_interactive.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::PageLoadTiming_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class FrameMetadataDataView {
public:
    FrameMetadataDataView() = default;

    FrameMetadataDataView(internal::FrameMetadata_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    int32_t behavior_flags() const
    {
        return data_->behavior_flags;
    }
    inline void GetMainFrameIntersectionRectDataView(::gfx::mojom::RectDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadMainFrameIntersectionRect(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::gfx::mojom::RectDataView, UserType>(),
            "Attempting to read the optional `main_frame_intersection_rect` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadMainFrameIntersectionRect` instead "
            "of `ReadMainFrameIntersectionRect if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->main_frame_intersection_rect.Get();
        return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(pointer, output, message_);
    }
    inline void GetMainFrameViewportRectDataView(::gfx::mojom::RectDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadMainFrameViewportRect(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::gfx::mojom::RectDataView, UserType>(),
            "Attempting to read the optional `main_frame_viewport_rect` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadMainFrameViewportRect` instead "
            "of `ReadMainFrameViewportRect if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->main_frame_viewport_rect.Get();
        return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(pointer, output, message_);
    }
    inline void GetMainFrameImageAdRectsDataView(mojo::MapDataView<int32_t, ::gfx::mojom::RectDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadMainFrameImageAdRects(UserType* output)
    {

        auto* pointer = data_->main_frame_image_ad_rects.Get();
        return mojo::internal::Deserialize<mojo::MapDataView<int32_t, ::gfx::mojom::RectDataView>>(pointer, output, message_);
    }
    inline void GetFrameworkDetectionResultDataView(::blink::mojom::JavaScriptFrameworkDetectionResultDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFrameworkDetectionResult(UserType* output)
    {

        auto* pointer = data_->framework_detection_result.Get();
        return mojo::internal::Deserialize<::blink::mojom::JavaScriptFrameworkDetectionResultDataView>(pointer, output, message_);
    }

private:
    internal::FrameMetadata_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class SubresourceLoadMetricsDataView {
public:
    SubresourceLoadMetricsDataView() = default;

    SubresourceLoadMetricsDataView(internal::SubresourceLoadMetrics_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t number_of_subresources_loaded() const
    {
        return data_->number_of_subresources_loaded;
    }
    uint32_t number_of_subresource_loads_handled_by_service_worker() const
    {
        return data_->number_of_subresource_loads_handled_by_service_worker;
    }
    inline void GetServiceWorkerSubresourceLoadMetricsDataView(ServiceWorkerSubresourceLoadMetricsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadServiceWorkerSubresourceLoadMetrics(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::page_load_metrics::mojom::ServiceWorkerSubresourceLoadMetricsDataView, UserType>(),
            "Attempting to read the optional `service_worker_subresource_load_metrics` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadServiceWorkerSubresourceLoadMetrics` instead "
            "of `ReadServiceWorkerSubresourceLoadMetrics if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->service_worker_subresource_load_metrics.Get();
        return mojo::internal::Deserialize<::page_load_metrics::mojom::ServiceWorkerSubresourceLoadMetricsDataView>(pointer, output, message_);
    }

private:
    internal::SubresourceLoadMetrics_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class ServiceWorkerSubresourceLoadMetricsDataView {
public:
    ServiceWorkerSubresourceLoadMetricsDataView() = default;

    ServiceWorkerSubresourceLoadMetricsDataView(internal::ServiceWorkerSubresourceLoadMetrics_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    bool image_handled() const
    {
        return data_->image_handled;
    }
    bool image_fallback() const
    {
        return data_->image_fallback;
    }
    bool css_handled() const
    {
        return data_->css_handled;
    }
    bool css_fallback() const
    {
        return data_->css_fallback;
    }
    bool script_handled() const
    {
        return data_->script_handled;
    }
    bool script_fallback() const
    {
        return data_->script_fallback;
    }
    bool font_handled() const
    {
        return data_->font_handled;
    }
    bool font_fallback() const
    {
        return data_->font_fallback;
    }
    bool raw_handled() const
    {
        return data_->raw_handled;
    }
    bool raw_fallback() const
    {
        return data_->raw_fallback;
    }
    bool svg_handled() const
    {
        return data_->svg_handled;
    }
    bool svg_fallback() const
    {
        return data_->svg_fallback;
    }
    bool xsl_handled() const
    {
        return data_->xsl_handled;
    }
    bool xsl_fallback() const
    {
        return data_->xsl_fallback;
    }
    bool link_prefetch_handled() const
    {
        return data_->link_prefetch_handled;
    }
    bool link_prefetch_fallback() const
    {
        return data_->link_prefetch_fallback;
    }
    bool text_track_handled() const
    {
        return data_->text_track_handled;
    }
    bool text_track_fallback() const
    {
        return data_->text_track_fallback;
    }
    bool audio_handled() const
    {
        return data_->audio_handled;
    }
    bool audio_fallback() const
    {
        return data_->audio_fallback;
    }
    bool video_handled() const
    {
        return data_->video_handled;
    }
    bool video_fallback() const
    {
        return data_->video_fallback;
    }
    bool manifest_handled() const
    {
        return data_->manifest_handled;
    }
    bool manifest_fallback() const
    {
        return data_->manifest_fallback;
    }
    bool speculation_rules_handled() const
    {
        return data_->speculation_rules_handled;
    }
    bool speculation_rules_fallback() const
    {
        return data_->speculation_rules_fallback;
    }
    bool mock_handled() const
    {
        return data_->mock_handled;
    }
    bool mock_fallback() const
    {
        return data_->mock_fallback;
    }
    bool dictionary_handled() const
    {
        return data_->dictionary_handled;
    }
    bool dictionary_fallback() const
    {
        return data_->dictionary_fallback;
    }
    uint32_t matched_cache_router_source_count() const
    {
        return data_->matched_cache_router_source_count;
    }
    uint32_t matched_fetch_event_router_source_count() const
    {
        return data_->matched_fetch_event_router_source_count;
    }
    uint32_t matched_network_router_source_count() const
    {
        return data_->matched_network_router_source_count;
    }
    uint32_t matched_race_network_and_fetch_router_source_count() const
    {
        return data_->matched_race_network_and_fetch_router_source_count;
    }
    inline void GetTotalRouterEvaluationTimeForSubresourcesDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadTotalRouterEvaluationTimeForSubresources(UserType* output)
    {

        auto* pointer = data_->total_router_evaluation_time_for_subresources.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetTotalCacheLookupTimeForSubresourcesDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadTotalCacheLookupTimeForSubresources(UserType* output)
    {

        auto* pointer = data_->total_cache_lookup_time_for_subresources.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::ServiceWorkerSubresourceLoadMetrics_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class ResourceDataUpdateDataView {
public:
    ResourceDataUpdateDataView() = default;

    ResourceDataUpdateDataView(internal::ResourceDataUpdate_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    int32_t request_id() const
    {
        return data_->request_id;
    }
    int64_t delta_bytes() const
    {
        return data_->delta_bytes;
    }
    int64_t received_data_length() const
    {
        return data_->received_data_length;
    }
    int64_t encoded_body_length() const
    {
        return data_->encoded_body_length;
    }
    int64_t decoded_body_length() const
    {
        return data_->decoded_body_length;
    }
    bool is_complete() const
    {
        return data_->is_complete;
    }
    bool reported_as_ad_resource() const
    {
        return data_->reported_as_ad_resource;
    }
    bool is_main_frame_resource() const
    {
        return data_->is_main_frame_resource;
    }
    template <typename UserType> [[nodiscard]] bool ReadCacheType(UserType* output) const
    {
        auto data_value = data_->cache_type;
        return mojo::internal::Deserialize<::page_load_metrics::mojom::CacheType>(data_value, output);
    }
    CacheType cache_type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::page_load_metrics::mojom::CacheType>(data_->cache_type));
    }
    bool is_primary_frame_resource() const
    {
        return data_->is_primary_frame_resource;
    }
    inline void GetMimeTypeDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadMimeType(UserType* output)
    {

        auto* pointer = data_->mime_type.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    bool is_secure_scheme() const
    {
        return data_->is_secure_scheme;
    }
    bool proxy_used() const
    {
        return data_->proxy_used;
    }

private:
    internal::ResourceDataUpdate_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class LayoutShiftDataView {
public:
    LayoutShiftDataView() = default;

    LayoutShiftDataView(internal::LayoutShift_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetLayoutShiftTimeDataView(::mojo_base::mojom::TimeTicksDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLayoutShiftTime(UserType* output)
    {

        auto* pointer = data_->layout_shift_time.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeTicksDataView>(pointer, output, message_);
    }
    double layout_shift_score() const
    {
        return data_->layout_shift_score;
    }

private:
    internal::LayoutShift_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class FrameRenderDataUpdateDataView {
public:
    FrameRenderDataUpdateDataView() = default;

    FrameRenderDataUpdateDataView(internal::FrameRenderDataUpdate_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    float layout_shift_delta() const
    {
        return data_->layout_shift_delta;
    }
    float layout_shift_delta_before_input_or_scroll() const
    {
        return data_->layout_shift_delta_before_input_or_scroll;
    }
    inline void GetNewLayoutShiftsDataView(mojo::ArrayDataView<LayoutShiftDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadNewLayoutShifts(UserType* output)
    {

        auto* pointer = data_->new_layout_shifts.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::page_load_metrics::mojom::LayoutShiftDataView>>(pointer, output, message_);
    }

private:
    internal::FrameRenderDataUpdate_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class CpuTimingDataView {
public:
    CpuTimingDataView() = default;

    CpuTimingDataView(internal::CpuTiming_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetTaskTimeDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadTaskTime(UserType* output)
    {

        auto* pointer = data_->task_time.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::CpuTiming_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class InputTimingDataView {
public:
    InputTimingDataView() = default;

    InputTimingDataView(internal::InputTiming_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint64_t num_interactions() const
    {
        return data_->num_interactions;
    }
    inline void GetMaxEventDurationsDataView(UserInteractionLatenciesDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadMaxEventDurations(UserType* output)
    {

        auto* pointer = !data_->max_event_durations.is_null() ? &data_->max_event_durations : nullptr;
        return mojo::internal::Deserialize<::page_load_metrics::mojom::UserInteractionLatenciesDataView>(pointer, output, message_);
    }

private:
    internal::InputTiming_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class UserInteractionLatencyDataView {
public:
    UserInteractionLatencyDataView() = default;

    UserInteractionLatencyDataView(internal::UserInteractionLatency_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetInteractionLatencyDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadInteractionLatency(UserType* output)
    {

        auto* pointer = data_->interaction_latency.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    template <typename UserType> [[nodiscard]] bool ReadInteractionType(UserType* output) const
    {
        auto data_value = data_->interaction_type;
        return mojo::internal::Deserialize<::page_load_metrics::mojom::UserInteractionType>(data_value, output);
    }
    UserInteractionType interaction_type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::page_load_metrics::mojom::UserInteractionType>(data_->interaction_type));
    }
    uint64_t interaction_offset() const
    {
        return data_->interaction_offset;
    }
    inline void GetInteractionTimeDataView(::mojo_base::mojom::TimeTicksDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadInteractionTime(UserType* output)
    {

        auto* pointer = data_->interaction_time.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeTicksDataView>(pointer, output, message_);
    }

private:
    internal::UserInteractionLatency_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class BackForwardCacheTimingDataView {
public:
    BackForwardCacheTimingDataView() = default;

    BackForwardCacheTimingDataView(internal::BackForwardCacheTiming_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetFirstPaintAfterBackForwardCacheRestoreDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFirstPaintAfterBackForwardCacheRestore(UserType* output)
    {

        auto* pointer = data_->first_paint_after_back_forward_cache_restore.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetRequestAnimationFramesAfterBackForwardCacheRestoreDataView(mojo::ArrayDataView<::mojo_base::mojom::TimeDeltaDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadRequestAnimationFramesAfterBackForwardCacheRestore(UserType* output)
    {

        auto* pointer = data_->request_animation_frames_after_back_forward_cache_restore.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::mojo_base::mojom::TimeDeltaDataView>>(pointer, output, message_);
    }
    inline void GetFirstInputDelayAfterBackForwardCacheRestoreDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadFirstInputDelayAfterBackForwardCacheRestore(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDeltaDataView, UserType>(),
            "Attempting to read the optional `first_input_delay_after_back_forward_cache_restore` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadFirstInputDelayAfterBackForwardCacheRestore` instead "
            "of `ReadFirstInputDelayAfterBackForwardCacheRestore if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->first_input_delay_after_back_forward_cache_restore.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }

private:
    internal::BackForwardCacheTiming_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class SoftNavigationMetricsDataView {
public:
    SoftNavigationMetricsDataView() = default;

    SoftNavigationMetricsDataView(internal::SoftNavigationMetrics_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint64_t count() const
    {
        return data_->count;
    }
    inline void GetStartTimeDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadStartTime(UserType* output)
    {

        auto* pointer = data_->start_time.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    inline void GetNavigationIdDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadNavigationId(UserType* output)
    {

        auto* pointer = data_->navigation_id.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetLargestContentfulPaintDataView(LargestContentfulPaintTimingDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLargestContentfulPaint(UserType* output)
    {

        auto* pointer = data_->largest_contentful_paint.Get();
        return mojo::internal::Deserialize<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView>(pointer, output, message_);
    }

private:
    internal::SoftNavigationMetrics_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class UserInteractionLatenciesDataView {
public:
    using Tag = internal::UserInteractionLatencies_Data::UserInteractionLatencies_Tag;

    UserInteractionLatenciesDataView() = default;

    UserInteractionLatenciesDataView(internal::UserInteractionLatencies_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        // For inlined unions, |data_| is always non-null. In that case we need to
        // check |data_->is_null()|.
        return !data_ || data_->is_null();
    }

    Tag tag() const
    {
        return data_->tag;
    }
    bool is_user_interaction_latencies() const
    {
        return data_->tag == Tag::kUserInteractionLatencies;
    }
    inline void GetUserInteractionLatenciesDataView(mojo::ArrayDataView<UserInteractionLatencyDataView>* output) const;

    template <typename UserType> [[nodiscard]] bool ReadUserInteractionLatencies(UserType* output) const
    {

        CHECK(is_user_interaction_latencies());
        return mojo::internal::Deserialize<mojo::ArrayDataView<::page_load_metrics::mojom::UserInteractionLatencyDataView>>(
            data_->data.f_user_interaction_latencies.Get(), output, message_);
    }
    bool is_worst_interaction_latency() const
    {
        return data_->tag == Tag::kWorstInteractionLatency;
    }
    inline void GetWorstInteractionLatencyDataView(::mojo_base::mojom::TimeDeltaDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadWorstInteractionLatency(UserType* output) const
    {

        CHECK(is_worst_interaction_latency());
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(data_->data.f_worst_interaction_latency.Get(), output, message_);
    }

private:
    internal::UserInteractionLatencies_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

} // page_load_metrics::mojom

namespace std {

template <> struct hash<::page_load_metrics::mojom::CacheType> : public mojo::internal::EnumHashImpl<::page_load_metrics::mojom::CacheType> { };

template <>
struct hash<::page_load_metrics::mojom::UserInteractionType> : public mojo::internal::EnumHashImpl<::page_load_metrics::mojom::UserInteractionType> { };

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::CacheType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::page_load_metrics::mojom::CacheType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::page_load_metrics::mojom::CacheType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::UserInteractionType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::page_load_metrics::mojom::UserInteractionType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::page_load_metrics::mojom::UserInteractionType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::DocumentTimingDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::DocumentTimingDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::DocumentTiming_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::dom_content_loaded_event_start(input)) in_dom_content_loaded_event_start = Traits::dom_content_loaded_event_start(input);
        mojo::internal::MessageFragment<typename decltype(fragment->dom_content_loaded_event_start)::BaseType> dom_content_loaded_event_start_fragment(
            fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_dom_content_loaded_event_start, dom_content_loaded_event_start_fragment);
        fragment->dom_content_loaded_event_start.Set(
            dom_content_loaded_event_start_fragment.is_null() ? nullptr : dom_content_loaded_event_start_fragment.data());
        decltype(Traits::load_event_start(input)) in_load_event_start = Traits::load_event_start(input);
        mojo::internal::MessageFragment<typename decltype(fragment->load_event_start)::BaseType> load_event_start_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_load_event_start, load_event_start_fragment);
        fragment->load_event_start.Set(load_event_start_fragment.is_null() ? nullptr : load_event_start_fragment.data());
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::DocumentTiming_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::DocumentTimingDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::LcpResourceLoadTimingsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::LcpResourceLoadTimingsDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::LcpResourceLoadTimings_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::discovery_time(input)) in_discovery_time = Traits::discovery_time(input);
        mojo::internal::MessageFragment<typename decltype(fragment->discovery_time)::BaseType> discovery_time_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_discovery_time, discovery_time_fragment);
        fragment->discovery_time.Set(discovery_time_fragment.is_null() ? nullptr : discovery_time_fragment.data());
        decltype(Traits::load_start(input)) in_load_start = Traits::load_start(input);
        mojo::internal::MessageFragment<typename decltype(fragment->load_start)::BaseType> load_start_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_load_start, load_start_fragment);
        fragment->load_start.Set(load_start_fragment.is_null() ? nullptr : load_start_fragment.data());
        decltype(Traits::load_end(input)) in_load_end = Traits::load_end(input);
        mojo::internal::MessageFragment<typename decltype(fragment->load_end)::BaseType> load_end_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_load_end, load_end_fragment);
        fragment->load_end.Set(load_end_fragment.is_null() ? nullptr : load_end_fragment.data());
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::LcpResourceLoadTimings_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::LcpResourceLoadTimingsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::LargestContentfulPaintTiming_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::largest_image_paint(input)) in_largest_image_paint = Traits::largest_image_paint(input);
        mojo::internal::MessageFragment<typename decltype(fragment->largest_image_paint)::BaseType> largest_image_paint_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_largest_image_paint, largest_image_paint_fragment);
        fragment->largest_image_paint.Set(largest_image_paint_fragment.is_null() ? nullptr : largest_image_paint_fragment.data());
        fragment->largest_image_paint_size = Traits::largest_image_paint_size(input);
        decltype(Traits::largest_text_paint(input)) in_largest_text_paint = Traits::largest_text_paint(input);
        mojo::internal::MessageFragment<typename decltype(fragment->largest_text_paint)::BaseType> largest_text_paint_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_largest_text_paint, largest_text_paint_fragment);
        fragment->largest_text_paint.Set(largest_text_paint_fragment.is_null() ? nullptr : largest_text_paint_fragment.data());
        fragment->largest_text_paint_size = Traits::largest_text_paint_size(input);
        decltype(Traits::resource_load_timings(input)) in_resource_load_timings = Traits::resource_load_timings(input);
        mojo::internal::MessageFragment<typename decltype(fragment->resource_load_timings)::BaseType> resource_load_timings_fragment(fragment.message());
        mojo::internal::Serialize<::page_load_metrics::mojom::LcpResourceLoadTimingsDataView>(in_resource_load_timings, resource_load_timings_fragment);
        fragment->resource_load_timings.Set(resource_load_timings_fragment.is_null() ? nullptr : resource_load_timings_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->resource_load_timings.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null resource_load_timings in LargestContentfulPaintTiming struct");
        fragment->type = Traits::type(input);
        fragment->image_bpp = Traits::image_bpp(input);
        fragment->image_request_priority_valid = Traits::image_request_priority_valid(input);
        mojo::internal::Serialize<::network::mojom::RequestPriority>(Traits::image_request_priority_value(input), &fragment->image_request_priority_value);
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::LargestContentfulPaintTiming_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::LargestContentfulPaintTimingDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::PaintTimingDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::PaintTimingDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::PaintTiming_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::first_paint(input)) in_first_paint = Traits::first_paint(input);
        mojo::internal::MessageFragment<typename decltype(fragment->first_paint)::BaseType> first_paint_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_first_paint, first_paint_fragment);
        fragment->first_paint.Set(first_paint_fragment.is_null() ? nullptr : first_paint_fragment.data());
        decltype(Traits::first_image_paint(input)) in_first_image_paint = Traits::first_image_paint(input);
        mojo::internal::MessageFragment<typename decltype(fragment->first_image_paint)::BaseType> first_image_paint_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_first_image_paint, first_image_paint_fragment);
        fragment->first_image_paint.Set(first_image_paint_fragment.is_null() ? nullptr : first_image_paint_fragment.data());
        decltype(Traits::first_contentful_paint(input)) in_first_contentful_paint = Traits::first_contentful_paint(input);
        mojo::internal::MessageFragment<typename decltype(fragment->first_contentful_paint)::BaseType> first_contentful_paint_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_first_contentful_paint, first_contentful_paint_fragment);
        fragment->first_contentful_paint.Set(first_contentful_paint_fragment.is_null() ? nullptr : first_contentful_paint_fragment.data());
        decltype(Traits::first_meaningful_paint(input)) in_first_meaningful_paint = Traits::first_meaningful_paint(input);
        mojo::internal::MessageFragment<typename decltype(fragment->first_meaningful_paint)::BaseType> first_meaningful_paint_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_first_meaningful_paint, first_meaningful_paint_fragment);
        fragment->first_meaningful_paint.Set(first_meaningful_paint_fragment.is_null() ? nullptr : first_meaningful_paint_fragment.data());
        decltype(Traits::largest_contentful_paint(input)) in_largest_contentful_paint = Traits::largest_contentful_paint(input);
        mojo::internal::MessageFragment<typename decltype(fragment->largest_contentful_paint)::BaseType> largest_contentful_paint_fragment(fragment.message());
        mojo::internal::Serialize<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView>(
            in_largest_contentful_paint, largest_contentful_paint_fragment);
        fragment->largest_contentful_paint.Set(largest_contentful_paint_fragment.is_null() ? nullptr : largest_contentful_paint_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->largest_contentful_paint.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null largest_contentful_paint in PaintTiming struct");
        decltype(Traits::experimental_largest_contentful_paint(input)) in_experimental_largest_contentful_paint
            = Traits::experimental_largest_contentful_paint(input);
        mojo::internal::MessageFragment<typename decltype(fragment->experimental_largest_contentful_paint)::BaseType>
            experimental_largest_contentful_paint_fragment(fragment.message());
        mojo::internal::Serialize<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView>(
            in_experimental_largest_contentful_paint, experimental_largest_contentful_paint_fragment);
        fragment->experimental_largest_contentful_paint.Set(
            experimental_largest_contentful_paint_fragment.is_null() ? nullptr : experimental_largest_contentful_paint_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->experimental_largest_contentful_paint.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null experimental_largest_contentful_paint in PaintTiming struct");
        decltype(Traits::first_eligible_to_paint(input)) in_first_eligible_to_paint = Traits::first_eligible_to_paint(input);
        mojo::internal::MessageFragment<typename decltype(fragment->first_eligible_to_paint)::BaseType> first_eligible_to_paint_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_first_eligible_to_paint, first_eligible_to_paint_fragment);
        fragment->first_eligible_to_paint.Set(first_eligible_to_paint_fragment.is_null() ? nullptr : first_eligible_to_paint_fragment.data());
        decltype(Traits::first_input_or_scroll_notified_timestamp(input)) in_first_input_or_scroll_notified_timestamp
            = Traits::first_input_or_scroll_notified_timestamp(input);
        mojo::internal::MessageFragment<typename decltype(fragment->first_input_or_scroll_notified_timestamp)::BaseType>
            first_input_or_scroll_notified_timestamp_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
            in_first_input_or_scroll_notified_timestamp, first_input_or_scroll_notified_timestamp_fragment);
        fragment->first_input_or_scroll_notified_timestamp.Set(
            first_input_or_scroll_notified_timestamp_fragment.is_null() ? nullptr : first_input_or_scroll_notified_timestamp_fragment.data());
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::PaintTiming_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::PaintTimingDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::ParseTimingDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::ParseTimingDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::ParseTiming_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::parse_start(input)) in_parse_start = Traits::parse_start(input);
        mojo::internal::MessageFragment<typename decltype(fragment->parse_start)::BaseType> parse_start_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_parse_start, parse_start_fragment);
        fragment->parse_start.Set(parse_start_fragment.is_null() ? nullptr : parse_start_fragment.data());
        decltype(Traits::parse_stop(input)) in_parse_stop = Traits::parse_stop(input);
        mojo::internal::MessageFragment<typename decltype(fragment->parse_stop)::BaseType> parse_stop_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_parse_stop, parse_stop_fragment);
        fragment->parse_stop.Set(parse_stop_fragment.is_null() ? nullptr : parse_stop_fragment.data());
        decltype(Traits::parse_blocked_on_script_load_duration(input)) in_parse_blocked_on_script_load_duration
            = Traits::parse_blocked_on_script_load_duration(input);
        mojo::internal::MessageFragment<typename decltype(fragment->parse_blocked_on_script_load_duration)::BaseType>
            parse_blocked_on_script_load_duration_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
            in_parse_blocked_on_script_load_duration, parse_blocked_on_script_load_duration_fragment);
        fragment->parse_blocked_on_script_load_duration.Set(
            parse_blocked_on_script_load_duration_fragment.is_null() ? nullptr : parse_blocked_on_script_load_duration_fragment.data());
        decltype(Traits::parse_blocked_on_script_load_from_document_write_duration(input)) in_parse_blocked_on_script_load_from_document_write_duration
            = Traits::parse_blocked_on_script_load_from_document_write_duration(input);
        mojo::internal::MessageFragment<typename decltype(fragment->parse_blocked_on_script_load_from_document_write_duration)::BaseType>
            parse_blocked_on_script_load_from_document_write_duration_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
            in_parse_blocked_on_script_load_from_document_write_duration, parse_blocked_on_script_load_from_document_write_duration_fragment);
        fragment->parse_blocked_on_script_load_from_document_write_duration.Set(parse_blocked_on_script_load_from_document_write_duration_fragment.is_null()
                ? nullptr
                : parse_blocked_on_script_load_from_document_write_duration_fragment.data());
        decltype(Traits::parse_blocked_on_script_execution_duration(input)) in_parse_blocked_on_script_execution_duration
            = Traits::parse_blocked_on_script_execution_duration(input);
        mojo::internal::MessageFragment<typename decltype(fragment->parse_blocked_on_script_execution_duration)::BaseType>
            parse_blocked_on_script_execution_duration_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
            in_parse_blocked_on_script_execution_duration, parse_blocked_on_script_execution_duration_fragment);
        fragment->parse_blocked_on_script_execution_duration.Set(
            parse_blocked_on_script_execution_duration_fragment.is_null() ? nullptr : parse_blocked_on_script_execution_duration_fragment.data());
        decltype(Traits::parse_blocked_on_script_execution_from_document_write_duration(
            input)) in_parse_blocked_on_script_execution_from_document_write_duration
            = Traits::parse_blocked_on_script_execution_from_document_write_duration(input);
        mojo::internal::MessageFragment<typename decltype(fragment->parse_blocked_on_script_execution_from_document_write_duration)::BaseType>
            parse_blocked_on_script_execution_from_document_write_duration_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
            in_parse_blocked_on_script_execution_from_document_write_duration, parse_blocked_on_script_execution_from_document_write_duration_fragment);
        fragment->parse_blocked_on_script_execution_from_document_write_duration.Set(
            parse_blocked_on_script_execution_from_document_write_duration_fragment.is_null()
                ? nullptr
                : parse_blocked_on_script_execution_from_document_write_duration_fragment.data());
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::ParseTiming_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::ParseTimingDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::InteractiveTimingDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::InteractiveTimingDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::InteractiveTiming_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::first_input_delay(input)) in_first_input_delay = Traits::first_input_delay(input);
        mojo::internal::MessageFragment<typename decltype(fragment->first_input_delay)::BaseType> first_input_delay_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_first_input_delay, first_input_delay_fragment);
        fragment->first_input_delay.Set(first_input_delay_fragment.is_null() ? nullptr : first_input_delay_fragment.data());
        decltype(Traits::first_input_timestamp(input)) in_first_input_timestamp = Traits::first_input_timestamp(input);
        mojo::internal::MessageFragment<typename decltype(fragment->first_input_timestamp)::BaseType> first_input_timestamp_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_first_input_timestamp, first_input_timestamp_fragment);
        fragment->first_input_timestamp.Set(first_input_timestamp_fragment.is_null() ? nullptr : first_input_timestamp_fragment.data());
        decltype(Traits::first_scroll_delay(input)) in_first_scroll_delay = Traits::first_scroll_delay(input);
        mojo::internal::MessageFragment<typename decltype(fragment->first_scroll_delay)::BaseType> first_scroll_delay_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_first_scroll_delay, first_scroll_delay_fragment);
        fragment->first_scroll_delay.Set(first_scroll_delay_fragment.is_null() ? nullptr : first_scroll_delay_fragment.data());
        decltype(Traits::first_scroll_timestamp(input)) in_first_scroll_timestamp = Traits::first_scroll_timestamp(input);
        mojo::internal::MessageFragment<typename decltype(fragment->first_scroll_timestamp)::BaseType> first_scroll_timestamp_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_first_scroll_timestamp, first_scroll_timestamp_fragment);
        fragment->first_scroll_timestamp.Set(first_scroll_timestamp_fragment.is_null() ? nullptr : first_scroll_timestamp_fragment.data());
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::InteractiveTiming_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::InteractiveTimingDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::CustomUserTimingMarkDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::CustomUserTimingMarkDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::CustomUserTimingMark_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::mark_name(input)) in_mark_name = Traits::mark_name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->mark_name)::BaseType> mark_name_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_mark_name, mark_name_fragment);
        fragment->mark_name.Set(mark_name_fragment.is_null() ? nullptr : mark_name_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->mark_name.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null mark_name in CustomUserTimingMark struct");
        decltype(Traits::start_time(input)) in_start_time = Traits::start_time(input);
        mojo::internal::MessageFragment<typename decltype(fragment->start_time)::BaseType> start_time_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_start_time, start_time_fragment);
        fragment->start_time.Set(start_time_fragment.is_null() ? nullptr : start_time_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->start_time.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null start_time in CustomUserTimingMark struct");
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::CustomUserTimingMark_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::CustomUserTimingMarkDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::DomainLookupTimingDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::DomainLookupTimingDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::DomainLookupTiming_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::domain_lookup_start(input)) in_domain_lookup_start = Traits::domain_lookup_start(input);
        mojo::internal::MessageFragment<typename decltype(fragment->domain_lookup_start)::BaseType> domain_lookup_start_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_domain_lookup_start, domain_lookup_start_fragment);
        fragment->domain_lookup_start.Set(domain_lookup_start_fragment.is_null() ? nullptr : domain_lookup_start_fragment.data());
        decltype(Traits::domain_lookup_end(input)) in_domain_lookup_end = Traits::domain_lookup_end(input);
        mojo::internal::MessageFragment<typename decltype(fragment->domain_lookup_end)::BaseType> domain_lookup_end_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_domain_lookup_end, domain_lookup_end_fragment);
        fragment->domain_lookup_end.Set(domain_lookup_end_fragment.is_null() ? nullptr : domain_lookup_end_fragment.data());
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::DomainLookupTiming_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::DomainLookupTimingDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::PageLoadTimingDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::PageLoadTimingDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::PageLoadTiming_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::navigation_start(input)) in_navigation_start = Traits::navigation_start(input);
        mojo::internal::MessageFragment<typename decltype(fragment->navigation_start)::BaseType> navigation_start_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(in_navigation_start, navigation_start_fragment);
        fragment->navigation_start.Set(navigation_start_fragment.is_null() ? nullptr : navigation_start_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->navigation_start.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null navigation_start in PageLoadTiming struct");
        decltype(Traits::connect_start(input)) in_connect_start = Traits::connect_start(input);
        mojo::internal::MessageFragment<typename decltype(fragment->connect_start)::BaseType> connect_start_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_connect_start, connect_start_fragment);
        fragment->connect_start.Set(connect_start_fragment.is_null() ? nullptr : connect_start_fragment.data());
        decltype(Traits::connect_end(input)) in_connect_end = Traits::connect_end(input);
        mojo::internal::MessageFragment<typename decltype(fragment->connect_end)::BaseType> connect_end_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_connect_end, connect_end_fragment);
        fragment->connect_end.Set(connect_end_fragment.is_null() ? nullptr : connect_end_fragment.data());
        decltype(Traits::response_start(input)) in_response_start = Traits::response_start(input);
        mojo::internal::MessageFragment<typename decltype(fragment->response_start)::BaseType> response_start_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_response_start, response_start_fragment);
        fragment->response_start.Set(response_start_fragment.is_null() ? nullptr : response_start_fragment.data());
        decltype(Traits::document_timing(input)) in_document_timing = Traits::document_timing(input);
        mojo::internal::MessageFragment<typename decltype(fragment->document_timing)::BaseType> document_timing_fragment(fragment.message());
        mojo::internal::Serialize<::page_load_metrics::mojom::DocumentTimingDataView>(in_document_timing, document_timing_fragment);
        fragment->document_timing.Set(document_timing_fragment.is_null() ? nullptr : document_timing_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->document_timing.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null document_timing in PageLoadTiming struct");
        decltype(Traits::interactive_timing(input)) in_interactive_timing = Traits::interactive_timing(input);
        mojo::internal::MessageFragment<typename decltype(fragment->interactive_timing)::BaseType> interactive_timing_fragment(fragment.message());
        mojo::internal::Serialize<::page_load_metrics::mojom::InteractiveTimingDataView>(in_interactive_timing, interactive_timing_fragment);
        fragment->interactive_timing.Set(interactive_timing_fragment.is_null() ? nullptr : interactive_timing_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->interactive_timing.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null interactive_timing in PageLoadTiming struct");
        decltype(Traits::paint_timing(input)) in_paint_timing = Traits::paint_timing(input);
        mojo::internal::MessageFragment<typename decltype(fragment->paint_timing)::BaseType> paint_timing_fragment(fragment.message());
        mojo::internal::Serialize<::page_load_metrics::mojom::PaintTimingDataView>(in_paint_timing, paint_timing_fragment);
        fragment->paint_timing.Set(paint_timing_fragment.is_null() ? nullptr : paint_timing_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->paint_timing.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null paint_timing in PageLoadTiming struct");
        decltype(Traits::parse_timing(input)) in_parse_timing = Traits::parse_timing(input);
        mojo::internal::MessageFragment<typename decltype(fragment->parse_timing)::BaseType> parse_timing_fragment(fragment.message());
        mojo::internal::Serialize<::page_load_metrics::mojom::ParseTimingDataView>(in_parse_timing, parse_timing_fragment);
        fragment->parse_timing.Set(parse_timing_fragment.is_null() ? nullptr : parse_timing_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->parse_timing.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null parse_timing in PageLoadTiming struct");
        decltype(Traits::domain_lookup_timing(input)) in_domain_lookup_timing = Traits::domain_lookup_timing(input);
        mojo::internal::MessageFragment<typename decltype(fragment->domain_lookup_timing)::BaseType> domain_lookup_timing_fragment(fragment.message());
        mojo::internal::Serialize<::page_load_metrics::mojom::DomainLookupTimingDataView>(in_domain_lookup_timing, domain_lookup_timing_fragment);
        fragment->domain_lookup_timing.Set(domain_lookup_timing_fragment.is_null() ? nullptr : domain_lookup_timing_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->domain_lookup_timing.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null domain_lookup_timing in PageLoadTiming struct");
        decltype(Traits::back_forward_cache_timings(input)) in_back_forward_cache_timings = Traits::back_forward_cache_timings(input);
        mojo::internal::MessageFragment<typename decltype(fragment->back_forward_cache_timings)::BaseType> back_forward_cache_timings_fragment(
            fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& back_forward_cache_timings_validate_params
            = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::page_load_metrics::mojom::BackForwardCacheTimingDataView>>(
            in_back_forward_cache_timings, back_forward_cache_timings_fragment, &back_forward_cache_timings_validate_params);
        fragment->back_forward_cache_timings.Set(back_forward_cache_timings_fragment.is_null() ? nullptr : back_forward_cache_timings_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->back_forward_cache_timings.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null back_forward_cache_timings in PageLoadTiming struct");
        decltype(Traits::activation_start(input)) in_activation_start = Traits::activation_start(input);
        mojo::internal::MessageFragment<typename decltype(fragment->activation_start)::BaseType> activation_start_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_activation_start, activation_start_fragment);
        fragment->activation_start.Set(activation_start_fragment.is_null() ? nullptr : activation_start_fragment.data());
        decltype(Traits::input_to_navigation_start(input)) in_input_to_navigation_start = Traits::input_to_navigation_start(input);
        mojo::internal::MessageFragment<typename decltype(fragment->input_to_navigation_start)::BaseType> input_to_navigation_start_fragment(
            fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_input_to_navigation_start, input_to_navigation_start_fragment);
        fragment->input_to_navigation_start.Set(input_to_navigation_start_fragment.is_null() ? nullptr : input_to_navigation_start_fragment.data());
        decltype(Traits::user_timing_mark_fully_loaded(input)) in_user_timing_mark_fully_loaded = Traits::user_timing_mark_fully_loaded(input);
        mojo::internal::MessageFragment<typename decltype(fragment->user_timing_mark_fully_loaded)::BaseType> user_timing_mark_fully_loaded_fragment(
            fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_user_timing_mark_fully_loaded, user_timing_mark_fully_loaded_fragment);
        fragment->user_timing_mark_fully_loaded.Set(user_timing_mark_fully_loaded_fragment.is_null() ? nullptr : user_timing_mark_fully_loaded_fragment.data());
        decltype(Traits::user_timing_mark_fully_visible(input)) in_user_timing_mark_fully_visible = Traits::user_timing_mark_fully_visible(input);
        mojo::internal::MessageFragment<typename decltype(fragment->user_timing_mark_fully_visible)::BaseType> user_timing_mark_fully_visible_fragment(
            fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_user_timing_mark_fully_visible, user_timing_mark_fully_visible_fragment);
        fragment->user_timing_mark_fully_visible.Set(
            user_timing_mark_fully_visible_fragment.is_null() ? nullptr : user_timing_mark_fully_visible_fragment.data());
        decltype(Traits::user_timing_mark_interactive(input)) in_user_timing_mark_interactive = Traits::user_timing_mark_interactive(input);
        mojo::internal::MessageFragment<typename decltype(fragment->user_timing_mark_interactive)::BaseType> user_timing_mark_interactive_fragment(
            fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_user_timing_mark_interactive, user_timing_mark_interactive_fragment);
        fragment->user_timing_mark_interactive.Set(user_timing_mark_interactive_fragment.is_null() ? nullptr : user_timing_mark_interactive_fragment.data());
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::PageLoadTiming_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::PageLoadTimingDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::FrameMetadataDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::FrameMetadataDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::FrameMetadata_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->behavior_flags = Traits::behavior_flags(input);
        decltype(Traits::main_frame_intersection_rect(input)) in_main_frame_intersection_rect = Traits::main_frame_intersection_rect(input);
        mojo::internal::MessageFragment<typename decltype(fragment->main_frame_intersection_rect)::BaseType> main_frame_intersection_rect_fragment(
            fragment.message());
        mojo::internal::Serialize<::gfx::mojom::RectDataView>(in_main_frame_intersection_rect, main_frame_intersection_rect_fragment);
        fragment->main_frame_intersection_rect.Set(main_frame_intersection_rect_fragment.is_null() ? nullptr : main_frame_intersection_rect_fragment.data());
        decltype(Traits::main_frame_viewport_rect(input)) in_main_frame_viewport_rect = Traits::main_frame_viewport_rect(input);
        mojo::internal::MessageFragment<typename decltype(fragment->main_frame_viewport_rect)::BaseType> main_frame_viewport_rect_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::RectDataView>(in_main_frame_viewport_rect, main_frame_viewport_rect_fragment);
        fragment->main_frame_viewport_rect.Set(main_frame_viewport_rect_fragment.is_null() ? nullptr : main_frame_viewport_rect_fragment.data());
        decltype(Traits::main_frame_image_ad_rects(input)) in_main_frame_image_ad_rects = Traits::main_frame_image_ad_rects(input);
        mojo::internal::MessageFragment<typename decltype(fragment->main_frame_image_ad_rects)::BaseType> main_frame_image_ad_rects_fragment(
            fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& main_frame_image_ad_rects_validate_params
            = mojo::internal::GetMapValidator<*&mojo::internal::GetArrayValidator<0, false, nullptr>(),
                *&mojo::internal::GetArrayValidator<0, false, nullptr>()>();
        mojo::internal::Serialize<mojo::MapDataView<int32_t, ::gfx::mojom::RectDataView>>(
            in_main_frame_image_ad_rects, main_frame_image_ad_rects_fragment, &main_frame_image_ad_rects_validate_params);
        fragment->main_frame_image_ad_rects.Set(main_frame_image_ad_rects_fragment.is_null() ? nullptr : main_frame_image_ad_rects_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->main_frame_image_ad_rects.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null main_frame_image_ad_rects in FrameMetadata struct");
        decltype(Traits::framework_detection_result(input)) in_framework_detection_result = Traits::framework_detection_result(input);
        mojo::internal::MessageFragment<typename decltype(fragment->framework_detection_result)::BaseType> framework_detection_result_fragment(
            fragment.message());
        mojo::internal::Serialize<::blink::mojom::JavaScriptFrameworkDetectionResultDataView>(
            in_framework_detection_result, framework_detection_result_fragment);
        fragment->framework_detection_result.Set(framework_detection_result_fragment.is_null() ? nullptr : framework_detection_result_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->framework_detection_result.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null framework_detection_result in FrameMetadata struct");
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::FrameMetadata_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::FrameMetadataDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::SubresourceLoadMetricsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::SubresourceLoadMetricsDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::SubresourceLoadMetrics_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->number_of_subresources_loaded = Traits::number_of_subresources_loaded(input);
        fragment->number_of_subresource_loads_handled_by_service_worker = Traits::number_of_subresource_loads_handled_by_service_worker(input);
        decltype(Traits::service_worker_subresource_load_metrics(input)) in_service_worker_subresource_load_metrics
            = Traits::service_worker_subresource_load_metrics(input);
        mojo::internal::MessageFragment<typename decltype(fragment->service_worker_subresource_load_metrics)::BaseType>
            service_worker_subresource_load_metrics_fragment(fragment.message());
        mojo::internal::Serialize<::page_load_metrics::mojom::ServiceWorkerSubresourceLoadMetricsDataView>(
            in_service_worker_subresource_load_metrics, service_worker_subresource_load_metrics_fragment);
        fragment->service_worker_subresource_load_metrics.Set(
            service_worker_subresource_load_metrics_fragment.is_null() ? nullptr : service_worker_subresource_load_metrics_fragment.data());
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::SubresourceLoadMetrics_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::SubresourceLoadMetricsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::ServiceWorkerSubresourceLoadMetricsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::ServiceWorkerSubresourceLoadMetricsDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::ServiceWorkerSubresourceLoadMetrics_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->image_handled = Traits::image_handled(input);
        fragment->image_fallback = Traits::image_fallback(input);
        fragment->css_handled = Traits::css_handled(input);
        fragment->css_fallback = Traits::css_fallback(input);
        fragment->script_handled = Traits::script_handled(input);
        fragment->script_fallback = Traits::script_fallback(input);
        fragment->font_handled = Traits::font_handled(input);
        fragment->font_fallback = Traits::font_fallback(input);
        fragment->raw_handled = Traits::raw_handled(input);
        fragment->raw_fallback = Traits::raw_fallback(input);
        fragment->svg_handled = Traits::svg_handled(input);
        fragment->svg_fallback = Traits::svg_fallback(input);
        fragment->xsl_handled = Traits::xsl_handled(input);
        fragment->xsl_fallback = Traits::xsl_fallback(input);
        fragment->link_prefetch_handled = Traits::link_prefetch_handled(input);
        fragment->link_prefetch_fallback = Traits::link_prefetch_fallback(input);
        fragment->text_track_handled = Traits::text_track_handled(input);
        fragment->text_track_fallback = Traits::text_track_fallback(input);
        fragment->audio_handled = Traits::audio_handled(input);
        fragment->audio_fallback = Traits::audio_fallback(input);
        fragment->video_handled = Traits::video_handled(input);
        fragment->video_fallback = Traits::video_fallback(input);
        fragment->manifest_handled = Traits::manifest_handled(input);
        fragment->manifest_fallback = Traits::manifest_fallback(input);
        fragment->speculation_rules_handled = Traits::speculation_rules_handled(input);
        fragment->speculation_rules_fallback = Traits::speculation_rules_fallback(input);
        fragment->mock_handled = Traits::mock_handled(input);
        fragment->mock_fallback = Traits::mock_fallback(input);
        fragment->dictionary_handled = Traits::dictionary_handled(input);
        fragment->dictionary_fallback = Traits::dictionary_fallback(input);
        fragment->matched_cache_router_source_count = Traits::matched_cache_router_source_count(input);
        fragment->matched_fetch_event_router_source_count = Traits::matched_fetch_event_router_source_count(input);
        fragment->matched_network_router_source_count = Traits::matched_network_router_source_count(input);
        fragment->matched_race_network_and_fetch_router_source_count = Traits::matched_race_network_and_fetch_router_source_count(input);
        decltype(Traits::total_router_evaluation_time_for_subresources(input)) in_total_router_evaluation_time_for_subresources
            = Traits::total_router_evaluation_time_for_subresources(input);
        mojo::internal::MessageFragment<typename decltype(fragment->total_router_evaluation_time_for_subresources)::BaseType>
            total_router_evaluation_time_for_subresources_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
            in_total_router_evaluation_time_for_subresources, total_router_evaluation_time_for_subresources_fragment);
        fragment->total_router_evaluation_time_for_subresources.Set(
            total_router_evaluation_time_for_subresources_fragment.is_null() ? nullptr : total_router_evaluation_time_for_subresources_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->total_router_evaluation_time_for_subresources.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null total_router_evaluation_time_for_subresources in ServiceWorkerSubresourceLoadMetrics struct");
        decltype(Traits::total_cache_lookup_time_for_subresources(input)) in_total_cache_lookup_time_for_subresources
            = Traits::total_cache_lookup_time_for_subresources(input);
        mojo::internal::MessageFragment<typename decltype(fragment->total_cache_lookup_time_for_subresources)::BaseType>
            total_cache_lookup_time_for_subresources_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
            in_total_cache_lookup_time_for_subresources, total_cache_lookup_time_for_subresources_fragment);
        fragment->total_cache_lookup_time_for_subresources.Set(
            total_cache_lookup_time_for_subresources_fragment.is_null() ? nullptr : total_cache_lookup_time_for_subresources_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->total_cache_lookup_time_for_subresources.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null total_cache_lookup_time_for_subresources in ServiceWorkerSubresourceLoadMetrics struct");
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::ServiceWorkerSubresourceLoadMetrics_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::ServiceWorkerSubresourceLoadMetricsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::ResourceDataUpdateDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::ResourceDataUpdateDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::ResourceDataUpdate_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->request_id = Traits::request_id(input);
        fragment->delta_bytes = Traits::delta_bytes(input);
        fragment->received_data_length = Traits::received_data_length(input);
        fragment->encoded_body_length = Traits::encoded_body_length(input);
        fragment->decoded_body_length = Traits::decoded_body_length(input);
        fragment->is_complete = Traits::is_complete(input);
        fragment->reported_as_ad_resource = Traits::reported_as_ad_resource(input);
        fragment->is_main_frame_resource = Traits::is_main_frame_resource(input);
        mojo::internal::Serialize<::page_load_metrics::mojom::CacheType>(Traits::cache_type(input), &fragment->cache_type);
        fragment->is_primary_frame_resource = Traits::is_primary_frame_resource(input);
        decltype(Traits::mime_type(input)) in_mime_type = Traits::mime_type(input);
        mojo::internal::MessageFragment<typename decltype(fragment->mime_type)::BaseType> mime_type_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_mime_type, mime_type_fragment);
        fragment->mime_type.Set(mime_type_fragment.is_null() ? nullptr : mime_type_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->mime_type.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null mime_type in ResourceDataUpdate struct");
        fragment->is_secure_scheme = Traits::is_secure_scheme(input);
        fragment->proxy_used = Traits::proxy_used(input);
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::ResourceDataUpdate_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::ResourceDataUpdateDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::LayoutShiftDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::LayoutShiftDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::LayoutShift_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::layout_shift_time(input)) in_layout_shift_time = Traits::layout_shift_time(input);
        mojo::internal::MessageFragment<typename decltype(fragment->layout_shift_time)::BaseType> layout_shift_time_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(in_layout_shift_time, layout_shift_time_fragment);
        fragment->layout_shift_time.Set(layout_shift_time_fragment.is_null() ? nullptr : layout_shift_time_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->layout_shift_time.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null layout_shift_time in LayoutShift struct");
        fragment->layout_shift_score = Traits::layout_shift_score(input);
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::LayoutShift_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::LayoutShiftDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::FrameRenderDataUpdateDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::FrameRenderDataUpdateDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::FrameRenderDataUpdate_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->layout_shift_delta = Traits::layout_shift_delta(input);
        fragment->layout_shift_delta_before_input_or_scroll = Traits::layout_shift_delta_before_input_or_scroll(input);
        decltype(Traits::new_layout_shifts(input)) in_new_layout_shifts = Traits::new_layout_shifts(input);
        mojo::internal::MessageFragment<typename decltype(fragment->new_layout_shifts)::BaseType> new_layout_shifts_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& new_layout_shifts_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::page_load_metrics::mojom::LayoutShiftDataView>>(
            in_new_layout_shifts, new_layout_shifts_fragment, &new_layout_shifts_validate_params);
        fragment->new_layout_shifts.Set(new_layout_shifts_fragment.is_null() ? nullptr : new_layout_shifts_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->new_layout_shifts.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null new_layout_shifts in FrameRenderDataUpdate struct");
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::FrameRenderDataUpdate_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::FrameRenderDataUpdateDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::CpuTimingDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::CpuTimingDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::CpuTiming_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::task_time(input)) in_task_time = Traits::task_time(input);
        mojo::internal::MessageFragment<typename decltype(fragment->task_time)::BaseType> task_time_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_task_time, task_time_fragment);
        fragment->task_time.Set(task_time_fragment.is_null() ? nullptr : task_time_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->task_time.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null task_time in CpuTiming struct");
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::CpuTiming_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::CpuTimingDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::InputTimingDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::InputTimingDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::InputTiming_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->num_interactions = Traits::num_interactions(input);
        decltype(Traits::max_event_durations(input)) in_max_event_durations = Traits::max_event_durations(input);
        mojo::internal::MessageFragment<decltype(fragment->max_event_durations)> max_event_durations_fragment(fragment.message());
        max_event_durations_fragment.Claim(&fragment->max_event_durations);
        mojo::internal::Serialize<::page_load_metrics::mojom::UserInteractionLatenciesDataView>(in_max_event_durations, max_event_durations_fragment, true);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->max_event_durations.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null max_event_durations in InputTiming struct");
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::InputTiming_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::InputTimingDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::UserInteractionLatencyDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::UserInteractionLatencyDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::UserInteractionLatency_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::interaction_latency(input)) in_interaction_latency = Traits::interaction_latency(input);
        mojo::internal::MessageFragment<typename decltype(fragment->interaction_latency)::BaseType> interaction_latency_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_interaction_latency, interaction_latency_fragment);
        fragment->interaction_latency.Set(interaction_latency_fragment.is_null() ? nullptr : interaction_latency_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->interaction_latency.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null interaction_latency in UserInteractionLatency struct");
        mojo::internal::Serialize<::page_load_metrics::mojom::UserInteractionType>(Traits::interaction_type(input), &fragment->interaction_type);
        fragment->interaction_offset = Traits::interaction_offset(input);
        decltype(Traits::interaction_time(input)) in_interaction_time = Traits::interaction_time(input);
        mojo::internal::MessageFragment<typename decltype(fragment->interaction_time)::BaseType> interaction_time_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(in_interaction_time, interaction_time_fragment);
        fragment->interaction_time.Set(interaction_time_fragment.is_null() ? nullptr : interaction_time_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->interaction_time.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null interaction_time in UserInteractionLatency struct");
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::UserInteractionLatency_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::UserInteractionLatencyDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::BackForwardCacheTimingDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::BackForwardCacheTimingDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::BackForwardCacheTiming_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::first_paint_after_back_forward_cache_restore(input)) in_first_paint_after_back_forward_cache_restore
            = Traits::first_paint_after_back_forward_cache_restore(input);
        mojo::internal::MessageFragment<typename decltype(fragment->first_paint_after_back_forward_cache_restore)::BaseType>
            first_paint_after_back_forward_cache_restore_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
            in_first_paint_after_back_forward_cache_restore, first_paint_after_back_forward_cache_restore_fragment);
        fragment->first_paint_after_back_forward_cache_restore.Set(
            first_paint_after_back_forward_cache_restore_fragment.is_null() ? nullptr : first_paint_after_back_forward_cache_restore_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->first_paint_after_back_forward_cache_restore.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null first_paint_after_back_forward_cache_restore in BackForwardCacheTiming struct");
        decltype(Traits::request_animation_frames_after_back_forward_cache_restore(input)) in_request_animation_frames_after_back_forward_cache_restore
            = Traits::request_animation_frames_after_back_forward_cache_restore(input);
        mojo::internal::MessageFragment<typename decltype(fragment->request_animation_frames_after_back_forward_cache_restore)::BaseType>
            request_animation_frames_after_back_forward_cache_restore_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& request_animation_frames_after_back_forward_cache_restore_validate_params
            = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::mojo_base::mojom::TimeDeltaDataView>>(in_request_animation_frames_after_back_forward_cache_restore,
            request_animation_frames_after_back_forward_cache_restore_fragment, &request_animation_frames_after_back_forward_cache_restore_validate_params);
        fragment->request_animation_frames_after_back_forward_cache_restore.Set(request_animation_frames_after_back_forward_cache_restore_fragment.is_null()
                ? nullptr
                : request_animation_frames_after_back_forward_cache_restore_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->request_animation_frames_after_back_forward_cache_restore.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null request_animation_frames_after_back_forward_cache_restore in BackForwardCacheTiming struct");
        decltype(Traits::first_input_delay_after_back_forward_cache_restore(input)) in_first_input_delay_after_back_forward_cache_restore
            = Traits::first_input_delay_after_back_forward_cache_restore(input);
        mojo::internal::MessageFragment<typename decltype(fragment->first_input_delay_after_back_forward_cache_restore)::BaseType>
            first_input_delay_after_back_forward_cache_restore_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
            in_first_input_delay_after_back_forward_cache_restore, first_input_delay_after_back_forward_cache_restore_fragment);
        fragment->first_input_delay_after_back_forward_cache_restore.Set(first_input_delay_after_back_forward_cache_restore_fragment.is_null()
                ? nullptr
                : first_input_delay_after_back_forward_cache_restore_fragment.data());
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::BackForwardCacheTiming_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::BackForwardCacheTimingDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::SoftNavigationMetricsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::page_load_metrics::mojom::SoftNavigationMetricsDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::SoftNavigationMetrics_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->count = Traits::count(input);
        decltype(Traits::start_time(input)) in_start_time = Traits::start_time(input);
        mojo::internal::MessageFragment<typename decltype(fragment->start_time)::BaseType> start_time_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_start_time, start_time_fragment);
        fragment->start_time.Set(start_time_fragment.is_null() ? nullptr : start_time_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->start_time.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null start_time in SoftNavigationMetrics struct");
        decltype(Traits::navigation_id(input)) in_navigation_id = Traits::navigation_id(input);
        mojo::internal::MessageFragment<typename decltype(fragment->navigation_id)::BaseType> navigation_id_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_navigation_id, navigation_id_fragment);
        fragment->navigation_id.Set(navigation_id_fragment.is_null() ? nullptr : navigation_id_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->navigation_id.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null navigation_id in SoftNavigationMetrics struct");
        decltype(Traits::largest_contentful_paint(input)) in_largest_contentful_paint = Traits::largest_contentful_paint(input);
        mojo::internal::MessageFragment<typename decltype(fragment->largest_contentful_paint)::BaseType> largest_contentful_paint_fragment(fragment.message());
        mojo::internal::Serialize<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView>(
            in_largest_contentful_paint, largest_contentful_paint_fragment);
        fragment->largest_contentful_paint.Set(largest_contentful_paint_fragment.is_null() ? nullptr : largest_contentful_paint_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->largest_contentful_paint.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null largest_contentful_paint in SoftNavigationMetrics struct");
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::SoftNavigationMetrics_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::SoftNavigationMetricsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::page_load_metrics::mojom::UserInteractionLatenciesDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = UnionTraits<::page_load_metrics::mojom::UserInteractionLatenciesDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, MessageFragment<::page_load_metrics::mojom::internal::UserInteractionLatencies_Data>& fragment, bool inlined)
    {
        if (CallIsNullIfExists<Traits>(input)) {
            if (inlined)
                fragment->set_null();
            return;
        }

        if (!inlined)
            fragment.Allocate();

        // TODO(azani): Handle unknown and objects.
        // Set the not-null flag.
        fragment->size = kUnionDataSize;
        fragment->tag = Traits::GetTag(input);
        switch (fragment->tag) {
        case ::page_load_metrics::mojom::UserInteractionLatenciesDataView::Tag::kUserInteractionLatencies: {
            decltype(Traits::user_interaction_latencies(input)) in_user_interaction_latencies = Traits::user_interaction_latencies(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_user_interaction_latencies)::BaseType> value_fragment(fragment.message());
            constexpr const mojo::internal::ContainerValidateParams& user_interaction_latencies_validate_params
                = mojo::internal::GetArrayValidator<0, false, nullptr>();
            mojo::internal::Serialize<mojo::ArrayDataView<::page_load_metrics::mojom::UserInteractionLatencyDataView>>(
                in_user_interaction_latencies, value_fragment, &user_interaction_latencies_validate_params);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
                "null user_interaction_latencies in UserInteractionLatencies union");
            fragment->data.f_user_interaction_latencies.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::page_load_metrics::mojom::UserInteractionLatenciesDataView::Tag::kWorstInteractionLatency: {
            decltype(Traits::worst_interaction_latency(input)) in_worst_interaction_latency = Traits::worst_interaction_latency(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_worst_interaction_latency)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_worst_interaction_latency, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
                "null worst_interaction_latency in UserInteractionLatencies union");
            fragment->data.f_worst_interaction_latency.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        }
    }

    static bool Deserialize(::page_load_metrics::mojom::internal::UserInteractionLatencies_Data* input, UserType* output, Message* message)
    {
        if (!input || input->is_null())
            return CallSetToNullIfExists<Traits>(output);

        ::page_load_metrics::mojom::UserInteractionLatenciesDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace page_load_metrics::mojom {

inline void DocumentTimingDataView::GetDomContentLoadedEventStartDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->dom_content_loaded_event_start.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void DocumentTimingDataView::GetLoadEventStartDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->load_event_start.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void LcpResourceLoadTimingsDataView::GetDiscoveryTimeDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->discovery_time.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void LcpResourceLoadTimingsDataView::GetLoadStartDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->load_start.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void LcpResourceLoadTimingsDataView::GetLoadEndDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->load_end.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void LargestContentfulPaintTimingDataView::GetLargestImagePaintDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->largest_image_paint.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void LargestContentfulPaintTimingDataView::GetLargestTextPaintDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->largest_text_paint.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void LargestContentfulPaintTimingDataView::GetResourceLoadTimingsDataView(LcpResourceLoadTimingsDataView* output)
{
    auto pointer = data_->resource_load_timings.Get();
    *output = LcpResourceLoadTimingsDataView(pointer, message_);
}

inline void PaintTimingDataView::GetFirstPaintDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->first_paint.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PaintTimingDataView::GetFirstImagePaintDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->first_image_paint.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PaintTimingDataView::GetFirstContentfulPaintDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->first_contentful_paint.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PaintTimingDataView::GetFirstMeaningfulPaintDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->first_meaningful_paint.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PaintTimingDataView::GetLargestContentfulPaintDataView(LargestContentfulPaintTimingDataView* output)
{
    auto pointer = data_->largest_contentful_paint.Get();
    *output = LargestContentfulPaintTimingDataView(pointer, message_);
}
inline void PaintTimingDataView::GetExperimentalLargestContentfulPaintDataView(LargestContentfulPaintTimingDataView* output)
{
    auto pointer = data_->experimental_largest_contentful_paint.Get();
    *output = LargestContentfulPaintTimingDataView(pointer, message_);
}
inline void PaintTimingDataView::GetFirstEligibleToPaintDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->first_eligible_to_paint.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PaintTimingDataView::GetFirstInputOrScrollNotifiedTimestampDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->first_input_or_scroll_notified_timestamp.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void ParseTimingDataView::GetParseStartDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->parse_start.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void ParseTimingDataView::GetParseStopDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->parse_stop.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void ParseTimingDataView::GetParseBlockedOnScriptLoadDurationDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->parse_blocked_on_script_load_duration.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void ParseTimingDataView::GetParseBlockedOnScriptLoadFromDocumentWriteDurationDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->parse_blocked_on_script_load_from_document_write_duration.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void ParseTimingDataView::GetParseBlockedOnScriptExecutionDurationDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->parse_blocked_on_script_execution_duration.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void ParseTimingDataView::GetParseBlockedOnScriptExecutionFromDocumentWriteDurationDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->parse_blocked_on_script_execution_from_document_write_duration.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void InteractiveTimingDataView::GetFirstInputDelayDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->first_input_delay.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void InteractiveTimingDataView::GetFirstInputTimestampDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->first_input_timestamp.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void InteractiveTimingDataView::GetFirstScrollDelayDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->first_scroll_delay.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void InteractiveTimingDataView::GetFirstScrollTimestampDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->first_scroll_timestamp.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void CustomUserTimingMarkDataView::GetMarkNameDataView(mojo::StringDataView* output)
{
    auto pointer = data_->mark_name.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void CustomUserTimingMarkDataView::GetStartTimeDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->start_time.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void DomainLookupTimingDataView::GetDomainLookupStartDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->domain_lookup_start.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void DomainLookupTimingDataView::GetDomainLookupEndDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->domain_lookup_end.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void PageLoadTimingDataView::GetNavigationStartDataView(::mojo_base::mojom::TimeDataView* output)
{
    auto pointer = data_->navigation_start.Get();
    *output = ::mojo_base::mojom::TimeDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetConnectStartDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->connect_start.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetConnectEndDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->connect_end.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetResponseStartDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->response_start.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetDocumentTimingDataView(DocumentTimingDataView* output)
{
    auto pointer = data_->document_timing.Get();
    *output = DocumentTimingDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetInteractiveTimingDataView(InteractiveTimingDataView* output)
{
    auto pointer = data_->interactive_timing.Get();
    *output = InteractiveTimingDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetPaintTimingDataView(PaintTimingDataView* output)
{
    auto pointer = data_->paint_timing.Get();
    *output = PaintTimingDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetParseTimingDataView(ParseTimingDataView* output)
{
    auto pointer = data_->parse_timing.Get();
    *output = ParseTimingDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetDomainLookupTimingDataView(DomainLookupTimingDataView* output)
{
    auto pointer = data_->domain_lookup_timing.Get();
    *output = DomainLookupTimingDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetBackForwardCacheTimingsDataView(mojo::ArrayDataView<BackForwardCacheTimingDataView>* output)
{
    auto pointer = data_->back_forward_cache_timings.Get();
    *output = mojo::ArrayDataView<BackForwardCacheTimingDataView>(pointer, message_);
}
inline void PageLoadTimingDataView::GetActivationStartDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->activation_start.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetInputToNavigationStartDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->input_to_navigation_start.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetUserTimingMarkFullyLoadedDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->user_timing_mark_fully_loaded.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetUserTimingMarkFullyVisibleDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->user_timing_mark_fully_visible.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetUserTimingMarkInteractiveDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->user_timing_mark_interactive.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void FrameMetadataDataView::GetMainFrameIntersectionRectDataView(::gfx::mojom::RectDataView* output)
{
    auto pointer = data_->main_frame_intersection_rect.Get();
    *output = ::gfx::mojom::RectDataView(pointer, message_);
}
inline void FrameMetadataDataView::GetMainFrameViewportRectDataView(::gfx::mojom::RectDataView* output)
{
    auto pointer = data_->main_frame_viewport_rect.Get();
    *output = ::gfx::mojom::RectDataView(pointer, message_);
}
inline void FrameMetadataDataView::GetMainFrameImageAdRectsDataView(mojo::MapDataView<int32_t, ::gfx::mojom::RectDataView>* output)
{
    auto pointer = data_->main_frame_image_ad_rects.Get();
    *output = mojo::MapDataView<int32_t, ::gfx::mojom::RectDataView>(pointer, message_);
}
inline void FrameMetadataDataView::GetFrameworkDetectionResultDataView(::blink::mojom::JavaScriptFrameworkDetectionResultDataView* output)
{
    auto pointer = data_->framework_detection_result.Get();
    *output = ::blink::mojom::JavaScriptFrameworkDetectionResultDataView(pointer, message_);
}

inline void SubresourceLoadMetricsDataView::GetServiceWorkerSubresourceLoadMetricsDataView(ServiceWorkerSubresourceLoadMetricsDataView* output)
{
    auto pointer = data_->service_worker_subresource_load_metrics.Get();
    *output = ServiceWorkerSubresourceLoadMetricsDataView(pointer, message_);
}

inline void ServiceWorkerSubresourceLoadMetricsDataView::GetTotalRouterEvaluationTimeForSubresourcesDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->total_router_evaluation_time_for_subresources.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void ServiceWorkerSubresourceLoadMetricsDataView::GetTotalCacheLookupTimeForSubresourcesDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->total_cache_lookup_time_for_subresources.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void ResourceDataUpdateDataView::GetMimeTypeDataView(mojo::StringDataView* output)
{
    auto pointer = data_->mime_type.Get();
    *output = mojo::StringDataView(pointer, message_);
}

inline void LayoutShiftDataView::GetLayoutShiftTimeDataView(::mojo_base::mojom::TimeTicksDataView* output)
{
    auto pointer = data_->layout_shift_time.Get();
    *output = ::mojo_base::mojom::TimeTicksDataView(pointer, message_);
}

inline void FrameRenderDataUpdateDataView::GetNewLayoutShiftsDataView(mojo::ArrayDataView<LayoutShiftDataView>* output)
{
    auto pointer = data_->new_layout_shifts.Get();
    *output = mojo::ArrayDataView<LayoutShiftDataView>(pointer, message_);
}

inline void CpuTimingDataView::GetTaskTimeDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->task_time.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void InputTimingDataView::GetMaxEventDurationsDataView(UserInteractionLatenciesDataView* output)
{
    auto pointer = &data_->max_event_durations;
    *output = UserInteractionLatenciesDataView(pointer, message_);
}

inline void UserInteractionLatencyDataView::GetInteractionLatencyDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->interaction_latency.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void UserInteractionLatencyDataView::GetInteractionTimeDataView(::mojo_base::mojom::TimeTicksDataView* output)
{
    auto pointer = data_->interaction_time.Get();
    *output = ::mojo_base::mojom::TimeTicksDataView(pointer, message_);
}

inline void BackForwardCacheTimingDataView::GetFirstPaintAfterBackForwardCacheRestoreDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->first_paint_after_back_forward_cache_restore.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void BackForwardCacheTimingDataView::GetRequestAnimationFramesAfterBackForwardCacheRestoreDataView(
    mojo::ArrayDataView<::mojo_base::mojom::TimeDeltaDataView>* output)
{
    auto pointer = data_->request_animation_frames_after_back_forward_cache_restore.Get();
    *output = mojo::ArrayDataView<::mojo_base::mojom::TimeDeltaDataView>(pointer, message_);
}
inline void BackForwardCacheTimingDataView::GetFirstInputDelayAfterBackForwardCacheRestoreDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->first_input_delay_after_back_forward_cache_restore.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}

inline void SoftNavigationMetricsDataView::GetStartTimeDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->start_time.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void SoftNavigationMetricsDataView::GetNavigationIdDataView(mojo::StringDataView* output)
{
    auto pointer = data_->navigation_id.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void SoftNavigationMetricsDataView::GetLargestContentfulPaintDataView(LargestContentfulPaintTimingDataView* output)
{
    auto pointer = data_->largest_contentful_paint.Get();
    *output = LargestContentfulPaintTimingDataView(pointer, message_);
}

inline void UserInteractionLatenciesDataView::GetUserInteractionLatenciesDataView(mojo::ArrayDataView<UserInteractionLatencyDataView>* output) const
{
    CHECK(is_user_interaction_latencies());
    *output = mojo::ArrayDataView<UserInteractionLatencyDataView>(data_->data.f_user_interaction_latencies.Get(), message_);
}
inline void UserInteractionLatenciesDataView::GetWorstInteractionLatencyDataView(::mojo_base::mojom::TimeDeltaDataView* output) const
{
    CHECK(is_worst_interaction_latency());
    *output = ::mojo_base::mojom::TimeDeltaDataView(data_->data.f_worst_interaction_latency.Get(), message_);
}

} // page_load_metrics::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <> struct TraceFormatTraits<::page_load_metrics::mojom::CacheType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::page_load_metrics::mojom::CacheType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::page_load_metrics::mojom::UserInteractionType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::page_load_metrics::mojom::UserInteractionType value);
};

} // namespace perfetto

#endif // COMPONENTS_PAGE_LOAD_METRICS_COMMON_PAGE_LOAD_METRICS_MOJOM_SHARED_H_
