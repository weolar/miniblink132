// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/user_event_specifics.proto

#include "components/sync/protocol/user_event_specifics.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sync_pb {
PROTOBUF_CONSTEXPR UserEventSpecifics_Test::UserEventSpecifics_Test(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct UserEventSpecifics_TestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserEventSpecifics_TestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserEventSpecifics_TestDefaultTypeInternal()
    {
    }
    union {
        UserEventSpecifics_Test _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserEventSpecifics_TestDefaultTypeInternal
    _UserEventSpecifics_Test_default_instance_;
PROTOBUF_CONSTEXPR UserEventSpecifics_LanguageDetection_Language::UserEventSpecifics_LanguageDetection_Language(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.language_code_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.is_reliable_)*/ false }
{
}
struct UserEventSpecifics_LanguageDetection_LanguageDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserEventSpecifics_LanguageDetection_LanguageDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserEventSpecifics_LanguageDetection_LanguageDefaultTypeInternal()
    {
    }
    union {
        UserEventSpecifics_LanguageDetection_Language _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserEventSpecifics_LanguageDetection_LanguageDefaultTypeInternal
    _UserEventSpecifics_LanguageDetection_Language_default_instance_;
PROTOBUF_CONSTEXPR UserEventSpecifics_LanguageDetection::UserEventSpecifics_LanguageDetection(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.detected_languages_)*/ {},
        /*decltype(_impl_.adopted_language_code_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct UserEventSpecifics_LanguageDetectionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserEventSpecifics_LanguageDetectionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserEventSpecifics_LanguageDetectionDefaultTypeInternal()
    {
    }
    union {
        UserEventSpecifics_LanguageDetection _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserEventSpecifics_LanguageDetectionDefaultTypeInternal
    _UserEventSpecifics_LanguageDetection_default_instance_;
PROTOBUF_CONSTEXPR UserEventSpecifics_Translation::UserEventSpecifics_Translation(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.from_language_code_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.to_language_code_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.interaction_)*/ 0 }
{
}
struct UserEventSpecifics_TranslationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserEventSpecifics_TranslationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserEventSpecifics_TranslationDefaultTypeInternal()
    {
    }
    union {
        UserEventSpecifics_Translation _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserEventSpecifics_TranslationDefaultTypeInternal
    _UserEventSpecifics_Translation_default_instance_;
PROTOBUF_CONSTEXPR UserEventSpecifics_GaiaPasswordCaptured::UserEventSpecifics_GaiaPasswordCaptured(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.event_trigger_)*/ 0 }
{
}
struct UserEventSpecifics_GaiaPasswordCapturedDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserEventSpecifics_GaiaPasswordCapturedDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserEventSpecifics_GaiaPasswordCapturedDefaultTypeInternal()
    {
    }
    union {
        UserEventSpecifics_GaiaPasswordCaptured _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserEventSpecifics_GaiaPasswordCapturedDefaultTypeInternal
    _UserEventSpecifics_GaiaPasswordCaptured_default_instance_;
PROTOBUF_CONSTEXPR UserEventSpecifics_FlocIdComputed::UserEventSpecifics_FlocIdComputed(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.floc_id_)*/ uint64_t { 0u } }
{
}
struct UserEventSpecifics_FlocIdComputedDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserEventSpecifics_FlocIdComputedDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserEventSpecifics_FlocIdComputedDefaultTypeInternal()
    {
    }
    union {
        UserEventSpecifics_FlocIdComputed _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserEventSpecifics_FlocIdComputedDefaultTypeInternal
    _UserEventSpecifics_FlocIdComputed_default_instance_;
PROTOBUF_CONSTEXPR UserEventSpecifics::UserEventSpecifics(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.event_time_usec_)*/ int64_t { 0 },
        /*decltype(_impl_.navigation_id_)*/ int64_t { 0 }, /*decltype(_impl_.session_id_)*/ uint64_t { 0u }, /*decltype(_impl_.event_)*/ {},
        /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct UserEventSpecificsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserEventSpecificsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserEventSpecificsDefaultTypeInternal()
    {
    }
    union {
        UserEventSpecifics _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserEventSpecificsDefaultTypeInternal _UserEventSpecifics_default_instance_;
} // namespace sync_pb
namespace sync_pb {
bool UserEventSpecifics_Translation_Interaction_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserEventSpecifics_Translation_Interaction_strings[10] = {};

static const char UserEventSpecifics_Translation_Interaction_names[] = "ACCEPT"
                                                                       "AUTO_TRANSLATION_BY_LINK"
                                                                       "AUTO_TRANSLATION_BY_PREF"
                                                                       "DECLINE"
                                                                       "DISMISSED"
                                                                       "IGNORED"
                                                                       "INITIALIZATION_ERROR"
                                                                       "MANUAL"
                                                                       "TRANSLATION_REVERTED"
                                                                       "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserEventSpecifics_Translation_Interaction_entries[] = {
    { { UserEventSpecifics_Translation_Interaction_names + 0, 6 }, 1 },
    { { UserEventSpecifics_Translation_Interaction_names + 6, 24 }, 8 },
    { { UserEventSpecifics_Translation_Interaction_names + 30, 24 }, 7 },
    { { UserEventSpecifics_Translation_Interaction_names + 54, 7 }, 2 },
    { { UserEventSpecifics_Translation_Interaction_names + 61, 9 }, 4 },
    { { UserEventSpecifics_Translation_Interaction_names + 70, 7 }, 3 },
    { { UserEventSpecifics_Translation_Interaction_names + 77, 20 }, 9 },
    { { UserEventSpecifics_Translation_Interaction_names + 97, 6 }, 5 },
    { { UserEventSpecifics_Translation_Interaction_names + 103, 20 }, 6 },
    { { UserEventSpecifics_Translation_Interaction_names + 123, 7 }, 0 },
};

static const int UserEventSpecifics_Translation_Interaction_entries_by_number[] = {
    9, // 0 -> UNKNOWN
    0, // 1 -> ACCEPT
    3, // 2 -> DECLINE
    5, // 3 -> IGNORED
    4, // 4 -> DISMISSED
    7, // 5 -> MANUAL
    8, // 6 -> TRANSLATION_REVERTED
    2, // 7 -> AUTO_TRANSLATION_BY_PREF
    1, // 8 -> AUTO_TRANSLATION_BY_LINK
    6, // 9 -> INITIALIZATION_ERROR
};

const std::string& UserEventSpecifics_Translation_Interaction_Name(UserEventSpecifics_Translation_Interaction value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(UserEventSpecifics_Translation_Interaction_entries,
        UserEventSpecifics_Translation_Interaction_entries_by_number, 10, UserEventSpecifics_Translation_Interaction_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        UserEventSpecifics_Translation_Interaction_entries, UserEventSpecifics_Translation_Interaction_entries_by_number, 10, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : UserEventSpecifics_Translation_Interaction_strings[idx].get();
}
bool UserEventSpecifics_Translation_Interaction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserEventSpecifics_Translation_Interaction* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(UserEventSpecifics_Translation_Interaction_entries, 10, name, &int_value);
    if (success) {
        *value = static_cast<UserEventSpecifics_Translation_Interaction>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UserEventSpecifics_Translation_Interaction UserEventSpecifics_Translation::UNKNOWN;
constexpr UserEventSpecifics_Translation_Interaction UserEventSpecifics_Translation::ACCEPT;
constexpr UserEventSpecifics_Translation_Interaction UserEventSpecifics_Translation::DECLINE;
constexpr UserEventSpecifics_Translation_Interaction UserEventSpecifics_Translation::IGNORED;
constexpr UserEventSpecifics_Translation_Interaction UserEventSpecifics_Translation::DISMISSED;
constexpr UserEventSpecifics_Translation_Interaction UserEventSpecifics_Translation::MANUAL;
constexpr UserEventSpecifics_Translation_Interaction UserEventSpecifics_Translation::TRANSLATION_REVERTED;
constexpr UserEventSpecifics_Translation_Interaction UserEventSpecifics_Translation::AUTO_TRANSLATION_BY_PREF;
constexpr UserEventSpecifics_Translation_Interaction UserEventSpecifics_Translation::AUTO_TRANSLATION_BY_LINK;
constexpr UserEventSpecifics_Translation_Interaction UserEventSpecifics_Translation::INITIALIZATION_ERROR;
constexpr UserEventSpecifics_Translation_Interaction UserEventSpecifics_Translation::Interaction_MIN;
constexpr UserEventSpecifics_Translation_Interaction UserEventSpecifics_Translation::Interaction_MAX;
constexpr int UserEventSpecifics_Translation::Interaction_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_strings[3] = {};

static const char UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_names[] = "EXPIRED_28D_TIMER"
                                                                                 "UNSPECIFIED"
                                                                                 "USER_LOGGED_IN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_entries[] = {
    { { UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_names + 0, 17 }, 2 },
    { { UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_names + 17, 11 }, 0 },
    { { UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_names + 28, 14 }, 1 },
};

static const int UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_entries_by_number[] = {
    1, // 0 -> UNSPECIFIED
    2, // 1 -> USER_LOGGED_IN
    0, // 2 -> EXPIRED_28D_TIMER
};

const std::string& UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_Name(UserEventSpecifics_GaiaPasswordCaptured_EventTrigger value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_entries,
        UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_entries_by_number, 3, UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_entries, UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_strings[idx].get();
}
bool UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserEventSpecifics_GaiaPasswordCaptured_EventTrigger* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<UserEventSpecifics_GaiaPasswordCaptured_EventTrigger>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UserEventSpecifics_GaiaPasswordCaptured_EventTrigger UserEventSpecifics_GaiaPasswordCaptured::UNSPECIFIED;
constexpr UserEventSpecifics_GaiaPasswordCaptured_EventTrigger UserEventSpecifics_GaiaPasswordCaptured::USER_LOGGED_IN;
constexpr UserEventSpecifics_GaiaPasswordCaptured_EventTrigger UserEventSpecifics_GaiaPasswordCaptured::EXPIRED_28D_TIMER;
constexpr UserEventSpecifics_GaiaPasswordCaptured_EventTrigger UserEventSpecifics_GaiaPasswordCaptured::EventTrigger_MIN;
constexpr UserEventSpecifics_GaiaPasswordCaptured_EventTrigger UserEventSpecifics_GaiaPasswordCaptured::EventTrigger_MAX;
constexpr int UserEventSpecifics_GaiaPasswordCaptured::EventTrigger_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool UserEventSpecifics_FlocIdComputed_EventTrigger_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserEventSpecifics_FlocIdComputed_EventTrigger_strings[4] = {};

static const char UserEventSpecifics_FlocIdComputed_EventTrigger_names[] = "HISTORY_DELETE"
                                                                           "NEW"
                                                                           "REFRESHED"
                                                                           "UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserEventSpecifics_FlocIdComputed_EventTrigger_entries[] = {
    { { UserEventSpecifics_FlocIdComputed_EventTrigger_names + 0, 14 }, 3 },
    { { UserEventSpecifics_FlocIdComputed_EventTrigger_names + 14, 3 }, 1 },
    { { UserEventSpecifics_FlocIdComputed_EventTrigger_names + 17, 9 }, 2 },
    { { UserEventSpecifics_FlocIdComputed_EventTrigger_names + 26, 11 }, 0 },
};

static const int UserEventSpecifics_FlocIdComputed_EventTrigger_entries_by_number[] = {
    3, // 0 -> UNSPECIFIED
    1, // 1 -> NEW
    2, // 2 -> REFRESHED
    0, // 3 -> HISTORY_DELETE
};

const std::string& UserEventSpecifics_FlocIdComputed_EventTrigger_Name(UserEventSpecifics_FlocIdComputed_EventTrigger value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(UserEventSpecifics_FlocIdComputed_EventTrigger_entries,
        UserEventSpecifics_FlocIdComputed_EventTrigger_entries_by_number, 4, UserEventSpecifics_FlocIdComputed_EventTrigger_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        UserEventSpecifics_FlocIdComputed_EventTrigger_entries, UserEventSpecifics_FlocIdComputed_EventTrigger_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : UserEventSpecifics_FlocIdComputed_EventTrigger_strings[idx].get();
}
bool UserEventSpecifics_FlocIdComputed_EventTrigger_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserEventSpecifics_FlocIdComputed_EventTrigger* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(UserEventSpecifics_FlocIdComputed_EventTrigger_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<UserEventSpecifics_FlocIdComputed_EventTrigger>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UserEventSpecifics_FlocIdComputed_EventTrigger UserEventSpecifics_FlocIdComputed::UNSPECIFIED;
constexpr UserEventSpecifics_FlocIdComputed_EventTrigger UserEventSpecifics_FlocIdComputed::NEW;
constexpr UserEventSpecifics_FlocIdComputed_EventTrigger UserEventSpecifics_FlocIdComputed::REFRESHED;
constexpr UserEventSpecifics_FlocIdComputed_EventTrigger UserEventSpecifics_FlocIdComputed::HISTORY_DELETE;
constexpr UserEventSpecifics_FlocIdComputed_EventTrigger UserEventSpecifics_FlocIdComputed::EventTrigger_MIN;
constexpr UserEventSpecifics_FlocIdComputed_EventTrigger UserEventSpecifics_FlocIdComputed::EventTrigger_MAX;
constexpr int UserEventSpecifics_FlocIdComputed::EventTrigger_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class UserEventSpecifics_Test::_Internal {
public:
};

UserEventSpecifics_Test::UserEventSpecifics_Test(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserEventSpecifics.Test)
}
UserEventSpecifics_Test::UserEventSpecifics_Test(const UserEventSpecifics_Test& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserEventSpecifics_Test* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserEventSpecifics.Test)
}

inline void UserEventSpecifics_Test::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

UserEventSpecifics_Test::~UserEventSpecifics_Test()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserEventSpecifics.Test)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserEventSpecifics_Test::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserEventSpecifics_Test::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserEventSpecifics_Test::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserEventSpecifics.Test)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* UserEventSpecifics_Test::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserEventSpecifics_Test::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserEventSpecifics.Test)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserEventSpecifics.Test)
    return target;
}

size_t UserEventSpecifics_Test::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserEventSpecifics.Test)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserEventSpecifics_Test::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserEventSpecifics_Test*>(&from));
}

void UserEventSpecifics_Test::MergeFrom(const UserEventSpecifics_Test& from)
{
    UserEventSpecifics_Test* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserEventSpecifics.Test)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserEventSpecifics_Test::CopyFrom(const UserEventSpecifics_Test& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserEventSpecifics.Test)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserEventSpecifics_Test::IsInitialized() const
{
    return true;
}

void UserEventSpecifics_Test::InternalSwap(UserEventSpecifics_Test* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string UserEventSpecifics_Test::GetTypeName() const
{
    return "sync_pb.UserEventSpecifics.Test";
}

// ===================================================================

class UserEventSpecifics_LanguageDetection_Language::_Internal {
public:
    using HasBits = decltype(std::declval<UserEventSpecifics_LanguageDetection_Language>()._impl_._has_bits_);
    static void set_has_language_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_is_reliable(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

UserEventSpecifics_LanguageDetection_Language::UserEventSpecifics_LanguageDetection_Language(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserEventSpecifics.LanguageDetection.Language)
}
UserEventSpecifics_LanguageDetection_Language::UserEventSpecifics_LanguageDetection_Language(const UserEventSpecifics_LanguageDetection_Language& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserEventSpecifics_LanguageDetection_Language* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.language_code_) {},
        decltype(_impl_.is_reliable_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.language_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_language_code()) {
        _this->_impl_.language_code_.Set(from._internal_language_code(), _this->GetArenaForAllocation());
    }
    _this->_impl_.is_reliable_ = from._impl_.is_reliable_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserEventSpecifics.LanguageDetection.Language)
}

inline void UserEventSpecifics_LanguageDetection_Language::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.language_code_) {},
        decltype(_impl_.is_reliable_) { false } };
    _impl_.language_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserEventSpecifics_LanguageDetection_Language::~UserEventSpecifics_LanguageDetection_Language()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserEventSpecifics.LanguageDetection.Language)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserEventSpecifics_LanguageDetection_Language::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.language_code_.Destroy();
}

void UserEventSpecifics_LanguageDetection_Language::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserEventSpecifics_LanguageDetection_Language::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserEventSpecifics.LanguageDetection.Language)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.language_code_.ClearNonDefaultToEmpty();
    }
    _impl_.is_reliable_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserEventSpecifics_LanguageDetection_Language::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string language_code = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_language_code();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_reliable = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_is_reliable(&has_bits);
                _impl_.is_reliable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserEventSpecifics_LanguageDetection_Language::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserEventSpecifics.LanguageDetection.Language)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string language_code = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_language_code(), target);
    }

    // optional bool is_reliable = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_reliable(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserEventSpecifics.LanguageDetection.Language)
    return target;
}

size_t UserEventSpecifics_LanguageDetection_Language::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserEventSpecifics.LanguageDetection.Language)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string language_code = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_language_code());
        }

        // optional bool is_reliable = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserEventSpecifics_LanguageDetection_Language::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserEventSpecifics_LanguageDetection_Language*>(&from));
}

void UserEventSpecifics_LanguageDetection_Language::MergeFrom(const UserEventSpecifics_LanguageDetection_Language& from)
{
    UserEventSpecifics_LanguageDetection_Language* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserEventSpecifics.LanguageDetection.Language)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_language_code(from._internal_language_code());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.is_reliable_ = from._impl_.is_reliable_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserEventSpecifics_LanguageDetection_Language::CopyFrom(const UserEventSpecifics_LanguageDetection_Language& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserEventSpecifics.LanguageDetection.Language)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserEventSpecifics_LanguageDetection_Language::IsInitialized() const
{
    return true;
}

void UserEventSpecifics_LanguageDetection_Language::InternalSwap(UserEventSpecifics_LanguageDetection_Language* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.language_code_, lhs_arena, &other->_impl_.language_code_, rhs_arena);
    swap(_impl_.is_reliable_, other->_impl_.is_reliable_);
}

std::string UserEventSpecifics_LanguageDetection_Language::GetTypeName() const
{
    return "sync_pb.UserEventSpecifics.LanguageDetection.Language";
}

// ===================================================================

class UserEventSpecifics_LanguageDetection::_Internal {
public:
    using HasBits = decltype(std::declval<UserEventSpecifics_LanguageDetection>()._impl_._has_bits_);
    static void set_has_adopted_language_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

UserEventSpecifics_LanguageDetection::UserEventSpecifics_LanguageDetection(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserEventSpecifics.LanguageDetection)
}
UserEventSpecifics_LanguageDetection::UserEventSpecifics_LanguageDetection(const UserEventSpecifics_LanguageDetection& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserEventSpecifics_LanguageDetection* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.detected_languages_) { from._impl_.detected_languages_ }, decltype(_impl_.adopted_language_code_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.adopted_language_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.adopted_language_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_adopted_language_code()) {
        _this->_impl_.adopted_language_code_.Set(from._internal_adopted_language_code(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserEventSpecifics.LanguageDetection)
}

inline void UserEventSpecifics_LanguageDetection::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.detected_languages_) { arena },
        decltype(_impl_.adopted_language_code_) {} };
    _impl_.adopted_language_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.adopted_language_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserEventSpecifics_LanguageDetection::~UserEventSpecifics_LanguageDetection()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserEventSpecifics.LanguageDetection)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserEventSpecifics_LanguageDetection::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.detected_languages_.~RepeatedPtrField();
    _impl_.adopted_language_code_.Destroy();
}

void UserEventSpecifics_LanguageDetection::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserEventSpecifics_LanguageDetection::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserEventSpecifics.LanguageDetection)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.detected_languages_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.adopted_language_code_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserEventSpecifics_LanguageDetection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_detected_languages(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string adopted_language_code = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_adopted_language_code();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserEventSpecifics_LanguageDetection::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserEventSpecifics.LanguageDetection)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_detected_languages_size()); i < n; i++) {
        const auto& repfield = this->_internal_detected_languages(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string adopted_language_code = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_adopted_language_code(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserEventSpecifics.LanguageDetection)
    return target;
}

size_t UserEventSpecifics_LanguageDetection::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserEventSpecifics.LanguageDetection)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.UserEventSpecifics.LanguageDetection.Language detected_languages = 1;
    total_size += 1UL * this->_internal_detected_languages_size();
    for (const auto& msg : this->_impl_.detected_languages_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional string adopted_language_code = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_adopted_language_code());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserEventSpecifics_LanguageDetection::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserEventSpecifics_LanguageDetection*>(&from));
}

void UserEventSpecifics_LanguageDetection::MergeFrom(const UserEventSpecifics_LanguageDetection& from)
{
    UserEventSpecifics_LanguageDetection* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserEventSpecifics.LanguageDetection)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.detected_languages_.MergeFrom(from._impl_.detected_languages_);
    if (from._internal_has_adopted_language_code()) {
        _this->_internal_set_adopted_language_code(from._internal_adopted_language_code());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserEventSpecifics_LanguageDetection::CopyFrom(const UserEventSpecifics_LanguageDetection& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserEventSpecifics.LanguageDetection)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserEventSpecifics_LanguageDetection::IsInitialized() const
{
    return true;
}

void UserEventSpecifics_LanguageDetection::InternalSwap(UserEventSpecifics_LanguageDetection* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.detected_languages_.InternalSwap(&other->_impl_.detected_languages_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.adopted_language_code_, lhs_arena, &other->_impl_.adopted_language_code_, rhs_arena);
}

std::string UserEventSpecifics_LanguageDetection::GetTypeName() const
{
    return "sync_pb.UserEventSpecifics.LanguageDetection";
}

// ===================================================================

class UserEventSpecifics_Translation::_Internal {
public:
    using HasBits = decltype(std::declval<UserEventSpecifics_Translation>()._impl_._has_bits_);
    static void set_has_from_language_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_to_language_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_interaction(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

UserEventSpecifics_Translation::UserEventSpecifics_Translation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserEventSpecifics.Translation)
}
UserEventSpecifics_Translation::UserEventSpecifics_Translation(const UserEventSpecifics_Translation& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserEventSpecifics_Translation* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.from_language_code_) {}, decltype(_impl_.to_language_code_) {}, decltype(_impl_.interaction_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.from_language_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_language_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_from_language_code()) {
        _this->_impl_.from_language_code_.Set(from._internal_from_language_code(), _this->GetArenaForAllocation());
    }
    _impl_.to_language_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.to_language_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_to_language_code()) {
        _this->_impl_.to_language_code_.Set(from._internal_to_language_code(), _this->GetArenaForAllocation());
    }
    _this->_impl_.interaction_ = from._impl_.interaction_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserEventSpecifics.Translation)
}

inline void UserEventSpecifics_Translation::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.from_language_code_) {},
        decltype(_impl_.to_language_code_) {}, decltype(_impl_.interaction_) { 0 } };
    _impl_.from_language_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_language_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.to_language_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.to_language_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserEventSpecifics_Translation::~UserEventSpecifics_Translation()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserEventSpecifics.Translation)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserEventSpecifics_Translation::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.from_language_code_.Destroy();
    _impl_.to_language_code_.Destroy();
}

void UserEventSpecifics_Translation::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserEventSpecifics_Translation::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserEventSpecifics.Translation)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.from_language_code_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.to_language_code_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.interaction_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserEventSpecifics_Translation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string from_language_code = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_from_language_code();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string to_language_code = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_to_language_code();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.UserEventSpecifics.Translation.Interaction interaction = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::UserEventSpecifics_Translation_Interaction_IsValid(val))) {
                    _internal_set_interaction(static_cast<::sync_pb::UserEventSpecifics_Translation_Interaction>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserEventSpecifics_Translation::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserEventSpecifics.Translation)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string from_language_code = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_from_language_code(), target);
    }

    // optional string to_language_code = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_to_language_code(), target);
    }

    // optional .sync_pb.UserEventSpecifics.Translation.Interaction interaction = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_interaction(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserEventSpecifics.Translation)
    return target;
}

size_t UserEventSpecifics_Translation::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserEventSpecifics.Translation)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string from_language_code = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_from_language_code());
        }

        // optional string to_language_code = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_to_language_code());
        }

        // optional .sync_pb.UserEventSpecifics.Translation.Interaction interaction = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_interaction());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserEventSpecifics_Translation::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserEventSpecifics_Translation*>(&from));
}

void UserEventSpecifics_Translation::MergeFrom(const UserEventSpecifics_Translation& from)
{
    UserEventSpecifics_Translation* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserEventSpecifics.Translation)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_from_language_code(from._internal_from_language_code());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_to_language_code(from._internal_to_language_code());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.interaction_ = from._impl_.interaction_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserEventSpecifics_Translation::CopyFrom(const UserEventSpecifics_Translation& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserEventSpecifics.Translation)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserEventSpecifics_Translation::IsInitialized() const
{
    return true;
}

void UserEventSpecifics_Translation::InternalSwap(UserEventSpecifics_Translation* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.from_language_code_, lhs_arena, &other->_impl_.from_language_code_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.to_language_code_, lhs_arena, &other->_impl_.to_language_code_, rhs_arena);
    swap(_impl_.interaction_, other->_impl_.interaction_);
}

std::string UserEventSpecifics_Translation::GetTypeName() const
{
    return "sync_pb.UserEventSpecifics.Translation";
}

// ===================================================================

class UserEventSpecifics_GaiaPasswordCaptured::_Internal {
public:
    using HasBits = decltype(std::declval<UserEventSpecifics_GaiaPasswordCaptured>()._impl_._has_bits_);
    static void set_has_event_trigger(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

UserEventSpecifics_GaiaPasswordCaptured::UserEventSpecifics_GaiaPasswordCaptured(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserEventSpecifics.GaiaPasswordCaptured)
}
UserEventSpecifics_GaiaPasswordCaptured::UserEventSpecifics_GaiaPasswordCaptured(const UserEventSpecifics_GaiaPasswordCaptured& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserEventSpecifics_GaiaPasswordCaptured* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.event_trigger_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.event_trigger_ = from._impl_.event_trigger_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserEventSpecifics.GaiaPasswordCaptured)
}

inline void UserEventSpecifics_GaiaPasswordCaptured::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.event_trigger_) { 0 } };
}

UserEventSpecifics_GaiaPasswordCaptured::~UserEventSpecifics_GaiaPasswordCaptured()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserEventSpecifics.GaiaPasswordCaptured)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserEventSpecifics_GaiaPasswordCaptured::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserEventSpecifics_GaiaPasswordCaptured::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserEventSpecifics_GaiaPasswordCaptured::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserEventSpecifics.GaiaPasswordCaptured)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.event_trigger_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserEventSpecifics_GaiaPasswordCaptured::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger event_trigger = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::UserEventSpecifics_GaiaPasswordCaptured_EventTrigger_IsValid(val))) {
                    _internal_set_event_trigger(static_cast<::sync_pb::UserEventSpecifics_GaiaPasswordCaptured_EventTrigger>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserEventSpecifics_GaiaPasswordCaptured::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserEventSpecifics.GaiaPasswordCaptured)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger event_trigger = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_event_trigger(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserEventSpecifics.GaiaPasswordCaptured)
    return target;
}

size_t UserEventSpecifics_GaiaPasswordCaptured::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserEventSpecifics.GaiaPasswordCaptured)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .sync_pb.UserEventSpecifics.GaiaPasswordCaptured.EventTrigger event_trigger = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_event_trigger());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserEventSpecifics_GaiaPasswordCaptured::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserEventSpecifics_GaiaPasswordCaptured*>(&from));
}

void UserEventSpecifics_GaiaPasswordCaptured::MergeFrom(const UserEventSpecifics_GaiaPasswordCaptured& from)
{
    UserEventSpecifics_GaiaPasswordCaptured* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserEventSpecifics.GaiaPasswordCaptured)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_event_trigger()) {
        _this->_internal_set_event_trigger(from._internal_event_trigger());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserEventSpecifics_GaiaPasswordCaptured::CopyFrom(const UserEventSpecifics_GaiaPasswordCaptured& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserEventSpecifics.GaiaPasswordCaptured)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserEventSpecifics_GaiaPasswordCaptured::IsInitialized() const
{
    return true;
}

void UserEventSpecifics_GaiaPasswordCaptured::InternalSwap(UserEventSpecifics_GaiaPasswordCaptured* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.event_trigger_, other->_impl_.event_trigger_);
}

std::string UserEventSpecifics_GaiaPasswordCaptured::GetTypeName() const
{
    return "sync_pb.UserEventSpecifics.GaiaPasswordCaptured";
}

// ===================================================================

class UserEventSpecifics_FlocIdComputed::_Internal {
public:
    using HasBits = decltype(std::declval<UserEventSpecifics_FlocIdComputed>()._impl_._has_bits_);
    static void set_has_floc_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

UserEventSpecifics_FlocIdComputed::UserEventSpecifics_FlocIdComputed(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserEventSpecifics.FlocIdComputed)
}
UserEventSpecifics_FlocIdComputed::UserEventSpecifics_FlocIdComputed(const UserEventSpecifics_FlocIdComputed& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserEventSpecifics_FlocIdComputed* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.floc_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.floc_id_ = from._impl_.floc_id_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserEventSpecifics.FlocIdComputed)
}

inline void UserEventSpecifics_FlocIdComputed::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.floc_id_) { uint64_t { 0u } } };
}

UserEventSpecifics_FlocIdComputed::~UserEventSpecifics_FlocIdComputed()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserEventSpecifics.FlocIdComputed)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserEventSpecifics_FlocIdComputed::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserEventSpecifics_FlocIdComputed::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserEventSpecifics_FlocIdComputed::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserEventSpecifics.FlocIdComputed)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.floc_id_ = uint64_t { 0u };
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserEventSpecifics_FlocIdComputed::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint64 floc_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_floc_id(&has_bits);
                _impl_.floc_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserEventSpecifics_FlocIdComputed::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserEventSpecifics.FlocIdComputed)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint64 floc_id = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_floc_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserEventSpecifics.FlocIdComputed)
    return target;
}

size_t UserEventSpecifics_FlocIdComputed::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserEventSpecifics.FlocIdComputed)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional uint64 floc_id = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_floc_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserEventSpecifics_FlocIdComputed::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserEventSpecifics_FlocIdComputed*>(&from));
}

void UserEventSpecifics_FlocIdComputed::MergeFrom(const UserEventSpecifics_FlocIdComputed& from)
{
    UserEventSpecifics_FlocIdComputed* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserEventSpecifics.FlocIdComputed)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_floc_id()) {
        _this->_internal_set_floc_id(from._internal_floc_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserEventSpecifics_FlocIdComputed::CopyFrom(const UserEventSpecifics_FlocIdComputed& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserEventSpecifics.FlocIdComputed)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserEventSpecifics_FlocIdComputed::IsInitialized() const
{
    return true;
}

void UserEventSpecifics_FlocIdComputed::InternalSwap(UserEventSpecifics_FlocIdComputed* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.floc_id_, other->_impl_.floc_id_);
}

std::string UserEventSpecifics_FlocIdComputed::GetTypeName() const
{
    return "sync_pb.UserEventSpecifics.FlocIdComputed";
}

// ===================================================================

class UserEventSpecifics::_Internal {
public:
    using HasBits = decltype(std::declval<UserEventSpecifics>()._impl_._has_bits_);
    static void set_has_event_time_usec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_navigation_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_session_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::sync_pb::UserEventSpecifics_Test& test_event(const UserEventSpecifics* msg);
    static const ::sync_pb::UserEventSpecifics_LanguageDetection& language_detection_event(const UserEventSpecifics* msg);
    static const ::sync_pb::UserEventSpecifics_Translation& translation_event(const UserEventSpecifics* msg);
    static const ::sync_pb::GaiaPasswordReuse& gaia_password_reuse_event(const UserEventSpecifics* msg);
    static const ::sync_pb::UserEventSpecifics_GaiaPasswordCaptured& gaia_password_captured_event(const UserEventSpecifics* msg);
    static const ::sync_pb::UserEventSpecifics_FlocIdComputed& floc_id_computed_event(const UserEventSpecifics* msg);
};

const ::sync_pb::UserEventSpecifics_Test& UserEventSpecifics::_Internal::test_event(const UserEventSpecifics* msg)
{
    return *msg->_impl_.event_.test_event_;
}
const ::sync_pb::UserEventSpecifics_LanguageDetection& UserEventSpecifics::_Internal::language_detection_event(const UserEventSpecifics* msg)
{
    return *msg->_impl_.event_.language_detection_event_;
}
const ::sync_pb::UserEventSpecifics_Translation& UserEventSpecifics::_Internal::translation_event(const UserEventSpecifics* msg)
{
    return *msg->_impl_.event_.translation_event_;
}
const ::sync_pb::GaiaPasswordReuse& UserEventSpecifics::_Internal::gaia_password_reuse_event(const UserEventSpecifics* msg)
{
    return *msg->_impl_.event_.gaia_password_reuse_event_;
}
const ::sync_pb::UserEventSpecifics_GaiaPasswordCaptured& UserEventSpecifics::_Internal::gaia_password_captured_event(const UserEventSpecifics* msg)
{
    return *msg->_impl_.event_.gaia_password_captured_event_;
}
const ::sync_pb::UserEventSpecifics_FlocIdComputed& UserEventSpecifics::_Internal::floc_id_computed_event(const UserEventSpecifics* msg)
{
    return *msg->_impl_.event_.floc_id_computed_event_;
}
void UserEventSpecifics::set_allocated_test_event(::sync_pb::UserEventSpecifics_Test* test_event)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_event();
    if (test_event) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(test_event);
        if (message_arena != submessage_arena) {
            test_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, test_event, submessage_arena);
        }
        set_has_test_event();
        _impl_.event_.test_event_ = test_event;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.UserEventSpecifics.test_event)
}
void UserEventSpecifics::set_allocated_language_detection_event(::sync_pb::UserEventSpecifics_LanguageDetection* language_detection_event)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_event();
    if (language_detection_event) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(language_detection_event);
        if (message_arena != submessage_arena) {
            language_detection_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, language_detection_event, submessage_arena);
        }
        set_has_language_detection_event();
        _impl_.event_.language_detection_event_ = language_detection_event;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.UserEventSpecifics.language_detection_event)
}
void UserEventSpecifics::set_allocated_translation_event(::sync_pb::UserEventSpecifics_Translation* translation_event)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_event();
    if (translation_event) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(translation_event);
        if (message_arena != submessage_arena) {
            translation_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, translation_event, submessage_arena);
        }
        set_has_translation_event();
        _impl_.event_.translation_event_ = translation_event;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.UserEventSpecifics.translation_event)
}
void UserEventSpecifics::set_allocated_gaia_password_reuse_event(::sync_pb::GaiaPasswordReuse* gaia_password_reuse_event)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_event();
    if (gaia_password_reuse_event) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gaia_password_reuse_event));
        if (message_arena != submessage_arena) {
            gaia_password_reuse_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, gaia_password_reuse_event, submessage_arena);
        }
        set_has_gaia_password_reuse_event();
        _impl_.event_.gaia_password_reuse_event_ = gaia_password_reuse_event;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.UserEventSpecifics.gaia_password_reuse_event)
}
void UserEventSpecifics::clear_gaia_password_reuse_event()
{
    if (_internal_has_gaia_password_reuse_event()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.event_.gaia_password_reuse_event_;
        }
        clear_has_event();
    }
}
void UserEventSpecifics::set_allocated_gaia_password_captured_event(::sync_pb::UserEventSpecifics_GaiaPasswordCaptured* gaia_password_captured_event)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_event();
    if (gaia_password_captured_event) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gaia_password_captured_event);
        if (message_arena != submessage_arena) {
            gaia_password_captured_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, gaia_password_captured_event, submessage_arena);
        }
        set_has_gaia_password_captured_event();
        _impl_.event_.gaia_password_captured_event_ = gaia_password_captured_event;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.UserEventSpecifics.gaia_password_captured_event)
}
void UserEventSpecifics::set_allocated_floc_id_computed_event(::sync_pb::UserEventSpecifics_FlocIdComputed* floc_id_computed_event)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_event();
    if (floc_id_computed_event) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(floc_id_computed_event);
        if (message_arena != submessage_arena) {
            floc_id_computed_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, floc_id_computed_event, submessage_arena);
        }
        set_has_floc_id_computed_event();
        _impl_.event_.floc_id_computed_event_ = floc_id_computed_event;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.UserEventSpecifics.floc_id_computed_event)
}
UserEventSpecifics::UserEventSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserEventSpecifics)
}
UserEventSpecifics::UserEventSpecifics(const UserEventSpecifics& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserEventSpecifics* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.event_time_usec_) {},
        decltype(_impl_.navigation_id_) {}, decltype(_impl_.session_id_) {}, decltype(_impl_.event_) {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.event_time_usec_, &from._impl_.event_time_usec_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.session_id_) - reinterpret_cast<char*>(&_impl_.event_time_usec_)) + sizeof(_impl_.session_id_));
    clear_has_event();
    switch (from.event_case()) {
    case kTestEvent: {
        _this->_internal_mutable_test_event()->::sync_pb::UserEventSpecifics_Test::MergeFrom(from._internal_test_event());
        break;
    }
    case kLanguageDetectionEvent: {
        _this->_internal_mutable_language_detection_event()->::sync_pb::UserEventSpecifics_LanguageDetection::MergeFrom(
            from._internal_language_detection_event());
        break;
    }
    case kTranslationEvent: {
        _this->_internal_mutable_translation_event()->::sync_pb::UserEventSpecifics_Translation::MergeFrom(from._internal_translation_event());
        break;
    }
    case kGaiaPasswordReuseEvent: {
        _this->_internal_mutable_gaia_password_reuse_event()->::sync_pb::GaiaPasswordReuse::MergeFrom(from._internal_gaia_password_reuse_event());
        break;
    }
    case kGaiaPasswordCapturedEvent: {
        _this->_internal_mutable_gaia_password_captured_event()->::sync_pb::UserEventSpecifics_GaiaPasswordCaptured::MergeFrom(
            from._internal_gaia_password_captured_event());
        break;
    }
    case kFlocIdComputedEvent: {
        _this->_internal_mutable_floc_id_computed_event()->::sync_pb::UserEventSpecifics_FlocIdComputed::MergeFrom(from._internal_floc_id_computed_event());
        break;
    }
    case EVENT_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserEventSpecifics)
}

inline void UserEventSpecifics::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.event_time_usec_) { int64_t { 0 } },
        decltype(_impl_.navigation_id_) { int64_t { 0 } }, decltype(_impl_.session_id_) { uint64_t { 0u } }, decltype(_impl_.event_) {},
        /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_event();
}

UserEventSpecifics::~UserEventSpecifics()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserEventSpecifics)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserEventSpecifics::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_event()) {
        clear_event();
    }
}

void UserEventSpecifics::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserEventSpecifics::clear_event()
{
    // @@protoc_insertion_point(one_of_clear_start:sync_pb.UserEventSpecifics)
    switch (event_case()) {
    case kTestEvent: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.event_.test_event_;
        }
        break;
    }
    case kLanguageDetectionEvent: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.event_.language_detection_event_;
        }
        break;
    }
    case kTranslationEvent: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.event_.translation_event_;
        }
        break;
    }
    case kGaiaPasswordReuseEvent: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.event_.gaia_password_reuse_event_;
        }
        break;
    }
    case kGaiaPasswordCapturedEvent: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.event_.gaia_password_captured_event_;
        }
        break;
    }
    case kFlocIdComputedEvent: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.event_.floc_id_computed_event_;
        }
        break;
    }
    case EVENT_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = EVENT_NOT_SET;
}

void UserEventSpecifics::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserEventSpecifics)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        ::memset(&_impl_.event_time_usec_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.session_id_) - reinterpret_cast<char*>(&_impl_.event_time_usec_)) + sizeof(_impl_.session_id_));
    }
    clear_event();
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserEventSpecifics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 event_time_usec = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_event_time_usec(&has_bits);
                _impl_.event_time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 navigation_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_navigation_id(&has_bits);
                _impl_.navigation_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional fixed64 session_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
                _Internal::set_has_session_id(&has_bits);
                _impl_.session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
                ptr += sizeof(uint64_t);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.UserEventSpecifics.Test test_event = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_test_event(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.UserEventSpecifics.LanguageDetection language_detection_event = 10 [deprecated = true];
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr = ctx->ParseMessage(_internal_mutable_language_detection_event(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.UserEventSpecifics.Translation translation_event = 11 [deprecated = true];
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_translation_event(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.UserEventSpecifics.GaiaPasswordCaptured gaia_password_captured_event = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
                ptr = ctx->ParseMessage(_internal_mutable_gaia_password_captured_event(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.UserEventSpecifics.FlocIdComputed floc_id_computed_event = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                ptr = ctx->ParseMessage(_internal_mutable_floc_id_computed_event(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.GaiaPasswordReuse gaia_password_reuse_event = 104;
        case 104:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_gaia_password_reuse_event(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserEventSpecifics::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserEventSpecifics)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 event_time_usec = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_event_time_usec(), target);
    }

    // optional int64 navigation_id = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_navigation_id(), target);
    }

    // optional fixed64 session_id = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_session_id(), target);
    }

    switch (event_case()) {
    case kTestEvent: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            8, _Internal::test_event(this), _Internal::test_event(this).GetCachedSize(), target, stream);
        break;
    }
    case kLanguageDetectionEvent: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            10, _Internal::language_detection_event(this), _Internal::language_detection_event(this).GetCachedSize(), target, stream);
        break;
    }
    case kTranslationEvent: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::translation_event(this), _Internal::translation_event(this).GetCachedSize(), target, stream);
        break;
    }
    case kGaiaPasswordCapturedEvent: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            15, _Internal::gaia_password_captured_event(this), _Internal::gaia_password_captured_event(this).GetCachedSize(), target, stream);
        break;
    }
    case kFlocIdComputedEvent: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            16, _Internal::floc_id_computed_event(this), _Internal::floc_id_computed_event(this).GetCachedSize(), target, stream);
        break;
    }
    case kGaiaPasswordReuseEvent: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            104, _Internal::gaia_password_reuse_event(this), _Internal::gaia_password_reuse_event(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserEventSpecifics)
    return target;
}

size_t UserEventSpecifics::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserEventSpecifics)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional int64 event_time_usec = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_event_time_usec());
        }

        // optional int64 navigation_id = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_navigation_id());
        }

        // optional fixed64 session_id = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 8;
        }
    }
    switch (event_case()) {
    // .sync_pb.UserEventSpecifics.Test test_event = 8;
    case kTestEvent: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.event_.test_event_);
        break;
    }
    // .sync_pb.UserEventSpecifics.LanguageDetection language_detection_event = 10 [deprecated = true];
    case kLanguageDetectionEvent: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.event_.language_detection_event_);
        break;
    }
    // .sync_pb.UserEventSpecifics.Translation translation_event = 11 [deprecated = true];
    case kTranslationEvent: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.event_.translation_event_);
        break;
    }
    // .sync_pb.GaiaPasswordReuse gaia_password_reuse_event = 104;
    case kGaiaPasswordReuseEvent: {
        total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.event_.gaia_password_reuse_event_);
        break;
    }
    // .sync_pb.UserEventSpecifics.GaiaPasswordCaptured gaia_password_captured_event = 15;
    case kGaiaPasswordCapturedEvent: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.event_.gaia_password_captured_event_);
        break;
    }
    // .sync_pb.UserEventSpecifics.FlocIdComputed floc_id_computed_event = 16;
    case kFlocIdComputedEvent: {
        total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.event_.floc_id_computed_event_);
        break;
    }
    case EVENT_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserEventSpecifics::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserEventSpecifics*>(&from));
}

void UserEventSpecifics::MergeFrom(const UserEventSpecifics& from)
{
    UserEventSpecifics* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserEventSpecifics)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.event_time_usec_ = from._impl_.event_time_usec_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.navigation_id_ = from._impl_.navigation_id_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.session_id_ = from._impl_.session_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    switch (from.event_case()) {
    case kTestEvent: {
        _this->_internal_mutable_test_event()->::sync_pb::UserEventSpecifics_Test::MergeFrom(from._internal_test_event());
        break;
    }
    case kLanguageDetectionEvent: {
        _this->_internal_mutable_language_detection_event()->::sync_pb::UserEventSpecifics_LanguageDetection::MergeFrom(
            from._internal_language_detection_event());
        break;
    }
    case kTranslationEvent: {
        _this->_internal_mutable_translation_event()->::sync_pb::UserEventSpecifics_Translation::MergeFrom(from._internal_translation_event());
        break;
    }
    case kGaiaPasswordReuseEvent: {
        _this->_internal_mutable_gaia_password_reuse_event()->::sync_pb::GaiaPasswordReuse::MergeFrom(from._internal_gaia_password_reuse_event());
        break;
    }
    case kGaiaPasswordCapturedEvent: {
        _this->_internal_mutable_gaia_password_captured_event()->::sync_pb::UserEventSpecifics_GaiaPasswordCaptured::MergeFrom(
            from._internal_gaia_password_captured_event());
        break;
    }
    case kFlocIdComputedEvent: {
        _this->_internal_mutable_floc_id_computed_event()->::sync_pb::UserEventSpecifics_FlocIdComputed::MergeFrom(from._internal_floc_id_computed_event());
        break;
    }
    case EVENT_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserEventSpecifics::CopyFrom(const UserEventSpecifics& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserEventSpecifics)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserEventSpecifics::IsInitialized() const
{
    return true;
}

void UserEventSpecifics::InternalSwap(UserEventSpecifics* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(UserEventSpecifics, _impl_.session_id_) + sizeof(UserEventSpecifics::_impl_.session_id_)
        - PROTOBUF_FIELD_OFFSET(UserEventSpecifics, _impl_.event_time_usec_)>(
        reinterpret_cast<char*>(&_impl_.event_time_usec_), reinterpret_cast<char*>(&other->_impl_.event_time_usec_));
    swap(_impl_.event_, other->_impl_.event_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string UserEventSpecifics::GetTypeName() const
{
    return "sync_pb.UserEventSpecifics";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::sync_pb::UserEventSpecifics_Test* Arena::CreateMaybeMessage<::sync_pb::UserEventSpecifics_Test>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserEventSpecifics_Test>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::UserEventSpecifics_LanguageDetection_Language* Arena::CreateMaybeMessage<::sync_pb::UserEventSpecifics_LanguageDetection_Language>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserEventSpecifics_LanguageDetection_Language>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::UserEventSpecifics_LanguageDetection* Arena::CreateMaybeMessage<::sync_pb::UserEventSpecifics_LanguageDetection>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserEventSpecifics_LanguageDetection>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::UserEventSpecifics_Translation* Arena::CreateMaybeMessage<::sync_pb::UserEventSpecifics_Translation>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserEventSpecifics_Translation>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::UserEventSpecifics_GaiaPasswordCaptured* Arena::CreateMaybeMessage<::sync_pb::UserEventSpecifics_GaiaPasswordCaptured>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserEventSpecifics_GaiaPasswordCaptured>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::UserEventSpecifics_FlocIdComputed* Arena::CreateMaybeMessage<::sync_pb::UserEventSpecifics_FlocIdComputed>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserEventSpecifics_FlocIdComputed>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::UserEventSpecifics* Arena::CreateMaybeMessage<::sync_pb::UserEventSpecifics>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserEventSpecifics>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
