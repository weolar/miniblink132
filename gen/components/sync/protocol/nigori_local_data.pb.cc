// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/nigori_local_data.proto

#include "components/sync/protocol/nigori_local_data.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sync_pb {
PROTOBUF_CONSTEXPR CrossUserSharingKeys::CrossUserSharingKeys(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.private_key_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct CrossUserSharingKeysDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CrossUserSharingKeysDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CrossUserSharingKeysDefaultTypeInternal()
    {
    }
    union {
        CrossUserSharingKeys _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CrossUserSharingKeysDefaultTypeInternal
    _CrossUserSharingKeys_default_instance_;
PROTOBUF_CONSTEXPR LocalNigoriKeyBag::LocalNigoriKeyBag(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.key_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct LocalNigoriKeyBagDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LocalNigoriKeyBagDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LocalNigoriKeyBagDefaultTypeInternal()
    {
    }
    union {
        LocalNigoriKeyBag _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocalNigoriKeyBagDefaultTypeInternal _LocalNigoriKeyBag_default_instance_;
PROTOBUF_CONSTEXPR CryptographerData::CryptographerData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.default_key_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.key_bag_)*/ nullptr,
        /*decltype(_impl_.cross_user_sharing_keys_)*/ nullptr }
{
}
struct CryptographerDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CryptographerDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CryptographerDataDefaultTypeInternal()
    {
    }
    union {
        CryptographerData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CryptographerDataDefaultTypeInternal _CryptographerData_default_instance_;
PROTOBUF_CONSTEXPR CustomPassphraseKeyDerivationParams::CustomPassphraseKeyDerivationParams(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.custom_passphrase_key_derivation_salt_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.custom_passphrase_key_derivation_method_)*/ 0 }
{
}
struct CustomPassphraseKeyDerivationParamsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CustomPassphraseKeyDerivationParamsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CustomPassphraseKeyDerivationParamsDefaultTypeInternal()
    {
    }
    union {
        CustomPassphraseKeyDerivationParams _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CustomPassphraseKeyDerivationParamsDefaultTypeInternal
    _CustomPassphraseKeyDerivationParams_default_instance_;
PROTOBUF_CONSTEXPR NigoriModel::NigoriModel(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.encrypted_types_specifics_field_number_)*/ {},
        /*decltype(_impl_.keystore_key_)*/ {},
        /*decltype(_impl_.current_keystore_key_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.last_default_trusted_vault_key_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.cryptographer_data_)*/ nullptr, /*decltype(_impl_.pending_keys_)*/ nullptr,
        /*decltype(_impl_.custom_passphrase_key_derivation_params_)*/ nullptr, /*decltype(_impl_.pending_keystore_decryptor_token_)*/ nullptr,
        /*decltype(_impl_.trusted_vault_debug_info_)*/ nullptr, /*decltype(_impl_.cross_user_sharing_public_key_)*/ nullptr,
        /*decltype(_impl_.keystore_migration_time_)*/ int64_t { 0 }, /*decltype(_impl_.custom_passphrase_time_)*/ int64_t { 0 },
        /*decltype(_impl_.passphrase_type_)*/ 0, /*decltype(_impl_.encrypt_everything_)*/ false }
{
}
struct NigoriModelDefaultTypeInternal {
    PROTOBUF_CONSTEXPR NigoriModelDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~NigoriModelDefaultTypeInternal()
    {
    }
    union {
        NigoriModel _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NigoriModelDefaultTypeInternal _NigoriModel_default_instance_;
PROTOBUF_CONSTEXPR NigoriLocalData::NigoriLocalData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.data_type_state_)*/ nullptr,
        /*decltype(_impl_.entity_metadata_)*/ nullptr, /*decltype(_impl_.nigori_model_)*/ nullptr }
{
}
struct NigoriLocalDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR NigoriLocalDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~NigoriLocalDataDefaultTypeInternal()
    {
    }
    union {
        NigoriLocalData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NigoriLocalDataDefaultTypeInternal _NigoriLocalData_default_instance_;
} // namespace sync_pb
namespace sync_pb {

// ===================================================================

class CrossUserSharingKeys::_Internal {
public:
};

void CrossUserSharingKeys::clear_private_key()
{
    _impl_.private_key_.Clear();
}
CrossUserSharingKeys::CrossUserSharingKeys(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.CrossUserSharingKeys)
}
CrossUserSharingKeys::CrossUserSharingKeys(const CrossUserSharingKeys& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CrossUserSharingKeys* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.private_key_) { from._impl_.private_key_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:sync_pb.CrossUserSharingKeys)
}

inline void CrossUserSharingKeys::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.private_key_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

CrossUserSharingKeys::~CrossUserSharingKeys()
{
    // @@protoc_insertion_point(destructor:sync_pb.CrossUserSharingKeys)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CrossUserSharingKeys::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.private_key_.~RepeatedPtrField();
}

void CrossUserSharingKeys::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CrossUserSharingKeys::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.CrossUserSharingKeys)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.private_key_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CrossUserSharingKeys::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .sync_pb.CrossUserSharingPrivateKey private_key = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_private_key(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CrossUserSharingKeys::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CrossUserSharingKeys)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .sync_pb.CrossUserSharingPrivateKey private_key = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_private_key_size()); i < n; i++) {
        const auto& repfield = this->_internal_private_key(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CrossUserSharingKeys)
    return target;
}

size_t CrossUserSharingKeys::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.CrossUserSharingKeys)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.CrossUserSharingPrivateKey private_key = 1;
    total_size += 1UL * this->_internal_private_key_size();
    for (const auto& msg : this->_impl_.private_key_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CrossUserSharingKeys::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CrossUserSharingKeys*>(&from));
}

void CrossUserSharingKeys::MergeFrom(const CrossUserSharingKeys& from)
{
    CrossUserSharingKeys* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CrossUserSharingKeys)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.private_key_.MergeFrom(from._impl_.private_key_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CrossUserSharingKeys::CopyFrom(const CrossUserSharingKeys& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CrossUserSharingKeys)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CrossUserSharingKeys::IsInitialized() const
{
    return true;
}

void CrossUserSharingKeys::InternalSwap(CrossUserSharingKeys* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.private_key_.InternalSwap(&other->_impl_.private_key_);
}

std::string CrossUserSharingKeys::GetTypeName() const
{
    return "sync_pb.CrossUserSharingKeys";
}

// ===================================================================

class LocalNigoriKeyBag::_Internal {
public:
};

void LocalNigoriKeyBag::clear_key()
{
    _impl_.key_.Clear();
}
LocalNigoriKeyBag::LocalNigoriKeyBag(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.LocalNigoriKeyBag)
}
LocalNigoriKeyBag::LocalNigoriKeyBag(const LocalNigoriKeyBag& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LocalNigoriKeyBag* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.key_) { from._impl_.key_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:sync_pb.LocalNigoriKeyBag)
}

inline void LocalNigoriKeyBag::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.key_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

LocalNigoriKeyBag::~LocalNigoriKeyBag()
{
    // @@protoc_insertion_point(destructor:sync_pb.LocalNigoriKeyBag)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LocalNigoriKeyBag::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.key_.~RepeatedPtrField();
}

void LocalNigoriKeyBag::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LocalNigoriKeyBag::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.LocalNigoriKeyBag)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.key_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* LocalNigoriKeyBag::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .sync_pb.NigoriKey key = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_key(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LocalNigoriKeyBag::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.LocalNigoriKeyBag)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .sync_pb.NigoriKey key = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_key_size()); i < n; i++) {
        const auto& repfield = this->_internal_key(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.LocalNigoriKeyBag)
    return target;
}

size_t LocalNigoriKeyBag::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.LocalNigoriKeyBag)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.NigoriKey key = 2;
    total_size += 1UL * this->_internal_key_size();
    for (const auto& msg : this->_impl_.key_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LocalNigoriKeyBag::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LocalNigoriKeyBag*>(&from));
}

void LocalNigoriKeyBag::MergeFrom(const LocalNigoriKeyBag& from)
{
    LocalNigoriKeyBag* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.LocalNigoriKeyBag)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.key_.MergeFrom(from._impl_.key_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LocalNigoriKeyBag::CopyFrom(const LocalNigoriKeyBag& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.LocalNigoriKeyBag)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LocalNigoriKeyBag::IsInitialized() const
{
    return true;
}

void LocalNigoriKeyBag::InternalSwap(LocalNigoriKeyBag* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.key_.InternalSwap(&other->_impl_.key_);
}

std::string LocalNigoriKeyBag::GetTypeName() const
{
    return "sync_pb.LocalNigoriKeyBag";
}

// ===================================================================

class CryptographerData::_Internal {
public:
    using HasBits = decltype(std::declval<CryptographerData>()._impl_._has_bits_);
    static const ::sync_pb::LocalNigoriKeyBag& key_bag(const CryptographerData* msg);
    static void set_has_key_bag(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_default_key_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::sync_pb::CrossUserSharingKeys& cross_user_sharing_keys(const CryptographerData* msg);
    static void set_has_cross_user_sharing_keys(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::sync_pb::LocalNigoriKeyBag& CryptographerData::_Internal::key_bag(const CryptographerData* msg)
{
    return *msg->_impl_.key_bag_;
}
const ::sync_pb::CrossUserSharingKeys& CryptographerData::_Internal::cross_user_sharing_keys(const CryptographerData* msg)
{
    return *msg->_impl_.cross_user_sharing_keys_;
}
CryptographerData::CryptographerData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.CryptographerData)
}
CryptographerData::CryptographerData(const CryptographerData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CryptographerData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.default_key_name_) {},
        decltype(_impl_.key_bag_) { nullptr }, decltype(_impl_.cross_user_sharing_keys_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.default_key_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_key_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_default_key_name()) {
        _this->_impl_.default_key_name_.Set(from._internal_default_key_name(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_key_bag()) {
        _this->_impl_.key_bag_ = new ::sync_pb::LocalNigoriKeyBag(*from._impl_.key_bag_);
    }
    if (from._internal_has_cross_user_sharing_keys()) {
        _this->_impl_.cross_user_sharing_keys_ = new ::sync_pb::CrossUserSharingKeys(*from._impl_.cross_user_sharing_keys_);
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.CryptographerData)
}

inline void CryptographerData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.default_key_name_) {},
        decltype(_impl_.key_bag_) { nullptr }, decltype(_impl_.cross_user_sharing_keys_) { nullptr } };
    _impl_.default_key_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.default_key_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CryptographerData::~CryptographerData()
{
    // @@protoc_insertion_point(destructor:sync_pb.CryptographerData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CryptographerData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.default_key_name_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.key_bag_;
    if (this != internal_default_instance())
        delete _impl_.cross_user_sharing_keys_;
}

void CryptographerData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CryptographerData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.CryptographerData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.default_key_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.key_bag_ != nullptr);
            _impl_.key_bag_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.cross_user_sharing_keys_ != nullptr);
            _impl_.cross_user_sharing_keys_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CryptographerData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.LocalNigoriKeyBag key_bag = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_key_bag(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string default_key_name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_default_key_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.CrossUserSharingKeys cross_user_sharing_keys = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_cross_user_sharing_keys(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CryptographerData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CryptographerData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.LocalNigoriKeyBag key_bag = 1;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::key_bag(this), _Internal::key_bag(this).GetCachedSize(), target, stream);
    }

    // optional string default_key_name = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_default_key_name(), target);
    }

    // optional .sync_pb.CrossUserSharingKeys cross_user_sharing_keys = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::cross_user_sharing_keys(this), _Internal::cross_user_sharing_keys(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CryptographerData)
    return target;
}

size_t CryptographerData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.CryptographerData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string default_key_name = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_default_key_name());
        }

        // optional .sync_pb.LocalNigoriKeyBag key_bag = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.key_bag_);
        }

        // optional .sync_pb.CrossUserSharingKeys cross_user_sharing_keys = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.cross_user_sharing_keys_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CryptographerData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CryptographerData*>(&from));
}

void CryptographerData::MergeFrom(const CryptographerData& from)
{
    CryptographerData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CryptographerData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_default_key_name(from._internal_default_key_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_key_bag()->::sync_pb::LocalNigoriKeyBag::MergeFrom(from._internal_key_bag());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_cross_user_sharing_keys()->::sync_pb::CrossUserSharingKeys::MergeFrom(from._internal_cross_user_sharing_keys());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CryptographerData::CopyFrom(const CryptographerData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CryptographerData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CryptographerData::IsInitialized() const
{
    return true;
}

void CryptographerData::InternalSwap(CryptographerData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.default_key_name_, lhs_arena, &other->_impl_.default_key_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(CryptographerData, _impl_.cross_user_sharing_keys_)
        + sizeof(CryptographerData::_impl_.cross_user_sharing_keys_) - PROTOBUF_FIELD_OFFSET(CryptographerData, _impl_.key_bag_)>(
        reinterpret_cast<char*>(&_impl_.key_bag_), reinterpret_cast<char*>(&other->_impl_.key_bag_));
}

std::string CryptographerData::GetTypeName() const
{
    return "sync_pb.CryptographerData";
}

// ===================================================================

class CustomPassphraseKeyDerivationParams::_Internal {
public:
    using HasBits = decltype(std::declval<CustomPassphraseKeyDerivationParams>()._impl_._has_bits_);
    static void set_has_custom_passphrase_key_derivation_method(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_custom_passphrase_key_derivation_salt(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

CustomPassphraseKeyDerivationParams::CustomPassphraseKeyDerivationParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.CustomPassphraseKeyDerivationParams)
}
CustomPassphraseKeyDerivationParams::CustomPassphraseKeyDerivationParams(const CustomPassphraseKeyDerivationParams& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CustomPassphraseKeyDerivationParams* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.custom_passphrase_key_derivation_salt_) {}, decltype(_impl_.custom_passphrase_key_derivation_method_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.custom_passphrase_key_derivation_salt_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.custom_passphrase_key_derivation_salt_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_custom_passphrase_key_derivation_salt()) {
        _this->_impl_.custom_passphrase_key_derivation_salt_.Set(from._internal_custom_passphrase_key_derivation_salt(), _this->GetArenaForAllocation());
    }
    _this->_impl_.custom_passphrase_key_derivation_method_ = from._impl_.custom_passphrase_key_derivation_method_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.CustomPassphraseKeyDerivationParams)
}

inline void CustomPassphraseKeyDerivationParams::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.custom_passphrase_key_derivation_salt_) {},
        decltype(_impl_.custom_passphrase_key_derivation_method_) { 0 } };
    _impl_.custom_passphrase_key_derivation_salt_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.custom_passphrase_key_derivation_salt_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CustomPassphraseKeyDerivationParams::~CustomPassphraseKeyDerivationParams()
{
    // @@protoc_insertion_point(destructor:sync_pb.CustomPassphraseKeyDerivationParams)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CustomPassphraseKeyDerivationParams::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.custom_passphrase_key_derivation_salt_.Destroy();
}

void CustomPassphraseKeyDerivationParams::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CustomPassphraseKeyDerivationParams::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.CustomPassphraseKeyDerivationParams)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.custom_passphrase_key_derivation_salt_.ClearNonDefaultToEmpty();
    }
    _impl_.custom_passphrase_key_derivation_method_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CustomPassphraseKeyDerivationParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.NigoriSpecifics.KeyDerivationMethod custom_passphrase_key_derivation_method = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::NigoriSpecifics_KeyDerivationMethod_IsValid(val))) {
                    _internal_set_custom_passphrase_key_derivation_method(static_cast<::sync_pb::NigoriSpecifics_KeyDerivationMethod>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string custom_passphrase_key_derivation_salt = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_custom_passphrase_key_derivation_salt();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CustomPassphraseKeyDerivationParams::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CustomPassphraseKeyDerivationParams)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.NigoriSpecifics.KeyDerivationMethod custom_passphrase_key_derivation_method = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_custom_passphrase_key_derivation_method(), target);
    }

    // optional string custom_passphrase_key_derivation_salt = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_custom_passphrase_key_derivation_salt(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CustomPassphraseKeyDerivationParams)
    return target;
}

size_t CustomPassphraseKeyDerivationParams::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.CustomPassphraseKeyDerivationParams)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string custom_passphrase_key_derivation_salt = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_custom_passphrase_key_derivation_salt());
        }

        // optional .sync_pb.NigoriSpecifics.KeyDerivationMethod custom_passphrase_key_derivation_method = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_custom_passphrase_key_derivation_method());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CustomPassphraseKeyDerivationParams::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CustomPassphraseKeyDerivationParams*>(&from));
}

void CustomPassphraseKeyDerivationParams::MergeFrom(const CustomPassphraseKeyDerivationParams& from)
{
    CustomPassphraseKeyDerivationParams* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CustomPassphraseKeyDerivationParams)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_custom_passphrase_key_derivation_salt(from._internal_custom_passphrase_key_derivation_salt());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.custom_passphrase_key_derivation_method_ = from._impl_.custom_passphrase_key_derivation_method_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CustomPassphraseKeyDerivationParams::CopyFrom(const CustomPassphraseKeyDerivationParams& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CustomPassphraseKeyDerivationParams)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CustomPassphraseKeyDerivationParams::IsInitialized() const
{
    return true;
}

void CustomPassphraseKeyDerivationParams::InternalSwap(CustomPassphraseKeyDerivationParams* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.custom_passphrase_key_derivation_salt_, lhs_arena, &other->_impl_.custom_passphrase_key_derivation_salt_, rhs_arena);
    swap(_impl_.custom_passphrase_key_derivation_method_, other->_impl_.custom_passphrase_key_derivation_method_);
}

std::string CustomPassphraseKeyDerivationParams::GetTypeName() const
{
    return "sync_pb.CustomPassphraseKeyDerivationParams";
}

// ===================================================================

class NigoriModel::_Internal {
public:
    using HasBits = decltype(std::declval<NigoriModel>()._impl_._has_bits_);
    static const ::sync_pb::CryptographerData& cryptographer_data(const NigoriModel* msg);
    static void set_has_cryptographer_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_current_keystore_key_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::sync_pb::EncryptedData& pending_keys(const NigoriModel* msg);
    static void set_has_pending_keys(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_passphrase_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_keystore_migration_time(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_custom_passphrase_time(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static const ::sync_pb::CustomPassphraseKeyDerivationParams& custom_passphrase_key_derivation_params(const NigoriModel* msg);
    static void set_has_custom_passphrase_key_derivation_params(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_encrypt_everything(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static const ::sync_pb::EncryptedData& pending_keystore_decryptor_token(const NigoriModel* msg);
    static void set_has_pending_keystore_decryptor_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_last_default_trusted_vault_key_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo& trusted_vault_debug_info(const NigoriModel* msg);
    static void set_has_trusted_vault_debug_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static const ::sync_pb::CrossUserSharingPublicKey& cross_user_sharing_public_key(const NigoriModel* msg);
    static void set_has_cross_user_sharing_public_key(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
};

const ::sync_pb::CryptographerData& NigoriModel::_Internal::cryptographer_data(const NigoriModel* msg)
{
    return *msg->_impl_.cryptographer_data_;
}
const ::sync_pb::EncryptedData& NigoriModel::_Internal::pending_keys(const NigoriModel* msg)
{
    return *msg->_impl_.pending_keys_;
}
const ::sync_pb::CustomPassphraseKeyDerivationParams& NigoriModel::_Internal::custom_passphrase_key_derivation_params(const NigoriModel* msg)
{
    return *msg->_impl_.custom_passphrase_key_derivation_params_;
}
const ::sync_pb::EncryptedData& NigoriModel::_Internal::pending_keystore_decryptor_token(const NigoriModel* msg)
{
    return *msg->_impl_.pending_keystore_decryptor_token_;
}
const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo& NigoriModel::_Internal::trusted_vault_debug_info(const NigoriModel* msg)
{
    return *msg->_impl_.trusted_vault_debug_info_;
}
const ::sync_pb::CrossUserSharingPublicKey& NigoriModel::_Internal::cross_user_sharing_public_key(const NigoriModel* msg)
{
    return *msg->_impl_.cross_user_sharing_public_key_;
}
void NigoriModel::clear_pending_keys()
{
    if (_impl_.pending_keys_ != nullptr)
        _impl_.pending_keys_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
void NigoriModel::clear_pending_keystore_decryptor_token()
{
    if (_impl_.pending_keystore_decryptor_token_ != nullptr)
        _impl_.pending_keystore_decryptor_token_->Clear();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
void NigoriModel::clear_trusted_vault_debug_info()
{
    if (_impl_.trusted_vault_debug_info_ != nullptr)
        _impl_.trusted_vault_debug_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
void NigoriModel::clear_cross_user_sharing_public_key()
{
    if (_impl_.cross_user_sharing_public_key_ != nullptr)
        _impl_.cross_user_sharing_public_key_->Clear();
    _impl_._has_bits_[0] &= ~0x00000080u;
}
NigoriModel::NigoriModel(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.NigoriModel)
}
NigoriModel::NigoriModel(const NigoriModel& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    NigoriModel* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.encrypted_types_specifics_field_number_) { from._impl_.encrypted_types_specifics_field_number_ },
        decltype(_impl_.keystore_key_) { from._impl_.keystore_key_ }, decltype(_impl_.current_keystore_key_name_) {},
        decltype(_impl_.last_default_trusted_vault_key_name_) {}, decltype(_impl_.cryptographer_data_) { nullptr }, decltype(_impl_.pending_keys_) { nullptr },
        decltype(_impl_.custom_passphrase_key_derivation_params_) { nullptr }, decltype(_impl_.pending_keystore_decryptor_token_) { nullptr },
        decltype(_impl_.trusted_vault_debug_info_) { nullptr }, decltype(_impl_.cross_user_sharing_public_key_) { nullptr },
        decltype(_impl_.keystore_migration_time_) {}, decltype(_impl_.custom_passphrase_time_) {}, decltype(_impl_.passphrase_type_) {},
        decltype(_impl_.encrypt_everything_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.current_keystore_key_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_keystore_key_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_current_keystore_key_name()) {
        _this->_impl_.current_keystore_key_name_.Set(from._internal_current_keystore_key_name(), _this->GetArenaForAllocation());
    }
    _impl_.last_default_trusted_vault_key_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_default_trusted_vault_key_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_last_default_trusted_vault_key_name()) {
        _this->_impl_.last_default_trusted_vault_key_name_.Set(from._internal_last_default_trusted_vault_key_name(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_cryptographer_data()) {
        _this->_impl_.cryptographer_data_ = new ::sync_pb::CryptographerData(*from._impl_.cryptographer_data_);
    }
    if (from._internal_has_pending_keys()) {
        _this->_impl_.pending_keys_ = new ::sync_pb::EncryptedData(*from._impl_.pending_keys_);
    }
    if (from._internal_has_custom_passphrase_key_derivation_params()) {
        _this->_impl_.custom_passphrase_key_derivation_params_
            = new ::sync_pb::CustomPassphraseKeyDerivationParams(*from._impl_.custom_passphrase_key_derivation_params_);
    }
    if (from._internal_has_pending_keystore_decryptor_token()) {
        _this->_impl_.pending_keystore_decryptor_token_ = new ::sync_pb::EncryptedData(*from._impl_.pending_keystore_decryptor_token_);
    }
    if (from._internal_has_trusted_vault_debug_info()) {
        _this->_impl_.trusted_vault_debug_info_ = new ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo(*from._impl_.trusted_vault_debug_info_);
    }
    if (from._internal_has_cross_user_sharing_public_key()) {
        _this->_impl_.cross_user_sharing_public_key_ = new ::sync_pb::CrossUserSharingPublicKey(*from._impl_.cross_user_sharing_public_key_);
    }
    ::memcpy(&_impl_.keystore_migration_time_, &from._impl_.keystore_migration_time_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.encrypt_everything_) - reinterpret_cast<char*>(&_impl_.keystore_migration_time_))
            + sizeof(_impl_.encrypt_everything_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.NigoriModel)
}

inline void NigoriModel::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.encrypted_types_specifics_field_number_) { arena },
            decltype(_impl_.keystore_key_) { arena }, decltype(_impl_.current_keystore_key_name_) {}, decltype(_impl_.last_default_trusted_vault_key_name_) {},
            decltype(_impl_.cryptographer_data_) { nullptr }, decltype(_impl_.pending_keys_) { nullptr },
            decltype(_impl_.custom_passphrase_key_derivation_params_) { nullptr }, decltype(_impl_.pending_keystore_decryptor_token_) { nullptr },
            decltype(_impl_.trusted_vault_debug_info_) { nullptr }, decltype(_impl_.cross_user_sharing_public_key_) { nullptr },
            decltype(_impl_.keystore_migration_time_) { int64_t { 0 } }, decltype(_impl_.custom_passphrase_time_) { int64_t { 0 } },
            decltype(_impl_.passphrase_type_) { 0 }, decltype(_impl_.encrypt_everything_) { false } };
    _impl_.current_keystore_key_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.current_keystore_key_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_default_trusted_vault_key_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_default_trusted_vault_key_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NigoriModel::~NigoriModel()
{
    // @@protoc_insertion_point(destructor:sync_pb.NigoriModel)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void NigoriModel::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.encrypted_types_specifics_field_number_.~RepeatedField();
    _impl_.keystore_key_.~RepeatedPtrField();
    _impl_.current_keystore_key_name_.Destroy();
    _impl_.last_default_trusted_vault_key_name_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.cryptographer_data_;
    if (this != internal_default_instance())
        delete _impl_.pending_keys_;
    if (this != internal_default_instance())
        delete _impl_.custom_passphrase_key_derivation_params_;
    if (this != internal_default_instance())
        delete _impl_.pending_keystore_decryptor_token_;
    if (this != internal_default_instance())
        delete _impl_.trusted_vault_debug_info_;
    if (this != internal_default_instance())
        delete _impl_.cross_user_sharing_public_key_;
}

void NigoriModel::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void NigoriModel::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.NigoriModel)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.encrypted_types_specifics_field_number_.Clear();
    _impl_.keystore_key_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.current_keystore_key_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.last_default_trusted_vault_key_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.cryptographer_data_ != nullptr);
            _impl_.cryptographer_data_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.pending_keys_ != nullptr);
            _impl_.pending_keys_->Clear();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.custom_passphrase_key_derivation_params_ != nullptr);
            _impl_.custom_passphrase_key_derivation_params_->Clear();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.pending_keystore_decryptor_token_ != nullptr);
            _impl_.pending_keystore_decryptor_token_->Clear();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.trusted_vault_debug_info_ != nullptr);
            _impl_.trusted_vault_debug_info_->Clear();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.cross_user_sharing_public_key_ != nullptr);
            _impl_.cross_user_sharing_public_key_->Clear();
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        ::memset(&_impl_.keystore_migration_time_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.encrypt_everything_) - reinterpret_cast<char*>(&_impl_.keystore_migration_time_))
                + sizeof(_impl_.encrypt_everything_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* NigoriModel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.CryptographerData cryptographer_data = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_cryptographer_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string current_keystore_key_name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_current_keystore_key_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.EncryptedData pending_keys = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_pending_keys(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.NigoriSpecifics.PassphraseType passphrase_type = 4 [default = UNKNOWN];
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::NigoriSpecifics_PassphraseType_IsValid(val))) {
                    _internal_set_passphrase_type(static_cast<::sync_pb::NigoriSpecifics_PassphraseType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 keystore_migration_time = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_keystore_migration_time(&has_bits);
                _impl_.keystore_migration_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 custom_passphrase_time = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_custom_passphrase_time(&has_bits);
                _impl_.custom_passphrase_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.CustomPassphraseKeyDerivationParams custom_passphrase_key_derivation_params = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_custom_passphrase_key_derivation_params(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool encrypt_everything = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_encrypt_everything(&has_bits);
                _impl_.encrypt_everything_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated int32 encrypted_types_specifics_field_number = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_encrypted_types_specifics_field_number(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<72>(ptr));
            } else if (static_cast<uint8_t>(tag) == 74) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_encrypted_types_specifics_field_number(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string keystore_key = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_keystore_key();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.EncryptedData pending_keystore_decryptor_token = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_pending_keystore_decryptor_token(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string last_default_trusted_vault_key_name = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                auto str = _internal_mutable_last_default_trusted_vault_key_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.NigoriSpecifics.TrustedVaultDebugInfo trusted_vault_debug_info = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                ptr = ctx->ParseMessage(_internal_mutable_trusted_vault_debug_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.CrossUserSharingPublicKey cross_user_sharing_public_key = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                ptr = ctx->ParseMessage(_internal_mutable_cross_user_sharing_public_key(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* NigoriModel::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.NigoriModel)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.CryptographerData cryptographer_data = 1;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::cryptographer_data(this), _Internal::cryptographer_data(this).GetCachedSize(), target, stream);
    }

    // optional string current_keystore_key_name = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_current_keystore_key_name(), target);
    }

    // optional .sync_pb.EncryptedData pending_keys = 3;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::pending_keys(this), _Internal::pending_keys(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.NigoriSpecifics.PassphraseType passphrase_type = 4 [default = UNKNOWN];
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_passphrase_type(), target);
    }

    // optional int64 keystore_migration_time = 5;
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_keystore_migration_time(), target);
    }

    // optional int64 custom_passphrase_time = 6;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_custom_passphrase_time(), target);
    }

    // optional .sync_pb.CustomPassphraseKeyDerivationParams custom_passphrase_key_derivation_params = 7;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(7, _Internal::custom_passphrase_key_derivation_params(this),
            _Internal::custom_passphrase_key_derivation_params(this).GetCachedSize(), target, stream);
    }

    // optional bool encrypt_everything = 8;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_encrypt_everything(), target);
    }

    // repeated int32 encrypted_types_specifics_field_number = 9;
    for (int i = 0, n = this->_internal_encrypted_types_specifics_field_number_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_encrypted_types_specifics_field_number(i), target);
    }

    // repeated string keystore_key = 10;
    for (int i = 0, n = this->_internal_keystore_key_size(); i < n; i++) {
        const auto& s = this->_internal_keystore_key(i);
        target = stream->WriteString(10, s, target);
    }

    // optional .sync_pb.EncryptedData pending_keystore_decryptor_token = 11;
    if (cached_has_bits & 0x00000020u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::pending_keystore_decryptor_token(this), _Internal::pending_keystore_decryptor_token(this).GetCachedSize(), target, stream);
    }

    // optional string last_default_trusted_vault_key_name = 12;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(12, this->_internal_last_default_trusted_vault_key_name(), target);
    }

    // optional .sync_pb.NigoriSpecifics.TrustedVaultDebugInfo trusted_vault_debug_info = 13;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            13, _Internal::trusted_vault_debug_info(this), _Internal::trusted_vault_debug_info(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.CrossUserSharingPublicKey cross_user_sharing_public_key = 14;
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            14, _Internal::cross_user_sharing_public_key(this), _Internal::cross_user_sharing_public_key(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.NigoriModel)
    return target;
}

size_t NigoriModel::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.NigoriModel)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 encrypted_types_specifics_field_number = 9;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.encrypted_types_specifics_field_number_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_encrypted_types_specifics_field_number_size());
        total_size += data_size;
    }

    // repeated string keystore_key = 10;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.keystore_key_.size());
    for (int i = 0, n = _impl_.keystore_key_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.keystore_key_.Get(i));
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string current_keystore_key_name = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_current_keystore_key_name());
        }

        // optional string last_default_trusted_vault_key_name = 12;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_last_default_trusted_vault_key_name());
        }

        // optional .sync_pb.CryptographerData cryptographer_data = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.cryptographer_data_);
        }

        // optional .sync_pb.EncryptedData pending_keys = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.pending_keys_);
        }

        // optional .sync_pb.CustomPassphraseKeyDerivationParams custom_passphrase_key_derivation_params = 7;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.custom_passphrase_key_derivation_params_);
        }

        // optional .sync_pb.EncryptedData pending_keystore_decryptor_token = 11;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.pending_keystore_decryptor_token_);
        }

        // optional .sync_pb.NigoriSpecifics.TrustedVaultDebugInfo trusted_vault_debug_info = 13;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.trusted_vault_debug_info_);
        }

        // optional .sync_pb.CrossUserSharingPublicKey cross_user_sharing_public_key = 14;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.cross_user_sharing_public_key_);
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        // optional int64 keystore_migration_time = 5;
        if (cached_has_bits & 0x00000100u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_keystore_migration_time());
        }

        // optional int64 custom_passphrase_time = 6;
        if (cached_has_bits & 0x00000200u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_custom_passphrase_time());
        }

        // optional .sync_pb.NigoriSpecifics.PassphraseType passphrase_type = 4 [default = UNKNOWN];
        if (cached_has_bits & 0x00000400u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_passphrase_type());
        }

        // optional bool encrypt_everything = 8;
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void NigoriModel::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const NigoriModel*>(&from));
}

void NigoriModel::MergeFrom(const NigoriModel& from)
{
    NigoriModel* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.NigoriModel)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.encrypted_types_specifics_field_number_.MergeFrom(from._impl_.encrypted_types_specifics_field_number_);
    _this->_impl_.keystore_key_.MergeFrom(from._impl_.keystore_key_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_current_keystore_key_name(from._internal_current_keystore_key_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_last_default_trusted_vault_key_name(from._internal_last_default_trusted_vault_key_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_cryptographer_data()->::sync_pb::CryptographerData::MergeFrom(from._internal_cryptographer_data());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_pending_keys()->::sync_pb::EncryptedData::MergeFrom(from._internal_pending_keys());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_custom_passphrase_key_derivation_params()->::sync_pb::CustomPassphraseKeyDerivationParams::MergeFrom(
                from._internal_custom_passphrase_key_derivation_params());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_pending_keystore_decryptor_token()->::sync_pb::EncryptedData::MergeFrom(from._internal_pending_keystore_decryptor_token());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_trusted_vault_debug_info()->::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo::MergeFrom(
                from._internal_trusted_vault_debug_info());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_cross_user_sharing_public_key()->::sync_pb::CrossUserSharingPublicKey::MergeFrom(
                from._internal_cross_user_sharing_public_key());
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.keystore_migration_time_ = from._impl_.keystore_migration_time_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.custom_passphrase_time_ = from._impl_.custom_passphrase_time_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.passphrase_type_ = from._impl_.passphrase_type_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.encrypt_everything_ = from._impl_.encrypt_everything_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NigoriModel::CopyFrom(const NigoriModel& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.NigoriModel)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool NigoriModel::IsInitialized() const
{
    return true;
}

void NigoriModel::InternalSwap(NigoriModel* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.encrypted_types_specifics_field_number_.InternalSwap(&other->_impl_.encrypted_types_specifics_field_number_);
    _impl_.keystore_key_.InternalSwap(&other->_impl_.keystore_key_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.current_keystore_key_name_, lhs_arena, &other->_impl_.current_keystore_key_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.last_default_trusted_vault_key_name_, lhs_arena, &other->_impl_.last_default_trusted_vault_key_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(NigoriModel, _impl_.encrypt_everything_) + sizeof(NigoriModel::_impl_.encrypt_everything_)
        - PROTOBUF_FIELD_OFFSET(NigoriModel, _impl_.cryptographer_data_)>(
        reinterpret_cast<char*>(&_impl_.cryptographer_data_), reinterpret_cast<char*>(&other->_impl_.cryptographer_data_));
}

std::string NigoriModel::GetTypeName() const
{
    return "sync_pb.NigoriModel";
}

// ===================================================================

class NigoriLocalData::_Internal {
public:
    using HasBits = decltype(std::declval<NigoriLocalData>()._impl_._has_bits_);
    static const ::sync_pb::DataTypeState& data_type_state(const NigoriLocalData* msg);
    static void set_has_data_type_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::sync_pb::EntityMetadata& entity_metadata(const NigoriLocalData* msg);
    static void set_has_entity_metadata(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::sync_pb::NigoriModel& nigori_model(const NigoriLocalData* msg);
    static void set_has_nigori_model(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::sync_pb::DataTypeState& NigoriLocalData::_Internal::data_type_state(const NigoriLocalData* msg)
{
    return *msg->_impl_.data_type_state_;
}
const ::sync_pb::EntityMetadata& NigoriLocalData::_Internal::entity_metadata(const NigoriLocalData* msg)
{
    return *msg->_impl_.entity_metadata_;
}
const ::sync_pb::NigoriModel& NigoriLocalData::_Internal::nigori_model(const NigoriLocalData* msg)
{
    return *msg->_impl_.nigori_model_;
}
void NigoriLocalData::clear_data_type_state()
{
    if (_impl_.data_type_state_ != nullptr)
        _impl_.data_type_state_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
void NigoriLocalData::clear_entity_metadata()
{
    if (_impl_.entity_metadata_ != nullptr)
        _impl_.entity_metadata_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
NigoriLocalData::NigoriLocalData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.NigoriLocalData)
}
NigoriLocalData::NigoriLocalData(const NigoriLocalData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    NigoriLocalData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.data_type_state_) { nullptr }, decltype(_impl_.entity_metadata_) { nullptr }, decltype(_impl_.nigori_model_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_data_type_state()) {
        _this->_impl_.data_type_state_ = new ::sync_pb::DataTypeState(*from._impl_.data_type_state_);
    }
    if (from._internal_has_entity_metadata()) {
        _this->_impl_.entity_metadata_ = new ::sync_pb::EntityMetadata(*from._impl_.entity_metadata_);
    }
    if (from._internal_has_nigori_model()) {
        _this->_impl_.nigori_model_ = new ::sync_pb::NigoriModel(*from._impl_.nigori_model_);
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.NigoriLocalData)
}

inline void NigoriLocalData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.data_type_state_) { nullptr },
        decltype(_impl_.entity_metadata_) { nullptr }, decltype(_impl_.nigori_model_) { nullptr } };
}

NigoriLocalData::~NigoriLocalData()
{
    // @@protoc_insertion_point(destructor:sync_pb.NigoriLocalData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void NigoriLocalData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.data_type_state_;
    if (this != internal_default_instance())
        delete _impl_.entity_metadata_;
    if (this != internal_default_instance())
        delete _impl_.nigori_model_;
}

void NigoriLocalData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void NigoriLocalData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.NigoriLocalData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.data_type_state_ != nullptr);
            _impl_.data_type_state_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.entity_metadata_ != nullptr);
            _impl_.entity_metadata_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.nigori_model_ != nullptr);
            _impl_.nigori_model_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* NigoriLocalData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.DataTypeState data_type_state = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_data_type_state(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.EntityMetadata entity_metadata = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_entity_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.NigoriModel nigori_model = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_nigori_model(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* NigoriLocalData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.NigoriLocalData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.DataTypeState data_type_state = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::data_type_state(this), _Internal::data_type_state(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.EntityMetadata entity_metadata = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::entity_metadata(this), _Internal::entity_metadata(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.NigoriModel nigori_model = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::nigori_model(this), _Internal::nigori_model(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.NigoriLocalData)
    return target;
}

size_t NigoriLocalData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.NigoriLocalData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional .sync_pb.DataTypeState data_type_state = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.data_type_state_);
        }

        // optional .sync_pb.EntityMetadata entity_metadata = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.entity_metadata_);
        }

        // optional .sync_pb.NigoriModel nigori_model = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.nigori_model_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void NigoriLocalData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const NigoriLocalData*>(&from));
}

void NigoriLocalData::MergeFrom(const NigoriLocalData& from)
{
    NigoriLocalData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.NigoriLocalData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_data_type_state()->::sync_pb::DataTypeState::MergeFrom(from._internal_data_type_state());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_entity_metadata()->::sync_pb::EntityMetadata::MergeFrom(from._internal_entity_metadata());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_nigori_model()->::sync_pb::NigoriModel::MergeFrom(from._internal_nigori_model());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NigoriLocalData::CopyFrom(const NigoriLocalData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.NigoriLocalData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool NigoriLocalData::IsInitialized() const
{
    return true;
}

void NigoriLocalData::InternalSwap(NigoriLocalData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(NigoriLocalData, _impl_.nigori_model_) + sizeof(NigoriLocalData::_impl_.nigori_model_)
        - PROTOBUF_FIELD_OFFSET(NigoriLocalData, _impl_.data_type_state_)>(
        reinterpret_cast<char*>(&_impl_.data_type_state_), reinterpret_cast<char*>(&other->_impl_.data_type_state_));
}

std::string NigoriLocalData::GetTypeName() const
{
    return "sync_pb.NigoriLocalData";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::sync_pb::CrossUserSharingKeys* Arena::CreateMaybeMessage<::sync_pb::CrossUserSharingKeys>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::CrossUserSharingKeys>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::LocalNigoriKeyBag* Arena::CreateMaybeMessage<::sync_pb::LocalNigoriKeyBag>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::LocalNigoriKeyBag>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::CryptographerData* Arena::CreateMaybeMessage<::sync_pb::CryptographerData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::CryptographerData>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::CustomPassphraseKeyDerivationParams* Arena::CreateMaybeMessage<::sync_pb::CustomPassphraseKeyDerivationParams>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::CustomPassphraseKeyDerivationParams>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::NigoriModel* Arena::CreateMaybeMessage<::sync_pb::NigoriModel>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::NigoriModel>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::NigoriLocalData* Arena::CreateMaybeMessage<::sync_pb::NigoriLocalData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::NigoriLocalData>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
