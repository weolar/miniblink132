// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/password_sharing_invitation_specifics.proto

#include "components/sync/protocol/password_sharing_invitation_specifics.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sync_pb {
PROTOBUF_CONSTEXPR PasswordSharingInvitationData_PasswordGroupElementData::PasswordSharingInvitationData_PasswordGroupElementData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.signon_realm_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.origin_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.username_element_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.password_element_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.display_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.avatar_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.scheme_)*/ 0 }
{
}
struct PasswordSharingInvitationData_PasswordGroupElementDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PasswordSharingInvitationData_PasswordGroupElementDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PasswordSharingInvitationData_PasswordGroupElementDataDefaultTypeInternal()
    {
    }
    union {
        PasswordSharingInvitationData_PasswordGroupElementData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSharingInvitationData_PasswordGroupElementDataDefaultTypeInternal
    _PasswordSharingInvitationData_PasswordGroupElementData_default_instance_;
PROTOBUF_CONSTEXPR PasswordSharingInvitationData_PasswordGroupData::PasswordSharingInvitationData_PasswordGroupData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.element_data_)*/ {},
        /*decltype(_impl_.username_value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.password_value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct PasswordSharingInvitationData_PasswordGroupDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PasswordSharingInvitationData_PasswordGroupDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PasswordSharingInvitationData_PasswordGroupDataDefaultTypeInternal()
    {
    }
    union {
        PasswordSharingInvitationData_PasswordGroupData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSharingInvitationData_PasswordGroupDataDefaultTypeInternal
    _PasswordSharingInvitationData_PasswordGroupData_default_instance_;
PROTOBUF_CONSTEXPR PasswordSharingInvitationData::PasswordSharingInvitationData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.password_group_data_)*/ nullptr }
{
}
struct PasswordSharingInvitationDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PasswordSharingInvitationDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PasswordSharingInvitationDataDefaultTypeInternal()
    {
    }
    union {
        PasswordSharingInvitationData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSharingInvitationDataDefaultTypeInternal
    _PasswordSharingInvitationData_default_instance_;
PROTOBUF_CONSTEXPR UserDisplayInfo::UserDisplayInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.email_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.display_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.profile_image_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct UserDisplayInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserDisplayInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserDisplayInfoDefaultTypeInternal()
    {
    }
    union {
        UserDisplayInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserDisplayInfoDefaultTypeInternal _UserDisplayInfo_default_instance_;
PROTOBUF_CONSTEXPR UserInfo::UserInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.user_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.user_display_info_)*/ nullptr,
        /*decltype(_impl_.cross_user_sharing_public_key_)*/ nullptr }
{
}
struct UserInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserInfoDefaultTypeInternal()
    {
    }
    union {
        UserInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserInfoDefaultTypeInternal _UserInfo_default_instance_;
PROTOBUF_CONSTEXPR IncomingPasswordSharingInvitationSpecifics::IncomingPasswordSharingInvitationSpecifics(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.guid_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.encrypted_password_sharing_invitation_data_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sender_info_)*/ nullptr, /*decltype(_impl_.client_only_unencrypted_data_)*/ nullptr, /*decltype(_impl_.recipient_key_version_)*/ 0u }
{
}
struct IncomingPasswordSharingInvitationSpecificsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR IncomingPasswordSharingInvitationSpecificsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~IncomingPasswordSharingInvitationSpecificsDefaultTypeInternal()
    {
    }
    union {
        IncomingPasswordSharingInvitationSpecifics _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IncomingPasswordSharingInvitationSpecificsDefaultTypeInternal
    _IncomingPasswordSharingInvitationSpecifics_default_instance_;
PROTOBUF_CONSTEXPR OutgoingPasswordSharingInvitationSpecifics::OutgoingPasswordSharingInvitationSpecifics(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.guid_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.recipient_user_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.encrypted_password_sharing_invitation_data_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.client_only_unencrypted_data_)*/ nullptr, /*decltype(_impl_.recipient_key_version_)*/ 0u,
        /*decltype(_impl_.sender_key_version_)*/ 0u }
{
}
struct OutgoingPasswordSharingInvitationSpecificsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR OutgoingPasswordSharingInvitationSpecificsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~OutgoingPasswordSharingInvitationSpecificsDefaultTypeInternal()
    {
    }
    union {
        OutgoingPasswordSharingInvitationSpecifics _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OutgoingPasswordSharingInvitationSpecificsDefaultTypeInternal
    _OutgoingPasswordSharingInvitationSpecifics_default_instance_;
PROTOBUF_CONSTEXPR OutgoingPasswordSharingInvitationCommitError::OutgoingPasswordSharingInvitationCommitError(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.error_code_)*/ 0 }
{
}
struct OutgoingPasswordSharingInvitationCommitErrorDefaultTypeInternal {
    PROTOBUF_CONSTEXPR OutgoingPasswordSharingInvitationCommitErrorDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~OutgoingPasswordSharingInvitationCommitErrorDefaultTypeInternal()
    {
    }
    union {
        OutgoingPasswordSharingInvitationCommitError _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OutgoingPasswordSharingInvitationCommitErrorDefaultTypeInternal
    _OutgoingPasswordSharingInvitationCommitError_default_instance_;
} // namespace sync_pb
namespace sync_pb {
bool OutgoingPasswordSharingInvitationCommitError_ErrorCode_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> OutgoingPasswordSharingInvitationCommitError_ErrorCode_strings[3] = {};

static const char OutgoingPasswordSharingInvitationCommitError_ErrorCode_names[] = "NOT_FAMILY_MEMBER"
                                                                                   "PUBLIC_KEY_VERSION_MISMATCH"
                                                                                   "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry OutgoingPasswordSharingInvitationCommitError_ErrorCode_entries[] = {
    { { OutgoingPasswordSharingInvitationCommitError_ErrorCode_names + 0, 17 }, 2 },
    { { OutgoingPasswordSharingInvitationCommitError_ErrorCode_names + 17, 27 }, 1 },
    { { OutgoingPasswordSharingInvitationCommitError_ErrorCode_names + 44, 7 }, 0 },
};

static const int OutgoingPasswordSharingInvitationCommitError_ErrorCode_entries_by_number[] = {
    2, // 0 -> UNKNOWN
    1, // 1 -> PUBLIC_KEY_VERSION_MISMATCH
    0, // 2 -> NOT_FAMILY_MEMBER
};

const std::string& OutgoingPasswordSharingInvitationCommitError_ErrorCode_Name(OutgoingPasswordSharingInvitationCommitError_ErrorCode value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(OutgoingPasswordSharingInvitationCommitError_ErrorCode_entries,
        OutgoingPasswordSharingInvitationCommitError_ErrorCode_entries_by_number, 3, OutgoingPasswordSharingInvitationCommitError_ErrorCode_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        OutgoingPasswordSharingInvitationCommitError_ErrorCode_entries, OutgoingPasswordSharingInvitationCommitError_ErrorCode_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : OutgoingPasswordSharingInvitationCommitError_ErrorCode_strings[idx].get();
}
bool OutgoingPasswordSharingInvitationCommitError_ErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OutgoingPasswordSharingInvitationCommitError_ErrorCode* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(OutgoingPasswordSharingInvitationCommitError_ErrorCode_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<OutgoingPasswordSharingInvitationCommitError_ErrorCode>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr OutgoingPasswordSharingInvitationCommitError_ErrorCode OutgoingPasswordSharingInvitationCommitError::UNKNOWN;
constexpr OutgoingPasswordSharingInvitationCommitError_ErrorCode OutgoingPasswordSharingInvitationCommitError::PUBLIC_KEY_VERSION_MISMATCH;
constexpr OutgoingPasswordSharingInvitationCommitError_ErrorCode OutgoingPasswordSharingInvitationCommitError::NOT_FAMILY_MEMBER;
constexpr OutgoingPasswordSharingInvitationCommitError_ErrorCode OutgoingPasswordSharingInvitationCommitError::ErrorCode_MIN;
constexpr OutgoingPasswordSharingInvitationCommitError_ErrorCode OutgoingPasswordSharingInvitationCommitError::ErrorCode_MAX;
constexpr int OutgoingPasswordSharingInvitationCommitError::ErrorCode_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class PasswordSharingInvitationData_PasswordGroupElementData::_Internal {
public:
    using HasBits = decltype(std::declval<PasswordSharingInvitationData_PasswordGroupElementData>()._impl_._has_bits_);
    static void set_has_scheme(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_signon_realm(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_origin(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_username_element(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_password_element(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_display_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_avatar_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
};

PasswordSharingInvitationData_PasswordGroupElementData::PasswordSharingInvitationData_PasswordGroupElementData(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSharingInvitationData.PasswordGroupElementData)
}
PasswordSharingInvitationData_PasswordGroupElementData::PasswordSharingInvitationData_PasswordGroupElementData(
    const PasswordSharingInvitationData_PasswordGroupElementData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PasswordSharingInvitationData_PasswordGroupElementData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.signon_realm_) {},
        decltype(_impl_.origin_) {}, decltype(_impl_.username_element_) {}, decltype(_impl_.password_element_) {}, decltype(_impl_.display_name_) {},
        decltype(_impl_.avatar_url_) {}, decltype(_impl_.scheme_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.signon_realm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signon_realm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_signon_realm()) {
        _this->_impl_.signon_realm_.Set(from._internal_signon_realm(), _this->GetArenaForAllocation());
    }
    _impl_.origin_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_origin()) {
        _this->_impl_.origin_.Set(from._internal_origin(), _this->GetArenaForAllocation());
    }
    _impl_.username_element_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_element_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_username_element()) {
        _this->_impl_.username_element_.Set(from._internal_username_element(), _this->GetArenaForAllocation());
    }
    _impl_.password_element_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_element_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_password_element()) {
        _this->_impl_.password_element_.Set(from._internal_password_element(), _this->GetArenaForAllocation());
    }
    _impl_.display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_display_name()) {
        _this->_impl_.display_name_.Set(from._internal_display_name(), _this->GetArenaForAllocation());
    }
    _impl_.avatar_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_avatar_url()) {
        _this->_impl_.avatar_url_.Set(from._internal_avatar_url(), _this->GetArenaForAllocation());
    }
    _this->_impl_.scheme_ = from._impl_.scheme_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSharingInvitationData.PasswordGroupElementData)
}

inline void PasswordSharingInvitationData_PasswordGroupElementData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.signon_realm_) {}, decltype(_impl_.origin_) {},
        decltype(_impl_.username_element_) {}, decltype(_impl_.password_element_) {}, decltype(_impl_.display_name_) {}, decltype(_impl_.avatar_url_) {},
        decltype(_impl_.scheme_) { 0 } };
    _impl_.signon_realm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signon_realm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_element_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_element_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_element_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_element_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PasswordSharingInvitationData_PasswordGroupElementData::~PasswordSharingInvitationData_PasswordGroupElementData()
{
    // @@protoc_insertion_point(destructor:sync_pb.PasswordSharingInvitationData.PasswordGroupElementData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PasswordSharingInvitationData_PasswordGroupElementData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.signon_realm_.Destroy();
    _impl_.origin_.Destroy();
    _impl_.username_element_.Destroy();
    _impl_.password_element_.Destroy();
    _impl_.display_name_.Destroy();
    _impl_.avatar_url_.Destroy();
}

void PasswordSharingInvitationData_PasswordGroupElementData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PasswordSharingInvitationData_PasswordGroupElementData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSharingInvitationData.PasswordGroupElementData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.signon_realm_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.origin_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.username_element_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.password_element_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.display_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.avatar_url_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.scheme_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PasswordSharingInvitationData_PasswordGroupElementData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 scheme = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_scheme(&has_bits);
                _impl_.scheme_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string signon_realm = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_signon_realm();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string origin = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_origin();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string username_element = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_username_element();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string password_element = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_password_element();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string display_name = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_display_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string avatar_url = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                auto str = _internal_mutable_avatar_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PasswordSharingInvitationData_PasswordGroupElementData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSharingInvitationData.PasswordGroupElementData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 scheme = 2;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_scheme(), target);
    }

    // optional string signon_realm = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_signon_realm(), target);
    }

    // optional string origin = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_origin(), target);
    }

    // optional string username_element = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_username_element(), target);
    }

    // optional string password_element = 7;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_password_element(), target);
    }

    // optional string display_name = 8;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_display_name(), target);
    }

    // optional string avatar_url = 9;
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteStringMaybeAliased(9, this->_internal_avatar_url(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSharingInvitationData.PasswordGroupElementData)
    return target;
}

size_t PasswordSharingInvitationData_PasswordGroupElementData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSharingInvitationData.PasswordGroupElementData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        // optional string signon_realm = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_signon_realm());
        }

        // optional string origin = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_origin());
        }

        // optional string username_element = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_username_element());
        }

        // optional string password_element = 7;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_password_element());
        }

        // optional string display_name = 8;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_display_name());
        }

        // optional string avatar_url = 9;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_avatar_url());
        }

        // optional int32 scheme = 2;
        if (cached_has_bits & 0x00000040u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_scheme());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PasswordSharingInvitationData_PasswordGroupElementData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PasswordSharingInvitationData_PasswordGroupElementData*>(&from));
}

void PasswordSharingInvitationData_PasswordGroupElementData::MergeFrom(const PasswordSharingInvitationData_PasswordGroupElementData& from)
{
    PasswordSharingInvitationData_PasswordGroupElementData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSharingInvitationData.PasswordGroupElementData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_signon_realm(from._internal_signon_realm());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_origin(from._internal_origin());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_username_element(from._internal_username_element());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_password_element(from._internal_password_element());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_display_name(from._internal_display_name());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_avatar_url(from._internal_avatar_url());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.scheme_ = from._impl_.scheme_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSharingInvitationData_PasswordGroupElementData::CopyFrom(const PasswordSharingInvitationData_PasswordGroupElementData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSharingInvitationData.PasswordGroupElementData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PasswordSharingInvitationData_PasswordGroupElementData::IsInitialized() const
{
    return true;
}

void PasswordSharingInvitationData_PasswordGroupElementData::InternalSwap(PasswordSharingInvitationData_PasswordGroupElementData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.signon_realm_, lhs_arena, &other->_impl_.signon_realm_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.origin_, lhs_arena, &other->_impl_.origin_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.username_element_, lhs_arena, &other->_impl_.username_element_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.password_element_, lhs_arena, &other->_impl_.password_element_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.display_name_, lhs_arena, &other->_impl_.display_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.avatar_url_, lhs_arena, &other->_impl_.avatar_url_, rhs_arena);
    swap(_impl_.scheme_, other->_impl_.scheme_);
}

std::string PasswordSharingInvitationData_PasswordGroupElementData::GetTypeName() const
{
    return "sync_pb.PasswordSharingInvitationData.PasswordGroupElementData";
}

// ===================================================================

class PasswordSharingInvitationData_PasswordGroupData::_Internal {
public:
    using HasBits = decltype(std::declval<PasswordSharingInvitationData_PasswordGroupData>()._impl_._has_bits_);
    static void set_has_username_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_password_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

PasswordSharingInvitationData_PasswordGroupData::PasswordSharingInvitationData_PasswordGroupData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSharingInvitationData.PasswordGroupData)
}
PasswordSharingInvitationData_PasswordGroupData::PasswordSharingInvitationData_PasswordGroupData(const PasswordSharingInvitationData_PasswordGroupData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PasswordSharingInvitationData_PasswordGroupData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.element_data_) { from._impl_.element_data_ }, decltype(_impl_.username_value_) {}, decltype(_impl_.password_value_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.username_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_username_value()) {
        _this->_impl_.username_value_.Set(from._internal_username_value(), _this->GetArenaForAllocation());
    }
    _impl_.password_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_password_value()) {
        _this->_impl_.password_value_.Set(from._internal_password_value(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSharingInvitationData.PasswordGroupData)
}

inline void PasswordSharingInvitationData_PasswordGroupData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.element_data_) { arena },
        decltype(_impl_.username_value_) {}, decltype(_impl_.password_value_) {} };
    _impl_.username_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PasswordSharingInvitationData_PasswordGroupData::~PasswordSharingInvitationData_PasswordGroupData()
{
    // @@protoc_insertion_point(destructor:sync_pb.PasswordSharingInvitationData.PasswordGroupData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PasswordSharingInvitationData_PasswordGroupData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.element_data_.~RepeatedPtrField();
    _impl_.username_value_.Destroy();
    _impl_.password_value_.Destroy();
}

void PasswordSharingInvitationData_PasswordGroupData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PasswordSharingInvitationData_PasswordGroupData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSharingInvitationData.PasswordGroupData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.element_data_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.username_value_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.password_value_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PasswordSharingInvitationData_PasswordGroupData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string username_value = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_username_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string password_value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_password_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.PasswordSharingInvitationData.PasswordGroupElementData element_data = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_element_data(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PasswordSharingInvitationData_PasswordGroupData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSharingInvitationData.PasswordGroupData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string username_value = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_username_value(), target);
    }

    // optional string password_value = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_password_value(), target);
    }

    // repeated .sync_pb.PasswordSharingInvitationData.PasswordGroupElementData element_data = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_element_data_size()); i < n; i++) {
        const auto& repfield = this->_internal_element_data(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSharingInvitationData.PasswordGroupData)
    return target;
}

size_t PasswordSharingInvitationData_PasswordGroupData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSharingInvitationData.PasswordGroupData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.PasswordSharingInvitationData.PasswordGroupElementData element_data = 3;
    total_size += 1UL * this->_internal_element_data_size();
    for (const auto& msg : this->_impl_.element_data_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string username_value = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_username_value());
        }

        // optional string password_value = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_password_value());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PasswordSharingInvitationData_PasswordGroupData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PasswordSharingInvitationData_PasswordGroupData*>(&from));
}

void PasswordSharingInvitationData_PasswordGroupData::MergeFrom(const PasswordSharingInvitationData_PasswordGroupData& from)
{
    PasswordSharingInvitationData_PasswordGroupData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSharingInvitationData.PasswordGroupData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.element_data_.MergeFrom(from._impl_.element_data_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_username_value(from._internal_username_value());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_password_value(from._internal_password_value());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSharingInvitationData_PasswordGroupData::CopyFrom(const PasswordSharingInvitationData_PasswordGroupData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSharingInvitationData.PasswordGroupData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PasswordSharingInvitationData_PasswordGroupData::IsInitialized() const
{
    return true;
}

void PasswordSharingInvitationData_PasswordGroupData::InternalSwap(PasswordSharingInvitationData_PasswordGroupData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.element_data_.InternalSwap(&other->_impl_.element_data_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.username_value_, lhs_arena, &other->_impl_.username_value_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.password_value_, lhs_arena, &other->_impl_.password_value_, rhs_arena);
}

std::string PasswordSharingInvitationData_PasswordGroupData::GetTypeName() const
{
    return "sync_pb.PasswordSharingInvitationData.PasswordGroupData";
}

// ===================================================================

class PasswordSharingInvitationData::_Internal {
public:
    using HasBits = decltype(std::declval<PasswordSharingInvitationData>()._impl_._has_bits_);
    static const ::sync_pb::PasswordSharingInvitationData_PasswordGroupData& password_group_data(const PasswordSharingInvitationData* msg);
    static void set_has_password_group_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::sync_pb::PasswordSharingInvitationData_PasswordGroupData& PasswordSharingInvitationData::_Internal::password_group_data(
    const PasswordSharingInvitationData* msg)
{
    return *msg->_impl_.password_group_data_;
}
PasswordSharingInvitationData::PasswordSharingInvitationData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSharingInvitationData)
}
PasswordSharingInvitationData::PasswordSharingInvitationData(const PasswordSharingInvitationData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PasswordSharingInvitationData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.password_group_data_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_password_group_data()) {
        _this->_impl_.password_group_data_ = new ::sync_pb::PasswordSharingInvitationData_PasswordGroupData(*from._impl_.password_group_data_);
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSharingInvitationData)
}

inline void PasswordSharingInvitationData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.password_group_data_) { nullptr } };
}

PasswordSharingInvitationData::~PasswordSharingInvitationData()
{
    // @@protoc_insertion_point(destructor:sync_pb.PasswordSharingInvitationData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PasswordSharingInvitationData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.password_group_data_;
}

void PasswordSharingInvitationData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PasswordSharingInvitationData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSharingInvitationData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.password_group_data_ != nullptr);
        _impl_.password_group_data_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PasswordSharingInvitationData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.PasswordSharingInvitationData.PasswordGroupData password_group_data = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_password_group_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PasswordSharingInvitationData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSharingInvitationData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.PasswordSharingInvitationData.PasswordGroupData password_group_data = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::password_group_data(this), _Internal::password_group_data(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSharingInvitationData)
    return target;
}

size_t PasswordSharingInvitationData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSharingInvitationData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .sync_pb.PasswordSharingInvitationData.PasswordGroupData password_group_data = 2;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.password_group_data_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PasswordSharingInvitationData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PasswordSharingInvitationData*>(&from));
}

void PasswordSharingInvitationData::MergeFrom(const PasswordSharingInvitationData& from)
{
    PasswordSharingInvitationData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSharingInvitationData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_password_group_data()) {
        _this->_internal_mutable_password_group_data()->::sync_pb::PasswordSharingInvitationData_PasswordGroupData::MergeFrom(
            from._internal_password_group_data());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSharingInvitationData::CopyFrom(const PasswordSharingInvitationData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSharingInvitationData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PasswordSharingInvitationData::IsInitialized() const
{
    return true;
}

void PasswordSharingInvitationData::InternalSwap(PasswordSharingInvitationData* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.password_group_data_, other->_impl_.password_group_data_);
}

std::string PasswordSharingInvitationData::GetTypeName() const
{
    return "sync_pb.PasswordSharingInvitationData";
}

// ===================================================================

class UserDisplayInfo::_Internal {
public:
    using HasBits = decltype(std::declval<UserDisplayInfo>()._impl_._has_bits_);
    static void set_has_email(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_display_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_profile_image_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

UserDisplayInfo::UserDisplayInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserDisplayInfo)
}
UserDisplayInfo::UserDisplayInfo(const UserDisplayInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserDisplayInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.email_) {},
        decltype(_impl_.display_name_) {}, decltype(_impl_.profile_image_url_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_email()) {
        _this->_impl_.email_.Set(from._internal_email(), _this->GetArenaForAllocation());
    }
    _impl_.display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_display_name()) {
        _this->_impl_.display_name_.Set(from._internal_display_name(), _this->GetArenaForAllocation());
    }
    _impl_.profile_image_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_image_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_profile_image_url()) {
        _this->_impl_.profile_image_url_.Set(from._internal_profile_image_url(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserDisplayInfo)
}

inline void UserDisplayInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.email_) {}, decltype(_impl_.display_name_) {},
        decltype(_impl_.profile_image_url_) {} };
    _impl_.email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_image_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_image_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserDisplayInfo::~UserDisplayInfo()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserDisplayInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserDisplayInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.email_.Destroy();
    _impl_.display_name_.Destroy();
    _impl_.profile_image_url_.Destroy();
}

void UserDisplayInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserDisplayInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserDisplayInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.email_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.display_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.profile_image_url_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserDisplayInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string email = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_email();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string display_name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_display_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string profile_image_url = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_profile_image_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserDisplayInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserDisplayInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string email = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_email(), target);
    }

    // optional string display_name = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_display_name(), target);
    }

    // optional string profile_image_url = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_profile_image_url(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserDisplayInfo)
    return target;
}

size_t UserDisplayInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserDisplayInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string email = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_email());
        }

        // optional string display_name = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_display_name());
        }

        // optional string profile_image_url = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_profile_image_url());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserDisplayInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserDisplayInfo*>(&from));
}

void UserDisplayInfo::MergeFrom(const UserDisplayInfo& from)
{
    UserDisplayInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserDisplayInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_email(from._internal_email());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_display_name(from._internal_display_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_profile_image_url(from._internal_profile_image_url());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserDisplayInfo::CopyFrom(const UserDisplayInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserDisplayInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserDisplayInfo::IsInitialized() const
{
    return true;
}

void UserDisplayInfo::InternalSwap(UserDisplayInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.email_, lhs_arena, &other->_impl_.email_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.display_name_, lhs_arena, &other->_impl_.display_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.profile_image_url_, lhs_arena, &other->_impl_.profile_image_url_, rhs_arena);
}

std::string UserDisplayInfo::GetTypeName() const
{
    return "sync_pb.UserDisplayInfo";
}

// ===================================================================

class UserInfo::_Internal {
public:
    using HasBits = decltype(std::declval<UserInfo>()._impl_._has_bits_);
    static void set_has_user_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::sync_pb::UserDisplayInfo& user_display_info(const UserInfo* msg);
    static void set_has_user_display_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::sync_pb::CrossUserSharingPublicKey& cross_user_sharing_public_key(const UserInfo* msg);
    static void set_has_cross_user_sharing_public_key(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::sync_pb::UserDisplayInfo& UserInfo::_Internal::user_display_info(const UserInfo* msg)
{
    return *msg->_impl_.user_display_info_;
}
const ::sync_pb::CrossUserSharingPublicKey& UserInfo::_Internal::cross_user_sharing_public_key(const UserInfo* msg)
{
    return *msg->_impl_.cross_user_sharing_public_key_;
}
void UserInfo::clear_cross_user_sharing_public_key()
{
    if (_impl_.cross_user_sharing_public_key_ != nullptr)
        _impl_.cross_user_sharing_public_key_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
UserInfo::UserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserInfo)
}
UserInfo::UserInfo(const UserInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.user_id_) {},
        decltype(_impl_.user_display_info_) { nullptr }, decltype(_impl_.cross_user_sharing_public_key_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_user_id()) {
        _this->_impl_.user_id_.Set(from._internal_user_id(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_user_display_info()) {
        _this->_impl_.user_display_info_ = new ::sync_pb::UserDisplayInfo(*from._impl_.user_display_info_);
    }
    if (from._internal_has_cross_user_sharing_public_key()) {
        _this->_impl_.cross_user_sharing_public_key_ = new ::sync_pb::CrossUserSharingPublicKey(*from._impl_.cross_user_sharing_public_key_);
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserInfo)
}

inline void UserInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.user_id_) {},
        decltype(_impl_.user_display_info_) { nullptr }, decltype(_impl_.cross_user_sharing_public_key_) { nullptr } };
    _impl_.user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserInfo::~UserInfo()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.user_id_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.user_display_info_;
    if (this != internal_default_instance())
        delete _impl_.cross_user_sharing_public_key_;
}

void UserInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.user_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.user_display_info_ != nullptr);
            _impl_.user_display_info_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.cross_user_sharing_public_key_ != nullptr);
            _impl_.cross_user_sharing_public_key_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string user_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_user_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.UserDisplayInfo user_display_info = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_user_display_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.CrossUserSharingPublicKey cross_user_sharing_public_key = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_cross_user_sharing_public_key(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string user_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_user_id(), target);
    }

    // optional .sync_pb.UserDisplayInfo user_display_info = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::user_display_info(this), _Internal::user_display_info(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.CrossUserSharingPublicKey cross_user_sharing_public_key = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::cross_user_sharing_public_key(this), _Internal::cross_user_sharing_public_key(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserInfo)
    return target;
}

size_t UserInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string user_id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_user_id());
        }

        // optional .sync_pb.UserDisplayInfo user_display_info = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.user_display_info_);
        }

        // optional .sync_pb.CrossUserSharingPublicKey cross_user_sharing_public_key = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.cross_user_sharing_public_key_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserInfo*>(&from));
}

void UserInfo::MergeFrom(const UserInfo& from)
{
    UserInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_user_id(from._internal_user_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_user_display_info()->::sync_pb::UserDisplayInfo::MergeFrom(from._internal_user_display_info());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_cross_user_sharing_public_key()->::sync_pb::CrossUserSharingPublicKey::MergeFrom(
                from._internal_cross_user_sharing_public_key());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserInfo::CopyFrom(const UserInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserInfo::IsInitialized() const
{
    return true;
}

void UserInfo::InternalSwap(UserInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.user_id_, lhs_arena, &other->_impl_.user_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(UserInfo, _impl_.cross_user_sharing_public_key_)
        + sizeof(UserInfo::_impl_.cross_user_sharing_public_key_) - PROTOBUF_FIELD_OFFSET(UserInfo, _impl_.user_display_info_)>(
        reinterpret_cast<char*>(&_impl_.user_display_info_), reinterpret_cast<char*>(&other->_impl_.user_display_info_));
}

std::string UserInfo::GetTypeName() const
{
    return "sync_pb.UserInfo";
}

// ===================================================================

class IncomingPasswordSharingInvitationSpecifics::_Internal {
public:
    using HasBits = decltype(std::declval<IncomingPasswordSharingInvitationSpecifics>()._impl_._has_bits_);
    static void set_has_guid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::sync_pb::UserInfo& sender_info(const IncomingPasswordSharingInvitationSpecifics* msg);
    static void set_has_sender_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_encrypted_password_sharing_invitation_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::sync_pb::PasswordSharingInvitationData& client_only_unencrypted_data(const IncomingPasswordSharingInvitationSpecifics* msg);
    static void set_has_client_only_unencrypted_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_recipient_key_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

const ::sync_pb::UserInfo& IncomingPasswordSharingInvitationSpecifics::_Internal::sender_info(const IncomingPasswordSharingInvitationSpecifics* msg)
{
    return *msg->_impl_.sender_info_;
}
const ::sync_pb::PasswordSharingInvitationData& IncomingPasswordSharingInvitationSpecifics::_Internal::client_only_unencrypted_data(
    const IncomingPasswordSharingInvitationSpecifics* msg)
{
    return *msg->_impl_.client_only_unencrypted_data_;
}
IncomingPasswordSharingInvitationSpecifics::IncomingPasswordSharingInvitationSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.IncomingPasswordSharingInvitationSpecifics)
}
IncomingPasswordSharingInvitationSpecifics::IncomingPasswordSharingInvitationSpecifics(const IncomingPasswordSharingInvitationSpecifics& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    IncomingPasswordSharingInvitationSpecifics* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.guid_) {},
        decltype(_impl_.encrypted_password_sharing_invitation_data_) {}, decltype(_impl_.sender_info_) { nullptr },
        decltype(_impl_.client_only_unencrypted_data_) { nullptr }, decltype(_impl_.recipient_key_version_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_guid()) {
        _this->_impl_.guid_.Set(from._internal_guid(), _this->GetArenaForAllocation());
    }
    _impl_.encrypted_password_sharing_invitation_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encrypted_password_sharing_invitation_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_encrypted_password_sharing_invitation_data()) {
        _this->_impl_.encrypted_password_sharing_invitation_data_.Set(
            from._internal_encrypted_password_sharing_invitation_data(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_sender_info()) {
        _this->_impl_.sender_info_ = new ::sync_pb::UserInfo(*from._impl_.sender_info_);
    }
    if (from._internal_has_client_only_unencrypted_data()) {
        _this->_impl_.client_only_unencrypted_data_ = new ::sync_pb::PasswordSharingInvitationData(*from._impl_.client_only_unencrypted_data_);
    }
    _this->_impl_.recipient_key_version_ = from._impl_.recipient_key_version_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.IncomingPasswordSharingInvitationSpecifics)
}

inline void IncomingPasswordSharingInvitationSpecifics::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.guid_) {},
        decltype(_impl_.encrypted_password_sharing_invitation_data_) {}, decltype(_impl_.sender_info_) { nullptr },
        decltype(_impl_.client_only_unencrypted_data_) { nullptr }, decltype(_impl_.recipient_key_version_) { 0u } };
    _impl_.guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encrypted_password_sharing_invitation_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encrypted_password_sharing_invitation_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

IncomingPasswordSharingInvitationSpecifics::~IncomingPasswordSharingInvitationSpecifics()
{
    // @@protoc_insertion_point(destructor:sync_pb.IncomingPasswordSharingInvitationSpecifics)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void IncomingPasswordSharingInvitationSpecifics::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.guid_.Destroy();
    _impl_.encrypted_password_sharing_invitation_data_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.sender_info_;
    if (this != internal_default_instance())
        delete _impl_.client_only_unencrypted_data_;
}

void IncomingPasswordSharingInvitationSpecifics::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void IncomingPasswordSharingInvitationSpecifics::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.IncomingPasswordSharingInvitationSpecifics)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.guid_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.encrypted_password_sharing_invitation_data_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.sender_info_ != nullptr);
            _impl_.sender_info_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.client_only_unencrypted_data_ != nullptr);
            _impl_.client_only_unencrypted_data_->Clear();
        }
    }
    _impl_.recipient_key_version_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* IncomingPasswordSharingInvitationSpecifics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string guid = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_guid();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.UserInfo sender_info = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_sender_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes encrypted_password_sharing_invitation_data = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_encrypted_password_sharing_invitation_data();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.PasswordSharingInvitationData client_only_unencrypted_data = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_client_only_unencrypted_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 recipient_key_version = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_recipient_key_version(&has_bits);
                _impl_.recipient_key_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* IncomingPasswordSharingInvitationSpecifics::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.IncomingPasswordSharingInvitationSpecifics)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string guid = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_guid(), target);
    }

    // optional .sync_pb.UserInfo sender_info = 2;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::sender_info(this), _Internal::sender_info(this).GetCachedSize(), target, stream);
    }

    // optional bytes encrypted_password_sharing_invitation_data = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_encrypted_password_sharing_invitation_data(), target);
    }

    // optional .sync_pb.PasswordSharingInvitationData client_only_unencrypted_data = 4;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::client_only_unencrypted_data(this), _Internal::client_only_unencrypted_data(this).GetCachedSize(), target, stream);
    }

    // optional uint32 recipient_key_version = 6;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_recipient_key_version(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.IncomingPasswordSharingInvitationSpecifics)
    return target;
}

size_t IncomingPasswordSharingInvitationSpecifics::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.IncomingPasswordSharingInvitationSpecifics)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string guid = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_guid());
        }

        // optional bytes encrypted_password_sharing_invitation_data = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_encrypted_password_sharing_invitation_data());
        }

        // optional .sync_pb.UserInfo sender_info = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.sender_info_);
        }

        // optional .sync_pb.PasswordSharingInvitationData client_only_unencrypted_data = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.client_only_unencrypted_data_);
        }

        // optional uint32 recipient_key_version = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_recipient_key_version());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void IncomingPasswordSharingInvitationSpecifics::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const IncomingPasswordSharingInvitationSpecifics*>(&from));
}

void IncomingPasswordSharingInvitationSpecifics::MergeFrom(const IncomingPasswordSharingInvitationSpecifics& from)
{
    IncomingPasswordSharingInvitationSpecifics* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.IncomingPasswordSharingInvitationSpecifics)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_guid(from._internal_guid());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_encrypted_password_sharing_invitation_data(from._internal_encrypted_password_sharing_invitation_data());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_sender_info()->::sync_pb::UserInfo::MergeFrom(from._internal_sender_info());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_client_only_unencrypted_data()->::sync_pb::PasswordSharingInvitationData::MergeFrom(
                from._internal_client_only_unencrypted_data());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.recipient_key_version_ = from._impl_.recipient_key_version_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IncomingPasswordSharingInvitationSpecifics::CopyFrom(const IncomingPasswordSharingInvitationSpecifics& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.IncomingPasswordSharingInvitationSpecifics)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool IncomingPasswordSharingInvitationSpecifics::IsInitialized() const
{
    return true;
}

void IncomingPasswordSharingInvitationSpecifics::InternalSwap(IncomingPasswordSharingInvitationSpecifics* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.guid_, lhs_arena, &other->_impl_.guid_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.encrypted_password_sharing_invitation_data_, lhs_arena, &other->_impl_.encrypted_password_sharing_invitation_data_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(IncomingPasswordSharingInvitationSpecifics, _impl_.recipient_key_version_)
        + sizeof(IncomingPasswordSharingInvitationSpecifics::_impl_.recipient_key_version_)
        - PROTOBUF_FIELD_OFFSET(IncomingPasswordSharingInvitationSpecifics, _impl_.sender_info_)>(
        reinterpret_cast<char*>(&_impl_.sender_info_), reinterpret_cast<char*>(&other->_impl_.sender_info_));
}

std::string IncomingPasswordSharingInvitationSpecifics::GetTypeName() const
{
    return "sync_pb.IncomingPasswordSharingInvitationSpecifics";
}

// ===================================================================

class OutgoingPasswordSharingInvitationSpecifics::_Internal {
public:
    using HasBits = decltype(std::declval<OutgoingPasswordSharingInvitationSpecifics>()._impl_._has_bits_);
    static void set_has_guid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_recipient_user_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_encrypted_password_sharing_invitation_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::sync_pb::PasswordSharingInvitationData& client_only_unencrypted_data(const OutgoingPasswordSharingInvitationSpecifics* msg);
    static void set_has_client_only_unencrypted_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_recipient_key_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_sender_key_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
};

const ::sync_pb::PasswordSharingInvitationData& OutgoingPasswordSharingInvitationSpecifics::_Internal::client_only_unencrypted_data(
    const OutgoingPasswordSharingInvitationSpecifics* msg)
{
    return *msg->_impl_.client_only_unencrypted_data_;
}
OutgoingPasswordSharingInvitationSpecifics::OutgoingPasswordSharingInvitationSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.OutgoingPasswordSharingInvitationSpecifics)
}
OutgoingPasswordSharingInvitationSpecifics::OutgoingPasswordSharingInvitationSpecifics(const OutgoingPasswordSharingInvitationSpecifics& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    OutgoingPasswordSharingInvitationSpecifics* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.guid_) {},
        decltype(_impl_.recipient_user_id_) {}, decltype(_impl_.encrypted_password_sharing_invitation_data_) {},
        decltype(_impl_.client_only_unencrypted_data_) { nullptr }, decltype(_impl_.recipient_key_version_) {}, decltype(_impl_.sender_key_version_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_guid()) {
        _this->_impl_.guid_.Set(from._internal_guid(), _this->GetArenaForAllocation());
    }
    _impl_.recipient_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_recipient_user_id()) {
        _this->_impl_.recipient_user_id_.Set(from._internal_recipient_user_id(), _this->GetArenaForAllocation());
    }
    _impl_.encrypted_password_sharing_invitation_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encrypted_password_sharing_invitation_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_encrypted_password_sharing_invitation_data()) {
        _this->_impl_.encrypted_password_sharing_invitation_data_.Set(
            from._internal_encrypted_password_sharing_invitation_data(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_client_only_unencrypted_data()) {
        _this->_impl_.client_only_unencrypted_data_ = new ::sync_pb::PasswordSharingInvitationData(*from._impl_.client_only_unencrypted_data_);
    }
    ::memcpy(&_impl_.recipient_key_version_, &from._impl_.recipient_key_version_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sender_key_version_) - reinterpret_cast<char*>(&_impl_.recipient_key_version_))
            + sizeof(_impl_.sender_key_version_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.OutgoingPasswordSharingInvitationSpecifics)
}

inline void OutgoingPasswordSharingInvitationSpecifics::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.guid_) {}, decltype(_impl_.recipient_user_id_) {},
            decltype(_impl_.encrypted_password_sharing_invitation_data_) {}, decltype(_impl_.client_only_unencrypted_data_) { nullptr },
            decltype(_impl_.recipient_key_version_) { 0u }, decltype(_impl_.sender_key_version_) { 0u } };
    _impl_.guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_user_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_user_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encrypted_password_sharing_invitation_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.encrypted_password_sharing_invitation_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OutgoingPasswordSharingInvitationSpecifics::~OutgoingPasswordSharingInvitationSpecifics()
{
    // @@protoc_insertion_point(destructor:sync_pb.OutgoingPasswordSharingInvitationSpecifics)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void OutgoingPasswordSharingInvitationSpecifics::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.guid_.Destroy();
    _impl_.recipient_user_id_.Destroy();
    _impl_.encrypted_password_sharing_invitation_data_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.client_only_unencrypted_data_;
}

void OutgoingPasswordSharingInvitationSpecifics::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void OutgoingPasswordSharingInvitationSpecifics::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.OutgoingPasswordSharingInvitationSpecifics)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.guid_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.recipient_user_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.encrypted_password_sharing_invitation_data_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.client_only_unencrypted_data_ != nullptr);
            _impl_.client_only_unencrypted_data_->Clear();
        }
    }
    if (cached_has_bits & 0x00000030u) {
        ::memset(&_impl_.recipient_key_version_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sender_key_version_) - reinterpret_cast<char*>(&_impl_.recipient_key_version_))
                + sizeof(_impl_.sender_key_version_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* OutgoingPasswordSharingInvitationSpecifics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string guid = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_guid();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string recipient_user_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_recipient_user_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes encrypted_password_sharing_invitation_data = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_encrypted_password_sharing_invitation_data();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.PasswordSharingInvitationData client_only_unencrypted_data = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_client_only_unencrypted_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 recipient_key_version = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_recipient_key_version(&has_bits);
                _impl_.recipient_key_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 sender_key_version = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_sender_key_version(&has_bits);
                _impl_.sender_key_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* OutgoingPasswordSharingInvitationSpecifics::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.OutgoingPasswordSharingInvitationSpecifics)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string guid = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_guid(), target);
    }

    // optional string recipient_user_id = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_recipient_user_id(), target);
    }

    // optional bytes encrypted_password_sharing_invitation_data = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_encrypted_password_sharing_invitation_data(), target);
    }

    // optional .sync_pb.PasswordSharingInvitationData client_only_unencrypted_data = 4;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::client_only_unencrypted_data(this), _Internal::client_only_unencrypted_data(this).GetCachedSize(), target, stream);
    }

    // optional uint32 recipient_key_version = 6;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_recipient_key_version(), target);
    }

    // optional uint32 sender_key_version = 7;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_sender_key_version(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.OutgoingPasswordSharingInvitationSpecifics)
    return target;
}

size_t OutgoingPasswordSharingInvitationSpecifics::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.OutgoingPasswordSharingInvitationSpecifics)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional string guid = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_guid());
        }

        // optional string recipient_user_id = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_recipient_user_id());
        }

        // optional bytes encrypted_password_sharing_invitation_data = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_encrypted_password_sharing_invitation_data());
        }

        // optional .sync_pb.PasswordSharingInvitationData client_only_unencrypted_data = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.client_only_unencrypted_data_);
        }

        // optional uint32 recipient_key_version = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_recipient_key_version());
        }

        // optional uint32 sender_key_version = 7;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sender_key_version());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void OutgoingPasswordSharingInvitationSpecifics::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const OutgoingPasswordSharingInvitationSpecifics*>(&from));
}

void OutgoingPasswordSharingInvitationSpecifics::MergeFrom(const OutgoingPasswordSharingInvitationSpecifics& from)
{
    OutgoingPasswordSharingInvitationSpecifics* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.OutgoingPasswordSharingInvitationSpecifics)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_guid(from._internal_guid());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_recipient_user_id(from._internal_recipient_user_id());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_encrypted_password_sharing_invitation_data(from._internal_encrypted_password_sharing_invitation_data());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_client_only_unencrypted_data()->::sync_pb::PasswordSharingInvitationData::MergeFrom(
                from._internal_client_only_unencrypted_data());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.recipient_key_version_ = from._impl_.recipient_key_version_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.sender_key_version_ = from._impl_.sender_key_version_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OutgoingPasswordSharingInvitationSpecifics::CopyFrom(const OutgoingPasswordSharingInvitationSpecifics& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.OutgoingPasswordSharingInvitationSpecifics)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool OutgoingPasswordSharingInvitationSpecifics::IsInitialized() const
{
    return true;
}

void OutgoingPasswordSharingInvitationSpecifics::InternalSwap(OutgoingPasswordSharingInvitationSpecifics* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.guid_, lhs_arena, &other->_impl_.guid_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.recipient_user_id_, lhs_arena, &other->_impl_.recipient_user_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.encrypted_password_sharing_invitation_data_, lhs_arena, &other->_impl_.encrypted_password_sharing_invitation_data_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(OutgoingPasswordSharingInvitationSpecifics, _impl_.sender_key_version_)
        + sizeof(OutgoingPasswordSharingInvitationSpecifics::_impl_.sender_key_version_)
        - PROTOBUF_FIELD_OFFSET(OutgoingPasswordSharingInvitationSpecifics, _impl_.client_only_unencrypted_data_)>(
        reinterpret_cast<char*>(&_impl_.client_only_unencrypted_data_), reinterpret_cast<char*>(&other->_impl_.client_only_unencrypted_data_));
}

std::string OutgoingPasswordSharingInvitationSpecifics::GetTypeName() const
{
    return "sync_pb.OutgoingPasswordSharingInvitationSpecifics";
}

// ===================================================================

class OutgoingPasswordSharingInvitationCommitError::_Internal {
public:
    using HasBits = decltype(std::declval<OutgoingPasswordSharingInvitationCommitError>()._impl_._has_bits_);
    static void set_has_error_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

OutgoingPasswordSharingInvitationCommitError::OutgoingPasswordSharingInvitationCommitError(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.OutgoingPasswordSharingInvitationCommitError)
}
OutgoingPasswordSharingInvitationCommitError::OutgoingPasswordSharingInvitationCommitError(const OutgoingPasswordSharingInvitationCommitError& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    OutgoingPasswordSharingInvitationCommitError* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.error_code_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.error_code_ = from._impl_.error_code_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.OutgoingPasswordSharingInvitationCommitError)
}

inline void OutgoingPasswordSharingInvitationCommitError::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.error_code_) { 0 } };
}

OutgoingPasswordSharingInvitationCommitError::~OutgoingPasswordSharingInvitationCommitError()
{
    // @@protoc_insertion_point(destructor:sync_pb.OutgoingPasswordSharingInvitationCommitError)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void OutgoingPasswordSharingInvitationCommitError::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void OutgoingPasswordSharingInvitationCommitError::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void OutgoingPasswordSharingInvitationCommitError::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.OutgoingPasswordSharingInvitationCommitError)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.error_code_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* OutgoingPasswordSharingInvitationCommitError::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.OutgoingPasswordSharingInvitationCommitError.ErrorCode error_code = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::OutgoingPasswordSharingInvitationCommitError_ErrorCode_IsValid(val))) {
                    _internal_set_error_code(static_cast<::sync_pb::OutgoingPasswordSharingInvitationCommitError_ErrorCode>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* OutgoingPasswordSharingInvitationCommitError::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.OutgoingPasswordSharingInvitationCommitError)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.OutgoingPasswordSharingInvitationCommitError.ErrorCode error_code = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_error_code(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.OutgoingPasswordSharingInvitationCommitError)
    return target;
}

size_t OutgoingPasswordSharingInvitationCommitError::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.OutgoingPasswordSharingInvitationCommitError)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .sync_pb.OutgoingPasswordSharingInvitationCommitError.ErrorCode error_code = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_error_code());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void OutgoingPasswordSharingInvitationCommitError::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const OutgoingPasswordSharingInvitationCommitError*>(&from));
}

void OutgoingPasswordSharingInvitationCommitError::MergeFrom(const OutgoingPasswordSharingInvitationCommitError& from)
{
    OutgoingPasswordSharingInvitationCommitError* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.OutgoingPasswordSharingInvitationCommitError)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_error_code()) {
        _this->_internal_set_error_code(from._internal_error_code());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OutgoingPasswordSharingInvitationCommitError::CopyFrom(const OutgoingPasswordSharingInvitationCommitError& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.OutgoingPasswordSharingInvitationCommitError)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool OutgoingPasswordSharingInvitationCommitError::IsInitialized() const
{
    return true;
}

void OutgoingPasswordSharingInvitationCommitError::InternalSwap(OutgoingPasswordSharingInvitationCommitError* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.error_code_, other->_impl_.error_code_);
}

std::string OutgoingPasswordSharingInvitationCommitError::GetTypeName() const
{
    return "sync_pb.OutgoingPasswordSharingInvitationCommitError";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template <>
PROTOBUF_NOINLINE ::sync_pb::PasswordSharingInvitationData_PasswordGroupElementData*
Arena::CreateMaybeMessage<::sync_pb::PasswordSharingInvitationData_PasswordGroupElementData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::PasswordSharingInvitationData_PasswordGroupElementData>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::PasswordSharingInvitationData_PasswordGroupData*
Arena::CreateMaybeMessage<::sync_pb::PasswordSharingInvitationData_PasswordGroupData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::PasswordSharingInvitationData_PasswordGroupData>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::PasswordSharingInvitationData* Arena::CreateMaybeMessage<::sync_pb::PasswordSharingInvitationData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::PasswordSharingInvitationData>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::UserDisplayInfo* Arena::CreateMaybeMessage<::sync_pb::UserDisplayInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserDisplayInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::UserInfo* Arena::CreateMaybeMessage<::sync_pb::UserInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserInfo>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::IncomingPasswordSharingInvitationSpecifics* Arena::CreateMaybeMessage<::sync_pb::IncomingPasswordSharingInvitationSpecifics>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::IncomingPasswordSharingInvitationSpecifics>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::OutgoingPasswordSharingInvitationSpecifics* Arena::CreateMaybeMessage<::sync_pb::OutgoingPasswordSharingInvitationSpecifics>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::OutgoingPasswordSharingInvitationSpecifics>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::OutgoingPasswordSharingInvitationCommitError* Arena::CreateMaybeMessage<::sync_pb::OutgoingPasswordSharingInvitationCommitError>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::OutgoingPasswordSharingInvitationCommitError>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
