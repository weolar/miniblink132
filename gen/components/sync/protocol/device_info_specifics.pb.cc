// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/device_info_specifics.proto

#include "components/sync/protocol/device_info_specifics.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sync_pb {
PROTOBUF_CONSTEXPR DeviceInfoSpecifics::DeviceInfoSpecifics(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.cache_guid_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.client_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sync_user_agent_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.chrome_version_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.signin_scoped_device_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.model_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.manufacturer_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.full_hardware_class_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.feature_fields_)*/ nullptr, /*decltype(_impl_.sharing_fields_)*/ nullptr, /*decltype(_impl_.invalidation_fields_)*/ nullptr,
        /*decltype(_impl_.paask_fields_)*/ nullptr, /*decltype(_impl_.deprecated_backup_timestamp_)*/ int64_t { 0 },
        /*decltype(_impl_.last_updated_timestamp_)*/ int64_t { 0 }, /*decltype(_impl_.device_type_)*/ 0, /*decltype(_impl_.pulse_interval_in_minutes_)*/ 0,
        /*decltype(_impl_.os_type_)*/ 0, /*decltype(_impl_.device_form_factor_)*/ 0, /*decltype(_impl_.client_version_info_)*/ {},
        /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct DeviceInfoSpecificsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DeviceInfoSpecificsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DeviceInfoSpecificsDefaultTypeInternal()
    {
    }
    union {
        DeviceInfoSpecifics _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceInfoSpecificsDefaultTypeInternal
    _DeviceInfoSpecifics_default_instance_;
PROTOBUF_CONSTEXPR FeatureSpecificFields::FeatureSpecificFields(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.send_tab_to_self_receiving_enabled_)*/ false,
        /*decltype(_impl_.send_tab_to_self_receiving_type_)*/ 0, /*decltype(_impl_.floating_workspace_last_signin_time_windows_epoch_micros_)*/ int64_t { 0 } }
{
}
struct FeatureSpecificFieldsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FeatureSpecificFieldsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FeatureSpecificFieldsDefaultTypeInternal()
    {
    }
    union {
        FeatureSpecificFields _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeatureSpecificFieldsDefaultTypeInternal
    _FeatureSpecificFields_default_instance_;
PROTOBUF_CONSTEXPR SharingSpecificFields::SharingSpecificFields(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.enabled_features_)*/ {},
        /*decltype(_impl_.vapid_fcm_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.vapid_p256dh_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.vapid_auth_secret_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sender_id_fcm_token_deprecated_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sender_id_p256dh_deprecated_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sender_id_auth_secret_deprecated_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sender_id_fcm_token_v2_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sender_id_p256dh_v2_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sender_id_auth_secret_v2_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.chime_representative_target_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct SharingSpecificFieldsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SharingSpecificFieldsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SharingSpecificFieldsDefaultTypeInternal()
    {
    }
    union {
        SharingSpecificFields _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SharingSpecificFieldsDefaultTypeInternal
    _SharingSpecificFields_default_instance_;
PROTOBUF_CONSTEXPR InvalidationSpecificFields::InvalidationSpecificFields(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.interested_data_type_ids_)*/ {},
        /*decltype(_impl_.instance_id_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct InvalidationSpecificFieldsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR InvalidationSpecificFieldsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~InvalidationSpecificFieldsDefaultTypeInternal()
    {
    }
    union {
        InvalidationSpecificFields _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InvalidationSpecificFieldsDefaultTypeInternal
    _InvalidationSpecificFields_default_instance_;
PROTOBUF_CONSTEXPR PhoneAsASecurityKeySpecificFields::PhoneAsASecurityKeySpecificFields(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.contact_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.secret_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.peer_public_key_x962_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.google_credential_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.tunnel_server_domain_)*/ 0u, /*decltype(_impl_.id_)*/ 0u }
{
}
struct PhoneAsASecurityKeySpecificFieldsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PhoneAsASecurityKeySpecificFieldsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PhoneAsASecurityKeySpecificFieldsDefaultTypeInternal()
    {
    }
    union {
        PhoneAsASecurityKeySpecificFields _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PhoneAsASecurityKeySpecificFieldsDefaultTypeInternal
    _PhoneAsASecurityKeySpecificFields_default_instance_;
PROTOBUF_CONSTEXPR ChromeVersionInfo::ChromeVersionInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.version_number_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ChromeVersionInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ChromeVersionInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ChromeVersionInfoDefaultTypeInternal()
    {
    }
    union {
        ChromeVersionInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeVersionInfoDefaultTypeInternal _ChromeVersionInfo_default_instance_;
PROTOBUF_CONSTEXPR GooglePlayServicesVersionInfo::GooglePlayServicesVersionInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.apk_version_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct GooglePlayServicesVersionInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GooglePlayServicesVersionInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GooglePlayServicesVersionInfoDefaultTypeInternal()
    {
    }
    union {
        GooglePlayServicesVersionInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GooglePlayServicesVersionInfoDefaultTypeInternal
    _GooglePlayServicesVersionInfo_default_instance_;
} // namespace sync_pb
namespace sync_pb {
bool SharingSpecificFields_EnabledFeatures_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
    case 7:
    case 8:
    case 9:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SharingSpecificFields_EnabledFeatures_strings[9] = {};

static const char SharingSpecificFields_EnabledFeatures_names[] = "CLICK_TO_CALL_V2"
                                                                  "CLICK_TO_CALL_VAPID"
                                                                  "DISCOVERY"
                                                                  "OPTIMIZATION_GUIDE_PUSH_NOTIFICATION"
                                                                  "REMOTE_COPY"
                                                                  "SHARED_CLIPBOARD_V2"
                                                                  "SHARED_CLIPBOARD_VAPID"
                                                                  "SMS_FETCHER"
                                                                  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SharingSpecificFields_EnabledFeatures_entries[] = {
    { { SharingSpecificFields_EnabledFeatures_names + 0, 16 }, 7 },
    { { SharingSpecificFields_EnabledFeatures_names + 16, 19 }, 1 },
    { { SharingSpecificFields_EnabledFeatures_names + 35, 9 }, 6 },
    { { SharingSpecificFields_EnabledFeatures_names + 44, 36 }, 9 },
    { { SharingSpecificFields_EnabledFeatures_names + 80, 11 }, 4 },
    { { SharingSpecificFields_EnabledFeatures_names + 91, 19 }, 8 },
    { { SharingSpecificFields_EnabledFeatures_names + 110, 22 }, 2 },
    { { SharingSpecificFields_EnabledFeatures_names + 132, 11 }, 3 },
    { { SharingSpecificFields_EnabledFeatures_names + 143, 7 }, 0 },
};

static const int SharingSpecificFields_EnabledFeatures_entries_by_number[] = {
    8, // 0 -> UNKNOWN
    1, // 1 -> CLICK_TO_CALL_VAPID
    6, // 2 -> SHARED_CLIPBOARD_VAPID
    7, // 3 -> SMS_FETCHER
    4, // 4 -> REMOTE_COPY
    2, // 6 -> DISCOVERY
    0, // 7 -> CLICK_TO_CALL_V2
    5, // 8 -> SHARED_CLIPBOARD_V2
    3, // 9 -> OPTIMIZATION_GUIDE_PUSH_NOTIFICATION
};

const std::string& SharingSpecificFields_EnabledFeatures_Name(SharingSpecificFields_EnabledFeatures value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(SharingSpecificFields_EnabledFeatures_entries,
        SharingSpecificFields_EnabledFeatures_entries_by_number, 9, SharingSpecificFields_EnabledFeatures_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        SharingSpecificFields_EnabledFeatures_entries, SharingSpecificFields_EnabledFeatures_entries_by_number, 9, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : SharingSpecificFields_EnabledFeatures_strings[idx].get();
}
bool SharingSpecificFields_EnabledFeatures_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SharingSpecificFields_EnabledFeatures* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(SharingSpecificFields_EnabledFeatures_entries, 9, name, &int_value);
    if (success) {
        *value = static_cast<SharingSpecificFields_EnabledFeatures>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields::UNKNOWN;
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields::CLICK_TO_CALL_VAPID;
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields::SHARED_CLIPBOARD_VAPID;
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields::SMS_FETCHER;
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields::REMOTE_COPY;
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields::DISCOVERY;
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields::CLICK_TO_CALL_V2;
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields::SHARED_CLIPBOARD_V2;
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields::OPTIMIZATION_GUIDE_PUSH_NOTIFICATION;
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields::EnabledFeatures_MIN;
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields::EnabledFeatures_MAX;
constexpr int SharingSpecificFields::EnabledFeatures_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class DeviceInfoSpecifics::_Internal {
public:
    using HasBits = decltype(std::declval<DeviceInfoSpecifics>()._impl_._has_bits_);
    static void set_has_cache_guid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_client_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_device_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static void set_has_sync_user_agent(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_chrome_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_deprecated_backup_timestamp(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static void set_has_signin_scoped_device_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_last_updated_timestamp(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static const ::sync_pb::FeatureSpecificFields& feature_fields(const DeviceInfoSpecifics* msg);
    static void set_has_feature_fields(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static const ::sync_pb::SharingSpecificFields& sharing_fields(const DeviceInfoSpecifics* msg);
    static void set_has_sharing_fields(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_model(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_manufacturer(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_pulse_interval_in_minutes(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32768u;
    }
    static const ::sync_pb::InvalidationSpecificFields& invalidation_fields(const DeviceInfoSpecifics* msg);
    static void set_has_invalidation_fields(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static const ::sync_pb::PhoneAsASecurityKeySpecificFields& paask_fields(const DeviceInfoSpecifics* msg);
    static void set_has_paask_fields(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_full_hardware_class(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static const ::sync_pb::ChromeVersionInfo& chrome_version_info(const DeviceInfoSpecifics* msg);
    static const ::sync_pb::GooglePlayServicesVersionInfo& google_play_services_version_info(const DeviceInfoSpecifics* msg);
    static void set_has_os_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 65536u;
    }
    static void set_has_device_form_factor(HasBits* has_bits)
    {
        (*has_bits)[0] |= 131072u;
    }
};

const ::sync_pb::FeatureSpecificFields& DeviceInfoSpecifics::_Internal::feature_fields(const DeviceInfoSpecifics* msg)
{
    return *msg->_impl_.feature_fields_;
}
const ::sync_pb::SharingSpecificFields& DeviceInfoSpecifics::_Internal::sharing_fields(const DeviceInfoSpecifics* msg)
{
    return *msg->_impl_.sharing_fields_;
}
const ::sync_pb::InvalidationSpecificFields& DeviceInfoSpecifics::_Internal::invalidation_fields(const DeviceInfoSpecifics* msg)
{
    return *msg->_impl_.invalidation_fields_;
}
const ::sync_pb::PhoneAsASecurityKeySpecificFields& DeviceInfoSpecifics::_Internal::paask_fields(const DeviceInfoSpecifics* msg)
{
    return *msg->_impl_.paask_fields_;
}
const ::sync_pb::ChromeVersionInfo& DeviceInfoSpecifics::_Internal::chrome_version_info(const DeviceInfoSpecifics* msg)
{
    return *msg->_impl_.client_version_info_.chrome_version_info_;
}
const ::sync_pb::GooglePlayServicesVersionInfo& DeviceInfoSpecifics::_Internal::google_play_services_version_info(const DeviceInfoSpecifics* msg)
{
    return *msg->_impl_.client_version_info_.google_play_services_version_info_;
}
void DeviceInfoSpecifics::set_allocated_chrome_version_info(::sync_pb::ChromeVersionInfo* chrome_version_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_client_version_info();
    if (chrome_version_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(chrome_version_info);
        if (message_arena != submessage_arena) {
            chrome_version_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, chrome_version_info, submessage_arena);
        }
        set_has_chrome_version_info();
        _impl_.client_version_info_.chrome_version_info_ = chrome_version_info;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.chrome_version_info)
}
void DeviceInfoSpecifics::set_allocated_google_play_services_version_info(::sync_pb::GooglePlayServicesVersionInfo* google_play_services_version_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_client_version_info();
    if (google_play_services_version_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(google_play_services_version_info);
        if (message_arena != submessage_arena) {
            google_play_services_version_info
                = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, google_play_services_version_info, submessage_arena);
        }
        set_has_google_play_services_version_info();
        _impl_.client_version_info_.google_play_services_version_info_ = google_play_services_version_info;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.google_play_services_version_info)
}
DeviceInfoSpecifics::DeviceInfoSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.DeviceInfoSpecifics)
}
DeviceInfoSpecifics::DeviceInfoSpecifics(const DeviceInfoSpecifics& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DeviceInfoSpecifics* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cache_guid_) {},
        decltype(_impl_.client_name_) {}, decltype(_impl_.sync_user_agent_) {}, decltype(_impl_.chrome_version_) {},
        decltype(_impl_.signin_scoped_device_id_) {}, decltype(_impl_.model_) {}, decltype(_impl_.manufacturer_) {}, decltype(_impl_.full_hardware_class_) {},
        decltype(_impl_.feature_fields_) { nullptr }, decltype(_impl_.sharing_fields_) { nullptr }, decltype(_impl_.invalidation_fields_) { nullptr },
        decltype(_impl_.paask_fields_) { nullptr }, decltype(_impl_.deprecated_backup_timestamp_) {}, decltype(_impl_.last_updated_timestamp_) {},
        decltype(_impl_.device_type_) {}, decltype(_impl_.pulse_interval_in_minutes_) {}, decltype(_impl_.os_type_) {}, decltype(_impl_.device_form_factor_) {},
        decltype(_impl_.client_version_info_) {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.cache_guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_cache_guid()) {
        _this->_impl_.cache_guid_.Set(from._internal_cache_guid(), _this->GetArenaForAllocation());
    }
    _impl_.client_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_client_name()) {
        _this->_impl_.client_name_.Set(from._internal_client_name(), _this->GetArenaForAllocation());
    }
    _impl_.sync_user_agent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sync_user_agent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sync_user_agent()) {
        _this->_impl_.sync_user_agent_.Set(from._internal_sync_user_agent(), _this->GetArenaForAllocation());
    }
    _impl_.chrome_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chrome_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_chrome_version()) {
        _this->_impl_.chrome_version_.Set(from._internal_chrome_version(), _this->GetArenaForAllocation());
    }
    _impl_.signin_scoped_device_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signin_scoped_device_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_signin_scoped_device_id()) {
        _this->_impl_.signin_scoped_device_id_.Set(from._internal_signin_scoped_device_id(), _this->GetArenaForAllocation());
    }
    _impl_.model_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_model()) {
        _this->_impl_.model_.Set(from._internal_model(), _this->GetArenaForAllocation());
    }
    _impl_.manufacturer_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_manufacturer()) {
        _this->_impl_.manufacturer_.Set(from._internal_manufacturer(), _this->GetArenaForAllocation());
    }
    _impl_.full_hardware_class_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.full_hardware_class_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_full_hardware_class()) {
        _this->_impl_.full_hardware_class_.Set(from._internal_full_hardware_class(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_feature_fields()) {
        _this->_impl_.feature_fields_ = new ::sync_pb::FeatureSpecificFields(*from._impl_.feature_fields_);
    }
    if (from._internal_has_sharing_fields()) {
        _this->_impl_.sharing_fields_ = new ::sync_pb::SharingSpecificFields(*from._impl_.sharing_fields_);
    }
    if (from._internal_has_invalidation_fields()) {
        _this->_impl_.invalidation_fields_ = new ::sync_pb::InvalidationSpecificFields(*from._impl_.invalidation_fields_);
    }
    if (from._internal_has_paask_fields()) {
        _this->_impl_.paask_fields_ = new ::sync_pb::PhoneAsASecurityKeySpecificFields(*from._impl_.paask_fields_);
    }
    ::memcpy(&_impl_.deprecated_backup_timestamp_, &from._impl_.deprecated_backup_timestamp_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.device_form_factor_) - reinterpret_cast<char*>(&_impl_.deprecated_backup_timestamp_))
            + sizeof(_impl_.device_form_factor_));
    clear_has_client_version_info();
    switch (from.client_version_info_case()) {
    case kChromeVersionInfo: {
        _this->_internal_mutable_chrome_version_info()->::sync_pb::ChromeVersionInfo::MergeFrom(from._internal_chrome_version_info());
        break;
    }
    case kGooglePlayServicesVersionInfo: {
        _this->_internal_mutable_google_play_services_version_info()->::sync_pb::GooglePlayServicesVersionInfo::MergeFrom(
            from._internal_google_play_services_version_info());
        break;
    }
    case CLIENT_VERSION_INFO_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.DeviceInfoSpecifics)
}

inline void DeviceInfoSpecifics::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cache_guid_) {}, decltype(_impl_.client_name_) {},
            decltype(_impl_.sync_user_agent_) {}, decltype(_impl_.chrome_version_) {}, decltype(_impl_.signin_scoped_device_id_) {}, decltype(_impl_.model_) {},
            decltype(_impl_.manufacturer_) {}, decltype(_impl_.full_hardware_class_) {}, decltype(_impl_.feature_fields_) { nullptr },
            decltype(_impl_.sharing_fields_) { nullptr }, decltype(_impl_.invalidation_fields_) { nullptr }, decltype(_impl_.paask_fields_) { nullptr },
            decltype(_impl_.deprecated_backup_timestamp_) { int64_t { 0 } }, decltype(_impl_.last_updated_timestamp_) { int64_t { 0 } },
            decltype(_impl_.device_type_) { 0 }, decltype(_impl_.pulse_interval_in_minutes_) { 0 }, decltype(_impl_.os_type_) { 0 },
            decltype(_impl_.device_form_factor_) { 0 }, decltype(_impl_.client_version_info_) {}, /*decltype(_impl_._oneof_case_)*/ {} };
    _impl_.cache_guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sync_user_agent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sync_user_agent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chrome_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chrome_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signin_scoped_device_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signin_scoped_device_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.model_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.manufacturer_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.full_hardware_class_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.full_hardware_class_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    clear_has_client_version_info();
}

DeviceInfoSpecifics::~DeviceInfoSpecifics()
{
    // @@protoc_insertion_point(destructor:sync_pb.DeviceInfoSpecifics)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DeviceInfoSpecifics::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.cache_guid_.Destroy();
    _impl_.client_name_.Destroy();
    _impl_.sync_user_agent_.Destroy();
    _impl_.chrome_version_.Destroy();
    _impl_.signin_scoped_device_id_.Destroy();
    _impl_.model_.Destroy();
    _impl_.manufacturer_.Destroy();
    _impl_.full_hardware_class_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.feature_fields_;
    if (this != internal_default_instance())
        delete _impl_.sharing_fields_;
    if (this != internal_default_instance())
        delete _impl_.invalidation_fields_;
    if (this != internal_default_instance())
        delete _impl_.paask_fields_;
    if (has_client_version_info()) {
        clear_client_version_info();
    }
}

void DeviceInfoSpecifics::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DeviceInfoSpecifics::clear_client_version_info()
{
    // @@protoc_insertion_point(one_of_clear_start:sync_pb.DeviceInfoSpecifics)
    switch (client_version_info_case()) {
    case kChromeVersionInfo: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.client_version_info_.chrome_version_info_;
        }
        break;
    }
    case kGooglePlayServicesVersionInfo: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.client_version_info_.google_play_services_version_info_;
        }
        break;
    }
    case CLIENT_VERSION_INFO_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = CLIENT_VERSION_INFO_NOT_SET;
}

void DeviceInfoSpecifics::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.DeviceInfoSpecifics)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.cache_guid_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.client_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.sync_user_agent_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.chrome_version_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.signin_scoped_device_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.model_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000040u) {
            _impl_.manufacturer_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000080u) {
            _impl_.full_hardware_class_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        if (cached_has_bits & 0x00000100u) {
            GOOGLE_DCHECK(_impl_.feature_fields_ != nullptr);
            _impl_.feature_fields_->Clear();
        }
        if (cached_has_bits & 0x00000200u) {
            GOOGLE_DCHECK(_impl_.sharing_fields_ != nullptr);
            _impl_.sharing_fields_->Clear();
        }
        if (cached_has_bits & 0x00000400u) {
            GOOGLE_DCHECK(_impl_.invalidation_fields_ != nullptr);
            _impl_.invalidation_fields_->Clear();
        }
        if (cached_has_bits & 0x00000800u) {
            GOOGLE_DCHECK(_impl_.paask_fields_ != nullptr);
            _impl_.paask_fields_->Clear();
        }
    }
    if (cached_has_bits & 0x0000f000u) {
        ::memset(&_impl_.deprecated_backup_timestamp_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pulse_interval_in_minutes_) - reinterpret_cast<char*>(&_impl_.deprecated_backup_timestamp_))
                + sizeof(_impl_.pulse_interval_in_minutes_));
    }
    if (cached_has_bits & 0x00030000u) {
        ::memset(&_impl_.os_type_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.device_form_factor_) - reinterpret_cast<char*>(&_impl_.os_type_))
                + sizeof(_impl_.device_form_factor_));
    }
    clear_client_version_info();
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DeviceInfoSpecifics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string cache_guid = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_cache_guid();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string client_name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_client_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.DeviceType device_type = 3 [deprecated = true];
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_DeviceType_IsValid(val))) {
                    _internal_set_device_type(static_cast<::sync_pb::SyncEnums_DeviceType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string sync_user_agent = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_sync_user_agent();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string chrome_version = 5 [deprecated = true];
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_chrome_version();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 deprecated_backup_timestamp = 6 [deprecated = true];
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_deprecated_backup_timestamp(&has_bits);
                _impl_.deprecated_backup_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string signin_scoped_device_id = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_signin_scoped_device_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 last_updated_timestamp = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_last_updated_timestamp(&has_bits);
                _impl_.last_updated_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.FeatureSpecificFields feature_fields = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr = ctx->ParseMessage(_internal_mutable_feature_fields(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SharingSpecificFields sharing_fields = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr = ctx->ParseMessage(_internal_mutable_sharing_fields(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string model = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                auto str = _internal_mutable_model();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string manufacturer = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                auto str = _internal_mutable_manufacturer();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 pulse_interval_in_minutes = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                _Internal::set_has_pulse_interval_in_minutes(&has_bits);
                _impl_.pulse_interval_in_minutes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.InvalidationSpecificFields invalidation_fields = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                ptr = ctx->ParseMessage(_internal_mutable_invalidation_fields(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.PhoneAsASecurityKeySpecificFields paask_fields = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
                ptr = ctx->ParseMessage(_internal_mutable_paask_fields(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string full_hardware_class = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                auto str = _internal_mutable_full_hardware_class();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.ChromeVersionInfo chrome_version_info = 17;
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
                ptr = ctx->ParseMessage(_internal_mutable_chrome_version_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.GooglePlayServicesVersionInfo google_play_services_version_info = 18;
        case 18:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
                ptr = ctx->ParseMessage(_internal_mutable_google_play_services_version_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.OsType os_type = 19;
        case 19:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_OsType_IsValid(val))) {
                    _internal_set_os_type(static_cast<::sync_pb::SyncEnums_OsType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.DeviceFormFactor device_form_factor = 20;
        case 20:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_DeviceFormFactor_IsValid(val))) {
                    _internal_set_device_form_factor(static_cast<::sync_pb::SyncEnums_DeviceFormFactor>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DeviceInfoSpecifics::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.DeviceInfoSpecifics)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string cache_guid = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_cache_guid(), target);
    }

    // optional string client_name = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_client_name(), target);
    }

    // optional .sync_pb.SyncEnums.DeviceType device_type = 3 [deprecated = true];
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_device_type(), target);
    }

    // optional string sync_user_agent = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_sync_user_agent(), target);
    }

    // optional string chrome_version = 5 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_chrome_version(), target);
    }

    // optional int64 deprecated_backup_timestamp = 6 [deprecated = true];
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_deprecated_backup_timestamp(), target);
    }

    // optional string signin_scoped_device_id = 7;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_signin_scoped_device_id(), target);
    }

    // optional int64 last_updated_timestamp = 8;
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_last_updated_timestamp(), target);
    }

    // optional .sync_pb.FeatureSpecificFields feature_fields = 9;
    if (cached_has_bits & 0x00000100u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            9, _Internal::feature_fields(this), _Internal::feature_fields(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.SharingSpecificFields sharing_fields = 10;
    if (cached_has_bits & 0x00000200u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            10, _Internal::sharing_fields(this), _Internal::sharing_fields(this).GetCachedSize(), target, stream);
    }

    // optional string model = 11;
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteStringMaybeAliased(11, this->_internal_model(), target);
    }

    // optional string manufacturer = 12;
    if (cached_has_bits & 0x00000040u) {
        target = stream->WriteStringMaybeAliased(12, this->_internal_manufacturer(), target);
    }

    // optional int32 pulse_interval_in_minutes = 13;
    if (cached_has_bits & 0x00008000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_pulse_interval_in_minutes(), target);
    }

    // optional .sync_pb.InvalidationSpecificFields invalidation_fields = 14;
    if (cached_has_bits & 0x00000400u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            14, _Internal::invalidation_fields(this), _Internal::invalidation_fields(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.PhoneAsASecurityKeySpecificFields paask_fields = 15;
    if (cached_has_bits & 0x00000800u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            15, _Internal::paask_fields(this), _Internal::paask_fields(this).GetCachedSize(), target, stream);
    }

    // optional string full_hardware_class = 16;
    if (cached_has_bits & 0x00000080u) {
        target = stream->WriteStringMaybeAliased(16, this->_internal_full_hardware_class(), target);
    }

    switch (client_version_info_case()) {
    case kChromeVersionInfo: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            17, _Internal::chrome_version_info(this), _Internal::chrome_version_info(this).GetCachedSize(), target, stream);
        break;
    }
    case kGooglePlayServicesVersionInfo: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            18, _Internal::google_play_services_version_info(this), _Internal::google_play_services_version_info(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    // optional .sync_pb.SyncEnums.OsType os_type = 19;
    if (cached_has_bits & 0x00010000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(19, this->_internal_os_type(), target);
    }

    // optional .sync_pb.SyncEnums.DeviceFormFactor device_form_factor = 20;
    if (cached_has_bits & 0x00020000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(20, this->_internal_device_form_factor(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.DeviceInfoSpecifics)
    return target;
}

size_t DeviceInfoSpecifics::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.DeviceInfoSpecifics)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string cache_guid = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_cache_guid());
        }

        // optional string client_name = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_client_name());
        }

        // optional string sync_user_agent = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_sync_user_agent());
        }

        // optional string chrome_version = 5 [deprecated = true];
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_chrome_version());
        }

        // optional string signin_scoped_device_id = 7;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_signin_scoped_device_id());
        }

        // optional string model = 11;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_model());
        }

        // optional string manufacturer = 12;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_manufacturer());
        }

        // optional string full_hardware_class = 16;
        if (cached_has_bits & 0x00000080u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_full_hardware_class());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        // optional .sync_pb.FeatureSpecificFields feature_fields = 9;
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.feature_fields_);
        }

        // optional .sync_pb.SharingSpecificFields sharing_fields = 10;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.sharing_fields_);
        }

        // optional .sync_pb.InvalidationSpecificFields invalidation_fields = 14;
        if (cached_has_bits & 0x00000400u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.invalidation_fields_);
        }

        // optional .sync_pb.PhoneAsASecurityKeySpecificFields paask_fields = 15;
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.paask_fields_);
        }

        // optional int64 deprecated_backup_timestamp = 6 [deprecated = true];
        if (cached_has_bits & 0x00001000u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_deprecated_backup_timestamp());
        }

        // optional int64 last_updated_timestamp = 8;
        if (cached_has_bits & 0x00002000u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_updated_timestamp());
        }

        // optional .sync_pb.SyncEnums.DeviceType device_type = 3 [deprecated = true];
        if (cached_has_bits & 0x00004000u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_device_type());
        }

        // optional int32 pulse_interval_in_minutes = 13;
        if (cached_has_bits & 0x00008000u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pulse_interval_in_minutes());
        }
    }
    if (cached_has_bits & 0x00030000u) {
        // optional .sync_pb.SyncEnums.OsType os_type = 19;
        if (cached_has_bits & 0x00010000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_os_type());
        }

        // optional .sync_pb.SyncEnums.DeviceFormFactor device_form_factor = 20;
        if (cached_has_bits & 0x00020000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_device_form_factor());
        }
    }
    switch (client_version_info_case()) {
    // .sync_pb.ChromeVersionInfo chrome_version_info = 17;
    case kChromeVersionInfo: {
        total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.client_version_info_.chrome_version_info_);
        break;
    }
    // .sync_pb.GooglePlayServicesVersionInfo google_play_services_version_info = 18;
    case kGooglePlayServicesVersionInfo: {
        total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.client_version_info_.google_play_services_version_info_);
        break;
    }
    case CLIENT_VERSION_INFO_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DeviceInfoSpecifics::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DeviceInfoSpecifics*>(&from));
}

void DeviceInfoSpecifics::MergeFrom(const DeviceInfoSpecifics& from)
{
    DeviceInfoSpecifics* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.DeviceInfoSpecifics)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_cache_guid(from._internal_cache_guid());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_client_name(from._internal_client_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_sync_user_agent(from._internal_sync_user_agent());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_chrome_version(from._internal_chrome_version());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_signin_scoped_device_id(from._internal_signin_scoped_device_id());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_model(from._internal_model());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_set_manufacturer(from._internal_manufacturer());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_set_full_hardware_class(from._internal_full_hardware_class());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_mutable_feature_fields()->::sync_pb::FeatureSpecificFields::MergeFrom(from._internal_feature_fields());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_internal_mutable_sharing_fields()->::sync_pb::SharingSpecificFields::MergeFrom(from._internal_sharing_fields());
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_internal_mutable_invalidation_fields()->::sync_pb::InvalidationSpecificFields::MergeFrom(from._internal_invalidation_fields());
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_internal_mutable_paask_fields()->::sync_pb::PhoneAsASecurityKeySpecificFields::MergeFrom(from._internal_paask_fields());
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.deprecated_backup_timestamp_ = from._impl_.deprecated_backup_timestamp_;
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.last_updated_timestamp_ = from._impl_.last_updated_timestamp_;
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.device_type_ = from._impl_.device_type_;
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_impl_.pulse_interval_in_minutes_ = from._impl_.pulse_interval_in_minutes_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00030000u) {
        if (cached_has_bits & 0x00010000u) {
            _this->_impl_.os_type_ = from._impl_.os_type_;
        }
        if (cached_has_bits & 0x00020000u) {
            _this->_impl_.device_form_factor_ = from._impl_.device_form_factor_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    switch (from.client_version_info_case()) {
    case kChromeVersionInfo: {
        _this->_internal_mutable_chrome_version_info()->::sync_pb::ChromeVersionInfo::MergeFrom(from._internal_chrome_version_info());
        break;
    }
    case kGooglePlayServicesVersionInfo: {
        _this->_internal_mutable_google_play_services_version_info()->::sync_pb::GooglePlayServicesVersionInfo::MergeFrom(
            from._internal_google_play_services_version_info());
        break;
    }
    case CLIENT_VERSION_INFO_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceInfoSpecifics::CopyFrom(const DeviceInfoSpecifics& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.DeviceInfoSpecifics)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DeviceInfoSpecifics::IsInitialized() const
{
    return true;
}

void DeviceInfoSpecifics::InternalSwap(DeviceInfoSpecifics* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.cache_guid_, lhs_arena, &other->_impl_.cache_guid_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.client_name_, lhs_arena, &other->_impl_.client_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.sync_user_agent_, lhs_arena, &other->_impl_.sync_user_agent_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.chrome_version_, lhs_arena, &other->_impl_.chrome_version_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.signin_scoped_device_id_, lhs_arena, &other->_impl_.signin_scoped_device_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.model_, lhs_arena, &other->_impl_.model_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.manufacturer_, lhs_arena, &other->_impl_.manufacturer_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.full_hardware_class_, lhs_arena, &other->_impl_.full_hardware_class_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(DeviceInfoSpecifics, _impl_.device_form_factor_)
        + sizeof(DeviceInfoSpecifics::_impl_.device_form_factor_) - PROTOBUF_FIELD_OFFSET(DeviceInfoSpecifics, _impl_.feature_fields_)>(
        reinterpret_cast<char*>(&_impl_.feature_fields_), reinterpret_cast<char*>(&other->_impl_.feature_fields_));
    swap(_impl_.client_version_info_, other->_impl_.client_version_info_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string DeviceInfoSpecifics::GetTypeName() const
{
    return "sync_pb.DeviceInfoSpecifics";
}

// ===================================================================

class FeatureSpecificFields::_Internal {
public:
    using HasBits = decltype(std::declval<FeatureSpecificFields>()._impl_._has_bits_);
    static void set_has_send_tab_to_self_receiving_enabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_send_tab_to_self_receiving_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_floating_workspace_last_signin_time_windows_epoch_micros(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

FeatureSpecificFields::FeatureSpecificFields(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.FeatureSpecificFields)
}
FeatureSpecificFields::FeatureSpecificFields(const FeatureSpecificFields& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    FeatureSpecificFields* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.send_tab_to_self_receiving_enabled_) {}, decltype(_impl_.send_tab_to_self_receiving_type_) {},
        decltype(_impl_.floating_workspace_last_signin_time_windows_epoch_micros_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.send_tab_to_self_receiving_enabled_, &from._impl_.send_tab_to_self_receiving_enabled_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.floating_workspace_last_signin_time_windows_epoch_micros_)
            - reinterpret_cast<char*>(&_impl_.send_tab_to_self_receiving_enabled_))
            + sizeof(_impl_.floating_workspace_last_signin_time_windows_epoch_micros_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.FeatureSpecificFields)
}

inline void FeatureSpecificFields::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.send_tab_to_self_receiving_enabled_) { false },
        decltype(_impl_.send_tab_to_self_receiving_type_) { 0 }, decltype(_impl_.floating_workspace_last_signin_time_windows_epoch_micros_) { int64_t { 0 } } };
}

FeatureSpecificFields::~FeatureSpecificFields()
{
    // @@protoc_insertion_point(destructor:sync_pb.FeatureSpecificFields)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void FeatureSpecificFields::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FeatureSpecificFields::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void FeatureSpecificFields::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.FeatureSpecificFields)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        ::memset(&_impl_.send_tab_to_self_receiving_enabled_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.floating_workspace_last_signin_time_windows_epoch_micros_)
                - reinterpret_cast<char*>(&_impl_.send_tab_to_self_receiving_enabled_))
                + sizeof(_impl_.floating_workspace_last_signin_time_windows_epoch_micros_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* FeatureSpecificFields::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bool send_tab_to_self_receiving_enabled = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_send_tab_to_self_receiving_enabled(&has_bits);
                _impl_.send_tab_to_self_receiving_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.SendTabReceivingType send_tab_to_self_receiving_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_SendTabReceivingType_IsValid(val))) {
                    _internal_set_send_tab_to_self_receiving_type(static_cast<::sync_pb::SyncEnums_SendTabReceivingType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 floating_workspace_last_signin_time_windows_epoch_micros = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_floating_workspace_last_signin_time_windows_epoch_micros(&has_bits);
                _impl_.floating_workspace_last_signin_time_windows_epoch_micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* FeatureSpecificFields::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.FeatureSpecificFields)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool send_tab_to_self_receiving_enabled = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_send_tab_to_self_receiving_enabled(), target);
    }

    // optional .sync_pb.SyncEnums.SendTabReceivingType send_tab_to_self_receiving_type = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_send_tab_to_self_receiving_type(), target);
    }

    // optional int64 floating_workspace_last_signin_time_windows_epoch_micros = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_floating_workspace_last_signin_time_windows_epoch_micros(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.FeatureSpecificFields)
    return target;
}

size_t FeatureSpecificFields::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.FeatureSpecificFields)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional bool send_tab_to_self_receiving_enabled = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 1;
        }

        // optional .sync_pb.SyncEnums.SendTabReceivingType send_tab_to_self_receiving_type = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_send_tab_to_self_receiving_type());
        }

        // optional int64 floating_workspace_last_signin_time_windows_epoch_micros = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_floating_workspace_last_signin_time_windows_epoch_micros());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void FeatureSpecificFields::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const FeatureSpecificFields*>(&from));
}

void FeatureSpecificFields::MergeFrom(const FeatureSpecificFields& from)
{
    FeatureSpecificFields* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.FeatureSpecificFields)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.send_tab_to_self_receiving_enabled_ = from._impl_.send_tab_to_self_receiving_enabled_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.send_tab_to_self_receiving_type_ = from._impl_.send_tab_to_self_receiving_type_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.floating_workspace_last_signin_time_windows_epoch_micros_ = from._impl_.floating_workspace_last_signin_time_windows_epoch_micros_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FeatureSpecificFields::CopyFrom(const FeatureSpecificFields& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.FeatureSpecificFields)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FeatureSpecificFields::IsInitialized() const
{
    return true;
}

void FeatureSpecificFields::InternalSwap(FeatureSpecificFields* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(FeatureSpecificFields, _impl_.floating_workspace_last_signin_time_windows_epoch_micros_)
        + sizeof(FeatureSpecificFields::_impl_.floating_workspace_last_signin_time_windows_epoch_micros_)
        - PROTOBUF_FIELD_OFFSET(FeatureSpecificFields, _impl_.send_tab_to_self_receiving_enabled_)>(
        reinterpret_cast<char*>(&_impl_.send_tab_to_self_receiving_enabled_), reinterpret_cast<char*>(&other->_impl_.send_tab_to_self_receiving_enabled_));
}

std::string FeatureSpecificFields::GetTypeName() const
{
    return "sync_pb.FeatureSpecificFields";
}

// ===================================================================

class SharingSpecificFields::_Internal {
public:
    using HasBits = decltype(std::declval<SharingSpecificFields>()._impl_._has_bits_);
    static void set_has_vapid_fcm_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_vapid_p256dh(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_vapid_auth_secret(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_sender_id_fcm_token_deprecated(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_sender_id_p256dh_deprecated(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_sender_id_auth_secret_deprecated(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_sender_id_fcm_token_v2(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_sender_id_p256dh_v2(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_sender_id_auth_secret_v2(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_chime_representative_target_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
};

SharingSpecificFields::SharingSpecificFields(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.SharingSpecificFields)
}
SharingSpecificFields::SharingSpecificFields(const SharingSpecificFields& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SharingSpecificFields* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.enabled_features_) { from._impl_.enabled_features_ }, decltype(_impl_.vapid_fcm_token_) {}, decltype(_impl_.vapid_p256dh_) {},
        decltype(_impl_.vapid_auth_secret_) {}, decltype(_impl_.sender_id_fcm_token_deprecated_) {}, decltype(_impl_.sender_id_p256dh_deprecated_) {},
        decltype(_impl_.sender_id_auth_secret_deprecated_) {}, decltype(_impl_.sender_id_fcm_token_v2_) {}, decltype(_impl_.sender_id_p256dh_v2_) {},
        decltype(_impl_.sender_id_auth_secret_v2_) {}, decltype(_impl_.chime_representative_target_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.vapid_fcm_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vapid_fcm_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_vapid_fcm_token()) {
        _this->_impl_.vapid_fcm_token_.Set(from._internal_vapid_fcm_token(), _this->GetArenaForAllocation());
    }
    _impl_.vapid_p256dh_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vapid_p256dh_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_vapid_p256dh()) {
        _this->_impl_.vapid_p256dh_.Set(from._internal_vapid_p256dh(), _this->GetArenaForAllocation());
    }
    _impl_.vapid_auth_secret_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vapid_auth_secret_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_vapid_auth_secret()) {
        _this->_impl_.vapid_auth_secret_.Set(from._internal_vapid_auth_secret(), _this->GetArenaForAllocation());
    }
    _impl_.sender_id_fcm_token_deprecated_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_fcm_token_deprecated_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sender_id_fcm_token_deprecated()) {
        _this->_impl_.sender_id_fcm_token_deprecated_.Set(from._internal_sender_id_fcm_token_deprecated(), _this->GetArenaForAllocation());
    }
    _impl_.sender_id_p256dh_deprecated_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_p256dh_deprecated_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sender_id_p256dh_deprecated()) {
        _this->_impl_.sender_id_p256dh_deprecated_.Set(from._internal_sender_id_p256dh_deprecated(), _this->GetArenaForAllocation());
    }
    _impl_.sender_id_auth_secret_deprecated_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_auth_secret_deprecated_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sender_id_auth_secret_deprecated()) {
        _this->_impl_.sender_id_auth_secret_deprecated_.Set(from._internal_sender_id_auth_secret_deprecated(), _this->GetArenaForAllocation());
    }
    _impl_.sender_id_fcm_token_v2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_fcm_token_v2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sender_id_fcm_token_v2()) {
        _this->_impl_.sender_id_fcm_token_v2_.Set(from._internal_sender_id_fcm_token_v2(), _this->GetArenaForAllocation());
    }
    _impl_.sender_id_p256dh_v2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_p256dh_v2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sender_id_p256dh_v2()) {
        _this->_impl_.sender_id_p256dh_v2_.Set(from._internal_sender_id_p256dh_v2(), _this->GetArenaForAllocation());
    }
    _impl_.sender_id_auth_secret_v2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_auth_secret_v2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sender_id_auth_secret_v2()) {
        _this->_impl_.sender_id_auth_secret_v2_.Set(from._internal_sender_id_auth_secret_v2(), _this->GetArenaForAllocation());
    }
    _impl_.chime_representative_target_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chime_representative_target_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_chime_representative_target_id()) {
        _this->_impl_.chime_representative_target_id_.Set(from._internal_chime_representative_target_id(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.SharingSpecificFields)
}

inline void SharingSpecificFields::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.enabled_features_) { arena },
        decltype(_impl_.vapid_fcm_token_) {}, decltype(_impl_.vapid_p256dh_) {}, decltype(_impl_.vapid_auth_secret_) {},
        decltype(_impl_.sender_id_fcm_token_deprecated_) {}, decltype(_impl_.sender_id_p256dh_deprecated_) {},
        decltype(_impl_.sender_id_auth_secret_deprecated_) {}, decltype(_impl_.sender_id_fcm_token_v2_) {}, decltype(_impl_.sender_id_p256dh_v2_) {},
        decltype(_impl_.sender_id_auth_secret_v2_) {}, decltype(_impl_.chime_representative_target_id_) {} };
    _impl_.vapid_fcm_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vapid_fcm_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vapid_p256dh_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vapid_p256dh_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vapid_auth_secret_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vapid_auth_secret_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_fcm_token_deprecated_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_fcm_token_deprecated_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_p256dh_deprecated_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_p256dh_deprecated_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_auth_secret_deprecated_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_auth_secret_deprecated_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_fcm_token_v2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_fcm_token_v2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_p256dh_v2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_p256dh_v2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_auth_secret_v2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_id_auth_secret_v2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chime_representative_target_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chime_representative_target_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SharingSpecificFields::~SharingSpecificFields()
{
    // @@protoc_insertion_point(destructor:sync_pb.SharingSpecificFields)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SharingSpecificFields::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.enabled_features_.~RepeatedField();
    _impl_.vapid_fcm_token_.Destroy();
    _impl_.vapid_p256dh_.Destroy();
    _impl_.vapid_auth_secret_.Destroy();
    _impl_.sender_id_fcm_token_deprecated_.Destroy();
    _impl_.sender_id_p256dh_deprecated_.Destroy();
    _impl_.sender_id_auth_secret_deprecated_.Destroy();
    _impl_.sender_id_fcm_token_v2_.Destroy();
    _impl_.sender_id_p256dh_v2_.Destroy();
    _impl_.sender_id_auth_secret_v2_.Destroy();
    _impl_.chime_representative_target_id_.Destroy();
}

void SharingSpecificFields::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SharingSpecificFields::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.SharingSpecificFields)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.enabled_features_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.vapid_fcm_token_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.vapid_p256dh_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.vapid_auth_secret_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.sender_id_fcm_token_deprecated_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.sender_id_p256dh_deprecated_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.sender_id_auth_secret_deprecated_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000040u) {
            _impl_.sender_id_fcm_token_v2_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000080u) {
            _impl_.sender_id_p256dh_v2_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00000300u) {
        if (cached_has_bits & 0x00000100u) {
            _impl_.sender_id_auth_secret_v2_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000200u) {
            _impl_.chime_representative_target_id_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SharingSpecificFields::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string vapid_fcm_token = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_vapid_fcm_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes vapid_p256dh = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_vapid_p256dh();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes vapid_auth_secret = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_vapid_auth_secret();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.SharingSpecificFields.EnabledFeatures enabled_features = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::sync_pb::SharingSpecificFields_EnabledFeatures_IsValid(val))) {
                        _internal_add_enabled_features(static_cast<::sync_pb::SharingSpecificFields_EnabledFeatures>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
            } else if (static_cast<uint8_t>(tag) == 34) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(
                    _internal_mutable_enabled_features(), ptr, ctx, ::sync_pb::SharingSpecificFields_EnabledFeatures_IsValid, &_internal_metadata_, 4);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string sender_id_fcm_token_deprecated = 5 [deprecated = true];
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_sender_id_fcm_token_deprecated();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes sender_id_p256dh_deprecated = 6 [deprecated = true];
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_sender_id_p256dh_deprecated();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes sender_id_auth_secret_deprecated = 7 [deprecated = true];
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_sender_id_auth_secret_deprecated();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string sender_id_fcm_token_v2 = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_sender_id_fcm_token_v2();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes sender_id_p256dh_v2 = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                auto str = _internal_mutable_sender_id_p256dh_v2();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes sender_id_auth_secret_v2 = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                auto str = _internal_mutable_sender_id_auth_secret_v2();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string chime_representative_target_id = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                auto str = _internal_mutable_chime_representative_target_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SharingSpecificFields::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.SharingSpecificFields)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string vapid_fcm_token = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_vapid_fcm_token(), target);
    }

    // optional bytes vapid_p256dh = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_vapid_p256dh(), target);
    }

    // optional bytes vapid_auth_secret = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_vapid_auth_secret(), target);
    }

    // repeated .sync_pb.SharingSpecificFields.EnabledFeatures enabled_features = 4;
    for (int i = 0, n = this->_internal_enabled_features_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_enabled_features(i), target);
    }

    // optional string sender_id_fcm_token_deprecated = 5 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_sender_id_fcm_token_deprecated(), target);
    }

    // optional bytes sender_id_p256dh_deprecated = 6 [deprecated = true];
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteBytesMaybeAliased(6, this->_internal_sender_id_p256dh_deprecated(), target);
    }

    // optional bytes sender_id_auth_secret_deprecated = 7 [deprecated = true];
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteBytesMaybeAliased(7, this->_internal_sender_id_auth_secret_deprecated(), target);
    }

    // optional string sender_id_fcm_token_v2 = 8;
    if (cached_has_bits & 0x00000040u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_sender_id_fcm_token_v2(), target);
    }

    // optional bytes sender_id_p256dh_v2 = 9;
    if (cached_has_bits & 0x00000080u) {
        target = stream->WriteBytesMaybeAliased(9, this->_internal_sender_id_p256dh_v2(), target);
    }

    // optional bytes sender_id_auth_secret_v2 = 10;
    if (cached_has_bits & 0x00000100u) {
        target = stream->WriteBytesMaybeAliased(10, this->_internal_sender_id_auth_secret_v2(), target);
    }

    // optional string chime_representative_target_id = 11;
    if (cached_has_bits & 0x00000200u) {
        target = stream->WriteStringMaybeAliased(11, this->_internal_chime_representative_target_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.SharingSpecificFields)
    return target;
}

size_t SharingSpecificFields::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.SharingSpecificFields)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.SharingSpecificFields.EnabledFeatures enabled_features = 4;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_enabled_features_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_enabled_features(static_cast<int>(i)));
        }
        total_size += (1UL * count) + data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string vapid_fcm_token = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_vapid_fcm_token());
        }

        // optional bytes vapid_p256dh = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_vapid_p256dh());
        }

        // optional bytes vapid_auth_secret = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_vapid_auth_secret());
        }

        // optional string sender_id_fcm_token_deprecated = 5 [deprecated = true];
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_sender_id_fcm_token_deprecated());
        }

        // optional bytes sender_id_p256dh_deprecated = 6 [deprecated = true];
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_sender_id_p256dh_deprecated());
        }

        // optional bytes sender_id_auth_secret_deprecated = 7 [deprecated = true];
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_sender_id_auth_secret_deprecated());
        }

        // optional string sender_id_fcm_token_v2 = 8;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_sender_id_fcm_token_v2());
        }

        // optional bytes sender_id_p256dh_v2 = 9;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_sender_id_p256dh_v2());
        }
    }
    if (cached_has_bits & 0x00000300u) {
        // optional bytes sender_id_auth_secret_v2 = 10;
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_sender_id_auth_secret_v2());
        }

        // optional string chime_representative_target_id = 11;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_chime_representative_target_id());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SharingSpecificFields::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SharingSpecificFields*>(&from));
}

void SharingSpecificFields::MergeFrom(const SharingSpecificFields& from)
{
    SharingSpecificFields* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.SharingSpecificFields)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.enabled_features_.MergeFrom(from._impl_.enabled_features_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_vapid_fcm_token(from._internal_vapid_fcm_token());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_vapid_p256dh(from._internal_vapid_p256dh());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_vapid_auth_secret(from._internal_vapid_auth_secret());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_sender_id_fcm_token_deprecated(from._internal_sender_id_fcm_token_deprecated());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_sender_id_p256dh_deprecated(from._internal_sender_id_p256dh_deprecated());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_sender_id_auth_secret_deprecated(from._internal_sender_id_auth_secret_deprecated());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_set_sender_id_fcm_token_v2(from._internal_sender_id_fcm_token_v2());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_set_sender_id_p256dh_v2(from._internal_sender_id_p256dh_v2());
        }
    }
    if (cached_has_bits & 0x00000300u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_set_sender_id_auth_secret_v2(from._internal_sender_id_auth_secret_v2());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_internal_set_chime_representative_target_id(from._internal_chime_representative_target_id());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SharingSpecificFields::CopyFrom(const SharingSpecificFields& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.SharingSpecificFields)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SharingSpecificFields::IsInitialized() const
{
    return true;
}

void SharingSpecificFields::InternalSwap(SharingSpecificFields* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.enabled_features_.InternalSwap(&other->_impl_.enabled_features_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.vapid_fcm_token_, lhs_arena, &other->_impl_.vapid_fcm_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.vapid_p256dh_, lhs_arena, &other->_impl_.vapid_p256dh_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.vapid_auth_secret_, lhs_arena, &other->_impl_.vapid_auth_secret_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.sender_id_fcm_token_deprecated_, lhs_arena, &other->_impl_.sender_id_fcm_token_deprecated_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.sender_id_p256dh_deprecated_, lhs_arena, &other->_impl_.sender_id_p256dh_deprecated_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.sender_id_auth_secret_deprecated_, lhs_arena, &other->_impl_.sender_id_auth_secret_deprecated_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.sender_id_fcm_token_v2_, lhs_arena, &other->_impl_.sender_id_fcm_token_v2_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.sender_id_p256dh_v2_, lhs_arena, &other->_impl_.sender_id_p256dh_v2_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.sender_id_auth_secret_v2_, lhs_arena, &other->_impl_.sender_id_auth_secret_v2_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.chime_representative_target_id_, lhs_arena, &other->_impl_.chime_representative_target_id_, rhs_arena);
}

std::string SharingSpecificFields::GetTypeName() const
{
    return "sync_pb.SharingSpecificFields";
}

// ===================================================================

class InvalidationSpecificFields::_Internal {
public:
    using HasBits = decltype(std::declval<InvalidationSpecificFields>()._impl_._has_bits_);
    static void set_has_instance_id_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

InvalidationSpecificFields::InvalidationSpecificFields(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.InvalidationSpecificFields)
}
InvalidationSpecificFields::InvalidationSpecificFields(const InvalidationSpecificFields& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    InvalidationSpecificFields* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.interested_data_type_ids_) { from._impl_.interested_data_type_ids_ }, decltype(_impl_.instance_id_token_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.instance_id_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instance_id_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_instance_id_token()) {
        _this->_impl_.instance_id_token_.Set(from._internal_instance_id_token(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.InvalidationSpecificFields)
}

inline void InvalidationSpecificFields::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.interested_data_type_ids_) { arena },
        decltype(_impl_.instance_id_token_) {} };
    _impl_.instance_id_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instance_id_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InvalidationSpecificFields::~InvalidationSpecificFields()
{
    // @@protoc_insertion_point(destructor:sync_pb.InvalidationSpecificFields)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void InvalidationSpecificFields::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.interested_data_type_ids_.~RepeatedField();
    _impl_.instance_id_token_.Destroy();
}

void InvalidationSpecificFields::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void InvalidationSpecificFields::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.InvalidationSpecificFields)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.interested_data_type_ids_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.instance_id_token_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* InvalidationSpecificFields::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string instance_id_token = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_instance_id_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated int32 interested_data_type_ids = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_interested_data_type_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
            } else if (static_cast<uint8_t>(tag) == 18) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_interested_data_type_ids(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* InvalidationSpecificFields::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.InvalidationSpecificFields)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string instance_id_token = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_instance_id_token(), target);
    }

    // repeated int32 interested_data_type_ids = 2;
    for (int i = 0, n = this->_internal_interested_data_type_ids_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_interested_data_type_ids(i), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.InvalidationSpecificFields)
    return target;
}

size_t InvalidationSpecificFields::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.InvalidationSpecificFields)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 interested_data_type_ids = 2;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.interested_data_type_ids_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_interested_data_type_ids_size());
        total_size += data_size;
    }

    // optional string instance_id_token = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_instance_id_token());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void InvalidationSpecificFields::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const InvalidationSpecificFields*>(&from));
}

void InvalidationSpecificFields::MergeFrom(const InvalidationSpecificFields& from)
{
    InvalidationSpecificFields* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.InvalidationSpecificFields)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.interested_data_type_ids_.MergeFrom(from._impl_.interested_data_type_ids_);
    if (from._internal_has_instance_id_token()) {
        _this->_internal_set_instance_id_token(from._internal_instance_id_token());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void InvalidationSpecificFields::CopyFrom(const InvalidationSpecificFields& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.InvalidationSpecificFields)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool InvalidationSpecificFields::IsInitialized() const
{
    return true;
}

void InvalidationSpecificFields::InternalSwap(InvalidationSpecificFields* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.interested_data_type_ids_.InternalSwap(&other->_impl_.interested_data_type_ids_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.instance_id_token_, lhs_arena, &other->_impl_.instance_id_token_, rhs_arena);
}

std::string InvalidationSpecificFields::GetTypeName() const
{
    return "sync_pb.InvalidationSpecificFields";
}

// ===================================================================

class PhoneAsASecurityKeySpecificFields::_Internal {
public:
    using HasBits = decltype(std::declval<PhoneAsASecurityKeySpecificFields>()._impl_._has_bits_);
    static void set_has_tunnel_server_domain(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_contact_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_secret(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_peer_public_key_x962(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_google_credential_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

PhoneAsASecurityKeySpecificFields::PhoneAsASecurityKeySpecificFields(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.PhoneAsASecurityKeySpecificFields)
}
PhoneAsASecurityKeySpecificFields::PhoneAsASecurityKeySpecificFields(const PhoneAsASecurityKeySpecificFields& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PhoneAsASecurityKeySpecificFields* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.contact_id_) {},
        decltype(_impl_.secret_) {}, decltype(_impl_.peer_public_key_x962_) {}, decltype(_impl_.google_credential_id_) {},
        decltype(_impl_.tunnel_server_domain_) {}, decltype(_impl_.id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.contact_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contact_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_contact_id()) {
        _this->_impl_.contact_id_.Set(from._internal_contact_id(), _this->GetArenaForAllocation());
    }
    _impl_.secret_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secret_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_secret()) {
        _this->_impl_.secret_.Set(from._internal_secret(), _this->GetArenaForAllocation());
    }
    _impl_.peer_public_key_x962_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.peer_public_key_x962_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_peer_public_key_x962()) {
        _this->_impl_.peer_public_key_x962_.Set(from._internal_peer_public_key_x962(), _this->GetArenaForAllocation());
    }
    _impl_.google_credential_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.google_credential_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_google_credential_id()) {
        _this->_impl_.google_credential_id_.Set(from._internal_google_credential_id(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.tunnel_server_domain_, &from._impl_.tunnel_server_domain_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.id_) - reinterpret_cast<char*>(&_impl_.tunnel_server_domain_)) + sizeof(_impl_.id_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.PhoneAsASecurityKeySpecificFields)
}

inline void PhoneAsASecurityKeySpecificFields::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.contact_id_) {}, decltype(_impl_.secret_) {},
        decltype(_impl_.peer_public_key_x962_) {}, decltype(_impl_.google_credential_id_) {}, decltype(_impl_.tunnel_server_domain_) { 0u },
        decltype(_impl_.id_) { 0u } };
    _impl_.contact_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.contact_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secret_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.secret_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.peer_public_key_x962_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.peer_public_key_x962_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.google_credential_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.google_credential_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PhoneAsASecurityKeySpecificFields::~PhoneAsASecurityKeySpecificFields()
{
    // @@protoc_insertion_point(destructor:sync_pb.PhoneAsASecurityKeySpecificFields)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PhoneAsASecurityKeySpecificFields::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.contact_id_.Destroy();
    _impl_.secret_.Destroy();
    _impl_.peer_public_key_x962_.Destroy();
    _impl_.google_credential_id_.Destroy();
}

void PhoneAsASecurityKeySpecificFields::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PhoneAsASecurityKeySpecificFields::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.PhoneAsASecurityKeySpecificFields)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.contact_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.secret_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.peer_public_key_x962_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.google_credential_id_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00000030u) {
        ::memset(&_impl_.tunnel_server_domain_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.id_) - reinterpret_cast<char*>(&_impl_.tunnel_server_domain_)) + sizeof(_impl_.id_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PhoneAsASecurityKeySpecificFields::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint32 tunnel_server_domain = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_tunnel_server_domain(&has_bits);
                _impl_.tunnel_server_domain_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes contact_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_contact_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes secret = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_secret();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional fixed32 id = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
                _Internal::set_has_id(&has_bits);
                _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
                ptr += sizeof(uint32_t);
            } else
                goto handle_unusual;
            continue;
        // optional bytes peer_public_key_x962 = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_peer_public_key_x962();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes google_credential_id = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_google_credential_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PhoneAsASecurityKeySpecificFields::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PhoneAsASecurityKeySpecificFields)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint32 tunnel_server_domain = 1;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_tunnel_server_domain(), target);
    }

    // optional bytes contact_id = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_contact_id(), target);
    }

    // optional bytes secret = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(3, this->_internal_secret(), target);
    }

    // optional fixed32 id = 4;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_id(), target);
    }

    // optional bytes peer_public_key_x962 = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteBytesMaybeAliased(5, this->_internal_peer_public_key_x962(), target);
    }

    // optional bytes google_credential_id = 6;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteBytesMaybeAliased(6, this->_internal_google_credential_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PhoneAsASecurityKeySpecificFields)
    return target;
}

size_t PhoneAsASecurityKeySpecificFields::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.PhoneAsASecurityKeySpecificFields)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional bytes contact_id = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_contact_id());
        }

        // optional bytes secret = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_secret());
        }

        // optional bytes peer_public_key_x962 = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_peer_public_key_x962());
        }

        // optional bytes google_credential_id = 6;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_google_credential_id());
        }

        // optional uint32 tunnel_server_domain = 1;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tunnel_server_domain());
        }

        // optional fixed32 id = 4;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 4;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PhoneAsASecurityKeySpecificFields::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PhoneAsASecurityKeySpecificFields*>(&from));
}

void PhoneAsASecurityKeySpecificFields::MergeFrom(const PhoneAsASecurityKeySpecificFields& from)
{
    PhoneAsASecurityKeySpecificFields* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PhoneAsASecurityKeySpecificFields)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_contact_id(from._internal_contact_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_secret(from._internal_secret());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_peer_public_key_x962(from._internal_peer_public_key_x962());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_google_credential_id(from._internal_google_credential_id());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.tunnel_server_domain_ = from._impl_.tunnel_server_domain_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.id_ = from._impl_.id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PhoneAsASecurityKeySpecificFields::CopyFrom(const PhoneAsASecurityKeySpecificFields& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PhoneAsASecurityKeySpecificFields)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PhoneAsASecurityKeySpecificFields::IsInitialized() const
{
    return true;
}

void PhoneAsASecurityKeySpecificFields::InternalSwap(PhoneAsASecurityKeySpecificFields* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.contact_id_, lhs_arena, &other->_impl_.contact_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.secret_, lhs_arena, &other->_impl_.secret_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.peer_public_key_x962_, lhs_arena, &other->_impl_.peer_public_key_x962_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.google_credential_id_, lhs_arena, &other->_impl_.google_credential_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PhoneAsASecurityKeySpecificFields, _impl_.id_)
        + sizeof(PhoneAsASecurityKeySpecificFields::_impl_.id_) - PROTOBUF_FIELD_OFFSET(PhoneAsASecurityKeySpecificFields, _impl_.tunnel_server_domain_)>(
        reinterpret_cast<char*>(&_impl_.tunnel_server_domain_), reinterpret_cast<char*>(&other->_impl_.tunnel_server_domain_));
}

std::string PhoneAsASecurityKeySpecificFields::GetTypeName() const
{
    return "sync_pb.PhoneAsASecurityKeySpecificFields";
}

// ===================================================================

class ChromeVersionInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ChromeVersionInfo>()._impl_._has_bits_);
    static void set_has_version_number(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ChromeVersionInfo::ChromeVersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.ChromeVersionInfo)
}
ChromeVersionInfo::ChromeVersionInfo(const ChromeVersionInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ChromeVersionInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.version_number_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.version_number_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_number_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_version_number()) {
        _this->_impl_.version_number_.Set(from._internal_version_number(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.ChromeVersionInfo)
}

inline void ChromeVersionInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.version_number_) {} };
    _impl_.version_number_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_number_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChromeVersionInfo::~ChromeVersionInfo()
{
    // @@protoc_insertion_point(destructor:sync_pb.ChromeVersionInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ChromeVersionInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.version_number_.Destroy();
}

void ChromeVersionInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ChromeVersionInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.ChromeVersionInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.version_number_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ChromeVersionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string version_number = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_version_number();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ChromeVersionInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ChromeVersionInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string version_number = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_version_number(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ChromeVersionInfo)
    return target;
}

size_t ChromeVersionInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.ChromeVersionInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string version_number = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_version_number());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ChromeVersionInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ChromeVersionInfo*>(&from));
}

void ChromeVersionInfo::MergeFrom(const ChromeVersionInfo& from)
{
    ChromeVersionInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ChromeVersionInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_version_number()) {
        _this->_internal_set_version_number(from._internal_version_number());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeVersionInfo::CopyFrom(const ChromeVersionInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ChromeVersionInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ChromeVersionInfo::IsInitialized() const
{
    return true;
}

void ChromeVersionInfo::InternalSwap(ChromeVersionInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.version_number_, lhs_arena, &other->_impl_.version_number_, rhs_arena);
}

std::string ChromeVersionInfo::GetTypeName() const
{
    return "sync_pb.ChromeVersionInfo";
}

// ===================================================================

class GooglePlayServicesVersionInfo::_Internal {
public:
    using HasBits = decltype(std::declval<GooglePlayServicesVersionInfo>()._impl_._has_bits_);
    static void set_has_apk_version_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

GooglePlayServicesVersionInfo::GooglePlayServicesVersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.GooglePlayServicesVersionInfo)
}
GooglePlayServicesVersionInfo::GooglePlayServicesVersionInfo(const GooglePlayServicesVersionInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GooglePlayServicesVersionInfo* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.apk_version_name_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.apk_version_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.apk_version_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_apk_version_name()) {
        _this->_impl_.apk_version_name_.Set(from._internal_apk_version_name(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.GooglePlayServicesVersionInfo)
}

inline void GooglePlayServicesVersionInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.apk_version_name_) {} };
    _impl_.apk_version_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.apk_version_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GooglePlayServicesVersionInfo::~GooglePlayServicesVersionInfo()
{
    // @@protoc_insertion_point(destructor:sync_pb.GooglePlayServicesVersionInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GooglePlayServicesVersionInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.apk_version_name_.Destroy();
}

void GooglePlayServicesVersionInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GooglePlayServicesVersionInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.GooglePlayServicesVersionInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.apk_version_name_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* GooglePlayServicesVersionInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string apk_version_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_apk_version_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GooglePlayServicesVersionInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.GooglePlayServicesVersionInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string apk_version_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_apk_version_name(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.GooglePlayServicesVersionInfo)
    return target;
}

size_t GooglePlayServicesVersionInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.GooglePlayServicesVersionInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string apk_version_name = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_apk_version_name());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GooglePlayServicesVersionInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GooglePlayServicesVersionInfo*>(&from));
}

void GooglePlayServicesVersionInfo::MergeFrom(const GooglePlayServicesVersionInfo& from)
{
    GooglePlayServicesVersionInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.GooglePlayServicesVersionInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_apk_version_name()) {
        _this->_internal_set_apk_version_name(from._internal_apk_version_name());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GooglePlayServicesVersionInfo::CopyFrom(const GooglePlayServicesVersionInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.GooglePlayServicesVersionInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GooglePlayServicesVersionInfo::IsInitialized() const
{
    return true;
}

void GooglePlayServicesVersionInfo::InternalSwap(GooglePlayServicesVersionInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.apk_version_name_, lhs_arena, &other->_impl_.apk_version_name_, rhs_arena);
}

std::string GooglePlayServicesVersionInfo::GetTypeName() const
{
    return "sync_pb.GooglePlayServicesVersionInfo";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::sync_pb::DeviceInfoSpecifics* Arena::CreateMaybeMessage<::sync_pb::DeviceInfoSpecifics>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::DeviceInfoSpecifics>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::FeatureSpecificFields* Arena::CreateMaybeMessage<::sync_pb::FeatureSpecificFields>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::FeatureSpecificFields>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::SharingSpecificFields* Arena::CreateMaybeMessage<::sync_pb::SharingSpecificFields>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::SharingSpecificFields>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::InvalidationSpecificFields* Arena::CreateMaybeMessage<::sync_pb::InvalidationSpecificFields>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::InvalidationSpecificFields>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::PhoneAsASecurityKeySpecificFields* Arena::CreateMaybeMessage<::sync_pb::PhoneAsASecurityKeySpecificFields>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::PhoneAsASecurityKeySpecificFields>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::ChromeVersionInfo* Arena::CreateMaybeMessage<::sync_pb::ChromeVersionInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::ChromeVersionInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::GooglePlayServicesVersionInfo* Arena::CreateMaybeMessage<::sync_pb::GooglePlayServicesVersionInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::GooglePlayServicesVersionInfo>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
