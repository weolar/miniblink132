// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/device_info_specifics.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/sync/protocol/sync_enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto {
    static const uint32_t offsets[];
};
namespace sync_pb {
class ChromeVersionInfo;
struct ChromeVersionInfoDefaultTypeInternal;
extern ChromeVersionInfoDefaultTypeInternal _ChromeVersionInfo_default_instance_;
class DeviceInfoSpecifics;
struct DeviceInfoSpecificsDefaultTypeInternal;
extern DeviceInfoSpecificsDefaultTypeInternal _DeviceInfoSpecifics_default_instance_;
class FeatureSpecificFields;
struct FeatureSpecificFieldsDefaultTypeInternal;
extern FeatureSpecificFieldsDefaultTypeInternal _FeatureSpecificFields_default_instance_;
class GooglePlayServicesVersionInfo;
struct GooglePlayServicesVersionInfoDefaultTypeInternal;
extern GooglePlayServicesVersionInfoDefaultTypeInternal _GooglePlayServicesVersionInfo_default_instance_;
class InvalidationSpecificFields;
struct InvalidationSpecificFieldsDefaultTypeInternal;
extern InvalidationSpecificFieldsDefaultTypeInternal _InvalidationSpecificFields_default_instance_;
class PhoneAsASecurityKeySpecificFields;
struct PhoneAsASecurityKeySpecificFieldsDefaultTypeInternal;
extern PhoneAsASecurityKeySpecificFieldsDefaultTypeInternal _PhoneAsASecurityKeySpecificFields_default_instance_;
class SharingSpecificFields;
struct SharingSpecificFieldsDefaultTypeInternal;
extern SharingSpecificFieldsDefaultTypeInternal _SharingSpecificFields_default_instance_;
} // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template <>::sync_pb::ChromeVersionInfo* Arena::CreateMaybeMessage<::sync_pb::ChromeVersionInfo>(Arena*);
template <>::sync_pb::DeviceInfoSpecifics* Arena::CreateMaybeMessage<::sync_pb::DeviceInfoSpecifics>(Arena*);
template <>::sync_pb::FeatureSpecificFields* Arena::CreateMaybeMessage<::sync_pb::FeatureSpecificFields>(Arena*);
template <>::sync_pb::GooglePlayServicesVersionInfo* Arena::CreateMaybeMessage<::sync_pb::GooglePlayServicesVersionInfo>(Arena*);
template <>::sync_pb::InvalidationSpecificFields* Arena::CreateMaybeMessage<::sync_pb::InvalidationSpecificFields>(Arena*);
template <>::sync_pb::PhoneAsASecurityKeySpecificFields* Arena::CreateMaybeMessage<::sync_pb::PhoneAsASecurityKeySpecificFields>(Arena*);
template <>::sync_pb::SharingSpecificFields* Arena::CreateMaybeMessage<::sync_pb::SharingSpecificFields>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sync_pb {

enum SharingSpecificFields_EnabledFeatures : int {
    SharingSpecificFields_EnabledFeatures_UNKNOWN = 0,
    SharingSpecificFields_EnabledFeatures_CLICK_TO_CALL_VAPID = 1,
    SharingSpecificFields_EnabledFeatures_SHARED_CLIPBOARD_VAPID = 2,
    SharingSpecificFields_EnabledFeatures_SMS_FETCHER = 3,
    SharingSpecificFields_EnabledFeatures_REMOTE_COPY = 4,
    SharingSpecificFields_EnabledFeatures_DISCOVERY = 6,
    SharingSpecificFields_EnabledFeatures_CLICK_TO_CALL_V2 = 7,
    SharingSpecificFields_EnabledFeatures_SHARED_CLIPBOARD_V2 = 8,
    SharingSpecificFields_EnabledFeatures_OPTIMIZATION_GUIDE_PUSH_NOTIFICATION = 9
};
bool SharingSpecificFields_EnabledFeatures_IsValid(int value);
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields_EnabledFeatures_EnabledFeatures_MIN = SharingSpecificFields_EnabledFeatures_UNKNOWN;
constexpr SharingSpecificFields_EnabledFeatures SharingSpecificFields_EnabledFeatures_EnabledFeatures_MAX
    = SharingSpecificFields_EnabledFeatures_OPTIMIZATION_GUIDE_PUSH_NOTIFICATION;
constexpr int SharingSpecificFields_EnabledFeatures_EnabledFeatures_ARRAYSIZE = SharingSpecificFields_EnabledFeatures_EnabledFeatures_MAX + 1;

const std::string& SharingSpecificFields_EnabledFeatures_Name(SharingSpecificFields_EnabledFeatures value);
template <typename T> inline const std::string& SharingSpecificFields_EnabledFeatures_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, SharingSpecificFields_EnabledFeatures>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function SharingSpecificFields_EnabledFeatures_Name.");
    return SharingSpecificFields_EnabledFeatures_Name(static_cast<SharingSpecificFields_EnabledFeatures>(enum_t_value));
}
bool SharingSpecificFields_EnabledFeatures_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SharingSpecificFields_EnabledFeatures* value);
// ===================================================================

class DeviceInfoSpecifics final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.DeviceInfoSpecifics) */ {
public:
    inline DeviceInfoSpecifics()
        : DeviceInfoSpecifics(nullptr)
    {
    }
    ~DeviceInfoSpecifics() override;
    explicit PROTOBUF_CONSTEXPR DeviceInfoSpecifics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    DeviceInfoSpecifics(const DeviceInfoSpecifics& from);
    DeviceInfoSpecifics(DeviceInfoSpecifics&& from) noexcept
        : DeviceInfoSpecifics()
    {
        *this = ::std::move(from);
    }

    inline DeviceInfoSpecifics& operator=(const DeviceInfoSpecifics& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DeviceInfoSpecifics& operator=(DeviceInfoSpecifics&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const DeviceInfoSpecifics& default_instance()
    {
        return *internal_default_instance();
    }
    enum ClientVersionInfoCase {
        kChromeVersionInfo = 17,
        kGooglePlayServicesVersionInfo = 18,
        CLIENT_VERSION_INFO_NOT_SET = 0,
    };

    static inline const DeviceInfoSpecifics* internal_default_instance()
    {
        return reinterpret_cast<const DeviceInfoSpecifics*>(&_DeviceInfoSpecifics_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(DeviceInfoSpecifics& a, DeviceInfoSpecifics& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(DeviceInfoSpecifics* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DeviceInfoSpecifics* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DeviceInfoSpecifics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<DeviceInfoSpecifics>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const DeviceInfoSpecifics& from);
    void MergeFrom(const DeviceInfoSpecifics& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DeviceInfoSpecifics* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.DeviceInfoSpecifics";
    }

protected:
    explicit DeviceInfoSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCacheGuidFieldNumber = 1,
        kClientNameFieldNumber = 2,
        kSyncUserAgentFieldNumber = 4,
        kChromeVersionFieldNumber = 5,
        kSigninScopedDeviceIdFieldNumber = 7,
        kModelFieldNumber = 11,
        kManufacturerFieldNumber = 12,
        kFullHardwareClassFieldNumber = 16,
        kFeatureFieldsFieldNumber = 9,
        kSharingFieldsFieldNumber = 10,
        kInvalidationFieldsFieldNumber = 14,
        kPaaskFieldsFieldNumber = 15,
        kDeprecatedBackupTimestampFieldNumber = 6,
        kLastUpdatedTimestampFieldNumber = 8,
        kDeviceTypeFieldNumber = 3,
        kPulseIntervalInMinutesFieldNumber = 13,
        kOsTypeFieldNumber = 19,
        kDeviceFormFactorFieldNumber = 20,
        kChromeVersionInfoFieldNumber = 17,
        kGooglePlayServicesVersionInfoFieldNumber = 18,
    };
    // optional string cache_guid = 1;
    bool has_cache_guid() const;

private:
    bool _internal_has_cache_guid() const;

public:
    void clear_cache_guid();
    const std::string& cache_guid() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_cache_guid(ArgT0&& arg0, ArgT... args);
    std::string* mutable_cache_guid();
    PROTOBUF_NODISCARD std::string* release_cache_guid();
    void set_allocated_cache_guid(std::string* cache_guid);

private:
    const std::string& _internal_cache_guid() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_cache_guid(const std::string& value);
    std::string* _internal_mutable_cache_guid();

public:
    // optional string client_name = 2;
    bool has_client_name() const;

private:
    bool _internal_has_client_name() const;

public:
    void clear_client_name();
    const std::string& client_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_client_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_client_name();
    PROTOBUF_NODISCARD std::string* release_client_name();
    void set_allocated_client_name(std::string* client_name);

private:
    const std::string& _internal_client_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(const std::string& value);
    std::string* _internal_mutable_client_name();

public:
    // optional string sync_user_agent = 4;
    bool has_sync_user_agent() const;

private:
    bool _internal_has_sync_user_agent() const;

public:
    void clear_sync_user_agent();
    const std::string& sync_user_agent() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_sync_user_agent(ArgT0&& arg0, ArgT... args);
    std::string* mutable_sync_user_agent();
    PROTOBUF_NODISCARD std::string* release_sync_user_agent();
    void set_allocated_sync_user_agent(std::string* sync_user_agent);

private:
    const std::string& _internal_sync_user_agent() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_sync_user_agent(const std::string& value);
    std::string* _internal_mutable_sync_user_agent();

public:
    // optional string chrome_version = 5 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_chrome_version() const;

private:
    bool _internal_has_chrome_version() const;

public:
    PROTOBUF_DEPRECATED void clear_chrome_version();
    PROTOBUF_DEPRECATED const std::string& chrome_version() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_chrome_version(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_chrome_version();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_chrome_version();
    PROTOBUF_DEPRECATED void set_allocated_chrome_version(std::string* chrome_version);

private:
    const std::string& _internal_chrome_version() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_chrome_version(const std::string& value);
    std::string* _internal_mutable_chrome_version();

public:
    // optional string signin_scoped_device_id = 7;
    bool has_signin_scoped_device_id() const;

private:
    bool _internal_has_signin_scoped_device_id() const;

public:
    void clear_signin_scoped_device_id();
    const std::string& signin_scoped_device_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_signin_scoped_device_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_signin_scoped_device_id();
    PROTOBUF_NODISCARD std::string* release_signin_scoped_device_id();
    void set_allocated_signin_scoped_device_id(std::string* signin_scoped_device_id);

private:
    const std::string& _internal_signin_scoped_device_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_signin_scoped_device_id(const std::string& value);
    std::string* _internal_mutable_signin_scoped_device_id();

public:
    // optional string model = 11;
    bool has_model() const;

private:
    bool _internal_has_model() const;

public:
    void clear_model();
    const std::string& model() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_model(ArgT0&& arg0, ArgT... args);
    std::string* mutable_model();
    PROTOBUF_NODISCARD std::string* release_model();
    void set_allocated_model(std::string* model);

private:
    const std::string& _internal_model() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
    std::string* _internal_mutable_model();

public:
    // optional string manufacturer = 12;
    bool has_manufacturer() const;

private:
    bool _internal_has_manufacturer() const;

public:
    void clear_manufacturer();
    const std::string& manufacturer() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_manufacturer(ArgT0&& arg0, ArgT... args);
    std::string* mutable_manufacturer();
    PROTOBUF_NODISCARD std::string* release_manufacturer();
    void set_allocated_manufacturer(std::string* manufacturer);

private:
    const std::string& _internal_manufacturer() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_manufacturer(const std::string& value);
    std::string* _internal_mutable_manufacturer();

public:
    // optional string full_hardware_class = 16;
    bool has_full_hardware_class() const;

private:
    bool _internal_has_full_hardware_class() const;

public:
    void clear_full_hardware_class();
    const std::string& full_hardware_class() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_full_hardware_class(ArgT0&& arg0, ArgT... args);
    std::string* mutable_full_hardware_class();
    PROTOBUF_NODISCARD std::string* release_full_hardware_class();
    void set_allocated_full_hardware_class(std::string* full_hardware_class);

private:
    const std::string& _internal_full_hardware_class() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_hardware_class(const std::string& value);
    std::string* _internal_mutable_full_hardware_class();

public:
    // optional .sync_pb.FeatureSpecificFields feature_fields = 9;
    bool has_feature_fields() const;

private:
    bool _internal_has_feature_fields() const;

public:
    void clear_feature_fields();
    const ::sync_pb::FeatureSpecificFields& feature_fields() const;
    PROTOBUF_NODISCARD ::sync_pb::FeatureSpecificFields* release_feature_fields();
    ::sync_pb::FeatureSpecificFields* mutable_feature_fields();
    void set_allocated_feature_fields(::sync_pb::FeatureSpecificFields* feature_fields);

private:
    const ::sync_pb::FeatureSpecificFields& _internal_feature_fields() const;
    ::sync_pb::FeatureSpecificFields* _internal_mutable_feature_fields();

public:
    void unsafe_arena_set_allocated_feature_fields(::sync_pb::FeatureSpecificFields* feature_fields);
    ::sync_pb::FeatureSpecificFields* unsafe_arena_release_feature_fields();

    // optional .sync_pb.SharingSpecificFields sharing_fields = 10;
    bool has_sharing_fields() const;

private:
    bool _internal_has_sharing_fields() const;

public:
    void clear_sharing_fields();
    const ::sync_pb::SharingSpecificFields& sharing_fields() const;
    PROTOBUF_NODISCARD ::sync_pb::SharingSpecificFields* release_sharing_fields();
    ::sync_pb::SharingSpecificFields* mutable_sharing_fields();
    void set_allocated_sharing_fields(::sync_pb::SharingSpecificFields* sharing_fields);

private:
    const ::sync_pb::SharingSpecificFields& _internal_sharing_fields() const;
    ::sync_pb::SharingSpecificFields* _internal_mutable_sharing_fields();

public:
    void unsafe_arena_set_allocated_sharing_fields(::sync_pb::SharingSpecificFields* sharing_fields);
    ::sync_pb::SharingSpecificFields* unsafe_arena_release_sharing_fields();

    // optional .sync_pb.InvalidationSpecificFields invalidation_fields = 14;
    bool has_invalidation_fields() const;

private:
    bool _internal_has_invalidation_fields() const;

public:
    void clear_invalidation_fields();
    const ::sync_pb::InvalidationSpecificFields& invalidation_fields() const;
    PROTOBUF_NODISCARD ::sync_pb::InvalidationSpecificFields* release_invalidation_fields();
    ::sync_pb::InvalidationSpecificFields* mutable_invalidation_fields();
    void set_allocated_invalidation_fields(::sync_pb::InvalidationSpecificFields* invalidation_fields);

private:
    const ::sync_pb::InvalidationSpecificFields& _internal_invalidation_fields() const;
    ::sync_pb::InvalidationSpecificFields* _internal_mutable_invalidation_fields();

public:
    void unsafe_arena_set_allocated_invalidation_fields(::sync_pb::InvalidationSpecificFields* invalidation_fields);
    ::sync_pb::InvalidationSpecificFields* unsafe_arena_release_invalidation_fields();

    // optional .sync_pb.PhoneAsASecurityKeySpecificFields paask_fields = 15;
    bool has_paask_fields() const;

private:
    bool _internal_has_paask_fields() const;

public:
    void clear_paask_fields();
    const ::sync_pb::PhoneAsASecurityKeySpecificFields& paask_fields() const;
    PROTOBUF_NODISCARD ::sync_pb::PhoneAsASecurityKeySpecificFields* release_paask_fields();
    ::sync_pb::PhoneAsASecurityKeySpecificFields* mutable_paask_fields();
    void set_allocated_paask_fields(::sync_pb::PhoneAsASecurityKeySpecificFields* paask_fields);

private:
    const ::sync_pb::PhoneAsASecurityKeySpecificFields& _internal_paask_fields() const;
    ::sync_pb::PhoneAsASecurityKeySpecificFields* _internal_mutable_paask_fields();

public:
    void unsafe_arena_set_allocated_paask_fields(::sync_pb::PhoneAsASecurityKeySpecificFields* paask_fields);
    ::sync_pb::PhoneAsASecurityKeySpecificFields* unsafe_arena_release_paask_fields();

    // optional int64 deprecated_backup_timestamp = 6 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_deprecated_backup_timestamp() const;

private:
    bool _internal_has_deprecated_backup_timestamp() const;

public:
    PROTOBUF_DEPRECATED void clear_deprecated_backup_timestamp();
    PROTOBUF_DEPRECATED int64_t deprecated_backup_timestamp() const;
    PROTOBUF_DEPRECATED void set_deprecated_backup_timestamp(int64_t value);

private:
    int64_t _internal_deprecated_backup_timestamp() const;
    void _internal_set_deprecated_backup_timestamp(int64_t value);

public:
    // optional int64 last_updated_timestamp = 8;
    bool has_last_updated_timestamp() const;

private:
    bool _internal_has_last_updated_timestamp() const;

public:
    void clear_last_updated_timestamp();
    int64_t last_updated_timestamp() const;
    void set_last_updated_timestamp(int64_t value);

private:
    int64_t _internal_last_updated_timestamp() const;
    void _internal_set_last_updated_timestamp(int64_t value);

public:
    // optional .sync_pb.SyncEnums.DeviceType device_type = 3 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_device_type() const;

private:
    bool _internal_has_device_type() const;

public:
    PROTOBUF_DEPRECATED void clear_device_type();
    PROTOBUF_DEPRECATED ::sync_pb::SyncEnums_DeviceType device_type() const;
    PROTOBUF_DEPRECATED void set_device_type(::sync_pb::SyncEnums_DeviceType value);

private:
    ::sync_pb::SyncEnums_DeviceType _internal_device_type() const;
    void _internal_set_device_type(::sync_pb::SyncEnums_DeviceType value);

public:
    // optional int32 pulse_interval_in_minutes = 13;
    bool has_pulse_interval_in_minutes() const;

private:
    bool _internal_has_pulse_interval_in_minutes() const;

public:
    void clear_pulse_interval_in_minutes();
    int32_t pulse_interval_in_minutes() const;
    void set_pulse_interval_in_minutes(int32_t value);

private:
    int32_t _internal_pulse_interval_in_minutes() const;
    void _internal_set_pulse_interval_in_minutes(int32_t value);

public:
    // optional .sync_pb.SyncEnums.OsType os_type = 19;
    bool has_os_type() const;

private:
    bool _internal_has_os_type() const;

public:
    void clear_os_type();
    ::sync_pb::SyncEnums_OsType os_type() const;
    void set_os_type(::sync_pb::SyncEnums_OsType value);

private:
    ::sync_pb::SyncEnums_OsType _internal_os_type() const;
    void _internal_set_os_type(::sync_pb::SyncEnums_OsType value);

public:
    // optional .sync_pb.SyncEnums.DeviceFormFactor device_form_factor = 20;
    bool has_device_form_factor() const;

private:
    bool _internal_has_device_form_factor() const;

public:
    void clear_device_form_factor();
    ::sync_pb::SyncEnums_DeviceFormFactor device_form_factor() const;
    void set_device_form_factor(::sync_pb::SyncEnums_DeviceFormFactor value);

private:
    ::sync_pb::SyncEnums_DeviceFormFactor _internal_device_form_factor() const;
    void _internal_set_device_form_factor(::sync_pb::SyncEnums_DeviceFormFactor value);

public:
    // .sync_pb.ChromeVersionInfo chrome_version_info = 17;
    bool has_chrome_version_info() const;

private:
    bool _internal_has_chrome_version_info() const;

public:
    void clear_chrome_version_info();
    const ::sync_pb::ChromeVersionInfo& chrome_version_info() const;
    PROTOBUF_NODISCARD ::sync_pb::ChromeVersionInfo* release_chrome_version_info();
    ::sync_pb::ChromeVersionInfo* mutable_chrome_version_info();
    void set_allocated_chrome_version_info(::sync_pb::ChromeVersionInfo* chrome_version_info);

private:
    const ::sync_pb::ChromeVersionInfo& _internal_chrome_version_info() const;
    ::sync_pb::ChromeVersionInfo* _internal_mutable_chrome_version_info();

public:
    void unsafe_arena_set_allocated_chrome_version_info(::sync_pb::ChromeVersionInfo* chrome_version_info);
    ::sync_pb::ChromeVersionInfo* unsafe_arena_release_chrome_version_info();

    // .sync_pb.GooglePlayServicesVersionInfo google_play_services_version_info = 18;
    bool has_google_play_services_version_info() const;

private:
    bool _internal_has_google_play_services_version_info() const;

public:
    void clear_google_play_services_version_info();
    const ::sync_pb::GooglePlayServicesVersionInfo& google_play_services_version_info() const;
    PROTOBUF_NODISCARD ::sync_pb::GooglePlayServicesVersionInfo* release_google_play_services_version_info();
    ::sync_pb::GooglePlayServicesVersionInfo* mutable_google_play_services_version_info();
    void set_allocated_google_play_services_version_info(::sync_pb::GooglePlayServicesVersionInfo* google_play_services_version_info);

private:
    const ::sync_pb::GooglePlayServicesVersionInfo& _internal_google_play_services_version_info() const;
    ::sync_pb::GooglePlayServicesVersionInfo* _internal_mutable_google_play_services_version_info();

public:
    void unsafe_arena_set_allocated_google_play_services_version_info(::sync_pb::GooglePlayServicesVersionInfo* google_play_services_version_info);
    ::sync_pb::GooglePlayServicesVersionInfo* unsafe_arena_release_google_play_services_version_info();

    void clear_client_version_info();
    ClientVersionInfoCase client_version_info_case() const;
    // @@protoc_insertion_point(class_scope:sync_pb.DeviceInfoSpecifics)
private:
    class _Internal;
    void set_has_chrome_version_info();
    void set_has_google_play_services_version_info();

    inline bool has_client_version_info() const;
    inline void clear_has_client_version_info();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cache_guid_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sync_user_agent_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chrome_version_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signin_scoped_device_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manufacturer_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_hardware_class_;
        ::sync_pb::FeatureSpecificFields* feature_fields_;
        ::sync_pb::SharingSpecificFields* sharing_fields_;
        ::sync_pb::InvalidationSpecificFields* invalidation_fields_;
        ::sync_pb::PhoneAsASecurityKeySpecificFields* paask_fields_;
        int64_t deprecated_backup_timestamp_;
        int64_t last_updated_timestamp_;
        int device_type_;
        int32_t pulse_interval_in_minutes_;
        int os_type_;
        int device_form_factor_;
        union ClientVersionInfoUnion {
            constexpr ClientVersionInfoUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::sync_pb::ChromeVersionInfo* chrome_version_info_;
            ::sync_pb::GooglePlayServicesVersionInfo* google_play_services_version_info_;
        } client_version_info_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class FeatureSpecificFields final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.FeatureSpecificFields) */ {
public:
    inline FeatureSpecificFields()
        : FeatureSpecificFields(nullptr)
    {
    }
    ~FeatureSpecificFields() override;
    explicit PROTOBUF_CONSTEXPR FeatureSpecificFields(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FeatureSpecificFields(const FeatureSpecificFields& from);
    FeatureSpecificFields(FeatureSpecificFields&& from) noexcept
        : FeatureSpecificFields()
    {
        *this = ::std::move(from);
    }

    inline FeatureSpecificFields& operator=(const FeatureSpecificFields& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FeatureSpecificFields& operator=(FeatureSpecificFields&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const FeatureSpecificFields& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FeatureSpecificFields* internal_default_instance()
    {
        return reinterpret_cast<const FeatureSpecificFields*>(&_FeatureSpecificFields_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(FeatureSpecificFields& a, FeatureSpecificFields& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FeatureSpecificFields* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FeatureSpecificFields* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FeatureSpecificFields* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FeatureSpecificFields>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FeatureSpecificFields& from);
    void MergeFrom(const FeatureSpecificFields& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FeatureSpecificFields* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.FeatureSpecificFields";
    }

protected:
    explicit FeatureSpecificFields(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSendTabToSelfReceivingEnabledFieldNumber = 1,
        kSendTabToSelfReceivingTypeFieldNumber = 2,
        kFloatingWorkspaceLastSigninTimeWindowsEpochMicrosFieldNumber = 3,
    };
    // optional bool send_tab_to_self_receiving_enabled = 1;
    bool has_send_tab_to_self_receiving_enabled() const;

private:
    bool _internal_has_send_tab_to_self_receiving_enabled() const;

public:
    void clear_send_tab_to_self_receiving_enabled();
    bool send_tab_to_self_receiving_enabled() const;
    void set_send_tab_to_self_receiving_enabled(bool value);

private:
    bool _internal_send_tab_to_self_receiving_enabled() const;
    void _internal_set_send_tab_to_self_receiving_enabled(bool value);

public:
    // optional .sync_pb.SyncEnums.SendTabReceivingType send_tab_to_self_receiving_type = 2;
    bool has_send_tab_to_self_receiving_type() const;

private:
    bool _internal_has_send_tab_to_self_receiving_type() const;

public:
    void clear_send_tab_to_self_receiving_type();
    ::sync_pb::SyncEnums_SendTabReceivingType send_tab_to_self_receiving_type() const;
    void set_send_tab_to_self_receiving_type(::sync_pb::SyncEnums_SendTabReceivingType value);

private:
    ::sync_pb::SyncEnums_SendTabReceivingType _internal_send_tab_to_self_receiving_type() const;
    void _internal_set_send_tab_to_self_receiving_type(::sync_pb::SyncEnums_SendTabReceivingType value);

public:
    // optional int64 floating_workspace_last_signin_time_windows_epoch_micros = 3;
    bool has_floating_workspace_last_signin_time_windows_epoch_micros() const;

private:
    bool _internal_has_floating_workspace_last_signin_time_windows_epoch_micros() const;

public:
    void clear_floating_workspace_last_signin_time_windows_epoch_micros();
    int64_t floating_workspace_last_signin_time_windows_epoch_micros() const;
    void set_floating_workspace_last_signin_time_windows_epoch_micros(int64_t value);

private:
    int64_t _internal_floating_workspace_last_signin_time_windows_epoch_micros() const;
    void _internal_set_floating_workspace_last_signin_time_windows_epoch_micros(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.FeatureSpecificFields)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        bool send_tab_to_self_receiving_enabled_;
        int send_tab_to_self_receiving_type_;
        int64_t floating_workspace_last_signin_time_windows_epoch_micros_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class SharingSpecificFields final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.SharingSpecificFields) */ {
public:
    inline SharingSpecificFields()
        : SharingSpecificFields(nullptr)
    {
    }
    ~SharingSpecificFields() override;
    explicit PROTOBUF_CONSTEXPR SharingSpecificFields(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SharingSpecificFields(const SharingSpecificFields& from);
    SharingSpecificFields(SharingSpecificFields&& from) noexcept
        : SharingSpecificFields()
    {
        *this = ::std::move(from);
    }

    inline SharingSpecificFields& operator=(const SharingSpecificFields& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SharingSpecificFields& operator=(SharingSpecificFields&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SharingSpecificFields& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SharingSpecificFields* internal_default_instance()
    {
        return reinterpret_cast<const SharingSpecificFields*>(&_SharingSpecificFields_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(SharingSpecificFields& a, SharingSpecificFields& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SharingSpecificFields* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SharingSpecificFields* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SharingSpecificFields* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SharingSpecificFields>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SharingSpecificFields& from);
    void MergeFrom(const SharingSpecificFields& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SharingSpecificFields* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.SharingSpecificFields";
    }

protected:
    explicit SharingSpecificFields(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef SharingSpecificFields_EnabledFeatures EnabledFeatures;
    static constexpr EnabledFeatures UNKNOWN = SharingSpecificFields_EnabledFeatures_UNKNOWN;
    static constexpr EnabledFeatures CLICK_TO_CALL_VAPID = SharingSpecificFields_EnabledFeatures_CLICK_TO_CALL_VAPID;
    static constexpr EnabledFeatures SHARED_CLIPBOARD_VAPID = SharingSpecificFields_EnabledFeatures_SHARED_CLIPBOARD_VAPID;
    static constexpr EnabledFeatures SMS_FETCHER = SharingSpecificFields_EnabledFeatures_SMS_FETCHER;
    static constexpr EnabledFeatures REMOTE_COPY = SharingSpecificFields_EnabledFeatures_REMOTE_COPY;
    static constexpr EnabledFeatures DISCOVERY = SharingSpecificFields_EnabledFeatures_DISCOVERY;
    static constexpr EnabledFeatures CLICK_TO_CALL_V2 = SharingSpecificFields_EnabledFeatures_CLICK_TO_CALL_V2;
    static constexpr EnabledFeatures SHARED_CLIPBOARD_V2 = SharingSpecificFields_EnabledFeatures_SHARED_CLIPBOARD_V2;
    static constexpr EnabledFeatures OPTIMIZATION_GUIDE_PUSH_NOTIFICATION = SharingSpecificFields_EnabledFeatures_OPTIMIZATION_GUIDE_PUSH_NOTIFICATION;
    static inline bool EnabledFeatures_IsValid(int value)
    {
        return SharingSpecificFields_EnabledFeatures_IsValid(value);
    }
    static constexpr EnabledFeatures EnabledFeatures_MIN = SharingSpecificFields_EnabledFeatures_EnabledFeatures_MIN;
    static constexpr EnabledFeatures EnabledFeatures_MAX = SharingSpecificFields_EnabledFeatures_EnabledFeatures_MAX;
    static constexpr int EnabledFeatures_ARRAYSIZE = SharingSpecificFields_EnabledFeatures_EnabledFeatures_ARRAYSIZE;
    template <typename T> static inline const std::string& EnabledFeatures_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, EnabledFeatures>::value || ::std::is_integral<T>::value, "Incorrect type passed to function EnabledFeatures_Name.");
        return SharingSpecificFields_EnabledFeatures_Name(enum_t_value);
    }
    static inline bool EnabledFeatures_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EnabledFeatures* value)
    {
        return SharingSpecificFields_EnabledFeatures_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kEnabledFeaturesFieldNumber = 4,
        kVapidFcmTokenFieldNumber = 1,
        kVapidP256DhFieldNumber = 2,
        kVapidAuthSecretFieldNumber = 3,
        kSenderIdFcmTokenDeprecatedFieldNumber = 5,
        kSenderIdP256DhDeprecatedFieldNumber = 6,
        kSenderIdAuthSecretDeprecatedFieldNumber = 7,
        kSenderIdFcmTokenV2FieldNumber = 8,
        kSenderIdP256DhV2FieldNumber = 9,
        kSenderIdAuthSecretV2FieldNumber = 10,
        kChimeRepresentativeTargetIdFieldNumber = 11,
    };
    // repeated .sync_pb.SharingSpecificFields.EnabledFeatures enabled_features = 4;
    int enabled_features_size() const;

private:
    int _internal_enabled_features_size() const;

public:
    void clear_enabled_features();

private:
    ::sync_pb::SharingSpecificFields_EnabledFeatures _internal_enabled_features(int index) const;
    void _internal_add_enabled_features(::sync_pb::SharingSpecificFields_EnabledFeatures value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_enabled_features();

public:
    ::sync_pb::SharingSpecificFields_EnabledFeatures enabled_features(int index) const;
    void set_enabled_features(int index, ::sync_pb::SharingSpecificFields_EnabledFeatures value);
    void add_enabled_features(::sync_pb::SharingSpecificFields_EnabledFeatures value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& enabled_features() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_enabled_features();

    // optional string vapid_fcm_token = 1;
    bool has_vapid_fcm_token() const;

private:
    bool _internal_has_vapid_fcm_token() const;

public:
    void clear_vapid_fcm_token();
    const std::string& vapid_fcm_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_vapid_fcm_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_vapid_fcm_token();
    PROTOBUF_NODISCARD std::string* release_vapid_fcm_token();
    void set_allocated_vapid_fcm_token(std::string* vapid_fcm_token);

private:
    const std::string& _internal_vapid_fcm_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_vapid_fcm_token(const std::string& value);
    std::string* _internal_mutable_vapid_fcm_token();

public:
    // optional bytes vapid_p256dh = 2;
    bool has_vapid_p256dh() const;

private:
    bool _internal_has_vapid_p256dh() const;

public:
    void clear_vapid_p256dh();
    const std::string& vapid_p256dh() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_vapid_p256dh(ArgT0&& arg0, ArgT... args);
    std::string* mutable_vapid_p256dh();
    PROTOBUF_NODISCARD std::string* release_vapid_p256dh();
    void set_allocated_vapid_p256dh(std::string* vapid_p256dh);

private:
    const std::string& _internal_vapid_p256dh() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_vapid_p256dh(const std::string& value);
    std::string* _internal_mutable_vapid_p256dh();

public:
    // optional bytes vapid_auth_secret = 3;
    bool has_vapid_auth_secret() const;

private:
    bool _internal_has_vapid_auth_secret() const;

public:
    void clear_vapid_auth_secret();
    const std::string& vapid_auth_secret() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_vapid_auth_secret(ArgT0&& arg0, ArgT... args);
    std::string* mutable_vapid_auth_secret();
    PROTOBUF_NODISCARD std::string* release_vapid_auth_secret();
    void set_allocated_vapid_auth_secret(std::string* vapid_auth_secret);

private:
    const std::string& _internal_vapid_auth_secret() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_vapid_auth_secret(const std::string& value);
    std::string* _internal_mutable_vapid_auth_secret();

public:
    // optional string sender_id_fcm_token_deprecated = 5 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_sender_id_fcm_token_deprecated() const;

private:
    bool _internal_has_sender_id_fcm_token_deprecated() const;

public:
    PROTOBUF_DEPRECATED void clear_sender_id_fcm_token_deprecated();
    PROTOBUF_DEPRECATED const std::string& sender_id_fcm_token_deprecated() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_sender_id_fcm_token_deprecated(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_sender_id_fcm_token_deprecated();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_sender_id_fcm_token_deprecated();
    PROTOBUF_DEPRECATED void set_allocated_sender_id_fcm_token_deprecated(std::string* sender_id_fcm_token_deprecated);

private:
    const std::string& _internal_sender_id_fcm_token_deprecated() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_fcm_token_deprecated(const std::string& value);
    std::string* _internal_mutable_sender_id_fcm_token_deprecated();

public:
    // optional bytes sender_id_p256dh_deprecated = 6 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_sender_id_p256dh_deprecated() const;

private:
    bool _internal_has_sender_id_p256dh_deprecated() const;

public:
    PROTOBUF_DEPRECATED void clear_sender_id_p256dh_deprecated();
    PROTOBUF_DEPRECATED const std::string& sender_id_p256dh_deprecated() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_sender_id_p256dh_deprecated(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_sender_id_p256dh_deprecated();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_sender_id_p256dh_deprecated();
    PROTOBUF_DEPRECATED void set_allocated_sender_id_p256dh_deprecated(std::string* sender_id_p256dh_deprecated);

private:
    const std::string& _internal_sender_id_p256dh_deprecated() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_p256dh_deprecated(const std::string& value);
    std::string* _internal_mutable_sender_id_p256dh_deprecated();

public:
    // optional bytes sender_id_auth_secret_deprecated = 7 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_sender_id_auth_secret_deprecated() const;

private:
    bool _internal_has_sender_id_auth_secret_deprecated() const;

public:
    PROTOBUF_DEPRECATED void clear_sender_id_auth_secret_deprecated();
    PROTOBUF_DEPRECATED const std::string& sender_id_auth_secret_deprecated() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_sender_id_auth_secret_deprecated(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_sender_id_auth_secret_deprecated();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_sender_id_auth_secret_deprecated();
    PROTOBUF_DEPRECATED void set_allocated_sender_id_auth_secret_deprecated(std::string* sender_id_auth_secret_deprecated);

private:
    const std::string& _internal_sender_id_auth_secret_deprecated() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_auth_secret_deprecated(const std::string& value);
    std::string* _internal_mutable_sender_id_auth_secret_deprecated();

public:
    // optional string sender_id_fcm_token_v2 = 8;
    bool has_sender_id_fcm_token_v2() const;

private:
    bool _internal_has_sender_id_fcm_token_v2() const;

public:
    void clear_sender_id_fcm_token_v2();
    const std::string& sender_id_fcm_token_v2() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_sender_id_fcm_token_v2(ArgT0&& arg0, ArgT... args);
    std::string* mutable_sender_id_fcm_token_v2();
    PROTOBUF_NODISCARD std::string* release_sender_id_fcm_token_v2();
    void set_allocated_sender_id_fcm_token_v2(std::string* sender_id_fcm_token_v2);

private:
    const std::string& _internal_sender_id_fcm_token_v2() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_fcm_token_v2(const std::string& value);
    std::string* _internal_mutable_sender_id_fcm_token_v2();

public:
    // optional bytes sender_id_p256dh_v2 = 9;
    bool has_sender_id_p256dh_v2() const;

private:
    bool _internal_has_sender_id_p256dh_v2() const;

public:
    void clear_sender_id_p256dh_v2();
    const std::string& sender_id_p256dh_v2() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_sender_id_p256dh_v2(ArgT0&& arg0, ArgT... args);
    std::string* mutable_sender_id_p256dh_v2();
    PROTOBUF_NODISCARD std::string* release_sender_id_p256dh_v2();
    void set_allocated_sender_id_p256dh_v2(std::string* sender_id_p256dh_v2);

private:
    const std::string& _internal_sender_id_p256dh_v2() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_p256dh_v2(const std::string& value);
    std::string* _internal_mutable_sender_id_p256dh_v2();

public:
    // optional bytes sender_id_auth_secret_v2 = 10;
    bool has_sender_id_auth_secret_v2() const;

private:
    bool _internal_has_sender_id_auth_secret_v2() const;

public:
    void clear_sender_id_auth_secret_v2();
    const std::string& sender_id_auth_secret_v2() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_sender_id_auth_secret_v2(ArgT0&& arg0, ArgT... args);
    std::string* mutable_sender_id_auth_secret_v2();
    PROTOBUF_NODISCARD std::string* release_sender_id_auth_secret_v2();
    void set_allocated_sender_id_auth_secret_v2(std::string* sender_id_auth_secret_v2);

private:
    const std::string& _internal_sender_id_auth_secret_v2() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_id_auth_secret_v2(const std::string& value);
    std::string* _internal_mutable_sender_id_auth_secret_v2();

public:
    // optional string chime_representative_target_id = 11;
    bool has_chime_representative_target_id() const;

private:
    bool _internal_has_chime_representative_target_id() const;

public:
    void clear_chime_representative_target_id();
    const std::string& chime_representative_target_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_chime_representative_target_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_chime_representative_target_id();
    PROTOBUF_NODISCARD std::string* release_chime_representative_target_id();
    void set_allocated_chime_representative_target_id(std::string* chime_representative_target_id);

private:
    const std::string& _internal_chime_representative_target_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_chime_representative_target_id(const std::string& value);
    std::string* _internal_mutable_chime_representative_target_id();

public:
    // @@protoc_insertion_point(class_scope:sync_pb.SharingSpecificFields)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> enabled_features_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vapid_fcm_token_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vapid_p256dh_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vapid_auth_secret_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_fcm_token_deprecated_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_p256dh_deprecated_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_auth_secret_deprecated_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_fcm_token_v2_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_p256dh_v2_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_id_auth_secret_v2_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chime_representative_target_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class InvalidationSpecificFields final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.InvalidationSpecificFields) */ {
public:
    inline InvalidationSpecificFields()
        : InvalidationSpecificFields(nullptr)
    {
    }
    ~InvalidationSpecificFields() override;
    explicit PROTOBUF_CONSTEXPR InvalidationSpecificFields(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    InvalidationSpecificFields(const InvalidationSpecificFields& from);
    InvalidationSpecificFields(InvalidationSpecificFields&& from) noexcept
        : InvalidationSpecificFields()
    {
        *this = ::std::move(from);
    }

    inline InvalidationSpecificFields& operator=(const InvalidationSpecificFields& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline InvalidationSpecificFields& operator=(InvalidationSpecificFields&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const InvalidationSpecificFields& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const InvalidationSpecificFields* internal_default_instance()
    {
        return reinterpret_cast<const InvalidationSpecificFields*>(&_InvalidationSpecificFields_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(InvalidationSpecificFields& a, InvalidationSpecificFields& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(InvalidationSpecificFields* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(InvalidationSpecificFields* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    InvalidationSpecificFields* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<InvalidationSpecificFields>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const InvalidationSpecificFields& from);
    void MergeFrom(const InvalidationSpecificFields& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(InvalidationSpecificFields* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.InvalidationSpecificFields";
    }

protected:
    explicit InvalidationSpecificFields(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kInterestedDataTypeIdsFieldNumber = 2,
        kInstanceIdTokenFieldNumber = 1,
    };
    // repeated int32 interested_data_type_ids = 2;
    int interested_data_type_ids_size() const;

private:
    int _internal_interested_data_type_ids_size() const;

public:
    void clear_interested_data_type_ids();

private:
    int32_t _internal_interested_data_type_ids(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& _internal_interested_data_type_ids() const;
    void _internal_add_interested_data_type_ids(int32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* _internal_mutable_interested_data_type_ids();

public:
    int32_t interested_data_type_ids(int index) const;
    void set_interested_data_type_ids(int index, int32_t value);
    void add_interested_data_type_ids(int32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& interested_data_type_ids() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* mutable_interested_data_type_ids();

    // optional string instance_id_token = 1;
    bool has_instance_id_token() const;

private:
    bool _internal_has_instance_id_token() const;

public:
    void clear_instance_id_token();
    const std::string& instance_id_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_instance_id_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_instance_id_token();
    PROTOBUF_NODISCARD std::string* release_instance_id_token();
    void set_allocated_instance_id_token(std::string* instance_id_token);

private:
    const std::string& _internal_instance_id_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_instance_id_token(const std::string& value);
    std::string* _internal_mutable_instance_id_token();

public:
    // @@protoc_insertion_point(class_scope:sync_pb.InvalidationSpecificFields)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t> interested_data_type_ids_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_id_token_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class PhoneAsASecurityKeySpecificFields final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.PhoneAsASecurityKeySpecificFields) */ {
public:
    inline PhoneAsASecurityKeySpecificFields()
        : PhoneAsASecurityKeySpecificFields(nullptr)
    {
    }
    ~PhoneAsASecurityKeySpecificFields() override;
    explicit PROTOBUF_CONSTEXPR PhoneAsASecurityKeySpecificFields(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PhoneAsASecurityKeySpecificFields(const PhoneAsASecurityKeySpecificFields& from);
    PhoneAsASecurityKeySpecificFields(PhoneAsASecurityKeySpecificFields&& from) noexcept
        : PhoneAsASecurityKeySpecificFields()
    {
        *this = ::std::move(from);
    }

    inline PhoneAsASecurityKeySpecificFields& operator=(const PhoneAsASecurityKeySpecificFields& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline PhoneAsASecurityKeySpecificFields& operator=(PhoneAsASecurityKeySpecificFields&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const PhoneAsASecurityKeySpecificFields& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const PhoneAsASecurityKeySpecificFields* internal_default_instance()
    {
        return reinterpret_cast<const PhoneAsASecurityKeySpecificFields*>(&_PhoneAsASecurityKeySpecificFields_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(PhoneAsASecurityKeySpecificFields& a, PhoneAsASecurityKeySpecificFields& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(PhoneAsASecurityKeySpecificFields* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PhoneAsASecurityKeySpecificFields* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PhoneAsASecurityKeySpecificFields* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<PhoneAsASecurityKeySpecificFields>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const PhoneAsASecurityKeySpecificFields& from);
    void MergeFrom(const PhoneAsASecurityKeySpecificFields& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PhoneAsASecurityKeySpecificFields* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.PhoneAsASecurityKeySpecificFields";
    }

protected:
    explicit PhoneAsASecurityKeySpecificFields(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kContactIdFieldNumber = 2,
        kSecretFieldNumber = 3,
        kPeerPublicKeyX962FieldNumber = 5,
        kGoogleCredentialIdFieldNumber = 6,
        kTunnelServerDomainFieldNumber = 1,
        kIdFieldNumber = 4,
    };
    // optional bytes contact_id = 2;
    bool has_contact_id() const;

private:
    bool _internal_has_contact_id() const;

public:
    void clear_contact_id();
    const std::string& contact_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_contact_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_contact_id();
    PROTOBUF_NODISCARD std::string* release_contact_id();
    void set_allocated_contact_id(std::string* contact_id);

private:
    const std::string& _internal_contact_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_contact_id(const std::string& value);
    std::string* _internal_mutable_contact_id();

public:
    // optional bytes secret = 3;
    bool has_secret() const;

private:
    bool _internal_has_secret() const;

public:
    void clear_secret();
    const std::string& secret() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_secret(ArgT0&& arg0, ArgT... args);
    std::string* mutable_secret();
    PROTOBUF_NODISCARD std::string* release_secret();
    void set_allocated_secret(std::string* secret);

private:
    const std::string& _internal_secret() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
    std::string* _internal_mutable_secret();

public:
    // optional bytes peer_public_key_x962 = 5;
    bool has_peer_public_key_x962() const;

private:
    bool _internal_has_peer_public_key_x962() const;

public:
    void clear_peer_public_key_x962();
    const std::string& peer_public_key_x962() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_peer_public_key_x962(ArgT0&& arg0, ArgT... args);
    std::string* mutable_peer_public_key_x962();
    PROTOBUF_NODISCARD std::string* release_peer_public_key_x962();
    void set_allocated_peer_public_key_x962(std::string* peer_public_key_x962);

private:
    const std::string& _internal_peer_public_key_x962() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer_public_key_x962(const std::string& value);
    std::string* _internal_mutable_peer_public_key_x962();

public:
    // optional bytes google_credential_id = 6;
    bool has_google_credential_id() const;

private:
    bool _internal_has_google_credential_id() const;

public:
    void clear_google_credential_id();
    const std::string& google_credential_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_google_credential_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_google_credential_id();
    PROTOBUF_NODISCARD std::string* release_google_credential_id();
    void set_allocated_google_credential_id(std::string* google_credential_id);

private:
    const std::string& _internal_google_credential_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_google_credential_id(const std::string& value);
    std::string* _internal_mutable_google_credential_id();

public:
    // optional uint32 tunnel_server_domain = 1;
    bool has_tunnel_server_domain() const;

private:
    bool _internal_has_tunnel_server_domain() const;

public:
    void clear_tunnel_server_domain();
    uint32_t tunnel_server_domain() const;
    void set_tunnel_server_domain(uint32_t value);

private:
    uint32_t _internal_tunnel_server_domain() const;
    void _internal_set_tunnel_server_domain(uint32_t value);

public:
    // optional fixed32 id = 4;
    bool has_id() const;

private:
    bool _internal_has_id() const;

public:
    void clear_id();
    uint32_t id() const;
    void set_id(uint32_t value);

private:
    uint32_t _internal_id() const;
    void _internal_set_id(uint32_t value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.PhoneAsASecurityKeySpecificFields)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contact_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_public_key_x962_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr google_credential_id_;
        uint32_t tunnel_server_domain_;
        uint32_t id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class ChromeVersionInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ChromeVersionInfo) */ {
public:
    inline ChromeVersionInfo()
        : ChromeVersionInfo(nullptr)
    {
    }
    ~ChromeVersionInfo() override;
    explicit PROTOBUF_CONSTEXPR ChromeVersionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ChromeVersionInfo(const ChromeVersionInfo& from);
    ChromeVersionInfo(ChromeVersionInfo&& from) noexcept
        : ChromeVersionInfo()
    {
        *this = ::std::move(from);
    }

    inline ChromeVersionInfo& operator=(const ChromeVersionInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ChromeVersionInfo& operator=(ChromeVersionInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ChromeVersionInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ChromeVersionInfo* internal_default_instance()
    {
        return reinterpret_cast<const ChromeVersionInfo*>(&_ChromeVersionInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(ChromeVersionInfo& a, ChromeVersionInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ChromeVersionInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ChromeVersionInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ChromeVersionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ChromeVersionInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ChromeVersionInfo& from);
    void MergeFrom(const ChromeVersionInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ChromeVersionInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.ChromeVersionInfo";
    }

protected:
    explicit ChromeVersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kVersionNumberFieldNumber = 1,
    };
    // optional string version_number = 1;
    bool has_version_number() const;

private:
    bool _internal_has_version_number() const;

public:
    void clear_version_number();
    const std::string& version_number() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_version_number(ArgT0&& arg0, ArgT... args);
    std::string* mutable_version_number();
    PROTOBUF_NODISCARD std::string* release_version_number();
    void set_allocated_version_number(std::string* version_number);

private:
    const std::string& _internal_version_number() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_version_number(const std::string& value);
    std::string* _internal_mutable_version_number();

public:
    // @@protoc_insertion_point(class_scope:sync_pb.ChromeVersionInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_number_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class GooglePlayServicesVersionInfo final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.GooglePlayServicesVersionInfo) */ {
public:
    inline GooglePlayServicesVersionInfo()
        : GooglePlayServicesVersionInfo(nullptr)
    {
    }
    ~GooglePlayServicesVersionInfo() override;
    explicit PROTOBUF_CONSTEXPR GooglePlayServicesVersionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    GooglePlayServicesVersionInfo(const GooglePlayServicesVersionInfo& from);
    GooglePlayServicesVersionInfo(GooglePlayServicesVersionInfo&& from) noexcept
        : GooglePlayServicesVersionInfo()
    {
        *this = ::std::move(from);
    }

    inline GooglePlayServicesVersionInfo& operator=(const GooglePlayServicesVersionInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline GooglePlayServicesVersionInfo& operator=(GooglePlayServicesVersionInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const GooglePlayServicesVersionInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const GooglePlayServicesVersionInfo* internal_default_instance()
    {
        return reinterpret_cast<const GooglePlayServicesVersionInfo*>(&_GooglePlayServicesVersionInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(GooglePlayServicesVersionInfo& a, GooglePlayServicesVersionInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(GooglePlayServicesVersionInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(GooglePlayServicesVersionInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    GooglePlayServicesVersionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<GooglePlayServicesVersionInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const GooglePlayServicesVersionInfo& from);
    void MergeFrom(const GooglePlayServicesVersionInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(GooglePlayServicesVersionInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.GooglePlayServicesVersionInfo";
    }

protected:
    explicit GooglePlayServicesVersionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kApkVersionNameFieldNumber = 1,
    };
    // optional string apk_version_name = 1;
    bool has_apk_version_name() const;

private:
    bool _internal_has_apk_version_name() const;

public:
    void clear_apk_version_name();
    const std::string& apk_version_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_apk_version_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_apk_version_name();
    PROTOBUF_NODISCARD std::string* release_apk_version_name();
    void set_allocated_apk_version_name(std::string* apk_version_name);

private:
    const std::string& _internal_apk_version_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_apk_version_name(const std::string& value);
    std::string* _internal_mutable_apk_version_name();

public:
    // @@protoc_insertion_point(class_scope:sync_pb.GooglePlayServicesVersionInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr apk_version_name_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// DeviceInfoSpecifics

// optional string cache_guid = 1;
inline bool DeviceInfoSpecifics::_internal_has_cache_guid() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool DeviceInfoSpecifics::has_cache_guid() const
{
    return _internal_has_cache_guid();
}
inline void DeviceInfoSpecifics::clear_cache_guid()
{
    _impl_.cache_guid_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceInfoSpecifics::cache_guid() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.cache_guid)
    return _internal_cache_guid();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DeviceInfoSpecifics::set_cache_guid(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.cache_guid_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.cache_guid)
}
inline std::string* DeviceInfoSpecifics::mutable_cache_guid()
{
    std::string* _s = _internal_mutable_cache_guid();
    // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.cache_guid)
    return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_cache_guid() const
{
    return _impl_.cache_guid_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_cache_guid(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.cache_guid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_cache_guid()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.cache_guid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_cache_guid()
{
    // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.cache_guid)
    if (!_internal_has_cache_guid()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.cache_guid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cache_guid_.IsDefault()) {
        _impl_.cache_guid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DeviceInfoSpecifics::set_allocated_cache_guid(std::string* cache_guid)
{
    if (cache_guid != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.cache_guid_.SetAllocated(cache_guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cache_guid_.IsDefault()) {
        _impl_.cache_guid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.cache_guid)
}

// optional string client_name = 2;
inline bool DeviceInfoSpecifics::_internal_has_client_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool DeviceInfoSpecifics::has_client_name() const
{
    return _internal_has_client_name();
}
inline void DeviceInfoSpecifics::clear_client_name()
{
    _impl_.client_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DeviceInfoSpecifics::client_name() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.client_name)
    return _internal_client_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DeviceInfoSpecifics::set_client_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.client_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.client_name)
}
inline std::string* DeviceInfoSpecifics::mutable_client_name()
{
    std::string* _s = _internal_mutable_client_name();
    // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.client_name)
    return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_client_name() const
{
    return _impl_.client_name_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_client_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.client_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_client_name()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.client_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_client_name()
{
    // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.client_name)
    if (!_internal_has_client_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.client_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.client_name_.IsDefault()) {
        _impl_.client_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DeviceInfoSpecifics::set_allocated_client_name(std::string* client_name)
{
    if (client_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.client_name_.SetAllocated(client_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.client_name_.IsDefault()) {
        _impl_.client_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.client_name)
}

// optional .sync_pb.SyncEnums.DeviceType device_type = 3 [deprecated = true];
inline bool DeviceInfoSpecifics::_internal_has_device_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
    return value;
}
inline bool DeviceInfoSpecifics::has_device_type() const
{
    return _internal_has_device_type();
}
inline void DeviceInfoSpecifics::clear_device_type()
{
    _impl_.device_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::sync_pb::SyncEnums_DeviceType DeviceInfoSpecifics::_internal_device_type() const
{
    return static_cast<::sync_pb::SyncEnums_DeviceType>(_impl_.device_type_);
}
inline ::sync_pb::SyncEnums_DeviceType DeviceInfoSpecifics::device_type() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.device_type)
    return _internal_device_type();
}
inline void DeviceInfoSpecifics::_internal_set_device_type(::sync_pb::SyncEnums_DeviceType value)
{
    assert(::sync_pb::SyncEnums_DeviceType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00004000u;
    _impl_.device_type_ = value;
}
inline void DeviceInfoSpecifics::set_device_type(::sync_pb::SyncEnums_DeviceType value)
{
    _internal_set_device_type(value);
    // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.device_type)
}

// optional string sync_user_agent = 4;
inline bool DeviceInfoSpecifics::_internal_has_sync_user_agent() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool DeviceInfoSpecifics::has_sync_user_agent() const
{
    return _internal_has_sync_user_agent();
}
inline void DeviceInfoSpecifics::clear_sync_user_agent()
{
    _impl_.sync_user_agent_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DeviceInfoSpecifics::sync_user_agent() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.sync_user_agent)
    return _internal_sync_user_agent();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DeviceInfoSpecifics::set_sync_user_agent(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.sync_user_agent_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.sync_user_agent)
}
inline std::string* DeviceInfoSpecifics::mutable_sync_user_agent()
{
    std::string* _s = _internal_mutable_sync_user_agent();
    // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.sync_user_agent)
    return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_sync_user_agent() const
{
    return _impl_.sync_user_agent_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_sync_user_agent(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.sync_user_agent_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_sync_user_agent()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.sync_user_agent_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_sync_user_agent()
{
    // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.sync_user_agent)
    if (!_internal_has_sync_user_agent()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.sync_user_agent_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sync_user_agent_.IsDefault()) {
        _impl_.sync_user_agent_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DeviceInfoSpecifics::set_allocated_sync_user_agent(std::string* sync_user_agent)
{
    if (sync_user_agent != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.sync_user_agent_.SetAllocated(sync_user_agent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sync_user_agent_.IsDefault()) {
        _impl_.sync_user_agent_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.sync_user_agent)
}

// optional string chrome_version = 5 [deprecated = true];
inline bool DeviceInfoSpecifics::_internal_has_chrome_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool DeviceInfoSpecifics::has_chrome_version() const
{
    return _internal_has_chrome_version();
}
inline void DeviceInfoSpecifics::clear_chrome_version()
{
    _impl_.chrome_version_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DeviceInfoSpecifics::chrome_version() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.chrome_version)
    return _internal_chrome_version();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DeviceInfoSpecifics::set_chrome_version(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.chrome_version_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.chrome_version)
}
inline std::string* DeviceInfoSpecifics::mutable_chrome_version()
{
    std::string* _s = _internal_mutable_chrome_version();
    // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.chrome_version)
    return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_chrome_version() const
{
    return _impl_.chrome_version_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_chrome_version(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.chrome_version_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_chrome_version()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.chrome_version_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_chrome_version()
{
    // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.chrome_version)
    if (!_internal_has_chrome_version()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.chrome_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.chrome_version_.IsDefault()) {
        _impl_.chrome_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DeviceInfoSpecifics::set_allocated_chrome_version(std::string* chrome_version)
{
    if (chrome_version != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.chrome_version_.SetAllocated(chrome_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.chrome_version_.IsDefault()) {
        _impl_.chrome_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.chrome_version)
}

// optional int64 deprecated_backup_timestamp = 6 [deprecated = true];
inline bool DeviceInfoSpecifics::_internal_has_deprecated_backup_timestamp() const
{
    bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
    return value;
}
inline bool DeviceInfoSpecifics::has_deprecated_backup_timestamp() const
{
    return _internal_has_deprecated_backup_timestamp();
}
inline void DeviceInfoSpecifics::clear_deprecated_backup_timestamp()
{
    _impl_.deprecated_backup_timestamp_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int64_t DeviceInfoSpecifics::_internal_deprecated_backup_timestamp() const
{
    return _impl_.deprecated_backup_timestamp_;
}
inline int64_t DeviceInfoSpecifics::deprecated_backup_timestamp() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.deprecated_backup_timestamp)
    return _internal_deprecated_backup_timestamp();
}
inline void DeviceInfoSpecifics::_internal_set_deprecated_backup_timestamp(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00001000u;
    _impl_.deprecated_backup_timestamp_ = value;
}
inline void DeviceInfoSpecifics::set_deprecated_backup_timestamp(int64_t value)
{
    _internal_set_deprecated_backup_timestamp(value);
    // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.deprecated_backup_timestamp)
}

// optional string signin_scoped_device_id = 7;
inline bool DeviceInfoSpecifics::_internal_has_signin_scoped_device_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool DeviceInfoSpecifics::has_signin_scoped_device_id() const
{
    return _internal_has_signin_scoped_device_id();
}
inline void DeviceInfoSpecifics::clear_signin_scoped_device_id()
{
    _impl_.signin_scoped_device_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DeviceInfoSpecifics::signin_scoped_device_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.signin_scoped_device_id)
    return _internal_signin_scoped_device_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DeviceInfoSpecifics::set_signin_scoped_device_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.signin_scoped_device_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.signin_scoped_device_id)
}
inline std::string* DeviceInfoSpecifics::mutable_signin_scoped_device_id()
{
    std::string* _s = _internal_mutable_signin_scoped_device_id();
    // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.signin_scoped_device_id)
    return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_signin_scoped_device_id() const
{
    return _impl_.signin_scoped_device_id_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_signin_scoped_device_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.signin_scoped_device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_signin_scoped_device_id()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    return _impl_.signin_scoped_device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_signin_scoped_device_id()
{
    // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.signin_scoped_device_id)
    if (!_internal_has_signin_scoped_device_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000010u;
    auto* p = _impl_.signin_scoped_device_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.signin_scoped_device_id_.IsDefault()) {
        _impl_.signin_scoped_device_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DeviceInfoSpecifics::set_allocated_signin_scoped_device_id(std::string* signin_scoped_device_id)
{
    if (signin_scoped_device_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.signin_scoped_device_id_.SetAllocated(signin_scoped_device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.signin_scoped_device_id_.IsDefault()) {
        _impl_.signin_scoped_device_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.signin_scoped_device_id)
}

// optional int64 last_updated_timestamp = 8;
inline bool DeviceInfoSpecifics::_internal_has_last_updated_timestamp() const
{
    bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
    return value;
}
inline bool DeviceInfoSpecifics::has_last_updated_timestamp() const
{
    return _internal_has_last_updated_timestamp();
}
inline void DeviceInfoSpecifics::clear_last_updated_timestamp()
{
    _impl_.last_updated_timestamp_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00002000u;
}
inline int64_t DeviceInfoSpecifics::_internal_last_updated_timestamp() const
{
    return _impl_.last_updated_timestamp_;
}
inline int64_t DeviceInfoSpecifics::last_updated_timestamp() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.last_updated_timestamp)
    return _internal_last_updated_timestamp();
}
inline void DeviceInfoSpecifics::_internal_set_last_updated_timestamp(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00002000u;
    _impl_.last_updated_timestamp_ = value;
}
inline void DeviceInfoSpecifics::set_last_updated_timestamp(int64_t value)
{
    _internal_set_last_updated_timestamp(value);
    // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.last_updated_timestamp)
}

// optional .sync_pb.FeatureSpecificFields feature_fields = 9;
inline bool DeviceInfoSpecifics::_internal_has_feature_fields() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.feature_fields_ != nullptr);
    return value;
}
inline bool DeviceInfoSpecifics::has_feature_fields() const
{
    return _internal_has_feature_fields();
}
inline void DeviceInfoSpecifics::clear_feature_fields()
{
    if (_impl_.feature_fields_ != nullptr)
        _impl_.feature_fields_->Clear();
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::sync_pb::FeatureSpecificFields& DeviceInfoSpecifics::_internal_feature_fields() const
{
    const ::sync_pb::FeatureSpecificFields* p = _impl_.feature_fields_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::FeatureSpecificFields&>(::sync_pb::_FeatureSpecificFields_default_instance_);
}
inline const ::sync_pb::FeatureSpecificFields& DeviceInfoSpecifics::feature_fields() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.feature_fields)
    return _internal_feature_fields();
}
inline void DeviceInfoSpecifics::unsafe_arena_set_allocated_feature_fields(::sync_pb::FeatureSpecificFields* feature_fields)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.feature_fields_);
    }
    _impl_.feature_fields_ = feature_fields;
    if (feature_fields) {
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.DeviceInfoSpecifics.feature_fields)
}
inline ::sync_pb::FeatureSpecificFields* DeviceInfoSpecifics::release_feature_fields()
{
    _impl_._has_bits_[0] &= ~0x00000100u;
    ::sync_pb::FeatureSpecificFields* temp = _impl_.feature_fields_;
    _impl_.feature_fields_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::FeatureSpecificFields* DeviceInfoSpecifics::unsafe_arena_release_feature_fields()
{
    // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.feature_fields)
    _impl_._has_bits_[0] &= ~0x00000100u;
    ::sync_pb::FeatureSpecificFields* temp = _impl_.feature_fields_;
    _impl_.feature_fields_ = nullptr;
    return temp;
}
inline ::sync_pb::FeatureSpecificFields* DeviceInfoSpecifics::_internal_mutable_feature_fields()
{
    _impl_._has_bits_[0] |= 0x00000100u;
    if (_impl_.feature_fields_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::FeatureSpecificFields>(GetArenaForAllocation());
        _impl_.feature_fields_ = p;
    }
    return _impl_.feature_fields_;
}
inline ::sync_pb::FeatureSpecificFields* DeviceInfoSpecifics::mutable_feature_fields()
{
    ::sync_pb::FeatureSpecificFields* _msg = _internal_mutable_feature_fields();
    // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.feature_fields)
    return _msg;
}
inline void DeviceInfoSpecifics::set_allocated_feature_fields(::sync_pb::FeatureSpecificFields* feature_fields)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.feature_fields_;
    }
    if (feature_fields) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feature_fields);
        if (message_arena != submessage_arena) {
            feature_fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, feature_fields, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    _impl_.feature_fields_ = feature_fields;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.feature_fields)
}

// optional .sync_pb.SharingSpecificFields sharing_fields = 10;
inline bool DeviceInfoSpecifics::_internal_has_sharing_fields() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.sharing_fields_ != nullptr);
    return value;
}
inline bool DeviceInfoSpecifics::has_sharing_fields() const
{
    return _internal_has_sharing_fields();
}
inline void DeviceInfoSpecifics::clear_sharing_fields()
{
    if (_impl_.sharing_fields_ != nullptr)
        _impl_.sharing_fields_->Clear();
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::sync_pb::SharingSpecificFields& DeviceInfoSpecifics::_internal_sharing_fields() const
{
    const ::sync_pb::SharingSpecificFields* p = _impl_.sharing_fields_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::SharingSpecificFields&>(::sync_pb::_SharingSpecificFields_default_instance_);
}
inline const ::sync_pb::SharingSpecificFields& DeviceInfoSpecifics::sharing_fields() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.sharing_fields)
    return _internal_sharing_fields();
}
inline void DeviceInfoSpecifics::unsafe_arena_set_allocated_sharing_fields(::sync_pb::SharingSpecificFields* sharing_fields)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sharing_fields_);
    }
    _impl_.sharing_fields_ = sharing_fields;
    if (sharing_fields) {
        _impl_._has_bits_[0] |= 0x00000200u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000200u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.DeviceInfoSpecifics.sharing_fields)
}
inline ::sync_pb::SharingSpecificFields* DeviceInfoSpecifics::release_sharing_fields()
{
    _impl_._has_bits_[0] &= ~0x00000200u;
    ::sync_pb::SharingSpecificFields* temp = _impl_.sharing_fields_;
    _impl_.sharing_fields_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::SharingSpecificFields* DeviceInfoSpecifics::unsafe_arena_release_sharing_fields()
{
    // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.sharing_fields)
    _impl_._has_bits_[0] &= ~0x00000200u;
    ::sync_pb::SharingSpecificFields* temp = _impl_.sharing_fields_;
    _impl_.sharing_fields_ = nullptr;
    return temp;
}
inline ::sync_pb::SharingSpecificFields* DeviceInfoSpecifics::_internal_mutable_sharing_fields()
{
    _impl_._has_bits_[0] |= 0x00000200u;
    if (_impl_.sharing_fields_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::SharingSpecificFields>(GetArenaForAllocation());
        _impl_.sharing_fields_ = p;
    }
    return _impl_.sharing_fields_;
}
inline ::sync_pb::SharingSpecificFields* DeviceInfoSpecifics::mutable_sharing_fields()
{
    ::sync_pb::SharingSpecificFields* _msg = _internal_mutable_sharing_fields();
    // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.sharing_fields)
    return _msg;
}
inline void DeviceInfoSpecifics::set_allocated_sharing_fields(::sync_pb::SharingSpecificFields* sharing_fields)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.sharing_fields_;
    }
    if (sharing_fields) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sharing_fields);
        if (message_arena != submessage_arena) {
            sharing_fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, sharing_fields, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000200u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000200u;
    }
    _impl_.sharing_fields_ = sharing_fields;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.sharing_fields)
}

// optional string model = 11;
inline bool DeviceInfoSpecifics::_internal_has_model() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool DeviceInfoSpecifics::has_model() const
{
    return _internal_has_model();
}
inline void DeviceInfoSpecifics::clear_model()
{
    _impl_.model_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DeviceInfoSpecifics::model() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.model)
    return _internal_model();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DeviceInfoSpecifics::set_model(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.model_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.model)
}
inline std::string* DeviceInfoSpecifics::mutable_model()
{
    std::string* _s = _internal_mutable_model();
    // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.model)
    return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_model() const
{
    return _impl_.model_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_model(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.model_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_model()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    return _impl_.model_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_model()
{
    // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.model)
    if (!_internal_has_model()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000020u;
    auto* p = _impl_.model_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.model_.IsDefault()) {
        _impl_.model_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DeviceInfoSpecifics::set_allocated_model(std::string* model)
{
    if (model != nullptr) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.model_.SetAllocated(model, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.model_.IsDefault()) {
        _impl_.model_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.model)
}

// optional string manufacturer = 12;
inline bool DeviceInfoSpecifics::_internal_has_manufacturer() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool DeviceInfoSpecifics::has_manufacturer() const
{
    return _internal_has_manufacturer();
}
inline void DeviceInfoSpecifics::clear_manufacturer()
{
    _impl_.manufacturer_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DeviceInfoSpecifics::manufacturer() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.manufacturer)
    return _internal_manufacturer();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DeviceInfoSpecifics::set_manufacturer(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.manufacturer_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.manufacturer)
}
inline std::string* DeviceInfoSpecifics::mutable_manufacturer()
{
    std::string* _s = _internal_mutable_manufacturer();
    // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.manufacturer)
    return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_manufacturer() const
{
    return _impl_.manufacturer_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_manufacturer(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.manufacturer_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_manufacturer()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    return _impl_.manufacturer_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_manufacturer()
{
    // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.manufacturer)
    if (!_internal_has_manufacturer()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000040u;
    auto* p = _impl_.manufacturer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.manufacturer_.IsDefault()) {
        _impl_.manufacturer_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DeviceInfoSpecifics::set_allocated_manufacturer(std::string* manufacturer)
{
    if (manufacturer != nullptr) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.manufacturer_.SetAllocated(manufacturer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.manufacturer_.IsDefault()) {
        _impl_.manufacturer_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.manufacturer)
}

// optional int32 pulse_interval_in_minutes = 13;
inline bool DeviceInfoSpecifics::_internal_has_pulse_interval_in_minutes() const
{
    bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
    return value;
}
inline bool DeviceInfoSpecifics::has_pulse_interval_in_minutes() const
{
    return _internal_has_pulse_interval_in_minutes();
}
inline void DeviceInfoSpecifics::clear_pulse_interval_in_minutes()
{
    _impl_.pulse_interval_in_minutes_ = 0;
    _impl_._has_bits_[0] &= ~0x00008000u;
}
inline int32_t DeviceInfoSpecifics::_internal_pulse_interval_in_minutes() const
{
    return _impl_.pulse_interval_in_minutes_;
}
inline int32_t DeviceInfoSpecifics::pulse_interval_in_minutes() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.pulse_interval_in_minutes)
    return _internal_pulse_interval_in_minutes();
}
inline void DeviceInfoSpecifics::_internal_set_pulse_interval_in_minutes(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00008000u;
    _impl_.pulse_interval_in_minutes_ = value;
}
inline void DeviceInfoSpecifics::set_pulse_interval_in_minutes(int32_t value)
{
    _internal_set_pulse_interval_in_minutes(value);
    // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.pulse_interval_in_minutes)
}

// optional .sync_pb.InvalidationSpecificFields invalidation_fields = 14;
inline bool DeviceInfoSpecifics::_internal_has_invalidation_fields() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.invalidation_fields_ != nullptr);
    return value;
}
inline bool DeviceInfoSpecifics::has_invalidation_fields() const
{
    return _internal_has_invalidation_fields();
}
inline void DeviceInfoSpecifics::clear_invalidation_fields()
{
    if (_impl_.invalidation_fields_ != nullptr)
        _impl_.invalidation_fields_->Clear();
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::sync_pb::InvalidationSpecificFields& DeviceInfoSpecifics::_internal_invalidation_fields() const
{
    const ::sync_pb::InvalidationSpecificFields* p = _impl_.invalidation_fields_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::InvalidationSpecificFields&>(::sync_pb::_InvalidationSpecificFields_default_instance_);
}
inline const ::sync_pb::InvalidationSpecificFields& DeviceInfoSpecifics::invalidation_fields() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.invalidation_fields)
    return _internal_invalidation_fields();
}
inline void DeviceInfoSpecifics::unsafe_arena_set_allocated_invalidation_fields(::sync_pb::InvalidationSpecificFields* invalidation_fields)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.invalidation_fields_);
    }
    _impl_.invalidation_fields_ = invalidation_fields;
    if (invalidation_fields) {
        _impl_._has_bits_[0] |= 0x00000400u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000400u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.DeviceInfoSpecifics.invalidation_fields)
}
inline ::sync_pb::InvalidationSpecificFields* DeviceInfoSpecifics::release_invalidation_fields()
{
    _impl_._has_bits_[0] &= ~0x00000400u;
    ::sync_pb::InvalidationSpecificFields* temp = _impl_.invalidation_fields_;
    _impl_.invalidation_fields_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::InvalidationSpecificFields* DeviceInfoSpecifics::unsafe_arena_release_invalidation_fields()
{
    // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.invalidation_fields)
    _impl_._has_bits_[0] &= ~0x00000400u;
    ::sync_pb::InvalidationSpecificFields* temp = _impl_.invalidation_fields_;
    _impl_.invalidation_fields_ = nullptr;
    return temp;
}
inline ::sync_pb::InvalidationSpecificFields* DeviceInfoSpecifics::_internal_mutable_invalidation_fields()
{
    _impl_._has_bits_[0] |= 0x00000400u;
    if (_impl_.invalidation_fields_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::InvalidationSpecificFields>(GetArenaForAllocation());
        _impl_.invalidation_fields_ = p;
    }
    return _impl_.invalidation_fields_;
}
inline ::sync_pb::InvalidationSpecificFields* DeviceInfoSpecifics::mutable_invalidation_fields()
{
    ::sync_pb::InvalidationSpecificFields* _msg = _internal_mutable_invalidation_fields();
    // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.invalidation_fields)
    return _msg;
}
inline void DeviceInfoSpecifics::set_allocated_invalidation_fields(::sync_pb::InvalidationSpecificFields* invalidation_fields)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.invalidation_fields_;
    }
    if (invalidation_fields) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(invalidation_fields);
        if (message_arena != submessage_arena) {
            invalidation_fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, invalidation_fields, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000400u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000400u;
    }
    _impl_.invalidation_fields_ = invalidation_fields;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.invalidation_fields)
}

// optional .sync_pb.PhoneAsASecurityKeySpecificFields paask_fields = 15;
inline bool DeviceInfoSpecifics::_internal_has_paask_fields() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.paask_fields_ != nullptr);
    return value;
}
inline bool DeviceInfoSpecifics::has_paask_fields() const
{
    return _internal_has_paask_fields();
}
inline void DeviceInfoSpecifics::clear_paask_fields()
{
    if (_impl_.paask_fields_ != nullptr)
        _impl_.paask_fields_->Clear();
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::sync_pb::PhoneAsASecurityKeySpecificFields& DeviceInfoSpecifics::_internal_paask_fields() const
{
    const ::sync_pb::PhoneAsASecurityKeySpecificFields* p = _impl_.paask_fields_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::sync_pb::PhoneAsASecurityKeySpecificFields&>(::sync_pb::_PhoneAsASecurityKeySpecificFields_default_instance_);
}
inline const ::sync_pb::PhoneAsASecurityKeySpecificFields& DeviceInfoSpecifics::paask_fields() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.paask_fields)
    return _internal_paask_fields();
}
inline void DeviceInfoSpecifics::unsafe_arena_set_allocated_paask_fields(::sync_pb::PhoneAsASecurityKeySpecificFields* paask_fields)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.paask_fields_);
    }
    _impl_.paask_fields_ = paask_fields;
    if (paask_fields) {
        _impl_._has_bits_[0] |= 0x00000800u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000800u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.DeviceInfoSpecifics.paask_fields)
}
inline ::sync_pb::PhoneAsASecurityKeySpecificFields* DeviceInfoSpecifics::release_paask_fields()
{
    _impl_._has_bits_[0] &= ~0x00000800u;
    ::sync_pb::PhoneAsASecurityKeySpecificFields* temp = _impl_.paask_fields_;
    _impl_.paask_fields_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::PhoneAsASecurityKeySpecificFields* DeviceInfoSpecifics::unsafe_arena_release_paask_fields()
{
    // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.paask_fields)
    _impl_._has_bits_[0] &= ~0x00000800u;
    ::sync_pb::PhoneAsASecurityKeySpecificFields* temp = _impl_.paask_fields_;
    _impl_.paask_fields_ = nullptr;
    return temp;
}
inline ::sync_pb::PhoneAsASecurityKeySpecificFields* DeviceInfoSpecifics::_internal_mutable_paask_fields()
{
    _impl_._has_bits_[0] |= 0x00000800u;
    if (_impl_.paask_fields_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::PhoneAsASecurityKeySpecificFields>(GetArenaForAllocation());
        _impl_.paask_fields_ = p;
    }
    return _impl_.paask_fields_;
}
inline ::sync_pb::PhoneAsASecurityKeySpecificFields* DeviceInfoSpecifics::mutable_paask_fields()
{
    ::sync_pb::PhoneAsASecurityKeySpecificFields* _msg = _internal_mutable_paask_fields();
    // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.paask_fields)
    return _msg;
}
inline void DeviceInfoSpecifics::set_allocated_paask_fields(::sync_pb::PhoneAsASecurityKeySpecificFields* paask_fields)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.paask_fields_;
    }
    if (paask_fields) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(paask_fields);
        if (message_arena != submessage_arena) {
            paask_fields = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, paask_fields, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000800u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000800u;
    }
    _impl_.paask_fields_ = paask_fields;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.paask_fields)
}

// optional string full_hardware_class = 16;
inline bool DeviceInfoSpecifics::_internal_has_full_hardware_class() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool DeviceInfoSpecifics::has_full_hardware_class() const
{
    return _internal_has_full_hardware_class();
}
inline void DeviceInfoSpecifics::clear_full_hardware_class()
{
    _impl_.full_hardware_class_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DeviceInfoSpecifics::full_hardware_class() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.full_hardware_class)
    return _internal_full_hardware_class();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void DeviceInfoSpecifics::set_full_hardware_class(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.full_hardware_class_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.full_hardware_class)
}
inline std::string* DeviceInfoSpecifics::mutable_full_hardware_class()
{
    std::string* _s = _internal_mutable_full_hardware_class();
    // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.full_hardware_class)
    return _s;
}
inline const std::string& DeviceInfoSpecifics::_internal_full_hardware_class() const
{
    return _impl_.full_hardware_class_.Get();
}
inline void DeviceInfoSpecifics::_internal_set_full_hardware_class(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.full_hardware_class_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::_internal_mutable_full_hardware_class()
{
    _impl_._has_bits_[0] |= 0x00000080u;
    return _impl_.full_hardware_class_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfoSpecifics::release_full_hardware_class()
{
    // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.full_hardware_class)
    if (!_internal_has_full_hardware_class()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000080u;
    auto* p = _impl_.full_hardware_class_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.full_hardware_class_.IsDefault()) {
        _impl_.full_hardware_class_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void DeviceInfoSpecifics::set_allocated_full_hardware_class(std::string* full_hardware_class)
{
    if (full_hardware_class != nullptr) {
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    _impl_.full_hardware_class_.SetAllocated(full_hardware_class, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.full_hardware_class_.IsDefault()) {
        _impl_.full_hardware_class_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.DeviceInfoSpecifics.full_hardware_class)
}

// .sync_pb.ChromeVersionInfo chrome_version_info = 17;
inline bool DeviceInfoSpecifics::_internal_has_chrome_version_info() const
{
    return client_version_info_case() == kChromeVersionInfo;
}
inline bool DeviceInfoSpecifics::has_chrome_version_info() const
{
    return _internal_has_chrome_version_info();
}
inline void DeviceInfoSpecifics::set_has_chrome_version_info()
{
    _impl_._oneof_case_[0] = kChromeVersionInfo;
}
inline void DeviceInfoSpecifics::clear_chrome_version_info()
{
    if (_internal_has_chrome_version_info()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.client_version_info_.chrome_version_info_;
        }
        clear_has_client_version_info();
    }
}
inline ::sync_pb::ChromeVersionInfo* DeviceInfoSpecifics::release_chrome_version_info()
{
    // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.chrome_version_info)
    if (_internal_has_chrome_version_info()) {
        clear_has_client_version_info();
        ::sync_pb::ChromeVersionInfo* temp = _impl_.client_version_info_.chrome_version_info_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.client_version_info_.chrome_version_info_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::sync_pb::ChromeVersionInfo& DeviceInfoSpecifics::_internal_chrome_version_info() const
{
    return _internal_has_chrome_version_info() ? *_impl_.client_version_info_.chrome_version_info_
                                               : reinterpret_cast<::sync_pb::ChromeVersionInfo&>(::sync_pb::_ChromeVersionInfo_default_instance_);
}
inline const ::sync_pb::ChromeVersionInfo& DeviceInfoSpecifics::chrome_version_info() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.chrome_version_info)
    return _internal_chrome_version_info();
}
inline ::sync_pb::ChromeVersionInfo* DeviceInfoSpecifics::unsafe_arena_release_chrome_version_info()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:sync_pb.DeviceInfoSpecifics.chrome_version_info)
    if (_internal_has_chrome_version_info()) {
        clear_has_client_version_info();
        ::sync_pb::ChromeVersionInfo* temp = _impl_.client_version_info_.chrome_version_info_;
        _impl_.client_version_info_.chrome_version_info_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void DeviceInfoSpecifics::unsafe_arena_set_allocated_chrome_version_info(::sync_pb::ChromeVersionInfo* chrome_version_info)
{
    clear_client_version_info();
    if (chrome_version_info) {
        set_has_chrome_version_info();
        _impl_.client_version_info_.chrome_version_info_ = chrome_version_info;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.DeviceInfoSpecifics.chrome_version_info)
}
inline ::sync_pb::ChromeVersionInfo* DeviceInfoSpecifics::_internal_mutable_chrome_version_info()
{
    if (!_internal_has_chrome_version_info()) {
        clear_client_version_info();
        set_has_chrome_version_info();
        _impl_.client_version_info_.chrome_version_info_ = CreateMaybeMessage<::sync_pb::ChromeVersionInfo>(GetArenaForAllocation());
    }
    return _impl_.client_version_info_.chrome_version_info_;
}
inline ::sync_pb::ChromeVersionInfo* DeviceInfoSpecifics::mutable_chrome_version_info()
{
    ::sync_pb::ChromeVersionInfo* _msg = _internal_mutable_chrome_version_info();
    // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.chrome_version_info)
    return _msg;
}

// .sync_pb.GooglePlayServicesVersionInfo google_play_services_version_info = 18;
inline bool DeviceInfoSpecifics::_internal_has_google_play_services_version_info() const
{
    return client_version_info_case() == kGooglePlayServicesVersionInfo;
}
inline bool DeviceInfoSpecifics::has_google_play_services_version_info() const
{
    return _internal_has_google_play_services_version_info();
}
inline void DeviceInfoSpecifics::set_has_google_play_services_version_info()
{
    _impl_._oneof_case_[0] = kGooglePlayServicesVersionInfo;
}
inline void DeviceInfoSpecifics::clear_google_play_services_version_info()
{
    if (_internal_has_google_play_services_version_info()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.client_version_info_.google_play_services_version_info_;
        }
        clear_has_client_version_info();
    }
}
inline ::sync_pb::GooglePlayServicesVersionInfo* DeviceInfoSpecifics::release_google_play_services_version_info()
{
    // @@protoc_insertion_point(field_release:sync_pb.DeviceInfoSpecifics.google_play_services_version_info)
    if (_internal_has_google_play_services_version_info()) {
        clear_has_client_version_info();
        ::sync_pb::GooglePlayServicesVersionInfo* temp = _impl_.client_version_info_.google_play_services_version_info_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.client_version_info_.google_play_services_version_info_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::sync_pb::GooglePlayServicesVersionInfo& DeviceInfoSpecifics::_internal_google_play_services_version_info() const
{
    return _internal_has_google_play_services_version_info()
        ? *_impl_.client_version_info_.google_play_services_version_info_
        : reinterpret_cast<::sync_pb::GooglePlayServicesVersionInfo&>(::sync_pb::_GooglePlayServicesVersionInfo_default_instance_);
}
inline const ::sync_pb::GooglePlayServicesVersionInfo& DeviceInfoSpecifics::google_play_services_version_info() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.google_play_services_version_info)
    return _internal_google_play_services_version_info();
}
inline ::sync_pb::GooglePlayServicesVersionInfo* DeviceInfoSpecifics::unsafe_arena_release_google_play_services_version_info()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:sync_pb.DeviceInfoSpecifics.google_play_services_version_info)
    if (_internal_has_google_play_services_version_info()) {
        clear_has_client_version_info();
        ::sync_pb::GooglePlayServicesVersionInfo* temp = _impl_.client_version_info_.google_play_services_version_info_;
        _impl_.client_version_info_.google_play_services_version_info_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void DeviceInfoSpecifics::unsafe_arena_set_allocated_google_play_services_version_info(
    ::sync_pb::GooglePlayServicesVersionInfo* google_play_services_version_info)
{
    clear_client_version_info();
    if (google_play_services_version_info) {
        set_has_google_play_services_version_info();
        _impl_.client_version_info_.google_play_services_version_info_ = google_play_services_version_info;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.DeviceInfoSpecifics.google_play_services_version_info)
}
inline ::sync_pb::GooglePlayServicesVersionInfo* DeviceInfoSpecifics::_internal_mutable_google_play_services_version_info()
{
    if (!_internal_has_google_play_services_version_info()) {
        clear_client_version_info();
        set_has_google_play_services_version_info();
        _impl_.client_version_info_.google_play_services_version_info_ = CreateMaybeMessage<::sync_pb::GooglePlayServicesVersionInfo>(GetArenaForAllocation());
    }
    return _impl_.client_version_info_.google_play_services_version_info_;
}
inline ::sync_pb::GooglePlayServicesVersionInfo* DeviceInfoSpecifics::mutable_google_play_services_version_info()
{
    ::sync_pb::GooglePlayServicesVersionInfo* _msg = _internal_mutable_google_play_services_version_info();
    // @@protoc_insertion_point(field_mutable:sync_pb.DeviceInfoSpecifics.google_play_services_version_info)
    return _msg;
}

// optional .sync_pb.SyncEnums.OsType os_type = 19;
inline bool DeviceInfoSpecifics::_internal_has_os_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
    return value;
}
inline bool DeviceInfoSpecifics::has_os_type() const
{
    return _internal_has_os_type();
}
inline void DeviceInfoSpecifics::clear_os_type()
{
    _impl_.os_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::sync_pb::SyncEnums_OsType DeviceInfoSpecifics::_internal_os_type() const
{
    return static_cast<::sync_pb::SyncEnums_OsType>(_impl_.os_type_);
}
inline ::sync_pb::SyncEnums_OsType DeviceInfoSpecifics::os_type() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.os_type)
    return _internal_os_type();
}
inline void DeviceInfoSpecifics::_internal_set_os_type(::sync_pb::SyncEnums_OsType value)
{
    assert(::sync_pb::SyncEnums_OsType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00010000u;
    _impl_.os_type_ = value;
}
inline void DeviceInfoSpecifics::set_os_type(::sync_pb::SyncEnums_OsType value)
{
    _internal_set_os_type(value);
    // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.os_type)
}

// optional .sync_pb.SyncEnums.DeviceFormFactor device_form_factor = 20;
inline bool DeviceInfoSpecifics::_internal_has_device_form_factor() const
{
    bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
    return value;
}
inline bool DeviceInfoSpecifics::has_device_form_factor() const
{
    return _internal_has_device_form_factor();
}
inline void DeviceInfoSpecifics::clear_device_form_factor()
{
    _impl_.device_form_factor_ = 0;
    _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::sync_pb::SyncEnums_DeviceFormFactor DeviceInfoSpecifics::_internal_device_form_factor() const
{
    return static_cast<::sync_pb::SyncEnums_DeviceFormFactor>(_impl_.device_form_factor_);
}
inline ::sync_pb::SyncEnums_DeviceFormFactor DeviceInfoSpecifics::device_form_factor() const
{
    // @@protoc_insertion_point(field_get:sync_pb.DeviceInfoSpecifics.device_form_factor)
    return _internal_device_form_factor();
}
inline void DeviceInfoSpecifics::_internal_set_device_form_factor(::sync_pb::SyncEnums_DeviceFormFactor value)
{
    assert(::sync_pb::SyncEnums_DeviceFormFactor_IsValid(value));
    _impl_._has_bits_[0] |= 0x00020000u;
    _impl_.device_form_factor_ = value;
}
inline void DeviceInfoSpecifics::set_device_form_factor(::sync_pb::SyncEnums_DeviceFormFactor value)
{
    _internal_set_device_form_factor(value);
    // @@protoc_insertion_point(field_set:sync_pb.DeviceInfoSpecifics.device_form_factor)
}

inline bool DeviceInfoSpecifics::has_client_version_info() const
{
    return client_version_info_case() != CLIENT_VERSION_INFO_NOT_SET;
}
inline void DeviceInfoSpecifics::clear_has_client_version_info()
{
    _impl_._oneof_case_[0] = CLIENT_VERSION_INFO_NOT_SET;
}
inline DeviceInfoSpecifics::ClientVersionInfoCase DeviceInfoSpecifics::client_version_info_case() const
{
    return DeviceInfoSpecifics::ClientVersionInfoCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FeatureSpecificFields

// optional bool send_tab_to_self_receiving_enabled = 1;
inline bool FeatureSpecificFields::_internal_has_send_tab_to_self_receiving_enabled() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool FeatureSpecificFields::has_send_tab_to_self_receiving_enabled() const
{
    return _internal_has_send_tab_to_self_receiving_enabled();
}
inline void FeatureSpecificFields::clear_send_tab_to_self_receiving_enabled()
{
    _impl_.send_tab_to_self_receiving_enabled_ = false;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool FeatureSpecificFields::_internal_send_tab_to_self_receiving_enabled() const
{
    return _impl_.send_tab_to_self_receiving_enabled_;
}
inline bool FeatureSpecificFields::send_tab_to_self_receiving_enabled() const
{
    // @@protoc_insertion_point(field_get:sync_pb.FeatureSpecificFields.send_tab_to_self_receiving_enabled)
    return _internal_send_tab_to_self_receiving_enabled();
}
inline void FeatureSpecificFields::_internal_set_send_tab_to_self_receiving_enabled(bool value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.send_tab_to_self_receiving_enabled_ = value;
}
inline void FeatureSpecificFields::set_send_tab_to_self_receiving_enabled(bool value)
{
    _internal_set_send_tab_to_self_receiving_enabled(value);
    // @@protoc_insertion_point(field_set:sync_pb.FeatureSpecificFields.send_tab_to_self_receiving_enabled)
}

// optional .sync_pb.SyncEnums.SendTabReceivingType send_tab_to_self_receiving_type = 2;
inline bool FeatureSpecificFields::_internal_has_send_tab_to_self_receiving_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool FeatureSpecificFields::has_send_tab_to_self_receiving_type() const
{
    return _internal_has_send_tab_to_self_receiving_type();
}
inline void FeatureSpecificFields::clear_send_tab_to_self_receiving_type()
{
    _impl_.send_tab_to_self_receiving_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sync_pb::SyncEnums_SendTabReceivingType FeatureSpecificFields::_internal_send_tab_to_self_receiving_type() const
{
    return static_cast<::sync_pb::SyncEnums_SendTabReceivingType>(_impl_.send_tab_to_self_receiving_type_);
}
inline ::sync_pb::SyncEnums_SendTabReceivingType FeatureSpecificFields::send_tab_to_self_receiving_type() const
{
    // @@protoc_insertion_point(field_get:sync_pb.FeatureSpecificFields.send_tab_to_self_receiving_type)
    return _internal_send_tab_to_self_receiving_type();
}
inline void FeatureSpecificFields::_internal_set_send_tab_to_self_receiving_type(::sync_pb::SyncEnums_SendTabReceivingType value)
{
    assert(::sync_pb::SyncEnums_SendTabReceivingType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.send_tab_to_self_receiving_type_ = value;
}
inline void FeatureSpecificFields::set_send_tab_to_self_receiving_type(::sync_pb::SyncEnums_SendTabReceivingType value)
{
    _internal_set_send_tab_to_self_receiving_type(value);
    // @@protoc_insertion_point(field_set:sync_pb.FeatureSpecificFields.send_tab_to_self_receiving_type)
}

// optional int64 floating_workspace_last_signin_time_windows_epoch_micros = 3;
inline bool FeatureSpecificFields::_internal_has_floating_workspace_last_signin_time_windows_epoch_micros() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool FeatureSpecificFields::has_floating_workspace_last_signin_time_windows_epoch_micros() const
{
    return _internal_has_floating_workspace_last_signin_time_windows_epoch_micros();
}
inline void FeatureSpecificFields::clear_floating_workspace_last_signin_time_windows_epoch_micros()
{
    _impl_.floating_workspace_last_signin_time_windows_epoch_micros_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t FeatureSpecificFields::_internal_floating_workspace_last_signin_time_windows_epoch_micros() const
{
    return _impl_.floating_workspace_last_signin_time_windows_epoch_micros_;
}
inline int64_t FeatureSpecificFields::floating_workspace_last_signin_time_windows_epoch_micros() const
{
    // @@protoc_insertion_point(field_get:sync_pb.FeatureSpecificFields.floating_workspace_last_signin_time_windows_epoch_micros)
    return _internal_floating_workspace_last_signin_time_windows_epoch_micros();
}
inline void FeatureSpecificFields::_internal_set_floating_workspace_last_signin_time_windows_epoch_micros(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.floating_workspace_last_signin_time_windows_epoch_micros_ = value;
}
inline void FeatureSpecificFields::set_floating_workspace_last_signin_time_windows_epoch_micros(int64_t value)
{
    _internal_set_floating_workspace_last_signin_time_windows_epoch_micros(value);
    // @@protoc_insertion_point(field_set:sync_pb.FeatureSpecificFields.floating_workspace_last_signin_time_windows_epoch_micros)
}

// -------------------------------------------------------------------

// SharingSpecificFields

// optional string vapid_fcm_token = 1;
inline bool SharingSpecificFields::_internal_has_vapid_fcm_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SharingSpecificFields::has_vapid_fcm_token() const
{
    return _internal_has_vapid_fcm_token();
}
inline void SharingSpecificFields::clear_vapid_fcm_token()
{
    _impl_.vapid_fcm_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SharingSpecificFields::vapid_fcm_token() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.vapid_fcm_token)
    return _internal_vapid_fcm_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SharingSpecificFields::set_vapid_fcm_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.vapid_fcm_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.vapid_fcm_token)
}
inline std::string* SharingSpecificFields::mutable_vapid_fcm_token()
{
    std::string* _s = _internal_mutable_vapid_fcm_token();
    // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.vapid_fcm_token)
    return _s;
}
inline const std::string& SharingSpecificFields::_internal_vapid_fcm_token() const
{
    return _impl_.vapid_fcm_token_.Get();
}
inline void SharingSpecificFields::_internal_set_vapid_fcm_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.vapid_fcm_token_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_vapid_fcm_token()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.vapid_fcm_token_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_vapid_fcm_token()
{
    // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.vapid_fcm_token)
    if (!_internal_has_vapid_fcm_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.vapid_fcm_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.vapid_fcm_token_.IsDefault()) {
        _impl_.vapid_fcm_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SharingSpecificFields::set_allocated_vapid_fcm_token(std::string* vapid_fcm_token)
{
    if (vapid_fcm_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.vapid_fcm_token_.SetAllocated(vapid_fcm_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.vapid_fcm_token_.IsDefault()) {
        _impl_.vapid_fcm_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.vapid_fcm_token)
}

// optional bytes vapid_p256dh = 2;
inline bool SharingSpecificFields::_internal_has_vapid_p256dh() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool SharingSpecificFields::has_vapid_p256dh() const
{
    return _internal_has_vapid_p256dh();
}
inline void SharingSpecificFields::clear_vapid_p256dh()
{
    _impl_.vapid_p256dh_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SharingSpecificFields::vapid_p256dh() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.vapid_p256dh)
    return _internal_vapid_p256dh();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SharingSpecificFields::set_vapid_p256dh(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.vapid_p256dh_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.vapid_p256dh)
}
inline std::string* SharingSpecificFields::mutable_vapid_p256dh()
{
    std::string* _s = _internal_mutable_vapid_p256dh();
    // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.vapid_p256dh)
    return _s;
}
inline const std::string& SharingSpecificFields::_internal_vapid_p256dh() const
{
    return _impl_.vapid_p256dh_.Get();
}
inline void SharingSpecificFields::_internal_set_vapid_p256dh(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.vapid_p256dh_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_vapid_p256dh()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.vapid_p256dh_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_vapid_p256dh()
{
    // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.vapid_p256dh)
    if (!_internal_has_vapid_p256dh()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.vapid_p256dh_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.vapid_p256dh_.IsDefault()) {
        _impl_.vapid_p256dh_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SharingSpecificFields::set_allocated_vapid_p256dh(std::string* vapid_p256dh)
{
    if (vapid_p256dh != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.vapid_p256dh_.SetAllocated(vapid_p256dh, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.vapid_p256dh_.IsDefault()) {
        _impl_.vapid_p256dh_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.vapid_p256dh)
}

// optional bytes vapid_auth_secret = 3;
inline bool SharingSpecificFields::_internal_has_vapid_auth_secret() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool SharingSpecificFields::has_vapid_auth_secret() const
{
    return _internal_has_vapid_auth_secret();
}
inline void SharingSpecificFields::clear_vapid_auth_secret()
{
    _impl_.vapid_auth_secret_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SharingSpecificFields::vapid_auth_secret() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.vapid_auth_secret)
    return _internal_vapid_auth_secret();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SharingSpecificFields::set_vapid_auth_secret(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.vapid_auth_secret_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.vapid_auth_secret)
}
inline std::string* SharingSpecificFields::mutable_vapid_auth_secret()
{
    std::string* _s = _internal_mutable_vapid_auth_secret();
    // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.vapid_auth_secret)
    return _s;
}
inline const std::string& SharingSpecificFields::_internal_vapid_auth_secret() const
{
    return _impl_.vapid_auth_secret_.Get();
}
inline void SharingSpecificFields::_internal_set_vapid_auth_secret(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.vapid_auth_secret_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_vapid_auth_secret()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.vapid_auth_secret_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_vapid_auth_secret()
{
    // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.vapid_auth_secret)
    if (!_internal_has_vapid_auth_secret()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.vapid_auth_secret_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.vapid_auth_secret_.IsDefault()) {
        _impl_.vapid_auth_secret_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SharingSpecificFields::set_allocated_vapid_auth_secret(std::string* vapid_auth_secret)
{
    if (vapid_auth_secret != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.vapid_auth_secret_.SetAllocated(vapid_auth_secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.vapid_auth_secret_.IsDefault()) {
        _impl_.vapid_auth_secret_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.vapid_auth_secret)
}

// repeated .sync_pb.SharingSpecificFields.EnabledFeatures enabled_features = 4;
inline int SharingSpecificFields::_internal_enabled_features_size() const
{
    return _impl_.enabled_features_.size();
}
inline int SharingSpecificFields::enabled_features_size() const
{
    return _internal_enabled_features_size();
}
inline void SharingSpecificFields::clear_enabled_features()
{
    _impl_.enabled_features_.Clear();
}
inline ::sync_pb::SharingSpecificFields_EnabledFeatures SharingSpecificFields::_internal_enabled_features(int index) const
{
    return static_cast<::sync_pb::SharingSpecificFields_EnabledFeatures>(_impl_.enabled_features_.Get(index));
}
inline ::sync_pb::SharingSpecificFields_EnabledFeatures SharingSpecificFields::enabled_features(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.enabled_features)
    return _internal_enabled_features(index);
}
inline void SharingSpecificFields::set_enabled_features(int index, ::sync_pb::SharingSpecificFields_EnabledFeatures value)
{
    assert(::sync_pb::SharingSpecificFields_EnabledFeatures_IsValid(value));
    _impl_.enabled_features_.Set(index, value);
    // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.enabled_features)
}
inline void SharingSpecificFields::_internal_add_enabled_features(::sync_pb::SharingSpecificFields_EnabledFeatures value)
{
    assert(::sync_pb::SharingSpecificFields_EnabledFeatures_IsValid(value));
    _impl_.enabled_features_.Add(value);
}
inline void SharingSpecificFields::add_enabled_features(::sync_pb::SharingSpecificFields_EnabledFeatures value)
{
    _internal_add_enabled_features(value);
    // @@protoc_insertion_point(field_add:sync_pb.SharingSpecificFields.enabled_features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& SharingSpecificFields::enabled_features() const
{
    // @@protoc_insertion_point(field_list:sync_pb.SharingSpecificFields.enabled_features)
    return _impl_.enabled_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* SharingSpecificFields::_internal_mutable_enabled_features()
{
    return &_impl_.enabled_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* SharingSpecificFields::mutable_enabled_features()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.SharingSpecificFields.enabled_features)
    return _internal_mutable_enabled_features();
}

// optional string sender_id_fcm_token_deprecated = 5 [deprecated = true];
inline bool SharingSpecificFields::_internal_has_sender_id_fcm_token_deprecated() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool SharingSpecificFields::has_sender_id_fcm_token_deprecated() const
{
    return _internal_has_sender_id_fcm_token_deprecated();
}
inline void SharingSpecificFields::clear_sender_id_fcm_token_deprecated()
{
    _impl_.sender_id_fcm_token_deprecated_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SharingSpecificFields::sender_id_fcm_token_deprecated() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.sender_id_fcm_token_deprecated)
    return _internal_sender_id_fcm_token_deprecated();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void SharingSpecificFields::set_sender_id_fcm_token_deprecated(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.sender_id_fcm_token_deprecated_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.sender_id_fcm_token_deprecated)
}
inline std::string* SharingSpecificFields::mutable_sender_id_fcm_token_deprecated()
{
    std::string* _s = _internal_mutable_sender_id_fcm_token_deprecated();
    // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.sender_id_fcm_token_deprecated)
    return _s;
}
inline const std::string& SharingSpecificFields::_internal_sender_id_fcm_token_deprecated() const
{
    return _impl_.sender_id_fcm_token_deprecated_.Get();
}
inline void SharingSpecificFields::_internal_set_sender_id_fcm_token_deprecated(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.sender_id_fcm_token_deprecated_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_sender_id_fcm_token_deprecated()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.sender_id_fcm_token_deprecated_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_sender_id_fcm_token_deprecated()
{
    // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.sender_id_fcm_token_deprecated)
    if (!_internal_has_sender_id_fcm_token_deprecated()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.sender_id_fcm_token_deprecated_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sender_id_fcm_token_deprecated_.IsDefault()) {
        _impl_.sender_id_fcm_token_deprecated_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SharingSpecificFields::set_allocated_sender_id_fcm_token_deprecated(std::string* sender_id_fcm_token_deprecated)
{
    if (sender_id_fcm_token_deprecated != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.sender_id_fcm_token_deprecated_.SetAllocated(sender_id_fcm_token_deprecated, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sender_id_fcm_token_deprecated_.IsDefault()) {
        _impl_.sender_id_fcm_token_deprecated_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.sender_id_fcm_token_deprecated)
}

// optional bytes sender_id_p256dh_deprecated = 6 [deprecated = true];
inline bool SharingSpecificFields::_internal_has_sender_id_p256dh_deprecated() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool SharingSpecificFields::has_sender_id_p256dh_deprecated() const
{
    return _internal_has_sender_id_p256dh_deprecated();
}
inline void SharingSpecificFields::clear_sender_id_p256dh_deprecated()
{
    _impl_.sender_id_p256dh_deprecated_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SharingSpecificFields::sender_id_p256dh_deprecated() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.sender_id_p256dh_deprecated)
    return _internal_sender_id_p256dh_deprecated();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void SharingSpecificFields::set_sender_id_p256dh_deprecated(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.sender_id_p256dh_deprecated_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.sender_id_p256dh_deprecated)
}
inline std::string* SharingSpecificFields::mutable_sender_id_p256dh_deprecated()
{
    std::string* _s = _internal_mutable_sender_id_p256dh_deprecated();
    // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.sender_id_p256dh_deprecated)
    return _s;
}
inline const std::string& SharingSpecificFields::_internal_sender_id_p256dh_deprecated() const
{
    return _impl_.sender_id_p256dh_deprecated_.Get();
}
inline void SharingSpecificFields::_internal_set_sender_id_p256dh_deprecated(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.sender_id_p256dh_deprecated_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_sender_id_p256dh_deprecated()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    return _impl_.sender_id_p256dh_deprecated_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_sender_id_p256dh_deprecated()
{
    // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.sender_id_p256dh_deprecated)
    if (!_internal_has_sender_id_p256dh_deprecated()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000010u;
    auto* p = _impl_.sender_id_p256dh_deprecated_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sender_id_p256dh_deprecated_.IsDefault()) {
        _impl_.sender_id_p256dh_deprecated_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SharingSpecificFields::set_allocated_sender_id_p256dh_deprecated(std::string* sender_id_p256dh_deprecated)
{
    if (sender_id_p256dh_deprecated != nullptr) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.sender_id_p256dh_deprecated_.SetAllocated(sender_id_p256dh_deprecated, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sender_id_p256dh_deprecated_.IsDefault()) {
        _impl_.sender_id_p256dh_deprecated_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.sender_id_p256dh_deprecated)
}

// optional bytes sender_id_auth_secret_deprecated = 7 [deprecated = true];
inline bool SharingSpecificFields::_internal_has_sender_id_auth_secret_deprecated() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool SharingSpecificFields::has_sender_id_auth_secret_deprecated() const
{
    return _internal_has_sender_id_auth_secret_deprecated();
}
inline void SharingSpecificFields::clear_sender_id_auth_secret_deprecated()
{
    _impl_.sender_id_auth_secret_deprecated_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& SharingSpecificFields::sender_id_auth_secret_deprecated() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.sender_id_auth_secret_deprecated)
    return _internal_sender_id_auth_secret_deprecated();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void SharingSpecificFields::set_sender_id_auth_secret_deprecated(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.sender_id_auth_secret_deprecated_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.sender_id_auth_secret_deprecated)
}
inline std::string* SharingSpecificFields::mutable_sender_id_auth_secret_deprecated()
{
    std::string* _s = _internal_mutable_sender_id_auth_secret_deprecated();
    // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.sender_id_auth_secret_deprecated)
    return _s;
}
inline const std::string& SharingSpecificFields::_internal_sender_id_auth_secret_deprecated() const
{
    return _impl_.sender_id_auth_secret_deprecated_.Get();
}
inline void SharingSpecificFields::_internal_set_sender_id_auth_secret_deprecated(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.sender_id_auth_secret_deprecated_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_sender_id_auth_secret_deprecated()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    return _impl_.sender_id_auth_secret_deprecated_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_sender_id_auth_secret_deprecated()
{
    // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.sender_id_auth_secret_deprecated)
    if (!_internal_has_sender_id_auth_secret_deprecated()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000020u;
    auto* p = _impl_.sender_id_auth_secret_deprecated_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sender_id_auth_secret_deprecated_.IsDefault()) {
        _impl_.sender_id_auth_secret_deprecated_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SharingSpecificFields::set_allocated_sender_id_auth_secret_deprecated(std::string* sender_id_auth_secret_deprecated)
{
    if (sender_id_auth_secret_deprecated != nullptr) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.sender_id_auth_secret_deprecated_.SetAllocated(sender_id_auth_secret_deprecated, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sender_id_auth_secret_deprecated_.IsDefault()) {
        _impl_.sender_id_auth_secret_deprecated_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.sender_id_auth_secret_deprecated)
}

// optional string sender_id_fcm_token_v2 = 8;
inline bool SharingSpecificFields::_internal_has_sender_id_fcm_token_v2() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool SharingSpecificFields::has_sender_id_fcm_token_v2() const
{
    return _internal_has_sender_id_fcm_token_v2();
}
inline void SharingSpecificFields::clear_sender_id_fcm_token_v2()
{
    _impl_.sender_id_fcm_token_v2_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& SharingSpecificFields::sender_id_fcm_token_v2() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.sender_id_fcm_token_v2)
    return _internal_sender_id_fcm_token_v2();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SharingSpecificFields::set_sender_id_fcm_token_v2(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.sender_id_fcm_token_v2_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.sender_id_fcm_token_v2)
}
inline std::string* SharingSpecificFields::mutable_sender_id_fcm_token_v2()
{
    std::string* _s = _internal_mutable_sender_id_fcm_token_v2();
    // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.sender_id_fcm_token_v2)
    return _s;
}
inline const std::string& SharingSpecificFields::_internal_sender_id_fcm_token_v2() const
{
    return _impl_.sender_id_fcm_token_v2_.Get();
}
inline void SharingSpecificFields::_internal_set_sender_id_fcm_token_v2(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.sender_id_fcm_token_v2_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_sender_id_fcm_token_v2()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    return _impl_.sender_id_fcm_token_v2_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_sender_id_fcm_token_v2()
{
    // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.sender_id_fcm_token_v2)
    if (!_internal_has_sender_id_fcm_token_v2()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000040u;
    auto* p = _impl_.sender_id_fcm_token_v2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sender_id_fcm_token_v2_.IsDefault()) {
        _impl_.sender_id_fcm_token_v2_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SharingSpecificFields::set_allocated_sender_id_fcm_token_v2(std::string* sender_id_fcm_token_v2)
{
    if (sender_id_fcm_token_v2 != nullptr) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.sender_id_fcm_token_v2_.SetAllocated(sender_id_fcm_token_v2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sender_id_fcm_token_v2_.IsDefault()) {
        _impl_.sender_id_fcm_token_v2_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.sender_id_fcm_token_v2)
}

// optional bytes sender_id_p256dh_v2 = 9;
inline bool SharingSpecificFields::_internal_has_sender_id_p256dh_v2() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool SharingSpecificFields::has_sender_id_p256dh_v2() const
{
    return _internal_has_sender_id_p256dh_v2();
}
inline void SharingSpecificFields::clear_sender_id_p256dh_v2()
{
    _impl_.sender_id_p256dh_v2_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& SharingSpecificFields::sender_id_p256dh_v2() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.sender_id_p256dh_v2)
    return _internal_sender_id_p256dh_v2();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SharingSpecificFields::set_sender_id_p256dh_v2(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.sender_id_p256dh_v2_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.sender_id_p256dh_v2)
}
inline std::string* SharingSpecificFields::mutable_sender_id_p256dh_v2()
{
    std::string* _s = _internal_mutable_sender_id_p256dh_v2();
    // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.sender_id_p256dh_v2)
    return _s;
}
inline const std::string& SharingSpecificFields::_internal_sender_id_p256dh_v2() const
{
    return _impl_.sender_id_p256dh_v2_.Get();
}
inline void SharingSpecificFields::_internal_set_sender_id_p256dh_v2(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.sender_id_p256dh_v2_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_sender_id_p256dh_v2()
{
    _impl_._has_bits_[0] |= 0x00000080u;
    return _impl_.sender_id_p256dh_v2_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_sender_id_p256dh_v2()
{
    // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.sender_id_p256dh_v2)
    if (!_internal_has_sender_id_p256dh_v2()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000080u;
    auto* p = _impl_.sender_id_p256dh_v2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sender_id_p256dh_v2_.IsDefault()) {
        _impl_.sender_id_p256dh_v2_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SharingSpecificFields::set_allocated_sender_id_p256dh_v2(std::string* sender_id_p256dh_v2)
{
    if (sender_id_p256dh_v2 != nullptr) {
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    _impl_.sender_id_p256dh_v2_.SetAllocated(sender_id_p256dh_v2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sender_id_p256dh_v2_.IsDefault()) {
        _impl_.sender_id_p256dh_v2_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.sender_id_p256dh_v2)
}

// optional bytes sender_id_auth_secret_v2 = 10;
inline bool SharingSpecificFields::_internal_has_sender_id_auth_secret_v2() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool SharingSpecificFields::has_sender_id_auth_secret_v2() const
{
    return _internal_has_sender_id_auth_secret_v2();
}
inline void SharingSpecificFields::clear_sender_id_auth_secret_v2()
{
    _impl_.sender_id_auth_secret_v2_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& SharingSpecificFields::sender_id_auth_secret_v2() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.sender_id_auth_secret_v2)
    return _internal_sender_id_auth_secret_v2();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SharingSpecificFields::set_sender_id_auth_secret_v2(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.sender_id_auth_secret_v2_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.sender_id_auth_secret_v2)
}
inline std::string* SharingSpecificFields::mutable_sender_id_auth_secret_v2()
{
    std::string* _s = _internal_mutable_sender_id_auth_secret_v2();
    // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.sender_id_auth_secret_v2)
    return _s;
}
inline const std::string& SharingSpecificFields::_internal_sender_id_auth_secret_v2() const
{
    return _impl_.sender_id_auth_secret_v2_.Get();
}
inline void SharingSpecificFields::_internal_set_sender_id_auth_secret_v2(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.sender_id_auth_secret_v2_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_sender_id_auth_secret_v2()
{
    _impl_._has_bits_[0] |= 0x00000100u;
    return _impl_.sender_id_auth_secret_v2_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_sender_id_auth_secret_v2()
{
    // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.sender_id_auth_secret_v2)
    if (!_internal_has_sender_id_auth_secret_v2()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000100u;
    auto* p = _impl_.sender_id_auth_secret_v2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sender_id_auth_secret_v2_.IsDefault()) {
        _impl_.sender_id_auth_secret_v2_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SharingSpecificFields::set_allocated_sender_id_auth_secret_v2(std::string* sender_id_auth_secret_v2)
{
    if (sender_id_auth_secret_v2 != nullptr) {
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    _impl_.sender_id_auth_secret_v2_.SetAllocated(sender_id_auth_secret_v2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sender_id_auth_secret_v2_.IsDefault()) {
        _impl_.sender_id_auth_secret_v2_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.sender_id_auth_secret_v2)
}

// optional string chime_representative_target_id = 11;
inline bool SharingSpecificFields::_internal_has_chime_representative_target_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool SharingSpecificFields::has_chime_representative_target_id() const
{
    return _internal_has_chime_representative_target_id();
}
inline void SharingSpecificFields::clear_chime_representative_target_id()
{
    _impl_.chime_representative_target_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& SharingSpecificFields::chime_representative_target_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SharingSpecificFields.chime_representative_target_id)
    return _internal_chime_representative_target_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void SharingSpecificFields::set_chime_representative_target_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.chime_representative_target_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SharingSpecificFields.chime_representative_target_id)
}
inline std::string* SharingSpecificFields::mutable_chime_representative_target_id()
{
    std::string* _s = _internal_mutable_chime_representative_target_id();
    // @@protoc_insertion_point(field_mutable:sync_pb.SharingSpecificFields.chime_representative_target_id)
    return _s;
}
inline const std::string& SharingSpecificFields::_internal_chime_representative_target_id() const
{
    return _impl_.chime_representative_target_id_.Get();
}
inline void SharingSpecificFields::_internal_set_chime_representative_target_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.chime_representative_target_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::_internal_mutable_chime_representative_target_id()
{
    _impl_._has_bits_[0] |= 0x00000200u;
    return _impl_.chime_representative_target_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SharingSpecificFields::release_chime_representative_target_id()
{
    // @@protoc_insertion_point(field_release:sync_pb.SharingSpecificFields.chime_representative_target_id)
    if (!_internal_has_chime_representative_target_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000200u;
    auto* p = _impl_.chime_representative_target_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.chime_representative_target_id_.IsDefault()) {
        _impl_.chime_representative_target_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SharingSpecificFields::set_allocated_chime_representative_target_id(std::string* chime_representative_target_id)
{
    if (chime_representative_target_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000200u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000200u;
    }
    _impl_.chime_representative_target_id_.SetAllocated(chime_representative_target_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.chime_representative_target_id_.IsDefault()) {
        _impl_.chime_representative_target_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SharingSpecificFields.chime_representative_target_id)
}

// -------------------------------------------------------------------

// InvalidationSpecificFields

// optional string instance_id_token = 1;
inline bool InvalidationSpecificFields::_internal_has_instance_id_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool InvalidationSpecificFields::has_instance_id_token() const
{
    return _internal_has_instance_id_token();
}
inline void InvalidationSpecificFields::clear_instance_id_token()
{
    _impl_.instance_id_token_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InvalidationSpecificFields::instance_id_token() const
{
    // @@protoc_insertion_point(field_get:sync_pb.InvalidationSpecificFields.instance_id_token)
    return _internal_instance_id_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void InvalidationSpecificFields::set_instance_id_token(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.instance_id_token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.InvalidationSpecificFields.instance_id_token)
}
inline std::string* InvalidationSpecificFields::mutable_instance_id_token()
{
    std::string* _s = _internal_mutable_instance_id_token();
    // @@protoc_insertion_point(field_mutable:sync_pb.InvalidationSpecificFields.instance_id_token)
    return _s;
}
inline const std::string& InvalidationSpecificFields::_internal_instance_id_token() const
{
    return _impl_.instance_id_token_.Get();
}
inline void InvalidationSpecificFields::_internal_set_instance_id_token(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.instance_id_token_.Set(value, GetArenaForAllocation());
}
inline std::string* InvalidationSpecificFields::_internal_mutable_instance_id_token()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.instance_id_token_.Mutable(GetArenaForAllocation());
}
inline std::string* InvalidationSpecificFields::release_instance_id_token()
{
    // @@protoc_insertion_point(field_release:sync_pb.InvalidationSpecificFields.instance_id_token)
    if (!_internal_has_instance_id_token()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.instance_id_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.instance_id_token_.IsDefault()) {
        _impl_.instance_id_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void InvalidationSpecificFields::set_allocated_instance_id_token(std::string* instance_id_token)
{
    if (instance_id_token != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.instance_id_token_.SetAllocated(instance_id_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.instance_id_token_.IsDefault()) {
        _impl_.instance_id_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.InvalidationSpecificFields.instance_id_token)
}

// repeated int32 interested_data_type_ids = 2;
inline int InvalidationSpecificFields::_internal_interested_data_type_ids_size() const
{
    return _impl_.interested_data_type_ids_.size();
}
inline int InvalidationSpecificFields::interested_data_type_ids_size() const
{
    return _internal_interested_data_type_ids_size();
}
inline void InvalidationSpecificFields::clear_interested_data_type_ids()
{
    _impl_.interested_data_type_ids_.Clear();
}
inline int32_t InvalidationSpecificFields::_internal_interested_data_type_ids(int index) const
{
    return _impl_.interested_data_type_ids_.Get(index);
}
inline int32_t InvalidationSpecificFields::interested_data_type_ids(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.InvalidationSpecificFields.interested_data_type_ids)
    return _internal_interested_data_type_ids(index);
}
inline void InvalidationSpecificFields::set_interested_data_type_ids(int index, int32_t value)
{
    _impl_.interested_data_type_ids_.Set(index, value);
    // @@protoc_insertion_point(field_set:sync_pb.InvalidationSpecificFields.interested_data_type_ids)
}
inline void InvalidationSpecificFields::_internal_add_interested_data_type_ids(int32_t value)
{
    _impl_.interested_data_type_ids_.Add(value);
}
inline void InvalidationSpecificFields::add_interested_data_type_ids(int32_t value)
{
    _internal_add_interested_data_type_ids(value);
    // @@protoc_insertion_point(field_add:sync_pb.InvalidationSpecificFields.interested_data_type_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& InvalidationSpecificFields::_internal_interested_data_type_ids() const
{
    return _impl_.interested_data_type_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& InvalidationSpecificFields::interested_data_type_ids() const
{
    // @@protoc_insertion_point(field_list:sync_pb.InvalidationSpecificFields.interested_data_type_ids)
    return _internal_interested_data_type_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* InvalidationSpecificFields::_internal_mutable_interested_data_type_ids()
{
    return &_impl_.interested_data_type_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* InvalidationSpecificFields::mutable_interested_data_type_ids()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.InvalidationSpecificFields.interested_data_type_ids)
    return _internal_mutable_interested_data_type_ids();
}

// -------------------------------------------------------------------

// PhoneAsASecurityKeySpecificFields

// optional uint32 tunnel_server_domain = 1;
inline bool PhoneAsASecurityKeySpecificFields::_internal_has_tunnel_server_domain() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool PhoneAsASecurityKeySpecificFields::has_tunnel_server_domain() const
{
    return _internal_has_tunnel_server_domain();
}
inline void PhoneAsASecurityKeySpecificFields::clear_tunnel_server_domain()
{
    _impl_.tunnel_server_domain_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t PhoneAsASecurityKeySpecificFields::_internal_tunnel_server_domain() const
{
    return _impl_.tunnel_server_domain_;
}
inline uint32_t PhoneAsASecurityKeySpecificFields::tunnel_server_domain() const
{
    // @@protoc_insertion_point(field_get:sync_pb.PhoneAsASecurityKeySpecificFields.tunnel_server_domain)
    return _internal_tunnel_server_domain();
}
inline void PhoneAsASecurityKeySpecificFields::_internal_set_tunnel_server_domain(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.tunnel_server_domain_ = value;
}
inline void PhoneAsASecurityKeySpecificFields::set_tunnel_server_domain(uint32_t value)
{
    _internal_set_tunnel_server_domain(value);
    // @@protoc_insertion_point(field_set:sync_pb.PhoneAsASecurityKeySpecificFields.tunnel_server_domain)
}

// optional bytes contact_id = 2;
inline bool PhoneAsASecurityKeySpecificFields::_internal_has_contact_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool PhoneAsASecurityKeySpecificFields::has_contact_id() const
{
    return _internal_has_contact_id();
}
inline void PhoneAsASecurityKeySpecificFields::clear_contact_id()
{
    _impl_.contact_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PhoneAsASecurityKeySpecificFields::contact_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.PhoneAsASecurityKeySpecificFields.contact_id)
    return _internal_contact_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PhoneAsASecurityKeySpecificFields::set_contact_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.contact_id_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.PhoneAsASecurityKeySpecificFields.contact_id)
}
inline std::string* PhoneAsASecurityKeySpecificFields::mutable_contact_id()
{
    std::string* _s = _internal_mutable_contact_id();
    // @@protoc_insertion_point(field_mutable:sync_pb.PhoneAsASecurityKeySpecificFields.contact_id)
    return _s;
}
inline const std::string& PhoneAsASecurityKeySpecificFields::_internal_contact_id() const
{
    return _impl_.contact_id_.Get();
}
inline void PhoneAsASecurityKeySpecificFields::_internal_set_contact_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.contact_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PhoneAsASecurityKeySpecificFields::_internal_mutable_contact_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.contact_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PhoneAsASecurityKeySpecificFields::release_contact_id()
{
    // @@protoc_insertion_point(field_release:sync_pb.PhoneAsASecurityKeySpecificFields.contact_id)
    if (!_internal_has_contact_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.contact_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.contact_id_.IsDefault()) {
        _impl_.contact_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void PhoneAsASecurityKeySpecificFields::set_allocated_contact_id(std::string* contact_id)
{
    if (contact_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.contact_id_.SetAllocated(contact_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.contact_id_.IsDefault()) {
        _impl_.contact_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.PhoneAsASecurityKeySpecificFields.contact_id)
}

// optional bytes secret = 3;
inline bool PhoneAsASecurityKeySpecificFields::_internal_has_secret() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool PhoneAsASecurityKeySpecificFields::has_secret() const
{
    return _internal_has_secret();
}
inline void PhoneAsASecurityKeySpecificFields::clear_secret()
{
    _impl_.secret_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PhoneAsASecurityKeySpecificFields::secret() const
{
    // @@protoc_insertion_point(field_get:sync_pb.PhoneAsASecurityKeySpecificFields.secret)
    return _internal_secret();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PhoneAsASecurityKeySpecificFields::set_secret(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.secret_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.PhoneAsASecurityKeySpecificFields.secret)
}
inline std::string* PhoneAsASecurityKeySpecificFields::mutable_secret()
{
    std::string* _s = _internal_mutable_secret();
    // @@protoc_insertion_point(field_mutable:sync_pb.PhoneAsASecurityKeySpecificFields.secret)
    return _s;
}
inline const std::string& PhoneAsASecurityKeySpecificFields::_internal_secret() const
{
    return _impl_.secret_.Get();
}
inline void PhoneAsASecurityKeySpecificFields::_internal_set_secret(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.secret_.Set(value, GetArenaForAllocation());
}
inline std::string* PhoneAsASecurityKeySpecificFields::_internal_mutable_secret()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.secret_.Mutable(GetArenaForAllocation());
}
inline std::string* PhoneAsASecurityKeySpecificFields::release_secret()
{
    // @@protoc_insertion_point(field_release:sync_pb.PhoneAsASecurityKeySpecificFields.secret)
    if (!_internal_has_secret()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.secret_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.secret_.IsDefault()) {
        _impl_.secret_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void PhoneAsASecurityKeySpecificFields::set_allocated_secret(std::string* secret)
{
    if (secret != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.secret_.SetAllocated(secret, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.secret_.IsDefault()) {
        _impl_.secret_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.PhoneAsASecurityKeySpecificFields.secret)
}

// optional fixed32 id = 4;
inline bool PhoneAsASecurityKeySpecificFields::_internal_has_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool PhoneAsASecurityKeySpecificFields::has_id() const
{
    return _internal_has_id();
}
inline void PhoneAsASecurityKeySpecificFields::clear_id()
{
    _impl_.id_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t PhoneAsASecurityKeySpecificFields::_internal_id() const
{
    return _impl_.id_;
}
inline uint32_t PhoneAsASecurityKeySpecificFields::id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.PhoneAsASecurityKeySpecificFields.id)
    return _internal_id();
}
inline void PhoneAsASecurityKeySpecificFields::_internal_set_id(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.id_ = value;
}
inline void PhoneAsASecurityKeySpecificFields::set_id(uint32_t value)
{
    _internal_set_id(value);
    // @@protoc_insertion_point(field_set:sync_pb.PhoneAsASecurityKeySpecificFields.id)
}

// optional bytes peer_public_key_x962 = 5;
inline bool PhoneAsASecurityKeySpecificFields::_internal_has_peer_public_key_x962() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool PhoneAsASecurityKeySpecificFields::has_peer_public_key_x962() const
{
    return _internal_has_peer_public_key_x962();
}
inline void PhoneAsASecurityKeySpecificFields::clear_peer_public_key_x962()
{
    _impl_.peer_public_key_x962_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PhoneAsASecurityKeySpecificFields::peer_public_key_x962() const
{
    // @@protoc_insertion_point(field_get:sync_pb.PhoneAsASecurityKeySpecificFields.peer_public_key_x962)
    return _internal_peer_public_key_x962();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void PhoneAsASecurityKeySpecificFields::set_peer_public_key_x962(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.peer_public_key_x962_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.PhoneAsASecurityKeySpecificFields.peer_public_key_x962)
}
inline std::string* PhoneAsASecurityKeySpecificFields::mutable_peer_public_key_x962()
{
    std::string* _s = _internal_mutable_peer_public_key_x962();
    // @@protoc_insertion_point(field_mutable:sync_pb.PhoneAsASecurityKeySpecificFields.peer_public_key_x962)
    return _s;
}
inline const std::string& PhoneAsASecurityKeySpecificFields::_internal_peer_public_key_x962() const
{
    return _impl_.peer_public_key_x962_.Get();
}
inline void PhoneAsASecurityKeySpecificFields::_internal_set_peer_public_key_x962(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.peer_public_key_x962_.Set(value, GetArenaForAllocation());
}
inline std::string* PhoneAsASecurityKeySpecificFields::_internal_mutable_peer_public_key_x962()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.peer_public_key_x962_.Mutable(GetArenaForAllocation());
}
inline std::string* PhoneAsASecurityKeySpecificFields::release_peer_public_key_x962()
{
    // @@protoc_insertion_point(field_release:sync_pb.PhoneAsASecurityKeySpecificFields.peer_public_key_x962)
    if (!_internal_has_peer_public_key_x962()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.peer_public_key_x962_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.peer_public_key_x962_.IsDefault()) {
        _impl_.peer_public_key_x962_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void PhoneAsASecurityKeySpecificFields::set_allocated_peer_public_key_x962(std::string* peer_public_key_x962)
{
    if (peer_public_key_x962 != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.peer_public_key_x962_.SetAllocated(peer_public_key_x962, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.peer_public_key_x962_.IsDefault()) {
        _impl_.peer_public_key_x962_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.PhoneAsASecurityKeySpecificFields.peer_public_key_x962)
}

// optional bytes google_credential_id = 6;
inline bool PhoneAsASecurityKeySpecificFields::_internal_has_google_credential_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool PhoneAsASecurityKeySpecificFields::has_google_credential_id() const
{
    return _internal_has_google_credential_id();
}
inline void PhoneAsASecurityKeySpecificFields::clear_google_credential_id()
{
    _impl_.google_credential_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PhoneAsASecurityKeySpecificFields::google_credential_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.PhoneAsASecurityKeySpecificFields.google_credential_id)
    return _internal_google_credential_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void PhoneAsASecurityKeySpecificFields::set_google_credential_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.google_credential_id_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.PhoneAsASecurityKeySpecificFields.google_credential_id)
}
inline std::string* PhoneAsASecurityKeySpecificFields::mutable_google_credential_id()
{
    std::string* _s = _internal_mutable_google_credential_id();
    // @@protoc_insertion_point(field_mutable:sync_pb.PhoneAsASecurityKeySpecificFields.google_credential_id)
    return _s;
}
inline const std::string& PhoneAsASecurityKeySpecificFields::_internal_google_credential_id() const
{
    return _impl_.google_credential_id_.Get();
}
inline void PhoneAsASecurityKeySpecificFields::_internal_set_google_credential_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.google_credential_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PhoneAsASecurityKeySpecificFields::_internal_mutable_google_credential_id()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.google_credential_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PhoneAsASecurityKeySpecificFields::release_google_credential_id()
{
    // @@protoc_insertion_point(field_release:sync_pb.PhoneAsASecurityKeySpecificFields.google_credential_id)
    if (!_internal_has_google_credential_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.google_credential_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.google_credential_id_.IsDefault()) {
        _impl_.google_credential_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void PhoneAsASecurityKeySpecificFields::set_allocated_google_credential_id(std::string* google_credential_id)
{
    if (google_credential_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.google_credential_id_.SetAllocated(google_credential_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.google_credential_id_.IsDefault()) {
        _impl_.google_credential_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.PhoneAsASecurityKeySpecificFields.google_credential_id)
}

// -------------------------------------------------------------------

// ChromeVersionInfo

// optional string version_number = 1;
inline bool ChromeVersionInfo::_internal_has_version_number() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ChromeVersionInfo::has_version_number() const
{
    return _internal_has_version_number();
}
inline void ChromeVersionInfo::clear_version_number()
{
    _impl_.version_number_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChromeVersionInfo::version_number() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ChromeVersionInfo.version_number)
    return _internal_version_number();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ChromeVersionInfo::set_version_number(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.version_number_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.ChromeVersionInfo.version_number)
}
inline std::string* ChromeVersionInfo::mutable_version_number()
{
    std::string* _s = _internal_mutable_version_number();
    // @@protoc_insertion_point(field_mutable:sync_pb.ChromeVersionInfo.version_number)
    return _s;
}
inline const std::string& ChromeVersionInfo::_internal_version_number() const
{
    return _impl_.version_number_.Get();
}
inline void ChromeVersionInfo::_internal_set_version_number(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.version_number_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromeVersionInfo::_internal_mutable_version_number()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.version_number_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromeVersionInfo::release_version_number()
{
    // @@protoc_insertion_point(field_release:sync_pb.ChromeVersionInfo.version_number)
    if (!_internal_has_version_number()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.version_number_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.version_number_.IsDefault()) {
        _impl_.version_number_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ChromeVersionInfo::set_allocated_version_number(std::string* version_number)
{
    if (version_number != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.version_number_.SetAllocated(version_number, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.version_number_.IsDefault()) {
        _impl_.version_number_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ChromeVersionInfo.version_number)
}

// -------------------------------------------------------------------

// GooglePlayServicesVersionInfo

// optional string apk_version_name = 1;
inline bool GooglePlayServicesVersionInfo::_internal_has_apk_version_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool GooglePlayServicesVersionInfo::has_apk_version_name() const
{
    return _internal_has_apk_version_name();
}
inline void GooglePlayServicesVersionInfo::clear_apk_version_name()
{
    _impl_.apk_version_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GooglePlayServicesVersionInfo::apk_version_name() const
{
    // @@protoc_insertion_point(field_get:sync_pb.GooglePlayServicesVersionInfo.apk_version_name)
    return _internal_apk_version_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void GooglePlayServicesVersionInfo::set_apk_version_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.apk_version_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.GooglePlayServicesVersionInfo.apk_version_name)
}
inline std::string* GooglePlayServicesVersionInfo::mutable_apk_version_name()
{
    std::string* _s = _internal_mutable_apk_version_name();
    // @@protoc_insertion_point(field_mutable:sync_pb.GooglePlayServicesVersionInfo.apk_version_name)
    return _s;
}
inline const std::string& GooglePlayServicesVersionInfo::_internal_apk_version_name() const
{
    return _impl_.apk_version_name_.Get();
}
inline void GooglePlayServicesVersionInfo::_internal_set_apk_version_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.apk_version_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GooglePlayServicesVersionInfo::_internal_mutable_apk_version_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.apk_version_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GooglePlayServicesVersionInfo::release_apk_version_name()
{
    // @@protoc_insertion_point(field_release:sync_pb.GooglePlayServicesVersionInfo.apk_version_name)
    if (!_internal_has_apk_version_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.apk_version_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.apk_version_name_.IsDefault()) {
        _impl_.apk_version_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void GooglePlayServicesVersionInfo::set_allocated_apk_version_name(std::string* apk_version_name)
{
    if (apk_version_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.apk_version_name_.SetAllocated(apk_version_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.apk_version_name_.IsDefault()) {
        _impl_.apk_version_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.GooglePlayServicesVersionInfo.apk_version_name)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace sync_pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::sync_pb::SharingSpecificFields_EnabledFeatures> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fdevice_5finfo_5fspecifics_2eproto
